Project Path: arc_gmh5225_bytecode-viewer_vwrm5iby

Source Tree:

```txt
arc_gmh5225_bytecode-viewer_vwrm5iby
├── BCV Icon.ico
├── BCV Icon.png
├── CONTRIBUTING.md
├── CREDITS.md
├── LICENSE
├── README.md
├── SECURITY.md
├── VERSION
├── install
│   ├── _install BCV.bat
│   ├── _uninstall BCV.bat
│   ├── jar2exe_config.j2e
│   └── launch4j_config.xml
├── libs
│   ├── Krakatau-11.zip
│   ├── README.md
│   ├── enjarify-4.zip
│   ├── eu
│   │   └── bibl
│   │       └── banalysis
│   │           └── byteanalysis
│   │               ├── 1.0bcv
│   │               │   ├── byteanalysis-1.0bcv.jar
│   │               │   ├── byteanalysis-1.0bcv.jar.md5
│   │               │   ├── byteanalysis-1.0bcv.jar.sha1
│   │               │   ├── byteanalysis-1.0bcv.pom
│   │               │   ├── byteanalysis-1.0bcv.pom.md5
│   │               │   └── byteanalysis-1.0bcv.pom.sha1
│   │               ├── maven-metadata.xml
│   │               ├── maven-metadata.xml.md5
│   │               └── maven-metadata.xml.sha1
│   └── org
│       └── jd
│           └── jd-gui
│               ├── 1.6.6bcv
│               │   ├── jd-gui-1.6.6bcv.jar
│               │   ├── jd-gui-1.6.6bcv.jar.md5
│               │   ├── jd-gui-1.6.6bcv.jar.sha1
│               │   ├── jd-gui-1.6.6bcv.pom
│               │   ├── jd-gui-1.6.6bcv.pom.md5
│               │   └── jd-gui-1.6.6bcv.pom.sha1
│               ├── maven-metadata.xml
│               ├── maven-metadata.xml.md5
│               └── maven-metadata.xml.sha1
├── plugins
│   ├── groovy
│   │   ├── ExampleStringDecrypter.gy
│   │   └── Skeleton.gy
│   ├── java
│   │   ├── ExampleStringDecrypter.java
│   │   ├── Skeleton.java
│   │   └── XposedGenerator.java
│   ├── javascript
│   │   ├── ExamplePrintClassesPlugin.js
│   │   ├── ExampleStringDecrypter.js
│   │   └── Skeleton.js
│   ├── python
│   │   └── skeleton.py
│   └── ruby
│       └── Skeleton.rb
├── pom.xml
└── src
    └── main
        ├── java
        │   ├── me
        │   │   └── konloch
        │   │       └── kontainer
        │   │           └── io
        │   │               ├── DiskReader.java
        │   │               ├── DiskWriter.java
        │   │               └── HTTPRequest.java
        │   └── the
        │       └── bytecode
        │           └── club
        │               └── bytecodeviewer
        │                   ├── BytecodeViewer.java
        │                   ├── CommandLineInput.java
        │                   ├── Configuration.java
        │                   ├── Constants.java
        │                   ├── GlobalHotKeys.java
        │                   ├── Settings.java
        │                   ├── SettingsSerializer.java
        │                   ├── api
        │                   │   ├── ASMResourceUtil.java
        │                   │   ├── ASMUtil.java
        │                   │   ├── BCV.java
        │                   │   ├── BytecodeHook.java
        │                   │   ├── ClassNodeLoader.java
        │                   │   ├── ExceptionUI.java
        │                   │   ├── Plugin.java
        │                   │   └── PluginConsole.java
        │                   ├── bootloader
        │                   │   ├── Boot.java
        │                   │   ├── BootState.java
        │                   │   ├── InitialBootScreen.java
        │                   │   ├── InstallFatJar.java
        │                   │   ├── UpdateCheck.java
        │                   │   ├── classtree
        │                   │   │   ├── ClassHelper.java
        │                   │   │   ├── ClassTree.java
        │                   │   │   └── nullpermablehashmap
        │                   │   │       ├── NullCreator.java
        │                   │   │       ├── NullPermeableHashMap.java
        │                   │   │       ├── SetCreator.java
        │                   │   │       └── ValueCreator.java
        │                   │   ├── loader
        │                   │   │   ├── AbstractLoaderFactory.java
        │                   │   │   ├── ClassPathLoader.java
        │                   │   │   ├── ILoader.java
        │                   │   │   ├── LibraryClassLoader.java
        │                   │   │   └── LoaderFactory.java
        │                   │   └── resource
        │                   │       ├── DataContainer.java
        │                   │       ├── external
        │                   │       │   ├── EmptyExternalResource.java
        │                   │       │   ├── ExternalLibrary.java
        │                   │       │   └── ExternalResource.java
        │                   │       └── jar
        │                   │           ├── JarInfo.java
        │                   │           ├── JarResource.java
        │                   │           ├── JarType.java
        │                   │           └── contents
        │                   │               ├── JarContents.java
        │                   │               └── LocateableJarContents.java
        │                   ├── compilers
        │                   │   ├── Compiler.java
        │                   │   ├── InternalCompiler.java
        │                   │   └── impl
        │                   │       ├── JavaCompiler.java
        │                   │       ├── KrakatauAssembler.java
        │                   │       └── SmaliAssembler.java
        │                   ├── decompilers
        │                   │   ├── Decompiler.java
        │                   │   ├── InternalDecompiler.java
        │                   │   ├── bytecode
        │                   │   │   ├── ClassNodeDecompiler.java
        │                   │   │   ├── FieldNodeDecompiler.java
        │                   │   │   ├── InstructionPattern.java
        │                   │   │   ├── InstructionPrinter.java
        │                   │   │   ├── InstructionSearcher.java
        │                   │   │   ├── MethodNodeDecompiler.java
        │                   │   │   ├── PrefixedStringBuilder.java
        │                   │   │   └── TypeAndName.java
        │                   │   ├── impl
        │                   │   │   ├── ASMTextifierDisassembler.java
        │                   │   │   ├── BytecodeDisassembler.java
        │                   │   │   ├── CFRDecompiler.java
        │                   │   │   ├── FernFlowerDecompiler.java
        │                   │   │   ├── JADXDecompiler.java
        │                   │   │   ├── JDGUIDecompiler.java
        │                   │   │   ├── JavapDisassembler.java
        │                   │   │   ├── KrakatauDecompiler.java
        │                   │   │   ├── KrakatauDisassembler.java
        │                   │   │   ├── ProcyonDecompiler.java
        │                   │   │   └── SmaliDisassembler.java
        │                   │   └── jdgui
        │                   │       ├── CommonPreferences.java
        │                   │       ├── DirectoryLoader.java
        │                   │       ├── JDGUIClassFileUtil.java
        │                   │       └── PlainTextPrinter.java
        │                   ├── gui
        │                   │   ├── MainViewerGUI.java
        │                   │   ├── components
        │                   │   │   ├── AboutWindow.java
        │                   │   │   ├── ButtonHoverAnimation.java
        │                   │   │   ├── DecompilerViewComponent.java
        │                   │   │   ├── ExportJar.java
        │                   │   │   ├── ExtendedJOptionPane.java
        │                   │   │   ├── FileChooser.java
        │                   │   │   ├── HTMLPane.java
        │                   │   │   ├── ImageJLabel.java
        │                   │   │   ├── JFrameConsole.java
        │                   │   │   ├── JFrameConsolePrintStream.java
        │                   │   │   ├── JFrameConsoleTabbed.java
        │                   │   │   ├── JMenuItemIcon.java
        │                   │   │   ├── JTextAreaOutputStream.java
        │                   │   │   ├── MaxWidthJLabel.java
        │                   │   │   ├── MethodsRenderer.java
        │                   │   │   ├── MultipleChoiceDialog.java
        │                   │   │   ├── RunOptions.java
        │                   │   │   ├── SearchableJTextArea.java
        │                   │   │   ├── SearchableRSyntaxTextArea.java
        │                   │   │   ├── SettingsDialog.java
        │                   │   │   ├── SystemConsole.java
        │                   │   │   ├── VisibleComponent.java
        │                   │   │   ├── WaitBusyIcon.java
        │                   │   │   └── listeners
        │                   │   │       ├── MouseClickedListener.java
        │                   │   │       ├── PressKeyListener.java
        │                   │   │       └── ReleaseKeyListener.java
        │                   │   ├── contextmenu
        │                   │   │   ├── BuildContextMenuItem.java
        │                   │   │   ├── ContextMenu.java
        │                   │   │   ├── ContextMenuItem.java
        │                   │   │   ├── ContextMenuType.java
        │                   │   │   ├── resourcelist
        │                   │   │   │   ├── Collapse.java
        │                   │   │   │   ├── Delete.java
        │                   │   │   │   ├── Expand.java
        │                   │   │   │   ├── New.java
        │                   │   │   │   ├── Open.java
        │                   │   │   │   ├── QuickEdit.java
        │                   │   │   │   └── QuickOpen.java
        │                   │   │   └── searchbox
        │                   │   │       ├── Open.java
        │                   │   │       ├── QuickEdit.java
        │                   │   │       └── QuickOpen.java
        │                   │   ├── hexviewer
        │                   │   │   ├── BaseSwitchableSpinnerPanel.java
        │                   │   │   ├── BinaryStatusApi.java
        │                   │   │   ├── BinaryStatusPanel.java
        │                   │   │   ├── GoToBinaryPanel.java
        │                   │   │   ├── GoToBinaryPositionMode.java
        │                   │   │   ├── HexViewer.java
        │                   │   │   ├── OkCancelPanel.java
        │                   │   │   ├── StatusCursorPositionFormat.java
        │                   │   │   ├── StatusDocumentSizeFormat.java
        │                   │   │   └── ValuesPanel.java
        │                   │   ├── plugins
        │                   │   │   ├── GraphicalReflectionKit.java
        │                   │   │   ├── MaliciousCodeScannerOptions.java
        │                   │   │   └── ReplaceStringsOptions.java
        │                   │   ├── resourcelist
        │                   │   │   ├── ResourceListIconRenderer.java
        │                   │   │   ├── ResourceListPane.java
        │                   │   │   ├── ResourceTree.java
        │                   │   │   ├── ResourceTreeNode.java
        │                   │   │   └── SearchKeyAdapter.java
        │                   │   ├── resourcesearch
        │                   │   │   ├── PerformSearch.java
        │                   │   │   ├── SearchBoxPane.java
        │                   │   │   ├── SearchRadius.java
        │                   │   │   └── SearchType.java
        │                   │   ├── resourceviewer
        │                   │   │   ├── BytecodeViewPanel.java
        │                   │   │   ├── DecompilerSelectionPane.java
        │                   │   │   ├── TabExitButton.java
        │                   │   │   ├── TabRemovalEvent.java
        │                   │   │   ├── TabbedPane.java
        │                   │   │   ├── Workspace.java
        │                   │   │   ├── WorkspaceRefresh.java
        │                   │   │   ├── WorkspaceRefreshEvent.java
        │                   │   │   └── viewer
        │                   │   │       ├── ClassViewer.java
        │                   │   │       ├── ComponentViewer.java
        │                   │   │       ├── FileViewer.java
        │                   │   │       ├── ResourceViewer.java
        │                   │   │       └── synchronizedscroll
        │                   │   │           └── MethodData.java
        │                   │   ├── theme
        │                   │   │   ├── LAFTheme.java
        │                   │   │   └── RSTATheme.java
        │                   │   └── util
        │                   │       ├── BytecodeViewPanelUpdater.java
        │                   │       ├── DelayTabbedPaneThread.java
        │                   │       └── StringMetricsUtil.java
        │                   ├── malwarescanner
        │                   │   ├── CodeScanner.java
        │                   │   ├── MalwareCodeScanner.java
        │                   │   ├── MalwareScan.java
        │                   │   ├── MalwareScanModule.java
        │                   │   ├── impl
        │                   │   │   ├── AWTRobotScanner.java
        │                   │   │   ├── JavaIOScanner.java
        │                   │   │   ├── JavaNetScanner.java
        │                   │   │   ├── JavaRuntimeScanner.java
        │                   │   │   ├── NullSecurityManagerScanner.java
        │                   │   │   ├── ReflectionScanner.java
        │                   │   │   └── URLScanner.java
        │                   │   └── util
        │                   │       ├── MaliciousCodeOptions.java
        │                   │       └── SearchableString.java
        │                   ├── obfuscators
        │                   │   ├── JavaObfuscator.java
        │                   │   ├── RenameClasses.java
        │                   │   ├── RenameFields.java
        │                   │   ├── RenameMethods.java
        │                   │   ├── mapping
        │                   │   │   ├── HookMap.java
        │                   │   │   ├── RefactorMapper.java
        │                   │   │   ├── Refactorer.java
        │                   │   │   ├── Remapper.java
        │                   │   │   ├── RemappingAnnotationAdapter.java
        │                   │   │   ├── RemappingClassAdapter.java
        │                   │   │   ├── RemappingFieldAdapter.java
        │                   │   │   ├── RemappingMethodAdapter.java
        │                   │   │   ├── RemappingSignatureAdapter.java
        │                   │   │   └── data
        │                   │   │       ├── FieldMappingData.java
        │                   │   │       ├── MappingData.java
        │                   │   │       └── MethodMappingData.java
        │                   │   └── rename
        │                   │       ├── RenameClasses.java
        │                   │       ├── RenameFields.java
        │                   │       └── RenameMethods.java
        │                   ├── plugin
        │                   │   ├── PluginLaunchStrategy.java
        │                   │   ├── PluginManager.java
        │                   │   ├── PluginTemplate.java
        │                   │   ├── PluginWriter.java
        │                   │   ├── preinstalled
        │                   │   │   ├── AllatoriStringDecrypter.java
        │                   │   │   ├── ChangeClassFileVersions.java
        │                   │   │   ├── CodeSequenceDiagram.java
        │                   │   │   ├── EZInjection.java
        │                   │   │   ├── MaliciousCodeScanner.java
        │                   │   │   ├── ReplaceStrings.java
        │                   │   │   ├── ShowAllStrings.java
        │                   │   │   ├── ShowMainMethods.java
        │                   │   │   ├── StackFramesRemover.java
        │                   │   │   ├── ViewAPKAndroidPermissions.java
        │                   │   │   ├── ViewManifest.java
        │                   │   │   ├── ZKMStringDecrypter.java
        │                   │   │   └── ZStringArrayDecrypter.java
        │                   │   └── strategies
        │                   │       ├── CompiledJavaPluginLaunchStrategy.java
        │                   │       ├── GroovyPluginLaunchStrategy.java
        │                   │       ├── JavaPluginLaunchStrategy.java
        │                   │       ├── JavascriptPluginLaunchStrategy.java
        │                   │       ├── PythonPluginLaunchStrategy.java
        │                   │       └── RubyPluginLaunchStrategy.java
        │                   ├── resources
        │                   │   ├── ExternalResources.java
        │                   │   ├── IconResources.java
        │                   │   ├── Resource.java
        │                   │   ├── ResourceContainer.java
        │                   │   ├── ResourceContainerImporter.java
        │                   │   ├── ResourceDecompiling.java
        │                   │   ├── ResourceType.java
        │                   │   ├── exporting
        │                   │   │   ├── Export.java
        │                   │   │   ├── Exporter.java
        │                   │   │   └── impl
        │                   │   │       ├── APKExport.java
        │                   │   │       ├── DexExport.java
        │                   │   │       ├── RunnableJarExporter.java
        │                   │   │       └── ZipExport.java
        │                   │   └── importing
        │                   │       ├── Import.java
        │                   │       ├── ImportResource.java
        │                   │       ├── Importer.java
        │                   │       └── impl
        │                   │           ├── APKResourceImporter.java
        │                   │           ├── ClassResourceImporter.java
        │                   │           ├── DEXResourceImporter.java
        │                   │           ├── DirectoryResourceImporter.java
        │                   │           ├── FileResourceImporter.java
        │                   │           ├── XAPKResourceImporter.java
        │                   │           └── ZipResourceImporter.java
        │                   ├── searching
        │                   │   ├── BackgroundSearchThread.java
        │                   │   ├── EnterKeyEvent.java
        │                   │   ├── LDCSearchTreeNodeResult.java
        │                   │   ├── RegexInsnFinder.java
        │                   │   ├── SearchPanel.java
        │                   │   └── impl
        │                   │       ├── FieldCallSearch.java
        │                   │       ├── LDCSearch.java
        │                   │       ├── MemberWithAnnotationSearch.java
        │                   │       ├── MethodCallSearch.java
        │                   │       └── RegexSearch.java
        │                   ├── translation
        │                   │   ├── Language.java
        │                   │   ├── TranslatedComponentReference.java
        │                   │   ├── TranslatedComponents.java
        │                   │   ├── TranslatedStrings.java
        │                   │   └── components
        │                   │       ├── TranslatedDefaultMutableTreeNode.java
        │                   │       ├── TranslatedJButton.java
        │                   │       ├── TranslatedJCheckBox.java
        │                   │       ├── TranslatedJCheckBoxMenuItem.java
        │                   │       ├── TranslatedJLabel.java
        │                   │       ├── TranslatedJMenu.java
        │                   │       ├── TranslatedJMenuItem.java
        │                   │       ├── TranslatedJRadioButtonMenuItem.java
        │                   │       ├── TranslatedJTextField.java
        │                   │       └── TranslatedVisibleComponent.java
        │                   └── util
        │                       ├── APKTool.java
        │                       ├── BootCheck.java
        │                       ├── ClassFileUtils.java
        │                       ├── Dex2Jar.java
        │                       ├── DialogUtils.java
        │                       ├── EncodeUtils.java
        │                       ├── Enjarify.java
        │                       ├── FileDrop.java
        │                       ├── JRTExtractor.java
        │                       ├── JTextAreaUtils.java
        │                       ├── JarUtils.java
        │                       ├── KeyEventDispatch.java
        │                       ├── LazyNameUtil.java
        │                       ├── MethodParser.java
        │                       ├── MiscUtils.java
        │                       ├── NewlineOutputStream.java
        │                       ├── PingBack.java
        │                       ├── SecurityMan.java
        │                       ├── SeqAndCount.java
        │                       ├── SyntaxLanguage.java
        │                       ├── WindowClosingAdapter.java
        │                       ├── WindowStateChangeAdapter.java
        │                       └── ZipUtils.java
        └── resources
            ├── Krakatau-12.zip
            ├── LICENSES
            │   ├── ASM.txt
            │   ├── BCV.txt
            │   ├── apktool-license.txt
            │   ├── byteanalysis-license.txt
            │   ├── cfr-license.txt
            │   ├── commons-license.txt
            │   ├── dex2jar-license.txt
            │   ├── enjarif-license.txt
            │   ├── fernflower-license.txt
            │   ├── imgscalr-license.txt
            │   ├── janino-license.txt
            │   ├── jd-gui-license.txt
            │   ├── jgraphx-license.txt
            │   ├── krakata-license.txt
            │   ├── procyon-license.txt
            │   ├── rsyntaxtextarea-license.txt
            │   └── smali.txt
            ├── enjarify-4.zip
            ├── gui
            │   ├── android.png
            │   ├── bat.png
            │   ├── c#.png
            │   ├── c++.png
            │   ├── class.png
            │   ├── config.png
            │   ├── decoded.png
            │   ├── file.png
            │   ├── folder.png
            │   ├── image.png
            │   ├── jar.png
            │   ├── java.png
            │   ├── loading.gif
            │   ├── package.png
            │   ├── sh.png
            │   ├── text.png
            │   └── zip.png
            ├── templates
            │   ├── Template_Plugin.java
            │   └── Template_Plugin.js
            ├── the
            │   └── bytecode
            │       └── club
            │           └── bytecodeviewer
            │               └── gui
            │                   └── hexviewer
            │                       └── resources
            │                           └── bined-linewrap.png
            └── translations
                ├── arabic.json
                ├── bengali.json
                ├── bulgarian.json
                ├── croatian.json
                ├── czech.json
                ├── danish.json
                ├── english.json
                ├── estonian.json
                ├── farsi.json
                ├── finnish.json
                ├── french.json
                ├── georgian.json
                ├── german.json
                ├── greek.json
                ├── hausa.json
                ├── hebrew.json
                ├── hindi.json
                ├── html
                │   ├── intro.english.html
                │   ├── intro.german.html
                │   └── intro.mandarin.html
                ├── hungarian.json
                ├── indonesian.json
                ├── italian.json
                ├── japanese.json
                ├── javanese.json
                ├── korean.json
                ├── lativan.json
                ├── lithuanian.json
                ├── malay.json
                ├── mandarin.json
                ├── nederlands.json
                ├── norwegian.json
                ├── polish.json
                ├── portuguese.json
                ├── romanian.json
                ├── russian.json
                ├── serbian.json
                ├── slovak.json
                ├── slovenian.json
                ├── spanish.json
                ├── swahili.json
                ├── swedish.json
                ├── thai.json
                ├── turkish.json
                ├── ukrainian.json
                └── vietnamese.json

```

`CONTRIBUTING.md`:

```md
## Contribution Guide Lines/Coding Conventions
* Packages must start with the.bytecode.club.bytecodeviewer.
* All variables must be at the start of each class.
```

`CREDITS.md`:

```md
## Code from various projects has been used, including but not limited to
* J-RET by WaterWolf
* JHexPane by Sam Koivu
* RSynaxPane by Robert Futrell
* Commons IO by Apache
* ASM by OW2
* FernFlower by Stiver
* Procyon by Mstrobel
* Luyten by DeathMarine
* CFR by Lee Benfield
* CFIDE by Bibl
* Smali by JesusFreke
* Dex2Jar by pxb1988 & Lanchon
* Krakatau by Storyyeller
* JD GUI/JD Core by The Java-Decompiler Team
* Enjarify by Storyyeller
* JADX by Skylot

## Contributors
[Full List Of Contributors](https://github.com/Konloch/bytecode-viewer/graphs/contributors)
* Konloch
* Bibl
* Fluke
* Righteous
* sahitya-pavurala
* priav03
* Afffsdd
* Szperak
* Zooty
* samczsun
* ItzSomebody
* DreamSworK
* HyperSpeeed
* If I missed you, please feel free to contact me @Konloch or konloch@gmail.com

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    Bytecode Viewer - Java & Android Reverse Engineering Suite
    Copyright (C) 2014  Kalen "Konloch" Kinloch - http://bytecodeviewer.com - http://the.bytecode.club

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    Bytecode Viewer(BCV)  Copyright (C) 2014  Kalen "Konloch" Kinloch - http://bytecodeviewer.com - http://the.bytecode.club
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
```

`README.md`:

```md
# Bytecode Viewer

Bytecode Viewer - a lightweight user-friendly Java/Android Bytecode Viewer, Decompiler & More.

#### New Features
* Patched [CVE-2022-21675](https://github.com/Konloch/bytecode-viewer/security/advisories/GHSA-3wq9-j4fc-4wmc) (Make sure to upgrade to v2.11.X)
* Dark mode with multiple themes
* Translated into over 30 languages including: Arabic, German, Japanese, Mandarin, Russian, Spanish
* Plugin Writer - create and edit external plugins from within BCV
* Fixed Java & Bytecode editing/compiling
* Tabbed plugin console
* Right-click menus on the resource and search panels
* Javap disassembler
* XAPK support
* Updated nearly all dependencies (incl. decompilers like CFR, JD-GUI etc.)
* Updated ASM library to version 9.1
* Added support to Java files compiled using JDK > 13
* Migrated to Maven

#### Links
* [BCV Discord](https://discord.gg/aexsYpfMEf)
* [Website](https://bytecodeviewer.com)
* [Source Code](https://github.com/konloch/bytecode-viewer)
* [Bin/Archive](https://github.com/konloch/bytecode-viewer/releases)
* [Java Docs](https://the.bytecode.club/docs/bytecode-viewer/)
* [License (Copyleft)](https://raw.githubusercontent.com/Konloch/bytecode-viewer/master/LICENSE)
* [Credits](https://github.com/Konloch/bytecode-viewer/blob/master/CREDITS.md)
* [Contributing](https://github.com/Konloch/bytecode-viewer/blob/master/CONTRIBUTING.md)
* [Report Bugs](https://github.com/Konloch/bytecode-viewer/issues)
* [Discussion Forum](https://the.bytecode.club/forumdisplay.php?fid=69)

#### Key Features
* Simply drag and drop to decompile and search Java Jars & Android APKs
* File format support for: Class, Jar, XAPK, APK, DEX, WAR, JSP, Image Resources, Text Resources & More
* 6 Built-in Java decompilers: Krakatau, CFR, Procyon, FernFlower, JADX, JD-GUI
* 3 Built-in Bytecode disassemblers, including 2 assemblers: Krakatau and Smali/BakSmali
* APK/DEX Support from Dex2Jar and Enjarify
* Built-in Java Compiler
* Advanced static-search functionality
* Customizable UI
* Plugins + Script Engine Design
* Malicious code scanning API
* Translated Into over 30 Languages Including: Arabic, German, Japanese, Mandarin, Russian, Spanish)
* Export functionality as Runnable Jar, Zip, APK, Decompile All As Zip, Etc.
* And more! Give it a try for yourself!

#### Command Line Input
```
	-help                         Displays the help menu
	-clean                        Deletes the BCV directory
	-english                      Forces English language translations
	-list                         Displays the available decompilers
	-decompiler <decompiler>      Selects the decompiler, procyon by default
	-i <input file>               Selects the input file (Jar, Class, APK, ZIP, DEX all work automatically)
	-o <output file>              Selects the output file (Java or Java-Bytecode)
	-t <target classname>         Must either be the fully qualified classname or "all" to decompile all as zip
	-nowait                       Doesn't wait for the user to read the CLI messages
```

## What is Bytecode Viewer?
Bytecode Viewer (BCV) is an Advanced Lightweight Java/Android Reverse Engineering Suite. Powered by several open source tools BCV is designed to aid in the reversing process.

BCV comes with 6 decompilers, 3 disassemblers, 2 assemblers, 2 APK converters, advanced searching, debugging & more.

It's written completely in Java, and it's open sourced. It's currently being maintained and developed by Konloch.

## Is there a demo?
[![BCV Demo](https://img.youtube.com/vi/I5GT6PoTGOw/0.jpg)](https://www.youtube.com/watch?v=I5GT6PoTGOw)

Please note this demo is from a very old version

## How do I install BCV?
Download the latest version from https://github.com/konloch/bytecode-viewer/releases and run the Bytecode-Viewer-2.10.x.jar.
You may need to execute it via command line ```java -jar Bytecode-Viewer-2.10.x.jar``` (replace the X with the current minor version)

## How can I use BCV?
* Starting with a Jar, Zip, ClassFile or Android file (APK, DEX, XAPK, etc) drag it into BCV. It will start the decoding process automatically.
* From here you can select the decompilers you would like to use by selecting the View Pane>View 1, View 2, View 3, etc.
* The view panes are-used to display up to 3 decompilers side by side, you can also toggle edibility here.
* Select the resource you would like to open by navigating using the resource list, BCV will do its best to display it (Decompiling, Disassembling, etc).
* You can use plugins to help you search along with using the search pane in the left-hand bottom corner.

## How do the plugins work?
There is also a plugin system that will allow you to interact with the loaded classfiles. You could for example write a String deobfuscator, a malicious code searcher, or anything else you can think of.

You can either use one of the pre-written plugins, or write your own. The plugin system supports java and javascript scripting.

Once a plugin is activated, it will execute the plugin with a ClassNode ArrayList of every single class loaded in BCV, this allows the user to handle it completely using ASM.

## Instructions to compile

Just clone this repo and run ``mvn package``. It's that simple!

## Working on the source

Open the Maven project (e.g. in IntelliJ, open the ``pom.xml`` as a project file).

## Java Heap Space Issues (java.lang.OutOfMemoryError)
Start BCV with more RAM, e.g. `java -Xmx3G -jar BCV.jar`

## File Permission Issues (java.io.FileNotFoundException)
Right click on the jar file, go to Properties, and select Unblock under Security at the bottom of the General tab.

## APK File Permission Issues (java.io.FileNotFoundException)
Run BCV as administrator.

#### Are you a Java Reverse Engineer? Do you want to learn?
Join The Bytecode Club Today! - https://the.bytecode.club

```

`SECURITY.md`:

```md
# Security Policy

## Supported Versions

All versions of BCV are actively supported for security patches & updates.

## Reporting a Vulnerability

E-Mail konloch@gmail.com if you find any issues.

```

`VERSION`:

```
2.9.10
```

`install/_install BCV.bat`:

```bat
@echo off
assoc .class=BCV
assoc .apk=BCV
assoc .dex=BCV
ftype BCV="%CD%\BytecodeViewer.exe" "%%1"
echo.
echo.
echo Installed, .class, .apk and .dex will be associated with BytecodeViwer.exe
echo.
echo Note, if you move BytecodeViewer.exe
echo you'll need to re-run this program in the same directory as it.
echo.
echo.
pause
```

`install/_uninstall BCV.bat`:

```bat
@echo off
assoc .class=
assoc .apk=
assoc .dex=
echo.
echo.
echo Uninstalled, .class, .apk and .dex will no longer be associated.
echo.
echo.
pause
```

`install/jar2exe_config.j2e`:

```j2e
"C:\Program Files (x86)\Jar2Exe Wizard\j2ewiz" /jar "H:\Repo\BCV\bytecode-viewer\BytecodeViewer 2.9.5.jar" /o H:\Repo\BCV\bytecode-viewer\BytecodeViewer.32.exe /m the.bytecode.club.bytecodeviewer.BytecodeViewer /type windows /minjre 1.7 /platform windows /checksum /icon "H:\Repo\BCV\bytecode-viewer\BCV Icon.ico, 0" /pv 1,0,0,1 /fv 1,0,0,1 /ve ProductVersion=1.9.0 /ve "ProductName=The Bytecode Club" /ve "LegalCopyright=Copyright (c) 2014 - 2015 Kalen (Konloch) Kinloch" /ve "SpecialBuild=1, 0, 0, 1" /ve FileVersion=1 /ve "FileDescription=Java Reverse Engineering Suite" /ve "LegalTrademarks=Trade marks" /ve "InternalName=1, 0, 0, 1" /ve "CompanyName=The Bytecode Club"
```

`install/launch4j_config.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<launch4jConfig>
  <dontWrapJar>false</dontWrapJar>
  <headerType>gui</headerType>
  <obj>w32api/crt2.o</obj>
  <obj>head/guihead.o</obj>
  <obj>head/head.o</obj>
  <lib>w32api/libmingw32.a</lib>
  <lib>w32api/libgcc.a</lib>
  <lib>w32api/libmsvcrt.a</lib>
  <lib>w32api/libkernel32.a</lib>
  <lib>w32api/libuser32.a</lib>
  <lib>w32api/libadvapi32.a</lib>
  <lib>w32api/libshell32.a</lib>
  <jar>H:\Repo\BCV\bytecode-viewer\BytecodeViewer 2.9.8.jar</jar>
  <outfile>H:\Repo\BCV\bytecode-viewer\BytecodeViewer.exe</outfile>
  <errTitle/>
  <cmdLine/>
  <chdir>.</chdir>
  <priority>normal</priority>
  <downloadUrl>https://java.com/de/download/</downloadUrl>
  <supportUrl/>
  <stayAlive>false</stayAlive>
  <restartOnCrash>false</restartOnCrash>
  <manifest/>
  <icon>H:\Repo\BCV\bytecode-viewer\BCV Icon.ico</icon>
  <jre>
    <path/>
    <bundledJre64Bit>false</bundledJre64Bit>
    <bundledJreAsFallback>false</bundledJreAsFallback>
    <minVersion>1.7.0_00</minVersion>
    <maxVersion/>
    <jdkPreference>preferJre</jdkPreference>
    <runtimeBits>64/32</runtimeBits>
  </jre>
  <versionInfo>
    <fileVersion>0.2.9.7</fileVersion>
    <txtFileVersion>https://the.bytecode.club/</txtFileVersion>
    <fileDescription>Bytecode Viewer</fileDescription>
    <copyright>https://bytecodeviewer.com/</copyright>
    <productVersion>0.2.9.6</productVersion>
    <txtProductVersion>https://the.bytecode.club/</txtProductVersion>
    <productName>Bytecode Viewer</productName>
    <companyName/>
    <internalName>BCV</internalName>
    <originalFilename>Bytecode_Viewer.exe</originalFilename>
  </versionInfo>
</launch4jConfig>

```

`libs/README.md`:

```md
### Welcome! You have reached the `libs` folder!

#### Adding new dependencies

Run the following command (replacing the placeholders first of course!):
```console
mvn deploy:deploy-file -DgroupId=[GROUP-ID] -DartifactId=[ARTIFACT-ID] -Dversion=[VERSION] -Durl=file:./libs -DrepositoryId=local-maven-repo -DupdateReleaseInfo=true -Dfile=[THE-JAR-FILE]
```

#### Updating dependencies

Just do the same procedure as in "Adding new dependencies", but with a new version number!

You can also safely delete the old version of the dependency, as nothing will depend on it anymore.

#### Why the suffix `bcv`?

Some dependencies may have been modified or could be released by their author in the future. To avoid confusion and dependency clashes in the local repository, the suffix is a nice way to ensure, the right dependency is used in every project (`bcv` = `ByteCode Viewer` btw).

#### Modifications

 - `ByteAnalysis`: Compiled from source with the newest dependency versions
 - `APKTool`: Added the `apktool-cli` subproject, compiled without changes from source
 - `JD-GUI`: Removed ASM, RSyntaxTextArea, ANTLR, and TreeLayout

```

`libs/eu/bibl/banalysis/byteanalysis/1.0bcv/byteanalysis-1.0bcv.jar.md5`:

```md5
577771e809d7208659fa9536da1a1f1d
```

`libs/eu/bibl/banalysis/byteanalysis/1.0bcv/byteanalysis-1.0bcv.jar.sha1`:

```sha1
cc4f751caa6c3fbb6d159b5b4fc772fc78d09faa
```

`libs/eu/bibl/banalysis/byteanalysis/1.0bcv/byteanalysis-1.0bcv.pom`:

```pom
<?xml version="1.0" encoding="UTF-8"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>eu.bibl.banalysis</groupId>
  <artifactId>byteanalysis</artifactId>
  <version>1.0bcv</version>
</project>

```

`libs/eu/bibl/banalysis/byteanalysis/1.0bcv/byteanalysis-1.0bcv.pom.md5`:

```md5
24ece026db49446067a87df4147fb22e
```

`libs/eu/bibl/banalysis/byteanalysis/1.0bcv/byteanalysis-1.0bcv.pom.sha1`:

```sha1
91deca562ba5dae7996327e35d9d4ca5d793e4cf
```

`libs/eu/bibl/banalysis/byteanalysis/maven-metadata.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<metadata>
  <groupId>eu.bibl.banalysis</groupId>
  <artifactId>byteanalysis</artifactId>
  <versioning>
    <release>1.0bcv</release>
    <versions>
      <version>1.0bcv</version>
    </versions>
    <lastUpdated>20210622184952</lastUpdated>
  </versioning>
</metadata>

```

`libs/eu/bibl/banalysis/byteanalysis/maven-metadata.xml.md5`:

```md5
06e2d8072d6732e85afce26be23c2a49
```

`libs/eu/bibl/banalysis/byteanalysis/maven-metadata.xml.sha1`:

```sha1
f28f7af3dedb25b5d112a263bf5c6b596010206e
```

`libs/org/jd/jd-gui/1.6.6bcv/jd-gui-1.6.6bcv.jar.md5`:

```md5
27038a07a27a96680c00ce9bc2e7ecf9
```

`libs/org/jd/jd-gui/1.6.6bcv/jd-gui-1.6.6bcv.jar.sha1`:

```sha1
d2e0687046e7e343b1150f23976c718b8f05d017
```

`libs/org/jd/jd-gui/1.6.6bcv/jd-gui-1.6.6bcv.pom`:

```pom
<?xml version="1.0" encoding="UTF-8"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.jd</groupId>
  <artifactId>jd-gui</artifactId>
  <version>1.6.6bcv</version>
</project>

```

`libs/org/jd/jd-gui/1.6.6bcv/jd-gui-1.6.6bcv.pom.md5`:

```md5
746c99600f2e54d10b6edadf901583ae
```

`libs/org/jd/jd-gui/1.6.6bcv/jd-gui-1.6.6bcv.pom.sha1`:

```sha1
a66b8df4397ea3f2985e811de4f1a6b06d2899b6
```

`libs/org/jd/jd-gui/maven-metadata.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<metadata>
  <groupId>org.jd</groupId>
  <artifactId>jd-gui</artifactId>
  <versioning>
    <release>1.6.6bcv</release>
    <versions>
      <version>1.6.6bcv</version>
    </versions>
    <lastUpdated>20210810090109</lastUpdated>
  </versioning>
</metadata>

```

`libs/org/jd/jd-gui/maven-metadata.xml.md5`:

```md5
3bacc3a2d75ec55b4a342685c525a242
```

`libs/org/jd/jd-gui/maven-metadata.xml.sha1`:

```sha1
7ccb5c6496569cac765190873996c27dc28361f0
```

`plugins/groovy/ExampleStringDecrypter.gy`:

```gy
import org.objectweb.asm.tree.ClassNode
import org.objectweb.asm.tree.FieldNode
import the.bytecode.club.bytecodeviewer.api.BCV
import the.bytecode.club.bytecodeviewer.api.Plugin
import the.bytecode.club.bytecodeviewer.api.PluginConsole
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog

import java.lang.reflect.Field

import static the.bytecode.club.bytecodeviewer.Constants.nl

/**
 ** This is an example of a String Decrypter Groovy Plugin for BCV.
 **
 ** @author [Your-Name-Goes-Here]
 **/
class ExampleStringDecrypter extends Plugin {

    @Override
    void execute(List<ClassNode> classNodesList) {
        PluginConsole gui = new PluginConsole("Example String Decrypter Groovy Edition")

        MultipleChoiceDialog dialog = new MultipleChoiceDialog("Bytecode Viewer - WARNING",
                "WARNING: This will load the classes into the JVM and execute the initialize function"
                        + nl + "for each class. IF THE FILE YOU'RE LOADING IS MALICIOUS, DO NOT CONTINUE.",
                new String[]{"Continue", "Cancel"})

        if (dialog.promptChoice() == 0) {
            for (ClassNode cn : classNodesList) {
                BCV.getClassNodeLoader().addClass(cn)

                for (Object o : cn.fields.toArray()) {
                    FieldNode f = (FieldNode) o
                    if (f.name == "z") {// && f.desc.equals("([Ljava/lang/String;)V")) {
                        try {
                            for (Field f2 : BCV.getClassNodeLoader().nodeToClass(cn).getFields()) {
                                String s = f2.get(null)
                                if (s != null && !s.empty)
                                    gui.appendText(cn + ":" + s)
                            }
                        } catch (Exception | StackOverflowError ignored) {
                        }
                    }
                }

            }
            gui.setVisible(true)
        }
    }

}

```

`plugins/groovy/Skeleton.gy`:

```gy
import org.objectweb.asm.tree.ClassNode
import the.bytecode.club.bytecodeviewer.api.*

/**
 ** This is a skeleton template for BCV's Groovy Plugin System
 **
 ** @author [Your Name Goes Here]
 **/

class Skeleton extends Plugin {

	@Override
	void execute(List<ClassNode> classNodesList) {
		PluginConsole gui = new PluginConsole("Skeleton Title")
		gui.setVisible(true)
		gui.appendText("executed skeleton example")
	}
}
```

`plugins/java/ExampleStringDecrypter.java`:

```java
import java.lang.reflect.Field;
import java.util.List;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import the.bytecode.club.bytecodeviewer.api.*;
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/**
 ** This is an example of a String Decrypter Java Plugin for BCV.
 **
 ** @author [Your-Name-Goes-Here]
 **/

public class ExampleStringDecrypter extends Plugin {

    @Override
    public void execute(List<ClassNode> classNodesList) {
        PluginConsole gui = new PluginConsole("Example String Decrypter Java Edition");

        MultipleChoiceDialog dialog = new MultipleChoiceDialog("Bytecode Viewer - WARNING",
                "WARNING: This will load the classes into the JVM and execute the initialize function"
                        + nl + "for each class. IF THE FILE YOU'RE LOADING IS MALICIOUS, DO NOT CONTINUE.",
                new String[]{"Continue", "Cancel"});

        if (dialog.promptChoice() == 0) {
            boolean needsWarning = false;
            
            for (ClassNode cn : classNodesList) {
                try {
                    //load the class node into the classloader
                    BCV.getClassNodeLoader().addClass(cn);
    
                    for (Object o : cn.fields.toArray()) {
                        FieldNode f = (FieldNode) o;
        
                        //if the class contains the field z, get the class object from the class node
                        //then print out the value of the fields inside the class
                        //if the strings get decrypted on init, this allows you to dump the current values
                        
                        if (f.name.equals("z")) {
                            try {
                                for (Field f2 : BCV.getClassNodeLoader().nodeToClass(cn).getFields()) {
                                    String s = (String) f2.get(null);
                                    if (s != null && !s.isEmpty())
                                        gui.appendText(cn + ":" + s);
                                }
                            } catch (Exception ignored) {
                            }
                        }
                    }
                } catch (Exception e) {
                    gui.appendText("Failed loading class " + cn.name);
                    e.printStackTrace();
                    needsWarning = true;
                }
            }
            
            if (needsWarning) {
                BytecodeViewer.showMessage("Some classes failed to decrypt, if you'd like to decrypt all of them\n"
                        + "makes sure you include ALL the libraries it requires.");
            }

            gui.setVisible(true);
        }
    }
}

```

`plugins/java/Skeleton.java`:

```java
import java.util.List;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.api.*;

/**
 ** This is a skeleton template for BCV's Java Plugin System
 **
 ** @author [Your Name Goes Here]
 **/

public class Skeleton extends Plugin {

    @Override
    public void execute(List<ClassNode> classNodesList) {
        PluginConsole gui = new PluginConsole("Skeleton Title");
        gui.setVisible(true);
        gui.appendText("executed skeleton example");
    }
}
```

`plugins/java/XposedGenerator.java`:

```java
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.Box;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.*;
import the.bytecode.club.bytecodeviewer.api.*;
import the.bytecode.club.bytecodeviewer.decompilers.impl.FernFlowerDecompiler;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ResourceViewer;

/**
 ** This is an Xposed Generator Plugin, used to aid Reverse-Engineering.
 **
 ** @author jowasp
 **/

public class XposedGenerator extends Plugin {
    
    private static final List<String> methodsNames = new ArrayList<>();
    private static final List<String> cleanMethodsNames = new ArrayList<>();
    private static String foundPckg;

    public XposedGenerator() {
    }

    @Override
    public void execute(List<ClassNode> classNodeList) {
        //Get actual file class content
        ResourceViewer viewer = BytecodeViewer.getActiveResource();

        if (viewer == null) {
            BytecodeViewer.showMessage("Open A Class First");
            return;
        }

        String className = viewer.getName();
        ClassNode classnode = BytecodeViewer.getCurrentlyOpenedClassNode();

        //Call XposedGenerator class
        ParseChosenFileContent(className, classnode);
    }

    public static void ParseChosenFileContent(String classname, ClassNode classNode) {
        try {
            //Parse content - Extract methods after APK /JAR has been extracted
            byte[] cont = ASMUtil.nodeToBytes(classNode);

            //Use one of the decompilers
            //TODO:Allow users to select other decompilers?
            FernFlowerDecompiler decompilefern = new FernFlowerDecompiler();

            //Decompile using Fern
            String decomp = decompilefern.decompileClassNode(classNode, cont);
            String[] xposedTemplateTypes = {"Empty", "Parameters", "Helper"};
            @SuppressWarnings({"unchecked", "rawtypes"})
            JComboBox xposedTemplateList = new JComboBox(xposedTemplateTypes);
            //Set results of parsed methods into a list
            List<String> methodsExtracted = ProcessContentExtractedClass(decomp);
            String packgExtracted = ProcessContentExtractedPackage(decomp);

            //Get a clean list
            List<String> cleanMethods;
            //clear list
            cleanMethods = ProcessCleanMethodsAll(methodsExtracted);
            if (!cleanMethods.isEmpty()) {
                JComboBox<String> cb = new JComboBox<>(cleanMethods.toArray(new String[0]));

                //Add Panel elements
                //Start Panel
                JPanel myPanel = new JPanel();
                myPanel.add(Box.createHorizontalStrut(15));
                myPanel.add(xposedTemplateList);
                myPanel.add(cb);

                //output methods to pane box
                int result = JOptionPane.showConfirmDialog(null, myPanel,
                        "Choose Template and Method for Xposed Module", JOptionPane.OK_CANCEL_OPTION);

                if (result == JOptionPane.OK_OPTION) {
                    //Read Chosen Class
                    Object cbItem = cb.getSelectedItem();
                    Object xPosedItem = xposedTemplateList.getSelectedItem();
                    System.out.println("SELECTED CLASS is" + cbItem);
                    if (cbItem != null && xPosedItem != null) {
                        String selectedClass = cbItem.toString();
                        String selectedXposedTemplate = xPosedItem.toString();

                        //WriteXposed Class with extracted data
                        try {
                            WriteXposedModule(selectedClass, packgExtracted, classname, selectedXposedTemplate);
                        } catch (IllegalArgumentException e) {
                            e.printStackTrace();
                            JOptionPane.showMessageDialog(null, "Error" + e);
                        }
                    }
                }
            } else {
                JOptionPane.showMessageDialog(null, "Class Not Suitable");
            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, "Error" + e);
        }

    }

    public static void WriteXposedModule(String functionToHook, String packageName, String classToHook,
                                         String template) {
        if (template != null && !template.equals("Empty")) {
            try {
                
                //TODO: Prompt save dialog
                File file = new File("./XposedClassTest.java");

                // if file doesn't exist, then create it
                if (!file.exists())
                    file.createNewFile();
                
                //Extract the package name only
                String packageNameOnly = packageName.substring(8, packageName.length() - 2).trim();
                String classToHookNameOnly = classToHook;
                if (classToHookNameOnly.endsWith(".class"))
                    classToHookNameOnly = classToHook.substring(0, classToHookNameOnly.length() - 6);

                String[] classClean = classToHookNameOnly.split("/");
                String[] functionSplitValues = functionToHook.split("\\s+");
                
                //select
                String onlyClass = classClean[classClean.length - 1];

                String onlyFunction = CleanUpFunction(functionSplitValues);

                //Write Xposed Class
                String XposedClassText = "package androidpentesting.com.xposedmodule;" + "\r\n" +
                                "import de.robv.android.xposed.IXposedHookLoadPackage;" + "\r\n" +
                                "\r\n" +
                                "import de.robv.android.xposed.XC_MethodHook;" + "\r\n" +
                                "import de.robv.android.xposed.XposedBridge;" + "\r\n" +
                                "import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;" + "\r\n" +
                                "import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;" + "\r\n" +
                                "\r\n" +
                                "public class XposedClassTest implements IXposedHookLoadPackage {" + "\r\n" + "\r\n" +
                                "   public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {" + "\r\n" + "\r\n" +
                                "		String classToHook = " + "\"" + packageNameOnly + "." + onlyClass + "\";" +
                                "\r\n" +
                                "		String functionToHook = " + "\"" + onlyFunction + "\";" + "\r\n" +
                                "		if (lpparam.packageName.equals(" + "\"" + packageNameOnly + "\"" + ")){" + "\r"
                                + "\n" +
                                "			XposedBridge.log(" + "\" Loaded app: \" " + " + lpparam.packageName);" +
                                "\r\n" + "\r\n" +
                                "			findAndHookMethod(" + "\"" + onlyClass + "\"" + ", lpparam.classLoader, " + " \"" + onlyFunction + "\"" + ", int.class," + "\r\n" +
                                "			new XC_MethodHook() {" + "\r\n" +
                                "			    @Override" + "\r\n" +
                                "		        protected void beforeHookedMethod(MethodHookParam param) throws "
                                + "Throwable {" + "\r\n" +
                                "		            //TO BE FILLED BY ANALYST" + "\r\n" +
                                "			    }" + "\r\n" +
                                "		    });" + "\r\n" +
                                "	    }" + "\r\n" +
                                "   }" + "\r\n" +
                                "}" + "\r\n";
                FileWriter fw = new FileWriter(file.getAbsoluteFile());
                BufferedWriter bw = new BufferedWriter(fw);
                bw.write(XposedClassText);
                bw.write("\r\n");
                bw.close();

                JOptionPane.showMessageDialog(null, "Xposed Module Generated");
            } catch (IOException e) {
                JOptionPane.showMessageDialog(null, "Error" + e);
                e.printStackTrace();
            }
        } else {
            JOptionPane.showMessageDialog(null, "Empty Template Chosen, Did Not Generate");
        }
    }

    private static List<String> ProcessContentExtractedClass(String contentFile) {
        Scanner scanner = null;
        try {
            scanner = new Scanner(contentFile);
            //@TODO : Improve patterns to match other excepts 'public'
            
            String regexclass = "public";
            Pattern pattern = Pattern.compile(regexclass, Pattern.CASE_INSENSITIVE);
            
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                
                // process the line
                Matcher matcher = pattern.matcher(line);
                while (matcher.find()) {
                    if (matcher.group() != null) {
                        System.out.println("find() found the pattern \"" + quote(line.trim()));
                        System.out.println("Function: " + CleanUpFunction(line.trim().split("\\s+")));
                        methodsNames.add(quote(line.trim()));
                    } else {
                        methodsNames.add("No methods found");
                    }
                }
            }

            if (methodsNames.isEmpty()) {
                methodsNames.add("No methods found");
            } else {
                return methodsNames;
            }
            return methodsNames;
        } finally {
            if (scanner != null)
                scanner.close();
        }
    }

    private static List<String> ProcessCleanMethodsAll(List<String> rawMethods) {
        for (String m : rawMethods) {
            //Exclude class declaration
            //TODO:add a list containing all possible types
            if (!m.contains("extends") && (!m.contains("implements") && (m.contains("(")))) {
                cleanMethodsNames.add(m);
            }
        }
        
        return cleanMethodsNames;
    }

    private static String CleanUpFunction(String[] rawFunction) {
        String onlyFunc = "functiondummy";
        for (String m : rawFunction) {
            if (m.contains("(")) {
                String[] split = m.split("\\(")[0].split(" ");
                return split[split.length - 1];
            }
        }

        return onlyFunc;
    }

    private static String ProcessContentExtractedPackage(String contentFile) {
        Scanner scanner = null;
        try {
            scanner = new Scanner(contentFile);
            String regexPkg = "package";
            Pattern patternPkg = Pattern.compile(regexPkg, Pattern.CASE_INSENSITIVE);
            String line = scanner.nextLine();
            
            // process the line
            Matcher matcher = patternPkg.matcher(line);
            while (matcher.find()) {
                if (matcher.group() != null) {
                    System.out.println("find() found the pattern \"" + quote(line.trim()));
                    foundPckg = quote(line.trim());
                } else {
                    foundPckg = "";
                }
            }
            
            try
            {
                if (foundPckg == null || foundPckg.isEmpty())
                    foundPckg = "No Package Found";

            } catch (NullPointerException e) {
                JOptionPane.showMessageDialog(null,
                        "Error - no package was found in the selected class: " + e);
            } finally {
                scanner.close();
            }
        } catch (IllegalArgumentException e) {
            JOptionPane.showMessageDialog(null, "Error" + e);
            if (scanner != null)
                scanner.close();
        } finally {
            if (scanner != null)
                scanner.close();
        }
        
        return foundPckg;
    }

    private static String quote(String aText) {
        String QUOTE = "'";
        return QUOTE + aText + QUOTE;
    }
}

```

`plugins/javascript/ExamplePrintClassesPlugin.js`:

```js

/**
 ** An example BCV Javascript Plugin.
 ** This is used to display all of loaded classnodes that have been imported into BCV.
 **
 ** @author [Your-Name-Goes-Here]
 **/

var PluginConsole = Java.type("the.bytecode.club.bytecodeviewer.api.PluginConsole");

var gui = new PluginConsole("Example Plugin Print Loaded Classes Javascript Edition");

function execute(classNodeList) {
    for (index = 0; index < classNodeList.length; index++) {
        var cn = classNodeList[index];
        gui.appendText("Resource: " + cn.name + ".class");
    }

    gui.setVisible(true);
}
```

`plugins/javascript/ExampleStringDecrypter.js`:

```js

/**
 ** This is an example of a String Decrypter Javascript Plugin for BCV.
 **
 ** @author [Your-Name-Goes-Here]
 **/

var PluginConsole = Java.type("the.bytecode.club.bytecodeviewer.api.PluginConsole");
var MultipleChoiceDialog = Java.type("the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog")
var BytecodeViewer = Java.type("the.bytecode.club.bytecodeviewer.api.BCV")

var dialog = new MultipleChoiceDialog("Bytecode Viewer - WARNING",
    "WARNING: This will load the classes into the JVM and execute the initialize function"
    + "\nfor each class. IF THE FILE YOU'RE LOADING IS MALICIOUS, DO NOT CONTINUE.",
    ["Continue", "Cancel"]);
var gui;

function execute(classNodeList) {
    gui = new PluginConsole("Example String Decrypter Javascript Edition");

    if (dialog.promptChoice() == 0) {
        var needsWarning = false;

        for (cnIndex = 0; cnIndex < classNodeList.length; cnIndex++) {
            try {
                var cn = classNodeList[cnIndex];

                //load the class node into the classloader
                BytecodeViewer.getClassNodeLoader().addClass(cn);

                var fields = cn.fields.toArray();
                for (fieldIndex = 0; fieldIndex < fields.length; fieldIndex++) {
                    var field = fields[fieldIndex];

                    //if the class contains the field z, get the class object from the class node
                    //then print out the value of the fields inside the class
                    //if the strings get decrypted on init, this allows you to dump the current values

                    if (field.name.equals("z")) {
                        try {
                            var loadedClass = BytecodeViewer.getClassNodeLoader().nodeToClass(cn);
                            var reflectedFields = loadedClass.getFields();

                            for (reflectedFieldIndex = 0; reflectedFieldIndex < reflectedFields.length; reflectedFieldIndex++) {
                                var reflectedField = reflectedFields[fieldIndex];
                                var s = reflectedField.get(null);

                                if (s != null && !s.empty())
                                    gui.appendText(cn + "->" + s);
                            }
                        } catch (ignored) {
                        }
                    }
                }
            } catch (e) {
                gui.appendText("Failed loading class " + cn.name);
                e.printStackTrace();
                needsWarning = true;
            }
        }

        if (needsWarning) {
            BytecodeViewer.showMessage("Some classes failed to decrypt, if you'd like to decrypt all of them\n"
                + "makes sure you include ALL the libraries it requires.");
        }

        gui.setVisible(true);
    }
}

```

`plugins/javascript/Skeleton.js`:

```js

/**
 ** This is a skeleton template for BCV's Javascript Plugin System
 **
 ** @author [Your Name Goes Here]
 **/

function execute(classNodeList) {
    var PluginConsole = Java.type("the.bytecode.club.bytecodeviewer.api.PluginConsole");
    var gui = new PluginConsole("Skeleton Title");
    gui.setVisible(true);
    gui.appendText("executed skeleton example");
}
```

`plugins/python/skeleton.py`:

```py
from the.bytecode.club.bytecodeviewer.api import Plugin
from the.bytecode.club.bytecodeviewer.api import PluginConsole
from java.lang import System
from java.lang import Boolean
from java.util import ArrayList
from org.objectweb.asm.tree import ClassNode

#
# This is a skeleton template for BCV's Ruby Plugin System
#
# @author [Your Name Goes Here]
#

class skeleton(Plugin):
	def execute(classNodeList, notUsed): #for some reason it requires a second arg
		gui = PluginConsole("Skeleton Title")
		gui.setVisible(Boolean.TRUE)
		gui.appendText("executed skeleton example")
```

`plugins/ruby/Skeleton.rb`:

```rb
require 'java'

java_import 'the.bytecode.club.bytecodeviewer.api.Plugin'
java_import 'the.bytecode.club.bytecodeviewer.api.PluginConsole'
java_import 'java.lang.System'
java_import 'java.util.ArrayList'
java_import 'org.objectweb.asm.tree.ClassNode'

#
# This is a skeleton template for BCV's Ruby Plugin System
#
# @author [Your Name Goes Here]
#

class Skeleton < Plugin
  def execute(classNodeList)
    gui = PluginConsole.new "Skeleton Title"
    gui.setVisible(true)
    gui.appendText("executed skeleton example")
  end
end
```

`pom.xml`:

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>

    <groupId>the.bytecode.club</groupId>
    <artifactId>Bytecode-Viewer</artifactId>
    <version>2.11.1</version>

    <properties>
        <!-- Project settings -->
        <java.version>1.8</java.version>
        <maven.compiler.target>${java.version}</maven.compiler.target>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

        <!-- Dependency versions -->
        <annotations.version>23.0.0</annotations.version>
        <antlr4.version>4.9.3</antlr4.version>
        <apktool.version>2.6.1</apktool.version>
        <asm.version>9.2</asm.version>
        <bined.version>0.2.0</bined.version>
        <byteanalysis.version>1.0bcv</byteanalysis.version>
        <cfr.version>0.152</cfr.version>
        <cloning.version>1.9.12</cloning.version>
        <commons-cli.version>1.5.0</commons-cli.version>
        <commons-codec.version>1.15</commons-codec.version>
        <commons-compiler.version>3.1.6</commons-compiler.version>
        <commons-compress.version>1.21</commons-compress.version>
        <commons-io.version>2.11.0</commons-io.version>
        <commons-lang3.version>3.12.0</commons-lang3.version>
        <commons-text.version>1.9</commons-text.version>
        <darklaf.version>2.7.3</darklaf.version>
        <darklaf-extensions-rsta.version>0.3.4</darklaf-extensions-rsta.version>
        <decompiler-fernflower.version>5.2.1.Final</decompiler-fernflower.version>
        <dex2jar.version>v49</dex2jar.version>
        <fernflower.version>4281855</fernflower.version>
        <gson.version>2.9.0</gson.version>
        <guava.version>31.1-jre</guava.version>
        <imgscalr-lib.version>4.2</imgscalr-lib.version>
        <jadx.version>1.3.4</jadx.version>
        <janino.version>3.1.6</janino.version>
        <jd-gui.version>1.6.6bcv</jd-gui.version>
        <jgraphx.version>3.4.1.3</jgraphx.version>
        <js.version>21.2.0</js.version>
        <objenesis.version>3.2</objenesis.version>
        <paged-data.version>0.2.0</paged-data.version>
        <procyon.version>0.6.0</procyon.version>
        <rsyntaxtextarea.version>3.2.0</rsyntaxtextarea.version>
        <semantic-version.version>2.1.1</semantic-version.version>
        <slf4j.version>1.7.36</slf4j.version>
        <smali.version>2.5.2</smali.version>
        <snakeyaml.version>1.30</snakeyaml.version>
        <treelayout.version>1.0.3</treelayout.version>
        <webp-imageio.version>0.2.2</webp-imageio.version>
        <xpp3.version>1.1.4c</xpp3.version>
    </properties>

    <repositories>
        <repository>
            <id>google</id>
            <url>https://maven.google.com/</url>
        </repository>
        <repository>
            <id>local-maven-repo</id>
            <url>file:///${project.basedir}/libs</url>
        </repository>
        <repository>
            <id>jitpack.io</id>
            <url>https://jitpack.io</url>
        </repository>
    </repositories>

    <dependencies>
        <dependency>
            <groupId>org.jetbrains</groupId>
            <artifactId>annotations</artifactId>
            <version>${annotations.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apktool</groupId>
            <artifactId>apktool-cli</artifactId>
            <version>${apktool.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apktool</groupId>
            <artifactId>apktool-lib</artifactId>
            <version>${apktool.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.yaml</groupId>
                    <artifactId>snakeyaml</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm-analysis</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm-commons</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm-tree</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.ow2.asm</groupId>
            <artifactId>asm-util</artifactId>
            <version>${asm.version}</version>
        </dependency>
        <dependency>
            <groupId>org.exbin.bined</groupId>
            <artifactId>bined-core</artifactId>
            <version>${bined.version}</version>
        </dependency>
        <dependency>
            <groupId>org.exbin.bined</groupId>
            <artifactId>bined-swing</artifactId>
            <version>${bined.version}</version>
        </dependency>
        <dependency>
            <groupId>org.exbin.bined</groupId>
            <artifactId>bined-highlight-swing</artifactId>
            <version>${bined.version}</version>
        </dependency>
        <dependency>
            <groupId>org.benf</groupId>
            <artifactId>cfr</artifactId>
            <version>${cfr.version}</version>
        </dependency>
        <dependency>
            <groupId>uk.com.robust-it</groupId>
            <artifactId>cloning</artifactId>
            <version>${cloning.version}</version>
        </dependency>
        <dependency>
            <groupId>commons-cli</groupId>
            <artifactId>commons-cli</artifactId>
            <version>${commons-cli.version}</version>
        </dependency>
        <dependency>
            <groupId>commons-codec</groupId>
            <artifactId>commons-codec</artifactId>
            <version>${commons-codec.version}</version>
        </dependency>
        <dependency>
            <groupId>org.codehaus.janino</groupId>
            <artifactId>commons-compiler</artifactId>
            <version>${commons-compiler.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-compress</artifactId>
            <version>${commons-compress.version}</version>
        </dependency>
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>${commons-io.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-text</artifactId>
            <version>${commons-text.version}</version>
        </dependency>
        <dependency>
            <groupId>org.jboss.windup.decompiler</groupId>
            <artifactId>decompiler-fernflower</artifactId>
            <version>${decompiler-fernflower.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>org.jboss.windup.decompiler.fernflower</groupId>
                    <artifactId>windup-fernflower</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>com.github.ThexXTURBOXx</groupId>
            <artifactId>fernflower</artifactId>
            <version>${fernflower.version}</version>
        </dependency>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>${guava.version}</version>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>${gson.version}</version>
        </dependency>
        <dependency>
            <groupId>org.imgscalr</groupId>
            <artifactId>imgscalr-lib</artifactId>
            <version>${imgscalr-lib.version}</version>
        </dependency>
        <dependency>
            <groupId>org.codehaus.janino</groupId>
            <artifactId>janino</artifactId>
            <version>${janino.version}</version>
        </dependency>
        <dependency>
            <groupId>org.jd</groupId>
            <artifactId>jd-gui</artifactId>
            <version>${jd-gui.version}</version>
        </dependency>
        <dependency>
            <groupId>eu.bibl.banalysis</groupId>
            <artifactId>byteanalysis</artifactId>
            <version>${byteanalysis.version}</version>
        </dependency>
        <dependency>
            <groupId>org.tinyjee.jgraphx</groupId>
            <artifactId>jgraphx</artifactId>
            <version>${jgraphx.version}</version>
        </dependency>
        <dependency>
            <groupId>org.objenesis</groupId>
            <artifactId>objenesis</artifactId>
            <version>${objenesis.version}</version>
        </dependency>
        <dependency>
            <groupId>org.exbin.auxiliary</groupId>
            <artifactId>paged_data</artifactId>
            <version>${paged-data.version}</version>
        </dependency>
        <dependency>
            <groupId>org.bitbucket.mstrobel</groupId>
            <artifactId>procyon-core</artifactId>
            <version>${procyon.version}</version>
        </dependency>
        <dependency>
            <groupId>org.bitbucket.mstrobel</groupId>
            <artifactId>procyon-expressions</artifactId>
            <version>${procyon.version}</version>
        </dependency>
        <dependency>
            <groupId>org.bitbucket.mstrobel</groupId>
            <artifactId>procyon-reflection</artifactId>
            <version>${procyon.version}</version>
        </dependency>
        <dependency>
            <groupId>org.bitbucket.mstrobel</groupId>
            <artifactId>procyon-compilertools</artifactId>
            <version>${procyon.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fifesoft</groupId>
            <artifactId>rsyntaxtextarea</artifactId>
            <version>${rsyntaxtextarea.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.smali</groupId>
            <artifactId>smali</artifactId>
            <version>${smali.version}</version>
        </dependency>
        <dependency>
            <groupId>org.smali</groupId>
            <artifactId>baksmali</artifactId>
            <version>${smali.version}</version>
        </dependency>
        <dependency>
            <groupId>org.yaml</groupId>
            <artifactId>snakeyaml</artifactId>
            <version>${snakeyaml.version}</version>
        </dependency>
        <dependency>
            <groupId>xpp3</groupId>
            <artifactId>xpp3</artifactId>
            <version>${xpp3.version}</version>
        </dependency>
        <dependency>
            <groupId>io.github.skylot</groupId>
            <artifactId>jadx-core</artifactId>
            <version>${jadx.version}</version>
        </dependency>
        <dependency>
            <groupId>io.github.skylot</groupId>
            <artifactId>jadx-java-convert</artifactId>
            <version>${jadx.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>com.android.tools</groupId>
                    <artifactId>r8</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>com.jakewharton.android.repackaged</groupId>
                    <artifactId>dalvik-dx</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>io.github.skylot</groupId>
            <artifactId>jadx-dex-input</artifactId>
            <version>${jadx.version}</version>
        </dependency>
        <dependency>
            <groupId>io.github.skylot</groupId>
            <artifactId>jadx-smali-input</artifactId>
            <version>${jadx.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.ThexXTURBOXx</groupId>
            <artifactId>dex2jar</artifactId>
            <version>${dex2jar.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.weisj</groupId>
            <artifactId>darklaf-core</artifactId>
            <version>${darklaf.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.weisj</groupId>
            <artifactId>darklaf-extensions-rsyntaxarea</artifactId>
            <version>${darklaf-extensions-rsta.version}</version>
        </dependency>
        <dependency>
            <groupId>com.github.gotson</groupId>
            <artifactId>webp-imageio</artifactId>
            <version>${webp-imageio.version}</version>
        </dependency>
        <dependency>
            <groupId>de.skuzzle</groupId>
            <artifactId>semantic-version</artifactId>
            <version>${semantic-version.version}</version>
        </dependency>
        <dependency>
            <groupId>org.abego.treelayout</groupId>
            <artifactId>org.abego.treelayout.core</artifactId>
            <version>${treelayout.version}</version>
        </dependency>
        <dependency>
            <groupId>org.antlr</groupId>
            <artifactId>antlr4</artifactId>
            <version>${antlr4.version}</version>
            <exclusions>
                <exclusion>
                    <groupId>com.ibm.icu</groupId>
                    <artifactId>icu4j</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!-- TODO Re-add for Graal.JS support -->
        <!--<dependency>
            <groupId>org.graalvm.js</groupId>
            <artifactId>js</artifactId>
            <version>${js.version}</version>
        </dependency>
        <dependency>
            <groupId>org.graalvm.js</groupId>
            <artifactId>js-scriptengine</artifactId>
            <version>${js.version}</version>
        </dependency>-->
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.9.0</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                    <showDeprecation>true</showDeprecation>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>3.3.1</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.2.4</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <filters>
                        <filter>
                            <artifact>*:*</artifact>
                            <excludes>
                                <exclude>module-info.class</exclude>
                                <exclude>META-INF/*.SF</exclude>
                                <exclude>META-INF/*.DSA</exclude>
                                <exclude>META-INF/*.RSA</exclude>
                                <exclude>META-INF/*LICENSE*</exclude>
                                <exclude>META-INF/*NOTICE*</exclude>
                                <exclude>META-INF/MANIFEST.MF</exclude>
                            </excludes>
                        </filter>
                    </filters>
                    <transformers>
                        <transformer
                                implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                            <mainClass>the.bytecode.club.bytecodeviewer.BytecodeViewer</mainClass>
                            <manifestEntries>
                                <Implementation-Version>${project.version}</Implementation-Version>
                                <X-Compile-Source-JDK>${maven.compiler.source}</X-Compile-Source-JDK>
                                <X-Compile-Target-JDK>${maven.compiler.target}</X-Compile-Target-JDK>
                            </manifestEntries>
                        </transformer>
                        <transformer
                                implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"/>
                    </transformers>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>

```

`src/main/java/me/konloch/kontainer/io/DiskReader.java`:

```java
package me.konloch.kontainer.io;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import the.bytecode.club.bytecodeviewer.util.EncodeUtils;

/**
 * Used to load from the disk, optional caching
 *
 * @author Konloch
 */

public class DiskReader {

    public static Random random = new Random();
    public static Map<String, List<String>> map = new HashMap<>();

    /**
     * Used to load from file, allows caching
     */
    public synchronized static List<String> loadArrayList(String fileName,
                                                          boolean cache) {
        List<String> array = new ArrayList<>();
        if (!map.containsKey(fileName)) {
            try {
                File file = new File(fileName);
                if (!file.exists()) // doesn't exist, return empty
                    return array;

                try (FileReader fr = new FileReader(file);
                     BufferedReader reader = new BufferedReader(fr)) {
                    String add;

                    while ((add = reader.readLine()) != null)
                        array.add(add);

                }

                if (cache)
                    map.put(fileName, array);
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            array = map.get(fileName);
        }

        return array;

    }

    /**
     * Used to load from file
     */
    public synchronized static String loadAsString(String fileName) throws Exception {
        StringBuilder s = new StringBuilder();

        try (FileReader fr = new FileReader(fileName);
             BufferedReader reader = new BufferedReader(fr)) {
            for (String add = reader.readLine(); add != null; add = reader.readLine()) {
                s.append(EncodeUtils.unicodeToString(add)).append(System.lineSeparator());
            }
        }

        return s.toString();
    }

    /**
     * Used to load a string via line number lineNumber = -1 means random.
     */
    public static String loadString(String fileName, int lineNumber,
                                    boolean cache) throws Exception {

        List<String> array;
        if (!map.containsKey(fileName)) {
            array = new ArrayList<>();
            File file = new File(fileName);

            try (FileReader fr = new FileReader(file);
                 BufferedReader reader = new BufferedReader(fr)) {
                String add;

                while ((add = reader.readLine()) != null)
                    array.add(add);
            }

            if (cache)
                map.put(fileName, array);
        } else {
            array = map.get(fileName);
        }

        if (lineNumber == -1) {
            int size = array.size();
            return array.get(random.nextInt(size));
        } else
            return array.get(lineNumber);
    }

}

```

`src/main/java/me/konloch/kontainer/io/DiskWriter.java`:

```java
package me.konloch.kontainer.io;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.Arrays;

/**
 * This method will save to disk
 *
 * @author Konloch
 */

public class DiskWriter {

    /**
     * Used to insert a difference string with preserving the file extension
     *
     * @param fileName   The file name
     * @param difference Normally an integer
     * @return The filename with the difference inserted and the file extension
     *         preserved
     */
    public static String insertFileName(String fileName, String difference) {
        String[] babe = fileName.split("\\.");
        int count = 0;
        int math = babe.length;
        StringBuilder m = new StringBuilder();

        for (String s2 : babe) {
            m.append(s2);
            if (math - 2 == count)
                m.append(difference).append(".");
            else if (math - 1 != count)
                m.append(".");
            count++;
        }

        return m.toString();
    }

    /**
     * Writes a new line to the file, if it doesn't exist it will automatically
     * create it.
     *
     * @param filename
     * @param fileContents
     * @param debug
     */
    public static synchronized void writeNewLine(String filename,
                                                 byte[] fileContents, boolean debug) {
        new File(filename).getParentFile().mkdirs();
        String original = filename;
        int counter = 0;

        boolean saved = false;
        int failSafe = 0;
        while (!saved && failSafe++ <= 42069)
        {
            try (FileWriter fr = new FileWriter(filename, true);
                 BufferedWriter bw = new BufferedWriter(fr);
                 PrintWriter writer = new PrintWriter(bw)) {
                writer.println(Arrays.toString(fileContents));
                if (debug)
                    System.out.println("Saved " + filename + " to disk");
                saved = true;
            } catch (Exception e) {
                if (debug)
                    System.out.println("Failed saving, trying to save as "
                            + filename);
                if (original.contains(".")) {
                    filename = insertFileName(original, "" + counter);
                } else
                    filename = original + counter;
                counter++;
            }
        }
    }
    
    /**
     * Writes a string to the file
     */
    public static void writeNewLine(String filename, String lineToWrite)
    {
        writeNewLine(filename, lineToWrite, false);
    }

    /**
     * Writes a string to the file
     */
    public static synchronized void writeNewLine(String filename,
                                                 String lineToWrite, boolean debug) {
        new File(filename).getParentFile().mkdirs();
        String original = filename;
        int counter = 0;

        boolean saved = false;
        int failSafe = 0;
        while (!saved && failSafe++ <= 42069)
        {
            try (FileWriter fr = new FileWriter(filename, true);
                 BufferedWriter bw = new BufferedWriter(fr);
                 PrintWriter writer = new PrintWriter(bw)) {
                writer.println(lineToWrite);
                if (debug)
                    System.out.println("Saved " + filename + ">" + lineToWrite
                            + " to disk");
                saved = true;
            } catch (Exception e) {
                if (debug)
                    System.out.println("Failed saving, trying to save as "
                            + filename);
                if (original.contains(".")) {
                    filename = insertFileName(original, "" + counter);
                } else
                    filename = original + counter;
                counter++;
            }
        }
    }

    /**
     * Deletes the original file if it exists, then writes the fileContents[] to
     * the file.
     *
     * @param filename
     * @param fileContents
     * @param debug
     */
    public static synchronized void replaceFileBytes(String filename,
                                                     byte[] fileContents, boolean debug) {
        new File(filename).getParentFile().mkdirs();
        File f = new File(filename);
        if (f.exists())
            f.delete();
    
        String original = filename;
        int counter = 0;

        boolean saved = false;
        int failSafe = 0;
        while (!saved && failSafe++ <= 42069)
        {
            try (FileOutputStream stream = new FileOutputStream(filename))
            {
                stream.write(fileContents);
                stream.flush();
                if (debug)
                    System.out.println("Saved " + filename + " to disk");
                saved = true;
            } catch (Exception e) {
                if (debug)
                    System.out.println("Failed saving, trying to save as "
                            + filename);
                if (original.contains(".")) {
                    filename = insertFileName(original, "" + counter);
                } else
                    filename = original + counter;
                counter++;
            }
        }
    }

    /**
     * Deletes the original file if it exists, then writes the lineToWrite to
     * the file.
     *
     * @param filename
     * @param lineToWrite
     * @param debug
     */
    public static synchronized void replaceFile(String filename,
                                                String lineToWrite, boolean debug) {
        new File(filename).getParentFile().mkdirs();
        File f = new File(filename);
        if (f.exists())
            f.delete();
        String original = filename;
        int counter = 0;

        boolean saved = false;
        int failSafe = 0;
        while (!saved && failSafe++ <= 42069)
        {
            try (FileWriter fr = new FileWriter(filename, true);
                 BufferedWriter bw = new BufferedWriter(fr);
                 PrintWriter writer = new PrintWriter(bw)) {
                writer.println(lineToWrite);
                if (debug)
                    System.out.println("Saved " + filename + ">" + lineToWrite
                            + " to disk");
                saved = true;
            } catch (Exception e) {
                if (debug)
                    System.out.println("Failed saving, trying to save as "
                            + filename + "_");
                if (original.contains(".")) {
                    filename = insertFileName(original, "" + counter);
                } else
                    filename = original + counter;
                counter++;
            }
        }
    }

}

```

`src/main/java/me/konloch/kontainer/io/HTTPRequest.java`:

```java
package me.konloch.kontainer.io;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.Proxy;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

/**
 * A wrapper for Java SE classes to write/read an HTTP Request
 *
 * @author Konloch
 */

public class HTTPRequest {

    public URL url;
    private int timeout = 30000;
    private String cookie;
    private String referer;
    private String postData;
    private String useragent = "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:25.0) Gecko/20100101 Firefox/25.0";
    private Proxy proxy;
    private boolean setFollowRedirects = true;
    private BufferedReader reader;
    private DataOutputStream writer;
    private HttpURLConnection connection;
    private Set<Entry<String, List<String>>> lastConnectionHeaders;
    private int statusCode;

    /**
     * Creates a new HTTPRequest object
     *
     * @param url
     */
    public HTTPRequest(URL url) {
        this.url = url;
    }

    /**
     * Sets a referer to send to the web server
     */
    public void setReferer(String referer) {
        this.referer = referer;
    }

    /**
     * Set a cookie string to send to the web server
     */
    public void setCookie(String cookie) {
        this.cookie = cookie;
    }

    /**
     * Sets post data to send to the web server
     */
    public void setPostData(String postData) {
        this.postData = postData;
    }

    /**
     * Sets a custom useragent, default 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:25.0) Gecko/20100101 Firefox/25.0'
     */
    public void setUseragent(String useragent) {
        this.useragent = useragent;
    }

    /**
     * Sets the seconds till timeout, default 30,000 milliseconds
     */
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    /**
     * Sets a proxy to connect through
     */
    public void setProxy(Proxy proxy) {
        this.proxy = proxy;
    }

    /**
     * Used to get the headers the webserver sent on our last connection
     */
    public Set<Entry<String, List<String>>> getLastConnectionHeaders() {
        return lastConnectionHeaders;
    }
    
    public int getStatusCode()
    {
        return statusCode;
    }
    
    /**
     * By default, follow redirects are enabled
     */
    public void setFollowRedirects(boolean setFollowRedirects) {
        this.setFollowRedirects = setFollowRedirects;
    }

    /**
     * Used to set up the connection to read the content.
     */
    private void setup() throws Exception {
        if (proxy != null)
            connection = (HttpURLConnection) url.openConnection(proxy);
        else
            connection = (HttpURLConnection) url.openConnection();

        if (cookie != null)
            connection.setRequestProperty("Cookie", cookie);
        if (referer != null)
            connection.addRequestProperty("Referer", referer);

        connection.setRequestProperty("User-Agent", useragent);
        connection.setReadTimeout(timeout);
        connection.setConnectTimeout(timeout);
        connection.setUseCaches(false);
        HttpURLConnection.setFollowRedirects(setFollowRedirects);

        if (postData != null) {
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setDoInput(true);
            writer = new DataOutputStream(connection.getOutputStream());
            writer.writeBytes(postData);
            writer.flush();
        }

        reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    }

    /**
     * Reads the entire page and returns a string array
     *
     * @return
     * @throws Exception
     */
    public String[] read() throws Exception {
        List<String> st;

        try {
            setup();

            st = new ArrayList<>();
            String s;
            while ((s = reader.readLine()) != null)
                st.add(s);

            lastConnectionHeaders = connection.getHeaderFields().entrySet();
            statusCode = connection.getResponseCode();
        } catch (Exception e) {
            cleanup();
            throw e;
        } finally {
            cleanup();
        }

        return st.toArray(new String[0]);
    }

    /**
     * Reads as many lines as expected unless it reaches the end.
     *
     * @param linesToRead
     * @return
     * @throws Exception
     */
    public String[] read(int linesToRead) throws Exception {
        List<String> st;

        try {
            setup();

            st = new ArrayList<>();
            for (int i = 0; i < linesToRead; i++) {
                String s = reader.readLine();
                if (s != null)
                    st.add(s);
            }

            lastConnectionHeaders = connection.getHeaderFields().entrySet();
            statusCode = connection.getResponseCode();
        } catch (Exception e) {
            cleanup();
            throw e;
        } finally {
            cleanup();
        }

        return st.toArray(new String[0]);
    }

    /**
     * Only reads the first line
     *
     * @return
     * @throws Exception
     */
    public String readSingle() throws Exception {
        String s;

        try {
            setup();

            s = reader.readLine();

            lastConnectionHeaders = connection.getHeaderFields().entrySet();
            statusCode = connection.getResponseCode();
        } catch (Exception e) {
            cleanup();
            throw e;
        } finally {
            cleanup();
        }

        return s;
    }

    /**
     * Reads until it reaches the expected line then it returns it.
     *
     * @param linesToRead
     * @return
     * @throws Exception
     */
    public String readSingle(int linesToRead) throws Exception {
        String s;

        try {
            setup();

            for (int i = 0; i < linesToRead - 1; i++)
                reader.readLine();

            s = reader.readLine();

            lastConnectionHeaders = connection.getHeaderFields().entrySet();
            statusCode = connection.getResponseCode();
        } catch (Exception e) {
            cleanup();
            throw e;
        } finally {
            cleanup();
        }

        return s;
    }

    /**
     * Used to clean up the connection, closes the connections and nulls the objects
     */
    private void cleanup() {
        try {
            reader.close();
        } catch (Exception ignored) {
        }
        try {
            writer.close();
        } catch (Exception ignored) {
        }
        try {
            connection.disconnect();
        } catch (Exception ignored) {
        }
        reader = null;
        writer = null;
        connection = null;
    }

}

```

`src/main/java/the/bytecode/club/bytecodeviewer/BytecodeViewer.java`:

```java
package the.bytecode.club.bytecodeviewer;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.swing.SwingUtilities;
import me.konloch.kontainer.io.DiskReader;
import org.apache.commons.io.FileUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.api.BCV;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.bootloader.Boot;
import the.bytecode.club.bytecodeviewer.bootloader.BootState;
import the.bytecode.club.bytecodeviewer.bootloader.InstallFatJar;
import the.bytecode.club.bytecodeviewer.bootloader.UpdateCheck;
import the.bytecode.club.bytecodeviewer.gui.MainViewerGUI;
import the.bytecode.club.bytecodeviewer.gui.components.ExtendedJOptionPane;
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog;
import the.bytecode.club.bytecodeviewer.gui.resourcelist.ResourceListIconRenderer;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.TabbedPane;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ClassViewer;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ResourceViewer;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.Refactorer;
import the.bytecode.club.bytecodeviewer.plugin.PluginWriter;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.importing.ImportResource;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.BootCheck;
import the.bytecode.club.bytecodeviewer.util.ClassFileUtils;
import the.bytecode.club.bytecodeviewer.util.LazyNameUtil;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;
import the.bytecode.club.bytecodeviewer.util.PingBack;
import the.bytecode.club.bytecodeviewer.util.SecurityMan;

import static javax.swing.JOptionPane.QUESTION_MESSAGE;
import static the.bytecode.club.bytecodeviewer.Constants.DEV_MODE;
import static the.bytecode.club.bytecodeviewer.Constants.FAT_JAR;
import static the.bytecode.club.bytecodeviewer.Constants.VERSION;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A lightweight Java Reverse Engineering suite, developed by Konloch - http://konloch.me
 *
 * All you have to do is add a jar or class file into the workspace,
 * select the file you want then it will start decompiling the class in the background.
 * When it's done it will show the Source code, Bytecode and Hexcode of the class file you chose.
 *
 * There is also a plugin system that will allow you to interact with the loaded classfiles.
 * For example you can write a String deobfuscator, a malicious code searcher,
 * or anything else you can think of.
 *
 * You can either use one of the pre-written plugins, or write your own. It supports java scripting.
 * Once a plugin is activated, it will send a ClassNode ArrayList of every single class loaded in the
 * file system to the execute function, this allows the user to handle it completely using ASM.
 *
 * Are you a Java Reverse Engineer? Or maybe you want to learn Java Reverse Engineering?
 * Join The Bytecode Club, we're noob friendly, and censorship free.
 * http://the.bytecode.club
 *
 * TODO BUGS:
 *      + View>Visual Settings>Show Class Methods
 *      + Spam-clicking the refresh button will cause the swing thread to deadlock (Quickly opening resources used to also do this)
 *          This is caused by the ctrlMouseWheelZoom code, a temporary patch is just removing it worst case
 *
 * TODO API BUGS:
 *      + All of the plugins that modify code need to include BytecodeViewer.updateAllClassNodeByteArrays();
 *      + All of the plugins that do any code changes should also include BytecodeViewer.refreshAllTabs();
 *      + Anything using getLoadedClasses() needs to be replaced with the new API
 *      + Anything using blindlySearchForClassNode() should instead search through the resource container search function
 *      + BCV's classLoader should be destroyed each time a resource is added or removed
 *
 * TODO DarkLAF Specific Bugs:
 *      + JMenuBar can only be displayed on a JFrame, a work around is needed for this (Partially solved)
 *
 * TODO IN-PROGRESS:
 *      + Resource Exporter/Save/Decompile As Zip needs to be rewritten
 *      + Finish dragging code
 *      + Finish right-click tab menu detection
 *      + Fix hook inject for EZ-Injection
 *
 * TODO FEATURES:
 *      + On refresh save scroll position
 *      + Option to only compile currently viewed class (true by default)
 *      + CLI Headless needs to be supported
 *      + Add stackmapframes to bytecode decompiler
 *      + Add https://github.com/exbin/bined as the replacement Hex Viewer/Editor
 *      + Make the decompilers launch in a separate process
 *      + Add decompile as zip for krakatau-bytecode, jd-gui and smali for CLI
 *      + Add decompile all as zip for CLI
 *      + Console on the Main Viewer UI
 *      + Font settings
 *
 *  TODO IDEAS:
 *      + App Bundle Support
 *      + Add JEB decompiler optionally, requires them to add jeb library jar
 *      + Add the setting to force all non-class resources to be opened with the Hex Viewer
 *          ^ Optionally a right-click menu open-as would work inside of the resource list
 *      + Allow class files to be opened without needing the .class extension
 *          ^ Easiest way to do this is to read the file header CAFEBABE on resource view
 *      + Add BCEL Support:
 *          ^ https://github.com/ptnkjke/Java-Bytecode-Editor visualizer as a plugin
 *      + Add animated GIF support to image viewer
 *      + Add drag support to images (allow not only to zoom, but also to drag the image)
 *
 * @author Konloch
 * @author The entire BCV community
 */

public class BytecodeViewer
{
    //TODO fix this for tab dragging & better tab controls
    public static boolean EXPERIMENTAL_TAB_CODE = false;
    
    //the launch args called on BCV
    public static String[] launchArgs;
    
    //the GUI reference
    public static MainViewerGUI viewer;
    
    //All of the opened resources (Files/Classes/Etc)
    public static Map<String,ResourceContainer> resourceContainers = new LinkedHashMap<>();
    
    //All of the created processes (Decompilers/etc)
    public static List<Process> createdProcesses = new ArrayList<>();
    
    //Security Manager for dynamic analysis debugging
    public static SecurityMan sm = new SecurityMan();
    
    //Refactorer
    public static Refactorer refactorer = new Refactorer();
    
    //GSON Reference
    public static final Gson gson = new GsonBuilder().setPrettyPrinting().create();
    
    //Threads
    private static final Thread versionChecker = new Thread(new UpdateCheck(), "Version Checker");
    private static final Thread pingBack = new Thread(new PingBack(), "Pingback");
    private static final Thread installFatJar = new Thread(new InstallFatJar(), "Install Fat-Jar");
    private static final Thread bootCheck = new Thread(new BootCheck(), "Boot Check");
    
    /**
     * Main startup
     *
     * @param args files you want to open or CLI
     */
    public static void main(String[] args)
    {
        launchArgs = args;
        
        //welcome message
        System.out.print("Bytecode Viewer " + VERSION);
        if (FAT_JAR)
            System.out.print(" [Fat Jar]");
        
        System.out.println(" - Created by @Konloch");
        System.out.println("https://bytecodeviewer.com - https://the.bytecode.club");

        // Set the security manager
        try {
            System.setSecurityManager(sm);
        } catch (Throwable t) {
            System.err.println("Cannot set security manager! Are you on Java 18+ and have not enabled support for it?");
            System.err.println("Because of this, you may be susceptible to some exploits!");
            System.err.println("Either deal with it or allow it using the -Djava.security.manager=allow parameter.");
        }

        try
        {
            //precache settings file
            SettingsSerializer.preloadSettingsFile();
            
            //setup look and feel
            Configuration.lafTheme.setLAF();
            
            //set swing specific system properties
            System.setProperty("swing.aatext", "true");
            
            //setup swing components
            viewer = new MainViewerGUI();
            SwingUtilities.updateComponentTreeUI(viewer);
            
            //load settings and set swing components state
            SettingsSerializer.loadSettings();
            Configuration.bootState = BootState.SETTINGS_LOADED;
            
            //set translation language
            if (!Settings.hasSetLanguageAsSystemLanguage)
                MiscUtils.setLanguage(MiscUtils.guessLanguage());
    
            //handle CLI
            int CLI = CommandLineInput.parseCommandLine(args);
            if (CLI == CommandLineInput.STOP)
                return;
    
            //load with shaded libraries
            if (FAT_JAR)
            {
                installFatJar.start();
            }
            else //load through bootloader
            {
                bootCheck.start();
                Boot.boot(args, CLI != CommandLineInput.GUI);
            }
            
            //CLI arguments say spawn the GUI
            if (CLI == CommandLineInput.GUI)
            {
                BytecodeViewer.boot(false);
                Configuration.bootState = BootState.GUI_SHOWING;
            }
            else //CLI arguments say keep it CLI
            {
                BytecodeViewer.boot(true);
                CommandLineInput.executeCommandLine(args);
            }
        }
        catch (Exception e)
        {
            BytecodeViewer.handleException(e);
        }
    }
    
    /**
     * Boot after all of the libraries have been loaded
     *
     * @param cli is it running CLI mode or not
     */
    public static void boot(boolean cli)
    {
        //delete files in the temp folder
        cleanupAsync();
        
        //shutdown hooks
        Runtime.getRuntime().addShutdownHook(new Thread(() ->
        {
            for (Process proc : createdProcesses)
                proc.destroy();
            
            SettingsSerializer.saveSettings();
            cleanup();
        }, "Shutdown Hook"));
    
        //setup the viewer
        viewer.calledAfterLoad();
        
        //setup the recent files
        Settings.resetRecentFilesMenu();
    
        //ping back once on first boot to add to global user count
        if (!Configuration.pingback)
        {
            pingBack.start();
            Configuration.pingback = true;
        }
        
        //version checking
        if (viewer.updateCheck.isSelected() && !DEV_MODE)
            versionChecker.start();
    
        //show the main UI
        if (!cli)
            viewer.setVisible(true);
    
        //print startup time
        System.out.println("Start up took " + ((System.currentTimeMillis() - Configuration.start) / 1000) + " seconds");
        
        //request focus on GUI for hotkeys on start
        if (!cli)
            viewer.requestFocus();
        
        //open files from launch args
        if (!cli)
            if (launchArgs.length >= 1)
                for (String s : launchArgs)
                    openFiles(new File[]{new File(s)}, true);
    }
    
    /**
     * Adds a resource container to BCVs resource container list
     */
    public static void addResourceContainer(ResourceContainer container)
    {
        resourceContainers.put(container.name, container);
        SwingUtilities.invokeLater(() ->
        {
            try {
                viewer.resourcePane.addResourceContainer(container);
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }
    
    /**
     * Returns true if there is at least one file resource loaded
     */
    public static boolean hasResources()
    {
        return !resourceContainers.isEmpty();
    }
    
    /**
     * Returns true if there is currently a tab open with a resource inside of it
     */
    public static boolean hasActiveResource()
    {
        return getActiveResource() != null;
    }
    
    /**
     * Returns true if there is currently a tab open with a resource inside of it
     */
    public static boolean isActiveResourceClass()
    {
        ResourceViewer resource = getActiveResource();
        return resource instanceof ClassViewer;
    }
    
    /**
     * Returns the currently opened & viewed resource
     */
    public static ResourceViewer getActiveResource()
    {
        return BytecodeViewer.viewer.workPane.getActiveResource();
    }
    
    /**
     * Returns the currently opened ClassNode
     *
     * @return the currently opened ClassNode
     */
    public static ClassNode getCurrentlyOpenedClassNode()
    {
        return getActiveResource().resource.getResourceClassNode();
    }
    
    /**
     * Returns the ClassNode by the specified name
     * <p>
     * TODO anything relying on this should be rewritten to search using the resource container
     *
     * @param name the class name
     * @return the ClassNode instance
     */
    @Deprecated
    public static ClassNode blindlySearchForClassNode(String name)
    {
        for (ResourceContainer container : resourceContainers.values())
        {
            ClassNode node = container.getClassNode(name);
            
            if (node != null)
                return node;
        }
    
        return null;
    }
    
    /**
     * Returns the resource container by the specific name
     */
    public static ResourceContainer getFileContainer(String name)
    {
        for (ResourceContainer container : resourceContainers.values())
            if (container.name.equals(name))
                return container;
    
        return null;
    }
    
    /**
     * Returns all of the loaded resource containers
     */
    public static Collection<ResourceContainer> getResourceContainers()
    {
        return resourceContainers.values();
    }
    
    /**
     * Grabs the file contents of the loaded resources.
     * <p>
     * TODO anything relying on this should be rewritten to use the resource container's getFileContents
     *
     * @param name the file name
     * @return the file contents as a byte[]
     */
    @Deprecated
    public static byte[] getFileContents(String name)
    {
        for (ResourceContainer container : resourceContainers.values())
            if (container.resourceFiles.containsKey(name))
                return container.resourceFiles.get(name);
    
        return null;
    }
    
    /**
     * Grab the byte array from the loaded Class object by getting the resource from the classloader
     */
    public static byte[] getClassFileBytes(Class<?> clazz) throws IOException
    {
        return ClassFileUtils.getClassFileBytes(clazz);
    }
    
    /**
     * Gets all of the loaded classes as an array list
     *
     * TODO: remove this and replace it with:
     * BytecodeViewer.getResourceContainers().forEach(container -> {
     *      execute(new ArrayList<>(container.resourceClasses.values()));
     * });
     *
     * @return the loaded classes as an array list
     */
    @Deprecated
    public static List<ClassNode> getLoadedClasses()
    {
        List<ClassNode> a = new ArrayList<>();
    
        for (ResourceContainer container : resourceContainers.values())
            for (ClassNode c : container.resourceClasses.values())
                if (!a.contains(c))
                    a.add(c);
    
        return a;
    }
    
    /**
     * Called any time refresh is called to automatically compile all of the compilable panes that're opened.
     */
    public static boolean autoCompileSuccessful()
    {
        if (!BytecodeViewer.viewer.autoCompileOnRefresh.isSelected())
            return true;
        
        try
        {
            return compile(false, false);
        }
        catch (NullPointerException ignored)
        {
            return false;
        }
    }
    
    /**
     * Compile all of the compilable panes that're opened.
     *
     * @param message if it should send a message saying it's compiled sucessfully.
     * @return true if no errors, false if it failed to compile.
     */
    public static boolean compile(boolean message, boolean successAlert)
    {
        BytecodeViewer.updateBusyStatus(true);
        boolean noErrors = true;
        boolean actuallyTried = false;
    
        for (java.awt.Component c : BytecodeViewer.viewer.workPane.getLoadedViewers())
        {
            if (c instanceof ClassViewer)
            {
                ClassViewer cv = (ClassViewer) c;
                
                if (noErrors && !cv.bytecodeViewPanel1.compile())
                    noErrors = false;
                if (noErrors && !cv.bytecodeViewPanel2.compile())
                    noErrors = false;
                if (noErrors && !cv.bytecodeViewPanel3.compile())
                    noErrors = false;
                
                if (cv.bytecodeViewPanel1.textArea != null && cv.bytecodeViewPanel1.textArea.isEditable())
                    actuallyTried = true;
                if (cv.bytecodeViewPanel2.textArea != null && cv.bytecodeViewPanel2.textArea.isEditable())
                    actuallyTried = true;
                if (cv.bytecodeViewPanel3.textArea != null && cv.bytecodeViewPanel3.textArea.isEditable())
                    actuallyTried = true;
            }
        }
    
        if (message)
        {
            if (actuallyTried)
            {
                if (noErrors && successAlert)
                    BytecodeViewer.showMessage("Compiled Successfully.");
            }
            else
            {
                BytecodeViewer.showMessage("You have no editable panes opened, make one editable and try again.");
            }
        }
        
        BytecodeViewer.updateBusyStatus(false);
        return true;
    }
    
    /**
     * Opens a file, optional if it should append to the recent files menu
     *
     * @param files       the file(s) you wish to open
     * @param recentFiles if it should append to the recent files menu
     */
    public static void openFiles(final File[] files, boolean recentFiles)
    {
        if (recentFiles)
        {
            for (File f : files)
                if (f.exists())
                    Settings.addRecentFile(f);
    
            SettingsSerializer.saveSettingsAsync();
        }
    
        BytecodeViewer.updateBusyStatus(true);
        Configuration.needsReDump = true;
        Thread t = new Thread(new ImportResource(files), "Import Resource");
        t.start();
    }
    
    /**
     * Starts the specified plugin
     *
     * @param file the file of the plugin
     */
    public static void startPlugin(File file)
    {
        if (!file.exists())
        {
            BytecodeViewer.showMessage("The plugin file " + file.getAbsolutePath() + " could not be found.");
            Settings.removeRecentPlugin(file);
            return;
        }
        
        try
        {
            PluginWriter writer = new PluginWriter(DiskReader.loadAsString(file.getAbsolutePath()), file.getName());
            writer.setSourceFile(file);
            writer.setVisible(true);
        }
        catch (Exception e)
        {
            BytecodeViewer.handleException(e);
        }
        
        Settings.addRecentPlugin(file);
    }
    
    /**
     * Send a message to alert the user
     *
     * @param message the message you need to send
     */
    public static void showMessage(String message)
    {
        ExtendedJOptionPane.showMessageDialog(viewer, message);
    }
    
    /**
     * Send a message to alert the user
     */
    public static String showInput(String message)
    {
        return ExtendedJOptionPane.showInputDialog(viewer, message);
    }
    
    /**
     * Send a message to alert the user
     */
    public static String showInput(String message, String title, String initialMessage)
    {
        return (String) ExtendedJOptionPane.showInputDialog(viewer, message, title,
                QUESTION_MESSAGE, null, null, initialMessage);
    }
    
    /**
     * Alerts the user the program is running something in the background
     */
    public static void updateBusyStatus(boolean busyStatus)
    {
        viewer.updateBusyStatus(busyStatus);
    }
    
    /**
     * Clears all active busy status icons
     */
    public static void clearBusyStatus()
    {
        viewer.clearBusyStatus();
    }
    
    /**
     * Returns true if there are no loaded resource classes
     */
    public static boolean promptIfNoLoadedClasses()
    {
        if (BytecodeViewer.getLoadedClasses().isEmpty())
        {
            BytecodeViewer.showMessage(TranslatedStrings.FIRST_OPEN_A_CLASS.toString());
            return true;
        }
        
        return false;
    }
    
    /**
     * Returns true if there are no loaded resource classes
     */
    public static boolean promptIfNoLoadedResources()
    {
        if (BytecodeViewer.resourceContainers.isEmpty())
        {
            BytecodeViewer.showMessage(TranslatedStrings.FIRST_OPEN_A_RESOURCE.toString());
            return true;
        }
        
        return false;
    }
    
    /**
     * Handle the exception by creating a new window for bug reporting
     */
    public static void handleException(Throwable t)
    {
        handleException(t, ExceptionUI.KONLOCH);
    }
    
    /**
     * Handle the exception by creating a new window for bug reporting
     */
    public static void handleException(Throwable t, String author)
    {
        new ExceptionUI(t, author);
    }
    
    /**
     * Refreshes the title on all of the opened tabs
     */
    public static void updateAllClassNodeByteArrays()
    {
        resourceContainers.values().forEach(ResourceContainer::updateClassNodeBytes);
    }
    
    /**
     * Refreshes the title on all of the opened tabs
     */
    public static void refreshAllTabTitles()
    {
        for(int i = 0; i < BytecodeViewer.viewer.workPane.tabs.getTabCount(); i++)
        {
            ResourceViewer viewer = ((TabbedPane) BytecodeViewer.viewer.workPane.tabs.getTabComponentAt(i)).resource;
            viewer.refreshTitle();
        }
    }
    
    /**
     * Refreshes the title on all of the opened tabs
     */
    public static void refreshAllTabs()
    {
        new Thread(()->
        {
            updateBusyStatus(true);
            for (int i = 0; i < BytecodeViewer.viewer.workPane.tabs.getTabCount(); i++)
            {
                ResourceViewer viewer = ((TabbedPane) BytecodeViewer.viewer.workPane.tabs.getTabComponentAt(i)).resource;
                viewer.refresh(null);
            }
            updateBusyStatus(false);
        }, "Refresh All Tabs").start();
    }

    /**
     * Resets the workspace with optional user input required
     *
     * @param ask if should require user input or not
     */
    public static void resetWorkspace(boolean ask)
    {
        if (ask)
        {
            MultipleChoiceDialog dialog = new MultipleChoiceDialog(TranslatedStrings.RESET_TITLE.toString(),
                    TranslatedStrings.RESET_CONFIRM.toString(),
                    new String[]{TranslatedStrings.YES.toString(), TranslatedStrings.NO.toString()});
        
            if (dialog.promptChoice() != 0)
                return;
        }
    
        resetWorkspace();
    }
    
    /**
     * Resets the workspace
     */
    public static void resetWorkspace()
    {
        BytecodeViewer.resourceContainers.clear();
        LazyNameUtil.reset();
        BytecodeViewer.viewer.resourcePane.resetWorkspace();
        BytecodeViewer.viewer.workPane.resetWorkspace();
        BytecodeViewer.viewer.searchBoxPane.resetWorkspace();
        BCV.getClassNodeLoader().clear();
        ResourceListIconRenderer.iconCache.clear();
    }
    
    /**
     * Clears the temp directory
     */
    public static void cleanupAsync()
    {
        Thread cleanupThread = new Thread(BytecodeViewer::cleanup, "Cleanup");
        cleanupThread.start();
    }

    /**
     * Clears the temp directory
     */
    public static void cleanup()
    {
        File tempF = new File(tempDirectory);

        try {
            FileUtils.deleteDirectory(tempF);
        } catch (Exception ignored) { }

        while (!tempF.exists()) // keep making dirs
            tempF.mkdir();
    }
    
    /**
     * because Smali and Baksmali System.exit if it failed
     */
    public static void exit(int i) { }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/CommandLineInput.java`:

```java
package the.bytecode.club.bytecodeviewer;

import java.io.File;
import me.konloch.kontainer.io.DiskWriter;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.Options;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.translation.Language;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.VERSION;
import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Used to allow BCV to be integrated as CLI instead of GUI.
 *
 * @author Konloch
 */

public class CommandLineInput {

    private static final Options options = new Options();
    private static final CommandLineParser parser = new DefaultParser();

    /*BECAUSE WHO DOESN'T LOVE MAGIC NUMBERS*/
    public static int STOP = -1;
    public static int GUI = 0;
    public static int CLI = 1;

    static {
        options.addOption("help", false, "prints the help menu.");
        options.addOption("list", false, "lists all the available decompilers for BCV " + VERSION + ".");
        options.addOption("decompiler", true, "sets the decompiler, procyon by default.");
        options.addOption("i", true, "sets the input.");
        options.addOption("o", true, "sets the output.");
        options.addOption("t", true, "sets the target class to decompile, append all to decomp all as zip.");
        options.addOption("nowait", true, "won't wait the 5 seconds to allow the user to read the CLI.");
    }

    public static boolean containsCommand(String[] args) {
        if (args == null || args.length == 0)
            return false;

        try {
            CommandLine cmd = parser.parse(options, args);
            if (
                    cmd.hasOption("help") ||
                            cmd.hasOption("clean") ||
                            cmd.hasOption("english") ||
                            cmd.hasOption("list") ||
                            cmd.hasOption("decompiler") ||
                            cmd.hasOption("i") ||
                            cmd.hasOption("o") ||
                            cmd.hasOption("t") ||
                            cmd.hasOption("nowait")
            ) {
                return true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return false;
    }

    public static int parseCommandLine(String[] args) {
        if (!containsCommand(args))
            return GUI;
        try {
            CommandLine cmd = parser.parse(options, args);
            if (cmd.hasOption("list")) {
                System.out.println("Procyon");
                System.out.println("CFR");
                System.out.println("FernFlower");
                System.out.println("Krakatau");
                System.out.println("Krakatau-Bytecode");
                System.out.println("JD-GUI");
                System.out.println("Smali");
                return STOP;
            } else if (cmd.hasOption("clean")) {
                new File(Constants.getBCVDirectory()).delete();
                if(cmd.getOptionValue("i") == null && cmd.getOptionValue("o") == null
                        && cmd.getOptionValue("t") == null)
                    return GUI;
            } else if (cmd.hasOption("english")) {
                Configuration.language = Language.ENGLISH;
                return GUI;
            } else if (cmd.hasOption("help")) {
                for (String s : new String[]{
                        "-help                         Displays the help menu",
                        "-clean                        Deletes the BCV directory",
                        "-english                      Forces English language translations",
                        "-list                         Displays the available decompilers",
                        "-decompiler <decompiler>      Selects the decompiler, procyon by default",
                        "-i <input file>               Selects the input file",
                        "-o <output file>              Selects the output file",
                        "-t <target classname>         Must either be the fully qualified classname or \"all\" to decompile all as zip",
                        "-nowait                       Doesn't wait for the user to read the CLI messages"
                })
                    System.out.println(s);
                return STOP;
            } else {
                if (cmd.getOptionValue("i") == null) {
                    System.err.println("Set the input with -i");
                    return STOP;
                }
                if (cmd.getOptionValue("o") == null) {
                    System.err.println("Set the output with -o");
                    return STOP;
                }
                if (cmd.getOptionValue("t") == null) {
                    System.err.println("Set the target with -t");
                    return STOP;
                }

                File input = new File(cmd.getOptionValue("i"));
                File output = new File(cmd.getOptionValue("o"));
                String decompiler = cmd.getOptionValue("decompiler");

                if (!input.exists()) {
                    System.err.println(input.getAbsolutePath() + " does not exist.");
                    return STOP;
                }

                if (output.exists()) {
                    System.err.println("WARNING: Deleted old " + output.getAbsolutePath() + ".");
                    output.delete();
                }

                //check if zip, jar, apk, dex, or class
                //if its zip/jar/apk/dex attempt unzip as whole zip
                //if its just class allow any

                if (
                        decompiler != null &&
                                !decompiler.equalsIgnoreCase("procyon") &&
                                !decompiler.equalsIgnoreCase("cfr") &&
                                !decompiler.equalsIgnoreCase("fernflower") &&
                                !decompiler.equalsIgnoreCase("krakatau") &&
                                !decompiler.equalsIgnoreCase("krakatau-bytecode") &&
                                !decompiler.equalsIgnoreCase("jd-gui") &&
                                !decompiler.equalsIgnoreCase("smali")
                ) {
                    System.out.println("Error, no decompiler called '" + decompiler + "' found. Type -decompiler-list"
                            + " for the list");
                }


                if (!cmd.hasOption("nowait"))
                    Thread.sleep(5 * 1000);

                return CLI;
            }
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }

        return GUI;
    }

    public static void executeCommandLine(String[] args) {
        try {
            CommandLine cmd = parser.parse(options, args);
            String decompiler = cmd.getOptionValue("decompiler");
            File input = new File(cmd.getOptionValue("i"));
            File output = new File(cmd.getOptionValue("o"));
            String target = cmd.getOptionValue("t");

            if (cmd.getOptionValue("decompiler") == null) {
                System.out.println("You can define another decompiler by appending -decompiler \"name\", by default "
                        + "procyon has been set.");
                decompiler = "procyon";
            }

            //check if zip, jar, apk, dex, or class
            //if its zip/jar/apk/dex attempt unzip as whole zip
            //if its just class allow any

            File tempZip =
                    new File(tempDirectory + fs + "temp_" + MiscUtils.getRandomizedName() + ".jar");
            if (tempZip.exists())
                tempZip.delete();

            JarUtils.saveAsJarClassesOnly(BytecodeViewer.getLoadedClasses(), tempZip.getAbsolutePath());

            if (decompiler.equalsIgnoreCase("procyon")) {
                System.out.println("Decompiling " + input.getAbsolutePath() + " with Procyon");
                BytecodeViewer.openFiles(new File[]{input}, false);

                Thread.sleep(5 * 1000);

                if (target.equalsIgnoreCase("all")) {
                    Decompiler.PROCYON_DECOMPILER.getDecompiler().decompileToZip(tempZip.getAbsolutePath(), output.getAbsolutePath());
                } else {
                    try {
                        ClassNode cn = BytecodeViewer.blindlySearchForClassNode(target);
                        final ClassWriter cw = accept(cn);
                        String contents = Decompiler.PROCYON_DECOMPILER.getDecompiler().decompileClassNode(cn, cw.toByteArray());
                        DiskWriter.replaceFile(output.getAbsolutePath(), contents, false);
                    } catch (Exception e) {
                        BytecodeViewer.handleException(e);
                    }
                }
            } else if (decompiler.equalsIgnoreCase("cfr")) {
                System.out.println("Decompiling " + input.getAbsolutePath() + " with CFR");
                BytecodeViewer.openFiles(new File[]{input}, false);

                Thread.sleep(5 * 1000);

                if (target.equalsIgnoreCase("all")) {
                    Decompiler.CFR_DECOMPILER.getDecompiler().decompileToZip(tempZip.getAbsolutePath(), output.getAbsolutePath());
                } else {
                    try {
                        ClassNode cn = BytecodeViewer.blindlySearchForClassNode(target);
                        final ClassWriter cw = accept(cn);
                        String contents = Decompiler.CFR_DECOMPILER.getDecompiler().decompileClassNode(cn, cw.toByteArray());
                        DiskWriter.replaceFile(output.getAbsolutePath(), contents, false);
                    } catch (Exception e) {
                        BytecodeViewer.handleException(e);
                    }
                }
            } else if (decompiler.equalsIgnoreCase("fernflower")) {
                System.out.println("Decompiling " + input.getAbsolutePath() + " with FernFlower");
                BytecodeViewer.openFiles(new File[]{input}, false);

                Thread.sleep(5 * 1000);

                if (target.equalsIgnoreCase("all")) {
                    Decompiler.FERNFLOWER_DECOMPILER.getDecompiler().decompileToZip(tempZip.getAbsolutePath(), output.getAbsolutePath());
                } else {
                    try {
                        ClassNode cn = BytecodeViewer.blindlySearchForClassNode(target);
                        final ClassWriter cw = accept(cn);
                        String contents = Decompiler.FERNFLOWER_DECOMPILER.getDecompiler().decompileClassNode(cn, cw.toByteArray());
                        DiskWriter.replaceFile(output.getAbsolutePath(), contents, false);
                    } catch (Exception e) {
                        BytecodeViewer.handleException(e);
                    }
                }
            } else if (decompiler.equalsIgnoreCase("krakatau")) {
                System.out.println("Decompiling " + input.getAbsolutePath() + " with Krakatau");
                BytecodeViewer.openFiles(new File[]{input}, false);

                Thread.sleep(5 * 1000);

                if (target.equalsIgnoreCase("all")) {
                    Decompiler.KRAKATAU_DECOMPILER.getDecompiler().decompileToZip(tempZip.getAbsolutePath(), output.getAbsolutePath());
                } else {
                    try {
                        ClassNode cn = BytecodeViewer.blindlySearchForClassNode(target);
                        final ClassWriter cw = accept(cn);
                        String contents = Decompiler.KRAKATAU_DECOMPILER.getDecompiler().decompileClassNode(cn, cw.toByteArray());
                        DiskWriter.replaceFile(output.getAbsolutePath(), contents, false);
                    } catch (Exception e) {
                        BytecodeViewer.handleException(e);
                    }
                }
            } else if (decompiler.equalsIgnoreCase("krakatau-bytecode")) {
                System.out.println("Decompiling " + input.getAbsolutePath() + " with Krakatau-Bytecode");
                BytecodeViewer.openFiles(new File[]{input}, false);

                Thread.sleep(5 * 1000);

                if (target.equalsIgnoreCase("all")) {
                    System.out.println("Coming soon.");
                    //Decompiler.krakatauDA.decompileToZip(output.getAbsolutePath());
                } else {
                    try {
                        ClassNode cn = BytecodeViewer.blindlySearchForClassNode(target);
                        final ClassWriter cw = accept(cn);
                        String contents = Decompiler.KRAKATAU_DISASSEMBLER.getDecompiler().decompileClassNode(cn, cw.toByteArray());
                        DiskWriter.replaceFile(output.getAbsolutePath(), contents, false);
                    } catch (Exception e) {
                        BytecodeViewer.handleException(e);
                    }
                }
            } else if (decompiler.equalsIgnoreCase("jd-gui")) {
                System.out.println("Decompiling " + input.getAbsolutePath() + " with JD-GUI");
                BytecodeViewer.openFiles(new File[]{input}, false);

                Thread.sleep(5 * 1000);

                if (target.equalsIgnoreCase("all")) {
                    System.out.println("Coming soon.");
                    //Decompiler.jdgui.decompileToZip(output.getAbsolutePath());
                } else {
                    try {
                        ClassNode cn = BytecodeViewer.blindlySearchForClassNode(target);
                        final ClassWriter cw = accept(cn);
                        String contents = Decompiler.JD_DECOMPILER.getDecompiler().decompileClassNode(cn, cw.toByteArray());
                        DiskWriter.replaceFile(output.getAbsolutePath(), contents, false);
                    } catch (Exception e) {
                        BytecodeViewer.handleException(e);
                    }
                }
            } else if (decompiler.equalsIgnoreCase("smali")) {
                System.out.println("Decompiling " + input.getAbsolutePath() + " with Smali");
                BytecodeViewer.openFiles(new File[]{input}, false);

                Thread.sleep(5 * 1000);

                if (target.equalsIgnoreCase("all")) {
                    System.out.println("Coming soon.");
                    //Decompiler.smali.decompileToZip(output.getAbsolutePath());
                } else {
                    try {
                        ClassNode cn = BytecodeViewer.blindlySearchForClassNode(target);
                        final ClassWriter cw = accept(cn);
                        String contents = Decompiler.SMALI_DISASSEMBLER.getDecompiler().decompileClassNode(cn, cw.toByteArray());
                        DiskWriter.replaceFile(output.getAbsolutePath(), contents, false);
                    } catch (Exception e) {
                        BytecodeViewer.handleException(e);
                    }
                }
            } else if (decompiler.equalsIgnoreCase("jadx")) {
                System.out.println("Decompiling " + input.getAbsolutePath() + " with JADX");
                BytecodeViewer.openFiles(new File[]{input}, false);

                Thread.sleep(5 * 1000);

                if (target.equalsIgnoreCase("all")) {
                    System.out.println("Coming soon.");
                    //Decompiler.smali.decompileToZip(output.getAbsolutePath());
                } else {
                    try {
                        ClassNode cn = BytecodeViewer.blindlySearchForClassNode(target);
                        final ClassWriter cw = accept(cn);
                        String contents = Decompiler.JADX_DECOMPILER.getDecompiler().decompileClassNode(cn, cw.toByteArray());
                        DiskWriter.replaceFile(output.getAbsolutePath(), contents, false);
                    } catch (Exception e) {
                        BytecodeViewer.handleException(e);
                    }
                }
            }

            System.out.println("Finished.");
            System.out.println("Bytecode Viewer " + VERSION + " [CLI] - Created by @Konloch - https://bytecodeviewer.com");
            Configuration.canExit = true;
            System.exit(0);
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }

    public static ClassWriter accept(ClassNode cn) {
        ClassWriter cw = new ClassWriter(0);
        try {
            cn.accept(cw);
        } catch (Exception e) {
            e.printStackTrace();
            try {
                Thread.sleep(200);
                cn.accept(cw);
            } catch (InterruptedException ignored) {
            }
        }
        return cw;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/Configuration.java`:

```java
package the.bytecode.club.bytecodeviewer;

import java.io.File;
import java.io.IOException;
import the.bytecode.club.bytecodeviewer.bootloader.BootState;
import the.bytecode.club.bytecodeviewer.gui.theme.LAFTheme;
import the.bytecode.club.bytecodeviewer.gui.theme.RSTATheme;
import the.bytecode.club.bytecodeviewer.translation.Language;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A collection of variables that can be configured through the settings menu or some form of UI/plugin
 *
 * @author Konloch
 * @since 6/21/2021
 */

public class Configuration
{
	public static String python2 = "";
	public static boolean python2Extra = false;
	public static String python3 = "";
	public static boolean python3Extra = false;
	public static String rt = "";
	public static String library = "";
	public static String java = Constants.JAVA_BINARY.exists() ? Constants.JAVA_BINARY.getAbsolutePath() :
			Constants.JAVA_BINARY_NIX.exists() ? Constants.JAVA_BINARY_NIX.getAbsolutePath() : "";
	public static String javac = "";
	public static String javaTools = "";
	public static File krakatauTempDir;
	public static File krakatauTempJar;
	
	public static boolean displayParentInTab = false; //also change in the main GUI
	public static boolean simplifiedTabNames = false;
	
	//if true it will show a settings dialog on click instead of more menu items
	public static boolean useNewSettingsDialog = true; //TODO add to GUI
	
	//if true it will put force error UIs and console UIs to be added as a tab
	public static boolean pluginConsoleAsNewTab = true; //TODO add to GUI
	//if true it will put force error UIs and console UIs to be added as a tab
	public static boolean errorLogsAsNewTab = true; //TODO add to GUI
	//if true the plugin writer will open inside of a tab
	public static boolean pluginWriterAsNewTab = true; //TODO add to GUI
	
	//if true jadx will be above smali in an android grouping
	public static boolean jadxGroupedWithSmali = true; //TODO add to GUI
	
	public static boolean forceResourceUpdateFromClassNode = false; //TODO add to GUI
	public static boolean showDarkLAFComponentIcons = false;
	public static boolean currentlyDumping = false;
	public static boolean needsReDump = true;
	public static boolean warnForEditing = false;
	public static boolean runningObfuscation = false;
	public static final long start = System.currentTimeMillis();
	public static String lastOpenDirectory = ".";
	public static String lastSaveDirectory = ".";
	public static String lastPluginDirectory = ".";
	public static boolean pingback = false;
	public static boolean deleteForeignLibraries = true;
	public static boolean canExit = false;
	public static int silenceExceptionGUI = 0;
	public static int pauseExceptionGUI = 0;
	
	public static final int maxRecentFiles = 25; //eventually may be a setting
	public static boolean verifyCorruptedStateOnBoot = false; //eventually may be a setting
	
	public static BootState bootState = BootState.START_UP;
	public static Language language = Language.ENGLISH;
	public static LAFTheme lafTheme = LAFTheme.SYSTEM; //lightmode by default since it uses the system theme
	public static RSTATheme rstaTheme = lafTheme.getRSTATheme();
	public static long lastHotKeyExecuted = 0;
	
	public static void setLastOpenDirectory(File file)
	{
		lastOpenDirectory = file.getAbsolutePath();
	}
	
	public static void setLastSaveDirectory(File file)
	{
		lastSaveDirectory = file.getAbsolutePath();
	}
	
	public static void setLastPluginDirectory(File file)
	{
		lastPluginDirectory = file.getAbsolutePath();
	}
	
	public static File getLastOpenDirectory()
	{
		File lastDir = new File(lastOpenDirectory);
		if(lastDir.getParentFile() != null && lastDir.getParentFile().exists())
			return lastDir;
		
		return new File(".");
	}
	
	public static File getLastSaveDirectory()
	{
		File lastDir = new File(lastSaveDirectory);
		if(lastDir.getParentFile() != null && lastDir.getParentFile().exists())
			return lastDir;
		
		try
		{
			return new File(".").getCanonicalFile();
		}
		catch (IOException e)
		{
			return new File(".");
		}
	}
	
	public static File getLastPluginDirectory()
	{
		File lastDir = new File(lastPluginDirectory);
		
		if(lastDir.getParentFile() != null && lastDir.getParentFile().exists())
			return lastDir;
		
		return new File(".");
	}
	
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/Constants.java`:

```java
package the.bytecode.club.bytecodeviewer;

import java.io.File;
import java.io.PrintStream;
import org.objectweb.asm.Opcodes;
import the.bytecode.club.bytecodeviewer.resources.ResourceType;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * General program constants, to use this class include everything as a wildcard static import:
 *      import static the.bytecode.club.bytecodeviewer.Constants.*;
 *
 * @author Konloch
 * @since 6/21/2021
 */
public class Constants
{
	/*per version*/
	public static String krakatauVersion = "12";
	public static String enjarifyVersion = "4";
	
	//if true this disables testing code for tabs
	//until dragging and full right-click menu support is added this is
	//a starting point
	public static final boolean BLOCK_TAB_MENU = true;
	
	//if true this will attempt to launch the decompilers in a new JVM process
	//the pro's to this are:
	//      + You can control the java arguments (more memory & stack)
	//the cons to this are:
	//      + If you could keep it in memory, now you need to write to disk (windows limitations)
	public static final boolean LAUNCH_DECOMPILERS_IN_NEW_PROCESS = false; //TODO
	
	//could be automatic by checking if it's loaded a class named whatever for a library
	//maybe it could be automatic with some maven plugin?
	public static final boolean FAT_JAR = true;
	
	//the automatic updater
	//SHADED_LIBRARIES must be false for the boot loader to startup
	//TODO this needs to be changed to support maven
	public static final boolean AUTOMATIC_LIBRARY_UPDATING = false;
	
	//version is set via maven
	public static final String VERSION = getVersion(BytecodeViewer.class.getPackage().getImplementationVersion());
	//dev mode is just a check for running via IDE
	public static boolean DEV_MODE;
	
	//if true the version checker will prompt and ask how you would like to proceed
	public static final boolean FORCE_VERSION_CHECKER_PROMPT = false;
	
	public static final String fs = System.getProperty("file.separator");
	public static final String nl = System.getProperty("line.separator");
	
	//TODO check if $HOME/.local/share exists, if so reference from there instead - #250
	public static final File BCVDir = new File(System.getProperty("user.home") + fs + ".Bytecode-Viewer");
	public static final File RT_JAR = new File(System.getProperty("java.home") + fs + "lib" + fs + "rt.jar");
	public static final File JAVA_BINARY = new File(System.getProperty("java.home") + fs + "bin" + fs + "java.exe");
	public static final File JAVA_BINARY_NIX = new File(System.getProperty("java.home") + fs + "bin" + fs + "java");
	public static final File RT_JAR_DUMPED = new File(getBCVDirectory() + fs + "rt.jar");
	public static final String filesName = getBCVDirectory() + fs + "recentfiles.json";
	public static final String pluginsName = getBCVDirectory() + fs + "recentplugins.json";
	public static final String settingsName = getBCVDirectory() + fs + "settings.bcv";
	public static final String tempDirectory = getBCVDirectory() + fs + "bcv_temp" + fs;
	public static final String systemTempDirectory = System.getProperty("java.io.tmpdir");
	public static final String libsDirectory = getBCVDirectory() + fs + "libs" + fs;
	public static String krakatauWorkingDirectory = getBCVDirectory() + fs + "krakatau_" + krakatauVersion;
	public static String enjarifyWorkingDirectory = getBCVDirectory() + fs + "enjarify_" + enjarifyVersion;
	public static final String[] SUPPORTED_FILE_EXTENSIONS = ResourceType.supportedBCVExtensionMap.keySet().toArray(new String[0]);
	public static final int ASM_VERSION = Opcodes.ASM9;
	
	public static final PrintStream ERR = System.err;
	public static final PrintStream OUT = System.out;
	
	/**
	 * Returns the BCV directory
	 *
	 * @return the static BCV directory
	 */
	public static String getBCVDirectory()
	{
		while (!BCVDir.exists())
			BCVDir.mkdirs();
		
		//hides the BCV directory
		if (isWindows() && !BCVDir.isHidden())
		{
			new Thread(()->{
				try {
					// Hide file by running attrib system command (on Windows)
					Process p = new ProcessBuilder("attrib",
							"+H",
							BCVDir.getAbsolutePath()).start();
				} catch (Exception e) {
					//ignore
				}
			}, "Hide BCV Dir").start();
		}
		
		return BCVDir.getAbsolutePath();
	}
	
	/**
	 * Checks if the OS contains 'win'
	 *
	 * @return true if the os.name property contains 'win'
	 */
	private static boolean isWindows()
	{
		return System.getProperty("os.name").toLowerCase().contains("win");
	}
	
	/**
	 * Detects developer mode or returns the current version
	 */
	public static String getVersion(String mavenVersion)
	{
		if(FORCE_VERSION_CHECKER_PROMPT)
			return "1.0.0";
		
		if(mavenVersion == null)
		{
			DEV_MODE = true;
			return "Developer Mode";
		}
		
		return mavenVersion;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/GlobalHotKeys.java`:

```java
package the.bytecode.club.bytecodeviewer;

import java.awt.event.KeyEvent;
import java.io.File;
import javax.swing.JFileChooser;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.gui.components.RunOptions;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Whenever a key is pressed on the swing UI it should get logged here
 *
 * @author Konloch
 * @since 7/6/2021
 */
public class GlobalHotKeys
{
	/**
	 * Checks the hotkeys
	 */
	public static void keyPressed(KeyEvent e)
	{
		if (System.currentTimeMillis() - Configuration.lastHotKeyExecuted <= (600))
			return;
		
		//CTRL + O
		//open resource
		if ((e.getKeyCode() == KeyEvent.VK_O) && ((e.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
		{
			Configuration.lastHotKeyExecuted = System.currentTimeMillis();
			
			final File file = DialogUtils.fileChooser("Select File or Folder to open in BCV",
					"APKs, DEX, Class Files or Zip/Jar/War Archives",
					Constants.SUPPORTED_FILE_EXTENSIONS);
			
			if(file == null)
				return;
			
			BytecodeViewer.updateBusyStatus(true);
			BytecodeViewer.openFiles(new File[]{file}, true);
			BytecodeViewer.updateBusyStatus(false);
		}
		
		//CTRL + N
		//new workspace
		else if ((e.getKeyCode() == KeyEvent.VK_N) && ((e.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
		{
			Configuration.lastHotKeyExecuted = System.currentTimeMillis();
			BytecodeViewer.resetWorkspace(true);
		}
		
		//CTRL + T
		//compile
		else if ((e.getKeyCode() == KeyEvent.VK_T) && ((e.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
		{
			Configuration.lastHotKeyExecuted = System.currentTimeMillis();
			Thread t = new Thread(() -> BytecodeViewer.compile(true, false), "Compile");
			t.start();
		}
		
		//CTRL + R
		//Run remote code
		else if ((e.getKeyCode() == KeyEvent.VK_R) && ((e.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
		{
			Configuration.lastHotKeyExecuted = System.currentTimeMillis();
			
			if (BytecodeViewer.promptIfNoLoadedClasses())
				return;
			
			new RunOptions().setVisible(true);
		}
		
		//CTRL + S
		//Export resources
		else if ((e.getKeyCode() == KeyEvent.VK_S) && ((e.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
		{
			Configuration.lastHotKeyExecuted = System.currentTimeMillis();
			
			if (BytecodeViewer.promptIfNoLoadedResources())
				return;
			
			Thread resourceExport = new Thread(() ->
			{
				if (!BytecodeViewer.autoCompileSuccessful())
					return;
				
				JFileChooser fc = new FileChooser(Configuration.getLastSaveDirectory(),
						"Select Zip Export",
						"Zip Archives",
						"zip");
				
				int returnVal = fc.showSaveDialog(BytecodeViewer.viewer);
				if (returnVal == JFileChooser.APPROVE_OPTION)
				{
					Configuration.setLastSaveDirectory(fc.getSelectedFile());
					
					File file = MiscUtils.autoAppendFileExtension(".zip", fc.getSelectedFile());
					
					if (!DialogUtils.canOverwriteFile(file))
						return;
					
					BytecodeViewer.updateBusyStatus(true);
					Thread jarExport = new Thread(() -> {
						JarUtils.saveAsJar(BytecodeViewer.getLoadedClasses(),
								file.getAbsolutePath());
						BytecodeViewer.updateBusyStatus(false);
					}, "Jar Export");
					jarExport.start();
				}
			}, "Resource Export");
			resourceExport.start();
		}
		
		//CTRL + W
		//close active resource (currently opened tab)
		else if ((e.getKeyCode() == KeyEvent.VK_W) && ((e.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
		{
			Configuration.lastHotKeyExecuted = System.currentTimeMillis();
			
			if (BytecodeViewer.hasActiveResource())
				BytecodeViewer.viewer.workPane.tabs.remove(BytecodeViewer.viewer.workPane.getActiveResource());
		}
		
		//CTRL + L
		//open last opened resource
		else if ((e.getKeyCode() == KeyEvent.VK_L) && ((e.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
		{
			Configuration.lastHotKeyExecuted = System.currentTimeMillis();
			
			String recentFile = Settings.getRecentFile();
			
			if(!BytecodeViewer.hasResources() && recentFile != null)
			{
				File file = new File(recentFile);
				if(file.exists())
				{
					BytecodeViewer.openFiles(new File[]{file}, false);
				}
				else
				{
					BytecodeViewer.showMessage("The file " + file.getAbsolutePath() + " could not be found.");
					Settings.removeRecentFile(file);
				}
			}
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/Settings.java`:

```java
package the.bytecode.club.bytecodeviewer;

import com.google.gson.reflect.TypeToken;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JMenuItem;
import me.konloch.kontainer.io.DiskReader;
import me.konloch.kontainer.io.DiskWriter;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.BytecodeViewer.gson;
import static the.bytecode.club.bytecodeviewer.Configuration.maxRecentFiles;
import static the.bytecode.club.bytecodeviewer.Constants.filesName;
import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.getBCVDirectory;
import static the.bytecode.club.bytecodeviewer.Constants.pluginsName;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/29/2021
 */
public class Settings
{
	public static boolean firstBoot = true; //stays true after settings load on first boot
	public static boolean hasSetLanguageAsSystemLanguage = false;
	private static List<String> recentPlugins;
	private static List<String> recentFiles;
	
	static
	{
		try
		{
			if (new File(filesName).exists())
				recentFiles = gson.fromJson(DiskReader.loadAsString(filesName), new TypeToken<ArrayList<String>>() {}.getType());
			else
				recentFiles = DiskReader.loadArrayList(getBCVDirectory() + fs + "recentfiles.bcv", false);
			
			if (new File(pluginsName).exists())
				recentPlugins = gson.fromJson(DiskReader.loadAsString(pluginsName), new TypeToken<ArrayList<String>>() {}.getType());
			else
				recentPlugins = DiskReader.loadArrayList(getBCVDirectory() + fs + "recentplugins.bcv", false);
			
			MiscUtils.deduplicateAndTrim(recentFiles, maxRecentFiles);
			MiscUtils.deduplicateAndTrim(recentPlugins, maxRecentFiles);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
	
	/**
	 * Add the recent file
	 *
	 * @param f the recent file
	 */
	public static synchronized void addRecentFile(File f)
	{
		recentFiles.remove(f.getAbsolutePath()); // already added on the list
		recentFiles.add(0, f.getAbsolutePath());
		MiscUtils.deduplicateAndTrim(recentFiles, maxRecentFiles);
		DiskWriter.replaceFile(filesName, MiscUtils.listToString(recentFiles), false);
		resetRecentFilesMenu();
	}
	
	public static synchronized void removeRecentFile(File f)
	{
		if(recentFiles.remove(f.getAbsolutePath()))
		{
			DiskWriter.replaceFile(filesName, MiscUtils.listToString(recentFiles), false);
			resetRecentFilesMenu();
		}
	}
	
	public static String getRecentFile()
	{
		if(recentFiles.isEmpty())
			return null;
		
		return recentFiles.get(0);
	}
	
	/**
	 * Add to the recent plugin list
	 *
	 * @param f the plugin file
	 */
	public static synchronized void addRecentPlugin(File f)
	{
		recentPlugins.remove(f.getAbsolutePath()); // already added on the list
		recentPlugins.add(0, f.getAbsolutePath());
		MiscUtils.deduplicateAndTrim(recentPlugins, maxRecentFiles);
		DiskWriter.replaceFile(pluginsName, MiscUtils.listToString(recentPlugins), false);
		resetRecentFilesMenu();
	}
	
	public static synchronized void removeRecentPlugin(File f)
	{
		if(recentPlugins.remove(f.getAbsolutePath()))
		{
			DiskWriter.replaceFile(pluginsName, MiscUtils.listToString(recentPlugins), false);
			resetRecentFilesMenu();
		}
	}
	
	/**
	 * resets the recent files menu
	 */
	protected static void resetRecentFilesMenu()
	{
		//build recent files
		BytecodeViewer.viewer.recentFilesSecondaryMenu.removeAll();
		for (String s : recentFiles)
		{
			if (!s.isEmpty())
			{
				JMenuItem m = new JMenuItem(s);
				m.addActionListener(e ->
				{
					JMenuItem m12 = (JMenuItem) e.getSource();
					BytecodeViewer.openFiles(new File[]{new File(m12.getText())}, true);
				});
				BytecodeViewer.viewer.recentFilesSecondaryMenu.add(m);
			}
		}
		
		//build recent plugins
		BytecodeViewer.viewer.recentPluginsSecondaryMenu.removeAll();
		for (String s : recentPlugins)
		{
			if (!s.isEmpty())
			{
				JMenuItem m = new JMenuItem(s);
				m.addActionListener(e ->
				{
					JMenuItem m1 = (JMenuItem) e.getSource();
					BytecodeViewer.startPlugin(new File(m1.getText()));
				});
				BytecodeViewer.viewer.recentPluginsSecondaryMenu.add(m);
			}
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/SettingsSerializer.java`:

```java
package the.bytecode.club.bytecodeviewer;

import java.io.File;
import javax.swing.JFrame;
import me.konloch.kontainer.io.DiskReader;
import me.konloch.kontainer.io.DiskWriter;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.theme.LAFTheme;
import the.bytecode.club.bytecodeviewer.gui.theme.RSTATheme;
import the.bytecode.club.bytecodeviewer.translation.Language;

import static the.bytecode.club.bytecodeviewer.Constants.VERSION;
import static the.bytecode.club.bytecodeviewer.Constants.settingsName;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Used to handle loading/saving the GUI (options).
 *
 * @author Konloch
 */

public class SettingsSerializer
{
    private static boolean settingsFileExists;
    
    public static void saveSettingsAsync()
    {
        Thread saveThread = new Thread(SettingsSerializer::saveSettings, "Save Settings");
        saveThread.start();
    }
    
    public static synchronized void saveSettings()
    {
        try
        {
            DiskWriter.replaceFile(settingsName, "BCV: " + VERSION, false);
            save(BytecodeViewer.viewer.rbr.isSelected());
            save(BytecodeViewer.viewer.rsy.isSelected());
            save(BytecodeViewer.viewer.din.isSelected());
            save(BytecodeViewer.viewer.dc4.isSelected());
            save(BytecodeViewer.viewer.das.isSelected());
            save(BytecodeViewer.viewer.hes.isSelected());
            save(BytecodeViewer.viewer.hdc.isSelected());
            save(BytecodeViewer.viewer.dgs.isSelected());
            save(BytecodeViewer.viewer.ner.isSelected());
            save(BytecodeViewer.viewer.den.isSelected());
            save(BytecodeViewer.viewer.rgn.isSelected());
            save(BytecodeViewer.viewer.bto.isSelected());
            save(BytecodeViewer.viewer.nns.isSelected());
            save(BytecodeViewer.viewer.uto.isSelected());
            save(BytecodeViewer.viewer.udv.isSelected());
            save(BytecodeViewer.viewer.rer.isSelected());
            save(BytecodeViewer.viewer.fdi.isSelected());
            save(BytecodeViewer.viewer.asc.isSelected());
            save(BytecodeViewer.viewer.decodeEnumSwitch.isSelected());
            save(BytecodeViewer.viewer.sugarEnums.isSelected());
            save(BytecodeViewer.viewer.decodeStringSwitch.isSelected());
            save(BytecodeViewer.viewer.arrayiter.isSelected());
            save(BytecodeViewer.viewer.collectioniter.isSelected());
            save(BytecodeViewer.viewer.innerClasses.isSelected());
            save(BytecodeViewer.viewer.removeBoilerPlate.isSelected());
            save(BytecodeViewer.viewer.removeInnerClassSynthetics.isSelected());
            save(BytecodeViewer.viewer.decodeLambdas.isSelected());
            save(BytecodeViewer.viewer.hideBridgeMethods.isSelected());
            save(BytecodeViewer.viewer.liftConstructorInit.isSelected());
            save(BytecodeViewer.viewer.removeDeadMethods.isSelected());
            save(BytecodeViewer.viewer.removeBadGenerics.isSelected());
            save(BytecodeViewer.viewer.sugarAsserts.isSelected());
            save(BytecodeViewer.viewer.sugarBoxing.isSelected());
            save(BytecodeViewer.viewer.showVersion.isSelected());
            save(BytecodeViewer.viewer.decodeFinally.isSelected());
            save(BytecodeViewer.viewer.tidyMonitors.isSelected());
            save(BytecodeViewer.viewer.lenient.isSelected());
            save(BytecodeViewer.viewer.dumpClassPath.isSelected());
            save(BytecodeViewer.viewer.comments.isSelected());
            save(BytecodeViewer.viewer.forceTopSort.isSelected());
            save(BytecodeViewer.viewer.forceTopSortAggress.isSelected());
            save(BytecodeViewer.viewer.stringBuffer.isSelected());
            save(BytecodeViewer.viewer.stringBuilder.isSelected());
            save(BytecodeViewer.viewer.silent.isSelected());
            save(BytecodeViewer.viewer.recover.isSelected());
            save(BytecodeViewer.viewer.eclipse.isSelected());
            save(BytecodeViewer.viewer.override.isSelected());
            save(BytecodeViewer.viewer.showInferrable.isSelected());
            save(BytecodeViewer.viewer.aexagg.isSelected());
            save(BytecodeViewer.viewer.forceCondPropagate.isSelected());
            save(BytecodeViewer.viewer.hideUTF.isSelected());
            save(BytecodeViewer.viewer.hideLongStrings.isSelected());
            save(BytecodeViewer.viewer.commentMonitor.isSelected());
            save(BytecodeViewer.viewer.allowCorrecting.isSelected());
            save(BytecodeViewer.viewer.labelledBlocks.isSelected());
            save(BytecodeViewer.viewer.j14ClassOBJ.isSelected());
            save(BytecodeViewer.viewer.hideLangImports.isSelected());
            save(BytecodeViewer.viewer.recoveryTypeClash.isSelected());
            save(BytecodeViewer.viewer.recoveryTypehInts.isSelected());
            save(BytecodeViewer.viewer.forceTurningIFs.isSelected());
            save(BytecodeViewer.viewer.forLoopAGGCapture.isSelected());
            save(BytecodeViewer.viewer.forceExceptionPrune.isSelected());
            save(BytecodeViewer.viewer.showDebugLineNumbers.isSelected());
            save(BytecodeViewer.viewer.simplifyMemberReferences.isSelected());
            save(BytecodeViewer.viewer.mergeVariables.isSelected());
            save(BytecodeViewer.viewer.unicodeOutputEnabled.isSelected());
            save(BytecodeViewer.viewer.retainPointlessSwitches.isSelected());
            save(BytecodeViewer.viewer.includeLineNumbersInBytecode.isSelected());
            save(BytecodeViewer.viewer.includeErrorDiagnostics.isSelected());
            save(BytecodeViewer.viewer.retainRedunantCasts.isSelected());
            save(BytecodeViewer.viewer.alwaysGenerateExceptionVars.isSelected());
            save(BytecodeViewer.viewer.showSyntheticMembers.isSelected());
            save(BytecodeViewer.viewer.forceExplicitTypeArguments.isSelected());
            save(BytecodeViewer.viewer.forceExplicitImports.isSelected());
            save(BytecodeViewer.viewer.flattenSwitchBlocks.isSelected());
            save(BytecodeViewer.viewer.excludeNestedTypes.isSelected());
            save(BytecodeViewer.viewer.appendBracketsToLabels.isSelected());
            save(BytecodeViewer.viewer.debugHelpers.isSelected());
            save("deprecated");
            save(BytecodeViewer.viewer.updateCheck.isSelected());
            save(BytecodeViewer.viewer.viewPane1.getSelectedDecompiler().ordinal());
            save(BytecodeViewer.viewer.viewPane2.getSelectedDecompiler().ordinal());
            save(BytecodeViewer.viewer.viewPane3.getSelectedDecompiler().ordinal());
            save(BytecodeViewer.viewer.refreshOnChange.isSelected());
            save(BytecodeViewer.viewer.isMaximized);
            save("deprecated");
            save("deprecated");
            save(Configuration.lastOpenDirectory);
            save(Configuration.python2);
            save(Configuration.rt);
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save(BytecodeViewer.viewer.decodeAPKResources.isSelected());
            save(Configuration.library);
            save(Configuration.pingback);
            save("deprecated");
            save("deprecated");
            save("deprecated");
            save(BytecodeViewer.viewer.getFontSize());
            save(Configuration.deleteForeignLibraries);
    
            if (BytecodeViewer.viewer.apkConversionGroup.isSelected(BytecodeViewer.viewer.apkConversionDex.getModel()))
                DiskWriter.writeNewLine(settingsName, "0");
            else if (BytecodeViewer.viewer.apkConversionGroup.isSelected(BytecodeViewer.viewer.apkConversionEnjarify.getModel()))
                DiskWriter.writeNewLine(settingsName, "1");
    
            save(Configuration.python3);
            save(Configuration.javac);
            save(Configuration.java);
            save(BytecodeViewer.viewer.compileOnSave.isSelected());
            save(BytecodeViewer.viewer.autoCompileOnRefresh.isSelected());
            save(Configuration.warnForEditing);
            save(BytecodeViewer.viewer.showFileInTabTitle.isSelected());
            save(BytecodeViewer.viewer.forcePureAsciiAsText.isSelected());
            save(BytecodeViewer.viewer.synchronizedViewing.isSelected());
            save(BytecodeViewer.viewer.showClassMethods.isSelected());
            save(BytecodeViewer.viewer.ren.isSelected());
            save("deprecated");
            
            save(Configuration.lafTheme.name());
            save(Configuration.rstaTheme.name());
            save(BytecodeViewer.viewer.simplifyNameInTabTitle.isSelected());
            save(Configuration.language.name());
            
            save(BytecodeViewer.viewer.viewPane1.isPaneEditable());
            save(BytecodeViewer.viewer.viewPane2.isPaneEditable());
            save(BytecodeViewer.viewer.viewPane3.isPaneEditable());
            
            save(Configuration.javaTools);
            save("deprecated");
            save("deprecated");
            save(Configuration.lastSaveDirectory);
            save(Configuration.lastPluginDirectory);
            save(Configuration.python2Extra);
            save(Configuration.python3Extra);
            save(BytecodeViewer.viewer.getMinSdkVersion());
            save(BytecodeViewer.viewer.printLineNumbers.isSelected());
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }
    
    /**
     * Preload data used to configure the looks and components of the application
     */
    public static void preloadSettingsFile()
    {
        try
        {
            settingsFileExists = new File(settingsName).exists();
            
            if(!settingsFileExists)
                return;
            
            //precache the file
            DiskReader.loadString(settingsName, 0, true);
            
            //process the cached file
            Configuration.lafTheme = LAFTheme.valueOf(asString(127));
            Configuration.rstaTheme = RSTATheme.valueOf(asString(128));
            //line 129 is used normal loading
            Configuration.language = Language.valueOf(asString(130));
        }
        catch (IndexOutOfBoundsException e)
        {
            //ignore because errors are expected, first start up and outdated settings.
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
    
    //utilizes the Disk Reader's caching system.
    public static void loadSettings()
    {
        if(!settingsFileExists)
            return;
        
        Settings.firstBoot = false;
        
        try
        {
            //parse the cached file from memory (from preload)
            BytecodeViewer.viewer.rbr.setSelected(asBoolean(1));
            BytecodeViewer.viewer.rsy.setSelected(asBoolean(2));
            BytecodeViewer.viewer.din.setSelected(asBoolean(3));
            BytecodeViewer.viewer.dc4.setSelected(asBoolean(4));
            BytecodeViewer.viewer.das.setSelected(asBoolean(5));
            BytecodeViewer.viewer.hes.setSelected(asBoolean(6));
            BytecodeViewer.viewer.hdc.setSelected(asBoolean(7));
            BytecodeViewer.viewer.dgs.setSelected(asBoolean(8));
            BytecodeViewer.viewer.ner.setSelected(asBoolean(9));
            BytecodeViewer.viewer.den.setSelected(asBoolean(10));
            BytecodeViewer.viewer.rgn.setSelected(asBoolean(11));
            BytecodeViewer.viewer.bto.setSelected(asBoolean(12));
            BytecodeViewer.viewer.nns.setSelected(asBoolean(13));
            BytecodeViewer.viewer.uto.setSelected(asBoolean(14));
            BytecodeViewer.viewer.udv.setSelected(asBoolean(15));
            BytecodeViewer.viewer.rer.setSelected(asBoolean(16));
            BytecodeViewer.viewer.fdi.setSelected(asBoolean(17));
            BytecodeViewer.viewer.asc.setSelected(asBoolean(18));
            BytecodeViewer.viewer.decodeEnumSwitch.setSelected(asBoolean(19));
            BytecodeViewer.viewer.sugarEnums.setSelected(asBoolean(20));
            BytecodeViewer.viewer.decodeStringSwitch.setSelected(asBoolean(21));
            BytecodeViewer.viewer.arrayiter.setSelected(asBoolean(22));
            BytecodeViewer.viewer.collectioniter.setSelected(asBoolean(23));
            BytecodeViewer.viewer.innerClasses.setSelected(asBoolean(24));
            BytecodeViewer.viewer.removeBoilerPlate.setSelected(asBoolean(25));
            BytecodeViewer.viewer.removeInnerClassSynthetics.setSelected(asBoolean(26));
            BytecodeViewer.viewer.decodeLambdas.setSelected(asBoolean(27));
            BytecodeViewer.viewer.hideBridgeMethods.setSelected(asBoolean(28));
            BytecodeViewer.viewer.liftConstructorInit.setSelected(asBoolean(29));
            BytecodeViewer.viewer.removeDeadMethods.setSelected(asBoolean(30));
            BytecodeViewer.viewer.removeBadGenerics.setSelected(asBoolean(31));
            BytecodeViewer.viewer.sugarAsserts.setSelected(asBoolean(32));
            BytecodeViewer.viewer.sugarBoxing.setSelected(asBoolean(33));
            BytecodeViewer.viewer.showVersion.setSelected(asBoolean(34));
            BytecodeViewer.viewer.decodeFinally.setSelected(asBoolean(35));
            BytecodeViewer.viewer.tidyMonitors.setSelected(asBoolean(36));
            BytecodeViewer.viewer.lenient.setSelected(asBoolean(37));
            BytecodeViewer.viewer.dumpClassPath.setSelected(asBoolean(38));
            BytecodeViewer.viewer.comments.setSelected(asBoolean(39));
            BytecodeViewer.viewer.forceTopSort.setSelected(asBoolean(40));
            BytecodeViewer.viewer.forceTopSortAggress.setSelected(asBoolean(41));
            BytecodeViewer.viewer.stringBuffer.setSelected(asBoolean(42));
            BytecodeViewer.viewer.stringBuilder.setSelected(asBoolean(43));
            BytecodeViewer.viewer.silent.setSelected(asBoolean(44));
            BytecodeViewer.viewer.recover.setSelected(asBoolean(45));
            BytecodeViewer.viewer.eclipse.setSelected(asBoolean(46));
            BytecodeViewer.viewer.override.setSelected(asBoolean(47));
            BytecodeViewer.viewer.showInferrable.setSelected(asBoolean(48));
            BytecodeViewer.viewer.aexagg.setSelected(asBoolean(49));
            BytecodeViewer.viewer.forceCondPropagate.setSelected(asBoolean(50));
            BytecodeViewer.viewer.hideUTF.setSelected(asBoolean(51));
            BytecodeViewer.viewer.hideLongStrings.setSelected(asBoolean(52));
            BytecodeViewer.viewer.commentMonitor.setSelected(asBoolean(53));
            BytecodeViewer.viewer.allowCorrecting.setSelected(asBoolean(54));
            BytecodeViewer.viewer.labelledBlocks.setSelected(asBoolean(55));
            BytecodeViewer.viewer.j14ClassOBJ.setSelected(asBoolean(56));
            BytecodeViewer.viewer.hideLangImports.setSelected(asBoolean(57));
            BytecodeViewer.viewer.recoveryTypeClash.setSelected(asBoolean(58));
            BytecodeViewer.viewer.recoveryTypehInts.setSelected(asBoolean(59));
            BytecodeViewer.viewer.forceTurningIFs.setSelected(asBoolean(60));
            BytecodeViewer.viewer.forLoopAGGCapture.setSelected(asBoolean(61));
            BytecodeViewer.viewer.forceExceptionPrune.setSelected(asBoolean(62));
            BytecodeViewer.viewer.showDebugLineNumbers.setSelected(asBoolean(63));
            BytecodeViewer.viewer.simplifyMemberReferences.setSelected(asBoolean(64));
            BytecodeViewer.viewer.mergeVariables.setSelected(asBoolean(65));
            BytecodeViewer.viewer.unicodeOutputEnabled.setSelected(asBoolean(66));
            BytecodeViewer.viewer.retainPointlessSwitches.setSelected(asBoolean(67));
            BytecodeViewer.viewer.includeLineNumbersInBytecode.setSelected(asBoolean(68));
            BytecodeViewer.viewer.includeErrorDiagnostics.setSelected(asBoolean(69));
            BytecodeViewer.viewer.retainRedunantCasts.setSelected(asBoolean(70));
            BytecodeViewer.viewer.alwaysGenerateExceptionVars.setSelected(asBoolean(71));
            BytecodeViewer.viewer.showSyntheticMembers.setSelected(asBoolean(72));
            BytecodeViewer.viewer.forceExplicitTypeArguments.setSelected(asBoolean(73));
            BytecodeViewer.viewer.forceExplicitImports.setSelected(asBoolean(74));
            BytecodeViewer.viewer.flattenSwitchBlocks.setSelected(asBoolean(75));
            BytecodeViewer.viewer.excludeNestedTypes.setSelected(asBoolean(76));
            BytecodeViewer.viewer.appendBracketsToLabels.setSelected(asBoolean(77));
            BytecodeViewer.viewer.debugHelpers.setSelected(asBoolean(78));
            //79 is deprecated
            BytecodeViewer.viewer.updateCheck.setSelected(asBoolean(80));
            BytecodeViewer.viewer.viewPane1.setSelectedDecompiler(Decompiler.values()[asInt(81)]);
            BytecodeViewer.viewer.viewPane2.setSelectedDecompiler(Decompiler.values()[asInt(82)]);
            BytecodeViewer.viewer.viewPane3.setSelectedDecompiler(Decompiler.values()[asInt(83)]);

            BytecodeViewer.viewer.refreshOnChange.setSelected(asBoolean(84));

            boolean bool = Boolean.parseBoolean(asString(85));
            if (bool) {
                BytecodeViewer.viewer.setExtendedState(JFrame.MAXIMIZED_BOTH);
                BytecodeViewer.viewer.isMaximized = true;
            }
            //86 is deprecated
            //87 is deprecated
            Configuration.lastOpenDirectory = asString(88);
            Configuration.python2 = asString(89);
            Configuration.rt = asString(90);
            
            BytecodeViewer.viewer.decodeAPKResources.setSelected(asBoolean(106));
            Configuration.library = asString(107);
            Configuration.pingback = asBoolean(108);
            
            BytecodeViewer.viewer.fontSpinner.setValue(asInt(112));
            Configuration.deleteForeignLibraries = asBoolean(113);
            
            //APK Decompiler
            switch(asInt(114))
            {
                case 0:
                    BytecodeViewer.viewer.apkConversionGroup.setSelected(BytecodeViewer.viewer.apkConversionDex.getModel(), true);
                    break;
                case 1:
                    BytecodeViewer.viewer.apkConversionGroup.setSelected(BytecodeViewer.viewer.apkConversionEnjarify.getModel(), true);
                    break;
            }
    
            Configuration.python3 = asString(115);
            Configuration.javac = asString(116);
            Configuration.java = asString(117);
            BytecodeViewer.viewer.compileOnSave.setSelected(asBoolean(118));
            BytecodeViewer.viewer.autoCompileOnRefresh.setSelected(asBoolean(119));
            Configuration.warnForEditing = asBoolean(120);
            BytecodeViewer.viewer.showFileInTabTitle.setSelected(asBoolean(121));
            Configuration.displayParentInTab = BytecodeViewer.viewer.showFileInTabTitle.isSelected();
            BytecodeViewer.viewer.forcePureAsciiAsText.setSelected(asBoolean(122));
            BytecodeViewer.viewer.synchronizedViewing.setSelected(asBoolean(123));
            BytecodeViewer.viewer.showClassMethods.setSelected(asBoolean(124));
            BytecodeViewer.viewer.ren.setSelected(asBoolean(125));
            //line 126 is deprecated
            //line 127 is used for theme on preload
            //line 128 is used for theme on preload
            BytecodeViewer.viewer.simplifyNameInTabTitle.setSelected(asBoolean(129));
            Configuration.simplifiedTabNames = BytecodeViewer.viewer.simplifyNameInTabTitle.isSelected();
            
            //line 130 is used for preload
            if(Configuration.language != Language.ENGLISH)
                Configuration.language.setLanguageTranslations(); //load language translations
            Settings.hasSetLanguageAsSystemLanguage = true;
            
            BytecodeViewer.viewer.viewPane1.setPaneEditable(asBoolean(131));
            BytecodeViewer.viewer.viewPane2.setPaneEditable(asBoolean(132));
            BytecodeViewer.viewer.viewPane3.setPaneEditable(asBoolean(133));
            
            Configuration.javaTools = asString(134);
            //ignore 135
            //ignore 136
            Configuration.lastSaveDirectory = asString(137);
            Configuration.lastPluginDirectory = asString(138);
            Configuration.python2Extra = asBoolean(139);
            Configuration.python3Extra = asBoolean(140);
            BytecodeViewer.viewer.minSdkVersionSpinner.setValue(asInt(141));
            BytecodeViewer.viewer.printLineNumbers.setSelected(asBoolean(142));
        }
        catch (IndexOutOfBoundsException e)
        {
            //ignore because errors are expected, first start up and outdated settings.
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
    
    public static void save(Object o)
    {
        DiskWriter.writeNewLine(settingsName, String.valueOf(o), false);
    }
    
    public static String asString(int lineNumber) throws Exception
    {
        return DiskReader.loadString(settingsName, lineNumber, false);
    }
    
    public static boolean asBoolean(int lineNumber) throws Exception
    {
        return Boolean.parseBoolean(DiskReader.loadString(settingsName, lineNumber, false));
    }
    
    public static int asInt(int lineNumber) throws Exception
    {
        return Integer.parseInt(DiskReader.loadString(settingsName, lineNumber, false));
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/api/ASMResourceUtil.java`:

```java
package the.bytecode.club.bytecodeviewer.api;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InnerClassNode;
import org.objectweb.asm.tree.LocalVariableNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Used to interact with classnodes loaded inside of BCV as resources
 *
 * @author Konloch
 */

public final class ASMResourceUtil
{
    /**
     * Attempts to a method main inside of the loaded resources and returns the fully qualified name
     */
    public static String findMainMethod(String defaultFQN)
    {
        for (ClassNode cn : BytecodeViewer.getLoadedClasses())
        {
            for (Object o : cn.methods.toArray())
            {
                MethodNode m = (MethodNode) o;
    
                if (m.name.equals("main") && m.desc.equals("([Ljava/lang/String;)V"))
                {
                    return cn.name + "." + m.name;
                }
            }
        }
        
        return defaultFQN;
    }

    public static void renameFieldNode(String originalParentName,
                                       String originalFieldName, String originalFieldDesc,
                                       String newFieldParent, String newFieldName, String newFieldDesc)
    {
        for (ClassNode c : BytecodeViewer.getLoadedClasses())
        {
            for (Object o : c.methods.toArray())
            {
                MethodNode m = (MethodNode) o;
                for (AbstractInsnNode i : m.instructions.toArray())
                {
                    if (i instanceof FieldInsnNode)
                    {
                        FieldInsnNode field = (FieldInsnNode) i;

                        if (field.owner.equals(originalParentName)
                                && field.name.equals(originalFieldName)
                                && field.desc.equals(originalFieldDesc))
                        {
                            if (newFieldParent != null)
                                field.owner = newFieldParent;
                            if (newFieldName != null)
                                field.name = newFieldName;
                            if (newFieldDesc != null)
                                field.desc = newFieldDesc;
                        }
                    }
                }
            }
        }
    }

    public static void renameMethodNode(String originalParentName,
                                        String originalMethodName, String originalMethodDesc,
                                        String newParent, String newName, String newDesc)
    {
        for (ClassNode c : BytecodeViewer.getLoadedClasses())
        {
            for (Object o : c.methods.toArray())
            {
                MethodNode m = (MethodNode) o;
                for (AbstractInsnNode i : m.instructions.toArray())
                {
                    if (i instanceof MethodInsnNode)
                    {
                        MethodInsnNode mi = (MethodInsnNode) i;
                        if (mi.owner.equals(originalParentName)
                                && mi.name.equals(originalMethodName)
                                && mi.desc.equals(originalMethodDesc))
                        {
                            if (newParent != null)
                                mi.owner = newParent;
                            if (newName != null)
                                mi.name = newName;
                            if (newDesc != null)
                                mi.desc = newDesc;
                        }
                    } /*else {
                        System.out.println(i.getOpcode()+":"+c.name+":"+m.name);
                    }*/
                }

                if (m.signature != null)
                {
                    if (newName != null)
                        m.signature = m.signature.replace(originalMethodName,
                                newName);
                    if (newParent != null)
                        m.signature = m.signature.replace(originalParentName,
                                newParent);
                }

                if (m.name.equals(originalMethodName)
                        && m.desc.equals(originalMethodDesc)
                        && c.name.equals(originalParentName))
                {
                    if (newName != null)
                        m.name = newName;
                    if (newDesc != null)
                        m.desc = newDesc;
                }
            }
        }
    }

    public static void renameClassNode(final String oldName,
                                       final String newName)
    {
        for (ClassNode c : BytecodeViewer.getLoadedClasses())
        {
            for (InnerClassNode oo : c.innerClasses)
            {
                if (oo.innerName != null && oo.innerName.equals(oldName))
                    oo.innerName = newName;
                
                if (oo.name.equals(oldName))
                    oo.name = newName;
                
                if (oo.outerName != null && oo.outerName.equals(oldName))
                    oo.outerName = newName;
            }

            if (c.signature != null)
                c.signature = c.signature.replace(oldName, newName);

            if (c.superName.equals(oldName))
                c.superName = newName;
            
            for (Object o : c.fields.toArray())
            {
                FieldNode f = (FieldNode) o;
                f.desc = f.desc.replace(oldName, newName);
            }
            
            for (Object o : c.methods.toArray())
            {
                MethodNode m = (MethodNode) o;

                if (m.localVariables != null)
                    for (LocalVariableNode node : m.localVariables)
                        node.desc = node.desc.replace(oldName, newName);

                if (m.signature != null)
                    m.signature = m.signature.replace(oldName, newName);

                for (int i = 0; i < m.exceptions.size(); i++)
                    if (m.exceptions.get(i).equals(oldName))
                        m.exceptions.set(i, newName);

                for (AbstractInsnNode i : m.instructions.toArray())
                {
                    if (i instanceof TypeInsnNode)
                    {
                        TypeInsnNode t = (TypeInsnNode) i;
                        if (t.desc.equals(oldName))
                            t.desc = newName;
                    }
                    
                    if (i instanceof MethodInsnNode)
                    {
                        MethodInsnNode mi = (MethodInsnNode) i;
                        if (mi.owner.equals(oldName))
                            mi.owner = newName;
                        mi.desc = mi.desc.replace(oldName, newName);
                    }
                    if (i instanceof FieldInsnNode)
                    {
                        FieldInsnNode fi = (FieldInsnNode) i;
                        if (fi.owner.equals(oldName))
                            fi.owner = newName;
                        fi.desc = fi.desc.replace(oldName, newName);
                    }
                }
            }
        }
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/api/ASMUtil.java`:

```java
package the.bytecode.club.bytecodeviewer.api;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public class ASMUtil
{
	/**
	 * Creates a new ClassNode instances from the provided byte[]
	 */
	public static ClassNode bytesToNode(final byte[] b)
	{
		ClassReader cr = new ClassReader(b);
		ClassNode cn = new ClassNode();
		try {
			cr.accept(cn, ClassReader.EXPAND_FRAMES);
		} catch (Exception e) {
			cr.accept(cn, ClassReader.SKIP_FRAMES);
		}
		return cn;
	}
	
	/**
	 * Writes a valid byte[] from the provided classnode
	 */
	public static byte[] nodeToBytes(ClassNode cn)
	{
		final ClassWriter cw = new ClassWriter(0);
		
		try {
			cn.accept(cw);
		} catch (Exception e) {
			e.printStackTrace();
			try {
				Thread.sleep(200);
				cn.accept(cw);
			} catch (InterruptedException ignored) { }
		}
		
		return cw.toByteArray();
	}
	
	public static MethodNode getMethodByName(ClassNode cn, String name)
	{
		for(MethodNode m : cn.methods)
		{
			if(m.name.equals(name))
				return m;
		}
		
		return null;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/api/BCV.java`:

```java
package the.bytecode.club.bytecodeviewer.api;

import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Objects;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import javax.swing.JFrame;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.compilers.Compiler;
import the.bytecode.club.bytecodeviewer.compilers.InternalCompiler;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.EZInjection;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.DEV_MODE;
import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * An easier to use version of the BCV API, this is designed for anyone who wants to extend BCV, in any shape
 * or form. One way of doing that is through the plugin system.
 *
 * @author Konloch
 */
public class BCV
{
    private static ClassNodeLoader loader = new ClassNodeLoader();
    private static URLClassLoader cl;

    /**
     * Grab the loader instance
     *
     * @return
     */
    public static ClassNodeLoader getClassNodeLoader() {
        return loader;
    }

    /**
     * Returns the URLClassLoader instance
     *
     * @return the URLClassLoader instance
     */
    public static URLClassLoader getClassLoaderInstance() {
        return cl;
    }

    /**
     * Re-instances the URLClassLoader and loads a jar to it.
     *
     * @return The loaded classes into the new URLClassLoader instance
     * @author Cafebabe
     */
    public static Class<?> loadClassIntoClassLoader(ClassNode cn)
    {
        if(cn == null)
            return null;
        
        getClassNodeLoader().addClass(cn);
    
        try
        {
            //TODO this should be rebuilding the class loader each time a new resource has been added or removed
            if(cl == null)
                loadClassesIntoClassLoader();
            
            return cl.loadClass(cn.name);
        } catch (Exception classLoadException) {
            the.bytecode.club.bytecodeviewer.BytecodeViewer.handleException(classLoadException);
        }
        
        return null;
    }
    
    /**
     * This shotgun approach will class-load all the classes that have been imported into BCV.
     *
     * @return A list with the Class objects of the successfully loaded classes.
     */
    public static List<Class<?>> loadClassesIntoClassLoader()
    {
        try
        {
            File f = new File(tempDirectory + fs + MiscUtils.randomString(12) + "loaded_temp.jar");
            List<Class<?>> ret = new ArrayList<>();
            
            JarUtils.saveAsJar(BCV.getLoadedClasses(), f.getAbsolutePath());
            try (JarFile jarFile = new JarFile("" + f.getAbsolutePath())) {

                Enumeration<JarEntry> e = jarFile.entries();
                URL[] urls = {new URL("jar:file:" + "" + f.getAbsolutePath() + "!/")};

                cl = URLClassLoader.newInstance(urls);

                while (e.hasMoreElements()) {
                    JarEntry je = e.nextElement();

                    if (je.isDirectory() || !je.getName().endsWith(".class"))
                        continue;

                    String className = je.getName().replace("/", ".").replace(".class", "");
                    className = className.replace('/', '.');

                    try {
                        ret.add(cl.loadClass(className));
                    } catch (Exception classLoadException) {
                        the.bytecode.club.bytecodeviewer.BytecodeViewer.handleException(classLoadException);
                    }
                }
            }

            return ret;
        } catch (Exception e) {
            the.bytecode.club.bytecodeviewer.BytecodeViewer.handleException(e);
        }
        return null;
    }

    /**
     * Creates a new instance of the ClassNode loader.
     */
    public static void createNewClassNodeLoaderInstance() {
        loader.clear();
        loader = new ClassNodeLoader();
    }

    /**
     * Used to start a plugin from file.
     *
     * @param plugin the file of the plugin
     */
    public static void startPlugin(File plugin) {
        the.bytecode.club.bytecodeviewer.BytecodeViewer.startPlugin(plugin);
    }

    /**
     * Used to load classes/jars into BCV.
     *
     * @param files       an array of the files you want loaded.
     * @param recentFiles if it should save to the recent files menu.
     */
    public static void openFiles(File[] files, boolean recentFiles) {
        the.bytecode.club.bytecodeviewer.BytecodeViewer.openFiles(files, recentFiles);
    }

    /**
     * Returns the currently opened class node, if nothing is opened it'll return null.
     *
     * @return The opened class node or a null if nothing is opened
     */
    public static ClassNode getCurrentlyOpenedClassNode() {
        return the.bytecode.club.bytecodeviewer.BytecodeViewer.getCurrentlyOpenedClassNode();
    }
    
    /**
     * Returns the currently opened class nodes ClassFile bytes
     *
     * @return The ClassFile bytes for the actively opened resource
     */
    public static byte[] getCurrentlyOpenedClassNodeBytes()
    {
        final ClassNode cn = BytecodeViewer.getCurrentlyOpenedClassNode();
        final ClassWriter cw = new ClassWriter(0);
    
        try {
            Objects.requireNonNull(cn).accept(cw);
        } catch (Exception e) {
            e.printStackTrace();
            try {
                Thread.sleep(200);
                Objects.requireNonNull(cn).accept(cw);
            } catch (InterruptedException ignored) {
            }
        }
        
        return cw.toByteArray();
    }
    
    /**
     * This decompiles the actively opened ClassFile inside of BCV.
     *
     * @param decompiler The decompiler you would like to use
     * @return The Ascii/text representation of the class node from the decompiler provided
     */
    public static String decompileCurrentlyOpenedClassNode(Decompiler decompiler)
    {
        return decompiler.getDecompiler().decompileClassNode(BCV.getCurrentlyOpenedClassNode(), BCV.getCurrentlyOpenedClassNodeBytes());
    }

    /**
     * Used to load a ClassNode.
     *
     * @param name the full name of the ClassNode
     * @return the ClassNode
     */
    public static ClassNode getClassNode(String name) {
        return the.bytecode.club.bytecodeviewer.BytecodeViewer
                .blindlySearchForClassNode(name);
    }

    /**
     * Used to grab the loaded ClassNodes.
     *
     * @return the loaded classes
     */
    public static List<ClassNode> getLoadedClasses() {
        return the.bytecode.club.bytecodeviewer.BytecodeViewer
                .getLoadedClasses();
    }

    /**
     * Used to insert a Bytecode Hook using EZ-Injection.
     *
     * @param hook
     */
    public static void insertHook(BytecodeHook hook) {
        EZInjection.hookArray.add(hook);
    }

    /**
     * This will ask the user if they really want to reset the workspace, then
     * it'll reset the work space.
     *
     * @param ask if it should ask the user about resetting the workspace
     */
    public static void resetWorkSpace(boolean ask) {
        the.bytecode.club.bytecodeviewer.BytecodeViewer.resetWorkspace(ask);
    }

    /**
     * If true, it will display the busy icon, if false it will remove it if
     * it's displayed.
     *
     * @param busy if it should display the busy icon or not
     */
    public static void setBusy(boolean busy) {
        the.bytecode.club.bytecodeviewer.BytecodeViewer.updateBusyStatus(busy);
    }

    /**
     * Sends a small window popup with the defined message.
     *
     * @param message the message you want to display
     */
    public static void showMessage(String message) {
        the.bytecode.club.bytecodeviewer.BytecodeViewer.showMessage(message);
    }

    /**
     * Asks if the user would like to overwrite the file
     */
    public static boolean canOverwriteFile(File file) {
        return DialogUtils.canOverwriteFile(file);
    }
    
    /**
     * This function will hide a JFrame after a given amount of time.
     *
     * @param frame Any JFrame object
     * @param milliseconds The amount of time until it will be hidden represented in milliseconds
     */
    public static void hideFrame(JFrame frame, long milliseconds)
    {
        new Thread(()->{
            long started = System.currentTimeMillis();
            while(System.currentTimeMillis()-started <= milliseconds)
            {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException ignored) { }
            }
    
            frame.setVisible(false);
        }, "Timed Swing Hide").start();
    }
    
    /**
     * Log to System.out
     */
    public static void log(String s)
    {
        log(false, s);
    }
    
    /**
     * Log to System.out
     */
    public static void log(boolean devModeOnly, String s)
    {
        if(!devModeOnly || DEV_MODE)
            System.out.println(s);
    }
    
    /**
     * Log to System.err
     */
    public static void logE(String s)
    {
        logE(false, s);
    }
    
    /**
     * Log to System.err
     */
    public static void logE(boolean devModeOnly, String s)
    {
        if(!devModeOnly || DEV_MODE)
            System.err.println(s);
    }

    /**
     * Returns the wrapped Krakatau Decompiler instance.
     *
     * @return The wrapped Krakatau Decompiler instance
     */
    public static InternalDecompiler getKrakatauDecompiler() {
        return Decompiler.KRAKATAU_DECOMPILER.getDecompiler();
    }

    /**
     * Returns the wrapped Procyon Decompiler instance.
     *
     * @return The wrapped Procyon Decompiler instance
     */
    public static InternalDecompiler getProcyonDecompiler() {
        return Decompiler.PROCYON_DECOMPILER.getDecompiler();
    }

    /**
     * Returns the wrapped CFR Decompiler instance.
     *
     * @return The wrapped CFR Decompiler instance
     */
    public static InternalDecompiler getCFRDecompiler() {
        return Decompiler.CFR_DECOMPILER.getDecompiler();
    }

    /**
     * Returns the wrapped FernFlower Decompiler instance.
     *
     * @return The wrapped FernFlower Decompiler instance
     */
    public static InternalDecompiler getFernFlowerDecompiler() {
        return Decompiler.FERNFLOWER_DECOMPILER.getDecompiler();
    }

    /**
     * Returns the wrapped Krakatau Disassembler instance.
     *
     * @return The wrapped Krakatau Disassembler instance
     */
    public static InternalDecompiler getKrakatauDisassembler() {
        return Decompiler.KRAKATAU_DISASSEMBLER.getDecompiler();
    }
    
    /**
     * Returns the wrapped JD-GUI Decompiler instance.
     *
     * @return The wrapped JD-GUI Decompiler instance
     */
    public static InternalDecompiler getDJGUIDecompiler() {
        return Decompiler.JD_DECOMPILER.getDecompiler();
    }
    
    /**
     * Returns the wrapped JADX Decompiler instance.
     *
     * @return The wrapped JADX Decompiler instance
     */
    public static InternalDecompiler getJADXDecompiler() {
        return Decompiler.JADX_DECOMPILER.getDecompiler();
    }

    /**
     * Returns the wrapped Java Compiler instance.
     *
     * @return The wrapped Java Compiler instance
     */
    public static InternalCompiler getJavaCompiler() {
        return Compiler.JAVA_COMPILER.getCompiler();
    }

    /**
     * Returns the wrapped Krakatau Assembler instance.
     *
     * @return The wrapped Krakatau Assembler instance
     */
    public static InternalCompiler getKrakatauCompiler() {
        return Compiler.KRAKATAU_ASSEMBLER.getCompiler();
    }

    /**
     * Returns the wrapped Smali Assembler instance.
     *
     * @return The wrapped Smali Assembler instance
     */
    public static InternalCompiler getSmaliCompiler() {
        return Compiler.SMALI_ASSEMBLER.getCompiler();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/api/BytecodeHook.java`:

```java
package the.bytecode.club.bytecodeviewer.api;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Used for BCV-Injected bytecode hooks
 *
 * @author Konloch
 */

public interface BytecodeHook
{
    /**
     * A callback event for functions that have been injected by EZ-Inject
     */
    void callHook(String information);
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/api/ClassNodeLoader.java`:

```java
package the.bytecode.club.bytecodeviewer.api;

import java.security.AllPermission;
import java.security.CodeSource;
import java.security.Permissions;
import java.security.ProtectionDomain;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.ClassNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Demmonic
 */

public final class ClassNodeLoader extends ClassLoader
{
    private final Map<String, ClassNode> classes = new HashMap<>();

    /**
     * Adds the provided class node to the class loader
     *
     * @param cn The class
     */
    public void addClass(ClassNode cn) {
        classes.put(cn.name.replace("/", "."), cn);
    }

    /**
     * @param name The name of the class
     * @return If this class loader contains the provided class node
     */
    public boolean contains(String name) {
        return (classes.get(name) != null);
    }

    /**
     * @return All class nodes in this loader
     */
    public Collection<ClassNode> getAll() {
        return classes.values();
    }

    /**
     * Clears out all class nodes
     */
    public void clear() {
        classes.clear();
    }

    /**
     * @return All classes in this loader
     */
    public Collection<Class<?>> getAllClasses() {
        List<Class<?>> classes = new ArrayList<>();
        for (String s : this.classes.keySet()) {
            try {
                classes.add(loadClass(s));
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }

        return classes;
    }

    /**
     * @param name The name of the class
     * @return The class node with the provided name
     */
    public ClassNode get(String name) {
        return classes.get(name);
    }

    @Override
    public Class<?> loadClass(String className) throws ClassNotFoundException {
        return findClass(className);
    }

    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        if (classes.containsKey(name)) {
            return nodeToClass(classes.get(name));
        } else {
            return super.loadClass(name);
        }
    }

    /**
     * Converts a class node to a class
     *
     * @param node The node to convert
     * @return The converted class
     */
    public Class<?> nodeToClass(ClassNode node)
    {
        if (super.findLoadedClass(node.name.replace("/", ".")) != null)
            return findLoadedClass(node.name.replace("/", "."));
       
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
        try {
            node.accept(cw);
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        byte[] b = cw.toByteArray();
        return defineClass(node.name.replaceAll("/", "."), b, 0, b.length,
                getDomain());
    }

    /**
     * @return This class loader's protection domain
     */
    private ProtectionDomain getDomain() {
        CodeSource code = new CodeSource(null, (Certificate[]) null);
        return new ProtectionDomain(code, getPermissions());
    }

    /**
     * @return This class loader's permissions
     */
    private Permissions getPermissions() {
        Permissions permissions = new Permissions();
        permissions.add(new AllPermission());
        return permissions;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/api/ExceptionUI.java`:

```java
package the.bytecode.club.bytecodeviewer.api;

import java.awt.CardLayout;
import java.awt.Dimension;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.JFrameConsole;
import the.bytecode.club.bytecodeviewer.plugin.PluginManager;
import the.bytecode.club.bytecodeviewer.resources.IconResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

import static the.bytecode.club.bytecodeviewer.Constants.FAT_JAR;
import static the.bytecode.club.bytecodeviewer.Constants.VERSION;
import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple class designed to show exceptions in the UI.
 *
 * @author Konloch
 */

public class ExceptionUI extends JFrameConsole
{
    public static final String KONLOCH = "https://github.com/Konloch/bytecode-viewer/issues or Konloch at https://the.bytecode.club or konloch@gmail.com";
    public static final String SEND_STACKTRACE_TO = buildErrorLogHeader(KONLOCH);
    public static final String SEND_STACKTRACE_TO_NL = SEND_STACKTRACE_TO + nl + nl;
    
    /**
     * @param e The exception to be shown
     */
    public ExceptionUI(Throwable e) {
        setupException(e, KONLOCH);
    }

    /**
     * @param e The exception to be shown
     */
    public ExceptionUI(String e) {
        setupFrame(e, KONLOCH);
    }

    /**
     * @param e      The exception to be shown
     * @param author the author of the plugin throwing this exception.
     */
    public ExceptionUI(Throwable e, String author) {
        setupException(e, author);
    }

    /**
     * @param e      The exception to be shown
     * @param author the author of the plugin throwing this exception.
     */
    public ExceptionUI(String e, String author) {
        setupFrame(e, author);
    }
    
    /**
     * Handles error suppression and prints stacktraces to strings
     */
    private void setupException(Throwable error, String author)
    {
        //exceptions are completely hidden
        if(Configuration.silenceExceptionGUI > 0)
            return;
    
        //exception GUI is disabled but printstack is still enabled
        if(Configuration.pauseExceptionGUI > 0)
        {
            error.printStackTrace();
            return;
        }
        
        try (StringWriter sw = new StringWriter();
             PrintWriter pw = new PrintWriter(sw)) {
            error.printStackTrace(pw);
            error.printStackTrace();

            setupFrame(sw.toString(), author);
        } catch (IOException ignored) {
        }
    }
    
    /**
     * Creates a new frame and fills it with the error log
     */
    private void setupFrame(String error, String author)
    {
        setIconImages(IconResources.iconList);
        setSize(new Dimension(600, 400));
        setTitle("Bytecode Viewer " + VERSION + " - Error Log - Send this to " + author);
        getContentPane().setLayout(new CardLayout(0, 0));
        
        getTextArea().setText(buildErrorLogHeader(author) + nl + nl + error);
        getTextArea().setCaretPosition(0);
        
        //embed error log as a new tab
        if(Configuration.errorLogsAsNewTab)
            PluginManager.addExceptionUI(this);
        
        //pop open a new window frame
        else
        {
            setLocationRelativeTo(BytecodeViewer.viewer);
            setVisible(true);
        }
    }
    
    /**
     * Returns the error log header
     */
    public static String buildErrorLogHeader(String author)
    {
        String fatJar = FAT_JAR ? " [Fat Jar]" : "";
        
        return TranslatedStrings.PLEASE_SEND_THIS_ERROR_LOG_TO + " " + author +
                "\n" + TranslatedStrings.PLEASE_SEND_RESOURCES +
                "\nBytecode Viewer Version: " + VERSION + fatJar +
                ", OS: " + System.getProperty("os.name") +
                ", Java: " + System.getProperty("java.version");
    }
    
    private static final long serialVersionUID = -5230501978224926296L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/api/Plugin.java`:

```java
package the.bytecode.club.bytecodeviewer.api;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple plugin class, it will run the plugin in a background thread.
 *
 * @author Konloch
 */

public abstract class Plugin extends Thread
{
    //as long as your code is being called from the execute function
    // this will be the current container
    public ResourceContainer activeContainer = null;
    
    @Override
    public void run()
    {
        BytecodeViewer.updateBusyStatus(true);
        
        try
        {
            if (BytecodeViewer.promptIfNoLoadedResources())
                return;
    
            executeContainer();
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        } finally {
            finished = true;
            BytecodeViewer.updateBusyStatus(false);
        }
    }

    private boolean finished = false;

    /**
     * When the plugin is finally finished, this will return true
     *
     * @return true if the plugin is finished executing
     */
    public boolean isFinished() {
        return finished;
    }

    /**
     * If for some reason your plugin needs to keep the thread alive, yet will
     * still be considered finished (EZ-Injection), you can call this function
     * and it will set the finished boolean to true.
     */
    public void setFinished() {
        finished = true;
    }
    
    /**
     * On plugin start each resource container is iterated through
     */
    public void executeContainer()
    {
        BytecodeViewer.getResourceContainers().forEach(container -> {
            //set the active container
            activeContainer = container;
            
            //call on the plugin code
            execute(new ArrayList<>(container.resourceClasses.values()));
        });
    }
    
    /**
     * On plugin start each resource container is iterated through,
     * then this is called with the resource container classes
     *
     * @param classNodeList all the loaded classes for easy access.
     */
    public abstract void execute(List<ClassNode> classNodeList);
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/api/PluginConsole.java`:

```java
package the.bytecode.club.bytecodeviewer.api;

import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.SystemConsole;
import the.bytecode.club.bytecodeviewer.plugin.PluginManager;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple console GUI.
 *
 * @author Konloch
 */

public class PluginConsole extends SystemConsole
{
    //window showing is disabled to allow this frame to be added as a tab
    private boolean showWindow;
    private boolean added;
    
    public PluginConsole(String pluginName)
    {
        super(Configuration.pluginConsoleAsNewTab ? (pluginName + " Output")
                : (TranslatedStrings.PLUGIN_CONSOLE_TITLE + " - " + pluginName));
    }
    
    @Override
    public void setVisible(boolean visible)
    {
        if(!added && visible)
        {
            added = true;
            PluginManager.addConsole(this);
        }
        
        //do nothing
        if(!showWindow)
            return;
        
        super.setVisible(visible);
    }
    
    private static final long serialVersionUID = -6556940545421437508L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/Boot.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import me.konloch.kontainer.io.HTTPRequest;
import org.apache.commons.io.FileUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.bootloader.loader.AbstractLoaderFactory;
import the.bytecode.club.bytecodeviewer.bootloader.loader.ClassPathLoader;
import the.bytecode.club.bytecodeviewer.bootloader.loader.ILoader;
import the.bytecode.club.bytecodeviewer.bootloader.resource.external.EmptyExternalResource;
import the.bytecode.club.bytecodeviewer.bootloader.resource.external.ExternalResource;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;
import the.bytecode.club.bytecodeviewer.util.ZipUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.getBCVDirectory;
import static the.bytecode.club.bytecodeviewer.Constants.krakatauVersion;
import static the.bytecode.club.bytecodeviewer.Constants.krakatauWorkingDirectory;
import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @created 19 Jul 2015 03:22:37
 */
public class Boot {

    /*flags*/
    public static boolean globalstop = false;
    public static boolean completedboot = false;
    public static boolean downloading = false;

    private static InitialBootScreen screen;
    private static final List<String> libsList = new ArrayList<>();
    private static final List<String> libsFileList = new ArrayList<>();
    private static final List<String> urlList = new ArrayList<>();

    public static void boot(String[] args, boolean CLI) throws Exception {
        bootstrap();
        ILoader<?> loader = findLoader();

        screen = new InitialBootScreen();
        
        if (!CLI)
            SwingUtilities.invokeLater(() -> screen.setVisible(true));

        create(loader, args.length <= 0 || Boolean.parseBoolean(args[0]));

        SwingUtilities.invokeLater(() -> screen.setVisible(false));
    }

    public static void hide() {
        SwingUtilities.invokeLater(() -> screen.setVisible(false));
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private static void create(ILoader<?> loader, boolean clean) throws Exception {
        setState("Bytecode Viewer Boot Screen - Checking Libraries...");
        final File libsDirectory = libsDir();

        populateUrlList();

        if (globalstop) {
            while (true) {
                Thread.sleep(100);//just keep this thread halted.
            }
        }

        if (urlList.isEmpty()) {
            JOptionPane.showMessageDialog(null, "Bytecode Viewer ran into an issue, for some reason github is not "
                    + "returning what we're expecting. Please try rebooting, if this issue persists please contact "
                    + "@Konloch.", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        if (clean)
            libsDirectory.delete();

        if (!libsDirectory.exists())
            libsDirectory.mkdir();

        populateLibsDirectory();

        screen.getProgressBar().setMaximum(urlList.size() * 2);

        int completedCheck = 0;

        for (String s : urlList) {
            String fileName = s.substring("https://github.com/Konloch/bytecode-viewer/blob/master/libs/".length()
            );
            File file = new File(libsDirectory, fileName);

            boolean passed = false;
            while (!passed) {
                if (!libsList.contains(fileName)) {
                    downloading = true;
                    setState("Bytecode Viewer Boot Screen - Downloading " + fileName + "...");
                    System.out.println("Downloading " + fileName);

                    try (InputStream is = new URL("https://github.com/Konloch/bytecode-viewer/raw/master/libs/" + fileName)
                            .openConnection().getInputStream();
                        FileOutputStream fos = new FileOutputStream(file)) {
                        System.out.println("Downloading from " + s);
                        byte[] buffer = new byte[8192];
                        int len;
                        int downloaded = 0;
                        boolean flag = false;
                        while ((len = is.read(buffer)) > 0) {
                            fos.write(buffer, 0, len);
                            fos.flush();
                            downloaded += 8192;
                            int mbs = downloaded / 1048576;
                            if (mbs % 5 == 0 && mbs != 0) {
                                if (!flag)
                                    System.out.println("Downloaded " + mbs + "MBs so far");
                                flag = true;
                            } else
                                flag = false;
                        }
                    }

                    try {
                        setState("Bytecode Viewer Boot Screen - Verifying " + fileName + "...");
                        System.out.println("Verifying " + fileName + "...");

                        File f = new File(Constants.tempDirectory, "temp");
                        if (!f.exists()) {
                            f.getParentFile().mkdirs();
                        }
                        ZipUtils.zipFile(file, f);
                        f.delete();

                        libsFileList.add(file.getAbsolutePath());
                        System.out.println("Download finished!");
                        passed = true;
                    } catch (Exception e) {
                        e.printStackTrace();
                        System.out.println("Jar or Zip" + file.getAbsolutePath() + " is corrupt, redownloading.");
                        file.delete();
                    }
                } else if (Configuration.verifyCorruptedStateOnBoot) { //verify its not corrupt each boot (adds 3 seconds boot time)
                    try {
                        setState("Bytecode Viewer Boot Screen - Verifying " + fileName + "...");
                        System.out.println("Verifying " + fileName + "...");

                        File f = new File(Constants.tempDirectory, "temp");
                        ZipUtils.zipFile(file, f);
                        f.delete();

                        passed = true;
                    } catch (Exception e) {
                        e.printStackTrace();
                        System.out.println("Jar or Zip" + file.getAbsolutePath() + " is corrupt, redownloading.");
                        libsFileList.remove(file.getAbsolutePath());
                        file.delete();
                    }
                } else {
                    passed = true;
                }
            }

            completedCheck++;
            screen.getProgressBar().setValue(completedCheck);
        }

        setState("Bytecode Viewer Boot Screen - Checking & Deleting Foreign/Outdated Libraries...");
        System.out.println("Checking & Deleting foreign/outdated libraries");
        for (String s : libsFileList) {
            File f = new File(s);
            boolean delete = true;
            for (String urlS : urlList) {
                String fileName =
                        urlS.substring("https://github.com/Konloch/bytecode-viewer/blob/master/libs/".length()
                        );
                if (fileName.equals(f.getName()))
                    delete = false;
            }
            if (delete) {
                f.delete();
                System.out.println("Detected & Deleted Foreign/Outdated Jar/File: " + f.getName());
            }
        }

        setState("Bytecode Viewer Boot Screen - Loading Libraries...");
        System.out.println("Loading libraries...");

        for (String s : libsFileList) {
            if (s.endsWith(".jar")) {
                File f = new File(s);
                if (f.exists()) {
                    setState("Bytecode Viewer Boot Screen - Loading Library " + f.getName());
                    System.out.println("Loading library " + f.getName());

                    try {
                        ExternalResource res = new EmptyExternalResource<>(f.toURI().toURL());
                        loader.bind(res);
                        System.out.println("Successfully loaded " + f.getName());
                    } catch (Exception e) {
                        e.printStackTrace();
                        f.delete();
                        JOptionPane.showMessageDialog(null, "Error, Library " + f.getName() + " is corrupt, please "
                                        + "restart to redownload it.",
                                "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }

                completedCheck++;
                screen.getProgressBar().setValue(completedCheck);
            }
        }

        checkKrakatau();
        completedCheck++;
        screen.getProgressBar().setValue(completedCheck);

        checkEnjarify();
        completedCheck++;
        screen.getProgressBar().setValue(completedCheck);

        setState("Bytecode Viewer Boot Screen - Booting!");
        completedboot = true;
    }

    public static File libsDir() {
        File dir = new File(System.getProperty("user.home"), ".Bytecode-Viewer/libs");
        while (!dir.exists())
            dir.mkdirs();

        return dir;
    }

    public static void setState(String s)
    {
        if (screen != null)
            screen.setTitle(s);
    }

    public static ILoader<?> findLoader() {
        // TODO: Find from providers
        // return new LibraryClassLoader();

        // TODO: Catch
        return AbstractLoaderFactory.find().spawnLoader();
    }

    private static void bootstrap() {
        AbstractLoaderFactory.register(ClassPathLoader::new);
    }

    public static void populateUrlList() throws Exception {
        HTTPRequest req = new HTTPRequest(new URL("https://github.com/Konloch/bytecode-viewer/tree/master/libs"));
        req.setTimeout(30000);
        for (String s : req.read())
            if (s.contains("href=\"/Konloch/bytecode-viewer/blob/master/libs/")) {
                urlList.add("https://github.com" + s.split("href=")[1].split("\"")[1]);
            }
    }

    public static void populateLibsDirectory() {
        File libsDir = libsDir();
        if (libsDir.exists())
            for (File f : MiscUtils.listFiles(libsDir)) {
                libsList.add(f.getName());
                libsFileList.add(f.getAbsolutePath());
            }
    }

    public static void dropKrakatau() {
        File temp = new File(getBCVDirectory() + fs + "krakatau_" + krakatauVersion + ".zip");
        File krakatauDirectory = new File(krakatauWorkingDirectory);
        krakatauWorkingDirectory += fs + "Krakatau-master";
        if (!krakatauDirectory.exists() || temp.exists()) {
            if (temp.exists())
                temp.delete();

            setState("Bytecode Viewer Boot Screen - Extracting Krakatau");
            System.out.println("Extracting Krakatau");

            while (temp.exists())
                temp.delete();

            try (InputStream is = BytecodeViewer.class.getClassLoader().getResourceAsStream("Krakatau-"
                    + krakatauVersion + ".zip");
                 FileOutputStream baos = new FileOutputStream(temp)) {
                int r;
                byte[] buffer = new byte[8192];
                while ((r = Objects.requireNonNull(is).read(buffer)) >= 0) {
                    baos.write(buffer, 0, r);
                }

                ZipUtils.unzipFilesToPath(temp.getAbsolutePath(), krakatauDirectory.getAbsolutePath());
                temp.delete();
                System.out.println("Successfully extracted Krakatau");
            } catch (Exception e) {
                setState("Bytecode Viewer Boot Screen - ERROR, please contact @Konloch with your stacktrace.");
                BytecodeViewer.handleException(e);
            }
        }
    }

    public static void dropEnjarify() {
        File temp = new File(getBCVDirectory() + fs + "enjarify" + Constants.enjarifyVersion + ".zip");
        File enjarifyDirectory = new File(Constants.enjarifyWorkingDirectory);
        Constants.enjarifyWorkingDirectory += fs + "enjarify-master";
        if (!enjarifyDirectory.exists() || temp.exists()) {
            if (temp.exists())
                temp.delete();
            
            setState("Bytecode Viewer Boot Screen - Extracting Enjarify");
            System.out.println("Extracting Enjarify");

            while (temp.exists())
                temp.delete();

            try (InputStream is = BytecodeViewer.class.getClassLoader().getResourceAsStream("enjarify-" +
                    Constants.enjarifyVersion + ".zip");
                 FileOutputStream baos = new FileOutputStream(temp)) {
                int r;
                byte[] buffer = new byte[8192];
                while ((r = Objects.requireNonNull(is).read(buffer)) >= 0) {
                    baos.write(buffer, 0, r);
                }

                ZipUtils.unzipFilesToPath(temp.getAbsolutePath(), enjarifyDirectory.getAbsolutePath());
                temp.delete();
                System.out.println("Successfully extracted Enjarify");
            } catch (Exception e) {
                setState("Bytecode Viewer Boot Screen - ERROR, please contact @Konloch with your stacktrace.");
                BytecodeViewer.handleException(e);
            }
        }
    }

    public static void downloadZipsOnly() {
        for (String s : urlList) {
            String fileName = s.substring("https://github.com/Konloch/bytecode-viewer/blob/master/libs/".length()
            );
            File file = new File(libsDir(), fileName);

            boolean passed = false;
            while (!passed) {
                if (!libsList.contains(fileName) && fileName.endsWith(".zip")) {
                    downloading = true;
                    setState("Bytecode Viewer Boot Screen - Downloading " + fileName + "...");
                    System.out.println("Downloading " + fileName);

                    try (InputStream is = new URL("https://github.com/Konloch/bytecode-viewer/raw/master/libs/" + fileName)
                            .openConnection().getInputStream();
                         FileOutputStream fos = new FileOutputStream(file)) {
                        System.out.println("Downloading from " + s);
                        byte[] buffer = new byte[8192];
                        int len;
                        int downloaded = 0;
                        boolean flag = false;
                        while ((len = is.read(buffer)) > 0) {
                            fos.write(buffer, 0, len);
                            fos.flush();
                            downloaded += 8192;
                            int mbs = downloaded / 1048576;
                            if (mbs % 5 == 0 && mbs != 0) {
                                if (!flag)
                                    System.out.println("Downloaded " + mbs + "MBs so far");
                                flag = true;
                            } else
                                flag = false;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                    try {
                        setState("Bytecode Viewer Boot Screen - Verifying " + fileName + "...");
                        System.out.println("Verifying " + fileName + "...");

                        File f = new File(Constants.tempDirectory, "temp");
                        ZipUtils.zipFile(file, f);
                        f.delete();

                        libsFileList.add(file.getAbsolutePath());
                        System.out.println("Download finished!");
                        passed = true;
                    } catch (Exception e) {
                        e.printStackTrace();
                        System.out.println("Jar or Zip" + file.getAbsolutePath() + " is corrupt, redownloading.");
                        file.delete();
                    }
                } else
                    passed = true;
            }
        }
    }

    public static void checkEnjarify() {
        setState("Bytecode Viewer Boot Screen - Checking Enjarify...");
        System.out.println("Checking enjarify");
        File enjarifyZip = null;
        for (File f : MiscUtils.listFiles(new File(Constants.libsDirectory))) {
            if (f.getName().toLowerCase().startsWith("enjarify-")) {
                Constants.enjarifyVersion = f.getName().split("-")[1].split("\\.")[0];
                enjarifyZip = f;
            }
        }

        for (File f : MiscUtils.listFiles(new File(getBCVDirectory()))) {
            if (f.getName().toLowerCase().startsWith("enjarify_") && !f.getName().split("_")[1].split("\\.")[0].equals(Constants.enjarifyVersion)) {
                setState("Bytecode Viewer Boot Screen - Removing Outdated " + f.getName() + "...");
                System.out.println("Removing oudated " + f.getName());
                try {
                    FileUtils.deleteDirectory(f);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    
        Constants.enjarifyWorkingDirectory = getBCVDirectory() + fs + "enjarify_" + Constants.enjarifyVersion + fs + "enjarify-master";
        File enjarifyDirectory = new File(getBCVDirectory() + fs + "enjarify_" + Constants.enjarifyVersion);
        if (!enjarifyDirectory.exists()) {
            try {
                setState("Bytecode Viewer Boot Screen - Updating to " + enjarifyDirectory.getName() + "...");
                ZipUtils.unzipFilesToPath(Objects.requireNonNull(enjarifyZip).getAbsolutePath(),
                        enjarifyDirectory.getAbsolutePath());
                System.out.println("Updated to enjarify v" + Constants.enjarifyVersion);
            } catch (Exception e) {
                BytecodeViewer.showMessage("ERROR: There was an issue unzipping enjarify (possibly corrupt). Restart "
                        + "BCV." + nl +
                        "If the error persists contact @Konloch.");
                BytecodeViewer.handleException(e);
                Objects.requireNonNull(enjarifyZip).delete();
            }
        }

    }

    public static void checkKrakatau() {
        setState("Bytecode Viewer Boot Screen - Checking Krakatau...");
        System.out.println("Checking krakatau");

        File krakatauZip = null;
        for (File f : MiscUtils.listFiles(new File(Constants.libsDirectory))) {
            if (f.getName().toLowerCase().startsWith("krakatau-")) {
                //System.out.println(f.getName());
                Constants.krakatauVersion = f.getName().split("-")[1].split("\\.")[0];
                krakatauZip = f;
            }
        }

        for (File f : MiscUtils.listFiles(new File(getBCVDirectory()))) {
            if (f.getName().toLowerCase().startsWith("krakatau_") && !f.getName().split("_")[1].split("\\.")[0].equals(Constants.krakatauVersion)) {
                setState("Bytecode Viewer Boot Screen - Removing Outdated " + f.getName() + "...");
                System.out.println("Removing oudated " + f.getName());
                try {
                    FileUtils.deleteDirectory(f);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        Constants.krakatauWorkingDirectory = getBCVDirectory() + fs + "krakatau_" + Constants.krakatauVersion + fs + "Krakatau-master";

        File krakatauDirectory = new File(getBCVDirectory() + fs + "krakatau_" + Constants.krakatauVersion);
        if (!krakatauDirectory.exists()) {
            try {
                setState("Bytecode Viewer Boot Screen - Updating to " + krakatauDirectory.getName() + "...");
                ZipUtils.unzipFilesToPath(Objects.requireNonNull(krakatauZip).getAbsolutePath(),
                        krakatauDirectory.getAbsolutePath());
                System.out.println("Updated to krakatau v" + Constants.krakatauVersion);
            } catch (Exception e) {
                BytecodeViewer.showMessage("ERROR: There was an issue unzipping Krakatau decompiler (possibly "
                        + "corrupt). Restart BCV." + nl +
                        "If the error persists contact @Konloch.");
                BytecodeViewer.handleException(e);
                Objects.requireNonNull(krakatauZip).delete();
            }
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/BootState.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/23/2021
 */

public enum BootState
{
	START_UP,
	SETTINGS_LOADED,
	GUI_SHOWING,
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/InitialBootScreen.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader;

import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Toolkit;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.HTMLPane;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

import static the.bytecode.club.bytecodeviewer.Configuration.language;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @created 19 Jul 2015 04:12:21
 */
public class InitialBootScreen extends JFrame
{
    private final JProgressBar progressBar = new JProgressBar();

    public InitialBootScreen() throws IOException
    {
        setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                Configuration.canExit = true;
                System.exit(0);
            }
        });
        this.setIconImages(IconResources.iconList);

        setSize(getSafeSize());

        setTitle("Bytecode Viewer Boot Screen - Starting Up");
        GridBagLayout gridBagLayout = new GridBagLayout();
        gridBagLayout.columnWidths = new int[]{0, 0};
        gridBagLayout.rowHeights = new int[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        gridBagLayout.columnWeights = new double[]{1.0, Double.MIN_VALUE};
        gridBagLayout.rowWeights = new double[]{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Double.MIN_VALUE};
        getContentPane().setLayout(gridBagLayout);

        JScrollPane scrollPane = new JScrollPane();
        GridBagConstraints gbc_scrollPane = new GridBagConstraints();
        gbc_scrollPane.gridheight = 24;
        gbc_scrollPane.insets = new Insets(0, 0, 5, 0);
        gbc_scrollPane.fill = GridBagConstraints.BOTH;
        gbc_scrollPane.gridx = 0;
        gbc_scrollPane.gridy = 0;
        getContentPane().add(scrollPane, gbc_scrollPane);
    
        scrollPane.setViewportView(HTMLPane.fromResource(language.getHTMLPath("intro")));

        GridBagConstraints gbc_progressBar = new GridBagConstraints();
        gbc_progressBar.fill = GridBagConstraints.HORIZONTAL;
        gbc_progressBar.gridx = 0;
        gbc_progressBar.gridy = 24;
        getContentPane().add(progressBar, gbc_progressBar);
        this.setLocationRelativeTo(null);
    }
    
    public static Dimension getSafeSize()
    {
        int i = (int) Toolkit.getDefaultToolkit().getScreenSize().getHeight();
        if (i >= 840)
           return new Dimension(600, 800);
        else if (i >= 640)
            return new Dimension(500, 600);
        else if (i >= 440)
            return new Dimension(400, 400);
        else
            return Toolkit.getDefaultToolkit().getScreenSize();
    }

    public JProgressBar getProgressBar() {
        return progressBar;
    }
    
    private static final long serialVersionUID = -1098467609722393444L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/InstallFatJar.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader;

import static the.bytecode.club.bytecodeviewer.Constants.AUTOMATIC_LIBRARY_UPDATING;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Downloads & installs the krakatau & enjarify zips
 *
 * Alternatively if OFFLINE_MODE is enabled it will drop the Krakatau and Enjarify versions supplied with BCV
 *
 * @author Konloch
 * @since 7/6/2021
 */
public class InstallFatJar implements Runnable
{
	@Override
	public void run()
	{
		try
		{
			if (AUTOMATIC_LIBRARY_UPDATING)
			{
				Boot.populateUrlList();
				Boot.populateLibsDirectory();
				Boot.downloadZipsOnly();
				Boot.checkKrakatau();
				Boot.checkEnjarify();
			}
			else
			{
				Boot.dropKrakatau();
				Boot.dropEnjarify();
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/UpdateCheck.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader;

import de.skuzzle.semantic.Version;
import java.awt.Desktop;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;
import javax.swing.JFileChooser;
import me.konloch.kontainer.io.HTTPRequest;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.api.BCV;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

import static the.bytecode.club.bytecodeviewer.Constants.VERSION;
import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 */
public class UpdateCheck implements Runnable
{
	//just brute force download the url path
	//one of these works for every single version of BCV
	public static final String[] remoteGithubReleases = new String[]
	{
			//current url scheme since v2.9.12
			"https://github.com/Konloch/bytecode-viewer/releases/download/v{VERSION}/Bytecode-Viewer-{VERSION}.jar",
			//for v2.9.10 and v2.9.11
			"https://github.com/Konloch/bytecode-viewer/releases/download/{VERSION}/Bytecode-Viewer-{VERSION}.jar",
			//for v2.7.0 to v2.9.8
			"https://github.com/Konloch/bytecode-viewer/releases/download/v{VERSION}/BytecodeViewer.{VERSION}.zip",
			//for v2.0 to v2.6.0
			"https://github.com/Konloch/bytecode-viewer/releases/download/v{VERSION}/BytecodeViewer.{VERSION}.jar",
			//for v1.1 to v1.5.3
			"https://github.com/Konloch/bytecode-viewer/releases/download/b{VERSION}/BytecodeViewer.Beta.{VERSION}.jar",
			//for v1.4
			"https://github.com/Konloch/bytecode-viewer/releases/download/b.{VERSION}/BytecodeViewer.Beta.{VERSION}.jar",
			//for v1.0
			"https://github.com/Konloch/bytecode-viewer/releases/download/B{VERSION}/BytecodeViewer.jar",
			//zip variant of current url scheme since v2.9.12 (not currently used but incase it ever does)
			"https://github.com/Konloch/bytecode-viewer/releases/download/v{VERSION}/Bytecode-Viewer-{VERSION}.zip",
	};
	
	//a list of all of the released versions of BCV
	public static final String[] versions = new String[]
	{
			//"2.11.0",
			//"2.10.15",
			"2.10.14",
			"2.10.13",
			"2.10.12",
			"2.10.11",
			"2.9.22",
			"2.9.21",
			"2.9.20",
			"2.9.19",
			"2.9.18",
			"2.9.17",
			"2.9.16",
			"2.9.15",
			"2.9.14",
			"2.9.13",
			"2.9.12",
			"2.9.11",
			"2.9.10", //broken due to repo change
			"2.9.8", //broken due to repo change & zip
			"2.9.7", //broken due to repo change & zip
			"2.9.6", //zip
			"2.9.5", //zip
			"2.9.4", //zip
			"2.9.3", //zip
			"2.9.2", //zip
			"2.9.1", //zip
			"2.9.0", //zip
			"2.8.1", //zip
			"2.8.0", //zip
			"2.7.1", //zip
			"2.7.0", //zip
			"2.6.0",
			"2.5.2",
			"2.5.1",
			"2.5.0",
			"2.4.0",
			"2.3.0",
			"2.2.1",
			"2.2.0",
			"2.1.1",
			"2.1.0",
			"2.0.1",
			"2.0",
			"1.5.3",
			"1.5.2",
			"1.5.1",
			"1.5",
			"1.4",
			"1.3.1",
			"1.3",
			"1.2",
			"1.1",
			"1.0",
	};
	
	@Override
	public void run()
	{
		try {
			HTTPRequest r = new HTTPRequest(new URL("https://raw.githubusercontent.com/Konloch/bytecode-viewer/master/VERSION"));
			final Version version = Version.parseVersion(r.readSingle());
			final Version localVersion = Version.parseVersion(VERSION);
			
			try {
				//developer version
				if (Version.compare(localVersion, version) > 0)
					return;
			} catch (Exception ignored) { }
			
			MultipleChoiceDialog outdatedDialog = new MultipleChoiceDialog("Bytecode Viewer - Outdated Version",
					"Your version: " + localVersion + ", latest version: " + version + nl +
							"What would you like to do?",
					new String[]{"Open The Download Page", "Download The Updated Jar", "Do Nothing (And Don't Ask Again)"});
			
			int result = outdatedDialog.promptChoice();
			
			if (result == 0)
			{
				if (Desktop.isDesktopSupported())
					Desktop.getDesktop().browse(new URI("https://github.com/Konloch/bytecode-viewer/releases"));
				else
					BytecodeViewer.showMessage("Cannot open the page, please manually type it."
							+ nl + "https://github.com/Konloch/bytecode-viewer/releases");
			}
			else if (result == 1)
			{
				//TODO move this to after the file extension has been found
				final File file = promptFileSave("Jar Archives", "jar");
				
				if(file != null)
				{
					Thread downloadThread = new Thread(() ->
							downloadBCV(version.toString(), file, ()->{}, ()->{}), "Downloader");
					downloadThread.start();
				}
			}
			else if(result == 2)
			{
				//TODO save version into a hashset called doNotPrompt
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static File promptFileSave(String description, String extension) throws IOException
	{
		JFileChooser fc = new FileChooser(new File("./").getCanonicalFile(),
				"Select Save File",  description, extension);
		
		int returnVal = fc.showSaveDialog(BytecodeViewer.viewer);
		File file = null;
		if (returnVal == JFileChooser.APPROVE_OPTION)
		{
			Configuration.setLastOpenDirectory(fc.getSelectedFile());
			
			file = fc.getSelectedFile();
			String nameLowercase = file.getAbsolutePath().toLowerCase();
			if (!nameLowercase.endsWith(".jar"))
				file = new File(file.getAbsolutePath() + ".jar");
			
			if (file.exists())
			{
				MultipleChoiceDialog overwriteDialog = new MultipleChoiceDialog("Bytecode Viewer - Overwrite File",
						"The file " + file + " exists, would you like to overwrite it?",
						new String[]{TranslatedStrings.YES.toString(), TranslatedStrings.NO.toString()});
				
				if (overwriteDialog.promptChoice() != 0)
					return null;
				
				file.delete();
			}
		}
		
		return file;
	}
	
	//used to download all released versions of BCV
	/*public static void main(String[] args)
	{
		BytecodeViewer.viewer = new MainViewerGUI();
		for(String version : versions)
		{
			//TODO most are jars, check which are zip and append zip as needed
			File file = new File("./" + version + ".zip");
			if(!file.exists())
				downloadBCV(version, file, () -> {}, () -> {});
		}
	}*/
	
	private static void downloadBCV(String version, File saveTo, Runnable onFinish, Runnable onFail)
	{
		boolean found = false;
		for(String urlAttempt : remoteGithubReleases)
		{
			try
			{
				String url = urlAttempt.replace("{VERSION}", version);
				
				if(validURl(url))
				{
					download(url, saveTo, onFinish);
					found = true;
					break;
				}
				
			} catch (FileNotFoundException ex) {
				//ignore 404s
			} catch (Exception e) {
				//print network errors but don't alert user
				e.printStackTrace();
			}
		}
		
		if(!found)
		{
			BCV.logE("Failed to download BCV v" + version);
			BytecodeViewer.showMessage("Unable to download BCV v" + version + ", please let Konloch know.");
			onFail.run();
		}
	}
	
	private static boolean validURl(String url) throws Exception
	{
		HTTPRequest request = new HTTPRequest(new URL(url));
		request.readSingle();
		return request.getStatusCode() == 200;
	}
	
	private static void download(String url, File saveTo, Runnable onFinish) throws Exception
	{
		BCV.log("Downloading from: " + url);
		BytecodeViewer.showMessage("Downloading the jar in the background, when it's finished you will be alerted with another message box."
				+ nl + nl + "Expect this to take several minutes.");

		try (InputStream is = new URL(url).openConnection().getInputStream();
			 FileOutputStream fos = new FileOutputStream(saveTo)) {
			byte[] buffer = new byte[8192];
			int len;
			int downloaded = 0;
			boolean flag = false;
			
			while ((len = is.read(buffer)) > 0)
			{
				fos.write(buffer, 0, len);
				fos.flush();
				
				downloaded += 8192;
				int mbs = downloaded / 1048576;
				if (mbs % 5 == 0 && mbs != 0)
				{
					if (!flag)
						System.out.println("Downloaded " + mbs + "MBs so far");
					flag = true;
				} else
					flag = false;
			}
		}
		
		BCV.log("Download finished!");
		BytecodeViewer.showMessage("Download successful! You can find the updated program at " + saveTo.getAbsolutePath());
		
		onFinish.run();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/classtree/ClassHelper.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.classtree;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import org.objectweb.asm.tree.ClassNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 25 May 2015 (actually before this)
 */
public class ClassHelper {

    public static Map<String, ClassNode> convertToMap(Collection<ClassNode> classes) {
        Map<String, ClassNode> map = new HashMap<>();
        for (ClassNode cn : classes) {
            map.put(cn.name, cn);
        }
        return map;
    }

    public static <T, K> Map<T, K> copyOf(Map<T, K> src) {
        Map<T, K> dst = new HashMap<>();
        copy(src, dst);
        return dst;
    }

    public static <T, K> void copy(Map<T, K> src, Map<T, K> dst) {
        dst.putAll(src);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/classtree/ClassTree.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.classtree;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.bootloader.classtree.nullpermablehashmap.NullPermeableHashMap;
import the.bytecode.club.bytecodeviewer.bootloader.classtree.nullpermablehashmap.SetCreator;

import static the.bytecode.club.bytecodeviewer.bootloader.classtree.ClassHelper.convertToMap;
import static the.bytecode.club.bytecodeviewer.bootloader.classtree.ClassHelper.copyOf;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 25 May 2015 (actually before this)
 */
public class ClassTree {
    private static final SetCreator<ClassNode> SET_CREATOR = new SetCreator<>();

    private final Map<String, ClassNode> classes;
    private final NullPermeableHashMap<ClassNode, Set<ClassNode>> supers;
    private final NullPermeableHashMap<ClassNode, Set<ClassNode>> delgates;

    public ClassTree() {
        classes = new HashMap<>();
        supers = new NullPermeableHashMap<>(SET_CREATOR);
        delgates = new NullPermeableHashMap<>(SET_CREATOR);
    }

    public ClassTree(Collection<ClassNode> classes) {
        this(convertToMap(classes));
    }

    public ClassTree(Map<String, ClassNode> classes_) {
        classes = copyOf(classes_);
        supers = new NullPermeableHashMap<>(SET_CREATOR);
        delgates = new NullPermeableHashMap<>(SET_CREATOR);

        build(classes);
    }

    // TODO: optimise
    public void build(Map<String, ClassNode> classes) {
        for (ClassNode node : classes.values()) {
            for (String iface : node.interfaces) {
                ClassNode ifacecs = classes.get(iface);
                if (ifacecs == null)
                    continue;

                getDelegates0(ifacecs).add(node);

                Set<ClassNode> superinterfaces = new HashSet<>();
                buildSubTree(classes, superinterfaces, ifacecs);

                getSupers0(node).addAll(superinterfaces);
            }
            ClassNode currentSuper = classes.get(node.superName);
            while (currentSuper != null) {
                getDelegates0(currentSuper).add(node);
                getSupers0(node).add(currentSuper);
                for (String iface : currentSuper.interfaces) {
                    ClassNode ifacecs = classes.get(iface);
                    if (ifacecs == null)
                        continue;
                    getDelegates0(ifacecs).add(currentSuper);
                    Set<ClassNode> superinterfaces = new HashSet<>();
                    buildSubTree(classes, superinterfaces, ifacecs);
                    getSupers0(currentSuper).addAll(superinterfaces);
                    getSupers0(node).addAll(superinterfaces);
                }
                currentSuper = classes.get(currentSuper.superName);
            }

            getSupers0(node);
            getDelegates0(node);
        }
    }

    public void build(ClassNode node) {
        for (String iface : node.interfaces) {
            ClassNode ifacecs = classes.get(iface);
            if (ifacecs == null)
                continue;

            getDelegates0(ifacecs).add(node);

            Set<ClassNode> superinterfaces = new HashSet<>();
            buildSubTree(classes, superinterfaces, ifacecs);

            getSupers0(node).addAll(superinterfaces);
        }
        ClassNode currentSuper = classes.get(node.superName);
        while (currentSuper != null) {
            getDelegates0(currentSuper).add(node);
            getSupers0(node).add(currentSuper);
            for (String iface : currentSuper.interfaces) {
                ClassNode ifacecs = classes.get(iface);
                if (ifacecs == null)
                    continue;
                getDelegates0(ifacecs).add(currentSuper);
                Set<ClassNode> superinterfaces = new HashSet<>();
                buildSubTree(classes, superinterfaces, ifacecs);
                getSupers0(currentSuper).addAll(superinterfaces);
                getSupers0(node).addAll(superinterfaces);
            }
            currentSuper = classes.get(currentSuper.superName);
        }

        getSupers0(node);
        getDelegates0(node);

        classes.put(node.name, node);
    }

    private void buildSubTree(Map<String, ClassNode> classes, Collection<ClassNode> superinterfaces,
                              ClassNode current) {
        superinterfaces.add(current);
        for (String iface : current.interfaces) {
            ClassNode cs = classes.get(iface);
            if (cs != null) {
                getDelegates0(cs).add(current);
                buildSubTree(classes, superinterfaces, cs);
            } /*else {
                System.out.println("Null interface -> " + iface);
            }*/
        }
    }

    public Set<MethodNode> getMethodsFromSuper(ClassNode node, String name, String desc) {
        Set<MethodNode> methods = new HashSet<>();
        for (ClassNode super_ : getSupers(node)) {
            for (MethodNode mn : super_.methods) {
                if (mn.name.equals(name) && mn.desc.equals(desc)) {
                    methods.add(mn);
                }
            }
        }
        return methods;
    }

    public Set<MethodNode> getMethodsFromDelegates(ClassNode node, String name, String desc) {
        Set<MethodNode> methods = new HashSet<>();
        for (ClassNode delegate : getDelegates(node)) {
            for (MethodNode mn : delegate.methods) {
                if (mn.name.equals(name) && mn.desc.equals(desc)) {
                    methods.add(mn);
                }
            }
        }
        return methods;
    }

    public MethodNode getFirstMethodFromSuper(ClassNode node, String name, String desc) {
        for (ClassNode super_ : getSupers(node)) {
            for (MethodNode mn : super_.methods) {
                if (mn.name.equals(name) && mn.desc.equals(desc)) {
                    return mn;
                }
            }
        }
        return null;
    }

    public ClassNode getClass(String name) {
        return classes.get(name);
    }

    public boolean isInherited(ClassNode cn, String name, String desc) {
        return getFirstMethodFromSuper(cn, name, desc) != null;
    }

    private Set<ClassNode> getSupers0(ClassNode cn) {
        return supers.getNonNull(cn);
    }

    private Set<ClassNode> getDelegates0(ClassNode cn) {
        return delgates.getNonNull(cn);
    }

    public Map<String, ClassNode> getClasses() {
        return classes;
    }

    public Set<ClassNode> getSupers(ClassNode cn) {
        return Collections.unmodifiableSet(supers.get(cn));
        // return supers.get(cn);
    }

    public Set<ClassNode> getDelegates(ClassNode cn) {
        return Collections.unmodifiableSet(delgates.get(cn));
        // return delgates.get(cn);
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/classtree/nullpermablehashmap/NullCreator.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.classtree.nullpermablehashmap;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created ages ago
 */
public class NullCreator<V> implements ValueCreator<V> {

    @Override
    public V create() {
        return null;
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/classtree/nullpermablehashmap/NullPermeableHashMap.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.classtree.nullpermablehashmap;

import java.util.HashMap;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created ages ago
 */
public class NullPermeableHashMap<K, V> extends HashMap<K, V> {

    private static final long serialVersionUID = 1L;

    private final ValueCreator<V> creator;

    public NullPermeableHashMap(ValueCreator<V> creator) {
        this.creator = creator;
    }

    public NullPermeableHashMap() {
        this(new NullCreator<>());
    }

    public V getNonNull(K k) {
        V val = get(k);
        if (val == null) {
            val = creator.create();
            put(k, val);
        }
        return val;
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/classtree/nullpermablehashmap/SetCreator.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.classtree.nullpermablehashmap;

import java.util.HashSet;
import java.util.Set;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 25 May 2015 (actually before this)
 */
public class SetCreator<T> implements ValueCreator<Set<T>> {

    @Override
    public Set<T> create() {
        return new HashSet<>();
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/classtree/nullpermablehashmap/ValueCreator.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.classtree.nullpermablehashmap;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created ages ago
 */
public interface ValueCreator<V> {

    V create();
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/loader/AbstractLoaderFactory.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.loader;

import java.util.HashMap;
import java.util.Map;
import the.bytecode.club.bytecodeviewer.bootloader.resource.external.ExternalResource;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 21 Jul 2015 00:18:07
 */
public final class AbstractLoaderFactory {

    private static final String DEFAULT_KEY = "default-factory";
    private static final Map<String, LoaderFactory<?>> FACTORY_CACHE = new HashMap<>();

    public static void register(LoaderFactory<?> factory) {
        register(DEFAULT_KEY, factory);
    }

    public static void register(String key, LoaderFactory<?> factory) {
        if (key == null || factory == null) {
            throw new IllegalArgumentException("null key or factory");
        }

        if (FACTORY_CACHE.containsKey(key)) {
            throw new IllegalArgumentException("factory already registered with key: " + key);
        }

        FACTORY_CACHE.put(key, factory);
    }

    public static void unregister(String key) {
        if (key == null) {
            throw new IllegalArgumentException("null key");
        }

        if (!FACTORY_CACHE.containsKey(key)) {
            throw new IllegalArgumentException("factory doesn't key for key: " + key);
        }

        FACTORY_CACHE.remove(key);
    }

    public static <T extends ExternalResource<?>> LoaderFactory<T> find() {
        return find(DEFAULT_KEY);
    }

    @SuppressWarnings("unchecked")
    public static <T extends ExternalResource<?>> LoaderFactory<T> find(String key) {
        if (key == null) {
            throw new IllegalArgumentException("null key");
        }

        if (!FACTORY_CACHE.containsKey(key)) {
            throw new IllegalArgumentException("factory doesn't key for key: " + key);
        }

        return (LoaderFactory<T>) FACTORY_CACHE.get(key);
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/loader/ClassPathLoader.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.loader;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import the.bytecode.club.bytecodeviewer.bootloader.resource.external.ExternalResource;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 21 Jul 2015 00:09:53
 */
public class ClassPathLoader implements ILoader<Object> {

    void extendClassPath(URL url) throws NoSuchMethodException, SecurityException, IllegalAccessException,
            IllegalArgumentException,
            InvocationTargetException {
        URLClassLoader urlClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader();
        Class<URLClassLoader> urlClass = URLClassLoader.class;
        Method method = urlClass.getDeclaredMethod("addURL", URL.class);
        method.setAccessible(true);
        method.invoke(urlClassLoader, url);
    }

    /*
     * (non-Javadoc)
     *
     * @see the.bytecode.club.bootloader.ILoader#bind(the.bytecode.club.bootloader .resource.ExternalResource)
     */
    @Override
    public void bind(ExternalResource<Object> resource) {
        try {
            if (resource != null) {
                URL url = resource.getLocation();
                if (url != null) {
                    extendClassPath(url);
                }
            }
        }/* catch (IOException e) {
			System.err.println("Error loading resource.");
			e.printStackTrace();
		}*/ catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
            System.err.println("Error reflecting URLClassLoader.addURL(URL) ?");
            e.printStackTrace();
        }
    }

    /*
     * (non-Javadoc)
     *
     * @see the.bytecode.club.bootloader.ILoader#findClass(java.lang.String)
     */
    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException, NoClassDefFoundError {
        return Class.forName(name);
    }

    /*
     * (non-Javadoc)
     *
     * @see the.bytecode.club.bootloader.ILoader#loadClass(java.lang.String)
     */
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException, NoClassDefFoundError {
        return findClass(name);
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/loader/ILoader.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.loader;

import the.bytecode.club.bytecodeviewer.bootloader.resource.external.ExternalResource;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 19 Jul 2015 02:29:43
 */
public interface ILoader<T> {

    void bind(ExternalResource<T> resource);

    Class<?> findClass(String name) throws ClassNotFoundException, NoClassDefFoundError;

    Class<?> loadClass(String name) throws ClassNotFoundException, NoClassDefFoundError;
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/loader/LibraryClassLoader.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.loader;

import java.io.IOException;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.bootloader.classtree.ClassTree;
import the.bytecode.club.bytecodeviewer.bootloader.resource.external.ExternalResource;
import the.bytecode.club.bytecodeviewer.bootloader.resource.jar.contents.JarContents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 19 Jul 2015 02:48:41
 *
 *         TODO: Resource loading
 */
@Deprecated
public class LibraryClassLoader extends ClassLoader implements ILoader<JarContents<ClassNode>> {

    private final Set<JarContents<ClassNode>> binded;
    private final Map<String, Class<?>> classCache;
    private final ClassTree tree;

    public LibraryClassLoader() {
        binded = new HashSet<>();
        classCache = new HashMap<>();
        tree = new ClassTree();
    }

    /* (non-Javadoc)
     * @see the.bytecode.club.bytecodeviewer.loadermodel.ILoader#bind(the.bytecode.club.bytecodeviewer.loadermodel
     * .ExternalResource)
     */
    @Override
    public void bind(ExternalResource<JarContents<ClassNode>> resource) {
        try {
            JarContents<ClassNode> contents = resource.load();
            if (contents != null) {
                binded.add(contents);
                tree.build(contents.getClassContents().namedMap());
            } else {
                System.err.println("Null contents?");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /* (non-Javadoc)
     * @see the.bytecode.club.bytecodeviewer.loadermodel.ILoader#loadClass(java.lang.String)
     */
    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException, NoClassDefFoundError {
        String byte_name = name.replace(".", "/");
        if (classCache.containsKey(byte_name))
            return classCache.get(byte_name);

        ClassNode cn = null;
        for (JarContents<ClassNode> contents : binded) {
            cn = contents.getClassContents().namedMap().get(byte_name);
            if (cn != null)
                break;
        }

        if (cn != null) {
            Class<?> klass = define(cn);
            if (klass != null) {
                classCache.put(byte_name, klass);
                return klass;
            }
        }

        return super.loadClass(name);
    }

    protected Class<?> define(ClassNode cn) {
        ClassWriter writer = new ResolvingClassWriter(tree);
        cn.accept(cn);
        byte[] bytes = writer.toByteArray();
        return defineClass(bytes, 0, bytes.length);
    }

    public static class ResolvingClassWriter extends ClassWriter {

        private final ClassTree classTree;

        public ResolvingClassWriter(ClassTree classTree) {
            super(ClassWriter.COMPUTE_FRAMES);
            this.classTree = classTree;
        }

        @Deprecated
        void update(Map<String, ClassNode> classes) {
            classTree.build(classes);
        }

        @Override
        protected String getCommonSuperClass(final String type1, final String type2) {
            ClassNode ccn = classTree.getClass(type1);
            ClassNode dcn = classTree.getClass(type2);

            //System.out.println(type1 + " " + type2);
            if (ccn == null) {
                classTree.build(createQuick(type1));
                return getCommonSuperClass(type1, type2);
            }

            if (dcn == null) {
                classTree.build(createQuick(type2));
                return getCommonSuperClass(type1, type2);
            }

            Set<ClassNode> c = classTree.getSupers(ccn);
            Set<ClassNode> d = classTree.getSupers(dcn);

            if (c.contains(dcn))
                return type1;

            if (d.contains(ccn))
                return type2;

            if (Modifier.isInterface(ccn.access) || Modifier.isInterface(dcn.access)) {
                return "java/lang/Object";
            } else {
                do {
                    ClassNode nccn = classTree.getClass(ccn.superName);
                    if (nccn == null)
                        break;
                    ccn = nccn;
                    c = classTree.getSupers(ccn);
                } while (!c.contains(dcn));
                return ccn.name;
            }
        }

        public ClassNode createQuick(String name) {
            try {
                ClassReader cr = new ClassReader(name);
                ClassNode cn = new ClassNode();
                cr.accept(cn, ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);
                return cn;
            } catch (IOException e) {
                e.printStackTrace();
                return null;
            }
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/loader/LoaderFactory.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.loader;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 21 Jul 2015 00:14:53
 */
public interface LoaderFactory<T> {

    ILoader<T> spawnLoader();
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/DataContainer.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created ages ago
 */
public abstract class DataContainer<T> extends ArrayList<T> {

    private static final long serialVersionUID = -9022506488647444546L;

    public DataContainer() {
        this(16);
    }

    public DataContainer(int cap) {
        super(cap);
    }

    public DataContainer(Collection<T> data) {
        addAll(data);
    }

    public abstract Map<String, T> namedMap();
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/external/EmptyExternalResource.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource.external;

import java.net.URL;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 21 Jul 2015 00:29:11
 */
public class EmptyExternalResource<T> extends ExternalResource<T> {

    /**
     * @param location
     */
    public EmptyExternalResource(URL location) {
        super(location);
    }

    /* (non-Javadoc)
     * @see the.bytecode.club.bootloader.resource.ExternalResource#load()
     */
    @Override
    public T load() {
        throw new UnsupportedOperationException();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/external/ExternalLibrary.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource.external;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.JarURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.bootloader.resource.jar.JarInfo;
import the.bytecode.club.bytecodeviewer.bootloader.resource.jar.JarResource;
import the.bytecode.club.bytecodeviewer.bootloader.resource.jar.contents.JarContents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 19 Jul 2015 02:33:23
 */
public class ExternalLibrary extends ExternalResource<JarContents<ClassNode>> {

    /**
     * @param location
     */
    public ExternalLibrary(URL location) {
        super(location);
    }

    /**
     * @param jar
     */
    public ExternalLibrary(JarInfo jar) {
        super(createJarURL(jar));
    }

    public static URL createJarURL(JarInfo jar) {
        try {
            return jar.formattedURL();
        } catch (MalformedURLException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static byte[] read(InputStream in) throws IOException {
        try (ByteArrayOutputStream byteArrayOut = new ByteArrayOutputStream()) {
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = in.read(buffer)) != -1)
                byteArrayOut.write(buffer, 0, bytesRead);
            return byteArrayOut.toByteArray();
        }
    }

    protected ClassNode create(byte[] b) {
        ClassReader cr = new ClassReader(b);
        ClassNode cn = new ClassNode();
        cr.accept(cn, 0);
        return cn;
    }

    /* (non-Javadoc)
     * @see the.bytecode.club.bytecodeviewer.loadermodel.ExternalResource#load()
     */
    @Override
    public JarContents<ClassNode> load() throws IOException {
        JarContents<ClassNode> contents = new JarContents<>();

        JarURLConnection con = (JarURLConnection) getLocation().openConnection();
        JarFile jar = con.getJarFile();

        Enumeration<JarEntry> entries = jar.entries();
        while (entries.hasMoreElements()) {
            JarEntry entry = entries.nextElement();
            try (InputStream is = jar.getInputStream(entry)) {
                byte[] bytes = read(is);
                if (entry.getName().endsWith(".class")) {
                    ClassNode cn = create(bytes);
                    contents.getClassContents().add(cn);
                } else {
                    JarResource resource = new JarResource(entry.getName(), bytes);
                    contents.getResourceContents().add(resource);
                }
            }
        }

        return contents;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/external/ExternalResource.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource.external;

import java.io.IOException;
import java.net.URL;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 19 Jul 2015 02:30:30
 */
public abstract class ExternalResource<T> {

    private final URL location;

    public ExternalResource(URL location) {
        if (location == null)
            throw new IllegalArgumentException();
        this.location = location;
    }

    public URL getLocation() {
        return location;
    }

    public abstract T load() throws IOException;

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + location.hashCode();
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        ExternalResource<?> other = (ExternalResource<?>) obj;
        return location.equals(other.location);
    }

    @Override
    public String toString() {
        return "Library @" + location.toExternalForm();
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/jar/JarInfo.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource.jar;

import java.io.File;
import java.net.JarURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Holds information about a single local or external JarFile.
 *
 * @author Bibl
 * @created ages ago
 */
public class JarInfo {

    private final String path;
    private final JarType type;

    /**
     * Creates a new holder as the JarFile is on the local system.
     *
     * @param path Path to jar.
     */
    public JarInfo(File path) {
        this(path.getAbsolutePath(), JarType.FILE);
    }

    /**
     * Creates a new holder.
     *
     * @param path Path to jar.
     * @param type Type of jar.
     */
    public JarInfo(String path, JarType type) {
        this.path = path;
        this.type = type;
    }

    /**
     * Creates a new holder.
     *
     * @param url URL to jar.
     */
    public JarInfo(URL url) {
        this(url.toExternalForm(), JarType.WEB);
    }

    /**
     * @return Real path to JarFile.
     */
    public final String getPath() {
        return path;
    }

    public final JarType getType() {
        return type;
    }

    /**
     * Formats a string ready for a {@link JarURLConnection} to connect to.
     *
     * @return The formatted url.
     * @throws MalformedURLException
     */
    public URL formattedURL() throws MalformedURLException {
        StringBuilder sb = new StringBuilder().append("jar:").append(type.prefix()).append(path);
        if (type.equals(JarType.FILE) && !path.endsWith(".jar")) {
            File file = new File(path);
            if (!file.exists())
                sb.append(".jar");
        }
        sb.append("!/");
        return new URL(sb.toString());
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = (prime * result) + ((path == null) ? 0 : path.hashCode());
        result = (prime * result) + ((type == null) ? 0 : type.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        JarInfo other = (JarInfo) obj;
        if (path == null) {
            if (other.path != null)
                return false;
        } else if (!path.equals(other.path))
            return false;
        return type == other.type;
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/jar/JarResource.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource.jar;

import java.util.Arrays;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created ages ago
 */
public class JarResource {

    private final String name;
    private final byte[] data;

    public JarResource(String name, byte[] data) {
        this.name = name;
        this.data = data;
    }

    public String getName() {
        return name;
    }

    public byte[] getData() {
        return data;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = (prime * result) + Arrays.hashCode(data);
        result = (prime * result) + ((name == null) ? 0 : name.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        JarResource other = (JarResource) obj;
        if (!Arrays.equals(data, other.data))
            return false;
        if (name == null) {
            return other.name == null;
        } else return name.equals(other.name);
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/jar/JarType.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource.jar;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Type of Jar Stored.
 *
 * @author Bibl
 * @created ages ago
 */
public enum JarType {

    /**
     * Local file
     **/
    FILE("file:"),
    /**
     * External URL
     **/
    WEB("");

    private final String prefix;

    JarType(String prefix) {
        this.prefix = prefix;
    }

    /**
     * Gets the prefix for the JarURLConnection.
     **/
    public String prefix() {
        return prefix;
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/jar/contents/JarContents.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource.jar.contents;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.bootloader.resource.DataContainer;
import the.bytecode.club.bytecodeviewer.bootloader.resource.jar.JarResource;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created ages ago
 */
public class JarContents<C extends ClassNode> {

    private final DataContainer<C> classContents;
    private final DataContainer<JarResource> resourceContents;

    public JarContents() {
        classContents = new ClassNodeContainer<>();
        resourceContents = new ResourceContainer();
    }

    public JarContents(DataContainer<C> classContents, DataContainer<JarResource> resourceContents) {
        this.classContents = classContents == null ? new ClassNodeContainer<>() : classContents;
        this.resourceContents = resourceContents == null ? new ResourceContainer() : resourceContents;
    }

    public final DataContainer<C> getClassContents() {
        return classContents;
    }

    public final DataContainer<JarResource> getResourceContents() {
        return resourceContents;
    }

    public void merge(JarContents<C> contents) {
        classContents.addAll(contents.classContents);
        resourceContents.addAll(contents.resourceContents);
    }

    public JarContents<C> add(JarContents<C> contents) {
        List<C> c1 = classContents;
        List<C> c2 = contents.classContents;

        List<JarResource> r1 = resourceContents;
        List<JarResource> r2 = contents.resourceContents;

        List<C> c3 = new ArrayList<>(c1.size() + c2.size());
        c3.addAll(c1);
        c3.addAll(c2);

        List<JarResource> r3 = new ArrayList<>(r1.size() + r2.size());
        r3.addAll(r1);
        r3.addAll(r2);

        return new JarContents<>(new ClassNodeContainer<>(c3), new ResourceContainer(r3));
    }

    public static class ClassNodeContainer<C extends ClassNode> extends DataContainer<C> {
        private static final long serialVersionUID = -6169578803641192235L;

        private Map<String, C> lastMap = new HashMap<>();
        private boolean invalidated;

        public ClassNodeContainer() {
            this(16);
        }

        public ClassNodeContainer(int cap) {
            super(cap);
        }

        public ClassNodeContainer(Collection<C> data) {
            super(data);
        }

        @Override
        public boolean add(C c) {
            invalidated = true;
            return super.add(c);
        }

        @Override
        public boolean addAll(Collection<? extends C> c) {
            invalidated = true;
            return super.addAll(c);
        }

        @Override
        public boolean remove(Object c) {
            invalidated = true;
            return super.remove(c);
        }

        @Override
        public Map<String, C> namedMap() {
            if (invalidated) {
                invalidated = false;
                Map<String, C> nodeMap = new HashMap<>();
                Iterator<C> it = iterator();
                while (it.hasNext()) {
                    C cn = it.next();
                    if (nodeMap.containsKey(cn.name)) {
                        it.remove();
                    } else {
                        nodeMap.put(cn.name, cn);
                    }
                }
                lastMap = nodeMap;
            }
            return lastMap;
        }
    }

    public static class ResourceContainer extends DataContainer<JarResource> {
        private static final long serialVersionUID = -6169578803641192235L;

        public ResourceContainer() {
            this(16);
        }

        public ResourceContainer(int cap) {
            super(cap);
        }

        public ResourceContainer(List<JarResource> data) {
            addAll(data);
        }

        @Override
        public Map<String, JarResource> namedMap() {
            Map<String, JarResource> map = new HashMap<>();
            for (JarResource resource : this) {
                map.put(resource.getName(), resource);
            }
            return map;
        }
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/bootloader/resource/jar/contents/LocateableJarContents.java`:

```java
package the.bytecode.club.bytecodeviewer.bootloader.resource.jar.contents;

import java.net.URL;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.bootloader.resource.DataContainer;
import the.bytecode.club.bytecodeviewer.bootloader.resource.jar.JarResource;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created ages ago
 */
public class LocateableJarContents<C extends ClassNode> extends JarContents<C> {

    private final URL[] jarUrls;

    public LocateableJarContents(URL... jarUrls) {
        super();
        this.jarUrls = jarUrls;
    }

    public LocateableJarContents(DataContainer<C> classContents, DataContainer<JarResource> resourceContents,
                                 URL... jarUrls) {
        super(classContents, resourceContents);
        this.jarUrls = jarUrls;
    }

    public URL[] getJarUrls() {
        return jarUrls;
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/compilers/Compiler.java`:

```java
package the.bytecode.club.bytecodeviewer.compilers;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

import the.bytecode.club.bytecodeviewer.compilers.impl.JavaCompiler;
import the.bytecode.club.bytecodeviewer.compilers.impl.KrakatauAssembler;
import the.bytecode.club.bytecodeviewer.compilers.impl.SmaliAssembler;

/**
 * A collection of all of the supported compilers/assemblers inside of BCV
 *
 * @author Konloch
 */
public enum Compiler
{
    KRAKATAU_ASSEMBLER(new KrakatauAssembler()),
    SMALI_ASSEMBLER(new SmaliAssembler()),
    JAVA_COMPILER(new JavaCompiler()),
    ;
    
    private final InternalCompiler compiler;
    
    Compiler(InternalCompiler compiler) {this.compiler = compiler;}
    
    public InternalCompiler getCompiler()
    {
        return compiler;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/compilers/InternalCompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.compilers;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Used to represent a single the compiler/assembler
 *
 * @author Konloch
 */

public abstract class InternalCompiler
{
    public abstract byte[] compile(String contents, String fullyQualifiedName);
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/compilers/impl/JavaCompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.compilers.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import me.konloch.kontainer.io.DiskWriter;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.compilers.InternalCompiler;
import the.bytecode.club.bytecodeviewer.resources.ExternalResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.nl;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Java Compiler
 *
 * @author Konloch
 */

public class JavaCompiler extends InternalCompiler
{
    @Override
    public byte[] compile(String contents, String fullyQualifiedName)
    {
        String fileStart = tempDirectory + fs + "temp" + MiscUtils.randomString(12) + fs;
        String fileStart2 = tempDirectory + fs + "temp" + MiscUtils.randomString(12) + fs;
        File java = new File(fileStart + fs + fullyQualifiedName + ".java");
        File clazz = new File(fileStart2 + fs + fullyQualifiedName + ".class");
        File cp = new File(tempDirectory + fs + "cpath_" + MiscUtils.randomString(12) + ".jar");
        File tempD = new File(fileStart + fs + fullyQualifiedName.substring(0, fullyQualifiedName.length() - fullyQualifiedName.split("/")[fullyQualifiedName.split("/").length - 1].length()));
        
        tempD.mkdirs();
        new File(fileStart2).mkdirs();

        if (Configuration.javac.isEmpty() || !new File(Configuration.javac).exists()) {
            BytecodeViewer.showMessage("You need to set your Javac path, this requires the JDK to be downloaded." + nl + "(C:/Program Files/Java/JDK_xx/bin/javac.exe)");
            ExternalResources.getSingleton().selectJavac();
        }

        if (Configuration.javac.isEmpty() || !new File(Configuration.javac).exists()) {
            BytecodeViewer.showMessage("You need to set Javac!");
            return null;
        }

        DiskWriter.replaceFile(java.getAbsolutePath(), contents, false);
        JarUtils.saveAsJar(BytecodeViewer.getLoadedClasses(), cp.getAbsolutePath());

        boolean cont = true;
        try {
            StringBuilder log = new StringBuilder();
            ProcessBuilder pb;

            if (Configuration.library.isEmpty()) {
                pb = new ProcessBuilder(
                        Configuration.javac,
                        "-d", fileStart2,
                        "-classpath", cp.getAbsolutePath(),
                        java.getAbsolutePath()
                );
            } else {
                pb = new ProcessBuilder(
                        Configuration.javac,
                        "-d", fileStart2,
                        "-classpath",
                        cp.getAbsolutePath() + System.getProperty("path.separator") + Configuration.library,
                        java.getAbsolutePath()
                );
            }

            Process process = pb.start();
            BytecodeViewer.createdProcesses.add(process);

            Thread failSafe = new Thread(() -> {
                long started = System.currentTimeMillis();
                while (System.currentTimeMillis() - started <= 10_000) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                if (process.isAlive())
                {
                    System.out.println("Force killing javac process, assuming it's gotten stuck");
                    process.destroyForcibly().destroy();
                }
            }, "Javac Fail-Safe");
            failSafe.start();

            int exitValue = process.waitFor();

            //Read out dir output
            try (InputStream is = process.getInputStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null)
                    log.append(nl).append(line);
            }

            log.append(nl).append(nl).append(TranslatedStrings.ERROR2).append(nl).append(nl);
            try (InputStream is = process.getErrorStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null)
                    log.append(nl).append(line);
            }

            log.append(nl).append(nl).append(TranslatedStrings.EXIT_VALUE_IS).append(" ").append(exitValue);
            System.out.println(log);

            if (!clazz.exists())
                throw new Exception(log.toString());
        } catch (Exception e) {
            cont = false;
            e.printStackTrace();
        }

        cp.delete();

        if (cont)
            try {
                return org.apache.commons.io.FileUtils.readFileToByteArray(clazz);
            } catch (IOException e) {
                e.printStackTrace();
                //BytecodeViewer.handleException(e);
            }

        return null;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/compilers/impl/KrakatauAssembler.java`:

```java
package the.bytecode.club.bytecodeviewer.compilers.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Objects;
import me.konloch.kontainer.io.DiskWriter;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ArrayUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.compilers.InternalCompiler;
import the.bytecode.club.bytecodeviewer.resources.ExternalResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.krakatauWorkingDirectory;
import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Krakatau Java assembler, requires Python 2.7
 *
 * @author Konloch
 */
public class KrakatauAssembler extends InternalCompiler
{
    @Override
    public byte[] compile(String contents, String fullyQualifiedName)
    {
        if(!ExternalResources.getSingleton().hasSetPython2Command())
            return null;

        File tempD = new File(Constants.tempDirectory + fs + MiscUtils.randomString(32) + fs);
        tempD.mkdir();

        File tempJ = new File(tempD.getAbsolutePath() + fs + fullyQualifiedName + ".j");
        DiskWriter.replaceFile(tempJ.getAbsolutePath(), contents, true);

        final File tempDirectory = new File(Constants.tempDirectory + fs + MiscUtils.randomString(32) + fs);
        tempDirectory.mkdir();
        
        final File tempJar = new File(Constants.tempDirectory + fs + "temp" + MiscUtils.randomString(32) + ".jar");
        JarUtils.saveAsJar(BytecodeViewer.getLoadedClasses(), tempJar.getAbsolutePath());
    
        StringBuilder log = new StringBuilder();
        
        try
        {
            String[] pythonCommands = new String[]{Configuration.python2};
            if(Configuration.python2Extra)
                pythonCommands = ArrayUtils.addAll(pythonCommands, "-2");
            
            ProcessBuilder pb = new ProcessBuilder(ArrayUtils.addAll(
                    pythonCommands,
                    "-O", //love you storyyeller <3
                    krakatauWorkingDirectory + fs + "assemble.py",
                    "-out",
                    tempDirectory.getAbsolutePath(),
                    tempJ.getAbsolutePath()
            ));

            Process process = pb.start();
            BytecodeViewer.createdProcesses.add(process);

            //Read out dir output
            try (InputStream is = process.getInputStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null)
                    log.append(nl).append(line);
            }

            log.append(nl).append(nl).append(TranslatedStrings.ERROR2).append(nl).append(nl);
            try (InputStream is = process.getErrorStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null)
                    log.append(nl).append(line);
            }

            int exitValue = process.waitFor();
            log.append(nl).append(nl).append(TranslatedStrings.EXIT_VALUE_IS).append(" ").append(exitValue);
            System.err.println(log);

            byte[] b = FileUtils.readFileToByteArray(Objects.requireNonNull(
                    ExternalResources.getSingleton().findFile(tempDirectory, ".class")));
            tempDirectory.delete();
            tempJar.delete();
            return b;
        } catch (Exception e) {
            e.printStackTrace();
            //BytecodeViewer.handleException(log.toString());
        }

        return null;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/compilers/impl/SmaliAssembler.java`:

```java
package the.bytecode.club.bytecodeviewer.compilers.impl;

import java.io.File;
import java.util.Objects;
import me.konloch.kontainer.io.DiskWriter;
import org.apache.commons.io.FileUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.compilers.InternalCompiler;
import the.bytecode.club.bytecodeviewer.util.Dex2Jar;
import the.bytecode.club.bytecodeviewer.util.Enjarify;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;
import the.bytecode.club.bytecodeviewer.util.ZipUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Smali Assembler Wrapper for Java
 *
 * @author Konloch
 */

public class SmaliAssembler extends InternalCompiler
{
    @Override
    public byte[] compile(String contents, String fullyQualifiedName)
    {
        String fileStart = tempDirectory + fs + "temp";
        int fileNumber = MiscUtils.getClassNumber(fileStart, ".dex");

        final File tempSmaliFolder = new File(fileStart + fileNumber + "-smalifolder" + fs);
        tempSmaliFolder.mkdir();

        File tempSmali = new File(tempSmaliFolder.getAbsolutePath() + fs + fileNumber + ".smali");
        File tempDex = new File("./out.dex");
        File tempJar = new File(fileStart + fileNumber + ".jar");
        File tempJarFolder = new File(fileStart + fileNumber + "-jar" + fs);

        try {
            DiskWriter.replaceFile(tempSmali.getAbsolutePath(), contents, false);
        } catch (final Exception e) {
            e.printStackTrace();
            //BytecodeViewer.handleException(e);
        }

        try {
            com.googlecode.d2j.smali.SmaliCmd.main(tempSmaliFolder.getAbsolutePath(),
                    "-o", tempDex.getAbsolutePath());
        } catch (Exception e) {
            e.printStackTrace();
            //BytecodeViewer.handleException(e);
        }


        if (BytecodeViewer.viewer.apkConversionGroup.isSelected(BytecodeViewer.viewer.apkConversionDex.getModel()))
            Dex2Jar.dex2Jar(tempDex, tempJar);
        else if (BytecodeViewer.viewer.apkConversionGroup.isSelected(BytecodeViewer.viewer.apkConversionEnjarify.getModel()))
            Enjarify.apk2Jar(tempDex, tempJar);

        System.out.println("Temporary dex: " + tempDex.getAbsolutePath());

        try {
            System.out.println("Unzipping to " + tempJarFolder.getAbsolutePath());
            ZipUtils.unzipFilesToPath(tempJar.getAbsolutePath(), tempJarFolder.getAbsolutePath());

            File outputClass = null;
            boolean found = false;
            File current = tempJarFolder;
            try {
                while (!found)
                {
                    File f = Objects.requireNonNull(current.listFiles())[0];
                    if (f.isDirectory())
                        current = f;
                    else
                    {
                        outputClass = f;
                        found = true;
                    }
                }

                System.out.println("Saved as: " + outputClass.getAbsolutePath());

                return FileUtils.readFileToByteArray(outputClass);
            } catch (java.lang.NullPointerException ignored) { }
        } catch (Exception e) {
            e.printStackTrace();
            //BytecodeViewer.handleException(e);
        }
        finally
        {
            tempDex.delete();
        }

        return null;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/Decompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers;

import the.bytecode.club.bytecodeviewer.decompilers.impl.ASMTextifierDisassembler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.BytecodeDisassembler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.CFRDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.FernFlowerDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.JADXDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.JDGUIDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.JavapDisassembler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.KrakatauDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.KrakatauDisassembler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.ProcyonDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.SmaliDisassembler;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * All of the decompilers/disassemblers BCV uses
 *
 * @author Konloch
 */
public enum Decompiler
{
    //TODO WARNING: do not change the decompiler order, when adding a new decompiler just add it to the end
    // enum ordinal is used for settings serialization instead of the enum name
    NONE("None", "", null),
    PROCYON_DECOMPILER("Procyon Decompiler", "proycon", new ProcyonDecompiler()),
    CFR_DECOMPILER("CFR Decompiler", "cfr", new CFRDecompiler()),
    FERNFLOWER_DECOMPILER("FernFlower Decompiler", "fernflower", new FernFlowerDecompiler()),
    BYTECODE_DISASSEMBLER("Bytecode Disassembler", "bcvbd", new BytecodeDisassembler()),
    HEXCODE_VIEWER("Hexcode Viewer", "bcvhex", null),
    SMALI_DISASSEMBLER("Smali Disassembler", "smali", new SmaliDisassembler()),
    KRAKATAU_DECOMPILER("Krakatau Decompiler", "krakatau", new KrakatauDecompiler()),
    KRAKATAU_DISASSEMBLER("Krakatau Disassembler", "krakataud", new KrakatauDisassembler()),
    JD_DECOMPILER("JD-GUI Decompiler", "jdgui", new JDGUIDecompiler()),
    JADX_DECOMPILER("JADX Decompiler", "jadx", new JADXDecompiler()),
    ASM_TEXTIFY_DISASSEMBLER("ASM Disassembler", "asm", new ASMTextifierDisassembler()),
    JAVAP_DISASSEMBLER("Javap Disassembler", "javap", new JavapDisassembler()),
    ;
    
    private final String decompilerName;
    private final String decompilerNameProgrammic;
    private final InternalDecompiler decompiler;
    
    Decompiler(String decompilerName, String decompilerNameProgrammic, InternalDecompiler decompiler)
    {
        this.decompilerName = decompilerName;
        this.decompilerNameProgrammic = decompilerNameProgrammic;
        this.decompiler = decompiler;
    }
    
    public String getDecompilerName()
    {
        return decompilerName;
    }
    
    public String getDecompilerNameProgrammic()
    {
        return decompilerNameProgrammic;
    }
    
    public InternalDecompiler getDecompiler()
    {
        return decompiler;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/InternalDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers;

import org.objectweb.asm.tree.ClassNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Used to represent a decompiler/disassembler
 *
 * @author Konloch
 */
public abstract class InternalDecompiler
{
    public abstract String decompileClassNode(ClassNode cn, byte[] b);

    public abstract void decompileToZip(String sourceJar, String zipName);
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/bytecode/ClassNodeDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.bytecode;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InnerClassNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl
 */

public class ClassNodeDecompiler
{
    public static PrefixedStringBuilder decompile(
            PrefixedStringBuilder sb, List<String> decompiledClasses,
            ClassNode cn) {
        List<String> unableToDecompile = new ArrayList<>();
        decompiledClasses.add(cn.name);
        sb.append(getAccessString(cn.access));
        sb.append(" ");
        sb.append(cn.name);
        if (cn.superName != null && !cn.superName.equals("java/lang/Object")) {
            sb.append(" extends ");
            sb.append(cn.superName);
        }

        int amountOfInterfaces = cn.interfaces.size();
        if (amountOfInterfaces > 0) {
            sb.append(" implements ");
            sb.append(cn.interfaces.get(0));
            for (int i = 1; i < amountOfInterfaces; i++) {
                sb.append(", ");
                sb.append(cn.interfaces.get(i));
            }
        }
        sb.append(" {");
        sb.append(nl);
        sb.append("     ");
        sb.append("<ClassVersion=" + cn.version + ">");
        sb.append(nl);

        if (cn.sourceDebug != null) {
            sb.append("     ");
            sb.append("<SourceDebug=" + cn.sourceDebug + ">");
            sb.append(nl);
        }

        if (cn.sourceFile != null) {
            sb.append("     ");
            sb.append("<SourceFile=" + cn.sourceFile + ">");
            sb.append(nl);
        }

        if (cn.signature != null) {
            sb.append("     ");
            sb.append("<Sig=" + cn.signature + ">");
        }

        for (FieldNode fn : cn.fields) {
            sb.append(nl);
            sb.append("     ");
            FieldNodeDecompiler.decompile(sb, fn);
        }
        if (cn.fields.size() > 0) {
            sb.append(nl);
        }
        for (MethodNode mn : cn.methods) {
            sb.append(nl);
            MethodNodeDecompiler.decompile(sb, mn, cn);
        }

        for (InnerClassNode o : cn.innerClasses) {
            String innerClassName = o.name;
            if ((innerClassName != null)
                    && !decompiledClasses.contains(innerClassName)) {
                decompiledClasses.add(innerClassName);
                ClassNode cn1 = BytecodeViewer.blindlySearchForClassNode(innerClassName);
                if (cn1 != null) {
                    sb.appendPrefix("     ");
                    sb.append(nl + nl);
                    sb = decompile(sb, decompiledClasses, cn1);
                    sb.trimPrefix(5);
                    sb.append(nl);
                } else {
                    unableToDecompile.add(innerClassName);
                }
            }
        }

        if (!unableToDecompile.isEmpty()) {
            sb.append("// The following inner classes couldn't be decompiled: ");
            for (String s : unableToDecompile) {
                sb.append(s);
                sb.append(" ");
            }
            sb.append(nl);
        }

        if (cn.attrs != null) {
            sb.append(nl);
            for (Attribute attr : cn.attrs) {
                //TODO: finish attributes
                sb.append(attr.type + ": ");// + attr.content.toString());
            }
        }

        //sb.append(BytecodeViewer.nl);
        sb.append("}");
        // System.out.println("Wrote end for " + cn.name +
        // " with prefix length: " + sb.prefix.length());
        return sb;
    }

    public static String getAccessString(int access) {
        List<String> tokens = new ArrayList<>();
        if ((access & Opcodes.ACC_PUBLIC) != 0)
            tokens.add("public");
        if ((access & Opcodes.ACC_PRIVATE) != 0)
            tokens.add("private");
        if ((access & Opcodes.ACC_PROTECTED) != 0)
            tokens.add("protected");
        if ((access & Opcodes.ACC_FINAL) != 0)
            tokens.add("final");
        if ((access & Opcodes.ACC_SYNTHETIC) != 0)
            tokens.add("synthetic");
        // if ((access & Opcodes.ACC_SUPER) != 0)
        // tokens.add("super"); implied by invokespecial insn
        if ((access & Opcodes.ACC_ABSTRACT) != 0)
            tokens.add("abstract");
        if ((access & Opcodes.ACC_INTERFACE) != 0)
            tokens.add("interface");
        if ((access & Opcodes.ACC_ENUM) != 0)
            tokens.add("enum");
        if ((access & Opcodes.ACC_ANNOTATION) != 0)
            tokens.add("annotation");
        if (!tokens.contains("interface") && !tokens.contains("enum")
                && !tokens.contains("annotation"))
            tokens.add("class");

        // hackery delimeters
        StringBuilder sb = new StringBuilder(tokens.get(0));
        for (int i = 1; i < tokens.size(); i++) {
            sb.append(" ");
            sb.append(tokens.get(i));
        }
        return sb.toString();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/bytecode/FieldNodeDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.bytecode;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.FieldNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl
 */

public class FieldNodeDecompiler {

    public static PrefixedStringBuilder decompile(PrefixedStringBuilder sb,
                                                  FieldNode f) {
        String s = getAccessString(f.access);
        sb.append(s);
        if (s.length() > 0)
            sb.append(" ");
        sb.append(Type.getType(f.desc).getClassName());
        sb.append(" ");
        sb.append(f.name);
        if (f.value != null) {
            sb.append(" = ");
            if (f.value instanceof String) {
                sb.append("\"");
                sb.append(f.value);
                sb.append("\"");
            } else {
                sb.append(f.value);
                sb.append(" (");
                sb.append(f.value.getClass().getCanonicalName());
                sb.append(")");
            }
        }
        sb.append(";");
        return sb;
    }

    private static String getAccessString(int access) {
        List<String> tokens = new ArrayList<>();
        if ((access & Opcodes.ACC_PUBLIC) != 0)
            tokens.add("public");
        if ((access & Opcodes.ACC_PRIVATE) != 0)
            tokens.add("private");
        if ((access & Opcodes.ACC_PROTECTED) != 0)
            tokens.add("protected");
        if ((access & Opcodes.ACC_SYNTHETIC) != 0)
            tokens.add("synthetic");
        if ((access & Opcodes.ACC_STATIC) != 0)
            tokens.add("static");
        if ((access & Opcodes.ACC_FINAL) != 0)
            tokens.add("final");
        if ((access & Opcodes.ACC_TRANSIENT) != 0)
            tokens.add("transient");
        if ((access & Opcodes.ACC_VOLATILE) != 0)
            tokens.add("volatile");
        if (tokens.size() == 0)
            return "";
        // hackery delimeters
        StringBuilder sb = new StringBuilder(tokens.get(0));
        for (int i = 1; i < tokens.size(); i++) {
            sb.append(" ");
            sb.append(tokens.get(i));
        }
        return sb.toString();
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/bytecode/InstructionPattern.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.bytecode;

import eu.bibl.banalysis.filter.InstructionFilter;
import eu.bibl.banalysis.filter.OpcodeFilter;
import eu.bibl.banalysis.filter.insn.FieldInstructionFilter;
import eu.bibl.banalysis.filter.insn.IincInstructionFilter;
import eu.bibl.banalysis.filter.insn.InsnInstructionFilter;
import eu.bibl.banalysis.filter.insn.JumpInstructionFilter;
import eu.bibl.banalysis.filter.insn.LdcInstructionFilter;
import eu.bibl.banalysis.filter.insn.MethodInstructionFilter;
import eu.bibl.banalysis.filter.insn.MultiANewArrayInstructionFilter;
import eu.bibl.banalysis.filter.insn.TypeInstructionFilter;
import eu.bibl.banalysis.filter.insn.VarInstructionFilter;
import java.util.Arrays;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.IincInsnNode;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MultiANewArrayInsnNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.VarInsnNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Pattern filter holder and stepper.
 *
 * @author Bibl
 */
public class InstructionPattern implements Opcodes {

    /**
     * Last instruction-match position pointer
     **/
    protected int pointer;
    /**
     * Filters/patterns/search criteria.
     **/
    protected InstructionFilter[] filters;
    /**
     * Last match found cache.
     **/
    protected AbstractInsnNode[] lastMatch;

    /**
     * Construct a new pattern from the specified instructions.
     *
     * @param insns {@link AbstractInsnNode} pattern array.
     */
    public InstructionPattern(AbstractInsnNode[] insns) {
        filters = translate(insns);
        lastMatch = new AbstractInsnNode[insns.length];
    }

    /**
     * Construct a new pattern from the specified opcode.
     *
     * @param opcodes Opcodes to convert to {@link OpcodeFilter}s.
     */
    public InstructionPattern(int[] opcodes) {
        filters = new InstructionFilter[opcodes.length];
        lastMatch = new AbstractInsnNode[opcodes.length];
        for (int i = 0; i < opcodes.length; i++) {
            filters[i] = new OpcodeFilter(opcodes[i]);
        }
    }

    /**
     * Construct an absolute pattern from user-defined filters.
     *
     * @param filters User-defined {@link InstructionFilter}s.
     */
    public InstructionPattern(InstructionFilter[] filters) {
        this.filters = filters;
        lastMatch = new AbstractInsnNode[filters.length];
    }

    /**
     * Steps through the instruction list checking if the current instruction
     * ended a successful pattern-match sequence.
     *
     * @param ain {@link AbstractInsnNode} to check.
     * @return True if this instruction successfully completed the pattern.
     */
    public boolean accept(AbstractInsnNode ain) {
        if (pointer >= filters.length)
            reset();

        InstructionFilter filter = filters[pointer];
        if (filter.accept(ain)) {
            lastMatch[pointer] = ain;
            if (pointer >= (filters.length - 1)) {
                return true;
            }
            pointer++;
        } else {
            reset();
        }
        return false;
    }

    /**
     * @return Last pattern sequence match equivilent from the inputted
     *         {@link AbstractInsnNode}s.
     */
    public AbstractInsnNode[] getLastMatch() {
        return lastMatch;
    }

    /**
     * Resets the instruction pointer and clears the last match cache data.
     */
    public void resetMatch() {
        reset();
        AbstractInsnNode[] match = lastMatch;
        lastMatch = new AbstractInsnNode[match.length];
    }

    /**
     * Sets the current instruction pointer to 0 (start of pattern).
     */
    public void reset() {
        pointer = 0;
    }

    /**
     * Converts an array of {@link AbstractInsnNode}s to their
     * {@link InstructionFilter} counterparts.
     *
     * @param ains {@link AbstractInsnNode}s to convert.
     * @return Array of {@link InstructionFilter}s.
     */
    public static InstructionFilter[] translate(AbstractInsnNode[] ains) {
        InstructionFilter[] filters = new InstructionFilter[ains.length];
        for (int i = 0; i < ains.length; i++) {
            filters[i] = translate(ains[i]);
        }
        return filters;
    }

    /**
     * Translate a single {@link AbstractInsnNode} to an
     * {@link InstructionFilter}.
     *
     * @param ain Instruction to convert.
     * @return A filter an an equivilent to the inputted instruction.
     */
    public static InstructionFilter translate(AbstractInsnNode ain) {
        if (ain instanceof LdcInsnNode) {
            return new LdcInstructionFilter(((LdcInsnNode) ain).cst);
        } else if (ain instanceof TypeInsnNode) {
            return new TypeInstructionFilter(ain.getOpcode(),
                    ((TypeInsnNode) ain).desc);
        } else if (ain instanceof FieldInsnNode) {
            return new FieldInstructionFilter(ain.getOpcode(),
                    ((FieldInsnNode) ain).owner, ((FieldInsnNode) ain).name,
                    ((FieldInsnNode) ain).desc);
        } else if (ain instanceof MethodInsnNode) {
            return new MethodInstructionFilter(ain.getOpcode(),
                    ((MethodInsnNode) ain).owner, ((MethodInsnNode) ain).name,
                    ((MethodInsnNode) ain).desc);
        } else if (ain instanceof VarInsnNode) {
            return new VarInstructionFilter(ain.getOpcode(),
                    ((VarInsnNode) ain).var);
        } else if (ain instanceof InsnNode) {
            return new InsnInstructionFilter(ain.getOpcode());
        } else if (ain instanceof IincInsnNode) {
            return new IincInstructionFilter(((IincInsnNode) ain).incr,
                    ((IincInsnNode) ain).var);
        } else if (ain instanceof JumpInsnNode) {
            return new JumpInstructionFilter(ain.getOpcode());
        } else if (ain instanceof LabelNode) {
            return InstructionFilter.ACCEPT_ALL; // TODO: Cache labels and
            // check. // TODO: That's a
            // fucking stupid idea.
        } else if (ain instanceof MultiANewArrayInsnNode) {
            return new MultiANewArrayInstructionFilter(
                    ((MultiANewArrayInsnNode) ain).desc,
                    ((MultiANewArrayInsnNode) ain).dims);
        } else {
            return InstructionFilter.ACCEPT_ALL;
        }
    }

    public static void main(String[] args) {
        AbstractInsnNode[] ains = new AbstractInsnNode[]{
                new LdcInsnNode("ldc"), new VarInsnNode(ASTORE, 0),
                new LdcInsnNode("ldc")};
        InstructionPattern pattern = new InstructionPattern(
                new AbstractInsnNode[]{new LdcInsnNode("ldc"),
                        new VarInsnNode(-1, -1)});
        for (AbstractInsnNode ain : ains) {
            if (pattern.accept(ain)) {
                System.out.println(Arrays.toString(pattern.getLastMatch()));
            }
        }
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/bytecode/InstructionPrinter.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.bytecode;

import eu.bibl.banalysis.asm.desc.OpcodeInfo;
import org.apache.commons.text.StringEscapeUtils;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Modifier;
import java.util.*;
import java.util.stream.Collectors;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl
 * @author GraxCode
 */
public class InstructionPrinter implements Opcodes {

  /**
   * The MethodNode to print
   **/
  private final MethodNode mNode;
  private final TypeAndName[] args;

  protected int[] pattern;
  protected boolean match;

  protected List<AbstractInsnNode> matchedInsns;
  protected Map<LabelNode, Integer> labels;
  private boolean firstLabel = false;
  private final List<String> info = new ArrayList<>();

  public InstructionPrinter(MethodNode m, TypeAndName[] args) {
    this.args = args;
    mNode = m;
    labels = new HashMap<>();
    precalculateLabelIndexes(m);
    // matchedInsns = new ArrayList<AbstractInsnNode>(); // ingnored because
    // match = false
    match = false;
  }

  public InstructionPrinter(MethodNode m, InstructionPattern pattern, TypeAndName[] args) {
    this(m, args);
    InstructionSearcher searcher = new InstructionSearcher(m.instructions, pattern);
    match = searcher.search();
    if (match) {
      for (AbstractInsnNode[] ains : searcher.getMatches()) {
        Collections.addAll(matchedInsns, ains);
      }
    }
  }

  private void precalculateLabelIndexes(MethodNode m) {
    int lIdx = 0;
    for (AbstractInsnNode ain : m.instructions) {
      if (ain.getType() == AbstractInsnNode.LABEL) {
        labels.put((LabelNode) ain, lIdx++);
      }
    }
  }

  /**
   * Creates the print
   *
   * @return The print as an ArrayList
   */
  public List<String> createPrint() {
    firstLabel = false;
    info.clear();
    for (AbstractInsnNode ain : mNode.instructions) {
      String line = printInstruction(ain);
      if (!line.isEmpty()) {
        if (match) if (matchedInsns.contains(ain)) line = "   -> " + line;

        info.add(line);
      }
    }
    if (firstLabel && BytecodeViewer.viewer.appendBracketsToLabels.isSelected()) info.add("}");
    return info;
  }

  public String printInstruction(AbstractInsnNode ain) {
    String line = "";
    if (ain instanceof VarInsnNode) {
      line = printVarInsnNode((VarInsnNode) ain);
    } else if (ain instanceof IntInsnNode) {
      line = printIntInsnNode((IntInsnNode) ain);
    } else if (ain instanceof FieldInsnNode) {
      line = printFieldInsnNode((FieldInsnNode) ain);
    } else if (ain instanceof MethodInsnNode) {
      line = printMethodInsnNode((MethodInsnNode) ain);
    } else if (ain instanceof LdcInsnNode) {
      line = printLdcInsnNode((LdcInsnNode) ain);
    } else if (ain instanceof InsnNode) {
      line = printInsnNode((InsnNode) ain);
    } else if (ain instanceof JumpInsnNode) {
      line = printJumpInsnNode((JumpInsnNode) ain);
    } else if (ain instanceof LineNumberNode) {
      line = printLineNumberNode((LineNumberNode) ain);
    } else if (ain instanceof LabelNode) {
      if (firstLabel && BytecodeViewer.viewer.appendBracketsToLabels.isSelected()) info.add("}");

      LabelNode label = (LabelNode) ain;
      if (mNode.tryCatchBlocks != null) {
        List<TryCatchBlockNode> tcbs = mNode.tryCatchBlocks;
        String starting = tcbs.stream().filter(tcb -> tcb.start == label).map(tcb -> "start TCB" + tcbs.indexOf(tcb)).collect(Collectors.joining(", "));
        String ending = tcbs.stream().filter(tcb -> tcb.end == label).map(tcb -> "end TCB" + tcbs.indexOf(tcb)).collect(Collectors.joining(", "));
        String handlers = tcbs.stream().filter(tcb -> tcb.handler == label).map(tcb -> "handle TCB" + tcbs.indexOf(tcb)).collect(Collectors.joining(", "));
        if (!ending.isEmpty()) info.add("// " + ending);
        if (!starting.isEmpty()) info.add("// " + starting);
        if (!handlers.isEmpty()) info.add("// " + handlers);
      }
      line = printLabelNode((LabelNode) ain);

      if (BytecodeViewer.viewer.appendBracketsToLabels.isSelected()) {
        if (!firstLabel) firstLabel = true;
        line += " {";
      }
    } else if (ain instanceof TypeInsnNode) {
      line = printTypeInsnNode((TypeInsnNode) ain);
    } else if (ain instanceof FrameNode) {
      line = printFrameNode((FrameNode) ain);
    } else if (ain instanceof IincInsnNode) {
      line = printIincInsnNode((IincInsnNode) ain);
    } else if (ain instanceof TableSwitchInsnNode) {
      line = printTableSwitchInsnNode((TableSwitchInsnNode) ain);
    } else if (ain instanceof LookupSwitchInsnNode) {
      line = printLookupSwitchInsnNode((LookupSwitchInsnNode) ain);
    } else if (ain instanceof InvokeDynamicInsnNode) {
      line = printInvokeDynamicInsNode((InvokeDynamicInsnNode) ain);
    } else if (ain instanceof MultiANewArrayInsnNode) {
      line = printMultiANewArrayInsNode((MultiANewArrayInsnNode) ain);
    } else {
      line += "UNADDED OPCODE: " + nameOpcode(ain.getOpcode()) + " " + ain;
    }

    return line;
  }

  protected String printVarInsnNode(VarInsnNode vin) {
    StringBuilder sb = new StringBuilder();
    sb.append(nameOpcode(vin.getOpcode()));
    sb.append(" ");
    sb.append(vin.var);
    if (BytecodeViewer.viewer.debugHelpers.isSelected()) {
      if (vin.var == 0 && !Modifier.isStatic(mNode.access)) {
        sb.append(" // reference to self");
      } else {
        final int refIndex = vin.var - (Modifier.isStatic(mNode.access) ? 0 : 1);
        if (refIndex >= 0 && refIndex < args.length - 1) {
          sb.append(" // reference to ").append(args[refIndex].name);
        }
      }
    }

    return sb.toString();
  }

  protected String printIntInsnNode(IntInsnNode iin) {
    return nameOpcode(iin.getOpcode()) + " " + iin.operand;
  }

  protected String printFieldInsnNode(FieldInsnNode fin) {
    String desc = Type.getType(fin.desc).getClassName();
    if (desc.equals("null")) desc = fin.desc;
    return nameOpcode(fin.getOpcode()) + " " + fin.owner + "." + fin.name + ":" + desc;
  }

  protected String printMethodInsnNode(MethodInsnNode min) {
    StringBuilder sb = new StringBuilder();
    sb.append(nameOpcode(min.getOpcode())).append(" ").append(min.owner).append(".").append(min.name);

    String desc = min.desc;
    try {
      if (Type.getType(min.desc) != null) desc = Type.getType(min.desc).getClassName();
    } catch (java.lang.AssertionError e) {
      //e.printStackTrace();
    } catch (java.lang.Exception e) {
      e.printStackTrace();
    }

    if (desc == null || desc.equals("null")) desc = min.desc;

    sb.append(desc);

    return sb.toString();
  }

  protected String printLdcInsnNode(LdcInsnNode ldc) {
    if (ldc.cst instanceof String)
      return nameOpcode(ldc.getOpcode()) + " \"" + StringEscapeUtils.escapeJava(ldc.cst.toString()) + "\" (" + ldc.cst.getClass().getCanonicalName() + ")";

    return nameOpcode(ldc.getOpcode()) + " " + StringEscapeUtils.escapeJava(ldc.cst.toString()) + " (" + ldc.cst.getClass().getCanonicalName() + ")";
  }

  protected String printInsnNode(InsnNode in) {
    return nameOpcode(in.getOpcode());
  }

  protected String printJumpInsnNode(JumpInsnNode jin) {
    return nameOpcode(jin.getOpcode()) + " L" + resolveLabel(jin.label);
  }

  protected String printLineNumberNode(LineNumberNode lnn) {
    if(BytecodeViewer.viewer.printLineNumbers.isSelected())
      return "// line " + lnn.line;
    
    return "";
  }

  protected String printLabelNode(LabelNode label) {
    return "L" + resolveLabel(label);
  }

  protected String printTypeInsnNode(TypeInsnNode tin) {
    try {
      String desc = tin.desc;
      try {
        if (Type.getType(tin.desc) != null) desc = Type.getType(tin.desc).getClassName();

        if (desc.equals("null")) desc = tin.desc;
      } catch (java.lang.ArrayIndexOutOfBoundsException ignored) {

      }
      return nameOpcode(tin.getOpcode()) + " " + desc;
    } catch (Exception e) {
      return nameOpcode(tin.getOpcode()) + " " + tin.desc;
    }
  }

  protected String printIincInsnNode(IincInsnNode iin) {
    return nameOpcode(iin.getOpcode()) + " " + iin.var + " " + iin.incr;
  }

  protected String printTableSwitchInsnNode(TableSwitchInsnNode tin) {
    StringBuilder line = new StringBuilder(nameOpcode(tin.getOpcode()) + " \n");
    List<?> labels = tin.labels;
    int count = 0;
    for (int i = tin.min; i < tin.max + 1; i++) {
      line.append("                val: ").append(i).append(" -> ").append("L").append(resolveLabel((LabelNode) labels.get(count++))).append("\n");
    }
    line.append("                default" + " -> L").append(resolveLabel(tin.dflt));
    return line.toString();
  }

  protected String printLookupSwitchInsnNode(LookupSwitchInsnNode lin) {
    StringBuilder line = new StringBuilder(nameOpcode(lin.getOpcode()) + ": \n");
    List<?> keys = lin.keys;
    List<?> labels = lin.labels;

    for (int i = 0; i < keys.size(); i++) {
      int key = (Integer) keys.get(i);
      LabelNode label = (LabelNode) labels.get(i);
      line.append("                val: ").append(key).append(" -> ").append("L").append(resolveLabel(label)).append("\n");
    }

    line.append("                default" + " -> L").append(resolveLabel(lin.dflt));
    return line.toString();
  }

  protected String printInvokeDynamicInsNode(InvokeDynamicInsnNode idin) {
    StringBuilder sb = new StringBuilder();
    sb.append(nameOpcode(idin.getOpcode())).append(" ").append(idin.bsm.getOwner()).append('.').append(idin.bsm.getName()).append(idin.bsm.getDesc()).append(" : ").append(idin.name).append(idin.desc);

    if (idin.bsmArgs != null) {
      for (Object o : idin.bsmArgs) {
        sb.append(" ");
        sb.append(o.toString());
      }
    }

    return sb.toString();
  }

  protected String printMultiANewArrayInsNode(MultiANewArrayInsnNode mana) {
    return nameOpcode(mana.getOpcode()) + " " + mana.dims + " : " + mana.desc;
  }

  private String printFrameNode(FrameNode frame) {
    StringBuilder sb = new StringBuilder();
    sb.append(nameFrameType(frame.type)).append(" ");
    sb.append("(Locals");
    if (frame.local != null && !frame.local.isEmpty()) {
      sb.append("[").append(frame.local.size()).append("]: ");
      sb.append(frame.local.stream().map(this::printFrameObject).collect(Collectors.joining(", ")));
    } else {
      sb.append("[0]");
    }
    sb.append(") ");

    sb.append("(Stack");
    if (frame.stack != null && !frame.stack.isEmpty()) {
      sb.append("[").append(frame.stack.size()).append("]: ");
      sb.append(frame.stack.stream().map(this::printFrameObject).collect(Collectors.joining(", ")));
    } else {
      sb.append("[0]");
    }
    sb.append(") ");

    return sb.toString();
  }

  private String printFrameObject(Object obj) {
    if (obj instanceof LabelNode) return "label [L" + resolveLabel((LabelNode) obj) + "]";
    if (obj instanceof Integer) {
      switch ((int) obj) {
        case 0:
          return "top";
        case 1:
          return "int";
        case 2:
          return "float";
        case 3:
          return "double";
        case 4:
          return "long";
        case 5:
          return "null";
        case 6:
          return "uninitialized this";
        default:
          return "unknown";
      }
    }
    if (obj instanceof String) return obj.toString();
    return "unknown [" + obj.toString() + "]";
  }

  private String nameFrameType(int type) {
    switch (type) {
      case F_NEW:
        return "    f_new";
      case F_FULL:
        return "    f_full";
      case F_APPEND:
        return "    f_append";
      case F_CHOP:
        return "    f_chop";
      case F_SAME:
        return "    f_same";
      case F_SAME1:
        return "    f_same1";
      default:
        return "    f_unknown" + type;
    }
  }

  protected String nameOpcode(int opcode) {
    return "    " + OpcodeInfo.OPCODES.get(opcode).toLowerCase();
  }

  protected int resolveLabel(LabelNode label) {
    if (labels.containsKey(label)) {
      return labels.get(label);
    } else {
            /*int newLabelIndex = labels.size() + 1;
            labels.put(label, newLabelIndex);
            return newLabelIndex;*/
      throw new IllegalStateException("LabelNode index not found. (Label not in InsnList?)");
    }
  }

  public static void saveTo(File file, InstructionPrinter printer) {
    try (FileWriter fw = new FileWriter(file); BufferedWriter bw = new BufferedWriter(fw)) {
      for (String s : printer.createPrint()) {
        bw.write(s);
        bw.newLine();
      }
    } catch (IOException e) {
      BytecodeViewer.handleException(e);
    }
  }

}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/bytecode/InstructionSearcher.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.bytecode;

import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FrameNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LineNumberNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl
 */

public class InstructionSearcher implements Opcodes {

    protected InsnList insns;
    protected InstructionPattern pattern;

    protected List<AbstractInsnNode[]> matches;

    public InstructionSearcher(InsnList insns, int[] opcodes) {
        this(insns, new InstructionPattern(opcodes));
    }

    public InstructionSearcher(InsnList insns, AbstractInsnNode[] ains) {
        this(insns, new InstructionPattern(ains));
    }

    public InstructionSearcher(InsnList insns, InstructionPattern pattern) {
        this.insns = insns;
        this.pattern = pattern;
        matches = new ArrayList<>();
    }

    public boolean search() {
        for (AbstractInsnNode ain : insns.toArray()) {
            if (ain instanceof LineNumberNode || ain instanceof FrameNode)
                continue;
            if (pattern.accept(ain)) {
                matches.add(pattern.getLastMatch());
                pattern.resetMatch();
            }
        }
        return size() != 0;
    }

    public List<AbstractInsnNode[]> getMatches() {
        return matches;
    }

    public int size() {
        return matches.size();
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/bytecode/MethodNodeDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.bytecode;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LocalVariableNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TryCatchBlockNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl
 */

public class MethodNodeDecompiler {

    public static PrefixedStringBuilder decompile(PrefixedStringBuilder sb,
                                                  MethodNode m, ClassNode cn) {
        String class_;
        if (cn.name.contains("/")) {
            class_ = cn.name.substring(cn.name.lastIndexOf("/") + 1);
        } else {
            class_ = cn.name;
        }

        String s = getAccessString(m.access);
        sb.append("     ");
        sb.append(s);
        if (s.length() > 0)
            sb.append(" ");

        if (m.name.equals("<init>")) {
            sb.append(class_);
        } else if (!m.name.equals("<clinit>")) {
            Type returnType = Type.getReturnType(m.desc);
            sb.append(returnType.getClassName());
            sb.append(" ");
            sb.append(m.name);
        }

        TypeAndName[] args = new TypeAndName[0];

        if (!m.name.equals("<clinit>")) {
            sb.append("(");

            final Type[] argTypes = Type.getArgumentTypes(m.desc);
            args = new TypeAndName[argTypes.length];

            for (int i = 0; i < argTypes.length; i++) {
                final Type type = argTypes[i];

                final TypeAndName tan = new TypeAndName();
                final String argName = "arg" + i;

                tan.name = argName;
                tan.type = type;

                args[i] = tan;

                sb.append(type.getClassName() + " " + argName
                        + (i < argTypes.length - 1 ? ", " : ""));
            }

            sb.append(")");
        }

        int amountOfThrows = m.exceptions.size();
        if (amountOfThrows > 0) {
            sb.append(" throws ");
            sb.append(m.exceptions.get(0));// exceptions is list<string>
            for (int i = 1; i < amountOfThrows; i++) {
                sb.append(", ");
                sb.append(m.exceptions.get(i));
            }
        }

        if (s.contains("abstract")) {
            sb.append(" {}");
            sb.append(" //");
            sb.append(m.desc);
            sb.append(nl);
        } else {

            sb.append(" {");

            if (BytecodeViewer.viewer.debugHelpers.isSelected()) {
                if (m.name.equals("<clinit>"))
                    sb.append(" // <clinit>");
                else if (m.name.equals("<init>"))
                    sb.append(" // <init>");
            }

            sb.append(" //");
            sb.append(m.desc);

            sb.append(nl);

            if (m.signature != null) {
                sb.append("         <sig:").append(m.signature).append(">");
            }

            if (m.annotationDefault != null) {
                sb.append(m.annotationDefault);
                sb.append("\n");
            }

            InstructionPrinter insnPrinter = new InstructionPrinter(m, args);

            addAttrList(m.attrs, "attr", sb, insnPrinter);
            addAttrList(m.invisibleAnnotations, "invisAnno", sb, insnPrinter);
            addAttrList(m.invisibleAnnotations, "invisLocalVarAnno", sb,
                    insnPrinter);
            addAttrList(m.invisibleTypeAnnotations, "invisTypeAnno", sb,
                    insnPrinter);
            addAttrList(m.localVariables, "localVar", sb, insnPrinter);
            addAttrList(m.visibleAnnotations, "visAnno", sb, insnPrinter);
            addAttrList(m.visibleLocalVariableAnnotations, "visLocalVarAnno",
                    sb, insnPrinter);
            addAttrList(m.visibleTypeAnnotations, "visTypeAnno", sb,
                    insnPrinter);

            List<TryCatchBlockNode> tryCatchBlocks = m.tryCatchBlocks;
            for (int i = 0; i < tryCatchBlocks.size(); i++) {
                TryCatchBlockNode o = tryCatchBlocks.get(i);
                sb.append("         ");
                sb.append("TryCatch").append(i).append(": L");
                sb.append(insnPrinter.resolveLabel(o.start));
                sb.append(" to L");
                sb.append(insnPrinter.resolveLabel(o.end));
                sb.append(" handled by L");
                sb.append(insnPrinter.resolveLabel(o.handler));
                sb.append(": ");
                if (o.type != null)
                    sb.append(o.type);
                else
                    sb.append("Type is null.");
                sb.append(nl);
            }
            for (String insn : insnPrinter.createPrint()) {
                sb.append("         ");
                sb.append(insn);
                sb.append(nl);
            }
            sb.append("     }" + nl);
        }
        return sb;
    }

    private static void addAttrList(List<?> list, String name,
                                    PrefixedStringBuilder sb, InstructionPrinter insnPrinter) {
        if (list == null)
            return;
        if (list.size() > 0) {
            for (Object o : list) {
                sb.append("         <");
                sb.append(name);
                sb.append(":");
                sb.append(printAttr(o, insnPrinter));
                sb.append(">");
                sb.append("\n");
            }
            sb.append("\n");
        }
    }

    private static String printAttr(Object o, InstructionPrinter insnPrinter) {
        if (o instanceof LocalVariableNode) {
            LocalVariableNode lvn = (LocalVariableNode) o;
            return "index=" + lvn.index + " , name=" + lvn.name + " , desc="
                    + lvn.desc + ", sig=" + lvn.signature + ", start=L"
                    + insnPrinter.resolveLabel(lvn.start) + ", end=L"
                    + insnPrinter.resolveLabel(lvn.end);
        } else if (o instanceof AnnotationNode) {
            AnnotationNode an = (AnnotationNode) o;
            StringBuilder sb = new StringBuilder();
            sb.append("desc = ");
            sb.append(an.desc);
            sb.append(" , values = ");
            if (an.values != null) {
                sb.append(Arrays.toString(an.values.toArray()));
            } else {
                sb.append("[]");
            }
            return sb.toString();
        }
        if (o == null)
            return "";
        return o.toString();
    }

    private static String getAccessString(int access) {
        // public, protected, private, abstract, static,
        // final, synchronized, native & strictfp are permitted
        List<String> tokens = new ArrayList<>();
        if ((access & Opcodes.ACC_PUBLIC) != 0)
            tokens.add("public");
        if ((access & Opcodes.ACC_PRIVATE) != 0)
            tokens.add("private");
        if ((access & Opcodes.ACC_PROTECTED) != 0)
            tokens.add("protected");
        if ((access & Opcodes.ACC_STATIC) != 0)
            tokens.add("static");
        if ((access & Opcodes.ACC_ABSTRACT) != 0)
            tokens.add("abstract");
        if ((access & Opcodes.ACC_FINAL) != 0)
            tokens.add("final");
        if ((access & Opcodes.ACC_SYNCHRONIZED) != 0)
            tokens.add("synchronized");
        if ((access & Opcodes.ACC_NATIVE) != 0)
            tokens.add("native");
        if ((access & Opcodes.ACC_STRICT) != 0)
            tokens.add("strictfp");
        if ((access & Opcodes.ACC_BRIDGE) != 0)
            tokens.add("bridge");
        if ((access & Opcodes.ACC_SYNTHETIC) != 0)
            tokens.add("synthetic");
        if ((access & Opcodes.ACC_VARARGS) != 0)
            tokens.add("varargs");
        if (tokens.isEmpty())
            return "";
        // hackery delimeters
        StringBuilder sb = new StringBuilder(tokens.get(0));
        for (int i = 1; i < tokens.size(); i++) {
            sb.append(" ");
            sb.append(tokens.get(i));
        }
        return sb.toString();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/bytecode/PrefixedStringBuilder.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.bytecode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl
 */

public class PrefixedStringBuilder {

    protected StringBuilder sb;
    protected String prefix;

    public PrefixedStringBuilder() {
        sb = new StringBuilder();
    }

    public PrefixedStringBuilder append(String s) {
        sb.append(s);
        if (s.contains("\n") && (prefix != null) && (prefix.length() > 0))// insert
            // the
            // prefix
            // at
            // every
            // new
            // line,
            // overridable
            sb.append(prefix);
        return this;
    }

    public PrefixedStringBuilder append(Object o) {
        return append(o.toString());
    }

    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }

    public void trimPrefix(int amount) {
        if (prefix == null)
            return;
        if (prefix.length() < amount)
            return;
        prefix = prefix.substring(0, prefix.length() - amount);
    }

    public void appendPrefix(String s) {
        if (prefix == null)
            prefix = "";
        prefix += s;
    }

    public String getPrefix() {
        return prefix;
    }

    @Override
    public String toString() {
        return sb.toString();
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/bytecode/TypeAndName.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.bytecode;

import org.objectweb.asm.Type;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Container class for type and name. Used to pass arguments and local variables
 * around
 *
 * @author Waterwolf
 * @since 10/02/2011
 */
public class TypeAndName {
    public Type type = null;
    public String name = null;
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/ASMTextifierDisassembler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.io.PrintWriter;
import java.io.StringWriter;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.util.Textifier;
import org.objectweb.asm.util.TraceClassVisitor;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Objectweb ASM Textifier output
 *
 * @author Thiakil
 */
public class ASMTextifierDisassembler extends InternalDecompiler
{
    @Override
    public String decompileClassNode(ClassNode cn, byte[] b) {
        StringWriter writer = new StringWriter();
        cn.accept(new TraceClassVisitor(null, new Textifier(), new PrintWriter(writer)));
        return writer.toString();
    }

    @Override
    public void decompileToZip(String sourceJar, String zipName) {

    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/BytecodeDisassembler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.util.ArrayList;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.bytecode.ClassNodeDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.bytecode.PrefixedStringBuilder;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/3/2021
 */
public class BytecodeDisassembler extends InternalDecompiler
{
	@Override
	public String decompileClassNode(ClassNode cn, byte[] b) {
		return ClassNodeDecompiler.decompile(new PrefixedStringBuilder(),
				new ArrayList<>(), cn).toString();
	}
	
	@Override
	public void decompileToZip(String sourceJar, String zipName) {
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/CFRDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.zip.ZipException;
import java.util.zip.ZipOutputStream;
import org.apache.commons.io.IOUtils;
import org.benf.cfr.reader.api.CfrDriver;
import org.benf.cfr.reader.api.ClassFileSource;
import org.benf.cfr.reader.api.OutputSinkFactory;
import org.benf.cfr.reader.api.SinkReturns;
import org.benf.cfr.reader.bytecode.analysis.parse.utils.Pair;
import org.benf.cfr.reader.state.ClassFileSourceImpl;
import org.benf.cfr.reader.util.getopt.Options;
import org.benf.cfr.reader.util.getopt.OptionsImpl;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

import static the.bytecode.club.bytecodeviewer.Constants.nl;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.CFR;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.ERROR;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * CFR Java Wrapper
 *
 * @author GraxCode
 *         Taken mostly out of Threadtear.
 */
public class CFRDecompiler extends InternalDecompiler {

    private static final String CLASS_SUFFIX = ".class";

    @Override
    public String decompileClassNode(ClassNode cn, byte[] content) {
        return decompile(cn, cn.name, content);
    }

    private String decompile(ClassNode cn, String name, byte[] content) {
        try {
            String classPath = name + (name.endsWith(CLASS_SUFFIX) ? "" : CLASS_SUFFIX);

            StringBuilder builder = new StringBuilder();
            Consumer<SinkReturns.Decompiled> dumpDecompiled = d -> builder.append(d.getJava());

            Options options = generateOptions();
            ClassFileSource source = new BCVDataSource(options, cn, classPath, content);
            CfrDriver driver = new CfrDriver.Builder()
                    .withClassFileSource(source)
                    .withBuiltOptions(options)
                    .withOutputSink(new BCVOutputSinkFactory(dumpDecompiled))
                    .build();
            driver.analyse(Collections.singletonList(name));

            return builder.toString();
        } catch (Throwable t) {
            t.printStackTrace();
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            t.printStackTrace(pw);
            return CFR + " " + ERROR + "! " + ExceptionUI.SEND_STACKTRACE_TO +
                    nl + nl + TranslatedStrings.SUGGESTED_FIX_DECOMPILER_ERROR +
                    nl + nl + sw;
        }
    }

    @Override
    public void decompileToZip(String sourceJar, String outJar) {
        try (JarFile jfile = new JarFile(new File(sourceJar));
             FileOutputStream dest = new FileOutputStream(outJar);
             BufferedOutputStream buffDest = new BufferedOutputStream(dest);
             ZipOutputStream out = new ZipOutputStream(buffDest)) {
            byte[] data = new byte[1024];

            Enumeration<JarEntry> ent = jfile.entries();
            Set<JarEntry> history = new HashSet<>();
            while (ent.hasMoreElements()) {
                JarEntry entry = ent.nextElement();
                if (entry.getName().endsWith(CLASS_SUFFIX)) {
                    JarEntry etn = new JarEntry(entry.getName().replace(CLASS_SUFFIX, ".java"));
                    if (history.add(etn)) {
                        out.putNextEntry(etn);
                        try {
                            IOUtils.write(decompile(null, entry.getName(),
                                            IOUtils.toByteArray(jfile.getInputStream(entry))),
                                    out, StandardCharsets.UTF_8);
                        } finally {
                            out.closeEntry();
                        }
                    }
                } else {
                    try {
                        JarEntry etn = new JarEntry(entry.getName());
                        if (history.add(etn)) continue;
                        history.add(etn);
                        out.putNextEntry(etn);
                        try (InputStream in = jfile.getInputStream(entry)) {
                            if (in != null) {
                                int count;
                                while ((count = in.read(data, 0, 1024)) != -1) {
                                    out.write(data, 0, count);
                                }
                            }
                        } finally {
                            out.closeEntry();
                        }
                    } catch (ZipException ze) {
                        // some jars contain duplicate pom.xml entries: ignore it
                        if (!ze.getMessage().contains("duplicate")) {
                            throw ze;
                        }
                    }
                }
            }
        } catch (StackOverflowError | Exception e) {
            BytecodeViewer.handleException(e);
        }
    }

    public Options generateOptions() {
        Map<String, String> options = new HashMap<>();
        options.put("decodeenumswitch", String.valueOf(BytecodeViewer.viewer.decodeEnumSwitch.isSelected()));
        options.put("sugarenums", String.valueOf(BytecodeViewer.viewer.sugarEnums.isSelected()));
        options.put("decodestringswitch", String.valueOf(BytecodeViewer.viewer.decodeStringSwitch.isSelected()));
        options.put("arrayiter", String.valueOf(BytecodeViewer.viewer.arrayiter.isSelected()));
        options.put("collectioniter", String.valueOf(BytecodeViewer.viewer.collectioniter.isSelected()));
        options.put("innerclasses", String.valueOf(BytecodeViewer.viewer.innerClasses.isSelected()));
        options.put("removeboilerplate", String.valueOf(BytecodeViewer.viewer.removeBoilerPlate.isSelected()));
        options.put("removeinnerclasssynthetics",
                String.valueOf(BytecodeViewer.viewer.removeInnerClassSynthetics.isSelected()));
        options.put("decodelambdas", String.valueOf(BytecodeViewer.viewer.decodeLambdas.isSelected()));
        options.put("hidebridgemethods", String.valueOf(BytecodeViewer.viewer.hideBridgeMethods.isSelected()));
        options.put("liftconstructorinit", String.valueOf(BytecodeViewer.viewer.liftConstructorInit.isSelected()));
        options.put("removebadgenerics", String.valueOf(BytecodeViewer.viewer.removeBadGenerics.isSelected()));
        options.put("sugarasserts", String.valueOf(BytecodeViewer.viewer.sugarAsserts.isSelected()));
        options.put("sugarboxing", String.valueOf(BytecodeViewer.viewer.sugarBoxing.isSelected()));
        options.put("showversion", String.valueOf(BytecodeViewer.viewer.showVersion.isSelected()));
        options.put("decodefinally", String.valueOf(BytecodeViewer.viewer.decodeFinally.isSelected()));
        options.put("tidymonitors", String.valueOf(BytecodeViewer.viewer.tidyMonitors.isSelected()));
        options.put("lenient", String.valueOf(BytecodeViewer.viewer.lenient.isSelected()));
        options.put("dumpclasspath", String.valueOf(BytecodeViewer.viewer.dumpClassPath.isSelected()));
        options.put("comments", String.valueOf(BytecodeViewer.viewer.comments.isSelected()));
        options.put("forcetopsort", String.valueOf(BytecodeViewer.viewer.forceTopSort.isSelected()));
        options.put("forcetopsortaggress", String.valueOf(BytecodeViewer.viewer.forceTopSortAggress.isSelected()));
        options.put("stringbuffer", String.valueOf(BytecodeViewer.viewer.stringBuffer.isSelected()));
        options.put("stringbuilder", String.valueOf(BytecodeViewer.viewer.stringBuilder.isSelected()));
        options.put("silent", String.valueOf(BytecodeViewer.viewer.silent.isSelected()));
        options.put("recover", String.valueOf(BytecodeViewer.viewer.recover.isSelected()));
        options.put("eclipse", String.valueOf(BytecodeViewer.viewer.eclipse.isSelected()));
        options.put("override", String.valueOf(BytecodeViewer.viewer.override.isSelected()));
        options.put("showinferrable", String.valueOf(BytecodeViewer.viewer.showInferrable.isSelected()));
        options.put("aexagg", String.valueOf(BytecodeViewer.viewer.aexagg.isSelected()));
        options.put("hideutf", String.valueOf(BytecodeViewer.viewer.hideUTF.isSelected()));
        options.put("hidelongstrings", String.valueOf(BytecodeViewer.viewer.hideLongStrings.isSelected()));
        options.put("commentmonitors", String.valueOf(BytecodeViewer.viewer.commentMonitor.isSelected()));
        options.put("allowcorrecting", String.valueOf(BytecodeViewer.viewer.allowCorrecting.isSelected()));
        options.put("labelledblocks", String.valueOf(BytecodeViewer.viewer.labelledBlocks.isSelected()));
        options.put("j14classobj", String.valueOf(BytecodeViewer.viewer.j14ClassOBJ.isSelected()));
        options.put("hidelangimports", String.valueOf(BytecodeViewer.viewer.hideLangImports.isSelected()));
        options.put("recovertypehints", String.valueOf(BytecodeViewer.viewer.recoveryTypehInts.isSelected()));
        options.put("forcereturningifs", String.valueOf(BytecodeViewer.viewer.forceTurningIFs.isSelected()));
        options.put("forloopaggcapture", String.valueOf(BytecodeViewer.viewer.forLoopAGGCapture.isSelected()));
        return new OptionsImpl(options);
    }

    private static class BCVDataSource extends ClassFileSourceImpl {

        private final ResourceContainer container;
        private final String classFilePath;
        private final byte[] content;

        private BCVDataSource(Options options, ClassNode cn, String classFilePath, byte[] content) {
            super(options);
            this.container = BytecodeViewer.getResourceContainers().stream()
                    .filter(rc -> rc.resourceClasses.containsValue(cn))
                    .findFirst().orElse(null);
            this.classFilePath = classFilePath;
            this.content = content;
        }

        @Override
        public Pair<byte[], String> getClassFileContent(String classFilePath) throws IOException {
            if (classFilePath.equals(this.classFilePath) && content != null) return Pair.make(content, classFilePath);
            if (container == null) return super.getClassFileContent(classFilePath);
            byte[] data = container.resourceClassBytes.get(classFilePath);
            if (data == null) return super.getClassFileContent(classFilePath);
            return Pair.make(data, classFilePath);
        }

    }

    private static class BCVOutputSinkFactory implements OutputSinkFactory {

        private final Consumer<SinkReturns.Decompiled> dumpDecompiled;

        private BCVOutputSinkFactory(Consumer<SinkReturns.Decompiled> dumpDecompiled) {
            this.dumpDecompiled = dumpDecompiled;
        }

        @Override
        public List<SinkClass> getSupportedSinks(SinkType sinkType, Collection<SinkClass> available) {
            return Collections.singletonList(SinkClass.DECOMPILED);
        }

        @Override
        public <T> Sink<T> getSink(SinkType sinkType, SinkClass sinkClass) {
            if (sinkType == SinkType.JAVA && sinkClass == SinkClass.DECOMPILED) {
                return x -> dumpDecompiled.accept((SinkReturns.Decompiled) x);
            }
            return ignore -> {
            };
        }

    }

}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/FernFlowerDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import me.konloch.kontainer.io.DiskReader;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.LAUNCH_DECOMPILERS_IN_NEW_PROCESS;
import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.nl;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.ERROR;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.FERNFLOWER;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A FernFlower wrapper with all the options (except 2)
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/26/2011
 */
public class FernFlowerDecompiler extends InternalDecompiler
{
    @Override
    public void decompileToZip(String sourceJar, String zipName)
    {
        File tempZip = new File(sourceJar);

        File f = new File(tempDirectory + fs + "temp" + fs);
        f.mkdir();

        try {
            org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler.main(generateMainMethod(tempZip.getAbsolutePath(), tempDirectory + "./temp/"));
        } catch (StackOverflowError | Exception ignored) { }

        File tempZip2 = new File(tempDirectory + fs + "temp" + fs + tempZip.getName());
        if (tempZip2.exists())
            tempZip2.renameTo(new File(zipName));

        f.delete();
    }

    @Override
    public String decompileClassNode(final ClassNode cn, byte[] b)
    {
        String start = tempDirectory + fs + MiscUtils.getUniqueName("", ".class");

        final File tempClass = new File(start + ".class");
        
        String exception = "";
        try (FileOutputStream fos = new FileOutputStream(tempClass)) {
            fos.write(b);
        } catch (final IOException e) {
            StringWriter exceptionWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(exceptionWriter));
            e.printStackTrace();
            exception = exceptionWriter.toString();
        }


        if (LAUNCH_DECOMPILERS_IN_NEW_PROCESS)
        {
            /*try
            {
                BytecodeViewer.sm.pauseBlocking();
                ProcessBuilder pb = new ProcessBuilder(ArrayUtils.addAll(
                        new String[]{ExternalResources.getSingleton().getJavaCommand(true), "-jar", ExternalResources.getSingleton().findLibrary("fernflower")},
                        generateMainMethod(tempClass.getAbsolutePath(),
                                new File(tempDirectory).getAbsolutePath())
                ));
                Process p = pb.start();
                BytecodeViewer.createdProcesses.add(p);
                p.waitFor();
            } catch (Exception e) {
                BytecodeViewer.handleException(e);
            } finally {
                BytecodeViewer.sm.resumeBlocking();
            }*/
        }
        else
        {
            try {
                org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler.main(
                        generateMainMethod(tempClass.getAbsolutePath(), new File(tempDirectory).getAbsolutePath()));
            } catch (Throwable e) {
                StringWriter exceptionWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(exceptionWriter));
                e.printStackTrace();
                exception =  exceptionWriter.toString();
            }
        }

        tempClass.delete();

        final File outputJava = new File(start + ".java");
        if (outputJava.exists()) {
            String s;
            try {
                s = DiskReader.loadAsString(outputJava.getAbsolutePath());
                
                outputJava.delete();
                
                return s;
            } catch (Exception e) {
                StringWriter exceptionWriter = new StringWriter();
                e.printStackTrace(new PrintWriter(exceptionWriter));
                e.printStackTrace();

                exception += nl + nl + exceptionWriter;
            }
        }
        
        return FERNFLOWER + " " + ERROR + "! " + ExceptionUI.SEND_STACKTRACE_TO +
                nl + nl + TranslatedStrings.SUGGESTED_FIX_DECOMPILER_ERROR +
                nl + nl + exception;
    }

    private String[] generateMainMethod(String className, String folder) {
        return new String[]{
                "-rbr=" + r(BytecodeViewer.viewer.rbr.isSelected()),
                "-rsy=" + r(BytecodeViewer.viewer.rsy.isSelected()),
                "-din=" + r(BytecodeViewer.viewer.din.isSelected()),
                "-dc4=" + r(BytecodeViewer.viewer.dc4.isSelected()),
                "-das=" + r(BytecodeViewer.viewer.das.isSelected()),
                "-hes=" + r(BytecodeViewer.viewer.hes.isSelected()),
                "-hdc=" + r(BytecodeViewer.viewer.hdc.isSelected()),
                "-dgs=" + r(BytecodeViewer.viewer.dgs.isSelected()),
                "-ner=" + r(BytecodeViewer.viewer.ner.isSelected()),
                "-den=" + r(BytecodeViewer.viewer.den.isSelected()),
                "-rgn=" + r(BytecodeViewer.viewer.rgn.isSelected()),
                "-bto=" + r(BytecodeViewer.viewer.bto.isSelected()),
                "-nns=" + r(BytecodeViewer.viewer.nns.isSelected()),
                "-uto=" + r(BytecodeViewer.viewer.uto.isSelected()),
                "-udv=" + r(BytecodeViewer.viewer.udv.isSelected()),
                "-rer=" + r(BytecodeViewer.viewer.rer.isSelected()),
                "-fdi=" + r(BytecodeViewer.viewer.fdi.isSelected()),
                "-asc=" + r(BytecodeViewer.viewer.asc.isSelected()),
                "-ren=" + r(BytecodeViewer.viewer.ren.isSelected()), className,
                folder};
    }

    private String r(boolean b) {
        if (b) {
            return "1";
        } else {
            return "0";
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/JADXDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import jadx.api.JadxArgs;
import jadx.api.JadxDecompiler;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Random;
import me.konloch.kontainer.io.DiskReader;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.nl;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.ERROR;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.JADX;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * JADX Java Wrapper
 *
 * @author Konloch
 */
public class JADXDecompiler extends InternalDecompiler
{
    private final Random r = new Random();
    
    @Override
    public String decompileClassNode(ClassNode cn, byte[] b) {
        String fileStart = tempDirectory + fs;

        String exception = "";
        final File tempClass = new File(MiscUtils.getUniqueName(fileStart, ".class") + ".class");

        try (FileOutputStream fos = new FileOutputStream(tempClass)) {
            fos.write(b);
        } catch (final IOException e) {
            BytecodeViewer.handleException(e);
        }

        File fuckery = new File(fuckery(fileStart));
        fuckery.mkdirs();
        
        try {
            JadxArgs args = new JadxArgs();
            args.setInputFile(tempClass);
            args.setOutDir(fuckery);
            args.setOutDirSrc(fuckery);
            args.setOutDirRes(fuckery);

            JadxDecompiler jadx = new JadxDecompiler(args);
            jadx.load();
            jadx.saveSources();
        } catch (StackOverflowError | Exception e) {
            StringWriter exceptionWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(exceptionWriter));
            e.printStackTrace();
            exception = exceptionWriter.toString();
        }

        tempClass.delete();

        if (fuckery.exists())
            return findFile(MiscUtils.listFiles(fuckery));
        
        if(exception.isEmpty())
            exception = "Decompiled source file not found!";

        return JADX + " " + ERROR + "! " + ExceptionUI.SEND_STACKTRACE_TO +
                nl + nl + TranslatedStrings.SUGGESTED_FIX_DECOMPILER_ERROR +
                nl + nl + exception;
    }

    //TODO remove
    public String fuckery(String start)
    {
        int failSafe = 0;
        while (failSafe++ <= 42069)
        {
            File f = new File(start + r.nextInt(Integer.MAX_VALUE));
            if (!f.exists())
                return f.toString();
        }
        
        return null;
    }

    public String findFile(File[] fA) {
        for (File f : fA) {
            if (f.isDirectory())
                return findFile(MiscUtils.listFiles(f));
            else {
                String s;
                try {
                    s = DiskReader.loadAsString(f.getAbsolutePath());
                } catch (Exception e) {
                    StringWriter sw = new StringWriter();
                    e.printStackTrace(new PrintWriter(sw));
                    e.printStackTrace();
                    String exception = ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
                    
                    return JADX + " " + ERROR + "! " + ExceptionUI.SEND_STACKTRACE_TO +
                            nl + nl + TranslatedStrings.SUGGESTED_FIX_DECOMPILER_ERROR +
                            nl + nl + exception;
                }
                return s;
            }
        }
        
        return "JADX error!" +
                nl + nl + TranslatedStrings.SUGGESTED_FIX_DECOMPILER_ERROR;
    }

    @Override
    public void decompileToZip(String sourceJar, String zipName) { }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/JDGUIDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import me.konloch.kontainer.io.DiskReader;
import org.jd.core.v1.ClassFileToJavaSourceDecompiler;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.jdgui.CommonPreferences;
import the.bytecode.club.bytecodeviewer.decompilers.jdgui.DirectoryLoader;
import the.bytecode.club.bytecodeviewer.decompilers.jdgui.JDGUIClassFileUtil;
import the.bytecode.club.bytecodeviewer.decompilers.jdgui.PlainTextPrinter;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.nl;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.ERROR;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.JDGUI;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * JD-Core Decompiler Wrapper
 *
 * @author Konloch
 * @author JD-Core developers
 */

public class JDGUIDecompiler extends InternalDecompiler
{

    @Override
    public String decompileClassNode(ClassNode cn, byte[] b) {
        String exception;
        try {
            final File tempDirectory = new File(Constants.tempDirectory + fs + MiscUtils.randomString(32) + fs);
            tempDirectory.mkdir();
            
            final File tempClass = new File(tempDirectory.getAbsolutePath() + fs + cn.name + ".class");
            final File tempJava = new File(tempDirectory.getAbsolutePath() + fs + cn.name + ".java");

            if (cn.name.contains("/")) {
                String[] raw = cn.name.split("/");
                String path = tempDirectory.getAbsolutePath() + fs;
                for (int i = 0; i < raw.length - 1; i++) {
                    path += raw[i] + fs;
                    File f = new File(path);
                    f.mkdir();
                }
            }

            try (FileOutputStream fos = new FileOutputStream(tempClass)) {
                fos.write(b);
            } catch (final IOException e) {
                BytecodeViewer.handleException(e);
            }


            String pathToClass = tempClass.getAbsolutePath().replace('/', File.separatorChar).replace('\\', File.separatorChar);
            String directoryPath = JDGUIClassFileUtil.ExtractDirectoryPath(pathToClass);
            String internalPath = JDGUIClassFileUtil.ExtractInternalPath(directoryPath, pathToClass);

            CommonPreferences preferences = new CommonPreferences() {
                @Override
                public boolean isShowLineNumbers() {
                    return false;
                }

                @Override
                public boolean isMergeEmptyLines() {
                    return true;
                }
            };

            DirectoryLoader loader = new DirectoryLoader(new File(directoryPath));

            //PrintStream ps = new PrintStream("test.html");
            //HtmlPrinter printer = new HtmlPrinter(ps);
            org.jd.core.v1.api.Decompiler decompiler = new ClassFileToJavaSourceDecompiler();

            try (PrintStream ps = new PrintStream(tempJava.getAbsolutePath());
                 PlainTextPrinter printer = new PlainTextPrinter(preferences, ps)) {
                decompiler.decompile(loader, printer, internalPath, preferences.getPreferences());
            }

            return DiskReader.loadAsString(tempJava.getAbsolutePath());
        } catch (Exception e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            e.printStackTrace();

            exception = ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
        }
        
        return JDGUI + " " + ERROR + "! " + ExceptionUI.SEND_STACKTRACE_TO +
                nl + nl + TranslatedStrings.SUGGESTED_FIX_DECOMPILER_ERROR +
                nl + nl + exception;
    }

    @Override
    public void decompileToZip(String sourceJar, String zipName) {
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/JavapDisassembler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.io.File;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import me.konloch.kontainer.io.DiskWriter;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.gui.components.JFrameConsolePrintStream;
import the.bytecode.club.bytecodeviewer.resources.ExternalResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.api.ExceptionUI.SEND_STACKTRACE_TO;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Javap disassembler
 *
 * https://github.com/Konloch/bytecode-viewer/issues/93
 *
 * @author Konloch
 * @since 07/11/2021
 */

public class JavapDisassembler extends InternalDecompiler
{
    @Override
    public String decompileClassNode(ClassNode cn, byte[] b)
    {
        if(!ExternalResources.getSingleton().hasJavaToolsSet())
            return "Set Java Tools Path!";
        
        return synchronizedDecompilation(cn, b);
    }
    
    private synchronized String synchronizedDecompilation(ClassNode cn, byte[] b)
    {
        final File tempDirectory = new File(Constants.tempDirectory + fs + MiscUtils.randomString(32) + fs);
        tempDirectory.mkdir();
        final File tempClass = new File(Constants.tempDirectory + fs + "temp" + MiscUtils.randomString(32) + ".class");
    
        DiskWriter.replaceFileBytes(tempClass.getAbsolutePath(), b, false);
    
        JFrameConsolePrintStream sysOutBuffer = null;
        try
        {
            //load java tools into a temporary classloader
            URLClassLoader child = new URLClassLoader(
                    new URL[] {new File(Configuration.javaTools).toURI().toURL()},
                    this.getClass().getClassLoader()
            );
        
            //setup reflection
            Class<?> javap = child.loadClass("com.sun.tools.javap.Main");
            Method main = javap.getMethod("main", String[].class);
        
            //pipe sys out
            sysOutBuffer = new JFrameConsolePrintStream("", false);
        
            //silence security manager debugging
            BytecodeViewer.sm.silenceExec(true);
        
            //invoke Javap
            main.invoke(null, (Object) new String[]{
                    "-p", //Shows all classes and members
                    "-c", //Prints out disassembled code
                    //"-l", //Prints out line and local variable tables
                    "-constants", //Shows static final constants
                    tempClass.getAbsolutePath()});
        }
        catch (IllegalAccessException e)
        {
            return TranslatedStrings.ILLEGAL_ACCESS_ERROR.toString();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        finally
        {
            BytecodeViewer.sm.silenceExec(false);
            tempClass.delete();
        }
    
        if(sysOutBuffer != null)
        {
            sysOutBuffer.finished();
            return sysOutBuffer.getTextAreaOutputStreamOut().getBuffer().toString();
        }
    
        return SEND_STACKTRACE_TO;
    }

    @Override
    public void decompileToZip(String sourceJar, String zipName) { }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/KrakatauDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Arrays;
import java.util.stream.Collectors;
import me.konloch.kontainer.io.DiskReader;
import org.apache.commons.lang3.ArrayUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.resources.ExternalResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;
import the.bytecode.club.bytecodeviewer.util.ZipUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.krakatauWorkingDirectory;
import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Krakatau Java Decompiler Wrapper, requires Python 2.7
 *
 * @author Konloch
 */

public class KrakatauDecompiler extends InternalDecompiler
{
    public String buildCLIArguments()
    {
        if (Configuration.library.isEmpty())
            return "";

        File dir = new File(Configuration.library);
        if (!dir.exists())
            return "";
        if (!dir.isDirectory())
            return ";" + Configuration.library;

        File[] files = dir.listFiles();
        if (files == null || files.length == 0)
            return "";

        return ";" + Arrays.stream(files).filter(File::isFile)
                .map(File::getAbsolutePath).collect(Collectors.joining(";"));
    }

    public String decompileClassNode(File krakatauTempJar, File krakatauTempDir, ClassNode cn)
    {
        if(!ExternalResources.getSingleton().hasSetPython2Command())
            return TranslatedStrings.YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH.toString();

        ExternalResources.getSingleton().rtCheck();
        if (Configuration.rt.isEmpty())
        {
            BytecodeViewer.showMessage(TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A
                    + "\r\n" + TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B);
            ExternalResources.getSingleton().selectJRERTLibrary();
        }

        if (Configuration.rt.isEmpty())
        {
            BytecodeViewer.showMessage(TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A
                    + "\r\n" + TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B);
            return TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A
                    + " " + TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B;
        }

        String s = ExceptionUI.SEND_STACKTRACE_TO_NL;

        try {
            String[] pythonCommands = new String[]{Configuration.python2};
            if(Configuration.python2Extra)
                pythonCommands = ArrayUtils.addAll(pythonCommands, "-2");
            
            ProcessBuilder pb = new ProcessBuilder(ArrayUtils.addAll(
                    pythonCommands,
                    "-O", //love you storyyeller <3
                    krakatauWorkingDirectory + fs + "decompile.py",
                    "-skip", //love you storyyeller <3
                    "-nauto",
                    "-path",
                    Configuration.rt + ";" + krakatauTempJar.getAbsolutePath() + buildCLIArguments(),
                    "-out",
                    krakatauTempDir.getAbsolutePath(),
                    cn.name + ".class"
            ));

            Process process = pb.start();
            BytecodeViewer.createdProcesses.add(process);

            StringBuilder log = new StringBuilder(TranslatedStrings.PROCESS2 + nl + nl);

            //Read out dir output
            try (InputStream is = process.getInputStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null) {
                    log.append(nl).append(line);
                }
            }

            log.append(nl).append(nl).append(TranslatedStrings.ERROR2).append(nl).append(nl);

            try (InputStream is = process.getErrorStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null) {
                    log.append(nl).append(line);
                }
            }

            int exitValue = process.waitFor();
            log.append(nl).append(nl).append(TranslatedStrings.EXIT_VALUE_IS).append(" ").append(exitValue);
            s = log.toString();

            //if the motherfucker failed this'll fail, aka wont set.
            s = DiskReader.loadAsString(krakatauTempDir.getAbsolutePath() + fs + cn.name + ".java");
        } catch (Exception e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            e.printStackTrace();
            s += nl + ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
        }

        return s;
    }

    @Override
    public String decompileClassNode(ClassNode cn, byte[] b)
    {
        //TODO look into transforming through krakatau as a zip rather than direct classfile
        
        if(!ExternalResources.getSingleton().hasSetPython2Command())
            return TranslatedStrings.YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH.toString();
        
        if (Configuration.rt.isEmpty()) {
            BytecodeViewer.showMessage(TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A
                    + "\r\n" + TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B);
            ExternalResources.getSingleton().selectJRERTLibrary();
        }

        if (Configuration.rt.isEmpty()) {
            BytecodeViewer.showMessage("You need to set RT.jar!");
            return "Set your paths";
        }

        String s = ExceptionUI.SEND_STACKTRACE_TO_NL;

        final File tempDirectory = new File(Constants.tempDirectory + fs + MiscUtils.randomString(32) + fs);
        tempDirectory.mkdir();
        final File tempJar = new File(Constants.tempDirectory + fs + "temp" + MiscUtils.randomString(32) + ".jar");

        JarUtils.saveAsJarClassesOnly(BytecodeViewer.getLoadedClasses(), tempJar.getAbsolutePath());

        try {
            String[] pythonCommands = new String[]{Configuration.python2};
            if(Configuration.python2Extra)
                pythonCommands = ArrayUtils.addAll(pythonCommands, "-2");
            
            ProcessBuilder pb = new ProcessBuilder(ArrayUtils.addAll(
                    pythonCommands,
                    "-O", //love you storyyeller <3
                    krakatauWorkingDirectory + fs + "decompile.py",
                    "-skip", //love you storyyeller <3
                    "-nauto",
                    "-path",
                    Configuration.rt + ";" + tempJar.getAbsolutePath() + buildCLIArguments(),
                    "-out",
                    tempDirectory.getAbsolutePath(),
                    cn.name + ".class"
            ));

            Process process = pb.start();
            BytecodeViewer.createdProcesses.add(process);

            StringBuilder log = new StringBuilder(TranslatedStrings.PROCESS2 + nl + nl);

            //Read out dir output
            try (InputStream is = process.getInputStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null) {
                    log.append(nl).append(line);
                }
            }

            log.append(nl).append(nl).append(TranslatedStrings.ERROR2).append(nl).append(nl);

            try (InputStream is = process.getErrorStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null) {
                    log.append(nl).append(line);
                }
            }

            int exitValue = process.waitFor();
            log.append(nl).append(nl).append(TranslatedStrings.EXIT_VALUE_IS).append(" ").append(exitValue);
            s = log.toString();

            //if the motherfucker failed this'll fail, aka wont set.
            s = DiskReader.loadAsString(tempDirectory.getAbsolutePath() + fs + cn.name + ".java");
            tempDirectory.delete();
            tempJar.delete();
        } catch (Exception e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            e.printStackTrace();
            s += nl + ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
        }

        return s;
    }

    @Override
    public void decompileToZip(String sourceJar, String zipName) {
        if(!ExternalResources.getSingleton().hasSetPython2Command())
            return;
    
        ExternalResources.getSingleton().rtCheck();
        if (Configuration.rt.isEmpty()) {
            BytecodeViewer.showMessage(TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A
                    + "\r\n" + TranslatedStrings.YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B);
            ExternalResources.getSingleton().selectJRERTLibrary();
        }

        String ran = MiscUtils.randomString(32);
        final File tempDirectory = new File(Constants.tempDirectory + fs + ran + fs);
        tempDirectory.mkdir();

        final File tempJar = new File(sourceJar);
        
        try {
            String[] pythonCommands = new String[]{Configuration.python2};
            if(Configuration.python2Extra)
                pythonCommands = ArrayUtils.addAll(pythonCommands, "-2");
            
            ProcessBuilder pb = new ProcessBuilder(ArrayUtils.addAll(
                    pythonCommands,
                    "-O", //love you storyyeller <3
                    krakatauWorkingDirectory + fs + "decompile.py",
                    "-skip", //love you storyyeller <3
                    "-nauto",
                    "-path",
                    Configuration.rt + ";" + tempJar.getAbsolutePath(),
                    "-out",
                    tempDirectory.getAbsolutePath(),
                    tempJar.getAbsolutePath()
            ));

            Process process = pb.start();
            BytecodeViewer.createdProcesses.add(process);
            process.waitFor();
            MiscUtils.printProcess(process);

            ZipUtils.zipFolder(tempDirectory.getAbsolutePath(), zipName, ran);
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/KrakatauDisassembler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import me.konloch.kontainer.io.DiskReader;
import org.apache.commons.lang3.ArrayUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.resources.ExternalResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;
import the.bytecode.club.bytecodeviewer.util.ZipUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.krakatauWorkingDirectory;
import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Krakatau Java Disassembler Wrapper, requires Python 2.7
 *
 * @author Konloch
 */

public class KrakatauDisassembler extends InternalDecompiler
{
    @Override
    public String decompileClassNode(ClassNode cn, byte[] b) {
        if(!ExternalResources.getSingleton().hasSetPython2Command())
            return TranslatedStrings.YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH.toString();

        String s = ExceptionUI.SEND_STACKTRACE_TO_NL;

        final File tempDirectory = new File(Constants.tempDirectory + fs + MiscUtils.randomString(32) + fs);
        tempDirectory.mkdir();
        final File tempJar = new File(Constants.tempDirectory + fs + "temp" + MiscUtils.randomString(32) + ".jar");
        JarUtils.saveAsJarClassesOnly(BytecodeViewer.getLoadedClasses(), tempJar.getAbsolutePath());

        try {
            String[] pythonCommands = new String[]{Configuration.python2};
            if(Configuration.python2Extra)
                pythonCommands = ArrayUtils.addAll(pythonCommands, "-2");
            
            ProcessBuilder pb = new ProcessBuilder(ArrayUtils.addAll(
                    pythonCommands,
                    "-O", //love you storyyeller <3
                    krakatauWorkingDirectory + fs + "disassemble.py",
                    "-path",
                    tempJar.getAbsolutePath(),
                    "-out",
                    tempDirectory.getAbsolutePath(),
                    cn.name + ".class"
            ));

            Process process = pb.start();
            BytecodeViewer.createdProcesses.add(process);

            StringBuilder log = new StringBuilder(TranslatedStrings.PROCESS2 + nl + nl);

            //Read out dir output
            try (InputStream is = process.getInputStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null) {
                    log.append(nl).append(line);
                }
            }

            log.append(nl).append(nl).append(TranslatedStrings.ERROR2).append(nl).append(nl);

            try (InputStream is = process.getErrorStream();
                 InputStreamReader isr = new InputStreamReader(is);
                 BufferedReader br = new BufferedReader(isr)) {
                String line;
                while ((line = br.readLine()) != null) {
                    log.append(nl).append(line);
                }
            }

            int exitValue = process.waitFor();
            log.append(nl).append(nl).append(TranslatedStrings.EXIT_VALUE_IS).append(" ").append(exitValue);
            s = log.toString();

            // if the motherfucker failed this'll fail, aka won't set.
            s = DiskReader.loadAsString(tempDirectory.getAbsolutePath() + fs + cn.name + ".j");
        } catch (Exception e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            e.printStackTrace();
            s += nl + ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
        }
        return s;
    }

    @Override
    public void decompileToZip(String sourceJar, String zipName) {
        if(!ExternalResources.getSingleton().hasSetPython2Command())
            return;

        String ran = MiscUtils.randomString(32);
        final File tempDirectory = new File(Constants.tempDirectory + fs + ran + fs);
        tempDirectory.mkdir();

        final File tempJar = new File(sourceJar);

        try {
            String[] pythonCommands = new String[]{Configuration.python2};
            if(Configuration.python2Extra)
                pythonCommands = ArrayUtils.addAll(pythonCommands, "-2");
            
            ProcessBuilder pb = new ProcessBuilder(ArrayUtils.addAll(
                    pythonCommands,
                    "-O", //love you storyyeller <3
                    krakatauWorkingDirectory + fs + "disassemble.py",
                    "-path",
                    Configuration.rt + ";" + tempJar.getAbsolutePath(),
                    "-out",
                    tempDirectory.getAbsolutePath(),
                    tempJar.getAbsolutePath()
            ));

            Process process = pb.start();
            BytecodeViewer.createdProcesses.add(process);
            process.waitFor();

            ZipUtils.zipFolder(tempDirectory.getAbsolutePath(), zipName, ran);
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/ProcyonDecompiler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import com.strobel.assembler.InputTypeLoader;
import com.strobel.assembler.metadata.Buffer;
import com.strobel.assembler.metadata.ITypeLoader;
import com.strobel.assembler.metadata.JarTypeLoader;
import com.strobel.assembler.metadata.MetadataSystem;
import com.strobel.assembler.metadata.TypeDefinition;
import com.strobel.assembler.metadata.TypeReference;
import com.strobel.core.StringUtilities;
import com.strobel.decompiler.DecompilationOptions;
import com.strobel.decompiler.DecompilerSettings;
import com.strobel.decompiler.PlainTextOutput;
import com.strobel.decompiler.languages.java.JavaFormattingOptions;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.zip.ZipException;
import java.util.zip.ZipOutputStream;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.EncodeUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.nl;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.ERROR;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.PROCYON;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Procyon Java Decompiler Wrapper
 *
 * @author Konloch
 * @author DeathMarine
 */
public class ProcyonDecompiler extends InternalDecompiler {

    public DecompilerSettings getDecompilerSettings() {
        DecompilerSettings settings = new DecompilerSettings();
        settings.setAlwaysGenerateExceptionVariableForCatchBlocks(BytecodeViewer.viewer.alwaysGenerateExceptionVars.isSelected());
        settings.setExcludeNestedTypes(BytecodeViewer.viewer.excludeNestedTypes.isSelected());
        settings.setShowDebugLineNumbers(BytecodeViewer.viewer.showDebugLineNumbers.isSelected());
        settings.setIncludeLineNumbersInBytecode(BytecodeViewer.viewer.includeLineNumbersInBytecode.isSelected());
        settings.setIncludeErrorDiagnostics(BytecodeViewer.viewer.includeErrorDiagnostics.isSelected());
        settings.setShowSyntheticMembers(BytecodeViewer.viewer.showSyntheticMembers.isSelected());
        settings.setSimplifyMemberReferences(BytecodeViewer.viewer.simplifyMemberReferences.isSelected());
        settings.setMergeVariables(BytecodeViewer.viewer.mergeVariables.isSelected());
        settings.setForceExplicitTypeArguments(BytecodeViewer.viewer.forceExplicitTypeArguments.isSelected());
        settings.setForceExplicitImports(BytecodeViewer.viewer.forceExplicitImports.isSelected());
        settings.setFlattenSwitchBlocks(BytecodeViewer.viewer.flattenSwitchBlocks.isSelected());
        settings.setRetainPointlessSwitches(BytecodeViewer.viewer.retainPointlessSwitches.isSelected());
        settings.setRetainRedundantCasts(BytecodeViewer.viewer.retainRedunantCasts.isSelected());
        settings.setUnicodeOutputEnabled(BytecodeViewer.viewer.unicodeOutputEnabled.isSelected());
        settings.setJavaFormattingOptions(JavaFormattingOptions.createDefault());
        return settings;
    }

    @Override
    public String decompileClassNode(ClassNode cn, byte[] b) {
        String exception;
        try {
            String fileStart = tempDirectory + fs + "temp";

            final File tempClass = new File(MiscUtils.getUniqueName(fileStart, ".class") + ".class");

            try (FileOutputStream fos = new FileOutputStream(tempClass)) {
                fos.write(b);
            } catch (final IOException e) {
                BytecodeViewer.handleException(e);
            }

            DecompilerSettings settings = getDecompilerSettings();

            LuytenTypeLoader typeLoader = new LuytenTypeLoader();
            MetadataSystem metadataSystem = new MetadataSystem(typeLoader);
            TypeReference type = metadataSystem.lookupType(tempClass.getCanonicalPath());

            DecompilationOptions decompilationOptions = new DecompilationOptions();
            decompilationOptions.setSettings(settings);
            decompilationOptions.setFullDecompilation(true);

            TypeDefinition resolvedType;
            if (type == null || ((resolvedType = type.resolve()) == null))
                throw new Exception("Unable to resolve type.");

            StringWriter stringwriter = new StringWriter();
            settings.getLanguage().decompileType(resolvedType, new PlainTextOutput(stringwriter), decompilationOptions);

            return EncodeUtils.unicodeToString(stringwriter.toString());
        } catch (StackOverflowError | Exception e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            e.printStackTrace();

            exception = ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
        }

        return PROCYON + " " + ERROR + "! " + ExceptionUI.SEND_STACKTRACE_TO +
                nl + nl + TranslatedStrings.SUGGESTED_FIX_DECOMPILER_ERROR +
                nl + nl + exception;
    }

    @Override
    public void decompileToZip(String sourceJar, String zipName) {
        try {
            doSaveJarDecompiled(new File(sourceJar), new File(zipName));
        } catch (StackOverflowError | Exception e) {
            BytecodeViewer.handleException(e);
        }
    }

    /**
     * @author DeathMarine
     */
    private void doSaveJarDecompiled(File inFile, File outFile)
            throws Exception {
        try (JarFile jfile = new JarFile(inFile);
             FileOutputStream dest = new FileOutputStream(outFile);
             BufferedOutputStream buffDest = new BufferedOutputStream(dest);
             ZipOutputStream out = new ZipOutputStream(buffDest)) {
            byte[] data = new byte[1024];
            DecompilerSettings settings = getDecompilerSettings();
            LuytenTypeLoader typeLoader = new LuytenTypeLoader();
            MetadataSystem metadataSystem = new MetadataSystem(typeLoader);
            ITypeLoader jarLoader = new JarTypeLoader(jfile);
            typeLoader.getTypeLoaders().add(jarLoader);

            DecompilationOptions decompilationOptions = new DecompilationOptions();
            decompilationOptions.setSettings(settings);
            decompilationOptions.setFullDecompilation(true);

            Enumeration<JarEntry> ent = jfile.entries();
            Set<JarEntry> history = new HashSet<>();
            while (ent.hasMoreElements()) {
                JarEntry entry = ent.nextElement();
                if (entry.getName().endsWith(".class")) {
                    JarEntry etn = new JarEntry(entry.getName().replace(
                            ".class", ".java"));
                    if (history.add(etn)) {
                        out.putNextEntry(etn);
                        try {
                            String internalName = StringUtilities.removeRight(
                                    entry.getName(), ".class");
                            TypeReference type = metadataSystem
                                    .lookupType(internalName);
                            TypeDefinition resolvedType;
                            if ((type == null)
                                    || ((resolvedType = type.resolve()) == null)) {
                                throw new Exception("Unable to resolve type.");
                            }
                            Writer writer = new OutputStreamWriter(out);
                            settings.getLanguage().decompileType(resolvedType,
                                    new PlainTextOutput(writer),
                                    decompilationOptions);
                            writer.flush();
                        } finally {
                            out.closeEntry();
                        }
                    }
                } else {
                    try {
                        JarEntry etn = new JarEntry(entry.getName());
                        if (history.add(etn))
                            continue;
                        history.add(etn);
                        out.putNextEntry(etn);
                        try (InputStream in = jfile.getInputStream(entry)) {
                            if (in != null) {
                                int count;
                                while ((count = in.read(data, 0, 1024)) != -1) {
                                    out.write(data, 0, count);
                                }
                            }
                        } finally {
                            out.closeEntry();
                        }
                    } catch (ZipException ze) {
                        // some jars contain duplicate pom.xml entries: ignore it
                        if (!ze.getMessage().contains("duplicate")) {
                            throw ze;
                        }
                    }
                }
            }
        }
    }

    /**
     * @author DeathMarine
     */
    public static final class LuytenTypeLoader implements ITypeLoader {

        private final List<ITypeLoader> _typeLoaders;

        public LuytenTypeLoader() {
            _typeLoaders = new ArrayList<>();
            _typeLoaders.add(new InputTypeLoader());
        }

        public List<ITypeLoader> getTypeLoaders() {
            return _typeLoaders;
        }

        @Override
        public boolean tryLoadType(final String internalName,
                                   final Buffer buffer) {
            for (final ITypeLoader typeLoader : _typeLoaders) {
                if (typeLoader.tryLoadType(internalName, buffer)) {
                    return true;
                }

                buffer.reset();
            }

            return false;
        }

    }

}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/impl/SmaliDisassembler.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Objects;
import me.konloch.kontainer.io.DiskReader;
import org.apache.commons.io.FileUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.decompilers.InternalDecompiler;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.Dex2Jar;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.nl;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.DISASSEMBLER;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.ERROR;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.SMALI;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Smali Disassembler Wrapper
 *
 * @author Konloch
 */

public class SmaliDisassembler extends InternalDecompiler
{
    @Override
    public String decompileClassNode(ClassNode cn, byte[] b)
    {
        String exception = "";
        String fileStart = tempDirectory + fs + "temp";

        String start = MiscUtils.getUniqueName(fileStart, ".class");

        final File tempClass = new File(start + ".class");
        final File tempDex = new File(start + ".dex");
        final File tempDexOut = new File(start + "-out");
        final File tempSmali = new File(start + "-smali"); //output directory

        try (FileOutputStream fos = new FileOutputStream(tempClass)) {
            fos.write(b);
        } catch (final IOException e) {
            BytecodeViewer.handleException(e);
        }

        //ZipUtils.zipFile(tempClass, tempZip);

        Dex2Jar.saveAsDex(tempClass, tempDex, true);

        try {
            com.googlecode.d2j.smali.BaksmaliCmd.main(tempDex.getAbsolutePath(),
                    "-o", tempDexOut.getAbsolutePath());
        } catch (Exception e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            e.printStackTrace();

            exception += ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
        }

        try {
            FileUtils.moveDirectory(tempDexOut, tempSmali);
        } catch (IOException e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            e.printStackTrace();

            exception += ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
        }

        File outputSmali = null;

        boolean found = false;
        File current = tempSmali;
        while (!found) {
            File f = Objects.requireNonNull(current.listFiles())[0];
            if (f.isDirectory())
                current = f;
            else {
                outputSmali = f;
                found = true;
            }

        }
        try {
            return DiskReader.loadAsString(outputSmali.getAbsolutePath());
        } catch (Exception e) {
            StringWriter sw = new StringWriter();
            e.printStackTrace(new PrintWriter(sw));
            e.printStackTrace();

            exception += ExceptionUI.SEND_STACKTRACE_TO_NL + sw;
        }
        
        return SMALI + " " + DISASSEMBLER + " " + ERROR + "! " + ExceptionUI.SEND_STACKTRACE_TO +
                nl + nl + TranslatedStrings.SUGGESTED_FIX_DECOMPILER_ERROR +
                nl + nl + exception;
    }

    @Override
    public void decompileToZip(String sourceJar, String zipName) {

    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/jdgui/CommonPreferences.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.jdgui;

import java.util.HashMap;
import java.util.Map;

public class CommonPreferences {
    private final Map<String, Object> preferences;
    protected boolean showDefaultConstructor;
    protected boolean realignmentLineNumber;
    protected boolean showPrefixThis;
    protected boolean mergeEmptyLines;
    protected boolean unicodeEscape;
    protected boolean showLineNumbers;

    public CommonPreferences() {
        this.showPrefixThis = true;
        this.mergeEmptyLines = false;
        this.unicodeEscape = false;
        this.showLineNumbers = true;
        this.preferences = new HashMap<>();
    }

    public CommonPreferences(
            boolean showDefaultConstructor, boolean realignmentLineNumber,
            boolean showPrefixThis, boolean mergeEmptyLines,
            boolean unicodeEscape, boolean showLineNumbers) {
        this.showDefaultConstructor = showDefaultConstructor;
        this.realignmentLineNumber = realignmentLineNumber;
        this.showPrefixThis = showPrefixThis;
        this.mergeEmptyLines = mergeEmptyLines;
        this.unicodeEscape = unicodeEscape;
        this.showLineNumbers = showLineNumbers;
        this.preferences = new HashMap<>();
    }

    public boolean isShowDefaultConstructor() {
        return showDefaultConstructor;
    }

    public boolean isRealignmentLineNumber() {
        return realignmentLineNumber;
    }

    public boolean isShowPrefixThis() {
        return showPrefixThis;
    }

    public boolean isMergeEmptyLines() {
        return mergeEmptyLines;
    }

    public boolean isUnicodeEscape() {
        return unicodeEscape;
    }

    public boolean isShowLineNumbers() {
        return showLineNumbers;
    }

    public Map<String, Object> getPreferences() {
        return preferences;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/jdgui/DirectoryLoader.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.jdgui;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import org.apache.commons.io.IOUtils;
import org.jd.core.v1.api.loader.Loader;
import org.jd.core.v1.api.loader.LoaderException;

public class DirectoryLoader implements Loader
{
    protected String codebase;
    protected long lastModified;
    protected boolean isFile;
    
    public DirectoryLoader(File file) throws LoaderException
    {
        this.codebase = file.getAbsolutePath();
        this.lastModified = file.lastModified();
        this.isFile = file.isFile();

        if (!(file.exists() && file.isDirectory()))
            throw new LoaderException("'" + codebase + "' is not a directory");
    }

    @Override
    public byte[] load(String internalPath)
            throws LoaderException {
        File file = new File(this.codebase, internalPath);

        try (FileInputStream fis = new FileInputStream(file);
             BufferedInputStream bis = new BufferedInputStream(fis)) {
            return IOUtils.toByteArray(bis);
        } catch (IOException e) {
            throw new LoaderException(
                    "'" + file.getAbsolutePath() + "'  not found.");
        }
    }

    @Override
    public boolean canLoad(String internalPath) {
        File file = new File(this.codebase, internalPath);
        return file.exists() && file.isFile();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/jdgui/JDGUIClassFileUtil.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.jdgui;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import org.jd.core.v1.model.classfile.constant.Constant;
import org.jd.core.v1.model.classfile.constant.ConstantClass;
import org.jd.core.v1.model.classfile.constant.ConstantUtf8;
import org.jd.core.v1.service.deserializer.classfile.ClassFileFormatException;
import org.jd.core.v1.service.deserializer.classfile.ClassFileReader;


public class JDGUIClassFileUtil
{
    public static final char INTERNAL_PACKAGE_SEPARATOR = '/';
    public static final String CLASS_FILE_SUFFIX = ".class";

    /*
     * Lecture rapide de la structure de la classe et extraction du nom du
     * repoertoire de base.
     */
    public static String ExtractDirectoryPath(String pathToClass) {
        String directoryPath;

        try (FileInputStream fis = new FileInputStream(pathToClass);
             BufferedInputStream bis = new BufferedInputStream(fis);
             DataInputStream dis = new DataInputStream(bis)) {
            int magic = dis.readInt();
            if (magic != ClassFileReader.JAVA_MAGIC_NUMBER) {
                throw new ClassFileFormatException("Invalid Java .class file");
            }

            /* int minor_version = */
            dis.readUnsignedShort();
            /* int major_version = */
            dis.readUnsignedShort();

            Constant[] constants = DeserializeConstants(dis);

            /* int access_flags = */
            dis.readUnsignedShort();
            int this_class = dis.readUnsignedShort();

            if (this_class > constants.length) {
                throw new ClassFileFormatException("Unknown Java structure");
            }
            Constant c = constants[this_class];
            if ((c == null) || (c.getTag() != Constant.CONSTANT_Class)) {
                throw new ClassFileFormatException("Invalid constant pool");
            }

            c = constants[((ConstantClass) c).getNameIndex()];
            if ((c == null) || (c.getTag() != Constant.CONSTANT_Utf8)) {
                throw new ClassFileFormatException("Invalid constant pool");
            }

            String internalClassName = ((ConstantUtf8) c).getValue();
            String pathSuffix = internalClassName.replace(
                    INTERNAL_PACKAGE_SEPARATOR, File.separatorChar) +
                    CLASS_FILE_SUFFIX;

            int index = pathToClass.indexOf(pathSuffix);

            if (index < 0) {
                throw new ClassFileFormatException("Invalid internal class name");
            }

            directoryPath = pathToClass.substring(0, index);
        } catch (IOException e) {
            directoryPath = null;
            e.printStackTrace();
        }

        return directoryPath;
    }

    public static String ExtractInternalPath(
            String directoryPath, String pathToClass) {
        if ((directoryPath == null) || (pathToClass == null) ||
                !pathToClass.startsWith(directoryPath))
            return null;

        String s = pathToClass.substring(directoryPath.length());

        return s.replace(File.separatorChar, INTERNAL_PACKAGE_SEPARATOR);
    }

    private static Constant[] DeserializeConstants(DataInputStream dis)
            throws IOException {
        int count = dis.readUnsignedShort();
        Constant[] constants = new Constant[count];

        for (int i = 1; i < count; i++) {
            byte tag = dis.readByte();

            switch (tag) {
            case Constant.CONSTANT_Class:
                constants[i] = new ConstantClass(dis.readUnsignedShort());
                break;
            case Constant.CONSTANT_Utf8:
                constants[i] = new ConstantUtf8(dis.readUTF());
                break;
            case Constant.CONSTANT_Long:
            case Constant.CONSTANT_Double:
                dis.read();
                dis.read();
                dis.read();
                dis.read();
                i++;
            case Constant.CONSTANT_FieldRef:
            case Constant.CONSTANT_MethodRef:
            case Constant.CONSTANT_InterfaceMethodRef:
            case Constant.CONSTANT_InvokeDynamic:
            case Constant.CONSTANT_NameAndType:
            case Constant.CONSTANT_Integer:
            case Constant.CONSTANT_Float:
                dis.read();
            case Constant.CONSTANT_MethodHandle:
                dis.read();
            case Constant.CONSTANT_String:
            case Constant.CONSTANT_MethodType:
                dis.read();
                dis.read();
                break;
            default:
                //throw new ClassFormatException("Invalid constant pool entry");
                return constants;
            }
        }

        return constants;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/decompilers/jdgui/PlainTextPrinter.java`:

```java
package the.bytecode.club.bytecodeviewer.decompilers.jdgui;

import java.io.Closeable;
import java.io.PrintStream;
import org.jd.core.v1.api.printer.Printer;

public class PlainTextPrinter implements Printer, Closeable {
    protected static final String TAB = "  ";
    protected static final String NEWLINE = "\n";

    protected CommonPreferences preferences;
    protected PrintStream printStream;
    protected int maxLineNumber;
    protected int majorVersion;
    protected int minorVersion;
    protected int digitCount;
    protected String lineNumberBeginPrefix;
    protected String lineNumberEndPrefix;
    protected String unknownLineNumberPrefix;
    protected int indentationCount;
    protected boolean display;

    public PlainTextPrinter(
            CommonPreferences preferences, PrintStream printStream) {
        this.preferences = preferences;
        this.printStream = printStream;
        this.maxLineNumber = 0;
        this.majorVersion = 0;
        this.minorVersion = 0;
        this.indentationCount = 0;
    }

    public int getMajorVersion() {
        return majorVersion;
    }

    public int getMinorVersion() {
        return minorVersion;
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

    @Override
    public void printKeyword(String s) {
        if (this.display)
            this.printStream.append(s);
    }

    @Override
    public void printDeclaration(int type, String internalTypeName, String name, String descriptor) {
        this.printStream.append(name);
    }

    @Override
    public void printReference(int type, String internalTypeName, String name, String descriptor,
                               String ownerInternalName) {
        this.printStream.append(name);
    }

    @Override
    public void start(int maxLineNumber, int majorVersion, int minorVersion) {
        this.majorVersion = majorVersion;
        this.minorVersion = minorVersion;
        this.indentationCount = 0;
        this.display = true;

        if (this.preferences.isShowLineNumbers()) {
            this.maxLineNumber = maxLineNumber;

            if (maxLineNumber > 0) {
                this.digitCount = 1;
                StringBuilder unknownLineNumberPrefixBuilder = new StringBuilder(" ");
                int maximum = 9;

                while (maximum < maxLineNumber) {
                    this.digitCount++;
                    unknownLineNumberPrefixBuilder.append(' ');
                    maximum = maximum * 10 + 9;
                }

                this.unknownLineNumberPrefix = unknownLineNumberPrefixBuilder.toString();
                this.lineNumberBeginPrefix = "/* ";
                this.lineNumberEndPrefix = " */ ";
            } else {
                this.unknownLineNumberPrefix = "";
                this.lineNumberBeginPrefix = "";
                this.lineNumberEndPrefix = "";
            }
        } else {
            this.maxLineNumber = 0;
            this.unknownLineNumberPrefix = "";
            this.lineNumberBeginPrefix = "";
            this.lineNumberEndPrefix = "";
        }
    }

    @Override
    public void end() {
    }

    @Override
    public void printText(String s) {
        if (this.display)
            printEscape(s);
    }

    @Override
    public void printNumericConstant(String s) {
        this.printStream.append(s);
    }

    @Override
    public void printStringConstant(String s, String s1) {
        this.printStream.append(s);
    }

    @Override
    public void indent() {
        this.indentationCount++;
    }

    @Override
    public void unindent() {
        if (this.indentationCount > 0)
            this.indentationCount--;
    }

    @Override
    public void startLine(int lineNumber) {
        if (this.maxLineNumber > 0) {
            this.printStream.append(this.lineNumberBeginPrefix);

            if (lineNumber == UNKNOWN_LINE_NUMBER) {
                this.printStream.append(this.unknownLineNumberPrefix);
            } else {
                int left = 0;

                left = printDigit(5, lineNumber, 10000, left);
                left = printDigit(4, lineNumber, 1000, left);
                left = printDigit(3, lineNumber, 100, left);
                left = printDigit(2, lineNumber, 10, left);
                this.printStream.append((char) ('0' + (lineNumber - left)));
            }

            this.printStream.append(this.lineNumberEndPrefix);
        }

        for (int i = 0; i < indentationCount; i++)
            this.printStream.append(TAB);
    }

    @Override
    public void endLine() {
        this.printStream.append(NEWLINE);
    }

    @Override
    public void extraLine(int count) {
        if (!this.preferences.isMergeEmptyLines()) {
            while (count-- > 0) {
                if (this.maxLineNumber > 0) {
                    this.printStream.append(this.lineNumberBeginPrefix);
                    this.printStream.append(this.unknownLineNumberPrefix);
                    this.printStream.append(this.lineNumberEndPrefix);
                }

                this.printStream.append(NEWLINE);
            }
        }
    }

    @Override
    public void startMarker(int i) {
    }

    @Override
    public void endMarker(int i) {
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

    protected void printEscape(String s) {
        if (this.preferences.isUnicodeEscape()) {
            int length = s.length();

            for (int i = 0; i < length; i++) {
                char c = s.charAt(i);

                if (c == '\t') {
                    this.printStream.append('\t');
                } else if (c < 32) {
                    // Write octal format
                    this.printStream.append("\\0");
                    this.printStream.append((char) ('0' + (c >> 3)));
                    this.printStream.append((char) ('0' + (c & 0x7)));
                } else if (c > 127) {
                    // Write octal format
                    this.printStream.append("\\u");

                    int z = (c >> 12);
                    this.printStream.append((char) ((z <= 9) ? ('0' + z) : (('A' - 10) + z)));
                    z = ((c >> 8) & 0xF);
                    this.printStream.append((char) ((z <= 9) ? ('0' + z) : (('A' - 10) + z)));
                    z = ((c >> 4) & 0xF);
                    this.printStream.append((char) ((z <= 9) ? ('0' + z) : (('A' - 10) + z)));
                    z = (c & 0xF);
                    this.printStream.append((char) ((z <= 9) ? ('0' + z) : (('A' - 10) + z)));
                } else {
                    this.printStream.append(c);
                }
            }
        } else {
            this.printStream.append(s);
        }
    }

    protected int printDigit(int dcv, int lineNumber, int divisor, int left) {
        if (this.digitCount >= dcv) {
            if (lineNumber < divisor) {
                this.printStream.append(' ');
            } else {
                int e = (lineNumber - left) / divisor;
                this.printStream.append((char) ('0' + e));
                left += e * divisor;
            }
        }

        return left;
    }

    @Override
    public void close() {
        if (this.printStream != null)
            this.printStream.close();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/MainViewerGUI.java`:

```java
package the.bytecode.club.bytecodeviewer.gui;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.KeyboardFocusManager;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JSeparator;
import javax.swing.JSpinner;
import javax.swing.JSplitPane;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.SettingsSerializer;
import the.bytecode.club.bytecodeviewer.gui.components.AboutWindow;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog;
import the.bytecode.club.bytecodeviewer.gui.components.RunOptions;
import the.bytecode.club.bytecodeviewer.gui.components.SettingsDialog;
import the.bytecode.club.bytecodeviewer.gui.components.VisibleComponent;
import the.bytecode.club.bytecodeviewer.gui.components.WaitBusyIcon;
import the.bytecode.club.bytecodeviewer.gui.plugins.MaliciousCodeScannerOptions;
import the.bytecode.club.bytecodeviewer.gui.plugins.ReplaceStringsOptions;
import the.bytecode.club.bytecodeviewer.gui.resourcelist.ResourceListPane;
import the.bytecode.club.bytecodeviewer.gui.resourcesearch.SearchBoxPane;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.DecompilerSelectionPane;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.Workspace;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ClassViewer;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ResourceViewer;
import the.bytecode.club.bytecodeviewer.gui.theme.LAFTheme;
import the.bytecode.club.bytecodeviewer.gui.theme.RSTATheme;
import the.bytecode.club.bytecodeviewer.obfuscators.rename.RenameClasses;
import the.bytecode.club.bytecodeviewer.obfuscators.rename.RenameFields;
import the.bytecode.club.bytecodeviewer.obfuscators.rename.RenameMethods;
import the.bytecode.club.bytecodeviewer.plugin.PluginManager;
import the.bytecode.club.bytecodeviewer.plugin.PluginTemplate;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.AllatoriStringDecrypter;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.ChangeClassFileVersions;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.CodeSequenceDiagram;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.ShowAllStrings;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.ShowMainMethods;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.StackFramesRemover;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.ViewAPKAndroidPermissions;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.ViewManifest;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.ZKMStringDecrypter;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.ZStringArrayDecrypter;
import the.bytecode.club.bytecodeviewer.resources.ExternalResources;
import the.bytecode.club.bytecodeviewer.resources.IconResources;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.ResourceDecompiling;
import the.bytecode.club.bytecodeviewer.resources.exporting.Export;
import the.bytecode.club.bytecodeviewer.translation.Language;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJCheckBoxMenuItem;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJMenu;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJMenuItem;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJRadioButtonMenuItem;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.KeyEventDispatch;
import the.bytecode.club.bytecodeviewer.util.LazyNameUtil;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;
import the.bytecode.club.bytecodeviewer.util.WindowClosingAdapter;
import the.bytecode.club.bytecodeviewer.util.WindowStateChangeAdapter;

import static the.bytecode.club.bytecodeviewer.Configuration.useNewSettingsDialog;
import static the.bytecode.club.bytecodeviewer.Constants.VERSION;
import static the.bytecode.club.bytecodeviewer.Constants.fs;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The main file for the GUI
 *
 * @author Konloch
 */
public class MainViewerGUI extends JFrame
{
    public boolean isMaximized;
    public final List<JMenuItem> waitIcons = new ArrayList<>();
    
    //main UI components
    public final List<VisibleComponent> uiComponents = new ArrayList<>();
    public final Workspace workPane = new Workspace();
    public final ResourceListPane resourcePane = new ResourceListPane();
    public final SearchBoxPane searchBoxPane = new SearchBoxPane();
    public JSplitPane splitPane1;
    public JSplitPane splitPane2;
    
    //the root menu bar
    public final JMenuBar rootMenu = new JMenuBar();
    
    //all of the files main menu components
    public final JMenu fileMainMenu = new TranslatedJMenu("File", TranslatedComponents.FILE);
    public final JMenuItem addResource = new TranslatedJMenuItem("Add...", TranslatedComponents.ADD);
    public final JMenuItem newWorkSpace = new TranslatedJMenuItem("New Workspace", TranslatedComponents.NEW_WORKSPACE);
    public final JMenuItem reloadResources = new TranslatedJMenuItem("Reload Resources", TranslatedComponents.RELOAD_RESOURCES);
    public final JMenuItem runButton = new TranslatedJMenuItem("Run", TranslatedComponents.RUN);
    public final JMenuItem compileButton = new TranslatedJMenuItem("Compile", TranslatedComponents.COMPILE);
    public final JMenuItem saveAsRunnableJar = new TranslatedJMenuItem("Save As Runnable Jar..", TranslatedComponents.SAVE_AS_RUNNABLE_JAR);
    public final JMenuItem saveAsDex = new TranslatedJMenuItem("Save As DEX..", TranslatedComponents.SAVE_AS_DEX);
    public final JMenuItem saveAsAPK = new TranslatedJMenuItem("Save As APK..", TranslatedComponents.SAVE_AS_APK);
    public final JMenuItem saveAsZip = new TranslatedJMenuItem("Save As Zip..", TranslatedComponents.SAVE_AS_ZIP);
    public final JMenuItem decompileSaveOpened = new TranslatedJMenuItem("Decompile & Save Opened Class..", TranslatedComponents.DECOMPILE_SAVE_OPENED_CLASSES);
    public final JMenuItem decompileSaveAll = new TranslatedJMenuItem("Decompile & Save All Classes..", TranslatedComponents.DECOMPILE_SAVE_ALL_CLASSES);
    public final JMenu recentFilesSecondaryMenu = new TranslatedJMenu("Recent Files", TranslatedComponents.RECENT_FILES);
    public final JMenuItem about = new TranslatedJMenuItem("About", TranslatedComponents.ABOUT);
    public final JMenuItem exit = new TranslatedJMenuItem("Exit", TranslatedComponents.EXIT);
    
    //all of the view main menu components
    public final JMenu viewMainMenu = new TranslatedJMenu("View", TranslatedComponents.VIEW);
    public final DecompilerSelectionPane viewPane1 = new DecompilerSelectionPane(1);
    public final DecompilerSelectionPane viewPane2 = new DecompilerSelectionPane(2);
    public final DecompilerSelectionPane viewPane3 = new DecompilerSelectionPane(3);
    
    //all of the plugins main menu components
    public final JMenu pluginsMainMenu = new TranslatedJMenu("Plugins", TranslatedComponents.PLUGINS);
    public final JMenuItem openExternalPlugin = new TranslatedJMenuItem("Open Plugin...", TranslatedComponents.OPEN_PLUGIN);
    public final JMenu recentPluginsSecondaryMenu = new TranslatedJMenu("Recent Plugins", TranslatedComponents.RECENT_PLUGINS);
    public final JMenuItem newJavaPlugin = new TranslatedJMenuItem("New Java Plugin...", TranslatedComponents.NEW_JAVA_PLUGIN);
    public final JMenuItem newJavascriptPlugin = new TranslatedJMenuItem("New Javascript Plugin...", TranslatedComponents.NEW_JAVASCRIPT_PLUGIN);
    public final JMenuItem codeSequenceDiagram = new TranslatedJMenuItem("Code Sequence Diagram", TranslatedComponents.CODE_SEQUENCE_DIAGRAM);
    public final JMenuItem maliciousCodeScanner = new TranslatedJMenuItem("Malicious Code Scanner", TranslatedComponents.MALICIOUS_CODE_SCANNER);
    public final JMenuItem showAllStrings = new TranslatedJMenuItem("Show All Strings", TranslatedComponents.SHOW_ALL_STRINGS);
    public final JMenuItem showMainMethods = new TranslatedJMenuItem("Show Main Methods", TranslatedComponents.SHOW_MAIN_METHODS);
    public final JMenuItem replaceStrings = new TranslatedJMenuItem("Replace Strings", TranslatedComponents.REPLACE_STRINGS);
    public final JMenuItem stackFramesRemover = new TranslatedJMenuItem("StackFrames Remover", TranslatedComponents.STACK_FRAMES_REMOVER);
    public final JMenuItem ZKMStringDecrypter = new TranslatedJMenuItem("ZKM String Decrypter", TranslatedComponents.ZKM_STRING_DECRYPTER);
    public final JMenuItem allatoriStringDecrypter = new TranslatedJMenuItem("Allatori String Decrypter", TranslatedComponents.ALLATORI_STRING_DECRYPTER);
    public final JMenuItem zStringArrayDecrypter = new TranslatedJMenuItem("ZStringArray Decrypter", TranslatedComponents.ZSTRINGARRAY_DECRYPTER);
    public final JMenuItem viewAPKAndroidPermissions = new TranslatedJMenuItem("View Android Permissions", TranslatedComponents.VIEW_ANDROID_PERMISSIONS);
    public final JMenuItem viewManifest = new TranslatedJMenuItem("View Manifest", TranslatedComponents.VIEW_MANIFEST);
    public final JMenuItem changeClassFileVersions = new TranslatedJMenuItem("Change ClassFile Versions", TranslatedComponents.CHANGE_CLASSFILE_VERSIONS);
    
    //all of the settings main menu components
    public final JMenu rstaTheme = new TranslatedJMenu("Text Area Theme", TranslatedComponents.TEXT_AREA_THEME);
    public final JMenuItem rstaThemeSettings = new TranslatedJMenuItem("Text Area Theme", TranslatedComponents.TEXT_AREA_THEME);
    public SettingsDialog rstaThemeSettingsDialog;
    public final JMenu lafTheme = new TranslatedJMenu("Window Theme", TranslatedComponents.WINDOW_THEME);
    public final JMenuItem lafThemeSettings = new TranslatedJMenuItem("Window Theme", TranslatedComponents.WINDOW_THEME);
    public SettingsDialog lafThemeSettingsDialog;
    public final JMenu language = new TranslatedJMenu("Language", TranslatedComponents.LANGUAGE);
    public final JMenuItem languageSettings = new TranslatedJMenuItem("Language", TranslatedComponents.LANGUAGE);
    public SettingsDialog languageSettingsDialog;
    public final JMenu fontSize = new TranslatedJMenu("Font Size", TranslatedComponents.FONT_SIZE);
    public final JSpinner fontSpinner = new JSpinner();
    public final Map<RSTATheme, JRadioButtonMenuItem> rstaThemes = new HashMap<>();
    public final Map<LAFTheme, JRadioButtonMenuItem> lafThemes = new HashMap<>();
    public final Map<Language, JRadioButtonMenuItem> languages = new HashMap<>();
    
    //BCV settings
    public final JCheckBoxMenuItem refreshOnChange = new TranslatedJCheckBoxMenuItem("Refresh On View Change", TranslatedComponents.REFRESH_ON_VIEW_CHANGE);
    private final JCheckBoxMenuItem deleteForeignOutdatedLibs = new TranslatedJCheckBoxMenuItem("Delete Foreign/Outdated Libs", TranslatedComponents.DELETE_UNKNOWN_LIBS);
    public final JMenu settingsMainMenu = new TranslatedJMenu("Settings", TranslatedComponents.SETTINGS);
    public final JMenu visualSettings = new TranslatedJMenu("Visual Settings", TranslatedComponents.VISUAL_SETTINGS);
    public final JCheckBoxMenuItem updateCheck = new TranslatedJCheckBoxMenuItem("Update Check", TranslatedComponents.UPDATE_CHECK);
    public final JMenuItem setPython2 = new TranslatedJMenuItem("Set Python 2.7 Executable", TranslatedComponents.SET_PYTHON_27_EXECUTABLE);
    public final JMenuItem setPython3 = new TranslatedJMenuItem("Set Python 3.X Executable", TranslatedComponents.SET_PYTHON_30_EXECUTABLE);
    public final JMenuItem setJRERT = new TranslatedJMenuItem("Set JRE RT Library", TranslatedComponents.SET_JRE_RT_LIBRARY);
    public final JMenuItem setJavac = new TranslatedJMenuItem("Set Javac Executable", TranslatedComponents.SET_JAVAC_EXECUTABLE);
    public final JMenuItem setOptionalLibrary = new TranslatedJMenuItem("Set Optional Library Folder", TranslatedComponents.SET_OPTIONAL_LIBRARY_FOLDER);
    public final JCheckBoxMenuItem compileOnSave = new TranslatedJCheckBoxMenuItem("Compile On Save", TranslatedComponents.COMPILE_ON_SAVE);
    public final JCheckBoxMenuItem showFileInTabTitle = new TranslatedJCheckBoxMenuItem("Show File In Tab Title", TranslatedComponents.SHOW_TAB_FILE_IN_TAB_TITLE);
    public final JCheckBoxMenuItem simplifyNameInTabTitle = new TranslatedJCheckBoxMenuItem("Simplify Name In Tab Title", TranslatedComponents.SIMPLIFY_NAME_IN_TAB_TITLE);
    public final JCheckBoxMenuItem forcePureAsciiAsText = new TranslatedJCheckBoxMenuItem("Force Pure Ascii As Text", TranslatedComponents.FORCE_PURE_ASCII_AS_TEXT);
    public final JCheckBoxMenuItem autoCompileOnRefresh = new TranslatedJCheckBoxMenuItem("Compile On Refresh", TranslatedComponents.COMPILE_ON_REFRESH);
    public final JCheckBoxMenuItem decodeAPKResources = new TranslatedJCheckBoxMenuItem("Decode APK Resources", TranslatedComponents.DECODE_APK_RESOURCES);
    public final JCheckBoxMenuItem synchronizedViewing = new TranslatedJCheckBoxMenuItem("Synchronized Viewing", TranslatedComponents.SYNCHRONIZED_VIEWING);
    public final JCheckBoxMenuItem showClassMethods = new TranslatedJCheckBoxMenuItem("Show Class Methods", TranslatedComponents.SHOW_CLASS_METHODS);
    
    //apk conversion settings
    public final JMenu apkConversionSecondaryMenu = new TranslatedJMenu("APK Conversion/Decoding", TranslatedComponents.APK_CONVERSION_DECODING);
    public final JMenuItem apkConversionSettings = new TranslatedJMenuItem("APK Conversion/Decoding", TranslatedComponents.APK_CONVERSION_DECODING);
    public SettingsDialog apkConversionSettingsDialog;
    public final ButtonGroup apkConversionGroup = new ButtonGroup();
    public final JRadioButtonMenuItem apkConversionDex = new JRadioButtonMenuItem("Dex2Jar");
    public final JRadioButtonMenuItem apkConversionEnjarify = new JRadioButtonMenuItem("Enjarify");
    
    //CFIDE settings
    public final JMenu bytecodeDecompilerSettingsSecondaryMenu = new TranslatedJMenu("Bytecode Decompiler", TranslatedComponents.BYTECODE_DECOMPILER);
    public final JMenuItem bytecodeDecompilerSettings = new TranslatedJMenuItem("Bytecode Decompiler", TranslatedComponents.BYTECODE_DECOMPILER);
    public SettingsDialog bytecodeDecompilerSettingsDialog;
    public final JCheckBoxMenuItem appendBracketsToLabels = new TranslatedJCheckBoxMenuItem("Append Brackets To Labels", TranslatedComponents.APPEND_BRACKETS_TO_LABEL);
    public JCheckBoxMenuItem debugHelpers = new TranslatedJCheckBoxMenuItem("Debug Helpers", TranslatedComponents.DEBUG_HELPERS);
    public final JCheckBoxMenuItem printLineNumbers = new TranslatedJCheckBoxMenuItem("Print Line Numbers", TranslatedComponents.PRINT_LINE_NUMBERS);
    
    //FernFlower settings
    public final JMenu fernFlowerSettingsSecondaryMenu = new TranslatedJMenu("FernFlower Settings", TranslatedComponents.FERNFLOWER_SETTINGS);
    public final JMenuItem fernFlowerSettings = new TranslatedJMenuItem("FernFlower Settings", TranslatedComponents.FERNFLOWER_SETTINGS);
    public SettingsDialog fernFlowerSettingsDialog;
    public TranslatedJCheckBoxMenuItem rbr = new TranslatedJCheckBoxMenuItem("Hide bridge methods", TranslatedComponents.HIDE_BRIDGE_METHODS);
    public TranslatedJCheckBoxMenuItem rsy = new TranslatedJCheckBoxMenuItem("Hide synthetic class members", TranslatedComponents.HIDE_SYNTHETIC_CLASS_MEMBERS);
    public TranslatedJCheckBoxMenuItem din = new TranslatedJCheckBoxMenuItem("Decompile inner classes", TranslatedComponents.DECOMPILE_INNER_CLASSES);
    public TranslatedJCheckBoxMenuItem dc4 = new TranslatedJCheckBoxMenuItem("Collapse 1.4 class references", TranslatedComponents.COLLAPSE_14_CLASS_REFERENCES);
    public TranslatedJCheckBoxMenuItem das = new TranslatedJCheckBoxMenuItem("Decompile assertions", TranslatedComponents.DECOMPILE_ASSERTIONS);
    public TranslatedJCheckBoxMenuItem hes = new TranslatedJCheckBoxMenuItem("Hide empty super invocation", TranslatedComponents.HIDE_EMPTY_SUPER_INVOCATION);
    public TranslatedJCheckBoxMenuItem hdc = new TranslatedJCheckBoxMenuItem("Hide empty default constructor", TranslatedComponents.HIDE_EMPTY_DEFAULT_CONSTRUCTOR);
    public TranslatedJCheckBoxMenuItem dgs = new TranslatedJCheckBoxMenuItem("Decompile generic signatures", TranslatedComponents.DECOMPILE_GENERIC_SIGNATURES);
    public TranslatedJCheckBoxMenuItem ner = new TranslatedJCheckBoxMenuItem("Assume return not throwing exceptions", TranslatedComponents.ASSUME_RETURN_NOT_THROWING_EXCEPTIONS);
    public TranslatedJCheckBoxMenuItem den = new TranslatedJCheckBoxMenuItem("Decompile enumerations", TranslatedComponents.DECOMPILE_ENUMERATIONS);
    public TranslatedJCheckBoxMenuItem rgn = new TranslatedJCheckBoxMenuItem("Remove getClass() invocation", TranslatedComponents.REMOVE_GETCLASS_INVOCATION);
    public TranslatedJCheckBoxMenuItem bto = new TranslatedJCheckBoxMenuItem("Interpret int 1 as boolean true", TranslatedComponents.INTERPRET_INT_1_AS_BOOLEAN_TRUE);
    public TranslatedJCheckBoxMenuItem nns = new TranslatedJCheckBoxMenuItem("Allow for not set synthetic attribute", TranslatedComponents.ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE);
    public TranslatedJCheckBoxMenuItem uto = new TranslatedJCheckBoxMenuItem("Consider nameless types as java.lang.Object", TranslatedComponents.CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT);
    public TranslatedJCheckBoxMenuItem udv = new TranslatedJCheckBoxMenuItem("Reconstruct variable names from debug info", TranslatedComponents.RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO);
    public TranslatedJCheckBoxMenuItem rer = new TranslatedJCheckBoxMenuItem("Remove empty exception ranges", TranslatedComponents.REMOVE_EMPTY_EXCEPTION_RANGES);
    public TranslatedJCheckBoxMenuItem fdi = new TranslatedJCheckBoxMenuItem("Deinline finally structures", TranslatedComponents.DEINLINE_FINALLY_STRUCTURES);
    public TranslatedJCheckBoxMenuItem asc = new TranslatedJCheckBoxMenuItem("Allow only ASCII characters in strings", TranslatedComponents.ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS);
    public TranslatedJCheckBoxMenuItem ren = new TranslatedJCheckBoxMenuItem("Rename ambiguous classes and class elements", TranslatedComponents.RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS);
    
    //Procyon
    public final JMenu procyonSettingsSecondaryMenu = new TranslatedJMenu("Procyon Settings", TranslatedComponents.PROCYON_SETTINGS);
    public final JMenuItem procyonSettings = new TranslatedJMenuItem("Procyon Settings", TranslatedComponents.PROCYON_SETTINGS);
    public SettingsDialog procyonSettingsDialog;
    public final JCheckBoxMenuItem alwaysGenerateExceptionVars = new TranslatedJCheckBoxMenuItem("Always Generate Exception Variable For Catch Blocks", TranslatedComponents.ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS);
    public final JCheckBoxMenuItem excludeNestedTypes = new TranslatedJCheckBoxMenuItem("Exclude Nested Types", TranslatedComponents.EXCLUDE_NESTED_TYPES);
    public final JCheckBoxMenuItem showDebugLineNumbers = new TranslatedJCheckBoxMenuItem("Show Debug Line Numbers", TranslatedComponents.SHOW_DEBUG_LINE_NUMBERS);
    public final JCheckBoxMenuItem includeLineNumbersInBytecode = new TranslatedJCheckBoxMenuItem("Include Line Numbers In Bytecode", TranslatedComponents.INCLUDE_LINE_NUMBERS_IN_BYTECODE);
    public final JCheckBoxMenuItem includeErrorDiagnostics = new TranslatedJCheckBoxMenuItem("Include Error Diagnostics", TranslatedComponents.INCLUDE_ERROR_DIAGNOSTICS);
    public final JCheckBoxMenuItem showSyntheticMembers = new TranslatedJCheckBoxMenuItem("Show Synthetic Members", TranslatedComponents.SHOW_SYNTHETIC_MEMBERS);
    public final JCheckBoxMenuItem simplifyMemberReferences = new TranslatedJCheckBoxMenuItem("Simplify Member References", TranslatedComponents.SIMPLIFY_MEMBER_REFERENCES);
    public final JCheckBoxMenuItem mergeVariables = new TranslatedJCheckBoxMenuItem("Merge Variables", TranslatedComponents.MERGE_VARIABLES);
    public final JCheckBoxMenuItem forceExplicitTypeArguments = new TranslatedJCheckBoxMenuItem("Force Explicit Type Arguments", TranslatedComponents.FORCE_EXPLICIT_TYPE_ARGUMENTS);
    public final JCheckBoxMenuItem forceExplicitImports = new TranslatedJCheckBoxMenuItem("Force Explicit Imports", TranslatedComponents.FORCE_EXPLICIT_IMPORTS);
    public final JCheckBoxMenuItem flattenSwitchBlocks = new TranslatedJCheckBoxMenuItem("Flatten Switch Blocks", TranslatedComponents.FLATTEN_SWITCH_BLOCKS);
    public final JCheckBoxMenuItem retainPointlessSwitches = new TranslatedJCheckBoxMenuItem("Retain Pointless Switches", TranslatedComponents.RETAIN_POINTLESS_SWITCHES);
    public final JCheckBoxMenuItem retainRedunantCasts = new TranslatedJCheckBoxMenuItem("Retain Redundant Casts", TranslatedComponents.RETAIN_REDUNDANT_CASTS);
    public final JCheckBoxMenuItem unicodeOutputEnabled = new TranslatedJCheckBoxMenuItem("Unicode Output Enabled", TranslatedComponents.UNICODE_OUTPUT_ENABLED);
    
    //CFR
    public final JMenu cfrSettingsSecondaryMenu = new TranslatedJMenu("CFR Settings", TranslatedComponents.CFR_SETTINGS);
    public final JMenuItem cfrSettings = new TranslatedJMenuItem("CFR Settings", TranslatedComponents.CFR_SETTINGS);
    public SettingsDialog cfrSettingsDialog;
    public final JCheckBoxMenuItem decodeEnumSwitch = new TranslatedJCheckBoxMenuItem("Decode Enum Switch", TranslatedComponents.DECODE_ENUM_SWITCH);
    public final JCheckBoxMenuItem sugarEnums = new TranslatedJCheckBoxMenuItem("SugarEnums", TranslatedComponents.SUGARENUMS);
    public final JCheckBoxMenuItem decodeStringSwitch = new TranslatedJCheckBoxMenuItem("Decode String Switch", TranslatedComponents.DECODE_STRING_SWITCH);
    public final JCheckBoxMenuItem arrayiter = new TranslatedJCheckBoxMenuItem("Arrayiter", TranslatedComponents.ARRAYITER);
    public final JCheckBoxMenuItem collectioniter = new TranslatedJCheckBoxMenuItem("Collectioniter", TranslatedComponents.COLLECTIONITER);
    public final JCheckBoxMenuItem innerClasses = new TranslatedJCheckBoxMenuItem("Inner Classes", TranslatedComponents.INNER_CLASSES);
    public final JCheckBoxMenuItem removeBoilerPlate = new TranslatedJCheckBoxMenuItem("Remove Boiler Plate", TranslatedComponents.REMOVE_BOILER_PLATE);
    public final JCheckBoxMenuItem removeInnerClassSynthetics = new TranslatedJCheckBoxMenuItem("Remove Inner Class Synthetics", TranslatedComponents.REMOVE_INNER_CLASS_SYNTHETICS);
    public final JCheckBoxMenuItem decodeLambdas = new TranslatedJCheckBoxMenuItem("Decode Lambdas", TranslatedComponents.DECODE_LAMBDAS);
    public final JCheckBoxMenuItem hideBridgeMethods = new TranslatedJCheckBoxMenuItem("Hide Bridge Methods", TranslatedComponents.HIDE_BRIDGE_METHODS);
    public final JCheckBoxMenuItem liftConstructorInit = new TranslatedJCheckBoxMenuItem("Lift  Constructor Init", TranslatedComponents.LIFT__CONSTRUCTOR_INIT);
    public final JCheckBoxMenuItem removeDeadMethods = new TranslatedJCheckBoxMenuItem("Remove Dead Methods", TranslatedComponents.REMOVE_DEAD_METHODS);
    public final JCheckBoxMenuItem removeBadGenerics = new TranslatedJCheckBoxMenuItem("Remove Bad Generics", TranslatedComponents.REMOVE_BAD_GENERICS);
    public final JCheckBoxMenuItem sugarAsserts = new TranslatedJCheckBoxMenuItem("Sugar Asserts", TranslatedComponents.SUGAR_ASSERTS);
    public final JCheckBoxMenuItem sugarBoxing = new TranslatedJCheckBoxMenuItem("Sugar Boxing", TranslatedComponents.SUGAR_BOXING);
    public final JCheckBoxMenuItem showVersion = new TranslatedJCheckBoxMenuItem("Show Version", TranslatedComponents.SHOW_VERSION);
    public final JCheckBoxMenuItem decodeFinally = new TranslatedJCheckBoxMenuItem("Decode Finally", TranslatedComponents.DECODE_FINALLY);
    public final JCheckBoxMenuItem tidyMonitors = new TranslatedJCheckBoxMenuItem("Tidy Monitors", TranslatedComponents.TIDY_MONITORS);
    public final JCheckBoxMenuItem lenient = new TranslatedJCheckBoxMenuItem("Lenient", TranslatedComponents.LENIENT);
    public final JCheckBoxMenuItem dumpClassPath = new TranslatedJCheckBoxMenuItem("Dump Classpath", TranslatedComponents.DUMP_CLASSPATH);
    public final JCheckBoxMenuItem comments = new TranslatedJCheckBoxMenuItem("Comments", TranslatedComponents.COMMENTS);
    public final JCheckBoxMenuItem forceTopSort = new TranslatedJCheckBoxMenuItem("Force Top Sort", TranslatedComponents.FORCE_TOP_SORT);
    public final JCheckBoxMenuItem forceTopSortAggress = new TranslatedJCheckBoxMenuItem("Force Top Sort Aggress", TranslatedComponents.FORCE_TOP_SORT_AGGRESS);
    public final JCheckBoxMenuItem forceExceptionPrune = new TranslatedJCheckBoxMenuItem("Force Exception Prune", TranslatedComponents.FORCE_EXCEPTION_PRUNE);
    public final JCheckBoxMenuItem stringBuffer = new TranslatedJCheckBoxMenuItem("String Buffer", TranslatedComponents.STRING_BUFFER);
    public final JCheckBoxMenuItem stringBuilder = new TranslatedJCheckBoxMenuItem("String Builder", TranslatedComponents.STRING_BUILDER);
    public final JCheckBoxMenuItem silent = new TranslatedJCheckBoxMenuItem("Silent", TranslatedComponents.SILENT);
    public final JCheckBoxMenuItem recover = new TranslatedJCheckBoxMenuItem("Recover", TranslatedComponents.RECOVER);
    public final JCheckBoxMenuItem eclipse = new TranslatedJCheckBoxMenuItem("Eclipse", TranslatedComponents.ECLIPSE);
    public final JCheckBoxMenuItem override = new TranslatedJCheckBoxMenuItem("Override", TranslatedComponents.OVERRIDE);
    public final JCheckBoxMenuItem showInferrable = new TranslatedJCheckBoxMenuItem("Show Inferrable", TranslatedComponents.SHOW_INFERRABLE);
    public final JCheckBoxMenuItem aexagg = new TranslatedJCheckBoxMenuItem("Aexagg", TranslatedComponents.AEXAGG);
    public final JCheckBoxMenuItem forceCondPropagate = new TranslatedJCheckBoxMenuItem("Force Cond Propagate", TranslatedComponents.FORCE_COND_PROPAGATE);
    public final JCheckBoxMenuItem hideUTF = new TranslatedJCheckBoxMenuItem("Hide UTF", TranslatedComponents.HIDE_UTF);
    public final JCheckBoxMenuItem hideLongStrings = new TranslatedJCheckBoxMenuItem("Hide Long Strings", TranslatedComponents.HIDE_LONG_STRINGS);
    public final JCheckBoxMenuItem commentMonitor = new TranslatedJCheckBoxMenuItem("Comment Monitors", TranslatedComponents.COMMENT_MONITORS);
    public final JCheckBoxMenuItem allowCorrecting = new TranslatedJCheckBoxMenuItem("Allow Correcting", TranslatedComponents.ALLOW_CORRECTING);
    public final JCheckBoxMenuItem labelledBlocks = new TranslatedJCheckBoxMenuItem("Labelled Blocks", TranslatedComponents.LABELLED_BLOCKS);
    public final JCheckBoxMenuItem j14ClassOBJ = new TranslatedJCheckBoxMenuItem("J14ClassOBJ", TranslatedComponents.J14CLASSOBJ);
    public final JCheckBoxMenuItem hideLangImports = new TranslatedJCheckBoxMenuItem("Hide Lang Imports", TranslatedComponents.HIDE_LANG_IMPORTS);
    public final JCheckBoxMenuItem recoveryTypeClash = new TranslatedJCheckBoxMenuItem("Recover Type Clash", TranslatedComponents.RECOVER_TYPE_CLASH);
    public final JCheckBoxMenuItem recoveryTypehInts = new TranslatedJCheckBoxMenuItem("Recover Type  Hints", TranslatedComponents.RECOVER_TYPE__HINTS);
    public final JCheckBoxMenuItem forceTurningIFs = new TranslatedJCheckBoxMenuItem("Force Returning IFs", TranslatedComponents.FORCE_RETURNING_IFS);
    public final JCheckBoxMenuItem forLoopAGGCapture = new TranslatedJCheckBoxMenuItem("For Loop AGG Capture", TranslatedComponents.FOR_LOOP_AGG_CAPTURE);

    //Smali/D2Jar
    public final JMenu minSdkVersionMenu = new TranslatedJMenu("Minimum SDK version", TranslatedComponents.MIN_SDK_VERSION);
    public final JSpinner minSdkVersionSpinner = new JSpinner();

    //obfuscation
    public final JMenu obfuscate = new JMenu("Obfuscate");
    public final JMenuItem renameFields = new JMenuItem("Rename Fields");
    public final JMenuItem renameMethods = new JMenuItem("Rename Methods");
    public final JMenuItem moveAllClassesIntoRoot = new JMenuItem("Move All Classes Into Root Package");
    public final JMenuItem controlFlow = new JMenuItem("Control Flow");
    public final JMenuItem junkCode = new JMenuItem("Junk Code");
    public final ButtonGroup obfuscatorGroup = new ButtonGroup();
    public final JRadioButtonMenuItem strongObf = new JRadioButtonMenuItem("Strong Obfuscation");
    public final JRadioButtonMenuItem lightObf = new JRadioButtonMenuItem("Light Obfuscation");
    public final JMenuItem renameClasses = new JMenuItem("Rename Classes");

    public MainViewerGUI()
    {
        setIconImages(IconResources.iconList);
        setSize(new Dimension(800, 488));
    
        setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new KeyEventDispatch());
        addWindowStateListener(new WindowStateChangeAdapter(this));
        addWindowListener(new WindowClosingAdapter());

        buildMenuBar();
        buildFileMenu();
        buildViewMenu();
        buildSettingsMenu();
        buildPluginMenu();
        buildObfuscateMenu();
        defaultSettings();
        
        setTitle("Bytecode Viewer " + VERSION + " - https://bytecodeviewer.com | https://the.bytecode.club - @Konloch");

        getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.X_AXIS));

        resourcePane.setMinimumSize(new Dimension(200, 50));
        resourcePane.setPreferredSize(new Dimension(200, 50));
        resourcePane.setMaximumSize(new Dimension(200, 2147483647));
        
        searchBoxPane.setPreferredSize(new Dimension(200, 50));
        searchBoxPane.setMinimumSize(new Dimension(200, 50));
        searchBoxPane.setMaximumSize(new Dimension(200, 2147483647));
        
        splitPane1 = new JSplitPane(JSplitPane.VERTICAL_SPLIT, resourcePane, searchBoxPane);
        splitPane2 = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, splitPane1, workPane);
        getContentPane().add(splitPane2);
        splitPane2.setResizeWeight(0.05);
        splitPane1.setResizeWeight(0.5);
        
        uiComponents.add(resourcePane);
        uiComponents.add(searchBoxPane);
        uiComponents.add(workPane);

        viewPane1.setDefault();
        viewPane2.setDefault();
        viewPane3.setDefault();

        this.setLocationRelativeTo(null);
    }
    
    public void buildMenuBar()
    {
        setJMenuBar(rootMenu);
    }
    
    public void buildFileMenu()
    {
        rootMenu.add(fileMainMenu);
        fileMainMenu.add(addResource);
        fileMainMenu.add(new JSeparator());
        fileMainMenu.add(newWorkSpace);
        fileMainMenu.add(new JSeparator());
        fileMainMenu.add(reloadResources);
        fileMainMenu.add(new JSeparator());
        fileMainMenu.add(runButton);
        fileMainMenu.add(compileButton);
        fileMainMenu.add(new JSeparator());
        fileMainMenu.add(saveAsRunnableJar);
        //fileMainMenuBar.add(mntmSaveAsAPK);
        fileMainMenu.add(saveAsDex);
        fileMainMenu.add(saveAsZip);
        fileMainMenu.add(decompileSaveOpened);
        fileMainMenu.add(decompileSaveAll);
        fileMainMenu.add(new JSeparator());
        fileMainMenu.add(recentFilesSecondaryMenu);
        fileMainMenu.add(new JSeparator());
        fileMainMenu.add(about);
        fileMainMenu.add(exit);
    
        saveAsZip.setActionCommand("");
    
        addResource.addActionListener(e -> selectFile());
        newWorkSpace.addActionListener(e -> BytecodeViewer.resetWorkspace(true));
        reloadResources.addActionListener(arg0 -> reloadResources());
        runButton.addActionListener(e -> runResources());
        compileButton.addActionListener(arg0 -> compileOnNewThread());
        saveAsRunnableJar.addActionListener(e -> Export.RUNNABLE_JAR.getExporter().promptForExport());
        saveAsAPK.addActionListener(arg0 -> Export.APK.getExporter().promptForExport());
        saveAsDex.addActionListener(arg0 -> Export.DEX.getExporter().promptForExport());
        saveAsZip.addActionListener(arg0 -> Export.ZIP.getExporter().promptForExport());
        decompileSaveAll.addActionListener(arg0 -> ResourceDecompiling.decompileSaveAll());
        decompileSaveOpened.addActionListener(arg0 -> ResourceDecompiling.decompileSaveOpenedResource());
        about.addActionListener(arg0 -> new AboutWindow().setVisible(true));
        exit.addActionListener(arg0 -> askBeforeExiting());
    }
    
    public void buildViewMenu()
    {
        rootMenu.add(viewMainMenu);
        viewMainMenu.add(visualSettings);
        viewMainMenu.add(viewPane1.getMenu());
        viewMainMenu.add(viewPane2.getMenu());
        viewMainMenu.add(viewPane3.getMenu());
    }
    
    public void buildSettingsMenu()
    {
        rootMenu.add(settingsMainMenu);
        
        //settingsMainMenu.add(visualSettings);
        //settingsMainMenu.add(new JSeparator());
        settingsMainMenu.add(compileOnSave);
        settingsMainMenu.add(autoCompileOnRefresh);
        settingsMainMenu.add(refreshOnChange);
        
        settingsMainMenu.add(new JSeparator());
        settingsMainMenu.add(updateCheck);
        settingsMainMenu.add(forcePureAsciiAsText);
        settingsMainMenu.add(new JSeparator());
        settingsMainMenu.add(setPython2);
        settingsMainMenu.add(setPython3);
        settingsMainMenu.add(setJRERT);
        settingsMainMenu.add(setOptionalLibrary);
        settingsMainMenu.add(setJavac);
        settingsMainMenu.add(new JSeparator());
        
        //TODO the dialog below works but for 3 options,
        // it might be better to leave it as a secondary menu
        settingsMainMenu.add(apkConversionSecondaryMenu);
        //settingsMainMenu.add(useNewSettingsDialog ? apkConversionSettings : apkConversionMenu);
    
        //Smali minSdkVersion
        minSdkVersionSpinner.setPreferredSize(new Dimension(60, 24));
        minSdkVersionSpinner.setMinimumSize(new Dimension(60, 24));
        minSdkVersionSpinner.setModel(new SpinnerNumberModel(26, 1, null, 1));
        minSdkVersionMenu.add(minSdkVersionSpinner);
        settingsMainMenu.add(minSdkVersionMenu);
        
        settingsMainMenu.add(new JSeparator());
        
        fontSpinner.setPreferredSize(new Dimension(60, 24));
        fontSpinner.setMinimumSize(new Dimension(60, 24));
        fontSpinner.setModel(new SpinnerNumberModel(12, 1, null, 1));
        fontSize.add(fontSpinner);
        
        apkConversionSecondaryMenu.add(decodeAPKResources);
        apkConversionSecondaryMenu.add(apkConversionDex);
        apkConversionSecondaryMenu.add(apkConversionEnjarify);
        apkConversionGroup.add(apkConversionDex);
        apkConversionGroup.add(apkConversionEnjarify);
        apkConversionGroup.setSelected(apkConversionDex.getModel(), true);
        //apkConversionSettingsDialog = new SettingsDialogue(apkConversionSecondaryMenu, new JPanel());
        apkConversionSettings.addActionListener((e)-> apkConversionSettingsDialog.showDialog());
        
        ButtonGroup rstaGroup = new ButtonGroup();
        for (RSTATheme t : RSTATheme.values())
        {
            JRadioButtonMenuItem item = new TranslatedJRadioButtonMenuItem(t.getReadableName(), t.getTranslation());
            if (Configuration.rstaTheme.equals(t))
                item.setSelected(true);
            
            rstaGroup.add(item);
            
            item.addActionListener(e ->
            {
                Configuration.rstaTheme = t;
                item.setSelected(true);
                SettingsSerializer.saveSettingsAsync();
                updateTabTheme();
            });
            
            rstaThemes.put(t, item);
            rstaTheme.add(item);
        }
        
        rstaThemeSettingsDialog = new SettingsDialog(rstaTheme, new JPanel());
        rstaThemeSettings.addActionListener((e)-> rstaThemeSettingsDialog.showDialog());
    
        ButtonGroup lafGroup = new ButtonGroup();
        for (LAFTheme theme : LAFTheme.values())
        {
            JRadioButtonMenuItem item = new TranslatedJRadioButtonMenuItem(theme.getReadableName(), theme.getTranslation());
            if (Configuration.lafTheme.equals(theme))
                item.setSelected(true);
            
            lafGroup.add(item);
            
            item.addActionListener(e ->
            {
                Configuration.lafTheme = theme;
                Configuration.rstaTheme = theme.getRSTATheme();
                rstaThemes.get(Configuration.rstaTheme).setSelected(true);
                item.setSelected(true);
                SettingsSerializer.saveSettingsAsync();
                
                try
                {
                    theme.setLAF();
                    updateTabTheme();
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                }
            });
    
            lafThemes.put(theme, item);
            lafTheme.add(item);
        }
        
        lafThemeSettingsDialog = new SettingsDialog(lafTheme, new JPanel());
        lafThemeSettings.addActionListener((e)-> lafThemeSettingsDialog.showDialog());
    
        ButtonGroup languageGroup = new ButtonGroup();
        for (Language l : Language.values())
        {
            JRadioButtonMenuItem item = new JRadioButtonMenuItem(l.getReadableName());
            if (Configuration.language.equals(l))
                item.setSelected(true);
    
            languageGroup.add(item);
            
            item.addActionListener(e ->
            {
                SettingsSerializer.saveSettingsAsync();
                MiscUtils.setLanguage(l);
            });
    
            languages.put(l, item);
            language.add(item);
        }
        
        languageSettingsDialog = new SettingsDialog(language, new JPanel());
        languageSettings.addActionListener((e)-> languageSettingsDialog.showDialog());
        
        visualSettings.add(useNewSettingsDialog ? lafThemeSettings : lafTheme);
        visualSettings.add(useNewSettingsDialog ? rstaThemeSettings : rstaTheme);
        visualSettings.add(useNewSettingsDialog ? languageSettings : language);
        visualSettings.add(fontSize);
        visualSettings.add(showFileInTabTitle);
        visualSettings.add(simplifyNameInTabTitle);
        visualSettings.add(synchronizedViewing);
        visualSettings.add(showClassMethods);
        
        //PROCYON SETTINGS
        settingsMainMenu.add(useNewSettingsDialog ? procyonSettings : procyonSettingsSecondaryMenu);
        procyonSettingsSecondaryMenu.add(alwaysGenerateExceptionVars);
        procyonSettingsSecondaryMenu.add(excludeNestedTypes);
        procyonSettingsSecondaryMenu.add(showDebugLineNumbers);
        procyonSettingsSecondaryMenu.add(includeLineNumbersInBytecode);
        procyonSettingsSecondaryMenu.add(includeErrorDiagnostics);
        procyonSettingsSecondaryMenu.add(showSyntheticMembers);
        procyonSettingsSecondaryMenu.add(simplifyMemberReferences);
        procyonSettingsSecondaryMenu.add(mergeVariables);
        procyonSettingsSecondaryMenu.add(forceExplicitTypeArguments);
        procyonSettingsSecondaryMenu.add(forceExplicitImports);
        procyonSettingsSecondaryMenu.add(flattenSwitchBlocks);
        procyonSettingsSecondaryMenu.add(retainPointlessSwitches);
        procyonSettingsSecondaryMenu.add(retainRedunantCasts);
        procyonSettingsSecondaryMenu.add(unicodeOutputEnabled);
        procyonSettingsDialog = new SettingsDialog(procyonSettingsSecondaryMenu, new JPanel());
        procyonSettings.addActionListener((e)-> procyonSettingsDialog.showDialog());
        
        //CFR SETTINGS
        settingsMainMenu.add(useNewSettingsDialog ? cfrSettings : cfrSettingsSecondaryMenu);
        cfrSettingsSecondaryMenu.add(decodeEnumSwitch);
        cfrSettingsSecondaryMenu.add(sugarEnums);
        cfrSettingsSecondaryMenu.add(decodeStringSwitch);
        cfrSettingsSecondaryMenu.add(arrayiter);
        cfrSettingsSecondaryMenu.add(collectioniter);
        cfrSettingsSecondaryMenu.add(innerClasses);
        cfrSettingsSecondaryMenu.add(removeBoilerPlate);
        cfrSettingsSecondaryMenu.add(removeInnerClassSynthetics);
        cfrSettingsSecondaryMenu.add(decodeLambdas);
        cfrSettingsSecondaryMenu.add(hideBridgeMethods);
        cfrSettingsSecondaryMenu.add(liftConstructorInit);
        cfrSettingsSecondaryMenu.add(removeDeadMethods);
        cfrSettingsSecondaryMenu.add(removeBadGenerics);
        cfrSettingsSecondaryMenu.add(sugarAsserts);
        cfrSettingsSecondaryMenu.add(sugarBoxing);
        cfrSettingsSecondaryMenu.add(showVersion);
        cfrSettingsSecondaryMenu.add(decodeFinally);
        cfrSettingsSecondaryMenu.add(tidyMonitors);
        cfrSettingsSecondaryMenu.add(lenient);
        cfrSettingsSecondaryMenu.add(dumpClassPath);
        cfrSettingsSecondaryMenu.add(comments);
        cfrSettingsSecondaryMenu.add(forceTopSort);
        cfrSettingsSecondaryMenu.add(forceTopSortAggress);
        cfrSettingsSecondaryMenu.add(forceExceptionPrune);
        cfrSettingsSecondaryMenu.add(stringBuffer);
        cfrSettingsSecondaryMenu.add(stringBuilder);
        cfrSettingsSecondaryMenu.add(silent);
        cfrSettingsSecondaryMenu.add(recover);
        cfrSettingsSecondaryMenu.add(eclipse);
        cfrSettingsSecondaryMenu.add(override);
        cfrSettingsSecondaryMenu.add(showInferrable);
        cfrSettingsSecondaryMenu.add(aexagg);
        cfrSettingsSecondaryMenu.add(forceCondPropagate);
        cfrSettingsSecondaryMenu.add(hideUTF);
        cfrSettingsSecondaryMenu.add(hideLongStrings);
        cfrSettingsSecondaryMenu.add(commentMonitor);
        cfrSettingsSecondaryMenu.add(allowCorrecting);
        cfrSettingsSecondaryMenu.add(labelledBlocks);
        cfrSettingsSecondaryMenu.add(j14ClassOBJ);
        cfrSettingsSecondaryMenu.add(hideLangImports);
        cfrSettingsSecondaryMenu.add(recoveryTypeClash);
        cfrSettingsSecondaryMenu.add(recoveryTypehInts);
        cfrSettingsSecondaryMenu.add(forceTurningIFs);
        cfrSettingsSecondaryMenu.add(forLoopAGGCapture);
        cfrSettingsDialog = new SettingsDialog(cfrSettingsSecondaryMenu, new JPanel());
        cfrSettings.addActionListener((e)-> cfrSettingsDialog.showDialog());
        
        //FERNFLOWER SETTINGS
        settingsMainMenu.add(useNewSettingsDialog ? fernFlowerSettings : fernFlowerSettingsSecondaryMenu);
        fernFlowerSettingsSecondaryMenu.add(ren);
        fernFlowerSettingsSecondaryMenu.add(dc4);
        fernFlowerSettingsSecondaryMenu.add(nns);
        fernFlowerSettingsSecondaryMenu.add(ner);
        fernFlowerSettingsSecondaryMenu.add(bto);
        fernFlowerSettingsSecondaryMenu.add(rgn);
        fernFlowerSettingsSecondaryMenu.add(rer);
        fernFlowerSettingsSecondaryMenu.add(rbr);
        fernFlowerSettingsSecondaryMenu.add(rsy);
        fernFlowerSettingsSecondaryMenu.add(hes);
        fernFlowerSettingsSecondaryMenu.add(hdc);
        fernFlowerSettingsSecondaryMenu.add(din);
        fernFlowerSettingsSecondaryMenu.add(das);
        fernFlowerSettingsSecondaryMenu.add(dgs);
        fernFlowerSettingsSecondaryMenu.add(den);
        fernFlowerSettingsSecondaryMenu.add(uto);
        fernFlowerSettingsSecondaryMenu.add(udv);
        fernFlowerSettingsSecondaryMenu.add(fdi);
        fernFlowerSettingsSecondaryMenu.add(asc);
        fernFlowerSettingsDialog = new SettingsDialog(fernFlowerSettingsSecondaryMenu, new JPanel());
        fernFlowerSettings.addActionListener((e)-> fernFlowerSettingsDialog.showDialog());
        
        //CFIDE SETTINGS
        settingsMainMenu.add(useNewSettingsDialog ? bytecodeDecompilerSettings : bytecodeDecompilerSettingsSecondaryMenu);
        bytecodeDecompilerSettingsSecondaryMenu.add(debugHelpers);
        bytecodeDecompilerSettingsSecondaryMenu.add(appendBracketsToLabels);
        bytecodeDecompilerSettingsSecondaryMenu.add(printLineNumbers);
        bytecodeDecompilerSettingsDialog = new SettingsDialog(bytecodeDecompilerSettingsSecondaryMenu, new JPanel());
        bytecodeDecompilerSettings.addActionListener((e)-> bytecodeDecompilerSettingsDialog.showDialog());
        
        deleteForeignOutdatedLibs.addActionListener(arg0 -> showForeignLibraryWarning());
        forcePureAsciiAsText.addActionListener(arg0 -> SettingsSerializer.saveSettingsAsync());
        setPython2.addActionListener(arg0 -> ExternalResources.getSingleton().selectPython2());
        setJRERT.addActionListener(arg0 -> ExternalResources.getSingleton().selectJRERTLibrary());
        setPython3.addActionListener(arg0 -> ExternalResources.getSingleton().selectPython3());
        setOptionalLibrary.addActionListener(arg0 -> ExternalResources.getSingleton().selectOptionalLibraryFolder());
        setJavac.addActionListener(arg0 -> ExternalResources.getSingleton().selectJavac());
        showFileInTabTitle.addActionListener(arg0 -> {
            Configuration.displayParentInTab = BytecodeViewer.viewer.showFileInTabTitle.isSelected();
            SettingsSerializer.saveSettingsAsync();
            BytecodeViewer.refreshAllTabTitles();
        });
        simplifyNameInTabTitle.addActionListener(arg0 -> {
            Configuration.simplifiedTabNames = BytecodeViewer.viewer.simplifyNameInTabTitle.isSelected();
            SettingsSerializer.saveSettingsAsync();
            BytecodeViewer.refreshAllTabTitles();
        });
    }
    
    public void buildPluginMenu()
    {
        rootMenu.add(pluginsMainMenu);
        pluginsMainMenu.add(openExternalPlugin);
        pluginsMainMenu.add(new JSeparator());
        pluginsMainMenu.add(recentPluginsSecondaryMenu);
        pluginsMainMenu.add(new JSeparator());
        pluginsMainMenu.add(newJavaPlugin);
        pluginsMainMenu.add(newJavascriptPlugin);
        pluginsMainMenu.add(new JSeparator()); //android specific plugins first
        pluginsMainMenu.add(viewAPKAndroidPermissions);
        pluginsMainMenu.add(new JSeparator());
        pluginsMainMenu.add(viewManifest);
        pluginsMainMenu.add(codeSequenceDiagram);
        pluginsMainMenu.add(maliciousCodeScanner);
        pluginsMainMenu.add(showMainMethods);
        pluginsMainMenu.add(showAllStrings);
        pluginsMainMenu.add(replaceStrings);
        pluginsMainMenu.add(stackFramesRemover);
        pluginsMainMenu.add(changeClassFileVersions);
        
        //allatori is disabled since they are just placeholders
        //ZKM and ZStringArray decrypter are disabled until deobfuscation has been extended
        //mnNewMenu_1.add(mntmNewMenuItem_2);
        //mnNewMenu_1.add(mntmStartZkmString);
        //pluginsMainMenu.add(zStringArrayDecrypter);
        
        openExternalPlugin.addActionListener(arg0 -> openExternalPlugin());
        newJavaPlugin.addActionListener(arg0 -> PluginTemplate.JAVA.openEditorExceptionHandled());
        newJavascriptPlugin.addActionListener(arg0 -> PluginTemplate.JAVASCRIPT.openEditorExceptionHandled());
        codeSequenceDiagram.addActionListener(arg0 -> CodeSequenceDiagram.open());
        maliciousCodeScanner.addActionListener(e -> MaliciousCodeScannerOptions.open());
        showMainMethods.addActionListener(e -> PluginManager.runPlugin(new ShowMainMethods()));
        showAllStrings.addActionListener(e -> PluginManager.runPlugin(new ShowAllStrings()));
        replaceStrings.addActionListener(arg0 -> ReplaceStringsOptions.open());
        stackFramesRemover.addActionListener(e -> PluginManager.runPlugin(new StackFramesRemover()));
        allatoriStringDecrypter.addActionListener(e -> PluginManager.runPlugin(new AllatoriStringDecrypter.AllatoriStringDecrypterOptions()));
        ZKMStringDecrypter.addActionListener(e -> PluginManager.runPlugin(new ZKMStringDecrypter()));
        zStringArrayDecrypter.addActionListener(arg0 -> PluginManager.runPlugin(new ZStringArrayDecrypter()));
        viewAPKAndroidPermissions.addActionListener(arg0 -> PluginManager.runPlugin(new ViewAPKAndroidPermissions()));
        viewManifest.addActionListener(arg0 -> PluginManager.runPlugin(new ViewManifest()));
        changeClassFileVersions.addActionListener(arg0 -> PluginManager.runPlugin(new ChangeClassFileVersions()));
    }
    
    public void buildObfuscateMenu()
    {
        //hide obfuscation menu since it's currently not being used
        obfuscate.setVisible(false);
        
        rootMenu.add(obfuscate);
        obfuscate.add(strongObf);
        obfuscate.add(lightObf);
        obfuscate.add(new JSeparator());
        obfuscate.add(moveAllClassesIntoRoot);
        obfuscate.add(renameFields);
        obfuscate.add(renameMethods);
        obfuscate.add(renameClasses);
        obfuscate.add(controlFlow);
        obfuscate.add(junkCode);
        
        obfuscatorGroup.add(strongObf);
        obfuscatorGroup.add(lightObf);
        obfuscatorGroup.setSelected(strongObf.getModel(), true);
    
        renameFields.addActionListener(arg0 -> RenameFields.open());
        renameClasses.addActionListener(arg0 -> RenameClasses.open());
        renameMethods.addActionListener(arg0 -> RenameMethods.open());
    }
    
    public void defaultSettings()
    {
        compileOnSave.setSelected(false);
        autoCompileOnRefresh.setSelected(true);
        decodeAPKResources.setSelected(true);
        updateCheck.setSelected(true);
        forcePureAsciiAsText.setSelected(true);
        showSyntheticMembers.setSelected(true);
        
        showFileInTabTitle.setSelected(false);
        showClassMethods.setSelected(false);
    
        simplifyNameInTabTitle.setEnabled(true);
    
        moveAllClassesIntoRoot.setEnabled(false);
        controlFlow.setEnabled(false);
        junkCode.setEnabled(false);
        
        // cfr
        decodeEnumSwitch.setSelected(true);
        sugarEnums.setSelected(true);
        decodeStringSwitch.setSelected(true);
        arrayiter.setSelected(true);
        collectioniter.setSelected(true);
        innerClasses.setSelected(true);
        removeBoilerPlate.setSelected(true);
        removeInnerClassSynthetics.setSelected(true);
        decodeLambdas.setSelected(true);
        hideBridgeMethods.setSelected(true);
        liftConstructorInit.setSelected(true);
        removeDeadMethods.setSelected(true);
        removeBadGenerics.setSelected(true);
        sugarAsserts.setSelected(true);
        sugarBoxing.setSelected(true);
        showVersion.setSelected(true);
        decodeFinally.setSelected(true);
        tidyMonitors.setSelected(true);
        lenient.setSelected(false);
        dumpClassPath.setSelected(false);
        comments.setSelected(true);
        forceTopSort.setSelected(true);
        forceTopSortAggress.setSelected(true);
        forceExceptionPrune.setSelected(true);
        stringBuffer.setSelected(false);
        stringBuilder.setSelected(true);
        silent.setSelected(true);
        recover.setSelected(true);
        eclipse.setSelected(true);
        override.setSelected(true);
        showInferrable.setSelected(true);
        aexagg.setSelected(true);
        forceCondPropagate.setSelected(true);
        hideUTF.setSelected(true);
        hideLongStrings.setSelected(false);
        commentMonitor.setSelected(false);
        allowCorrecting.setSelected(true);
        labelledBlocks.setSelected(true);
        j14ClassOBJ.setSelected(false);
        hideLangImports.setSelected(true);
        recoveryTypeClash.setSelected(true);
        recoveryTypehInts.setSelected(true);
        forceTurningIFs.setSelected(true);
        forLoopAGGCapture.setSelected(true);
        
        // fernflower
        rbr.setSelected(true);
        rsy.setSelected(false);
        din.setSelected(true);
        das.setSelected(true);
        dgs.setSelected(false);
        den.setSelected(true);
        uto.setSelected(true);
        udv.setSelected(true);
        fdi.setSelected(true);
        asc.setSelected(false);
        ren.setSelected(false);
        dc4.setSelected(true);
        nns.setSelected(true);
        ner.setSelected(true);
        bto.setSelected(true);
        rgn.setSelected(true);
        rer.setSelected(true);
        hes.setSelected(true);
        hdc.setSelected(true);
        
        //CFIDE
        debugHelpers.setSelected(true);
        appendBracketsToLabels.setSelected(true);
        printLineNumbers.setSelected(false);
    }
    
    public void calledAfterLoad() {
        deleteForeignOutdatedLibs.setSelected(Configuration.deleteForeignLibraries);
    }
    
    public int getFontSize()
    {
        return (int) fontSpinner.getValue();
    }

    public int getMinSdkVersion()
    {
        return (int) minSdkVersionSpinner.getValue();
    }
    
    public synchronized void clearBusyStatus()
    {
        SwingUtilities.invokeLater(()->
        {
            int length = waitIcons.size();
            for (int i = 0; i < length; i++)
                updateBusyStatus(false);
        });
    }
    
    public synchronized void updateBusyStatus(final boolean busy)
    {
        SwingUtilities.invokeLater(() ->
        {
            if (busy)
            {
                JMenuItem waitIcon = new WaitBusyIcon();
                
                rootMenu.add(waitIcon);
                waitIcons.add(waitIcon);
            }
            else
            {
                if(waitIcons.isEmpty())
                    return;
    
                JMenuItem waitIcon = waitIcons.get(0);
                waitIcons.remove(0);
                rootMenu.remove(waitIcon);
                
                //re-enable the Refresh Button incase it gets stuck
                if(waitIcons.isEmpty() && !workPane.refreshClass.isEnabled())
                    workPane.refreshClass.setEnabled(true);
            }
    
            rootMenu.updateUI();
        });
    }
    
    public void compileOnNewThread()
    {
        Thread t = new Thread(() -> BytecodeViewer.compile(true, true), "Compile");
        t.start();
    }
    
    public void runResources()
    {
        if (BytecodeViewer.promptIfNoLoadedClasses())
            return;
        
        new RunOptions().setVisible(true);
    }
    
    public void reloadResources()
    {
        MultipleChoiceDialog dialog = new MultipleChoiceDialog(TranslatedStrings.RELOAD_RESOURCES_TITLE.toString(),
                TranslatedStrings.RELOAD_RESOURCES_CONFIRM.toString(),
                new String[]{TranslatedStrings.YES.toString(), TranslatedStrings.NO.toString()});
    
        if (dialog.promptChoice() == 0)
        {
            LazyNameUtil.reset();
            List<File> reopen = new ArrayList<>();
        
            for (ResourceContainer container : BytecodeViewer.resourceContainers.values())
            {
                File newFile = new File(container.file.getParent() + fs + container.name);
                if (!container.file.getAbsolutePath().equals(newFile.getAbsolutePath()) &&
                        (container.file.getAbsolutePath().endsWith(".apk") || container.file.getAbsolutePath().endsWith(".dex"))) //APKs & dex get renamed
                {
                    container.file.renameTo(newFile);
                    container.file = newFile;
                }
                reopen.add(container.file);
            }
        
            BytecodeViewer.viewer.resourcePane.treeRoot.removeAllChildren();
            BytecodeViewer.resourceContainers.clear();
        
            for (File f : reopen)
            {
                BytecodeViewer.openFiles(new File[]{f}, false);
            }
        
            //refresh panes
        }
    }
    
    public void selectFile()
    {
        final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_FILE_TITLE.toString(),
                TranslatedStrings.SELECT_FILE_DESCRIPTION.toString(),
                Constants.SUPPORTED_FILE_EXTENSIONS);
    
        if(file == null)
            return;
        
        BytecodeViewer.updateBusyStatus(true);
        BytecodeViewer.openFiles(new File[]{file}, true);
        BytecodeViewer.updateBusyStatus(false);
    }
    
    public void openExternalPlugin()
    {
        final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_EXTERNAL_PLUGIN_TITLE.toString(),
                TranslatedStrings.SELECT_EXTERNAL_PLUGIN_DESCRIPTION.toString(),
                Configuration.getLastPluginDirectory(),
                PluginManager.fileFilter(),
                Configuration::setLastPluginDirectory,
                FileChooser.EVERYTHING);
    
        if(file == null)
            return;
    
        BytecodeViewer.updateBusyStatus(true);
        BytecodeViewer.startPlugin(file);
        BytecodeViewer.updateBusyStatus(false);
        SettingsSerializer.saveSettingsAsync();
    }
    
    public void askBeforeExiting()
    {
        MultipleChoiceDialog dialog = new MultipleChoiceDialog(TranslatedStrings.EXIT_TITLE.toString(),
                TranslatedStrings.EXIT_CONFIRM.toString(),
                new String[]{TranslatedStrings.YES.toString(), TranslatedStrings.NO.toString()});
    
        if (dialog.promptChoice() == 0)
        {
            Configuration.canExit = true;
            System.exit(0);
        }
    }
    
    public void showForeignLibraryWarning()
    {
        if (!deleteForeignOutdatedLibs.isSelected())
            BytecodeViewer.showMessage(TranslatedStrings.FOREIGN_LIBRARY_WARNING.toString());
        
        Configuration.deleteForeignLibraries = deleteForeignOutdatedLibs.isSelected();
    }
    
    public void updateTabTheme()
    {
        try
        {
            for(Component viewerComponent : BytecodeViewer.viewer.workPane.tabs.getComponents())
            {
                if(!(viewerComponent instanceof ResourceViewer))
                    continue;
            
                ResourceViewer viewerResource = (ResourceViewer) viewerComponent;
                if(!(viewerResource instanceof ClassViewer))
                    continue;
            
                ClassViewer viewerClass = (ClassViewer) viewerResource;
                Configuration.rstaTheme.apply(viewerClass.bytecodeViewPanel1.textArea);
                Configuration.rstaTheme.apply(viewerClass.bytecodeViewPanel2.textArea);
                Configuration.rstaTheme.apply(viewerClass.bytecodeViewPanel3.textArea);
            }
            
            SwingUtilities.updateComponentTreeUI(BytecodeViewer.viewer);
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
    }
    
    public static final long serialVersionUID = 1851409230530948543L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/AboutWindow.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.CardLayout;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import the.bytecode.club.bytecodeviewer.bootloader.InitialBootScreen;
import the.bytecode.club.bytecodeviewer.resources.IconResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

import static the.bytecode.club.bytecodeviewer.Configuration.language;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The about window - used to explain what BCV is, how to use it, etc.
 *
 * @author Konloch
 */

public class AboutWindow extends JFrame
{
    public AboutWindow()
    {
        this.setIconImages(IconResources.iconList);
        setSize(InitialBootScreen.getSafeSize());
        setTitle(TranslatedStrings.ABOUT_TITLE.toString());
        getContentPane().setLayout(new CardLayout(0, 0));
        
        JScrollPane scrollPane = new JScrollPane();
        getContentPane().add(scrollPane);
        
        try
        {
            scrollPane.setViewportView(HTMLPane.fromResource(language.getHTMLPath("intro")));
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        
        this.setLocationRelativeTo(null);
    }

    private static final long serialVersionUID = -8230501978224923296L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/ButtonHoverAnimation.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Component;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.AbstractButton;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public class ButtonHoverAnimation extends MouseAdapter
{
	@Override
	public void mouseEntered(final MouseEvent e)
	{
		final Component component = e.getComponent();
		if (component instanceof AbstractButton)
		{
			final AbstractButton button = (AbstractButton) component;
			button.setBorderPainted(true);
		}
	}
	
	@Override
	public void mouseExited(final MouseEvent e)
	{
		final Component component = e.getComponent();
		if (component instanceof AbstractButton)
		{
			final AbstractButton button = (AbstractButton) component;
			button.setBorderPainted(false);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/DecompilerViewComponent.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import javax.swing.ButtonGroup;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JSeparator;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.WorkspaceRefreshEvent;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJCheckBoxMenuItem;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJRadioButtonMenuItem;

import static the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent.DecompilerComponentType.BYTECODE;
import static the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent.DecompilerComponentType.BYTECODE_NON_EDITABLE;
import static the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent.DecompilerComponentType.JAVA;
import static the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent.DecompilerComponentType.JAVA_AND_BYTECODE;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/21/2021
 */
public class DecompilerViewComponent
{
	private final String name;
	private final JMenu menu;
	private final DecompilerComponentType type;
	private final Decompiler[] decompilers;
	private final JRadioButtonMenuItem java;
	private final JRadioButtonMenuItem bytecode;
	private final JCheckBoxMenuItem editable;
	
	public DecompilerViewComponent(String name, DecompilerComponentType type, Decompiler... decompilers)
	{
		this.name = name;
		this.menu = new JMenu(name);
		this.type = type;
		this.decompilers = decompilers;
		this.java = new TranslatedJRadioButtonMenuItem("Java", TranslatedComponents.JAVA);
		this.bytecode = new TranslatedJRadioButtonMenuItem("Bytecode", TranslatedComponents.BYTECODE);
		this.editable = new TranslatedJCheckBoxMenuItem( "Editable", TranslatedComponents.EDITABLE);
		
		createMenu();
	}
	
	private void createMenu()
	{
		if(type == JAVA || type == JAVA_AND_BYTECODE)
			menu.add(java);
		if(type == BYTECODE || type == JAVA_AND_BYTECODE || type == BYTECODE_NON_EDITABLE)
			menu.add(bytecode);
		
		if(type != BYTECODE_NON_EDITABLE)
		{
			menu.add(new JSeparator());
			menu.add(editable);
		}
		
		java.addActionListener(new WorkspaceRefreshEvent());
	}
	
	public void addToGroup(ButtonGroup group)
	{
		if(type == JAVA || type == JAVA_AND_BYTECODE)
			group.add(java);
		if(type == BYTECODE || type == JAVA_AND_BYTECODE || type == BYTECODE_NON_EDITABLE)
			group.add(bytecode);
	}
	
	public JMenu getMenu()
	{
		return menu;
	}
	
	public JRadioButtonMenuItem getJava()
	{
		return java;
	}
	
	public JRadioButtonMenuItem getBytecode()
	{
		return bytecode;
	}
	
	public JCheckBoxMenuItem getEditable()
	{
		return editable;
	}
	
	public DecompilerComponentType getType()
	{
		return type;
	}
	
	public Decompiler[] getDecompilers()
	{
		return decompilers;
	}
	
	public enum DecompilerComponentType
	{
		JAVA,
		BYTECODE,
		BYTECODE_NON_EDITABLE,
		JAVA_AND_BYTECODE
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/ExportJar.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Dimension;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.util.JarUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The export as Jar UI.
 *
 * @author Konloch
 */

public class ExportJar extends JFrame
{
    public ExportJar(final String jarPath)
    {
        setSize(new Dimension(250, 277));
        setResizable(false);
        setTitle("Save As Jar..");

        JButton btnNewButton = new JButton("Save As Jar..");
        btnNewButton.setMaximumSize(new Dimension(999, 23));
        btnNewButton.setMinimumSize(new Dimension(999, 23));
        btnNewButton.setSize(new Dimension(999, 0));
        getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));

        JScrollPane scrollPane = new JScrollPane();
        getContentPane().add(scrollPane);

        scrollPane.setColumnHeaderView(new JLabel("META-INF/MANIFEST.MF:"));

        final JTextArea manifest = new JTextArea();
        manifest.setText("Manifest-Version: 1.0\r\nClass-Path: .\r\nMain-Class: ");
        scrollPane.setViewportView(manifest);
        getContentPane().add(btnNewButton);

        btnNewButton.addActionListener(arg0 ->
        {
            BytecodeViewer.updateBusyStatus(true);
            Thread t = new Thread(() ->
            {
                JarUtils.saveAsJar(BytecodeViewer.getLoadedClasses(), jarPath, manifest.getText());
                BytecodeViewer.updateBusyStatus(false);
            }, "Jar Export");
            t.start();
            dispose();
        });

        this.setLocationRelativeTo(null);
    }

    private static final long serialVersionUID = -2662514582647810868L;
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/ExtendedJOptionPane.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.HeadlessException;
import javax.swing.Icon;
import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.UIManager;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

import static javax.swing.JOptionPane.CLOSED_OPTION;
import static javax.swing.JOptionPane.DEFAULT_OPTION;
import static javax.swing.JOptionPane.ERROR_MESSAGE;
import static javax.swing.JOptionPane.INFORMATION_MESSAGE;
import static javax.swing.JOptionPane.OK_CANCEL_OPTION;
import static javax.swing.JOptionPane.PLAIN_MESSAGE;
import static javax.swing.JOptionPane.QUESTION_MESSAGE;
import static javax.swing.JOptionPane.UNINITIALIZED_VALUE;
import static javax.swing.JOptionPane.WARNING_MESSAGE;
import static javax.swing.JOptionPane.getRootFrame;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Extends the JOptionPane
 *
 * @author Konloch
 * @author James Gosling
 * @author Scott Violet
 * @since 7/4/2021
 */

public class ExtendedJOptionPane
{
	public static void showMessageDialog(Component parentComponent,
	                                     Object message) throws HeadlessException
	{
		showMessageDialog(parentComponent, message, UIManager.getString(
				"OptionPane.messageDialogTitle", parentComponent.getLocale()),
				INFORMATION_MESSAGE);
	}
	
	public static void showMessageDialog(Component parentComponent,
	                                     Object message, String title, int messageType)
			throws HeadlessException
	{
		showMessageDialog(parentComponent, message, title, messageType, null);
	}
	
	public static void showMessageDialog(Component parentComponent,
	                                     Object message, String title, int messageType, Icon icon)
			throws HeadlessException
	{
		showOptionDialog(parentComponent, message, title, DEFAULT_OPTION,
				messageType, icon, null, null);
	}
	
	public static String showInputDialog(Object message)
			throws HeadlessException {
		return showInputDialog(null, message);
	}
	
	public static String showInputDialog(Object message, Object initialSelectionValue) {
		return showInputDialog(null, message, initialSelectionValue);
	}
	
	public static String showInputDialog(Component parentComponent,
	                                     Object message) throws HeadlessException {
		return showInputDialog(parentComponent, message, UIManager.getString(
				"OptionPane.inputDialogTitle", parentComponent.getLocale()), QUESTION_MESSAGE);
	}
	
	public static String showInputDialog(Component parentComponent, Object message,
	                                     Object initialSelectionValue) {
		return (String)showInputDialog(parentComponent, message,
				UIManager.getString("OptionPane.inputDialogTitle",
						parentComponent.getLocale()), QUESTION_MESSAGE, null, null,
				initialSelectionValue);
	}
	
	public static String showInputDialog(Component parentComponent,
	                                     Object message, String title, int messageType)
			throws HeadlessException {
		return (String)showInputDialog(parentComponent, message, title,
				messageType, null, null, null);
	}
	
	public static int showOptionDialog(Component parentComponent,
	                                   Object message, String title, int optionType, int messageType,
	                                   Icon icon, Object[] options, Object initialValue)
			throws HeadlessException
	{
		JOptionPane pane = new JOptionPane(message, messageType,
				optionType, icon,
				options, initialValue);
		
		pane.setInitialValue(initialValue);
		pane.setComponentOrientation(((parentComponent == null) ?
				getRootFrame() : parentComponent).getComponentOrientation());
		
		int style = styleFromMessageType(messageType);
		JDialog dialog = createNewJDialog(parentComponent, pane, title, style, (d)->
                pane.selectInitialValue());
		
		pane.selectInitialValue();
		
		Object selectedValue = pane.getValue();
		
		if(selectedValue == null)
			return CLOSED_OPTION;
		
		if(options == null)
		{
			if(selectedValue instanceof Integer)
				return (Integer) selectedValue;
			return CLOSED_OPTION;
		}
		
		for(int counter = 0, maxCounter = options.length;
		    counter < maxCounter; counter++)
		{
			if(options[counter].equals(selectedValue))
				return counter;
		}
		
		return CLOSED_OPTION;
	}
	
	public static Object showInputDialog(Component parentComponent,
	                                     Object message, String title, int messageType, Icon icon,
	                                     Object[] selectionValues, Object initialSelectionValue)
			throws HeadlessException {
		JOptionPane    pane = new JOptionPane(message, messageType,
				OK_CANCEL_OPTION, icon,
				null, null);
		
		pane.setWantsInput(true);
		pane.setSelectionValues(selectionValues);
		pane.setInitialSelectionValue(initialSelectionValue);
		pane.setComponentOrientation(((parentComponent == null) ?
				getRootFrame() : parentComponent).getComponentOrientation());
		
		int style = styleFromMessageType(messageType);
		JDialog dialog = createNewJDialog(parentComponent, pane, title, style, (d)->
                pane.selectInitialValue());
		
		pane.selectInitialValue();
		
		Object value = pane.getInputValue();
		
		if (value == UNINITIALIZED_VALUE)
			return null;
		
		return value;
	}
	
	public static void showJPanelDialog(Component parentComponent, JScrollPane panel, int minimumHeight, OnCreate onCreate)
			throws HeadlessException
	{
		//create a new option pane with a empty text and just 'ok'
		JOptionPane pane = new JOptionPane("");
		pane.add(panel, 0);

		JDialog dialog = createNewJDialog(parentComponent, pane, panel.getName(), ERROR_MESSAGE, (d)->
		{
			int newHeight = Math.min(minimumHeight, d.getHeight());
			d.setMinimumSize(new Dimension(d.getWidth(), newHeight));
			d.setSize(new Dimension(d.getWidth(), newHeight));
			
			if(onCreate != null)
				onCreate.onCreate(d);
		});
	}
	
	private static JDialog createNewJDialog(Component parentComponent, JOptionPane pane, String title, int style, OnCreate onCreate)
	{
		JDialog dialog = pane.createDialog(parentComponent, title);
		if (JDialog.isDefaultLookAndFeelDecorated()) {
			boolean supportsWindowDecorations =
					UIManager.getLookAndFeel().getSupportsWindowDecorations();
			if (supportsWindowDecorations) {
				dialog.setUndecorated(true);
				pane.getRootPane().setWindowDecorationStyle(style);
			}
		}

		onCreate.onCreate(dialog);
		
		//check if the dialog is in a poor location, attempt to correct
		if (dialog.getLocation().getY() == 0 || dialog.getLocation().getY() == 1)
			dialog.setLocationRelativeTo(null); //TODO check if BytecodeViewer.viewer is better on multi monitor for this edgecase
		else
			dialog.setLocationRelativeTo(BytecodeViewer.viewer);
		
		dialog.setVisible(true);
		dialog.dispose();
		
		return dialog;
	}
	
	private static int styleFromMessageType(int messageType)
	{
		switch (messageType)
		{
			case ERROR_MESSAGE:
				return JRootPane.ERROR_DIALOG;
			case QUESTION_MESSAGE:
				return JRootPane.QUESTION_DIALOG;
			case WARNING_MESSAGE:
				return JRootPane.WARNING_DIALOG;
			case INFORMATION_MESSAGE:
				return JRootPane.INFORMATION_DIALOG;
			case PLAIN_MESSAGE:
			default:
				return JRootPane.PLAIN_DIALOG;
		}
	}
	
	interface OnCreate
	{
		void onCreate(JDialog dialog);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/FileChooser.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.io.File;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public class FileChooser extends JFileChooser
{
	public static final String EVERYTHING = "everything";
	
	public FileChooser(File file, String title, String description, String... extensions)
	{
		this(false, file, title, description, extensions);
	}
	
	public FileChooser(boolean skipFileFilter, File file, String title, String description, String... extensions)
	{
		Set<String> extensionSet = new HashSet<>(Arrays.asList(extensions));
		
		setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
		try {
			setSelectedFile(file);
		} catch (Exception ignored) { }
		
		setDialogTitle(title);
		setFileHidingEnabled(false);
		setAcceptAllFileFilterUsed(false);
		if(!skipFileFilter)
		{
            addChoosableFileFilter(new FileFilter()
			{
				@Override
				public boolean accept(File f)
				{
					if (f.isDirectory())
						return true;
					
					if(extensions[0].equals(EVERYTHING))
						return true;
					
					return extensionSet.contains(MiscUtils.extension(f.getAbsolutePath()));
				}
				
				@Override
				public String getDescription() {
					return description;
				}
			});
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/HTMLPane.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.io.IOException;
import java.io.InputStream;
import java.util.Scanner;
import javax.swing.JEditorPane;
import javax.swing.text.html.HTMLEditorKit;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.bootloader.InitialBootScreen;

import static the.bytecode.club.bytecodeviewer.Constants.BCVDir;
import static the.bytecode.club.bytecodeviewer.Constants.FAT_JAR;
import static the.bytecode.club.bytecodeviewer.Constants.enjarifyVersion;
import static the.bytecode.club.bytecodeviewer.Constants.enjarifyWorkingDirectory;
import static the.bytecode.club.bytecodeviewer.Constants.krakatauVersion;
import static the.bytecode.club.bytecodeviewer.Constants.krakatauWorkingDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/7/2021
 */
public class HTMLPane extends JEditorPane
{
	private HTMLPane()
	{
		setEditorKit(new HTMLEditorKit());
		setEditable(false);
	}
	
	public static HTMLPane fromResource(String resourcePath) throws IOException
	{
		try (InputStream is = InitialBootScreen.class.getClassLoader().getResourceAsStream(resourcePath)) {
			return fromString(convertStreamToString(is));
		}
	}
	
	public static HTMLPane fromString(String text)
	{
		if (text == null)
			return null;
		
		HTMLPane pane = new HTMLPane();
		
		text = text.replace("{fatJar}", String.valueOf(FAT_JAR));
		text = text.replace("{java}", Configuration.java);
		text = text.replace("{javac}", Configuration.javac);
		text = text.replace("{bcvDir}", BCVDir.getAbsolutePath());
		text = text.replace("{python}", Configuration.python2+" " + (Configuration.python2Extra ? "-2" : ""));
		text = text.replace("{python3}", Configuration.python3 + " " + (Configuration.python3Extra ? "-3" : ""));
		text = text.replace("{rt}", Configuration.rt);
		text = text.replace("{lib}", Configuration.library);
		text = text.replace("{krakatauVersion}", krakatauVersion);
		text = text.replace("{krakatauDir}", krakatauWorkingDirectory);
		text = text.replace("{enjarifyVersion}", enjarifyVersion);
		text = text.replace("{enjarifyDir}", enjarifyWorkingDirectory);
		
		pane.setText(text);
		pane.setCaretPosition(0);
		
		return pane;
	}
	
	public static String convertStreamToString(InputStream is) throws IOException
	{
		if (is == null)
			return null;
		try (InputStream stream = is;
			 Scanner s = new Scanner(stream, "UTF-8").useDelimiter("\\A")) {
			return s.hasNext() ? s.next() : "";
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/ImageJLabel.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Image;
import javax.swing.ImageIcon;
import javax.swing.JLabel;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Display an image on a JLabel element
 *
 * @author Konloch
 * @since 6/25/2021
 */
public class ImageJLabel extends JLabel
{
	public ImageJLabel(Image image)
	{
		super("", new ImageIcon(image), JLabel.CENTER);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/JFrameConsole.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.io.File;
import javax.swing.JFrame;
import me.konloch.kontainer.io.DiskWriter;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple swing JFrame console
 *
 * @author Konloch
 * @since 6/25/2021
 */
public class JFrameConsole extends JFrame
{
	private String containerName;
	private int consoleID;
	private final SearchableJTextArea textArea;
	
	public JFrameConsole()
	{
		this("");
	}
	
	public JFrameConsole(String title)
	{
		setIconImages(IconResources.iconList);
		setTitle(title);
		setSize(new Dimension(542, 316));
		
		textArea = new SearchableJTextArea();
		getContentPane().add(textArea.getScrollPane(), BorderLayout.CENTER);
		
		this.setLocationRelativeTo(null);
	}
	
	/**
	 * Appends \r\n to the end of your string, then it puts it on the top.
	 *
	 * @param t the string you want to append
	 */
	public void appendText(String t)
	{
		setText((textArea.getText().isEmpty()
				? ""
				: textArea.getText() + "\r\n"
		) + t);
	}
	
	/**
	 * Sets the text
	 *
	 * @param t the text you want set
	 */
	public void setText(String t)
	{
		textArea.setText(trimConsoleText(t));
		textArea.setCaretPosition(0);
	}
	
	/**
	 * Returns the SearchableJTextArea pane
	 */
	public SearchableJTextArea getTextArea()
	{
		return textArea;
	}
	
	/**
	 * Returns the console ID
	 */
	public int getConsoleID()
	{
		return consoleID;
	}
	
	/**
	 * Returns the current container name
	 */
	public String getContainerName()
	{
		return containerName;
	}
	
	/**
	 * Set the console ID
	 */
	public void setConsoleID(int consoleID)
	{
		this.consoleID = consoleID;
	}
	
	/**
	 * Set the container name
	 */
	public void setContainerName(String containerName)
	{
		this.containerName = containerName;
	}
	
	/**
	 * Trims the console text to prevent killing the swing thread
	 */
	public String trimConsoleText(final String s)
	{
		int len = s.length();
		
		//TODO this should also be a setting eventually
		int max = 500_000;
		if(len >= max)
		{
			//TODO if two consoles are ran at the same time and exceed the maximum this file will be overwritten
			
			final File tempFile = new File(tempDirectory, "console_" + consoleID + ".log");
			
			//TODO this needs to be rewritten, it doesn't work for a plugin that causes multiple exception UIs
			new Thread(()->
			{
				//save to disk
				DiskWriter.replaceFile(tempFile.getAbsolutePath(), s, false);
			}, "Console Log Saving").start();
			
			//trim
			int skipped = len - max;
			String trimmed = s.substring(0, max);
			
			if(!trimmed.startsWith("WARNING: Skipping"))
				trimmed = ("WARNING: Skipping " + skipped + " chars, allowing " + max + "\n\r")
					+ "Full log saved to: " + tempFile.getAbsolutePath() + "\n\r\n\r"
					+ trimmed;
			
			return trimmed;
		}
		
		return s;
	}
	
	private static final long serialVersionUID = -5056940543411437508L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/JFrameConsolePrintStream.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.io.PrintStream;
import javax.swing.SwingUtilities;
import the.bytecode.club.bytecodeviewer.Constants;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A swing console that can print out from PrintStreams
 *
 * @author Konloch
 * @since 6/25/2021
 */
public class JFrameConsolePrintStream extends JFrameConsole
{
	private final JTextAreaOutputStream textAreaOutputStreamOut;
	private final JTextAreaOutputStream textAreaOutputStreamErr;
	private Thread updateThread;
	private boolean finished;
	private long lastUpdate = 0;
	
	public JFrameConsolePrintStream(String title)
	{
		this(title, true);
	}
	
	public JFrameConsolePrintStream(String title, boolean preserveOriginalOutput)
	{
		super(title);
		
		textAreaOutputStreamOut = new JTextAreaOutputStream(getTextArea(), preserveOriginalOutput ? System.out : null);
		textAreaOutputStreamErr = new JTextAreaOutputStream(getTextArea(), preserveOriginalOutput ? System.err : null);
		
		System.setOut(new PrintStream(textAreaOutputStreamOut));
		System.setErr(new PrintStream(textAreaOutputStreamErr));
	}
	
	@Override
	public void setVisible(boolean b)
	{
		super.setVisible(b);
		
		if(b && updateThread == null)
		{
			updateThread = new Thread(() ->
			{
				while (isVisible() && !finished)
				{
					update();
					
					try {
						Thread.sleep(10);
					} catch (InterruptedException ignored) { }
				}
				
				lastUpdate = 0;
				update();
			}, "Lazy Console Update");
			
			updateThread.start();
		}
	}
	
	public void finished()
	{
		finished = true;
		System.setErr(Constants.ERR);
		System.setOut(Constants.OUT);
	}
	
	public JTextAreaOutputStream getTextAreaOutputStreamErr()
	{
		return textAreaOutputStreamErr;
	}
	
	public JTextAreaOutputStream getTextAreaOutputStreamOut()
	{
		return textAreaOutputStreamOut;
	}
	
	private void update()
	{
		if(System.currentTimeMillis()-lastUpdate <= 50)
			return;
		
		lastUpdate = System.currentTimeMillis();
		
		//update only if required
		if(textAreaOutputStreamErr.noUpdateRequired() && textAreaOutputStreamOut.noUpdateRequired())
			return;
		
		SwingUtilities.invokeLater(()->
		{
			//print output to the pane
			textAreaOutputStreamOut.update();
			
			//print error to the pane
			textAreaOutputStreamErr.update();
			
			//reformat the pane
			String content = getTextArea().getText();
			if(content.contains("File `"))
			{
				String[] test = content.split("\r?\n");
				
				StringBuilder replace = new StringBuilder();
				for (String s : test)
				{
					if (s.startsWith("File '"))
					{
						String[] split = s.split("'");
						String start = split[0] + "'" + split[1] + "', ";
						s = s.substring(start.length());
					}
					replace.append(s).append(nl);
				}
				
				setText(replace.toString());
			}
		});
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/JFrameConsoleTabbed.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.JTabbedPane;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/14/2021
 */

public class JFrameConsoleTabbed extends JFrame
{
	private final JTabbedPane tabbedPane;
	
	public JFrameConsoleTabbed(String title)
	{
		setIconImages(IconResources.iconList);
		setTitle(title);
		setSize(new Dimension(542, 316));
		
		tabbedPane = new JTabbedPane();
		getContentPane().add(tabbedPane, BorderLayout.CENTER);
		
		this.setLocationRelativeTo(null);
	}
	
	public void addConsole(Component console, String containerName)
	{
		tabbedPane.add(console, containerName);
	}
	
	public JTabbedPane getTabbedPane()
	{
		return tabbedPane;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/JMenuItemIcon.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Dimension;
import java.awt.Graphics;
import javax.swing.Icon;
import javax.swing.JMenuItem;
import javax.swing.UIManager;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/4/2021
 */
public class JMenuItemIcon extends JMenuItem
{
	public JMenuItemIcon(Icon icon)
	{
		super("");
		
		setIcon(icon);
		setAlignmentY(0.65f);
		Dimension size = new Dimension((int) (icon.getIconWidth()*1.4), icon.getIconHeight());
		setSize(size);
		setPreferredSize(size);
		setMinimumSize(size);
		setMaximumSize(size);
	}
	
	@Override
	public void paint(Graphics g)
	{
		g.setColor(UIManager.getColor("Panel.background"));
		g.fillRect(0, 0, getWidth(), getHeight());
		super.paint(g);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/JTextAreaOutputStream.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.io.Closeable;
import java.io.OutputStream;
import java.io.PrintStream;
import javax.swing.JTextArea;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/21/2021
 */
public class JTextAreaOutputStream extends OutputStream implements Closeable
{
	private StringBuilder sb = new StringBuilder();
	private final JTextArea textArea;
	private final PrintStream og;
	
	public JTextAreaOutputStream(JTextArea textArea, PrintStream og)
	{
		this.textArea = textArea;
		this.og = og;
	}
	
	public boolean noUpdateRequired()
	{
		return sb.length() <= 0;
	}
	
	public void update()
	{
		textArea.append(sb.toString());
		sb = new StringBuilder();
	}
	
	@Override
	public void write(int b)
	{
		sb.append((char) b);
		if(og != null)
			og.write(b);
	}
	
	public StringBuilder getBuffer()
	{
		return sb;
	}

	@Override
	public void close() {
		if (og != null)
			og.close();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/MaxWidthJLabel.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Dimension;
import javax.swing.JLabel;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public class MaxWidthJLabel extends JLabel
{
	private final int width;
	private final int height;
	
	public MaxWidthJLabel(String title, int width, int height)
	{
		super(title);
		this.width = width;
		this.height = height;
	}
	
	@Override
	public Dimension getPreferredSize()
	{
		Dimension realDimension = super.getPreferredSize();
		if (realDimension.getWidth() >= width)
			return new Dimension(width, height);
		else
			return realDimension;
	}
	
	private static final long serialVersionUID = -5511025206527893360L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/MethodsRenderer.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Component;
import java.util.List;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;

import the.bytecode.club.bytecodeviewer.gui.resourceviewer.BytecodeViewPanel;
import the.bytecode.club.bytecodeviewer.gui.util.BytecodeViewPanelUpdater;
import the.bytecode.club.bytecodeviewer.util.MethodParser;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Waterwolf
 * @since 09/29/2011
 */
public class MethodsRenderer extends JLabel implements ListCellRenderer<Object>
{
	private final BytecodeViewPanelUpdater bytecodeViewPanelUpdater;
	
	public MethodsRenderer(BytecodeViewPanelUpdater bytecodeViewPanelUpdater)
	{
		this.bytecodeViewPanelUpdater = bytecodeViewPanelUpdater;
		setOpaque(true);
	}
	
	@Override
	public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected,
	                                              boolean cellHasFocus)
	{
		int methodIndex = (Integer) value;
		MethodParser methods;
		List<MethodParser> methodParsers = bytecodeViewPanelUpdater.viewer.methods;
		BytecodeViewPanel bytecodeViewPanel = bytecodeViewPanelUpdater.bytecodeViewPanel;
		try {
			methods = methodParsers.get(bytecodeViewPanel.decompiler.ordinal());
		} catch (ArrayIndexOutOfBoundsException e) {
			methods = methodParsers.get(bytecodeViewPanel.panelIndex);
		}
		MethodParser.Method method = methods.getMethod(methodIndex);
		setText(method.toString());
		return this;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/MultipleChoiceDialog.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import javax.swing.JDialog;
import javax.swing.JOptionPane;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public class MultipleChoiceDialog
{
	private final String title;
	private final String description;
	private final String[] options;
	
	public MultipleChoiceDialog(String title, String description, String[] options)
	{
		this.title = title;
		this.description = description;
		this.options = options;
	}
	
	public int promptChoice()
	{
		JOptionPane pane = new JOptionPane(description);
		pane.setOptions(options);
		JDialog dialog = pane.createDialog(BytecodeViewer.viewer, title);
		dialog.setVisible(true);
		Object obj = pane.getValue();
		int result = -1;
		for (int k = 0; k < options.length; k++)
			if (options[k].equals(obj))
				result = k;
			
		return result;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/RunOptions.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Dimension;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
import the.bytecode.club.bytecodeviewer.api.ASMResourceUtil;
import the.bytecode.club.bytecodeviewer.plugin.PluginManager;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.EZInjection;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The UI for File>Run aka EZ-Injection plugin.
 *
 * @author Konloch
 */

public class RunOptions extends JFrame
{
    private final JTextField mainMethodFQN;
    private final JCheckBox debugMethodCalls;
    private final JTextField debugClasses;
    private final JTextField socksProxy;
    
    public RunOptions()
    {
        this.setIconImages(IconResources.iconList);
        setSize(new Dimension(250, 402));
        setResizable(false);
        setTitle("Run Options");
        getContentPane().setLayout(null);

        final JCheckBox accessModifiers = new JCheckBox("Set All Access Modifiers Public");
        accessModifiers.setBounds(6, 7, 232, 23);
        getContentPane().add(accessModifiers);

        final JCheckBox invokeMethod = new JCheckBox("Invoke Main Method:");
        invokeMethod.setSelected(true);
        invokeMethod.setBounds(6, 203, 232, 23);
        getContentPane().add(invokeMethod);

        final JCheckBox injectHooks = new JCheckBox("Inject Hooks");
        injectHooks.setBounds(6, 33, 232, 23);
        getContentPane().add(injectHooks);

        debugMethodCalls = new JCheckBox("Debug Method Calls");
        debugMethodCalls.setBounds(6, 59, 232, 23);
        getContentPane().add(debugMethodCalls);

        mainMethodFQN = new JTextField();

        JButton btnNewButton = new JButton("Execute");
        btnNewButton.setBounds(6, 345, 232, 23);
        getContentPane().add(btnNewButton);

        mainMethodFQN.setText(ASMResourceUtil.findMainMethod("the/bytecode/club/Example.main"));

        mainMethodFQN.setBounds(6, 233, 232, 20);
        getContentPane().add(mainMethodFQN);
        mainMethodFQN.setColumns(10);

        JLabel lblNewLabel = new JLabel("Debug Classes (Separated with , ):");
        lblNewLabel.setBounds(10, 89, 228, 14);
        getContentPane().add(lblNewLabel);

        debugClasses = new JTextField();
        debugClasses.setText("*");
        debugClasses.setBounds(6, 111, 232, 20);
        getContentPane().add(debugClasses);
        debugClasses.setColumns(10);

        socksProxy = new JTextField();
        socksProxy.setText("127.0.0.1:9150");
        socksProxy.setColumns(10);
        socksProxy.setBounds(6, 172, 232, 20);
        getContentPane().add(socksProxy);

        final JCheckBox forceProxy = new JCheckBox("Force Proxy (socks5, host:port):");
        forceProxy.setBounds(6, 142, 232, 23);
        getContentPane().add(forceProxy);

        final JCheckBox launchReflectionKit = new JCheckBox("Launch Reflection Kit On Successful Invoke");
        launchReflectionKit.setEnabled(false);
        launchReflectionKit.setBounds(6, 260, 232, 23);
        getContentPane().add(launchReflectionKit);

        final JCheckBox console = new JCheckBox("Launch Console");
        console.setBounds(6, 286, 232, 23);
        console.setSelected(true);
        getContentPane().add(console);

        final JCheckBox printToCommandLine = new JCheckBox("Print To Command Line");
        printToCommandLine.setSelected(true);
        printToCommandLine.setBounds(6, 315, 232, 23);
        getContentPane().add(printToCommandLine);
        this.setLocationRelativeTo(null);
        btnNewButton.addActionListener(arg0 -> {
            PluginManager.runPlugin(new EZInjection(accessModifiers
                    .isSelected(), injectHooks.isSelected(),
                    debugMethodCalls.isSelected(), invokeMethod
                    .isSelected(),
                    mainMethodFQN.getText(), false, false, debugClasses
                    .getText(), this.socksProxy.getText(), forceProxy
                    .isSelected(),
                    launchReflectionKit.isSelected(), console.isSelected(),
                    printToCommandLine.isSelected()));
            dispose();
        });
    }

    private static final long serialVersionUID = -2662514582647810868L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/SearchableJTextArea.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.BorderLayout;
import java.awt.Font;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseWheelListener;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.GlobalHotKeys;
import the.bytecode.club.bytecodeviewer.gui.components.listeners.PressKeyListener;
import the.bytecode.club.bytecodeviewer.gui.components.listeners.ReleaseKeyListener;
import the.bytecode.club.bytecodeviewer.resources.IconResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJCheckBox;
import the.bytecode.club.bytecodeviewer.util.JTextAreaUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Searching on a JTextArea using swing highlighting
 *
 * @author Konloch
 * @since 6/25/2021
 */
public class SearchableJTextArea extends JTextArea
{
	private final JScrollPane scrollPane = new JScrollPane();
	private final JPanel searchPanel = new JPanel(new BorderLayout());
	private final JTextField searchInput = new JTextField();
	private final JCheckBox caseSensitiveSearch = new TranslatedJCheckBox("Match case", TranslatedComponents.MATCH_CASE);
	
	public SearchableJTextArea()
	{
		scrollPane.setViewportView(this);
		scrollPane.setColumnHeaderView(searchPanel);
		
		JButton searchNext = new JButton();
		searchNext.setIcon(IconResources.nextIcon);
		
		JButton searchPrev = new JButton();
		searchPrev.setIcon(IconResources.prevIcon);
		
		JPanel buttonPane = new JPanel(new BorderLayout());
		buttonPane.add(searchNext, BorderLayout.WEST);
		buttonPane.add(searchPrev, BorderLayout.EAST);
		
		searchPanel.add(buttonPane, BorderLayout.WEST);
		searchPanel.add(searchInput, BorderLayout.CENTER);
		searchPanel.add(caseSensitiveSearch, BorderLayout.EAST);
		
		searchNext.addActionListener(arg0 -> search(searchInput.getText(), true, caseSensitiveSearch.isSelected()));
		searchPrev.addActionListener(arg0 -> search(searchInput.getText(), false, caseSensitiveSearch.isSelected()));
		
		searchInput.addKeyListener(new ReleaseKeyListener(keyEvent ->
		{
			if (keyEvent.getKeyCode() == KeyEvent.VK_ENTER)
				search(searchInput.getText(), true, caseSensitiveSearch.isSelected());
		}));
		
		addKeyListener(new PressKeyListener(keyEvent ->
		{
			if ((keyEvent.getKeyCode() == KeyEvent.VK_F) && ((keyEvent.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
				searchInput.requestFocus();
			
			GlobalHotKeys.keyPressed(keyEvent);
		}));
		
		final Font newFont = getFont().deriveFont((float) BytecodeViewer.viewer.getFontSize());
		
		//set number-bar font
		setFont(newFont);
		
		SwingUtilities.invokeLater(()-> {
			//attach CTRL + Mouse Wheel Zoom
			attachCtrlMouseWheelZoom();
			
			//set text font
			setFont(newFont);
		});
	}
	
	public void search(String search, boolean forwardSearchDirection, boolean caseSensitiveSearch)
	{
		JTextAreaUtils.search(this, search, forwardSearchDirection, caseSensitiveSearch);
	}
	
	public void highlight(String pattern, boolean caseSensitiveSearch)
	{
		JTextAreaUtils.highlight(this, pattern, caseSensitiveSearch);
	}
	
	public void attachCtrlMouseWheelZoom()
	{
		//get the existing scroll event
		MouseWheelListener ogListener = scrollPane.getMouseWheelListeners().length > 0 ?
				scrollPane.getMouseWheelListeners()[0] : null;
		
		//remove the existing event
		if(ogListener != null)
			scrollPane.removeMouseWheelListener(ogListener);
		
		//add a new event
		scrollPane.addMouseWheelListener(e ->
		{
			if (getText().isEmpty())
				return;
			
			if ((e.getModifiersEx() & InputEvent.CTRL_DOWN_MASK) != 0)
			{
				Font font = getFont();
				int size = font.getSize();
				
				if (e.getWheelRotation() > 0) //Up
					setFont(new Font(font.getName(), font.getStyle(), --size >= 2 ? --size : 2));
				else //Down
					setFont(new Font(font.getName(), font.getStyle(), ++size));
				
				e.consume();
			}
			else if(ogListener != null)
			{
				ogListener.mouseWheelMoved(e);
			}
		});
	}
	
	public JScrollPane getScrollPane()
	{
		return scrollPane;
	}
	
	public JPanel getSearchPanel()
	{
		return searchPanel;
	}
	
	public JTextField getSearchInput()
	{
		return searchInput;
	}
	
	public JCheckBox getCaseSensitiveSearch()
	{
		return caseSensitiveSearch;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/SearchableRSyntaxTextArea.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseWheelListener;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rtextarea.RTextScrollPane;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.GlobalHotKeys;
import the.bytecode.club.bytecodeviewer.gui.components.listeners.PressKeyListener;
import the.bytecode.club.bytecodeviewer.gui.components.listeners.ReleaseKeyListener;
import the.bytecode.club.bytecodeviewer.gui.theme.LAFTheme;
import the.bytecode.club.bytecodeviewer.resources.IconResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJCheckBox;
import the.bytecode.club.bytecodeviewer.util.JTextAreaUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Searching on an RSyntaxTextArea using swing highlighting
 *
 * @author Konloch
 * @since 6/25/2021
 */
public class SearchableRSyntaxTextArea extends RSyntaxTextArea
{
	private final RTextScrollPane scrollPane = new RTextScrollPane(this);
	private final JPanel searchPanel = new JPanel(new BorderLayout());
	private final JTextField searchInput = new JTextField();
	private final JCheckBox caseSensitiveSearch = new TranslatedJCheckBox("Match case", TranslatedComponents.MATCH_CASE);
	private final JLabel titleHeader = new JLabel("");
	private final Color darkScrollBackground = new Color(0x3c3f41);
	private final Color darkScrollForeground = new Color(0x575859);
	private final Color blackScrollBackground = new Color(0x232323);
	private final Color blackScrollForeground = new Color(0x575859);
	private Runnable onCtrlS;
	
	public SearchableRSyntaxTextArea()
	{
		if(Configuration.lafTheme == LAFTheme.HIGH_CONTRAST_DARK)
		{
			//this fixes the white border on the jScrollBar panes
			scrollPane.getHorizontalScrollBar().setBackground(blackScrollBackground);
			scrollPane.getHorizontalScrollBar().setForeground(blackScrollForeground);
			scrollPane.getVerticalScrollBar().setBackground(blackScrollBackground);
			scrollPane.getVerticalScrollBar().setForeground(blackScrollForeground);
		}
		else if(Configuration.lafTheme.isDark())
		{
			//this fixes the white border on the jScrollBar panes
			scrollPane.getHorizontalScrollBar().setBackground(darkScrollBackground);
			scrollPane.getHorizontalScrollBar().setForeground(darkScrollForeground);
			scrollPane.getVerticalScrollBar().setBackground(darkScrollBackground);
			scrollPane.getVerticalScrollBar().setForeground(darkScrollForeground);
		}
		
		setAntiAliasingEnabled(true);
		
		scrollPane.setColumnHeaderView(searchPanel);
		
		JButton searchNext = new JButton();
		JButton searchPrev = new JButton();
		JPanel buttonPane = new JPanel(new BorderLayout());
		buttonPane.add(searchNext, BorderLayout.WEST);
		buttonPane.add(searchPrev, BorderLayout.EAST);
		searchNext.setIcon(IconResources.nextIcon);
		searchPrev.setIcon(IconResources.prevIcon);
		searchPanel.add(buttonPane, BorderLayout.WEST);
		searchPanel.add(searchInput, BorderLayout.CENTER);
		searchPanel.add(caseSensitiveSearch, BorderLayout.EAST);
		
		searchNext.addActionListener(arg0 -> search(searchInput.getText(), true, caseSensitiveSearch.isSelected()));
		searchPrev.addActionListener(arg0 -> search(searchInput.getText(), false, caseSensitiveSearch.isSelected()));
		
		searchInput.addKeyListener(new ReleaseKeyListener(keyEvent ->
		{
			if (keyEvent.getKeyCode() == KeyEvent.VK_ENTER)
				search(searchInput.getText(), true, caseSensitiveSearch.isSelected());
		}));
		
		addKeyListener(new PressKeyListener(keyEvent ->
		{
			if ((keyEvent.getKeyCode() == KeyEvent.VK_F) && ((keyEvent.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
				searchInput.requestFocus();
			
			if (onCtrlS != null && (keyEvent.getKeyCode() == KeyEvent.VK_S) && ((keyEvent.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) != 0))
			{
				onCtrlS.run();
				return;
			}
			
			GlobalHotKeys.keyPressed(keyEvent);
		}));
		
		final Font newFont = getFont().deriveFont((float) BytecodeViewer.viewer.getFontSize());
		
		//set number-bar font
		setFont(newFont);
		
		SwingUtilities.invokeLater(()-> {
			//attach CTRL + Mouse Wheel Zoom
			attachCtrlMouseWheelZoom();
			
			//set text font
			setFont(newFont);
		});
		
	}
	
	public void search(String search, boolean forwardSearchDirection, boolean caseSensitiveSearch)
	{
		JTextAreaUtils.search(this, search, forwardSearchDirection, caseSensitiveSearch);
	}
	
	public void highlight(String pattern, boolean caseSensitiveSearch)
	{
		JTextAreaUtils.highlight(this, pattern, caseSensitiveSearch);
	}
	
	public void attachCtrlMouseWheelZoom()
	{
		//get the existing scroll event
		MouseWheelListener ogListener = scrollPane.getMouseWheelListeners().length > 0 ?
				scrollPane.getMouseWheelListeners()[0] : null;
		
		//remove the existing event
		if(ogListener != null)
			scrollPane.removeMouseWheelListener(ogListener);
		
		//add a new event
		scrollPane.addMouseWheelListener(e ->
		{
			if (getText().isEmpty())
				return;
			
			if ((e.getModifiersEx() & InputEvent.CTRL_DOWN_MASK) != 0)
			{
				Font font = getFont();
				int size = font.getSize();
				
				if (e.getWheelRotation() > 0) //Up
					setFont(new Font(font.getName(), font.getStyle(), --size >= 2 ? --size : 2));
				else //Down
					setFont(new Font(font.getName(), font.getStyle(), ++size));
				
				e.consume();
			}
			else if(ogListener != null)
			{
				ogListener.mouseWheelMoved(e);
			}
		});
	}
	
	public String getLineText(int line) {
		try {
			if (line < getLineCount()) {
				int start = getLineStartOffset(line);
				int end = getLineEndOffset(line);
				return getText(start, end - start).trim();
			}
		} catch (BadLocationException ignored) { }
		return "";
	}
	
	public void setOnCtrlS(Runnable onCtrlS)
	{
		this.onCtrlS = onCtrlS;
	}
	
	public RTextScrollPane getScrollPane()
	{
		return scrollPane;
	}
	
	public JPanel getSearchPanel()
	{
		return searchPanel;
	}
	
	public JTextField getSearchInput()
	{
		return searchInput;
	}
	
	public JCheckBox getCaseSensitiveSearch()
	{
		return caseSensitiveSearch;
	}
	
	public JLabel getTitleHeader()
	{
		return titleHeader;
	}
	
	public Runnable getOnCtrlS()
	{
		return onCtrlS;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/SettingsDialog.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import java.awt.Component;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

import static the.bytecode.club.bytecodeviewer.Configuration.useNewSettingsDialog;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/19/2021
 */

public class SettingsDialog extends JScrollPane
{
	public static final List<JComponent> components = new ArrayList<>();
	public static final List<JDialog> dialogs = new ArrayList<>();
	private final List<JMenuItem> options = new ArrayList<>();
	private final JMenu menu;
	private final JPanel display;
	
	public SettingsDialog(JMenu menu, JPanel display)
	{
		super(display);
		
		this.menu = menu;
		this.display = display;
		
		if(!useNewSettingsDialog)
			return;
		
		List<JMenuItem> options = new ArrayList<>();
		for(Component child : menu.getMenuComponents())
		{
			if(!(child instanceof JMenuItem))
				continue;
			
			JMenuItem menuItem = (JMenuItem) child;
			
			options.add(menuItem);
			
			//force unselect after a selection has been made
			//this fixes a graphical bug from forcing menu items on non-menus
			menuItem.addActionListener(e -> unselectAll());
		}
		
		this.options.addAll(options);
		
		buildPanel();
		
		components.add(this);
	}
	
	public void unselectAll()
	{
		options.forEach(jMenuItem -> jMenuItem.setArmed(false));
	}
	
	public void showDialog()
	{
		ExtendedJOptionPane.showJPanelDialog(null, this, 460, dialogs::add);
	}
	
	private void buildPanel()
	{
		display.setLayout(new BoxLayout(display, BoxLayout.Y_AXIS));
		for(JMenuItem menuItem : options)
			display.add(menuItem);
	}
	
	@Override
	public String getName()
	{
		if(menu == null)
			return "ERROR: Dialog missing menu";
		
		return menu.getText();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/SystemConsole.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple console GUI.
 *
 * @author Konloch
 */

public class SystemConsole extends JFrameConsolePrintStream
{
    public SystemConsole(String title)
    {
        super(title);
    }
    
    private static final long serialVersionUID = -6666940545499937508L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/VisibleComponent.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import com.github.weisj.darklaf.icons.ThemedSVGIcon;
import javax.swing.BorderFactory;
import javax.swing.JInternalFrame;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.Workspace;
import the.bytecode.club.bytecodeviewer.gui.theme.LAFTheme;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Used to represent all the panes inside of Bytecode Viewer.
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/26/2011
 */

public abstract class VisibleComponent extends JInternalFrame
{
    public VisibleComponent(final String title)
    {
        super(title, false, false, false, false);
        this.setDefaultIcon();
    }

    @Override
    public void updateUI() {
        if (Configuration.lafTheme != LAFTheme.SYSTEM)
            setBorder(BorderFactory.createEmptyBorder());
        else
            setBorder(null);
        super.updateUI();
    }

    public void setDefaultIcon()
    {
        try {
            if(Configuration.showDarkLAFComponentIcons)
                setFrameIcon(new ThemedSVGIcon(Workspace.class.getResource("/com/github/weisj/darklaf/icons/frame/frame.svg").toURI(), 16, 16));
            else
                setFrameIcon(IconResources.jarIcon);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private static final long serialVersionUID = -6453413772343643526L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/WaitBusyIcon.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components;

import javax.swing.Icon;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/4/2021
 */
public class WaitBusyIcon extends JMenuItemIcon
{
	public WaitBusyIcon()
	{
		super(loadIcon());
		setAlignmentY(0.65f);
	}
	
	public static Icon loadIcon()
	{
		if(IconResources.busyIcon != null)
			return IconResources.busyIcon;
			
		return IconResources.busyB64Icon;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/listeners/MouseClickedListener.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components.listeners;

import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public class MouseClickedListener implements MouseListener
{
	private final MouseClickedEvent mouseClickedEvent;
	
	public MouseClickedListener(MouseClickedEvent mouseClickedEvent) {this.mouseClickedEvent = mouseClickedEvent;}
	
	@Override
	public void mouseClicked(MouseEvent e) {
		mouseClickedEvent.mouseClicked(e);
	}
	
	@Override
	public void mouseEntered(MouseEvent arg0) { }
	
	@Override
	public void mouseExited(MouseEvent arg0) { }
	
	@Override
	public void mousePressed(MouseEvent arg0) { }
	
	@Override
	public void mouseReleased(MouseEvent e) { }
	
	public interface MouseClickedEvent
	{
		void mouseClicked(MouseEvent e);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/listeners/PressKeyListener.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components.listeners;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public class PressKeyListener implements KeyListener
{
	private final KeyPressedEvent keyPressedEvent;
	
	public PressKeyListener(KeyPressedEvent keyPressedEvent) {this.keyPressedEvent = keyPressedEvent;}
	
	@Override
	public void keyTyped(KeyEvent e) { }
	
	@Override
	public void keyPressed(KeyEvent e)
	{
		keyPressedEvent.keyReleased(e);
	}
	
	@Override
	public void keyReleased(KeyEvent e) {}
	
	public interface KeyPressedEvent
	{
		void keyReleased(KeyEvent e);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/components/listeners/ReleaseKeyListener.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.components.listeners;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public class ReleaseKeyListener implements KeyListener
{
	private final KeyReleasedEvent keyReleasedEvent;
	
	public ReleaseKeyListener(KeyReleasedEvent keyReleasedEvent) {this.keyReleasedEvent = keyReleasedEvent;}
	
	@Override
	public void keyTyped(KeyEvent e) { }
	
	@Override
	public void keyPressed(KeyEvent e) { }
	
	@Override
	public void keyReleased(KeyEvent e)
	{
		keyReleasedEvent.keyReleased(e);
	}
	
	public interface KeyReleasedEvent
	{
		void keyReleased(KeyEvent e);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/BuildContextMenuItem.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu;

import javax.swing.JPopupMenu;
import javax.swing.tree.TreePath;
import the.bytecode.club.bytecodeviewer.gui.resourcelist.ResourceTree;
import the.bytecode.club.bytecodeviewer.searching.LDCSearchTreeNodeResult;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public interface BuildContextMenuItem
{
	void buildMenu(ResourceTree tree, TreePath selPath, LDCSearchTreeNodeResult result, JPopupMenu menu);
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/ContextMenu.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu;

import java.util.ArrayList;
import java.util.List;
import javax.swing.JPopupMenu;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist.Collapse;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist.Expand;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist.New;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist.Open;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist.QuickEdit;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist.QuickOpen;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist.Delete;
import the.bytecode.club.bytecodeviewer.gui.resourcelist.ResourceTree;
import the.bytecode.club.bytecodeviewer.searching.LDCSearchTreeNodeResult;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public class ContextMenu
{
	private static final ContextMenu SINGLETON = new ContextMenu();
	private final List<ContextMenuItem> contextMenuItems = new ArrayList<>();
	
	static
	{
		//resource list
		addContext(new Delete()); //TODO add support for resources & whole parent nodes (directories)
		addContext(new New());
		addContext(new Open());
		addContext(new QuickOpen());
		addContext(new QuickEdit());
		addContext(new Expand());
		addContext(new Collapse());
		
		//search box
		addContext(new the.bytecode.club.bytecodeviewer.gui.contextmenu.searchbox.Open());
		addContext(new the.bytecode.club.bytecodeviewer.gui.contextmenu.searchbox.QuickOpen());
		addContext(new the.bytecode.club.bytecodeviewer.gui.contextmenu.searchbox.QuickEdit());
	}
	
	public static void addContext(ContextMenuItem menuItem)
	{
		SINGLETON.contextMenuItems.add(menuItem);
	}
	
	public static void buildMenu(ResourceTree tree, TreePath selPath, LDCSearchTreeNodeResult selectedNode, JPopupMenu menu)
	{
		menu.removeAll();
		
		boolean searchBoxPane = selectedNode != null;
		boolean isContainerSelected = !searchBoxPane && selPath.getParentPath() != null && selPath.getParentPath().getParentPath() == null;
		boolean isResourceSelected = false;
		
		//TODO this is hacky - there is probably a better way to do this
		if(!searchBoxPane)
		{
			tree.setSelectionPath(selPath);
			DefaultMutableTreeNode node = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();
			isResourceSelected = !node.children().hasMoreElements();
		}
		
		for(ContextMenuItem item : SINGLETON.contextMenuItems)
		{
			switch(item.getMenuType())
			{
				case CONTAINER:
					if(!isContainerSelected)
						continue;
					break;
				case RESOURCE:
					if(!isResourceSelected || isContainerSelected)
						continue;
					break;
				case DIRECTORY:
					if(isResourceSelected || searchBoxPane)
						continue;
					break;
				case RESOURCE_LIST:
					if(searchBoxPane)
						continue;
					break;
				case SEARCH_BOX_RESULT:
					if(!searchBoxPane)
						continue;
					break;
			}
			
			item.getBuildContextMenuItem().buildMenu(tree, selPath, selectedNode, menu);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/ContextMenuItem.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public class ContextMenuItem
{
	private final ContextMenuType menuType;
	private final BuildContextMenuItem buildContextMenuItem;
	
	public ContextMenuItem(ContextMenuType menuType, BuildContextMenuItem buildContextMenuItem) {
		this.menuType = menuType;
		this.buildContextMenuItem = buildContextMenuItem;
	}
	
	public ContextMenuType getMenuType()
	{
		return menuType;
	}
	
	public BuildContextMenuItem getBuildContextMenuItem()
	{
		return buildContextMenuItem;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/ContextMenuType.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public enum ContextMenuType
{
	RESOURCE_LIST,
	RESOURCE,
	DIRECTORY,
	CONTAINER,
	SEARCH_BOX_RESULT,
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/resourcelist/Collapse.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist;

import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public class Collapse extends ContextMenuItem
{
	public Collapse()
	{
		super(ContextMenuType.DIRECTORY, ((tree, selPath, result, menu) ->
                menu.add(new AbstractAction(TranslatedStrings.COLLAPSE.toString())
                {
                    @Override
                    public void actionPerformed(ActionEvent e)
                    {
                        BytecodeViewer.viewer.resourcePane.expandAll(tree, selPath, false);
                    }
                })));
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/resourcelist/Delete.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist;

import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public class Delete extends ContextMenuItem
{
	public Delete()
	{
		super(ContextMenuType.CONTAINER, ((tree, selPath, result, menu) ->
                menu.add(new AbstractAction(TranslatedStrings.DELETE.toString())
                {
                    @Override
                    public void actionPerformed(ActionEvent e)
                    {
                        BytecodeViewer.viewer.resourcePane.removeNode(tree, selPath);
                    }
                })));
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/resourcelist/Expand.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist;

import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public class Expand extends ContextMenuItem
{
	public Expand()
	{
		super(ContextMenuType.DIRECTORY, ((tree, selPath, result, menu) ->
                menu.add(new AbstractAction(TranslatedStrings.EXPAND.toString())
                {
                    @Override
                    public void actionPerformed(ActionEvent e)
                    {
                        BytecodeViewer.viewer.resourcePane.expandAll(tree, selPath, true);
                    }
                })));
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/resourcelist/New.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist;

import java.util.Enumeration;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import org.apache.commons.io.FilenameUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.api.ASMUtil;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/27/2021
 */
public class New extends ContextMenuItem
{
	public New()
	{
		super(ContextMenuType.RESOURCE_LIST, ((tree, selPath, result, menu) ->
		{
			JMenu quickOpen = new JMenu(TranslatedStrings.NEW.toString());
			quickOpen.add(createMenu("Class", FileType.CLASS, selPath));
			
			//TODO
			// + directory isn't finished
			// + file has no purpose until the plugin writer code is added for newly created resources
			//   ^ this will allow users to edit the files they have created
			if(Constants.DEV_MODE)
			{
				quickOpen.add(createMenu("File", FileType.FILE, selPath));
				quickOpen.add(createMenu("Directory", FileType.DIRECTORY, selPath));
			}
			menu.add(quickOpen);
		}));
	}
	
	private static JMenuItem createMenu(String name, FileType fileType, TreePath selPath)
	{
		JMenuItem menu = new JMenuItem(name);
		
		String separator = fileType == FileType.CLASS ? "." : "/";
		String firstPath = buildPath(0, 2, selPath, "/");
		String path = buildPath(2, selPath.getPathCount(), selPath, separator);
		String containerName = selPath.getPathComponent(1).toString();
		
		menu.addActionListener((e)->{
			String newPath = BytecodeViewer.showInput("Name",
					fileType == FileType.CLASS ? "Enter the class name" : "Enter the file name",
					FilenameUtils.removeExtension(path));
			
			if(newPath == null || newPath.isEmpty())
				return;
			
			byte[] contents = new byte[0];

			switch(fileType)
			{
				case CLASS:
					ClassNode cn = new ClassNode();
					
					//TODO this should be a dialog
					cn.version = 52;
					
					//TODO santize newPath and remove extension if added
					cn.name = newPath;
					String oldResourcePath = newPath.replace(".", "/");
					String newResourcePath = oldResourcePath + ".class";
					
					contents = ASMUtil.nodeToBytes(cn);
					
					BytecodeViewer.resourceContainers.get(containerName).resourceClasses.put(oldResourcePath, cn);
					BytecodeViewer.resourceContainers.get(containerName).resourceClassBytes.put(newResourcePath, contents);
					searchAndInsert(firstPath + "/" + newResourcePath, BytecodeViewer.resourceContainers.get(containerName).treeNode, "/");
					
					break;
				case FILE:
					BytecodeViewer.resourceContainers.get(containerName).resourceFiles.put(newPath, contents);
					searchAndInsert(firstPath + separator +newPath, BytecodeViewer.resourceContainers.get(containerName).treeNode, separator);
					break;
			}
			
			BytecodeViewer.viewer.resourcePane.tree.updateUI();
		});
		
		return menu;
	}
	
	public static String buildPath(int startsAt, int max, TreePath selPath, String separator)
	{
		StringBuilder tempSpot = new StringBuilder();
		
		for(int counter = startsAt; counter < max; counter++)
		{
			if(counter > startsAt)
				tempSpot.append(separator);
			tempSpot.append(selPath.getPathComponent(counter));
		}
		
		return tempSpot.toString();
	}
	
	public static String buildPath(int startsAt, int max, DefaultMutableTreeNode treeNode, String separator)
	{
		StringBuilder tempSpot = new StringBuilder();
		
		for(int counter = startsAt; counter < max; counter++)
		{
			if(counter > startsAt)
				tempSpot.append(separator);
			tempSpot.append(treeNode.getPath()[counter]);
		}
		
		return tempSpot.toString();
	}
	
	//TODO this needs to be rewritten to support creating parent nodes that don't exist
	@SuppressWarnings("unchecked")
	public static boolean searchAndInsert(String path, DefaultMutableTreeNode treeNode, String separator)
	{
		Enumeration<TreeNode> children = treeNode.children();
		
		String findPath = FilenameUtils.getPath(path);
		String currentPath = buildPath(0, treeNode.getPath().length, treeNode, separator);
		String directory = FilenameUtils.getPath(currentPath);
		
		if(currentPath.startsWith(findPath))
		{
			//TODO this can be written without the need for .getParent
			((DefaultMutableTreeNode)treeNode.getParent()).add(new DefaultMutableTreeNode(FilenameUtils.getName(path)));
			return true;
		}
		
		while(children.hasMoreElements())
		{
			DefaultMutableTreeNode child = (DefaultMutableTreeNode) children.nextElement();
			if(searchAndInsert(path, child, separator))
				return true;
		}
		
		return false;
	}
	
	public enum FileType
	{
		CLASS,
		FILE,
		DIRECTORY,
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/resourcelist/Open.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist;

import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public class Open extends ContextMenuItem
{
	public Open()
	{
		super(ContextMenuType.RESOURCE, ((tree, selPath, result, menu) ->
                menu.add(new AbstractAction(TranslatedStrings.OPEN_UNSTYLED.toString())
                {
                    @Override
                    public void actionPerformed(ActionEvent e)
                    {
                        BytecodeViewer.viewer.resourcePane.openPath(selPath);
                    }
                })));
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/resourcelist/QuickEdit.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist;

import javax.swing.JMenu;
import javax.swing.JMenuItem;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/27/2021
 */
public class QuickEdit extends ContextMenuItem
{
	public QuickEdit()
	{
		super(ContextMenuType.RESOURCE, ((tree, selPath, result, menu) ->
		{
			JMenu quickOpen = new JMenu("Quick Edit");
			quickOpen.add(createMenu(TranslatedStrings.KRAKATAU.toString(), ()->
					BytecodeViewer.viewer.resourcePane.quickDecompile(Decompiler.KRAKATAU_DISASSEMBLER, selPath, true)));
			menu.add(quickOpen);
		}));
	}
	
	private static JMenuItem createMenu(String name, Runnable onClick)
	{
		JMenuItem menu = new JMenuItem(name);
		menu.addActionListener((e)->onClick.run());
		return menu;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/resourcelist/QuickOpen.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.resourcelist;

import javax.swing.JMenu;
import javax.swing.JMenuItem;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public class QuickOpen extends ContextMenuItem
{
	public QuickOpen()
	{
		super(ContextMenuType.RESOURCE, ((tree, selPath, result, menu) ->
		{
			JMenu quickOpen = new JMenu(TranslatedStrings.QUICK_OPEN.toString());
			quickOpen.add(createMenu(TranslatedStrings.PROCYON.toString(), ()->BytecodeViewer.viewer.resourcePane.quickDecompile(Decompiler.PROCYON_DECOMPILER, selPath, false)));
			quickOpen.add(createMenu(TranslatedStrings.CFR.toString(), ()->BytecodeViewer.viewer.resourcePane.quickDecompile(Decompiler.CFR_DECOMPILER, selPath, false)));
			quickOpen.add(createMenu(TranslatedStrings.FERNFLOWER.toString(), ()->BytecodeViewer.viewer.resourcePane.quickDecompile(Decompiler.FERNFLOWER_DECOMPILER, selPath, false)));
			quickOpen.add(createMenu(TranslatedStrings.KRAKATAU.toString(), ()->BytecodeViewer.viewer.resourcePane.quickDecompile(Decompiler.KRAKATAU_DECOMPILER, selPath, false)));
			quickOpen.add(createMenu(TranslatedStrings.BYTECODE.toString(), ()->BytecodeViewer.viewer.resourcePane.quickDecompile(Decompiler.BYTECODE_DISASSEMBLER, selPath, false)));
			menu.add(quickOpen);
		}));
	}
	
	private static JMenuItem createMenu(String name, Runnable onClick)
	{
		JMenuItem menu = new JMenuItem(name);
		menu.addActionListener((e)->onClick.run());
		return menu;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/searchbox/Open.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.searchbox;

import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/29/2021
 */
public class Open extends ContextMenuItem
{
	public Open()
	{
		super(ContextMenuType.SEARCH_BOX_RESULT, ((tree, selPath, result, menu) ->
                menu.add(new AbstractAction(TranslatedStrings.OPEN_UNSTYLED.toString())
                {
                    @Override
                    public void actionPerformed(ActionEvent e)
                    {
                        BytecodeViewer.viewer.workPane.addClassResource(result.container, result.resourceWorkingName);
                    }
                })));
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/searchbox/QuickEdit.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.searchbox;

import javax.swing.JMenu;
import javax.swing.JMenuItem;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/27/2021
 */
public class QuickEdit extends ContextMenuItem
{
	public QuickEdit()
	{
		super(ContextMenuType.SEARCH_BOX_RESULT, ((tree, selPath, result, menu) ->
		{
			JMenu quickOpen = new JMenu("Quick Edit");
			quickOpen.add(createMenu(TranslatedStrings.KRAKATAU.toString(), ()->
					BytecodeViewer.viewer.searchBoxPane.quickDecompile(Decompiler.KRAKATAU_DISASSEMBLER, result, true)));
			menu.add(quickOpen);
		}));
	}
	
	private static JMenuItem createMenu(String name, Runnable onClick)
	{
		JMenuItem menu = new JMenuItem(name);
		menu.addActionListener((e)->onClick.run());
		return menu;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/contextmenu/searchbox/QuickOpen.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.contextmenu.searchbox;

import javax.swing.JMenu;
import javax.swing.JMenuItem;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuItem;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenuType;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/26/2021
 */
public class QuickOpen extends ContextMenuItem
{
	public QuickOpen()
	{
		super(ContextMenuType.SEARCH_BOX_RESULT, ((tree, selPath, result, menu) ->
		{
			JMenu quickOpen = new JMenu(TranslatedStrings.QUICK_OPEN.toString());
			quickOpen.add(createMenu(TranslatedStrings.PROCYON.toString(), ()->BytecodeViewer.viewer.searchBoxPane.quickDecompile(Decompiler.PROCYON_DECOMPILER, result, false)));
			quickOpen.add(createMenu(TranslatedStrings.CFR.toString(), ()->BytecodeViewer.viewer.searchBoxPane.quickDecompile(Decompiler.CFR_DECOMPILER, result, false)));
			quickOpen.add(createMenu(TranslatedStrings.FERNFLOWER.toString(), ()->BytecodeViewer.viewer.searchBoxPane.quickDecompile(Decompiler.FERNFLOWER_DECOMPILER, result, false)));
			quickOpen.add(createMenu(TranslatedStrings.KRAKATAU.toString(), ()->BytecodeViewer.viewer.searchBoxPane.quickDecompile(Decompiler.KRAKATAU_DECOMPILER, result, false)));
			quickOpen.add(createMenu(TranslatedStrings.BYTECODE.toString(), ()->BytecodeViewer.viewer.searchBoxPane.quickDecompile(Decompiler.BYTECODE_DISASSEMBLER, result, false)));
			menu.add(quickOpen);
		}));
	}
	
	private static JMenuItem createMenu(String name, Runnable onClick)
	{
		JMenuItem menu = new JMenuItem(name);
		menu.addActionListener((e)->onClick.run());
		return menu;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/BaseSwitchableSpinnerPanel.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.text.ParseException;
import java.util.Arrays;
import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.JTextField;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.JTextComponent;
import org.exbin.bined.CodeAreaUtils;
import org.exbin.bined.CodeCharactersCase;
import org.exbin.bined.PositionCodeType;

/**
 * Spinner supporting multiple bases.
 */
@ParametersAreNonnullByDefault
public class BaseSwitchableSpinnerPanel extends javax.swing.JPanel {

    private boolean adjusting;
    private final PositionSpinnerEditor spinnerEditor;
    private static final String SPINNER_PROPERTY = "value";

    public BaseSwitchableSpinnerPanel() {
        initComponents();
        spinnerEditor = new PositionSpinnerEditor(spinner);
        spinner.setEditor(spinnerEditor);
        init();
    }

    private void init() {
        // Spinner selection workaround from http://forums.sun.com/thread.jspa?threadID=409748&forumID=57
        spinnerEditor.getTextField().addFocusListener(new FocusAdapter() {
            @Override
            public void focusGained(FocusEvent e) {
                if (e.getSource() instanceof JTextComponent) {
                    final JTextComponent textComponent = ((JTextComponent) e.getSource());
                    SwingUtilities.invokeLater(textComponent::selectAll);
                }
            }
        });

        Dimension preferredSize = baseSwitchButton.getPreferredSize();
        setPreferredSize(new Dimension(preferredSize.width * 4, preferredSize.height));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        baseSwitchPopupMenu = new javax.swing.JPopupMenu();
        octalMenuItem = new javax.swing.JMenuItem();
        decimalMenuItem = new javax.swing.JMenuItem();
        hexadecimalMenuItem = new javax.swing.JMenuItem();
        baseSwitchButton = new javax.swing.JButton();
        spinner = new javax.swing.JSpinner();

        octalMenuItem.setText("OCT");
        octalMenuItem.setToolTipText("Octal");
        octalMenuItem.addActionListener(this::octalMenuItemActionPerformed);
        baseSwitchPopupMenu.add(octalMenuItem);

        decimalMenuItem.setText("DEC");
        decimalMenuItem.setToolTipText("Decimal");
        decimalMenuItem.addActionListener(this::decimalMenuItemActionPerformed);
        baseSwitchPopupMenu.add(decimalMenuItem);

        hexadecimalMenuItem.setText("HEX");
        hexadecimalMenuItem.setToolTipText("Hexadecimal");
        hexadecimalMenuItem.addActionListener(this::hexadecimalMenuItemActionPerformed);
        baseSwitchPopupMenu.add(hexadecimalMenuItem);

        setPreferredSize(new java.awt.Dimension(400, 300));

        baseSwitchButton.setText("DEC");
        baseSwitchButton.setToolTipText("Decimal");
        baseSwitchButton.setComponentPopupMenu(baseSwitchPopupMenu);
        baseSwitchButton.addActionListener(this::baseSwitchButtonActionPerformed);

        spinner.setModel(new javax.swing.SpinnerNumberModel(0L, null, null, 1L));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(baseSwitchButton, javax.swing.GroupLayout.PREFERRED_SIZE, 65, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(spinner, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(spinner)
            .addComponent(baseSwitchButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void baseSwitchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_baseSwitchButtonActionPerformed
        PositionCodeType positionCodeType = spinnerEditor.getPositionCodeType();
        switch (positionCodeType) {
            case OCTAL: {
                switchNumBase(PositionCodeType.DECIMAL);
                break;
            }
            case DECIMAL: {
                switchNumBase(PositionCodeType.HEXADECIMAL);
                break;
            }
            case HEXADECIMAL: {
                switchNumBase(PositionCodeType.OCTAL);
                break;
            }
            default:
                throw CodeAreaUtils.getInvalidTypeException(positionCodeType);
        }
    }//GEN-LAST:event_baseSwitchButtonActionPerformed

    private void octalMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_octalMenuItemActionPerformed
        switchNumBase(PositionCodeType.OCTAL);
    }//GEN-LAST:event_octalMenuItemActionPerformed

    private void decimalMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_decimalMenuItemActionPerformed
        switchNumBase(PositionCodeType.DECIMAL);
    }//GEN-LAST:event_decimalMenuItemActionPerformed

    private void hexadecimalMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_hexadecimalMenuItemActionPerformed
        switchNumBase(PositionCodeType.HEXADECIMAL);
    }//GEN-LAST:event_hexadecimalMenuItemActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton baseSwitchButton;
    private javax.swing.JPopupMenu baseSwitchPopupMenu;
    private javax.swing.JMenuItem decimalMenuItem;
    private javax.swing.JMenuItem hexadecimalMenuItem;
    private javax.swing.JMenuItem octalMenuItem;
    private javax.swing.JSpinner spinner;
    // End of variables declaration//GEN-END:variables

    private void switchNumBase(PositionCodeType codeType) {
        adjusting = true;
        long value = getValue();
        int position = codeType.ordinal();
        baseSwitchButton.setText(codeType.name().substring(0, 3));
        baseSwitchButton.setToolTipText(((JMenuItem) baseSwitchPopupMenu.getComponent(position)).getToolTipText());
        spinnerEditor.setPositionCodeType(codeType);
        setValue(value);
        adjusting = false;
    }

    public long getValue() {
        return (Long) spinner.getValue();
    }

    public void setValue(long value) {
        spinnerEditor.setPositionValue(value);
    }

    public void acceptInput() {
        try {
            spinner.commitEdit();
        } catch (ParseException ex) {
            // Ignore parse exception
        }
    }

    public void initFocus() {
        /* ((JSpinner.DefaultEditor) positionSpinner.getEditor()) */
        spinnerEditor.getTextField().requestFocusInWindow();
    }

    public void setMinimum(long minimum) {
        ((SpinnerNumberModel) spinner.getModel()).setMinimum(minimum);
    }

    public void setMaximum(long maximum) {
        ((SpinnerNumberModel) spinner.getModel()).setMaximum(maximum);
    }

    public void revalidateSpinner() {
        spinner.revalidate();
    }

    public void addChangeListener(ChangeListener changeListener) {
        spinner.addChangeListener(changeListener);
    }

    public void removeChangeListener(ChangeListener changeListener) {
        spinner.removeChangeListener(changeListener);
    }

    @ParametersAreNonnullByDefault
    private class PositionSpinnerEditor extends JPanel implements ChangeListener, PropertyChangeListener, LayoutManager {

        private static final int LENGTH_LIMIT = 21;

        private PositionCodeType positionCodeType = PositionCodeType.DECIMAL;

        private final char[] cache = new char[LENGTH_LIMIT];

        private final JTextField textField;
        private final JSpinner spinner;

        public PositionSpinnerEditor(JSpinner spinner) {
            this.spinner = spinner;
            textField = new JTextField();

            init();
        }

        private void init() {
            textField.setName("Spinner.textField");
            textField.setText(getPositionAsString((Long) spinner.getValue()));
            textField.addPropertyChangeListener(this);
            textField.getDocument().addDocumentListener(new DocumentListener() {
                private final PropertyChangeEvent changeEvent = new PropertyChangeEvent(textField, SPINNER_PROPERTY, null, null);

                @Override
                public void changedUpdate(DocumentEvent e) {
                    notifyChanged();
                }

                @Override
                public void removeUpdate(DocumentEvent e) {
                    notifyChanged();
                }

                @Override
                public void insertUpdate(DocumentEvent e) {
                    notifyChanged();
                }

                public void notifyChanged() {
                    propertyChange(changeEvent);
                }
            });
            textField.setEditable(true);
            textField.setInheritsPopupMenu(true);

            String toolTipText = spinner.getToolTipText();
            if (toolTipText != null) {
                textField.setToolTipText(toolTipText);
            }

            add(textField);

            setLayout(this);
            spinner.addChangeListener(this);
        }

        @Nonnull
        private JTextField getTextField() {
            return textField;
        }

        @Nonnull
        private JSpinner getSpinner() {
            return spinner;
        }

        @Override
        public void stateChanged(ChangeEvent e) {
            if (adjusting) {
                return;
            }

            JSpinner sourceSpinner = (JSpinner) (e.getSource());
            SwingUtilities.invokeLater(() -> textField.setText(getPositionAsString((Long) sourceSpinner.getValue())));
        }

        @Override
        public void propertyChange(PropertyChangeEvent e) {
            if (adjusting) {
                return;
            }

            JSpinner sourceSpinner = getSpinner();

            Object source = e.getSource();
            String name = e.getPropertyName();
            if ((source instanceof JTextField) && SPINNER_PROPERTY.equals(name)) {
                Long lastValue = (Long) sourceSpinner.getValue();

                // Try to set the new value
                try {
                    sourceSpinner.setValue(valueOfPosition(getTextField().getText()));
                } catch (IllegalArgumentException iae) {
                    // SpinnerModel didn't like new value, reset
                    try {
                        sourceSpinner.setValue(lastValue);
                    } catch (IllegalArgumentException iae2) {
                        // Still bogus, nothing else we can do, the
                        // SpinnerModel and JFormattedTextField are now out
                        // of sync.
                    }
                }
            }
        }

        public void setPositionValue(long positionValue) {
            textField.setText(getPositionAsString(positionValue));
            spinner.setValue(positionValue);
        }

        @Override
        public void addLayoutComponent(String name, Component comp) {
        }

        @Override
        public void removeLayoutComponent(Component comp) {
        }

        /**
         * Returns the size of the parents insets.
         */
        @Nonnull
        private Dimension insetSize(Container parent) {
            Insets insets = parent.getInsets();
            int width = insets.left + insets.right;
            int height = insets.top + insets.bottom;
            return new Dimension(width, height);
        }

        @Nonnull
        @Override
        public Dimension preferredLayoutSize(Container parent) {
            Dimension preferredSize = insetSize(parent);
            if (parent.getComponentCount() > 0) {
                Dimension childSize = getComponent(0).getPreferredSize();
                preferredSize.width += childSize.width;
                preferredSize.height += childSize.height;
            }
            return preferredSize;
        }

        @Nonnull
        @Override
        public Dimension minimumLayoutSize(Container parent) {
            Dimension minimumSize = insetSize(parent);
            if (parent.getComponentCount() > 0) {
                Dimension childSize = getComponent(0).getMinimumSize();
                minimumSize.width += childSize.width;
                minimumSize.height += childSize.height;
            }
            return minimumSize;
        }

        @Override
        public void layoutContainer(Container parent) {
            if (parent.getComponentCount() > 0) {
                Insets insets = parent.getInsets();
                int width = parent.getWidth() - (insets.left + insets.right);
                int height = parent.getHeight() - (insets.top + insets.bottom);
                getComponent(0).setBounds(insets.left, insets.top, width, height);
            }
        }

        @Nonnull
        public PositionCodeType getPositionCodeType() {
            return positionCodeType;
        }

        public void setPositionCodeType(PositionCodeType positionCodeType) {
            this.positionCodeType = positionCodeType;
        }

        @Nonnull
        private String getPositionAsString(long position) {
            if (position < 0) {
                return "-" + getNonNegativePostionAsString(-position);
            }
            return getNonNegativePostionAsString(position);
        }

        @Nonnull
        private String getNonNegativePostionAsString(long position) {
            Arrays.fill(cache, ' ');
            CodeAreaUtils.longToBaseCode(cache, 0, position, positionCodeType.getBase(), LENGTH_LIMIT, false, CodeCharactersCase.LOWER);
            return new String(cache).trim();
        }

        private long valueOfPosition(String position) {
            return Long.parseLong(position, positionCodeType.getBase());
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/BinaryStatusApi.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

import javax.annotation.ParametersAreNonnullByDefault;
import org.exbin.bined.CodeAreaCaretPosition;
import org.exbin.bined.EditMode;
import org.exbin.bined.EditOperation;
import org.exbin.bined.SelectionRange;

/**
 * Binary editor status interface.
 *
 * @author hajdam
 */
@ParametersAreNonnullByDefault
public interface BinaryStatusApi {

    /**
     * Reports cursor position.
     *
     * @param cursorPosition cursor position
     */
    void setCursorPosition(CodeAreaCaretPosition cursorPosition);

    /**
     * Sets current selection.
     *
     * @param selectionRange current selection
     */
    void setSelectionRange(SelectionRange selectionRange);

    /**
     * Reports currently active edit mode.
     *
     * @param mode edit mode
     * @param operation edit operation
     */
    void setEditMode(EditMode mode, EditOperation operation);

    /**
     * Sets current document size.
     *
     * @param documentSize document size
     * @param initialDocumentSize document size when file was opened
     */
    void setCurrentDocumentSize(long documentSize, long initialDocumentSize);
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/BinaryStatusPanel.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseEvent;
import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.swing.JToolTip;
import org.exbin.bined.CodeAreaCaretPosition;
import org.exbin.bined.CodeAreaUtils;
import org.exbin.bined.EditMode;
import org.exbin.bined.EditOperation;
import org.exbin.bined.PositionCodeType;
import org.exbin.bined.SelectionRange;

/**
 * Binary editor status panel.
 *
 * @author hajdam
 */
@ParametersAreNonnullByDefault
public class BinaryStatusPanel extends javax.swing.JPanel implements BinaryStatusApi {

    public static int DEFAULT_OCTAL_SPACE_GROUP_SIZE = 4;
    public static int DEFAULT_DECIMAL_SPACE_GROUP_SIZE = 3;
    public static int DEFAULT_HEXADECIMAL_SPACE_GROUP_SIZE = 4;

    public static final String INSERT_EDIT_MODE_LABEL = "INS";
    public static final String OVERWRITE_EDIT_MODE_LABEL = "OVR";
    public static final String READONLY_EDIT_MODE_LABEL = "RO";
    public static final String INPLACE_EDIT_MODE_LABEL = "INP";

    public static final String OCTAL_CODE_TYPE_LABEL = "OCT";
    public static final String DECIMAL_CODE_TYPE_LABEL = "DEC";
    public static final String HEXADECIMAL_CODE_TYPE_LABEL = "HEX";

    private final StatusCursorPositionFormat cursorPositionFormat = new StatusCursorPositionFormat();
    private final StatusDocumentSizeFormat documentSizeFormat = new StatusDocumentSizeFormat();
    private final int octalSpaceGroupSize = DEFAULT_OCTAL_SPACE_GROUP_SIZE;
    private final int decimalSpaceGroupSize = DEFAULT_DECIMAL_SPACE_GROUP_SIZE;
    private final int hexadecimalSpaceGroupSize = DEFAULT_HEXADECIMAL_SPACE_GROUP_SIZE;

    private EditOperation editOperation;
    private CodeAreaCaretPosition caretPosition;
    private SelectionRange selectionRange;
    private long documentSize;
    private long initialDocumentSize;

    private javax.swing.JMenu cursorPositionCodeTypeMenu;
    private javax.swing.JLabel cursorPositionLabel;
    private javax.swing.ButtonGroup cursorPositionModeButtonGroup;
    private javax.swing.JCheckBoxMenuItem cursorPositionShowOffsetCheckBoxMenuItem;
    private javax.swing.JRadioButtonMenuItem decimalCursorPositionModeRadioButtonMenuItem;
    private javax.swing.JRadioButtonMenuItem decimalDocumentSizeModeRadioButtonMenuItem;
    private javax.swing.JMenu documentSizeCodeTypeMenu;
    private javax.swing.JMenuItem documentSizeCopyMenuItem;
    private javax.swing.JLabel documentSizeLabel;
    private javax.swing.ButtonGroup documentSizeModeButtonGroup;
    private javax.swing.JPopupMenu documentSizePopupMenu;
    private javax.swing.JCheckBoxMenuItem documentSizeShowRelativeCheckBoxMenuItem;
    private javax.swing.JLabel editModeLabel;
    private javax.swing.JLabel encodingLabel;
    private javax.swing.JRadioButtonMenuItem hexadecimalCursorPositionModeRadioButtonMenuItem;
    private javax.swing.JRadioButtonMenuItem hexadecimalDocumentSizeModeRadioButtonMenuItem;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    private javax.swing.JRadioButtonMenuItem octalCursorPositionModeRadioButtonMenuItem;
    private javax.swing.JRadioButtonMenuItem octalDocumentSizeModeRadioButtonMenuItem;
    private javax.swing.JMenuItem positionCopyMenuItem;
    private javax.swing.JMenuItem positionGoToMenuItem;
    private javax.swing.JPopupMenu positionPopupMenu;

    public BinaryStatusPanel() {
        initComponents();
    }

    public void updateStatus() {
        updateCaretPosition();
        updateCursorPositionToolTip();
        updateDocumentSize();
        updateDocumentSizeToolTip();

        switch (cursorPositionFormat.getCodeType()) {
            case OCTAL: {
                octalCursorPositionModeRadioButtonMenuItem.setSelected(true);
                break;
            }
            case DECIMAL: {
                decimalCursorPositionModeRadioButtonMenuItem.setSelected(true);
                break;
            }
            case HEXADECIMAL: {
                hexadecimalCursorPositionModeRadioButtonMenuItem.setSelected(true);
                break;
            }
            default:
                throw CodeAreaUtils.getInvalidTypeException(cursorPositionFormat.getCodeType());
        }
        cursorPositionShowOffsetCheckBoxMenuItem.setSelected(cursorPositionFormat.isShowOffset());

        switch (documentSizeFormat.getCodeType()) {
            case OCTAL: {
                octalDocumentSizeModeRadioButtonMenuItem.setSelected(true);
                break;
            }
            case DECIMAL: {
                decimalDocumentSizeModeRadioButtonMenuItem.setSelected(true);
                break;
            }
            case HEXADECIMAL: {
                hexadecimalDocumentSizeModeRadioButtonMenuItem.setSelected(true);
                break;
            }
            default:
                throw CodeAreaUtils.getInvalidTypeException(documentSizeFormat.getCodeType());
        }
        documentSizeShowRelativeCheckBoxMenuItem.setSelected(documentSizeFormat.isShowRelative());
    }

    private void initComponents() {

        positionPopupMenu = new javax.swing.JPopupMenu();
        cursorPositionCodeTypeMenu = new javax.swing.JMenu();
        octalCursorPositionModeRadioButtonMenuItem = new javax.swing.JRadioButtonMenuItem();
        decimalCursorPositionModeRadioButtonMenuItem = new javax.swing.JRadioButtonMenuItem();
        hexadecimalCursorPositionModeRadioButtonMenuItem = new javax.swing.JRadioButtonMenuItem();
        cursorPositionShowOffsetCheckBoxMenuItem = new javax.swing.JCheckBoxMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        positionCopyMenuItem = new javax.swing.JMenuItem();
        positionGoToMenuItem = new javax.swing.JMenuItem();
        documentSizePopupMenu = new javax.swing.JPopupMenu();
        documentSizeCodeTypeMenu = new javax.swing.JMenu();
        octalDocumentSizeModeRadioButtonMenuItem = new javax.swing.JRadioButtonMenuItem();
        decimalDocumentSizeModeRadioButtonMenuItem = new javax.swing.JRadioButtonMenuItem();
        hexadecimalDocumentSizeModeRadioButtonMenuItem = new javax.swing.JRadioButtonMenuItem();
        documentSizeShowRelativeCheckBoxMenuItem = new javax.swing.JCheckBoxMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        documentSizeCopyMenuItem = new javax.swing.JMenuItem();
        documentSizeModeButtonGroup = new javax.swing.ButtonGroup();
        cursorPositionModeButtonGroup = new javax.swing.ButtonGroup();
        documentSizeLabel = new javax.swing.JLabel() {
            @Override
            public JToolTip createToolTip() {
                updateDocumentSizeToolTip();
                return super.createToolTip();
            }
        };
        cursorPositionLabel = new javax.swing.JLabel() {
            @Override
            public JToolTip createToolTip() {
                updateCursorPositionToolTip();
                return super.createToolTip();
            }
        };
        editModeLabel = new javax.swing.JLabel();
        encodingLabel = new javax.swing.JLabel();

        positionPopupMenu.setName("positionPopupMenu");

        cursorPositionCodeTypeMenu.setText("Code Type");
        cursorPositionCodeTypeMenu.setName("cursorPositionCodeTypeMenu");

        cursorPositionModeButtonGroup.add(octalCursorPositionModeRadioButtonMenuItem);
        octalCursorPositionModeRadioButtonMenuItem.setText("Show as octal");
        octalCursorPositionModeRadioButtonMenuItem.setName("octalCursorPositionModeRadioButtonMenuItem");
        octalCursorPositionModeRadioButtonMenuItem.addActionListener(this::octalCursorPositionModeRadioButtonMenuItemActionPerformed);
        cursorPositionCodeTypeMenu.add(octalCursorPositionModeRadioButtonMenuItem);

        cursorPositionModeButtonGroup.add(decimalCursorPositionModeRadioButtonMenuItem);
        decimalCursorPositionModeRadioButtonMenuItem.setSelected(true);
        decimalCursorPositionModeRadioButtonMenuItem.setText("Show as decimal");
        decimalCursorPositionModeRadioButtonMenuItem.setName("decimalCursorPositionModeRadioButtonMenuItem");
        decimalCursorPositionModeRadioButtonMenuItem.addActionListener(this::decimalCursorPositionModeRadioButtonMenuItemActionPerformed);
        cursorPositionCodeTypeMenu.add(decimalCursorPositionModeRadioButtonMenuItem);

        cursorPositionModeButtonGroup.add(hexadecimalCursorPositionModeRadioButtonMenuItem);
        hexadecimalCursorPositionModeRadioButtonMenuItem.setText("Show as hexadecimal");
        hexadecimalCursorPositionModeRadioButtonMenuItem.setName("hexadecimalCursorPositionModeRadioButtonMenuItem");
        hexadecimalCursorPositionModeRadioButtonMenuItem.addActionListener(this::hexadecimalCursorPositionModeRadioButtonMenuItemActionPerformed);
        cursorPositionCodeTypeMenu.add(hexadecimalCursorPositionModeRadioButtonMenuItem);

        positionPopupMenu.add(cursorPositionCodeTypeMenu);

        cursorPositionShowOffsetCheckBoxMenuItem.setSelected(true);
        cursorPositionShowOffsetCheckBoxMenuItem.setText("Show offset");
        cursorPositionShowOffsetCheckBoxMenuItem.setName("cursorPositionShowOffsetCheckBoxMenuItem");
        cursorPositionShowOffsetCheckBoxMenuItem.addActionListener(this::cursorPositionShowOffsetCheckBoxMenuItemActionPerformed);
        positionPopupMenu.add(cursorPositionShowOffsetCheckBoxMenuItem);

        jSeparator2.setName("jSeparator2");
        positionPopupMenu.add(jSeparator2);

        positionCopyMenuItem.setText("Copy");
        positionCopyMenuItem.setName("positionCopyMenuItem");
        positionCopyMenuItem.addActionListener(this::positionCopyMenuItemActionPerformed);
        positionPopupMenu.add(positionCopyMenuItem);

        positionGoToMenuItem.setText("Go To...");
        positionGoToMenuItem.setEnabled(false);
        positionGoToMenuItem.setName("positionGoToMenuItem");
        positionGoToMenuItem.addActionListener(this::positionGoToMenuItemActionPerformed);
        positionPopupMenu.add(positionGoToMenuItem);

        documentSizePopupMenu.setName("documentSizePopupMenu");

        documentSizeCodeTypeMenu.setText("Code Type");
        documentSizeCodeTypeMenu.setName("documentSizeCodeTypeMenu");

        documentSizeModeButtonGroup.add(octalDocumentSizeModeRadioButtonMenuItem);
        octalDocumentSizeModeRadioButtonMenuItem.setText("Show as octal");
        octalDocumentSizeModeRadioButtonMenuItem.setName("octalDocumentSizeModeRadioButtonMenuItem");
        octalDocumentSizeModeRadioButtonMenuItem.addActionListener(this::octalDocumentSizeModeRadioButtonMenuItemActionPerformed);
        documentSizeCodeTypeMenu.add(octalDocumentSizeModeRadioButtonMenuItem);

        documentSizeModeButtonGroup.add(decimalDocumentSizeModeRadioButtonMenuItem);
        decimalDocumentSizeModeRadioButtonMenuItem.setText("Show as decimal");
        decimalDocumentSizeModeRadioButtonMenuItem.setName("decimalDocumentSizeModeRadioButtonMenuItem");
        decimalDocumentSizeModeRadioButtonMenuItem.addActionListener(this::decimalDocumentSizeModeRadioButtonMenuItemActionPerformed);
        documentSizeCodeTypeMenu.add(decimalDocumentSizeModeRadioButtonMenuItem);

        documentSizeModeButtonGroup.add(hexadecimalDocumentSizeModeRadioButtonMenuItem);
        hexadecimalDocumentSizeModeRadioButtonMenuItem.setText("Show as hexadecimal");
        hexadecimalDocumentSizeModeRadioButtonMenuItem.setName("hexadecimalDocumentSizeModeRadioButtonMenuItem");
        hexadecimalDocumentSizeModeRadioButtonMenuItem.addActionListener(this::hexadecimalDocumentSizeModeRadioButtonMenuItemActionPerformed);
        documentSizeCodeTypeMenu.add(hexadecimalDocumentSizeModeRadioButtonMenuItem);

        documentSizePopupMenu.add(documentSizeCodeTypeMenu);

        documentSizeShowRelativeCheckBoxMenuItem.setSelected(true);
        documentSizeShowRelativeCheckBoxMenuItem.setText("Show relative size");
        documentSizeShowRelativeCheckBoxMenuItem.setName("documentSizeShowRelativeCheckBoxMenuItem");
        documentSizeShowRelativeCheckBoxMenuItem.addActionListener(this::documentSizeShowRelativeCheckBoxMenuItemActionPerformed);
        documentSizePopupMenu.add(documentSizeShowRelativeCheckBoxMenuItem);

        jSeparator1.setName("jSeparator1");
        documentSizePopupMenu.add(jSeparator1);

        documentSizeCopyMenuItem.setText("Copy");
        documentSizeCopyMenuItem.setName("documentSizeCopyMenuItem");
        documentSizeCopyMenuItem.addActionListener(this::documentSizeCopyMenuItemActionPerformed);
        documentSizePopupMenu.add(documentSizeCopyMenuItem);

        setName("Form");

        documentSizeLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        documentSizeLabel.setText("0 (0)");
        documentSizeLabel.setToolTipText("Document size");
        documentSizeLabel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        documentSizeLabel.setComponentPopupMenu(documentSizePopupMenu);
        documentSizeLabel.setName("documentSizeLabel");

        cursorPositionLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        cursorPositionLabel.setText("0:0");
        cursorPositionLabel.setToolTipText("Cursor position");
        cursorPositionLabel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        cursorPositionLabel.setComponentPopupMenu(positionPopupMenu);
        cursorPositionLabel.setName("cursorPositionLabel");
        cursorPositionLabel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                cursorPositionLabelMouseClicked(evt);
            }
        });

        editModeLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        editModeLabel.setText("OVR");
        editModeLabel.setToolTipText("Edit mode");
        editModeLabel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        editModeLabel.setName("editModeLabel");
        editModeLabel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                editModeLabelMouseClicked(evt);
            }
        });

        encodingLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        encodingLabel.setText("UTF-8");
        encodingLabel.setToolTipText("Active encoding");
        encodingLabel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        encodingLabel.setName("encodingLabel");
        encodingLabel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                encodingLabelMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                encodingLabelMouseReleased(evt);
            }
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                encodingLabelMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(195, Short.MAX_VALUE)
                .addComponent(encodingLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(documentSizeLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 168, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(cursorPositionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 168, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addComponent(editModeLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(editModeLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(documentSizeLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(cursorPositionLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(encodingLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void editModeLabelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_editModeLabelMouseClicked
//        if (statusControlHandler != null && evt.getButton() == MouseEvent.BUTTON1) {
//            if (editOperation == EditOperation.INSERT) {
//                statusControlHandler.changeEditOperation(EditOperation.OVERWRITE);
//            } else if (editOperation == EditOperation.OVERWRITE) {
//                statusControlHandler.changeEditOperation(EditOperation.INSERT);
//            }
//        }
    }//GEN-LAST:event_editModeLabelMouseClicked

    private void cursorPositionLabelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_cursorPositionLabelMouseClicked
        if (evt.getButton() == MouseEvent.BUTTON1 && evt.getClickCount() > 1) {
            // statusControlHandler.changeCursorPosition();
        }
    }//GEN-LAST:event_cursorPositionLabelMouseClicked

    private void positionGoToMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_positionGoToMenuItemActionPerformed
        // statusControlHandler.changeCursorPosition();
    }//GEN-LAST:event_positionGoToMenuItemActionPerformed

    private void positionCopyMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_positionCopyMenuItemActionPerformed
        try {
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            clipboard.setContents(new StringSelection(cursorPositionLabel.getText()), null);
        } catch (IllegalStateException ex) {
            // ignore issues with clipboard
        }
    }//GEN-LAST:event_positionCopyMenuItemActionPerformed

    private void documentSizeCopyMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_documentSizeCopyMenuItemActionPerformed
        try {
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            clipboard.setContents(new StringSelection(documentSizeLabel.getText()), null);
        } catch (IllegalStateException ex) {
            // ignore issues with clipboard
        }
    }//GEN-LAST:event_documentSizeCopyMenuItemActionPerformed

    private void encodingLabelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_encodingLabelMouseClicked
        if (evt.getButton() == MouseEvent.BUTTON1) {
            // Not supported
        } else {
            handleEncodingPopup(evt);
        }
    }//GEN-LAST:event_encodingLabelMouseClicked

    private void encodingLabelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_encodingLabelMousePressed
        handleEncodingPopup(evt);
    }//GEN-LAST:event_encodingLabelMousePressed

    private void encodingLabelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_encodingLabelMouseReleased
        handleEncodingPopup(evt);
    }//GEN-LAST:event_encodingLabelMouseReleased

    private void cursorPositionShowOffsetCheckBoxMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cursorPositionShowOffsetCheckBoxMenuItemActionPerformed
        cursorPositionFormat.setShowOffset(cursorPositionShowOffsetCheckBoxMenuItem.isSelected());
        updateCaretPosition();
    }//GEN-LAST:event_cursorPositionShowOffsetCheckBoxMenuItemActionPerformed

    private void documentSizeShowRelativeCheckBoxMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_documentSizeShowRelativeCheckBoxMenuItemActionPerformed
        documentSizeFormat.setShowRelative(documentSizeShowRelativeCheckBoxMenuItem.isSelected());
        updateDocumentSize();
        updateDocumentSizeToolTip();
    }//GEN-LAST:event_documentSizeShowRelativeCheckBoxMenuItemActionPerformed

    private void octalCursorPositionModeRadioButtonMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_octalCursorPositionModeRadioButtonMenuItemActionPerformed
        cursorPositionFormat.setCodeType(PositionCodeType.OCTAL);
        updateCaretPosition();
    }//GEN-LAST:event_octalCursorPositionModeRadioButtonMenuItemActionPerformed

    private void decimalCursorPositionModeRadioButtonMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_decimalCursorPositionModeRadioButtonMenuItemActionPerformed
        cursorPositionFormat.setCodeType(PositionCodeType.DECIMAL);
        updateCaretPosition();
    }//GEN-LAST:event_decimalCursorPositionModeRadioButtonMenuItemActionPerformed

    private void hexadecimalCursorPositionModeRadioButtonMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_hexadecimalCursorPositionModeRadioButtonMenuItemActionPerformed
        cursorPositionFormat.setCodeType(PositionCodeType.HEXADECIMAL);
        updateCaretPosition();
    }//GEN-LAST:event_hexadecimalCursorPositionModeRadioButtonMenuItemActionPerformed

    private void octalDocumentSizeModeRadioButtonMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_octalDocumentSizeModeRadioButtonMenuItemActionPerformed
        documentSizeFormat.setCodeType(PositionCodeType.OCTAL);
        updateDocumentSize();
    }//GEN-LAST:event_octalDocumentSizeModeRadioButtonMenuItemActionPerformed

    private void decimalDocumentSizeModeRadioButtonMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_decimalDocumentSizeModeRadioButtonMenuItemActionPerformed
        documentSizeFormat.setCodeType(PositionCodeType.DECIMAL);
        updateDocumentSize();
    }//GEN-LAST:event_decimalDocumentSizeModeRadioButtonMenuItemActionPerformed

    private void hexadecimalDocumentSizeModeRadioButtonMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_hexadecimalDocumentSizeModeRadioButtonMenuItemActionPerformed
        documentSizeFormat.setCodeType(PositionCodeType.HEXADECIMAL);
        updateDocumentSize();
    }//GEN-LAST:event_hexadecimalDocumentSizeModeRadioButtonMenuItemActionPerformed

    private void handleEncodingPopup(java.awt.event.MouseEvent evt) {
        if (evt.isPopupTrigger()) {
            // Not supported
        }
    }

    @Override
    public void setCursorPosition(CodeAreaCaretPosition caretPosition) {
        this.caretPosition = caretPosition;
        updateCaretPosition();
        updateCursorPositionToolTip();
    }

    @Override
    public void setSelectionRange(SelectionRange selectionRange) {
        this.selectionRange = selectionRange;
        updateCaretPosition();
        updateCursorPositionToolTip();
        updateDocumentSize();
        updateDocumentSizeToolTip();
    }

    @Override
    public void setCurrentDocumentSize(long documentSize, long initialDocumentSize) {
        this.documentSize = documentSize;
        this.initialDocumentSize = initialDocumentSize;
        updateDocumentSize();
        updateDocumentSizeToolTip();
    }

    @Nonnull
    public String getEncoding() {
        return encodingLabel.getText();
    }

    public void setEncoding(String encodingName) {
        encodingLabel.setText(encodingName + " ^");
    }

    @Override
    public void setEditMode(EditMode editMode, EditOperation editOperation) {
        this.editOperation = editOperation;
        switch (editMode) {
            case READ_ONLY: {
                editModeLabel.setText(READONLY_EDIT_MODE_LABEL);
                break;
            }
            case EXPANDING:
            case CAPPED: {
                switch (editOperation) {
                    case INSERT: {
                        editModeLabel.setText(INSERT_EDIT_MODE_LABEL);
                        break;
                    }
                    case OVERWRITE: {
                        editModeLabel.setText(OVERWRITE_EDIT_MODE_LABEL);
                        break;
                    }
                    default:
                        throw CodeAreaUtils.getInvalidTypeException(editOperation);
                }
                break;
            }
            case INPLACE: {
                editModeLabel.setText(INPLACE_EDIT_MODE_LABEL);
                break;
            }
            default:
                throw CodeAreaUtils.getInvalidTypeException(editMode);
        }
    }

    private void updateCaretPosition() {
        if (caretPosition == null) {
            cursorPositionLabel.setText("-");
        } else {
            StringBuilder labelBuilder = new StringBuilder();
            if (selectionRange != null && !selectionRange.isEmpty()) {
                long first = selectionRange.getFirst();
                long last = selectionRange.getLast();
                labelBuilder.append(numberToPosition(first, cursorPositionFormat.getCodeType()));
                labelBuilder.append(" to ");
                labelBuilder.append(numberToPosition(last, cursorPositionFormat.getCodeType()));
            } else {
                labelBuilder.append(numberToPosition(caretPosition.getDataPosition(), cursorPositionFormat.getCodeType()));
                if (cursorPositionFormat.isShowOffset()) {
                    labelBuilder.append(":");
                    labelBuilder.append(caretPosition.getCodeOffset());
                }
            }
            cursorPositionLabel.setText(labelBuilder.toString());
        }
    }

    private void updateCursorPositionToolTip() {
        StringBuilder builder = new StringBuilder();
        builder.append("<html>");
        if (caretPosition == null) {
            builder.append("Cursor position");
        } else {
            if (selectionRange != null && !selectionRange.isEmpty()) {
                long first = selectionRange.getFirst();
                long last = selectionRange.getLast();
                builder.append("Selection from<br>");
                builder.append(OCTAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(first, PositionCodeType.OCTAL)).append("<br>");
                builder.append(DECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(first, PositionCodeType.DECIMAL)).append("<br>");
                builder.append(HEXADECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(first, PositionCodeType.HEXADECIMAL)).append("<br>");
                builder.append("<br>");
                builder.append("Selection to<br>");
                builder.append(OCTAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(last, PositionCodeType.OCTAL)).append("<br>");
                builder.append(DECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(last, PositionCodeType.DECIMAL)).append("<br>");
                builder.append(HEXADECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(first, PositionCodeType.HEXADECIMAL)).append("<br>");
            } else {
                long dataPosition = caretPosition.getDataPosition();
                builder.append("Cursor position<br>");
                builder.append(OCTAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(dataPosition, PositionCodeType.OCTAL)).append("<br>");
                builder.append(DECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(dataPosition, PositionCodeType.DECIMAL)).append("<br>");
                builder.append(HEXADECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(dataPosition, PositionCodeType.HEXADECIMAL));
                builder.append("</html>");
            }
        }

        cursorPositionLabel.setToolTipText(builder.toString());
    }

    private void updateDocumentSize() {
        if (documentSize == -1) {
            documentSizeLabel.setText(documentSizeFormat.isShowRelative() ? "0 (0)" : "0");
        } else {
            StringBuilder labelBuilder = new StringBuilder();
            if (selectionRange != null && !selectionRange.isEmpty()) {
                labelBuilder.append(numberToPosition(selectionRange.getLength(), documentSizeFormat.getCodeType()));
                labelBuilder.append(" of ");
                labelBuilder.append(numberToPosition(documentSize, documentSizeFormat.getCodeType()));
            } else {
                labelBuilder.append(numberToPosition(documentSize, documentSizeFormat.getCodeType()));
                if (documentSizeFormat.isShowRelative()) {
                    long difference = documentSize - initialDocumentSize;
                    labelBuilder.append(difference > 0 ? " (+" : " (");
                    labelBuilder.append(numberToPosition(difference, documentSizeFormat.getCodeType()));
                    labelBuilder.append(")");

                }
            }

            documentSizeLabel.setText(labelBuilder.toString());
        }
    }

    private void updateDocumentSizeToolTip() {
        StringBuilder builder = new StringBuilder();
        builder.append("<html>");
        if (selectionRange != null && !selectionRange.isEmpty()) {
            long length = selectionRange.getLength();
            builder.append("Selection length<br>");
            builder.append(OCTAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(length, PositionCodeType.OCTAL)).append("<br>");
            builder.append(DECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(length, PositionCodeType.DECIMAL)).append("<br>");
            builder.append(HEXADECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(length, PositionCodeType.HEXADECIMAL)).append("<br>");
            builder.append("<br>");
        }

        builder.append("Document size<br>");
        builder.append(OCTAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(documentSize, PositionCodeType.OCTAL)).append("<br>");
        builder.append(DECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(documentSize, PositionCodeType.DECIMAL)).append("<br>");
        builder.append(HEXADECIMAL_CODE_TYPE_LABEL + ": ").append(numberToPosition(documentSize, PositionCodeType.HEXADECIMAL));
        builder.append("</html>");
        documentSizeLabel.setToolTipText(builder.toString());
    }

    @Nonnull
    private String numberToPosition(long value, PositionCodeType codeType) {
        if (value == 0) {
            return "0";
        }

        int spaceGroupSize;
        switch (codeType) {
            case OCTAL: {
                spaceGroupSize = octalSpaceGroupSize;
                break;
            }
            case DECIMAL: {
                spaceGroupSize = decimalSpaceGroupSize;
                break;
            }
            case HEXADECIMAL: {
                spaceGroupSize = hexadecimalSpaceGroupSize;
                break;
            }
            default:
                throw CodeAreaUtils.getInvalidTypeException(codeType);
        }

        long remainder = value > 0 ? value : -value;
        StringBuilder builder = new StringBuilder();
        int base = codeType.getBase();
        int groupSize = spaceGroupSize == 0 ? -1 : spaceGroupSize;
        while (remainder > 0) {
            if (groupSize >= 0) {
                if (groupSize == 0) {
                    builder.insert(0, ' ');
                    groupSize = spaceGroupSize - 1;
                } else {
                    groupSize--;
                }
            }

            int digit = (int) (remainder % base);
            remainder /= base;
            builder.insert(0, CodeAreaUtils.UPPER_HEX_CODES[digit]);
        }

        if (value < 0) {
            builder.insert(0, "-");
        }
        return builder.toString();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/GoToBinaryPanel.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

import javax.annotation.ParametersAreNonnullByDefault;
import org.exbin.bined.CodeAreaUtils;

/**
 * Go-to position panel for binary editor.
 */
@ParametersAreNonnullByDefault
public class GoToBinaryPanel extends javax.swing.JPanel {

    private long cursorPosition;
    private long maxPosition;
    private GoToBinaryPositionMode goToMode = GoToBinaryPositionMode.FROM_START;

    public GoToBinaryPanel() {
        initComponents();

        baseSwitchableSpinnerPanel.setMinimum(0L);
        baseSwitchableSpinnerPanel.addChangeListener((javax.swing.event.ChangeEvent evt) -> updateTargetPosition());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        positionTypeButtonGroup = new javax.swing.ButtonGroup();
        currentPositionLabel = new javax.swing.JLabel();
        currentPositionTextField = new javax.swing.JTextField();
        goToPanel = new javax.swing.JPanel();
        fromStartRadioButton = new javax.swing.JRadioButton();
        fromEndRadioButton = new javax.swing.JRadioButton();
        fromCursorRadioButton = new javax.swing.JRadioButton();
        positionLabel = new javax.swing.JLabel();
        baseSwitchableSpinnerPanel = new BaseSwitchableSpinnerPanel();
        targetPositionLabel = new javax.swing.JLabel();
        targetPositionTextField = new javax.swing.JTextField();

        currentPositionLabel.setText("Current Position");

        currentPositionTextField.setEditable(false);
        currentPositionTextField.setText("0");

        goToPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Go To Position"));

        positionTypeButtonGroup.add(fromStartRadioButton);
        fromStartRadioButton.setSelected(true);
        fromStartRadioButton.setText("Position from start");
        fromStartRadioButton.addItemListener(this::fromStartRadioButtonItemStateChanged);

        positionTypeButtonGroup.add(fromEndRadioButton);
        fromEndRadioButton.setText("Position from end");
        fromEndRadioButton.addItemListener(this::fromEndRadioButtonItemStateChanged);

        positionTypeButtonGroup.add(fromCursorRadioButton);
        fromCursorRadioButton.setText("Position relative to cursor");
        fromCursorRadioButton.addItemListener(this::fromCursorRadioButtonItemStateChanged);

        positionLabel.setText("Position");

        javax.swing.GroupLayout goToPanelLayout = new javax.swing.GroupLayout(goToPanel);
        goToPanel.setLayout(goToPanelLayout);
        goToPanelLayout.setHorizontalGroup(
            goToPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(fromStartRadioButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(fromCursorRadioButton, javax.swing.GroupLayout.DEFAULT_SIZE, 412, Short.MAX_VALUE)
            .addComponent(fromEndRadioButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(goToPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(goToPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(baseSwitchableSpinnerPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(goToPanelLayout.createSequentialGroup()
                        .addComponent(positionLabel)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        goToPanelLayout.setVerticalGroup(
            goToPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(goToPanelLayout.createSequentialGroup()
                .addComponent(fromStartRadioButton, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(fromEndRadioButton, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(fromCursorRadioButton, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(positionLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(baseSwitchableSpinnerPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        targetPositionLabel.setText("Target Position");

        targetPositionTextField.setEditable(false);
        targetPositionTextField.setText("0");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(currentPositionTextField)
                    .addComponent(goToPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(targetPositionTextField)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(currentPositionLabel)
                            .addComponent(targetPositionLabel))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(currentPositionLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(currentPositionTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(goToPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(targetPositionLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(targetPositionTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void fromStartRadioButtonItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_fromStartRadioButtonItemStateChanged
        if (fromStartRadioButton.isSelected()) {
            switchGoToMode(GoToBinaryPositionMode.FROM_START);
        }
    }//GEN-LAST:event_fromStartRadioButtonItemStateChanged

    private void fromEndRadioButtonItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_fromEndRadioButtonItemStateChanged
        if (fromEndRadioButton.isSelected()) {
            switchGoToMode(GoToBinaryPositionMode.FROM_END);
        }
    }//GEN-LAST:event_fromEndRadioButtonItemStateChanged

    private void fromCursorRadioButtonItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_fromCursorRadioButtonItemStateChanged
        if (fromCursorRadioButton.isSelected()) {
            switchGoToMode(GoToBinaryPositionMode.FROM_CURSOR);
        }
    }//GEN-LAST:event_fromCursorRadioButtonItemStateChanged

    private void updateTargetPosition() {
        targetPositionTextField.setText(String.valueOf(getTargetPosition()));
    }

    public void initFocus() {
        baseSwitchableSpinnerPanel.initFocus();
    }

    public long getTargetPosition() {
        long absolutePosition;
        long position = getPositionValue();
        switch (goToMode) {
            case FROM_START:
                absolutePosition = position;
                break;
            case FROM_END:
                absolutePosition = maxPosition - position;
                break;
            case FROM_CURSOR:
                absolutePosition = cursorPosition + position;
                break;
            default:
                throw CodeAreaUtils.getInvalidTypeException(goToMode);
        }

        if (absolutePosition < 0) {
            absolutePosition = 0;
        } else if (absolutePosition > maxPosition) {
            absolutePosition = maxPosition;
        }
        return absolutePosition;
    }

    public void setTargetPosition(long absolutePosition) {
        if (absolutePosition < 0) {
            absolutePosition = 0;
        } else if (absolutePosition > maxPosition) {
            absolutePosition = maxPosition;
        }
        switch (goToMode) {
            case FROM_START:
                setPositionValue(absolutePosition);
                break;
            case FROM_END:
                setPositionValue(maxPosition - absolutePosition);
                break;
            case FROM_CURSOR:
                setPositionValue(absolutePosition - cursorPosition);
                break;
            default:
                throw CodeAreaUtils.getInvalidTypeException(goToMode);
        }
        updateTargetPosition();
    }

    public long getCursorPosition() {
        return cursorPosition;
    }

    public void setCursorPosition(long cursorPosition) {
        this.cursorPosition = cursorPosition;
        setPositionValue(cursorPosition);
        currentPositionTextField.setText(String.valueOf(cursorPosition));
    }

    public void setMaxPosition(long maxPosition) {
        this.maxPosition = maxPosition;
        baseSwitchableSpinnerPanel.setMaximum(maxPosition);
        updateTargetPosition();
    }

    public void setSelected() {
        baseSwitchableSpinnerPanel.requestFocusInWindow();
    }

    private void switchGoToMode(GoToBinaryPositionMode goToMode) {
        if (this.goToMode == goToMode) {
            return;
        }

        long absolutePosition = getTargetPosition();
        this.goToMode = goToMode;
        switch (goToMode) {
        case FROM_START:
        case FROM_END: {
                setPositionValue(0L);
                baseSwitchableSpinnerPanel.setMinimum(0L);
                baseSwitchableSpinnerPanel.setMaximum(maxPosition);
                baseSwitchableSpinnerPanel.revalidateSpinner();
                break;
            }
        case FROM_CURSOR: {
                setPositionValue(0L);
                baseSwitchableSpinnerPanel.setMinimum(-cursorPosition);
                baseSwitchableSpinnerPanel.setMaximum(maxPosition - cursorPosition);
                baseSwitchableSpinnerPanel.revalidateSpinner();
                break;
            }
            default:
                throw CodeAreaUtils.getInvalidTypeException(goToMode);
        }
        setTargetPosition(absolutePosition);
    }

    private long getPositionValue() {
        return baseSwitchableSpinnerPanel.getValue();
    }

    private void setPositionValue(long value) {
        baseSwitchableSpinnerPanel.setValue(value);
        updateTargetPosition();
//        positionSpinner.setValue(value);
//        positionSpinner.firePropertyChange(SPINNER_PROPERTY, value, value);
    }

    public void acceptInput() {
        baseSwitchableSpinnerPanel.acceptInput();
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private BaseSwitchableSpinnerPanel baseSwitchableSpinnerPanel;
    private javax.swing.JLabel currentPositionLabel;
    private javax.swing.JTextField currentPositionTextField;
    private javax.swing.JRadioButton fromCursorRadioButton;
    private javax.swing.JRadioButton fromEndRadioButton;
    private javax.swing.JRadioButton fromStartRadioButton;
    private javax.swing.JPanel goToPanel;
    private javax.swing.JLabel positionLabel;
    private javax.swing.ButtonGroup positionTypeButtonGroup;
    private javax.swing.JLabel targetPositionLabel;
    private javax.swing.JTextField targetPositionTextField;
    // End of variables declaration//GEN-END:variables

}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/GoToBinaryPositionMode.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

/**
 * Mode for calculation of the go-to position in binary document.
 */
public enum GoToBinaryPositionMode {
    /**
     * Count from start of the document.
     */
    FROM_START,
    /**
     * Count from end of the document.
     */
    FROM_END,
    /**
     * Count from current position of the cursor in the document.
     */
    FROM_CURSOR
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/HexViewer.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

import org.exbin.auxiliary.paged_data.ByteArrayData;
import org.exbin.bined.CodeAreaCaretPosition;
import org.exbin.bined.CodeType;
import org.exbin.bined.EditMode;
import org.exbin.bined.RowWrappingMode;
import org.exbin.bined.highlight.swing.HighlightNonAsciiCodeAreaPainter;
import org.exbin.bined.swing.basic.CodeArea;

import javax.annotation.Nonnull;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;

/**
 * Binary/hexadecimal viewer based on BinEd library.
 *
 * @author hajdam
 */
public class HexViewer extends JPanel {

    private final CodeArea codeArea;
    private final JToolBar toolBar;
    private final BinaryStatusPanel statusPanel;
    private final ValuesPanel valuesPanel;
    private JPanel codeAreaPanel;
    private JScrollPane valuesPanelScrollBar;
    private boolean valuesPanelVisible = false;

    private final AbstractAction cycleCodeTypesAction;
    private JButton cycleCodeTypeButton;
    private BinaryStatusApi binaryStatus;
    private final AbstractAction goToAction;

    public HexViewer(byte[] contentData) {
        super(new BorderLayout());
        codeArea = new CodeArea();
        codeArea.setPainter(new HighlightNonAsciiCodeAreaPainter(codeArea));
        toolBar = new JToolBar();
        statusPanel = new BinaryStatusPanel() {
            @Override
            public Dimension getMinimumSize() {
                return new Dimension(0, super.getMinimumSize().height);
            }
        };
        valuesPanel = new ValuesPanel();
        codeArea.setContentData(new ByteArrayData(contentData));
        codeArea.setEditMode(EditMode.READ_ONLY);

        cycleCodeTypesAction = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                int codeTypePos = codeArea.getCodeType().ordinal();
                CodeType[] values = CodeType.values();
                CodeType next = codeTypePos + 1 >= values.length ? values[0] : values[codeTypePos + 1];
                codeArea.setCodeType(next);
                updateCycleButtonState();
            }
        };

        goToAction = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                final GoToBinaryPanel goToPanel = new GoToBinaryPanel();
                goToPanel.setCursorPosition(codeArea.getCaret().getCaretPosition().getDataPosition());
                goToPanel.setMaxPosition(codeArea.getDataSize());
                final JDialog dialog = new JDialog((JFrame) SwingUtilities.getRoot(HexViewer.this), Dialog.ModalityType.APPLICATION_MODAL);
                OkCancelPanel okCancelPanel = new OkCancelPanel() {
                    @Override
                    protected void okAction() {
                        goToPanel.acceptInput();
                        codeArea.setCaretPosition(goToPanel.getTargetPosition());
                        codeArea.revealCursor();
                        dialog.setVisible(false);
                        dialog.dispose();
                        codeArea.requestFocus();
                    }

                    @Override
                    protected void cancelAction() {
                        dialog.setVisible(false);
                        dialog.dispose();
                    }
                };

                final String ESC_CANCEL = "esc-cancel";
                dialog.getRootPane().getActionMap().put(ESC_CANCEL, new AbstractAction() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        okCancelPanel.cancelAction();
                    }
                });
                dialog.getRootPane().getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), ESC_CANCEL);
                okCancelPanel.setOkButtonText("Go To");
                dialog.setTitle("Go To Position");
                dialog.add(goToPanel, BorderLayout.CENTER);
                dialog.add(okCancelPanel, BorderLayout.SOUTH);
                dialog.pack();
                dialog.setLocationByPlatform(true);
                dialog.setVisible(true);
            }
        };

        init();
    }

    private void init() {
        cycleCodeTypesAction.putValue(Action.SHORT_DESCRIPTION, "Cycle through code types");

        cycleCodeTypeButton = new JButton();
        cycleCodeTypeButton.setAction(cycleCodeTypesAction);
        updateCycleButtonState();
        toolBar.add(cycleCodeTypeButton);
        JToggleButton lineWrappingToggleButton = new JToggleButton();
        lineWrappingToggleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/the/bytecode/club/bytecodeviewer/gui/hexviewer/resources/bined-linewrap.png")));
        lineWrappingToggleButton.setToolTipText("Toggle line wrapping");
        lineWrappingToggleButton.addActionListener(evt -> {
            if (codeArea.getRowWrapping() == RowWrappingMode.WRAPPING) {
                codeArea.setMaxBytesPerRow(16);
                codeArea.setRowWrapping(RowWrappingMode.NO_WRAPPING);
            } else {
                codeArea.setMaxBytesPerRow(0);
                codeArea.setRowWrapping(RowWrappingMode.WRAPPING);
            }
        });
        toolBar.add(lineWrappingToggleButton);

        add(toolBar, BorderLayout.NORTH);

        codeAreaPanel = new JPanel(new BorderLayout());
        codeAreaPanel.add(codeArea, BorderLayout.CENTER);
        codeArea.setComponentPopupMenu(new JPopupMenu() {
            @Override
            public void show(Component invoker, int x, int y) {
                removeAll();
                final JPopupMenu menu = createPopupMenu();
                menu.show(invoker, x, y);
            }
        });

        valuesPanelScrollBar = new JScrollPane();
        valuesPanel.setCodeArea(codeArea);
        valuesPanel.updateValues();
        valuesPanelScrollBar.setViewportView(valuesPanel);
        valuesPanelScrollBar.setMinimumSize(new Dimension(10, valuesPanel.getMinimumSize().height));
        setShowValuesPanel(true);
        add(codeAreaPanel, BorderLayout.CENTER);

        registerBinaryStatus(statusPanel);
        add(statusPanel, BorderLayout.SOUTH);

        final String GO_TO_ACTION = "goToAction";
        codeArea.getActionMap().put(GO_TO_ACTION, goToAction);
        codeArea.getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke(KeyEvent.VK_G, HexViewer.getMetaMask()), GO_TO_ACTION);
        invalidate();
    }

    private void setShowValuesPanel(boolean show) {
        if (valuesPanelVisible != show) {
            if (show) {
                codeAreaPanel.add(valuesPanelScrollBar, BorderLayout.SOUTH);
                codeAreaPanel.revalidate();
                codeAreaPanel.repaint();
                valuesPanelVisible = true;
                valuesPanel.enableUpdate();
            } else {
                valuesPanel.disableUpdate();
                codeAreaPanel.remove(valuesPanelScrollBar);
                codeAreaPanel.revalidate();
                codeAreaPanel.repaint();
                valuesPanelVisible = false;
            }
        }
    }

    public void registerBinaryStatus(BinaryStatusApi binaryStatusApi) {
        this.binaryStatus = binaryStatusApi;
        codeArea.addCaretMovedListener((CodeAreaCaretPosition caretPosition) -> binaryStatus.setCursorPosition(caretPosition));
        codeArea.addSelectionChangedListener(() -> binaryStatus.setSelectionRange(codeArea.getSelection()));
        codeArea.addDataChangedListener(() -> binaryStatus.setCurrentDocumentSize(codeArea.getDataSize(), codeArea.getDataSize()));
        binaryStatus.setCurrentDocumentSize(codeArea.getDataSize(), codeArea.getDataSize());

        codeArea.addEditModeChangedListener(binaryStatus::setEditMode);
        binaryStatus.setEditMode(codeArea.getEditMode(), codeArea.getActiveOperation());
    }

    /**
     * Returns platform specific down mask filter.
     *
     * @return down mask for meta keys
     */
    public static int getMetaMask() {
        try {
            switch (java.awt.Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()) {
                case java.awt.Event.META_MASK:
                    return KeyEvent.META_DOWN_MASK;
                case java.awt.Event.SHIFT_MASK:
                    return KeyEvent.SHIFT_DOWN_MASK;
                case java.awt.Event.ALT_MASK:
                    return KeyEvent.ALT_DOWN_MASK;
                default:
                    return KeyEvent.CTRL_DOWN_MASK;
            }
        } catch (java.awt.HeadlessException ex) {
            return KeyEvent.CTRL_DOWN_MASK;
        }
    }

    @Nonnull
    private JPopupMenu createPopupMenu() {
        JPopupMenu menu = new JPopupMenu();

        JMenu viewMenu = new JMenu("View");
        JMenu codeTypeMenu = new JMenu("Code Type");
        ButtonGroup codeTypeButtonGroup = new ButtonGroup();
        JRadioButtonMenuItem binaryCodeTypeMenuItem = new JRadioButtonMenuItem(new AbstractAction("Binary") {
            @Override
            public void actionPerformed(ActionEvent e) {
                codeArea.setCodeType(CodeType.BINARY);
                updateCycleButtonState();
                menu.setVisible(false);
            }
        });
        codeTypeButtonGroup.add(binaryCodeTypeMenuItem);
        JRadioButtonMenuItem octalCodeTypeMenuItem = new JRadioButtonMenuItem(new AbstractAction("Octal") {
            @Override
            public void actionPerformed(ActionEvent e) {
                codeArea.setCodeType(CodeType.OCTAL);
                updateCycleButtonState();
                menu.setVisible(false);
            }
        });
        codeTypeButtonGroup.add(octalCodeTypeMenuItem);
        JRadioButtonMenuItem decimalCodeTypeMenuItem = new JRadioButtonMenuItem(new AbstractAction("Decimal") {
            @Override
            public void actionPerformed(ActionEvent e) {
                codeArea.setCodeType(CodeType.DECIMAL);
                updateCycleButtonState();
                menu.setVisible(false);
            }
        });
        codeTypeButtonGroup.add(decimalCodeTypeMenuItem);
        JRadioButtonMenuItem hexadecimalCodeTypeMenuItem = new JRadioButtonMenuItem(new AbstractAction("Hexadecimal") {
            @Override
            public void actionPerformed(ActionEvent e) {
                codeArea.setCodeType(CodeType.HEXADECIMAL);
                updateCycleButtonState();
                menu.setVisible(false);
            }
        });
        codeTypeButtonGroup.add(hexadecimalCodeTypeMenuItem);
        codeTypeMenu.add(binaryCodeTypeMenuItem);
        codeTypeMenu.add(octalCodeTypeMenuItem);
        codeTypeMenu.add(decimalCodeTypeMenuItem);
        codeTypeMenu.add(hexadecimalCodeTypeMenuItem);
        switch (codeArea.getCodeType()) {
            case BINARY: {
                binaryCodeTypeMenuItem.setSelected(true);
                break;
            }
            case OCTAL: {
                octalCodeTypeMenuItem.setSelected(true);
                break;
            }
            case DECIMAL: {
                decimalCodeTypeMenuItem.setSelected(true);
                break;
            }
            case HEXADECIMAL: {
                hexadecimalCodeTypeMenuItem.setSelected(true);
                break;
            }
        }

        viewMenu.add(codeTypeMenu);
        JCheckBoxMenuItem showValuesPanelMenuItem = new JCheckBoxMenuItem("Show values panel");
        showValuesPanelMenuItem.setSelected(valuesPanelVisible);
        showValuesPanelMenuItem.addActionListener((event) -> {
            setShowValuesPanel(showValuesPanelMenuItem.isSelected());
            menu.setVisible(false);
        });
        viewMenu.add(showValuesPanelMenuItem);
        JCheckBoxMenuItem codeColorizationMenuItem = new JCheckBoxMenuItem("Code Colorization");
        codeColorizationMenuItem.setSelected(((HighlightNonAsciiCodeAreaPainter) codeArea.getPainter()).isNonAsciiHighlightingEnabled());
        codeColorizationMenuItem.addActionListener((event) -> {
            ((HighlightNonAsciiCodeAreaPainter) codeArea.getPainter()).setNonAsciiHighlightingEnabled(codeColorizationMenuItem.isSelected());
            menu.setVisible(false);
        });
        viewMenu.add(codeColorizationMenuItem);
        menu.add(viewMenu);

        final JMenuItem copyMenuItem = new JMenuItem("Copy");
        copyMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, HexViewer.getMetaMask()));
        copyMenuItem.setEnabled(codeArea.hasSelection());
        copyMenuItem.addActionListener((ActionEvent e) -> codeArea.copy());
        menu.add(copyMenuItem);

        final JMenuItem selectAllMenuItem = new JMenuItem("Select All");
        selectAllMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, HexViewer.getMetaMask()));
        selectAllMenuItem.addActionListener((ActionEvent e) -> codeArea.selectAll());
        menu.add(selectAllMenuItem);
        menu.addSeparator();

        final JMenuItem goToMenuItem = new JMenuItem("Go To...");
        goToMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, HexViewer.getMetaMask()));
        goToMenuItem.addActionListener(goToAction);
        menu.add(goToMenuItem);

        return menu;
    }

    private void updateCycleButtonState() {
        CodeType codeType = codeArea.getCodeType();
        cycleCodeTypeButton.setText(codeType.name().substring(0, 3));
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/OkCancelPanel.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

/**
 * OK/Cancel Panel.
 */
public class OkCancelPanel extends javax.swing.JPanel {

    public OkCancelPanel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        cancelButton = new javax.swing.JButton();
        okButton = new javax.swing.JButton();

        cancelButton.setText("Cancel");
        cancelButton.addActionListener(this::cancelButtonActionPerformed);

        okButton.setText("Ok");
        okButton.addActionListener(this::okButtonActionPerformed);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(okButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(cancelButton)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cancelButton)
                    .addComponent(okButton))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        cancelAction();
    }//GEN-LAST:event_cancelButtonActionPerformed

    private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed
        okAction();
    }//GEN-LAST:event_okButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cancelButton;
    private javax.swing.JButton okButton;
    // End of variables declaration//GEN-END:variables

    protected void okAction() {
    }
    
    protected void cancelAction() {
    }

    public void setOkButtonText(String text) {
        okButton.setText(text);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/StatusCursorPositionFormat.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

import java.util.Objects;
import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import org.exbin.bined.PositionCodeType;

/**
 * Cursor position format for status.
 *
 * @author hajdam
 */
@ParametersAreNonnullByDefault
public class StatusCursorPositionFormat {

    private PositionCodeType positionCodeType = PositionCodeType.DECIMAL;
    private boolean showOffset = true;

    public StatusCursorPositionFormat() {
    }

    public StatusCursorPositionFormat(PositionCodeType positionCodeType, boolean showOffset) {
        this.positionCodeType = positionCodeType;
        this.showOffset = showOffset;
    }

    @Nonnull
    public PositionCodeType getCodeType() {
        return positionCodeType;
    }

    public void setCodeType(PositionCodeType positionCodeType) {
        this.positionCodeType = Objects.requireNonNull(positionCodeType);
    }

    public boolean isShowOffset() {
        return showOffset;
    }

    public void setShowOffset(boolean showOffset) {
        this.showOffset = showOffset;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/StatusDocumentSizeFormat.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

import java.util.Objects;
import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;
import org.exbin.bined.PositionCodeType;

/**
 * Document size format for status.
 *
 * @author hajdam
 */
@ParametersAreNonnullByDefault
public class StatusDocumentSizeFormat {

    private PositionCodeType positionCodeType = PositionCodeType.DECIMAL;
    private boolean showRelative = true;

    public StatusDocumentSizeFormat() {

    }

    public StatusDocumentSizeFormat(PositionCodeType positionCodeType, boolean showRelative) {
        this.positionCodeType = positionCodeType;
        this.showRelative = showRelative;
    }

    @Nonnull
    public PositionCodeType getCodeType() {
        return positionCodeType;
    }

    public void setCodeType(PositionCodeType positionCodeType) {
        this.positionCodeType = Objects.requireNonNull(positionCodeType);
    }

    public boolean isShowRelative() {
        return showRelative;
    }

    public void setShowRelative(boolean showRelativeSize) {
        this.showRelative = showRelativeSize;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/hexviewer/ValuesPanel.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.hexviewer;

import java.awt.event.KeyEvent;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.Objects;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import org.exbin.bined.CaretMovedListener;
import org.exbin.bined.CodeAreaCaretPosition;
import org.exbin.bined.DataChangedListener;
import org.exbin.bined.swing.basic.CodeArea;
import org.exbin.auxiliary.paged_data.BinaryData;
import org.exbin.bined.capability.EditModeCapable;

/**
 * Values side panel.
 *
 * @author hajdam
 */
@ParametersAreNonnullByDefault
public class ValuesPanel extends javax.swing.JPanel {

    public static final int UBYTE_MAX_VALUE = 255;
    public static final int SWORD_MIN_VALUE = -32768;
    public static final int SWORD_MAX_VALUE = 32767;
    public static final int UWORD_MAX_VALUE = 65535;
    public static final long UINT_MAX_VALUE = 4294967295L;
    public static final BigInteger ULONG_MAX_VALUE = new BigInteger("4294967295");
    public static final BigInteger BIG_INTEGER_BYTE_MASK = BigInteger.valueOf(255);
    public static final String VALUE_OUT_OF_RANGE = "Value is out of range";
    public static int CACHE_SIZE = 250;

    private CodeArea codeArea;
    private long dataPosition;
    private DataChangedListener dataChangedListener;
    private CaretMovedListener caretMovedListener;

    private final byte[] valuesCache = new byte[CACHE_SIZE];
    private final ByteBuffer byteBuffer = ByteBuffer.wrap(valuesCache);
    private final ValuesUpdater valuesUpdater = new ValuesUpdater();

    private javax.swing.JRadioButton bigEndianRadioButton;
    private javax.swing.JCheckBox binaryCheckBox0;
    private javax.swing.JCheckBox binaryCheckBox1;
    private javax.swing.JCheckBox binaryCheckBox2;
    private javax.swing.JCheckBox binaryCheckBox3;
    private javax.swing.JCheckBox binaryCheckBox4;
    private javax.swing.JCheckBox binaryCheckBox5;
    private javax.swing.JCheckBox binaryCheckBox6;
    private javax.swing.JCheckBox binaryCheckBox7;
    private javax.swing.JLabel binaryLabel;
    private javax.swing.JLabel byteLabel;
    private javax.swing.JTextField byteTextField;
    private javax.swing.JLabel characterLabel;
    private javax.swing.JTextField characterTextField;
    private javax.swing.JLabel doubleLabel;
    private javax.swing.JTextField doubleTextField;
    private javax.swing.ButtonGroup endianButtonGroup;
    private javax.swing.JLabel floatLabel;
    private javax.swing.JTextField floatTextField;
    private javax.swing.JLabel intLabel;
    private javax.swing.JTextField intTextField;
    private javax.swing.ButtonGroup integerSignButtonGroup;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JRadioButton littleEndianRadioButton;
    private javax.swing.JLabel longLabel;
    private javax.swing.JTextField longTextField;
    private javax.swing.JRadioButton signedRadioButton;
    private javax.swing.JLabel stringLabel;
    private javax.swing.JTextField stringTextField;
    private javax.swing.JRadioButton unsignedRadioButton;
    private javax.swing.JLabel wordLabel;
    private javax.swing.JTextField wordTextField;

    public ValuesPanel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        endianButtonGroup = new javax.swing.ButtonGroup();
        integerSignButtonGroup = new javax.swing.ButtonGroup();
        binaryLabel = new javax.swing.JLabel();
        binaryCheckBox0 = new javax.swing.JCheckBox();
        binaryCheckBox1 = new javax.swing.JCheckBox();
        binaryCheckBox2 = new javax.swing.JCheckBox();
        binaryCheckBox3 = new javax.swing.JCheckBox();
        binaryCheckBox4 = new javax.swing.JCheckBox();
        binaryCheckBox5 = new javax.swing.JCheckBox();
        binaryCheckBox6 = new javax.swing.JCheckBox();
        binaryCheckBox7 = new javax.swing.JCheckBox();
        byteLabel = new javax.swing.JLabel();
        byteTextField = new javax.swing.JTextField();
        wordLabel = new javax.swing.JLabel();
        wordTextField = new javax.swing.JTextField();
        intLabel = new javax.swing.JLabel();
        intTextField = new javax.swing.JTextField();
        longLabel = new javax.swing.JLabel();
        longTextField = new javax.swing.JTextField();
        floatLabel = new javax.swing.JLabel();
        floatTextField = new javax.swing.JTextField();
        doubleLabel = new javax.swing.JLabel();
        doubleTextField = new javax.swing.JTextField();
        characterLabel = new javax.swing.JLabel();
        characterTextField = new javax.swing.JTextField();
        stringLabel = new javax.swing.JLabel();
        stringTextField = new javax.swing.JTextField();
        jSeparator1 = new javax.swing.JSeparator();
        bigEndianRadioButton = new javax.swing.JRadioButton();
        littleEndianRadioButton = new javax.swing.JRadioButton();
        signedRadioButton = new javax.swing.JRadioButton();
        unsignedRadioButton = new javax.swing.JRadioButton();

        setMaximumSize(new java.awt.Dimension(246, 447));
        setMinimumSize(new java.awt.Dimension(246, 447));

        binaryLabel.setText("Binary");

        binaryCheckBox0.addActionListener(this::binaryCheckBox0ActionPerformed);

        binaryCheckBox1.addActionListener(this::binaryCheckBox1ActionPerformed);

        binaryCheckBox2.addActionListener(this::binaryCheckBox2ActionPerformed);

        binaryCheckBox3.addActionListener(this::binaryCheckBox3ActionPerformed);

        binaryCheckBox4.addActionListener(this::binaryCheckBox4ActionPerformed);

        binaryCheckBox5.addActionListener(this::binaryCheckBox5ActionPerformed);

        binaryCheckBox6.addActionListener(this::binaryCheckBox6ActionPerformed);

        binaryCheckBox7.addActionListener(this::binaryCheckBox7ActionPerformed);

        byteLabel.setText("Byte");

        byteTextField.setEditable(false);
        byteTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                byteTextFieldKeyReleased(evt);
            }
        });

        wordLabel.setText("Word");

        wordTextField.setEditable(false);
        wordTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                wordTextFieldKeyReleased(evt);
            }
        });

        intLabel.setText("Integer");

        intTextField.setEditable(false);
        intTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                intTextFieldKeyReleased(evt);
            }
        });

        longLabel.setText("Long");

        longTextField.setEditable(false);
        longTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                longTextFieldKeyReleased(evt);
            }
        });

        floatLabel.setText("Float");

        floatTextField.setEditable(false);
        floatTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                floatTextFieldKeyReleased(evt);
            }
        });

        doubleLabel.setText("Double");

        doubleTextField.setEditable(false);
        doubleTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                doubleTextFieldKeyReleased(evt);
            }
        });

        characterLabel.setText("Character");

        characterTextField.setEditable(false);
        characterTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                characterTextFieldKeyReleased(evt);
            }
        });

        stringLabel.setText("String");

        stringTextField.setEditable(false);
        stringTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                stringTextFieldKeyReleased(evt);
            }
        });

        jSeparator1.setOrientation(javax.swing.SwingConstants.VERTICAL);

        endianButtonGroup.add(bigEndianRadioButton);
        bigEndianRadioButton.setSelected(true);
        bigEndianRadioButton.setText("BE");
        bigEndianRadioButton.setToolTipText("Big Endian");
        bigEndianRadioButton.addChangeListener(this::bigEndianRadioButtonStateChanged);

        endianButtonGroup.add(littleEndianRadioButton);
        littleEndianRadioButton.setText("LE");
        littleEndianRadioButton.setToolTipText("Little Endian");
        littleEndianRadioButton.addChangeListener(this::littleEndianRadioButtonStateChanged);

        integerSignButtonGroup.add(signedRadioButton);
        signedRadioButton.setSelected(true);
        signedRadioButton.setText("Sig");
        signedRadioButton.setToolTipText("Signed Integers");
        signedRadioButton.addChangeListener(this::signedRadioButtonStateChanged);

        integerSignButtonGroup.add(unsignedRadioButton);
        unsignedRadioButton.setText("Uns");
        unsignedRadioButton.setToolTipText("Unsigned Integers");
        unsignedRadioButton.addChangeListener(this::unsignedRadioButtonStateChanged);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createSequentialGroup()
                                                .addComponent(bigEndianRadioButton)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(littleEndianRadioButton)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(signedRadioButton)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(unsignedRadioButton))
                                        .addComponent(binaryLabel)
                                        .addGroup(layout.createSequentialGroup()
                                                .addComponent(binaryCheckBox0)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(binaryCheckBox1)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(binaryCheckBox2)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(binaryCheckBox3)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(binaryCheckBox4)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(binaryCheckBox5)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(binaryCheckBox6)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(binaryCheckBox7))
                                        .addGroup(layout.createSequentialGroup()
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                        .addComponent(byteTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(wordTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(intTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(longTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(byteLabel)
                                                        .addComponent(wordLabel)
                                                        .addComponent(intLabel)
                                                        .addComponent(longLabel))
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                        .addComponent(characterTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(floatTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(floatLabel)
                                                        .addComponent(doubleLabel)
                                                        .addComponent(doubleTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                        .addComponent(characterLabel)
                                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                                .addComponent(stringTextField, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 234, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                                .addComponent(stringLabel)))))
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addContainerGap()
                                .addComponent(binaryLabel)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addComponent(binaryCheckBox0)
                                        .addComponent(binaryCheckBox1)
                                        .addComponent(binaryCheckBox2)
                                        .addComponent(binaryCheckBox3)
                                        .addComponent(binaryCheckBox4)
                                        .addComponent(binaryCheckBox5)
                                        .addComponent(binaryCheckBox6)
                                        .addComponent(binaryCheckBox7))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addGroup(layout.createSequentialGroup()
                                                .addComponent(byteLabel)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(byteTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(wordLabel)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(wordTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(intLabel)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(intTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(longLabel)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(longTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(layout.createSequentialGroup()
                                                .addComponent(floatLabel)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(floatTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(doubleLabel)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(doubleTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(characterLabel)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(characterTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(stringLabel)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(stringTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                                .addComponent(bigEndianRadioButton)
                                                .addComponent(littleEndianRadioButton))
                                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                                .addComponent(signedRadioButton)
                                                .addComponent(unsignedRadioButton)))
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void littleEndianRadioButtonStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_littleEndianRadioButtonStateChanged
        updateValues();
    }//GEN-LAST:event_littleEndianRadioButtonStateChanged

    private void bigEndianRadioButtonStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_bigEndianRadioButtonStateChanged
        updateValues();
    }//GEN-LAST:event_bigEndianRadioButtonStateChanged

    private void signedRadioButtonStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_signedRadioButtonStateChanged
        updateValues();
    }//GEN-LAST:event_signedRadioButtonStateChanged

    private void unsignedRadioButtonStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_unsignedRadioButtonStateChanged
        updateValues();
    }//GEN-LAST:event_unsignedRadioButtonStateChanged

    private void binaryCheckBox0ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox0ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x80) > 0 != binaryCheckBox0.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x80);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox0ActionPerformed

    private void binaryCheckBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox1ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x40) > 0 != binaryCheckBox1.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x40);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox1ActionPerformed

    private void binaryCheckBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox2ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x20) > 0 != binaryCheckBox2.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x20);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox2ActionPerformed

    private void binaryCheckBox3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox3ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x10) > 0 != binaryCheckBox3.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x10);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox3ActionPerformed

    private void binaryCheckBox4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox4ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x8) > 0 != binaryCheckBox4.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x8);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox4ActionPerformed

    private void binaryCheckBox5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox5ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x4) > 0 != binaryCheckBox5.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x4);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox5ActionPerformed

    private void binaryCheckBox6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox6ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x2) > 0 != binaryCheckBox6.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x2);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox6ActionPerformed

    private void binaryCheckBox7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binaryCheckBox7ActionPerformed
        if (!valuesUpdater.isUpdateInProgress() && ((valuesCache[0] & 0x1) > 0 != binaryCheckBox7.isSelected())) {
            valuesCache[0] = (byte) (valuesCache[0] ^ 0x1);
            modifyValues(1);
        }
    }//GEN-LAST:event_binaryCheckBox7ActionPerformed

    private void byteTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_byteTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                int intValue = Integer.parseInt(byteTextField.getText());
                if (isSigned()) {
                    if (intValue < Byte.MIN_VALUE || intValue > Byte.MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE);
                    }
                } else {
                    if (intValue < 0 || intValue > UBYTE_MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE);
                    }
                }

                valuesCache[0] = (byte) intValue;
                modifyValues(1);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_byteTextFieldKeyReleased

    private void wordTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_wordTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                int intValue = Integer.parseInt(wordTextField.getText());
                if (isSigned()) {
                    if (intValue < SWORD_MIN_VALUE || intValue > SWORD_MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE);
                    }
                } else {
                    if (intValue < 0 || intValue > UWORD_MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE);
                    }
                }

                if (getByteOrder() == ByteOrder.LITTLE_ENDIAN) {
                    valuesCache[0] = (byte) (intValue & 0xff);
                    valuesCache[1] = (byte) ((intValue >> 8) & 0xff);
                } else {
                    valuesCache[0] = (byte) ((intValue >> 8) & 0xff);
                    valuesCache[1] = (byte) (intValue & 0xff);
                }
                modifyValues(2);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_wordTextFieldKeyReleased

    private void intTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_intTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                long longValue = Long.parseLong(intTextField.getText());
                if (isSigned()) {
                    if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE);
                    }
                } else {
                    if (longValue < 0 || longValue > UINT_MAX_VALUE) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE);
                    }
                }

                if (getByteOrder() == ByteOrder.LITTLE_ENDIAN) {
                    valuesCache[0] = (byte) (longValue & 0xff);
                    valuesCache[1] = (byte) ((longValue >> 8) & 0xff);
                    valuesCache[2] = (byte) ((longValue >> 16) & 0xff);
                    valuesCache[3] = (byte) ((longValue >> 24) & 0xff);
                } else {
                    valuesCache[0] = (byte) ((longValue >> 24) & 0xff);
                    valuesCache[1] = (byte) ((longValue >> 16) & 0xff);
                    valuesCache[2] = (byte) ((longValue >> 8) & 0xff);
                    valuesCache[3] = (byte) (longValue & 0xff);
                }
                modifyValues(4);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_intTextFieldKeyReleased

    private void longTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_longTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                ByteOrder byteOrder = getByteOrder();
                if (isSigned()) {
                    long longValue = Long.parseLong(longTextField.getText());

                    byteBuffer.rewind();
                    if (byteBuffer.order() != byteOrder) {
                        byteBuffer.order(byteOrder);
                    }

                    byteBuffer.putLong(longValue);
                } else {
                    BigInteger bigInteger = new BigInteger(longTextField.getText());
                    if (bigInteger.signum() == -1 || bigInteger.compareTo(ULONG_MAX_VALUE) > 0) {
                        throw new NumberFormatException(VALUE_OUT_OF_RANGE);
                    }

                    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
                        for (int i = 0; i < 7; i++) {
                            BigInteger nextByte = bigInteger.and(BIG_INTEGER_BYTE_MASK);
                            valuesCache[7 - i] = nextByte.byteValue();
                            bigInteger = bigInteger.shiftRight(8);
                        }
                    } else {
                        for (int i = 0; i < 7; i++) {
                            BigInteger nextByte = bigInteger.and(BIG_INTEGER_BYTE_MASK);
                            valuesCache[i] = nextByte.byteValue();
                            bigInteger = bigInteger.shiftRight(8);
                        }
                    }
                }

                modifyValues(8);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_longTextFieldKeyReleased

    private void floatTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_floatTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                ByteOrder byteOrder = getByteOrder();
                float floatValue = Float.parseFloat(floatTextField.getText());

                byteBuffer.rewind();
                if (byteBuffer.order() != byteOrder) {
                    byteBuffer.order(byteOrder);
                }

                byteBuffer.putFloat(floatValue);

                modifyValues(4);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_floatTextFieldKeyReleased

    private void doubleTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_doubleTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                ByteOrder byteOrder = getByteOrder();
                double doubleValue = Double.parseDouble(doubleTextField.getText());

                byteBuffer.rewind();
                if (byteBuffer.order() != byteOrder) {
                    byteBuffer.order(byteOrder);
                }

                byteBuffer.putDouble(doubleValue);

                modifyValues(8);
                updateValues();
            } catch (NumberFormatException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_doubleTextFieldKeyReleased

    private void characterTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_characterTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                String characterText = characterTextField.getText();
                if (characterText.length() == 0) {
                    throw new InputMismatchException("Empty value not valid");
                }

                if (characterText.length() > 1) {
                    throw new InputMismatchException("Only single character allowed");
                }

                byte[] bytes = characterText.getBytes(codeArea.getCharset());
                System.arraycopy(bytes, 0, valuesCache, 0, bytes.length);

                modifyValues(bytes.length);
                updateValues();
            } catch (InputMismatchException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_characterTextFieldKeyReleased

    private void stringTextFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_stringTextFieldKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER && isEditable()) {
            try {
                String characterText = stringTextField.getText();
                if (characterText.length() == 0) {
                    throw new InputMismatchException("Empty value not valid");
                }

                byte[] bytes = characterText.getBytes(codeArea.getCharset());
                if (bytes.length > CACHE_SIZE) {
                    throw new InputMismatchException("String is too long");
                }
                System.arraycopy(bytes, 0, valuesCache, 0, bytes.length);

                modifyValues(bytes.length);
                updateValues();
            } catch (InputMismatchException ex) {
                showException(ex);
            }
        }
    }//GEN-LAST:event_stringTextFieldKeyReleased

    public void setCodeArea(CodeArea codeArea) {
        this.codeArea = codeArea;
    }

    public void enableUpdate() {
        dataChangedListener = () -> {
            updateEditMode();
            updateValues();
        };
        codeArea.addDataChangedListener(dataChangedListener);
        caretMovedListener = (CodeAreaCaretPosition caretPosition) -> updateValues();
        codeArea.addCaretMovedListener(caretMovedListener);
        updateEditMode();
        updateValues();
    }

    public void disableUpdate() {
        codeArea.removeDataChangedListener(dataChangedListener);
        codeArea.removeCaretMovedListener(caretMovedListener);
    }

    public void updateEditMode() {
        boolean editable = isEditable();
        binaryCheckBox0.setEnabled(editable);
        binaryCheckBox1.setEnabled(editable);
        binaryCheckBox2.setEnabled(editable);
        binaryCheckBox3.setEnabled(editable);
        binaryCheckBox4.setEnabled(editable);
        binaryCheckBox5.setEnabled(editable);
        binaryCheckBox6.setEnabled(editable);
        binaryCheckBox7.setEnabled(editable);
        byteTextField.setEditable(editable);
        wordTextField.setEditable(editable);
        intTextField.setEditable(editable);
        longTextField.setEditable(editable);
        floatTextField.setEditable(editable);
        doubleTextField.setEditable(editable);
        characterTextField.setEditable(editable);
        stringTextField.setEditable(editable);
    }

    public void updateValues() {
        CodeAreaCaretPosition caretPosition = codeArea.getCaretPosition();
        dataPosition = caretPosition.getDataPosition();
        long dataSize = codeArea.getDataSize();

        if (dataPosition < dataSize) {
            int availableData = dataSize - dataPosition >= CACHE_SIZE ? CACHE_SIZE : (int) (dataSize - dataPosition);
            BinaryData contentData = Objects.requireNonNull(codeArea.getContentData());
            contentData.copyToArray(dataPosition, valuesCache, 0, availableData);
            if (availableData < CACHE_SIZE) {
                Arrays.fill(valuesCache, availableData, CACHE_SIZE, (byte) 0);
            }
        }

        valuesUpdater.schedule();
    }

    private void modifyValues(int bytesCount) {
        // Unsupported in this version
    }

    private boolean isSigned() {
        return signedRadioButton.isSelected();
    }

    private boolean isEditable() {
        return ((EditModeCapable) codeArea).isEditable();
    }

    private ByteOrder getByteOrder() {
        return littleEndianRadioButton.isSelected() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
    }

    private void showException(Exception ex) {
        JOptionPane.showMessageDialog(this, ex.getMessage(), "Invalid Input", JOptionPane.ERROR_MESSAGE);
    }

    public enum ValuesPanelField {
        BINARY0,
        BINARY1,
        BINARY2,
        BINARY3,
        BINARY4,
        BINARY5,
        BINARY6,
        BINARY7,
        BYTE,
        WORD,
        INTEGER,
        LONG,
        FLOAT,
        DOUBLE,
        CHARACTER,
        STRING
    }

    @ParametersAreNonnullByDefault
    private class ValuesUpdater {

        private boolean updateInProgress = false;
        private boolean updateTerminated = false;
        private boolean scheduleUpdate = false;
        private boolean clearFields = true;

        private boolean signed;
        private ByteOrder byteOrder;
        private byte[] values;

        private synchronized void schedule() {
            if (updateInProgress) {
                updateTerminated = true;
            }
            if (!scheduleUpdate) {
                scheduleUpdate = true;
                scheduleNextStep(ValuesPanelField.values()[0]);
            }
        }

        private void scheduleNextStep(final ValuesPanelField valuesPanelField) {
            SwingUtilities.invokeLater(() -> updateValue(valuesPanelField));
        }

        public boolean isUpdateInProgress() {
            return updateInProgress;
        }

        private void updateValue(final ValuesPanelField valuesPanelField) {
            if (valuesPanelField.ordinal() == 0) {
                long dataSize = codeArea.getDataSize();
                clearFields = dataPosition >= dataSize;
                byteOrder = littleEndianRadioButton.isSelected() ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;
                byteOrder = getByteOrder();
                signed = isSigned();
                values = valuesCache;
                if (clearFields) {
                    values[0] = 0;
                }
                updateStarted();
            }

            if (updateTerminated) {
                stopUpdate();
                return;
            }

            if (clearFields) {
                clearField(valuesPanelField);
            } else {
                updateField(valuesPanelField);
            }

            final ValuesPanelField[] panelFields = ValuesPanelField.values();
            ValuesPanelField lastValue = panelFields[panelFields.length - 1];
            if (valuesPanelField == lastValue) {
                stopUpdate();
            } else {
                SwingUtilities.invokeLater(() -> {
                    ValuesPanelField nextValue = panelFields[valuesPanelField.ordinal() + 1];
                    updateValue(nextValue);
                });
            }
        }

        private void updateField(ValuesPanelField valuesPanelField) {
            switch (valuesPanelField) {
                case BINARY0: {
                    binaryCheckBox0.setSelected((values[0] & 0x80) > 0);
                    break;
                }
                case BINARY1: {
                    binaryCheckBox1.setSelected((values[0] & 0x40) > 0);
                    break;
                }
                case BINARY2: {
                    binaryCheckBox2.setSelected((values[0] & 0x20) > 0);
                    break;
                }
                case BINARY3: {
                    binaryCheckBox3.setSelected((values[0] & 0x10) > 0);
                    break;
                }
                case BINARY4: {
                    binaryCheckBox4.setSelected((values[0] & 0x8) > 0);
                    break;
                }
                case BINARY5: {
                    binaryCheckBox5.setSelected((values[0] & 0x4) > 0);
                    break;
                }
                case BINARY6: {
                    binaryCheckBox6.setSelected((values[0] & 0x2) > 0);
                    break;
                }
                case BINARY7: {
                    binaryCheckBox7.setSelected((values[0] & 0x1) > 0);
                    break;
                }
                case BYTE: {
                    byteTextField.setText(String.valueOf(signed ? values[0] : values[0] & 0xff));
                    break;
                }
                case WORD: {
                    int wordValue = signed
                            ? (byteOrder == ByteOrder.LITTLE_ENDIAN
                                    ? (values[0] & 0xff) | (values[1] << 8)
                                    : (values[1] & 0xff) | (values[0] << 8))
                            : (byteOrder == ByteOrder.LITTLE_ENDIAN
                                    ? (values[0] & 0xff) | ((values[1] & 0xff) << 8)
                                    : (values[1] & 0xff) | ((values[0] & 0xff) << 8));
                    wordTextField.setText(String.valueOf(wordValue));
                    break;
                }
                case INTEGER: {
                    long intValue = signed
                            ? (byteOrder == ByteOrder.LITTLE_ENDIAN
                                    ? (values[0] & 0xffL) | ((values[1] & 0xffL) << 8) | ((values[2] & 0xffL) << 16) | (values[3] << 24)
                                    : (values[3] & 0xffL) | ((values[2] & 0xffL) << 8) | ((values[1] & 0xffL) << 16) | (values[0] << 24))
                            : (byteOrder == ByteOrder.LITTLE_ENDIAN
                                    ? (values[0] & 0xffL) | ((values[1] & 0xffL) << 8) | ((values[2] & 0xffL) << 16) | ((values[3] & 0xffL) << 24)
                                    : (values[3] & 0xffL) | ((values[2] & 0xffL) << 8) | ((values[1] & 0xffL) << 16) | ((values[0] & 0xffL) << 24));
                    intTextField.setText(String.valueOf(intValue));
                    break;
                }
                case LONG: {
                    if (signed) {
                        byteBuffer.rewind();
                        if (byteBuffer.order() != byteOrder) {
                            byteBuffer.order(byteOrder);
                        }

                        longTextField.setText(String.valueOf(byteBuffer.getLong()));
                    } else {
                        long longValue = byteOrder == ByteOrder.LITTLE_ENDIAN
                                ? (values[0] & 0xffL) | ((values[1] & 0xffL) << 8) | ((values[2] & 0xffL) << 16) | ((values[3] & 0xffL) << 24)
                                | ((values[4] & 0xffL) << 32) | ((values[5] & 0xffL) << 40) | ((values[6] & 0xffL) << 48)
                                : (values[7] & 0xffL) | ((values[6] & 0xffL) << 8) | ((values[5] & 0xffL) << 16) | ((values[4] & 0xffL) << 24)
                                | ((values[3] & 0xffL) << 32) | ((values[2] & 0xffL) << 40) | ((values[1] & 0xffL) << 48);
                        BigInteger bigInt1 = BigInteger.valueOf(values[byteOrder == ByteOrder.LITTLE_ENDIAN ? 7 : 0] & 0xffL);
                        BigInteger bigInt2 = bigInt1.shiftLeft(56);
                        BigInteger bigInt3 = bigInt2.add(BigInteger.valueOf(longValue));
                        longTextField.setText(bigInt3.toString());
                    }
                    break;
                }
                case FLOAT: {
                    byteBuffer.rewind();
                    if (byteBuffer.order() != byteOrder) {
                        byteBuffer.order(byteOrder);
                    }

                    floatTextField.setText(String.valueOf(byteBuffer.getFloat()));
                    break;
                }
                case DOUBLE: {
                    byteBuffer.rewind();
                    if (byteBuffer.order() != byteOrder) {
                        byteBuffer.order(byteOrder);
                    }

                    doubleTextField.setText(String.valueOf(byteBuffer.getDouble()));
                    break;
                }
                case CHARACTER: {
                    String strValue = new String(values, codeArea.getCharset());
                    if (strValue.length() > 0) {
                        characterTextField.setText(strValue.substring(0, 1));
                    } else {
                        characterTextField.setText("");
                    }
                    break;
                }
                case STRING: {
                    String strValue = new String(values, codeArea.getCharset());
                    for (int i = 0; i < strValue.length(); i++) {
                        char charAt = strValue.charAt(i);
                        if (charAt == '\r' || charAt == '\n' || charAt == 0) {
                            strValue = strValue.substring(0, i);
                            break;
                        }
                    }
                    stringTextField.setText(strValue);
                    stringTextField.setCaretPosition(0);
                    break;
                }
            }
        }

        private void clearField(ValuesPanelField valuesPanelField) {
            switch (valuesPanelField) {
                case BINARY0: {
                    binaryCheckBox0.setSelected(false);
                    break;
                }
                case BINARY1: {
                    binaryCheckBox1.setSelected(false);
                    break;
                }
                case BINARY2: {
                    binaryCheckBox2.setSelected(false);
                    break;
                }
                case BINARY3: {
                    binaryCheckBox3.setSelected(false);
                    break;
                }
                case BINARY4: {
                    binaryCheckBox4.setSelected(false);
                    break;
                }
                case BINARY5: {
                    binaryCheckBox5.setSelected(false);
                    break;
                }
                case BINARY6: {
                    binaryCheckBox6.setSelected(false);
                    break;
                }
                case BINARY7: {
                    binaryCheckBox7.setSelected(false);
                    break;
                }
                case BYTE: {
                    byteTextField.setText("");
                    break;
                }
                case WORD: {
                    wordTextField.setText("");
                    break;
                }
                case INTEGER: {
                    intTextField.setText("");
                    break;
                }
                case LONG: {
                    longTextField.setText("");
                    break;
                }
                case FLOAT: {
                    floatTextField.setText("");
                    break;
                }
                case DOUBLE: {
                    doubleTextField.setText("");
                    break;
                }
                case CHARACTER: {
                    characterTextField.setText("");
                    break;
                }
                case STRING: {
                    stringTextField.setText("");
                    break;
                }
            }
        }

        private synchronized void updateStarted() {
            updateInProgress = true;
            scheduleUpdate = false;
        }

        private synchronized void stopUpdate() {
            updateInProgress = false;
            updateTerminated = false;
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/plugins/GraphicalReflectionKit.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.plugins;

import java.awt.BorderLayout;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTabbedPane;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A graphical way to execute reflection.
 *
 * @author Konloch
 */

public class GraphicalReflectionKit extends JFrame
{
    public GraphicalReflectionKit()
    {
        this.setIconImages(IconResources.iconList);
        setSize(new Dimension(382, 356));
        setTitle("Graphical Reflection Kit");

        JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
        getContentPane().add(tabbedPane, BorderLayout.CENTER);

        JPanel panel = new JPanel();
        tabbedPane.addTab("Invoke Method", null, panel, null);

        JPanel panel_1 = new JPanel();
        tabbedPane.addTab("Get Field Value", null, panel_1, null);

        JPanel panel_2 = new JPanel();
        tabbedPane.addTab("Cast Field", null, panel_2, null);
    }

    private static final long serialVersionUID = 6728356108271228236L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/plugins/MaliciousCodeScannerOptions.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.plugins;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScanModule;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.MaliciousCodeOptions;
import the.bytecode.club.bytecodeviewer.plugin.PluginManager;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.MaliciousCodeScanner;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * This GUI automatically populates the scan options from the MalwareScanModule enum.
 *
 * @author Konloch
 */

public class MaliciousCodeScannerOptions extends JFrame
{
    private static final int SPACER_HEIGHT_BETWEEN_OPTIONS = 26;
    
    public static void open()
    {
        if (BytecodeViewer.promptIfNoLoadedClasses())
            return;
        
        new MaliciousCodeScannerOptions().setVisible(true);
    }
    
    public MaliciousCodeScannerOptions()
    {
        this.setIconImages(IconResources.iconList);
        setSize(new Dimension(250, 7 + (MalwareScanModule.values().length * SPACER_HEIGHT_BETWEEN_OPTIONS) + 90));
        setResizable(false);
        setTitle("Malicious Code Scanner Options");
        getContentPane().setLayout(null);
        List<MaliciousCodeOptions> checkBoxes = new ArrayList<>();
        
        int y = 7;
        for(MalwareScanModule module : MalwareScanModule.values())
        {
            final JCheckBox checkBox = new JCheckBox(module.getOptionText());
            checkBox.setSelected(module.isToggledByDefault());
            checkBox.setBounds(6, y, 232, 23);
            getContentPane().add(checkBox);
            checkBoxes.add(new MaliciousCodeOptions(module, checkBox));
            
            y += SPACER_HEIGHT_BETWEEN_OPTIONS;
        }
    
        JButton btnNewButton = new JButton("Start Scanning");
        btnNewButton.addActionListener(arg0 -> {
            PluginManager.runPlugin(new MaliciousCodeScanner(checkBoxes));
            dispose();
        });

        btnNewButton.setBounds(6, y, 232, 23);
        getContentPane().add(btnNewButton);
        this.setLocationRelativeTo(null);
    }

    private static final long serialVersionUID = -2662514582647810868L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/plugins/ReplaceStringsOptions.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.plugins;

import java.awt.Dimension;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.plugin.PluginManager;
import the.bytecode.club.bytecodeviewer.plugin.preinstalled.ReplaceStrings;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The UI for replace strings plugin.
 *
 * @author Konloch
 */

public class ReplaceStringsOptions extends JFrame
{
    public static void open()
    {
        if (BytecodeViewer.promptIfNoLoadedClasses())
            return;
        
        new ReplaceStringsOptions().setVisible(true);
    }
    
    public ReplaceStringsOptions()
    {
        this.setIconImages(IconResources.iconList);
        setSize(new Dimension(250, 176));
        setResizable(false);
        setTitle("Replace Strings");
        getContentPane().setLayout(null);

        JButton btnNewButton = new JButton("Start Replacing");
        btnNewButton.setBounds(6, 115, 232, 23);
        getContentPane().add(btnNewButton);

        JLabel lblNewLabel = new JLabel("Original LDC:");
        lblNewLabel.setBounds(6, 40, 67, 14);
        getContentPane().add(lblNewLabel);

        originalLDC = new JTextField();
        originalLDC.setBounds(80, 37, 158, 20);
        getContentPane().add(originalLDC);
        originalLDC.setColumns(10);

        JLabel lblNewLabel_1 = new JLabel("New LDC:");
        lblNewLabel_1.setBounds(6, 65, 77, 14);
        getContentPane().add(lblNewLabel_1);

        newLDC = new JTextField();
        newLDC.setColumns(10);
        newLDC.setBounds(80, 62, 158, 20);
        getContentPane().add(newLDC);

        JLabel lblNewLabel_2 = new JLabel("Class:");
        lblNewLabel_2.setBounds(6, 90, 46, 14);
        getContentPane().add(lblNewLabel_2);

        classToReplaceIn = new JTextField();
        classToReplaceIn.setToolTipText("* will search all classes");
        classToReplaceIn.setText("*");
        classToReplaceIn.setBounds(80, 87, 158, 20);
        getContentPane().add(classToReplaceIn);
        classToReplaceIn.setColumns(10);

        final JCheckBox chckbxNewCheckBox = new JCheckBox("Replace All Contains");
        chckbxNewCheckBox.setToolTipText("If it's unticked, it will check if the string equals, if its ticked it will check if"
                        + " it contains, then replace the original LDC part of the string.");
        chckbxNewCheckBox.setBounds(6, 7, 232, 23);
        getContentPane().add(chckbxNewCheckBox);
        btnNewButton.addActionListener(arg0 -> {
            PluginManager.runPlugin(new ReplaceStrings(originalLDC.getText(),
                    newLDC.getText(), classToReplaceIn.getText(),
                    chckbxNewCheckBox.isSelected()));
            dispose();
        });
        
        this.setLocationRelativeTo(null);
    }

    private static final long serialVersionUID = -2662514582647810868L;
    private final JTextField originalLDC;
    private final JTextField newLDC;
    private final JTextField classToReplaceIn;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcelist/ResourceListIconRenderer.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcelist;

import java.awt.Component;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.ImageIcon;
import javax.swing.JTree;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.TreeNode;
import org.apache.commons.io.FilenameUtils;
import the.bytecode.club.bytecodeviewer.resources.IconResources;
import the.bytecode.club.bytecodeviewer.resources.ResourceType;

/**
 * @author http://stackoverflow.com/questions/14968005
 * @author Konloch
 */

public class ResourceListIconRenderer extends DefaultTreeCellRenderer
{
	//TODO the icon cache needs to be cleared on treenode removal
	public static Map<ResourceTreeNode, ImageIcon> iconCache = new HashMap<>();
	
	//called every time there is a pane update
	@Override
	public Component getTreeCellRendererComponent(
			JTree tree, Object value,
			boolean sel, boolean expanded, boolean leaf,
			int row, boolean hasFocus)
	{
		Component ret = super.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
		
		if (value instanceof ResourceTreeNode)
		{
			if (iconCache.containsKey(value))
			{
				setIcon(iconCache.get(value));
				return ret;
			}
			
			ResourceTreeNode node = (ResourceTreeNode) value;
			
			String nameOG = node.toString();
			String name = nameOG.toLowerCase();
			String onlyName = FilenameUtils.getName(name);
			boolean iconSet = false;
			
			//guess file type based on extension
			ResourceType knownResourceType = onlyName.contains(":") ? null
					: ResourceType.extensionMap.get(FilenameUtils.getExtension(onlyName).toLowerCase());
			
			//set the icon to a known file type
			if (knownResourceType != null
					//check if is parent/root node, or not a directory
					&& (node.getParent() == node.getRoot()
					|| node.getChildCount() == 0))
			{
				cacheNodeIcon(node, knownResourceType.getIcon());
				iconSet = true;
			}
			//hardcoded resource icons go here
			else if (nameOG.equals("Decoded Resources") && node.getChildCount() > 0)
			{
				cacheNodeIcon(node, IconResources.decodedIcon);
				iconSet = true;
			}
			else if (node.getChildCount() == 0
					&& (nameOG.equals("README")
					|| nameOG.equals("LICENSE")
					|| nameOG.equals("NOTICE")))
			{
				cacheNodeIcon(node, IconResources.textIcon);
				iconSet = true;
			}
			
			//folders
			if (node.getChildCount() > 0)
			{
				List<TreeNode> nodes = new ArrayList<>();
				List<TreeNode> totalNodes = new ArrayList<>();
				
				nodes.add(node);
				totalNodes.add(node);
				
				boolean isJava = false;
				boolean finished = false;
				
				while (!finished)
				{ //may cause a clusterfuck with huge files
					if (nodes.isEmpty())
						finished = true;
					else
					{
						TreeNode treeNode = nodes.get(0);
						nodes.remove(treeNode);
						int children = treeNode.getChildCount();
						if (children >= 1)
							for (int i = 0; i < children; i++)
							{
								TreeNode child = treeNode.getChildAt(i);
								
								if (!totalNodes.contains(child))
								{
									nodes.add(child);
									totalNodes.add(child);
								}
								
								if (child.toString().endsWith(".class"))
									isJava = true;
							}
						
						if (isJava)
							nodes.clear();
					}
				}
				
				if(!iconSet)
				{
					//java packages
					if (isJava)
						cacheNodeIcon(node, IconResources.packagesIcon);
					else //regular folders
						cacheNodeIcon(node, IconResources.folderIcon);
				}
			}
			
			//unknown files
			else if (knownResourceType == null && !iconSet)
				cacheNodeIcon(node, IconResources.unknownFileIcon);
		}
		
		return ret;
	}
	
	public void cacheNodeIcon(ResourceTreeNode node, ImageIcon icon)
	{
		iconCache.put(node, icon);
		setIcon(icon);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcelist/ResourceListPane.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcelist;

import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.util.Enumeration;
import java.util.Map.Entry;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.JTree;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import me.konloch.kontainer.io.DiskWriter;
import org.apache.commons.io.FilenameUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenu;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.importing.Import;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJCheckBox;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJTextField;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedVisibleComponent;
import the.bytecode.club.bytecodeviewer.util.FileDrop;
import the.bytecode.club.bytecodeviewer.util.LazyNameUtil;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The file navigation pane.
 *
 * @author Konloch
 * @author WaterWolf
 * @author afffsdd
 * @since 09/26/2011
 */

public class ResourceListPane extends TranslatedVisibleComponent implements FileDrop.Listener
{
    public final JPopupMenu rightClickMenu = new JPopupMenu();
    public final JCheckBox exact = new TranslatedJCheckBox("Exact path", TranslatedComponents.EXACT_PATH);
    public final JCheckBox caseSensitive = new TranslatedJCheckBox("Match case", TranslatedComponents.MATCH_CASE);
    public final JButton open = new JButton("+");
    public final JButton close = new JButton("-");
    public final ResourceTreeNode treeRoot = new ResourceTreeNode("Loaded Files:");
    public final ResourceTree tree = new ResourceTree(treeRoot);
    public final JTextField quickSearch = new TranslatedJTextField("Quick file search (no file extension)", TranslatedComponents.QUICK_FILE_SEARCH_NO_FILE_EXTENSION);
    public final FileDrop fileDrop;
    public boolean cancel = false;
    
    public final KeyAdapter search = new SearchKeyAdapter(this);
    
    private void showContextMenu(ResourceTree tree, TreePath selPath, int x, int y)
    {
        if (selPath == null)
            return;
    
        ContextMenu.buildMenu(tree, selPath, null, rightClickMenu);
        rightClickMenu.show(this.tree, x, y);
    }
    
    //used to remove resources from the resource list
    public void removeFile(ResourceContainer resourceContainer)
    {
        while (BytecodeViewer.resourceContainers.values().remove(resourceContainer));
        LazyNameUtil.removeName(resourceContainer.name);
    }
    
    public ResourceListPane()
    {
        super("Files", TranslatedComponents.FILES);
        
        tree.setRootVisible(false);
        tree.setShowsRootHandles(true);
        quickSearch.setForeground(quickSearch.getDisabledTextColor());
    
        attachTreeListeners();
        attachQuickSearchListeners();
    
        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(new JScrollPane(tree), BorderLayout.CENTER);
    
        JPanel exactPanel = new JPanel(new BorderLayout());
        JPanel quickSearchPanel = new JPanel();
        JPanel buttonPanel = new JPanel(new BorderLayout());
        
        quickSearchPanel.setLayout(new BorderLayout());
        quickSearchPanel.add(quickSearch, BorderLayout.CENTER);

        JPanel btns = new JPanel(new FlowLayout());
        btns.add(exact);
        btns.add(caseSensitive);
        exactPanel.add(btns, BorderLayout.WEST);

        buttonPanel.add(open, BorderLayout.EAST);
        buttonPanel.add(close, BorderLayout.WEST);
        quickSearchPanel.add(buttonPanel, BorderLayout.EAST);
        quickSearchPanel.add(exactPanel, BorderLayout.SOUTH);
    
        getContentPane().add(quickSearchPanel, BorderLayout.SOUTH);
    
        this.setVisible(true);
        fileDrop = new FileDrop(this, this);
    }
    
    @Override
    public void filesDropped(final File[] files)
    {
        if (files.length < 1)
            return;
        
        BytecodeViewer.openFiles(files, true);
    }
    
    public void addResourceContainer(ResourceContainer container)
    {
        ResourceTreeNode root = container.treeNode = new ResourceTreeNode(container.name);
    
        treeRoot.add(root);
        tree.setCellRenderer(new ResourceListIconRenderer());
        
        buildTree(container, root);
    
        treeRoot.sort();
        
        tree.expandPath(new TreePath(tree.getModel().getRoot()));
        tree.updateUI();
    
        //TODO add a setting to expand on resource import
        // expandAll(tree, true);
    }
    
    public void removeResource(ResourceContainer container)
    {
        container.treeNode.removeFromParent();
        tree.updateUI();
    }
    
    private void buildTree(ResourceContainer container, ResourceTreeNode root)
    {
        if (!container.resourceClasses.isEmpty())
        {
            for (String name : container.resourceClasses.keySet())
            {
                final String[] spl = name.split("/");
                if (spl.length < 2)
                {
                    root.add(new ResourceTreeNode(name + ".class"));
                }
                else
                {
                    ResourceTreeNode parent = root;
                    for (int i1 = 0; i1 < spl.length; i1++)
                    {
                        String s = spl[i1];
                    
                        if (i1 == spl.length - 1)
                            s += ".class";
                    
                        ResourceTreeNode child = null;
                        for (int i = 0; i < parent.getChildCount(); i++)
                        {
                            if (((ResourceTreeNode) parent.getChildAt(i)).getUserObject().equals(s))
                            {
                                child = (ResourceTreeNode) parent.getChildAt(i);
                                break;
                            }
                        }
                    
                        if (child == null)
                        {
                            child = new ResourceTreeNode(s);
                            parent.add(child);
                        }
                    
                        parent = child;
                    }
                }
            }
        }
    
        if (!container.resourceFiles.isEmpty())
        {
            for (final Entry<String, byte[]> entry : container.resourceFiles.entrySet())
            {
                String name = entry.getKey();
                final String[] spl = name.split("/");
                if (spl.length < 2)
                {
                    root.add(new ResourceTreeNode(name));
                }
                else
                {
                    ResourceTreeNode parent = root;
                    for (final String s : spl)
                    {
                        ResourceTreeNode child = null;
                        for (int i = 0; i < parent.getChildCount(); i++)
                        {
                            if (((ResourceTreeNode) parent.getChildAt(i)).getUserObject().equals(s))
                            {
                                child = (ResourceTreeNode) parent.getChildAt(i);
                                break;
                            }
                        }
                        if (child == null)
                        {
                            child = new ResourceTreeNode(s);
                            parent.add(child);
                        }
                        parent = child;
                    }
                }
            }
        }
    }

    @SuppressWarnings("rawtypes")
    public void expandAll(final JTree tree, final TreePath parent,
                           final boolean expand) {
        // Traverse children
        final TreeNode node = (TreeNode) parent.getLastPathComponent();
        if (node.getChildCount() >= 0) {
            for (final Enumeration e = node.children(); e.hasMoreElements(); ) {
                final TreeNode n = (TreeNode) e.nextElement();
                final TreePath path = parent.pathByAddingChild(n);
                expandAll(tree, path, expand);
            }
        }

        // Expansion or collapse must be done bottom-up
        if (expand) {
            tree.expandPath(parent);
        } else {
            tree.collapsePath(parent);
        }
    }

    public void removeNode(final JTree tree, final TreePath nodePath) {
        MutableTreeNode node = findNodeByPath(nodePath);
        if (node == null)
            return;
        
        node.removeFromParent();
        tree.repaint();
        tree.updateUI();
    }
    
    private MutableTreeNode findNodeByPath(TreePath path) {
        MutableTreeNode node = treeRoot;
        for (int pathStep = 1; pathStep < path.getPathCount(); pathStep++) {
            TreeNode pathNode = (TreeNode) path.getPathComponent(pathStep);
            int childIndex = node.getIndex(pathNode);
            if (childIndex < 0) {
                return null;
            }
            node = (MutableTreeNode) node.getChildAt(childIndex);
            
            if (node == null) {
                return null;
            }
        }
        
        return node;
    }
    
    public void resetWorkspace()
    {
        treeRoot.removeAllChildren();
        tree.repaint();
        tree.updateUI();
    }
    
    /**
     * Opens and decompiles the TreePath in a new tab
     */
    public void quickDecompile(Decompiler decompiler, TreePath selPath, boolean quickEdit)
    {
        Decompiler tempDecompiler1 = BytecodeViewer.viewer.viewPane1.getSelectedDecompiler();
        boolean editable1 = BytecodeViewer.viewer.viewPane1.isPaneEditable();
        Decompiler tempDecompiler2 = BytecodeViewer.viewer.viewPane2.getSelectedDecompiler();
        boolean editable2 = BytecodeViewer.viewer.viewPane2.isPaneEditable();
        Decompiler tempDecompiler3 = BytecodeViewer.viewer.viewPane3.getSelectedDecompiler();
        boolean editable3 = BytecodeViewer.viewer.viewPane3.isPaneEditable();
    
        BytecodeViewer.viewer.viewPane1.setSelectedDecompiler(decompiler);
        BytecodeViewer.viewer.viewPane1.setPaneEditable(quickEdit);
        BytecodeViewer.viewer.viewPane2.setSelectedDecompiler(Decompiler.NONE);
        BytecodeViewer.viewer.viewPane2.setPaneEditable(false);
        BytecodeViewer.viewer.viewPane3.setSelectedDecompiler(Decompiler.NONE);
        BytecodeViewer.viewer.viewPane3.setPaneEditable(false);
        
        openPath(selPath);
    
        BytecodeViewer.viewer.viewPane1.setSelectedDecompiler(tempDecompiler1);
        BytecodeViewer.viewer.viewPane1.setPaneEditable(editable1);
        BytecodeViewer.viewer.viewPane2.setSelectedDecompiler(tempDecompiler2);
        BytecodeViewer.viewer.viewPane2.setPaneEditable(editable2);
        BytecodeViewer.viewer.viewPane3.setSelectedDecompiler(tempDecompiler3);
        BytecodeViewer.viewer.viewPane3.setPaneEditable(editable3);
    }

    public void openPath(TreePath path)
    {
        if (path == null || path.getPathCount() == 1)
            return;

        final StringBuilder nameBuffer = new StringBuilder();
        for (int i = 2; i < path.getPathCount(); i++)
        {
            nameBuffer.append(path.getPathComponent(i));
            if (i < path.getPathCount() - 1)
                nameBuffer.append("/");
        }

        String cheapHax = path.getPathComponent(1).toString();
        ResourceContainer container = null;

        for (ResourceContainer c : BytecodeViewer.resourceContainers.values())
        {
            if (c.name.equals(cheapHax))
                container = c;
        }
        
        String name = nameBuffer.toString();
        
        boolean resourceMode = false;
        byte[] content = container.resourceClassBytes.get(name);
        
        if(content == null)
        {
            content = container.resourceFiles.get(name);
            resourceMode = true;
        }
        
        //view classes
        if (content != null && MiscUtils.getFileHeaderMagicNumber(content).equalsIgnoreCase("cafebabe")
                || name.endsWith(".class"))
        {
            try
            {
                if(resourceMode)
                {
                    //TODO load this cn into the resource viewer
                    //final ClassNode cn = ASMUtil.bytesToNode(content);
                }
                
                //display via name
                BytecodeViewer.viewer.workPane.addClassResource(container, name);
            }
            catch (Exception e)
            {
                e.printStackTrace();
                BytecodeViewer.viewer.workPane.addFileResource(container, name);
            }
        }
        //view non-classfile resources
        else if(container.resourceFiles.containsKey(name))
        {
            final String fn = name.toLowerCase();
            final String extension = fn.contains(":") ? null : FilenameUtils.getExtension(fn);
    
            Import imp = Import.extensionMap.get(extension);
            if(imp == null) //show images, text files, or hex view
                BytecodeViewer.viewer.workPane.addFileResource(container, name);
            else //attempt to import known resources
            {
                int hash = (container.name + name).hashCode();
                
                //TODO make a settings toggle to disable preservation of the original name
                // it should also detect if the file name is not compatible with the current OS and enable automatically
                File tempFile = new File(tempDirectory + fs + hash + fs + name + "." + extension);
                if(!tempFile.exists())
                {
                    DiskWriter.replaceFileBytes(tempFile.getAbsolutePath(), content, false);
    
                    try
                    {
                        imp.getImporter().open(tempFile);
                    }
                    catch (Exception e)
                    {
                        e.printStackTrace();
        
                        //failsafe
                        BytecodeViewer.viewer.workPane.addFileResource(container, name);
                    }
                }
                else
                {
                    //alert the user
                }
            }
        }
    }
    
    public void attachTreeListeners()
    {
        tree.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseReleased(MouseEvent e)
            {
                if (e.isMetaDown())
                {
                    ResourceTree tree = (ResourceTree) e.getSource();
                    TreePath selPath = ResourceListPane.this.tree.getClosestPathForLocation(e.getX(), e.getY());
                    
                    if (selPath == null)
                        return;
                    
                    showContextMenu(tree, selPath, e.getX(), e.getY());
                }
            }
        });
    
        this.open.addActionListener(e -> {
            final TreeNode root = (TreeNode) tree.getModel().getRoot();
            expandAll(tree, new TreePath(root), true);
        });
    
        this.close.addActionListener(e -> {
            final TreeNode root = (TreeNode) tree.getModel().getRoot();
            final TreePath path = new TreePath(root);
            expandAll(tree, path, false);
            tree.expandPath(path);
        });
    
        this.tree.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if(e.getButton() == MouseEvent.BUTTON1) //right-click
                    openPath(tree.getPathForLocation(e.getX(), e.getY()));
            }
        });
    
        /*this.tree.addTreeSelectionListener(arg0 -> {
            if (cancel) {
                cancel = false;
                return;
            }
            
            openPath(arg0.getPath());
        });*/
    
        this.tree.addKeyListener(new KeyListener()
        {
            @Override
            public void keyReleased(KeyEvent e) { }
        
            @Override
            public void keyTyped(KeyEvent e) { }
        
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() == KeyEvent.VK_ENTER)
                {
                    if (e.getSource() instanceof ResourceTree)
                    {
                        ResourceTree tree = (ResourceTree) e.getSource();
                        openPath(tree.getSelectionPath());
                    }
                }
                else if ((int) e.getKeyChar() != 0 &&
                        (int) e.getKeyChar() != 8 &&
                        (int) e.getKeyChar() != 127 &&
                        (int) e.getKeyChar() != 65535 &&
                        !e.isControlDown() &&
                        !e.isAltDown())
                {
                    quickSearch.grabFocus();
                    quickSearch.setText("" + e.getKeyChar());
                    cancel = true;
                }
                else if (e.isControlDown() && (int) e.getKeyChar() == 6) //ctrl + f
                    quickSearch.grabFocus();
                else
                    cancel = true;
            }
        });
    }
    
    public void attachQuickSearchListeners()
    {
        quickSearch.addKeyListener(search);
        quickSearch.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(final FocusEvent arg0)
            {
                if (quickSearch.getText().equals(TranslatedStrings.QUICK_FILE_SEARCH_NO_FILE_EXTENSION.toString()))
                {
                    quickSearch.setText("");
                    quickSearch.setForeground(quickSearch.getSelectedTextColor());
                }
            }
        
            @Override
            public void focusLost(final FocusEvent arg0)
            {
                if (quickSearch.getText().isEmpty())
                {
                    quickSearch.setText(TranslatedStrings.QUICK_FILE_SEARCH_NO_FILE_EXTENSION.toString());
                    quickSearch.setForeground(quickSearch.getDisabledTextColor());
                }
            }
        });
    }
    
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcelist/ResourceTree.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcelist;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import the.bytecode.club.bytecodeviewer.gui.util.StringMetricsUtil;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/22/2021
 */
public class ResourceTree extends JTree
{
	private static final long serialVersionUID = -2355167326094772096L;
    DefaultMutableTreeNode treeRoot;
	
	public ResourceTree(final DefaultMutableTreeNode treeRoot)
	{
        super(treeRoot);
        this.treeRoot = treeRoot;
    }
	
	StringMetricsUtil m = null;
	
	@Override
    public void paint(final Graphics graphics)
	{
        try
        {
            Graphics2D g = (Graphics2D) graphics;
            super.paint(g);
            if (m == null)
            {
                m = new StringMetricsUtil(g);
            }
            if (treeRoot.getChildCount() < 1)
            {
                g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
                        RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
                g.setColor(new Color(0, 0, 0, 100));
                g.fillRect(0, 0, getWidth(), getHeight());
                g.setColor(Color.white);
                String s = TranslatedStrings.DRAG_CLASS_JAR.toString();
                g.drawString(s,
                        ((int) ((getWidth() / 2) - (m.getWidth(s) / 2))),
                        getHeight() / 2);
            }
        }
        catch (InternalError | NullPointerException | ClassCastException ignored)
        {
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcelist/ResourceTreeNode.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcelist;

import java.util.Comparator;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreeNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/22/2021
 */
public class ResourceTreeNode extends DefaultMutableTreeNode
{
	
	private static final long serialVersionUID = -8817777566176729571L;
	
	public ResourceTreeNode(final Object o)
	{
		super(o);
	}
	
	@Override
	public void insert(final MutableTreeNode newChild, final int childIndex)
	{
		super.insert(newChild, childIndex);
	}
	
	public void sort()
	{
		recursiveSort(this);
	}
	
	@SuppressWarnings("unchecked")
	private void recursiveSort(final ResourceTreeNode node)
	{
		node.children.sort(nodeComparator);
		for (TreeNode nextNode : (Iterable<TreeNode>) node.children)
		{
			if (nextNode.getChildCount() > 0)
			{
				recursiveSort((ResourceTreeNode) nextNode);
			}
		}
	}
	
	protected Comparator<TreeNode> nodeComparator = new Comparator<TreeNode>()
	{
		@Override
		public int compare(final TreeNode o1, final TreeNode o2)
		{
			// To make sure nodes with children are always on top
			final int firstOffset = o1.getChildCount() > 0 ? -1000 : 0;
			final int secondOffset = o2.getChildCount() > 0 ? 1000 : 0;
			return o1.toString().compareToIgnoreCase(o2.toString())
					+ firstOffset + secondOffset;
		}
		
		@Override
		public boolean equals(final Object obj)
		{
			return false;
		}
		
		@Override
		public int hashCode()
		{
			return 7;
		}
	};
	
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcelist/SearchKeyAdapter.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcelist;

import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Arrays;
import java.util.Enumeration;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/22/2021
 */
public class SearchKeyAdapter extends KeyAdapter {
  private final ResourceListPane resourceListPane;

  public SearchKeyAdapter(ResourceListPane resourceListPane) {
    this.resourceListPane = resourceListPane;
  }

  @Override
  public void keyPressed(final KeyEvent ke) {
    //only trigger on enter
    if (ke.getKeyCode() != KeyEvent.VK_ENTER)
      return;

    String qt = resourceListPane.quickSearch.getText();

    if (qt.trim().isEmpty()) //NOPE
      return;

    String[] path;

    path = qt.split("[\\./]+"); // split at dot or slash
    qt = qt.replace('/', '.');

    ResourceTreeNode curNode = resourceListPane.treeRoot;
    boolean caseSensitive = resourceListPane.caseSensitive.isSelected();

    boolean success = false;
    if (resourceListPane.exact.isSelected()) {
      pathLoop:
      for (int i = 0; i < path.length; i++) {
        final String pathName = path[i];
        final boolean isLast = i == path.length - 1;

        for (int c = 0; c < curNode.getChildCount(); c++) {
          final ResourceTreeNode child = (ResourceTreeNode) curNode.getChildAt(c);
          Object userObject = child.getUserObject();
          if (caseSensitive ? userObject.toString().equals(pathName) : userObject.toString().equalsIgnoreCase(pathName)) {
            curNode = child;
            if (isLast) {
              final TreePath pathn = new TreePath(curNode.getPath());
              resourceListPane.tree.setSelectionPath(pathn);
              resourceListPane.tree.makeVisible(pathn);
              resourceListPane.tree.scrollPathToVisible(pathn);
              resourceListPane.openPath(pathn); //auto open
              success = true;
              break pathLoop;
            }
            continue pathLoop;
          }
        }
        System.out.println("Could not find " + pathName);
        break;
      }
    } else {
      @SuppressWarnings("unchecked")
      Enumeration<TreeNode> enums = curNode.depthFirstEnumeration();
      while (enums != null && enums.hasMoreElements()) {
        ResourceTreeNode node = (ResourceTreeNode) enums.nextElement();
        if (node.isLeaf()) {
          String userObject = (String) (node.getUserObject());
          String lastElem = path[path.length - 1];

          if (caseSensitive ? userObject.contains(lastElem) : userObject.toLowerCase().contains(lastElem.toLowerCase())) {
            TreeNode[] pathArray = node.getPath();
            int k = 0;
            StringBuilder fullPath = new StringBuilder();
            while (pathArray != null
                    && k < pathArray.length) {
              ResourceTreeNode n = (ResourceTreeNode) pathArray[k];
              String s = (String) (n.getUserObject());
              fullPath.append(s);
              if (k++ != pathArray.length - 1) {
                fullPath.append(".");
              }
            }
            String fullPathString = fullPath.toString();

            if (caseSensitive ? fullPathString.contains(qt) : fullPathString.toLowerCase().contains(qt.toLowerCase())) {
              final TreePath pathn = new TreePath(node.getPath());
              resourceListPane.tree.setSelectionPath(pathn.getParentPath());
              resourceListPane.tree.setSelectionPath(pathn);
              resourceListPane.tree.makeVisible(pathn);
              resourceListPane.tree.scrollPathToVisible(pathn);
              success = true;
              break;
            }
          }
        }
      }

    }

    if (!success) {
      Toolkit.getDefaultToolkit().beep();
    }
  }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcesearch/PerformSearch.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcesearch;

import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.swing.tree.TreePath;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.searching.BackgroundSearchThread;
import the.bytecode.club.bytecodeviewer.searching.RegexInsnFinder;
import the.bytecode.club.bytecodeviewer.searching.impl.RegexSearch;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
class PerformSearch extends BackgroundSearchThread
{
	private final SearchBoxPane searchBoxPane;
	
	public PerformSearch(SearchBoxPane searchBoxPane)
	{
		this.searchBoxPane = searchBoxPane;
	}
	
	@Override
	public void search()
	{
		try
		{
			if(RegexSearch.searchText != null)
				Pattern.compile(RegexInsnFinder.processRegex(RegexSearch.searchText.getText()), Pattern.MULTILINE);
		}
		catch (PatternSyntaxException ex)
		{
			BytecodeViewer.showMessage("You have an error in your regex syntax.");
		}
		
		for (ResourceContainer container : BytecodeViewer.resourceContainers.values())
			container.resourceClasses.forEach((key,cn)-> searchBoxPane.searchType.panel.search(container, key, cn, searchBoxPane.exact.isSelected()));
		
		BytecodeViewer.viewer.searchBoxPane.search.setEnabled(true);
		BytecodeViewer.viewer.searchBoxPane.search.setText(TranslatedStrings.SEARCH.toString());
		
		searchBoxPane.tree.expandPath(new TreePath(searchBoxPane.tree.getModel().getRoot()));
		searchBoxPane.tree.updateUI();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcesearch/SearchBoxPane.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcesearch;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Objects;
import javax.swing.*;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.contextmenu.ContextMenu;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ResourceViewer;
import the.bytecode.club.bytecodeviewer.searching.BackgroundSearchThread;
import the.bytecode.club.bytecodeviewer.searching.LDCSearchTreeNodeResult;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedDefaultMutableTreeNode;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJButton;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJCheckBox;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJLabel;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedVisibleComponent;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A pane dedicating to searching the loaded files.
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/29/2011
 */
public class SearchBoxPane extends TranslatedVisibleComponent
{
    public static final SearchRadius[] SEARCH_RADII = SearchRadius.values();
    public static final SearchType[] SEARCH_TYPES = SearchType.values();

    public final JCheckBox exact = new TranslatedJCheckBox("Exact", TranslatedComponents.EXACT);
    public final TranslatedDefaultMutableTreeNode treeRoot = new TranslatedDefaultMutableTreeNode("Results", TranslatedComponents.RESULTS);
    public final JTree tree;
    public final JComboBox<SearchType> typeBox;
    
    public SearchType searchType = null;
    public final JComboBox<SearchRadius> searchRadiusBox;
    public final JPopupMenu rightClickMenu = new JPopupMenu();

    public JButton search = new TranslatedJButton("Search", TranslatedComponents.SEARCH);
    public BackgroundSearchThread performSearchThread;

    public SearchBoxPane()
    {
        super("Search", TranslatedComponents.SEARCH);

        final JPanel optionPanel = new JPanel(new BorderLayout());
        final JPanel searchRadiusOpt = new JPanel(new BorderLayout());
        final JPanel searchOpts = new JPanel(new GridLayout(2, 1));

        searchRadiusOpt.add(new TranslatedJLabel("Search from ", TranslatedComponents.SEARCH_FROM), BorderLayout.WEST);

        DefaultComboBoxModel<SearchRadius> radiusModel = new DefaultComboBoxModel<>();
        
        for (final SearchRadius st : SEARCH_RADII)
            radiusModel.addElement(st);

        searchRadiusBox = new JComboBox<>(radiusModel);
        searchRadiusOpt.add(searchRadiusBox, BorderLayout.CENTER);
        searchOpts.add(searchRadiusOpt);

        DefaultComboBoxModel<SearchType> typeModel = new DefaultComboBoxModel<>();
        for (final SearchType st : SEARCH_TYPES)
            typeModel.addElement(st);

        typeBox = new JComboBox<>(typeModel);
        final JPanel searchOptPanel = new JPanel(new BorderLayout());
        searchOptPanel.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));
        final ItemListener il = arg0 -> {
            searchOptPanel.removeAll();
            searchType = (SearchType) typeBox.getSelectedItem();
            searchOptPanel.add(Objects.requireNonNull(searchType).panel.getPanel(), BorderLayout.CENTER);

            searchOptPanel.revalidate();
            searchOptPanel.repaint();
        };

        typeBox.addItemListener(il);

        typeBox.setSelectedItem(SearchType.Strings);
        il.itemStateChanged(null);

        searchOpts.add(typeBox);

        optionPanel.add(searchOpts, BorderLayout.NORTH);

        JPanel sharedPanel = new JPanel();
        sharedPanel.setLayout(new BorderLayout());
        sharedPanel.add(searchOptPanel, BorderLayout.NORTH);
        sharedPanel.add(exact, BorderLayout.SOUTH);

        optionPanel.add(sharedPanel, BorderLayout.CENTER);

        search.addActionListener(arg0 -> search());

        optionPanel.add(search, BorderLayout.SOUTH);

        this.tree = new JTree(treeRoot);
        treeRoot.setTree((DefaultTreeModel) tree.getModel());

        getContentPane().setLayout(new BorderLayout());

        getContentPane().add(optionPanel, BorderLayout.NORTH);
        getContentPane().add(new JScrollPane(tree), BorderLayout.CENTER);
        
        tree.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseReleased(MouseEvent e)
            {
                //TODO right-click context menu
                if (e.isMetaDown())
                {
                    TreePath selPath = SearchBoxPane.this.tree.getClosestPathForLocation(e.getX(), e.getY());
    
                    if (selPath == null)
                        return;
                    
                    //select the closest path
                    SearchBoxPane.this.tree.clearSelection();
                    SearchBoxPane.this.tree.addSelectionPath(selPath);
                    
                    if(!(tree.getLastSelectedPathComponent() instanceof LDCSearchTreeNodeResult))
                        return;
                    
                    //get selected path
                    LDCSearchTreeNodeResult result = (LDCSearchTreeNodeResult) tree.getLastSelectedPathComponent();
    
                    showContextMenu(result, e.getX(), e.getY());
                }
                else if (e.getButton() == MouseEvent.BUTTON1)
                {
                    if(!(tree.getLastSelectedPathComponent() instanceof  LDCSearchTreeNodeResult))
                        return;
                    
                    LDCSearchTreeNodeResult result = (LDCSearchTreeNodeResult) tree.getLastSelectedPathComponent();
    
                    final String name = result.resourceWorkingName;
    
                    BytecodeViewer.viewer.workPane.addClassResource(result.container, name);
                }
            }
        });

        this.setVisible(true);
    }
    
    public void resetWorkspace()
    {
        treeRoot.removeAllChildren();
        tree.updateUI();
    }

    public void search()
    {
        treeRoot.removeAllChildren();
        searchType = (SearchType) typeBox.getSelectedItem();
        final SearchRadius radius = (SearchRadius) searchRadiusBox.getSelectedItem();
        
        if (radius == SearchRadius.All_Classes)
        {
            if (performSearchThread == null || performSearchThread.finished)
            {
                BytecodeViewer.viewer.searchBoxPane.search.setEnabled(false);
                BytecodeViewer.viewer.searchBoxPane.search.setText("Searching, please wait..");
                
                performSearchThread = new PerformSearch(this);
                performSearchThread.start();
            }
            else
            { // this should really never be called.
                BytecodeViewer.showMessage("You currently have a search performing in the background, please wait for that to finish.");
            }
        }
        else if (radius == SearchRadius.Current_Class)
        {
            final ResourceViewer cv = BytecodeViewer.getActiveResource();
            
            if (cv != null)
                searchType.panel.search(cv.resource.container, cv.resource.workingName, cv.resource.getResourceClassNode(), exact.isSelected());
        }
    }
    
    private void showContextMenu(LDCSearchTreeNodeResult selectedNode, int x, int y)
    {
        if (selectedNode == null)
            return;
        
        ContextMenu.buildMenu(null, null, selectedNode, rightClickMenu);
        rightClickMenu.show(this.tree, x, y);
    }
    
    /**
     * Opens and decompiles the LDCSearchTreeNodeResult in a new tab
     */
    public void quickDecompile(Decompiler decompiler, LDCSearchTreeNodeResult result,  boolean quickEdit)
    {
        Decompiler tempDecompiler1 = BytecodeViewer.viewer.viewPane1.getSelectedDecompiler();
        boolean editable1 = BytecodeViewer.viewer.viewPane1.isPaneEditable();
        Decompiler tempDecompiler2 = BytecodeViewer.viewer.viewPane2.getSelectedDecompiler();
        boolean editable2 = BytecodeViewer.viewer.viewPane2.isPaneEditable();
        Decompiler tempDecompiler3 = BytecodeViewer.viewer.viewPane3.getSelectedDecompiler();
        boolean editable3 = BytecodeViewer.viewer.viewPane3.isPaneEditable();
        
        BytecodeViewer.viewer.viewPane1.setSelectedDecompiler(decompiler);
        BytecodeViewer.viewer.viewPane1.setPaneEditable(quickEdit);
        BytecodeViewer.viewer.viewPane2.setSelectedDecompiler(Decompiler.NONE);
        BytecodeViewer.viewer.viewPane2.setPaneEditable(false);
        BytecodeViewer.viewer.viewPane3.setSelectedDecompiler(Decompiler.NONE);
        BytecodeViewer.viewer.viewPane3.setPaneEditable(false);
    
        BytecodeViewer.viewer.workPane.addClassResource(result.container, result.resourceWorkingName);
        
        BytecodeViewer.viewer.viewPane1.setSelectedDecompiler(tempDecompiler1);
        BytecodeViewer.viewer.viewPane1.setPaneEditable(editable1);
        BytecodeViewer.viewer.viewPane2.setSelectedDecompiler(tempDecompiler2);
        BytecodeViewer.viewer.viewPane2.setPaneEditable(editable2);
        BytecodeViewer.viewer.viewPane3.setSelectedDecompiler(tempDecompiler3);
        BytecodeViewer.viewer.viewPane3.setPaneEditable(editable3);
    }
    
    private static final long serialVersionUID = -1098524689236993932L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcesearch/SearchRadius.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcesearch;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public enum SearchRadius
{
	All_Classes, Current_Class
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourcesearch/SearchType.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourcesearch;

import the.bytecode.club.bytecodeviewer.searching.SearchPanel;
import the.bytecode.club.bytecodeviewer.searching.impl.*;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public enum SearchType
{
	Strings(new LDCSearch()),
	Regex(new RegexSearch()),
	MethodCall(new MethodCallSearch()),
	FieldCall(new FieldCallSearch()),
	MemberWithAnnotation(new MemberWithAnnotationSearch())
	;
	
	public final SearchPanel panel;
	
	SearchType(final SearchPanel panel)
	{
		this.panel = panel;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/BytecodeViewPanel.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer;

import java.awt.BorderLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.compilers.Compiler;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.components.SearchableRSyntaxTextArea;
import the.bytecode.club.bytecodeviewer.gui.components.SystemConsole;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ClassViewer;
import the.bytecode.club.bytecodeviewer.gui.util.BytecodeViewPanelUpdater;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.JarUtils;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Represents a Bytecode/ClassFile View Panel
 *
 * @author Konloch
 * @since 6/24/2021
 */
public class BytecodeViewPanel extends JPanel
{
	public final int panelIndex;
	public final ClassViewer viewer;
	public SearchableRSyntaxTextArea textArea;
	public BytecodeViewPanelUpdater updateThread;
	public Decompiler decompiler = Decompiler.NONE;
	public Compiler compiler = Compiler.JAVA_COMPILER;
	
	public BytecodeViewPanel(int panelIndex, ClassViewer viewer)
	{
		super(new BorderLayout());
		this.panelIndex = panelIndex;
		this.viewer = viewer;
	}
	
	public void createPane(ClassViewer viewer)
	{
		removeAll();
		textArea = null;
		
		if(viewer.resource == null)
			add(new JLabel("ERROR: Resource Viewer Missing Resource"));

		//TODO remove when bcel support is added
		else if(viewer.resource.getResourceClassNode() == null)
			add(new JLabel("ERROR: Resource Viewer Missing ClassNode"));
	}
	
	public void updatePane(ClassViewer cv, byte[] b, JButton button, boolean isPanelEditable)
	{
		updateThread = new BytecodeViewPanelUpdater(this, cv, b, isPanelEditable, button);
	}
	
	public boolean compile()
	{
		if(textArea == null || !textArea.isEditable())
			return true;
		
		SystemConsole errConsole = new SystemConsole(TranslatedStrings.JAVA_COMPILE_FAILED.toString());
		errConsole.setText(TranslatedStrings.ERROR_COMPILING_CLASS + " " + viewer.resource.getResourceClassNode().name +
				nl + TranslatedStrings.COMPILER_TIP +
				nl + nl + TranslatedStrings.SUGGESTED_FIX_COMPILER_ERROR +
				nl + nl);
		
		try
		{
			String text = textArea.getText();
			byte[] compiledClass = compiler.getCompiler().compile(text, viewer.resource.getResourceClassNode().name);
			
			if (compiledClass != null)
			{
				ClassNode newNode = JarUtils.getNode(compiledClass);
				viewer.resource.container.updateNode(viewer.resource.name, newNode);
				errConsole.finished();
				return true;
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		
		errConsole.setVisible(true);
		errConsole.finished();
		return false;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/DecompilerSelectionPane.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import javax.swing.AbstractButton;
import javax.swing.ButtonGroup;
import javax.swing.JMenu;
import javax.swing.JRadioButtonMenuItem;
import javax.swing.JSeparator;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.SettingsSerializer;
import the.bytecode.club.bytecodeviewer.bootloader.BootState;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJMenu;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJRadioButtonMenuItem;

import static the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent.DecompilerComponentType.BYTECODE;
import static the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent.DecompilerComponentType.BYTECODE_NON_EDITABLE;
import static the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent.DecompilerComponentType.JAVA;
import static the.bytecode.club.bytecodeviewer.gui.components.DecompilerViewComponent.DecompilerComponentType.JAVA_AND_BYTECODE;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/21/2021
 */
public class DecompilerSelectionPane
{
	private final int paneID;
	private final JMenu menu;
	private final ButtonGroup group = new ButtonGroup();
	private final JRadioButtonMenuItem none = new TranslatedJRadioButtonMenuItem("None", TranslatedComponents.NONE);
	private final JRadioButtonMenuItem hexcode = new TranslatedJRadioButtonMenuItem("Hexcode", TranslatedComponents.HEXCODE);
	private final DecompilerViewComponent procyon = new DecompilerViewComponent("Procyon", JAVA, Decompiler.PROCYON_DECOMPILER);
	private final DecompilerViewComponent CFR = new DecompilerViewComponent("CFR", JAVA, Decompiler.CFR_DECOMPILER);
	private final DecompilerViewComponent JADX = new DecompilerViewComponent("JADX", JAVA, Decompiler.JADX_DECOMPILER);
	private final DecompilerViewComponent JD = new DecompilerViewComponent("JD-GUI", JAVA, Decompiler.JD_DECOMPILER);
	private final DecompilerViewComponent fern = new DecompilerViewComponent("FernFlower", JAVA, Decompiler.FERNFLOWER_DECOMPILER);
	private final DecompilerViewComponent krakatau = new DecompilerViewComponent( "Krakatau", JAVA_AND_BYTECODE, Decompiler.KRAKATAU_DECOMPILER, Decompiler.KRAKATAU_DISASSEMBLER);
	private final DecompilerViewComponent smali = new DecompilerViewComponent("Smali", BYTECODE, Decompiler.SMALI_DISASSEMBLER);
	private final DecompilerViewComponent bytecode = new DecompilerViewComponent("Bytecode", BYTECODE_NON_EDITABLE, Decompiler.BYTECODE_DISASSEMBLER);
	private final DecompilerViewComponent asmTextify = new DecompilerViewComponent("ASM Textify", BYTECODE_NON_EDITABLE, Decompiler.ASM_TEXTIFY_DISASSEMBLER);
	private final DecompilerViewComponent javap = new DecompilerViewComponent("Javap", BYTECODE_NON_EDITABLE, Decompiler.JAVAP_DISASSEMBLER);
	
	//TODO when adding new decompilers insert the DecompilerViewComponent object into here
	// also in the group, then finally the build menu
	public List<DecompilerViewComponent> components = new ArrayList<>(Arrays.asList(
			procyon, CFR, JADX, JD, fern, krakatau, smali, bytecode, asmTextify, javap));
	
	public DecompilerSelectionPane(int paneID)
	{
		this.paneID = paneID;
		if(paneID == 1)
			this.menu = new TranslatedJMenu("Pane " + 1, TranslatedComponents.PANE_1);
		else if(paneID == 2)
			this.menu = new TranslatedJMenu("Pane " + 2, TranslatedComponents.PANE_2);
		else
			this.menu = new TranslatedJMenu("Pane " + paneID, TranslatedComponents.PANE_3);
		
		buildMenu();
	}
	
	/**
	 * Sets the default decompilers for each pane
	 */
	public void setDefault()
	{
		switch(paneID)
		{
			case 1:
				group.setSelected(fern.getJava().getModel(), true);
				break;
			case 2:
				group.setSelected(bytecode.getBytecode().getModel(), true);
				break;
			case 3:
				group.setSelected(none.getModel(), true);
				break;
		}
	}
	
	/**
	 * Builds the Decompiler View menu
	 */
	public void buildMenu()
	{
		//build the radiobutton group
		group.add(none);
		group.add(hexcode);
		components.forEach(decompilerViewComponent -> decompilerViewComponent.addToGroup(group));
		
		//build the action commands
		none.setActionCommand(Decompiler.NONE.name());
		hexcode.setActionCommand(Decompiler.HEXCODE_VIEWER.name());
		for(DecompilerViewComponent component : components)
		{
			for(Decompiler decompiler : component.getDecompilers())
			{
				String cmd = decompiler.name();
				
				//TODO this is pretty janky and will break if a decompiler doesn't end with _DECOMPILER suffix
				if(cmd.endsWith("DECOMPILER"))
					component.getJava().setActionCommand(cmd);
				else// if(cmd.endsWith("DISASSEMBLER"))
					component.getBytecode().setActionCommand(cmd);
			}
		}
		
		//auto-save on decompiler change
		Enumeration<AbstractButton> it = group.getElements();
		while(it.hasMoreElements())
		{
			AbstractButton button = it.nextElement();
			button.addActionListener((event)->
			{
				if(Configuration.bootState != BootState.GUI_SHOWING)
					return;
				
				SettingsSerializer.saveSettingsAsync();
			});
		}
		
		//build the menu
		menu.add(none);
		menu.add(new JSeparator());
		menu.add(procyon.getMenu());
		menu.add(CFR.getMenu());
		if(!Configuration.jadxGroupedWithSmali)
			menu.add(JADX.getMenu());
		menu.add(JD.getMenu());
		menu.add(fern.getMenu());
		menu.add(krakatau.getMenu());
		menu.add(new JSeparator());
		if(Configuration.jadxGroupedWithSmali)
			menu.add(JADX.getMenu());
		menu.add(smali.getMenu());
		menu.add(new JSeparator());
		menu.add(bytecode.getMenu());
		menu.add(javap.getMenu());
		menu.add(asmTextify.getMenu());
		menu.add(new JSeparator());
		menu.add(hexcode);
	}
	
	public Decompiler getSelectedDecompiler()
	{
		return Decompiler.valueOf(group.getSelection().getActionCommand());
	}
	
	public void setSelectedDecompiler(Decompiler decompiler)
	{
		Enumeration<AbstractButton> it = group.getElements();
		while(it.hasMoreElements())
		{
			AbstractButton button = it.nextElement();
			if(button.getActionCommand().equals(decompiler.name()))
			{
				group.setSelected(button.getModel(), true);
				break;
			}
		}
	}
	
	public boolean isPaneEditable()
	{
		String cmd = group.getSelection().getActionCommand();
		
		for(DecompilerViewComponent component : components)
			for (Decompiler decompiler : component.getDecompilers())
				if(decompiler.name().equalsIgnoreCase(cmd))
					return component.getEditable().isSelected();
		
		return false;
	}
	
	public void setPaneEditable(boolean value)
	{
		String cmd = group.getSelection().getActionCommand();
		
		for(DecompilerViewComponent component : components)
			for (Decompiler decompiler : component.getDecompilers())
				if(decompiler.name().equalsIgnoreCase(cmd))
				{
					component.getEditable().setSelected(value);
					return;
				}
	}
	
	public JMenu getMenu()
	{
		return menu;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/TabExitButton.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.plaf.basic.BasicButtonUI;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/25/2021
 */
public class TabExitButton extends JButton implements ActionListener
{
	private final TabbedPane tabbedPane;
	private final int tabIndex;
	private final String tabWorkingName;
	
	public TabExitButton(TabbedPane tabbedPane, int tabIndex, String tabWorkingName)
	{
		this.tabbedPane = tabbedPane;
		this.tabIndex = tabIndex;
		this.tabWorkingName = tabWorkingName;
		final int size = 17;
		setPreferredSize(new Dimension(size, size));
		setToolTipText("Close this tab");
		// Make the button looks the same for all Laf's
		setUI(new BasicButtonUI());
		// Make it transparent
		setContentAreaFilled(false);
		// No need to be focusable
		setFocusable(false);
		setBorder(BorderFactory.createEtchedBorder());
		setBorderPainted(false);
		// Making nice rollover effect
		// we use the same listener for all buttons
		addMouseListener(TabbedPane.buttonHoverAnimation);
		setRolloverEnabled(true);
		// Close the proper tab by clicking the button
		addActionListener(this);
	}
	
	public int getTabIndex()
	{
		return tabIndex;
	}
	
	@Override
	public void actionPerformed(final ActionEvent e)
	{
		final int i = tabbedPane.tabs.indexOfTabComponent(tabbedPane);
		if (i != -1)
		{
			tabbedPane.tabs.remove(i);
		}
	}
	
	// we don't want to update UI for this button
	@Override
	public void updateUI() { }
	
	// paint the cross
	@Override
	protected void paintComponent(final Graphics g)
	{
		super.paintComponent(g);
		final Graphics2D g2 = (Graphics2D) g.create();
		// shift the image for pressed buttons
		if (getModel().isPressed())
			g2.translate(1, 1);
		
		g2.setStroke(new BasicStroke(2));
		g2.setColor(Color.BLACK);
		
		if (getModel().isRollover())
			g2.setColor(Color.MAGENTA);
		
		final int delta = 6;
		g2.drawLine(delta, delta, getWidth() - delta - 1, getHeight() - delta - 1);
		g2.drawLine(getWidth() - delta - 1, delta, delta, getHeight() - delta - 1);
		g2.dispose();
	}
	
	public TabbedPane getTabbedPane()
	{
		return tabbedPane;
	}
	
	public String getTabWorkingName()
	{
		return tabWorkingName;
	}
	
	public static long getSerialVersionUID()
	{
		return serialVersionUID;
	}
	
	private static final long serialVersionUID = -4492967978286454159L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/TabRemovalEvent.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer;

import java.awt.Component;
import java.awt.event.ContainerEvent;
import java.awt.event.ContainerListener;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ResourceViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/24/2021
 */
public class TabRemovalEvent implements ContainerListener
{
	@Override
	public void componentAdded(ContainerEvent e) { }
	
	@Override
	public void componentRemoved(ContainerEvent e)
	{
		final Component c = e.getChild();
		
		if(!(c instanceof ResourceViewer))
			return;
		
		String workingName = ((ResourceViewer) c).resource.workingName;
		BytecodeViewer.viewer.workPane.openedTabs.remove(workingName);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/TabbedPane.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer;

import java.awt.Color;
import java.awt.Component;
import java.awt.FlowLayout;
import java.awt.Rectangle;
import java.awt.event.InputEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTabbedPane;
import javax.swing.SwingUtilities;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.gui.components.ButtonHoverAnimation;
import the.bytecode.club.bytecodeviewer.gui.components.MaxWidthJLabel;
import the.bytecode.club.bytecodeviewer.gui.components.listeners.MouseClickedListener;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ResourceViewer;
import the.bytecode.club.bytecodeviewer.gui.util.DelayTabbedPaneThread;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Component to be used as tabComponent; Contains a JLabel to show the text and a JButton to close the tab it belongs to
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/26/2011
 */
public class TabbedPane extends JPanel
{
    public final JTabbedPane tabs;
    public final JLabel label;
    private DelayTabbedPaneThread probablyABadIdea;
    private long startedDragging = 0;
    public final String tabName;
    public final String fileContainerName;
    public final ResourceViewer resource;
    private static long lastMouseClick = System.currentTimeMillis();
    public final static MouseListener buttonHoverAnimation = new ButtonHoverAnimation();
    public static final Color BLANK_COLOR = new Color(0, 0, 0, 0);
    
    public TabbedPane(int tabIndex, String tabWorkingName, String fileContainerName, String name, final JTabbedPane existingTabs, ResourceViewer resource)
    {
        // unset default FlowLayout' gaps
        super(new FlowLayout(FlowLayout.LEFT, 0, 0));

        this.tabName = name;
        this.fileContainerName = fileContainerName;
        this.resource = resource;
    
        if (existingTabs == null)
            throw new NullPointerException("TabbedPane is null");

        this.tabs = existingTabs;
        setOpaque(false);

        // make JLabel read titles from JTabbedPane
        label = new MaxWidthJLabel(tabName, 400, 20);

        this.add(label);
        // add more space between the label and the button
        label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));
        // tab button
        JButton exitButton = new TabExitButton(this, tabIndex, tabWorkingName);
        this.add(exitButton);
        // add more space to the top of the component
        setBorder(BorderFactory.createEmptyBorder(2, 0, 0, 0));
        
        //define the right click pop-up menu
        JPopupMenu rightClickMenu = new JPopupMenu();
        JMenuItem closeAllTabs = new JMenuItem(TranslatedStrings.CLOSE_ALL_BUT_THIS + ": " + name);
        JMenuItem closeTab = new JMenuItem(TranslatedStrings.CLOSE_TAB + ": " + name);
    
        rightClickMenu.add(closeAllTabs);
        rightClickMenu.add(closeTab);
        //setComponentPopupMenu(rightClickMenu);
        
        exitButton.setComponentPopupMenu(rightClickMenu);
        exitButton.addMouseListener(new MouseClickedListener(e ->
        {
            if (e.getModifiersEx() != InputEvent.ALT_DOWN_MASK || System.currentTimeMillis() - lastMouseClick < 100)
                return;
    
            lastMouseClick = System.currentTimeMillis();
            final int i = existingTabs.indexOfTabComponent(TabbedPane.this);
            if (i != -1)
                existingTabs.remove(i);
        }));
        
        closeTab.addActionListener(e ->
        {
            TabExitButton tabExitButton = (TabExitButton) ((JPopupMenu)((JMenuItem) e.getSource()).getParent()).getInvoker();
            final int index = tabExitButton.getTabIndex();
    
            if (index != -1)
                existingTabs.remove(index);
        });
        closeAllTabs.addActionListener(e ->
        {
            TabExitButton tabExitButton = (TabExitButton) ((JPopupMenu)((JMenuItem) e.getSource()).getParent()).getInvoker();
            final int index = tabExitButton.getTabIndex();
            
            while (true)
            {
                if (existingTabs.getTabCount() <= 1)
                    return;
                
                if (index != 0)
                    existingTabs.remove(0);
                else
                    existingTabs.remove(1);
            }
        });
        
        //tab dragging
        if(BytecodeViewer.EXPERIMENTAL_TAB_CODE)
        {
            /*label.addMouseListener(new MouseListener() {
                @Override public void mouseClicked(MouseEvent e) {}
                @Override public void mouseEntered(MouseEvent arg0) {
                }
                @Override public void mouseExited(MouseEvent arg0) {
                }
                @Override public void mousePressed(MouseEvent e) {
                    onMousePressed(e);
                }
                @Override public void mouseReleased(MouseEvent e) {
                    stopDragging(e.getX(), e.getY());
                }
            });*/
            
            this.addMouseListener(new MouseListener() {
                @Override public void mouseClicked(MouseEvent e) {}
                @Override public void mouseEntered(MouseEvent arg0) {}
                @Override public void mouseExited(MouseEvent arg0) {}
                @Override public void mousePressed(MouseEvent e) {
                    onMousePressed(e);
                }
                @Override public void mouseReleased(MouseEvent e) {
                    stopDragging(e.getX(), e.getY());
                }
            });
        }
        
        //middle click close
        if(BytecodeViewer.EXPERIMENTAL_TAB_CODE)
        {
            this.addMouseListener(new MouseAdapter()
            {
                @Override
                public void mouseReleased(MouseEvent e)
                {
                    if (e.getButton() != MouseEvent.BUTTON2)
                        return;
    
                    final int i = existingTabs.indexOfTabComponent(TabbedPane.this);
                    if (i != -1)
                        existingTabs.remove(i);
                }
            });
        }
    }

    private void stopDragging(int mouseX, int mouseY)
    {
        if (System.currentTimeMillis() - startedDragging >= 210)
        {
            Rectangle bounds = new Rectangle(1, 1, mouseX, mouseY);
            System.out.println("debug-5: " + mouseX + ", " + mouseY);
            
            int totalTabs = BytecodeViewer.viewer.workPane.tabs.getTabCount();
            int index = -1;
            for (int i = 0; i < totalTabs; i++)
            {
                Component c = BytecodeViewer.viewer.workPane.tabs.getTabComponentAt(i);
                
                if (c != null && bounds.intersects(c.getBounds()))
                    index = i; //replace this tabs position
            }

            if (index == -1)
            {
                for (int i = 0; i < totalTabs; i++)
                {
                    Component c = BytecodeViewer.viewer.workPane.tabs.getTabComponentAt(i);
                    //do some check to see if it's past the X or Y
                    if (c != null) {
                        System.out.println("debug-6: " + c.getBounds());
                    }
                }
            }

            if (index != -1)
            {
                BytecodeViewer.viewer.workPane.tabs.remove(this);
                BytecodeViewer.viewer.workPane.tabs.setTabComponentAt(index, this);
            }
        }
        
        SwingUtilities.invokeLater(() ->
        {
            label.setBackground(BLANK_COLOR);
            label.updateUI();
        });
    }
    
    public void onMousePressed(MouseEvent e)
    {
        BytecodeViewer.viewer.workPane.tabs.dispatchEvent(e);
    
        if(e.getButton() == 1)
        {
            startedDragging = System.currentTimeMillis();
            //dragging = true;
            if (probablyABadIdea != null)
                probablyABadIdea.stopped = true;
            
            probablyABadIdea = new DelayTabbedPaneThread(TabbedPane.this);
            probablyABadIdea.start();
            repaint();
            System.out.println(e.getX()+", "+e.getY());
            Rectangle bounds = new Rectangle(1, 1, e.getX(), e.getY());
            for(int i = 0; i < BytecodeViewer.viewer.workPane.tabs.getTabCount(); i++)
            {
                Component c = BytecodeViewer.viewer.workPane.tabs.getTabComponentAt(i);
                if(c != null && bounds.intersects(c.getBounds()))
                    BytecodeViewer.viewer.workPane.tabs.setSelectedIndex(i);
            }
        }
        else
        {
            stopDragging(e.getX(), e.getY());
        }
    }
    
    private static final long serialVersionUID = -4774885688297538774L;
    
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/Workspace.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.FlowLayout;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTabbedPane;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ClassViewer;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.FileViewer;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ResourceViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJButton;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedVisibleComponent;

import static the.bytecode.club.bytecodeviewer.Constants.BLOCK_TAB_MENU;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The pane that contains all of the resources as tabs.
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/26/2011
 */

public class Workspace extends TranslatedVisibleComponent
{
    public final JTabbedPane tabs;
    public final JPanel buttonPanel;
    public final JButton refreshClass;
    public final Set<String> openedTabs = new HashSet<>();

    public Workspace()
    {
        super("Workspace", TranslatedComponents.WORK_SPACE);

        this.tabs = new JTabbedPane();
        
        JPopupMenu popUp = new JPopupMenu();
        JMenuItem closeAllTabs = new JMenuItem("Close All But This");
        JMenuItem closeTab = new JMenuItem("Close Tab");
        closeTab.addActionListener(e ->
        {
            TabExitButton tabExitButton = (TabExitButton) ((JPopupMenu)((JMenuItem) e.getSource()).getParent()).getInvoker();
            final int index = tabExitButton.getTabIndex();
            
            if (index != -1)
                tabs.remove(index);
        });
        
        closeAllTabs.addActionListener(e ->
        {
            TabExitButton tabExitButton = (TabExitButton) ((JPopupMenu)((JMenuItem) e.getSource()).getParent()).getInvoker();
            final int index = tabExitButton.getTabIndex();
    
            while (true)
            {
                if (tabs.getTabCount() <= 1)
                    return;
        
                if (index != 0)
                    tabs.remove(0);
                else
                    tabs.remove(1);
            }
        });
        
        tabs.addMouseListener(new MouseListener()
        {
            @Override
            public void mouseClicked(MouseEvent e) { }
            @Override
            public void mouseEntered(MouseEvent arg0) { }
            @Override
            public void mouseExited(MouseEvent arg0) { }

            @Override
            public void mousePressed(MouseEvent e)
            {
                if (BLOCK_TAB_MENU)
                    return;
                
                if (e.getButton() == 3)
                {
                    Rectangle bounds = new Rectangle(1, 1, e.getX(), e.getY());
                    
                    for (int i = 0; i < BytecodeViewer.viewer.workPane.tabs.getTabCount(); i++)
                    {
                        Component c = BytecodeViewer.viewer.workPane.tabs.getTabComponentAt(i);
                        if (c != null && bounds.intersects(c.getBounds()))
                        {
                            popUp.setVisible(true);
                            closeAllTabs.setText(TranslatedStrings.CLOSE_TAB + ": " + ((TabbedPane) c).tabName);
                            closeTab.setText(TranslatedStrings.CLOSE_TAB + ": " + ((TabbedPane) c).tabName);
                        }
                        else
                        {
                            popUp.setVisible(false);
                        }
                    }
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) { }
        });

        popUp.add(closeAllTabs);
        popUp.add(closeTab);
        
        if (!BLOCK_TAB_MENU)
            tabs.setComponentPopupMenu(popUp);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(tabs, BorderLayout.CENTER);

        buttonPanel = new JPanel(new FlowLayout());

        refreshClass = new TranslatedJButton("Refresh", TranslatedComponents.REFRESH);
        refreshClass.addActionListener((event)->
        {
            refreshClass.setEnabled(false);
            Thread t = new Thread(() -> new WorkspaceRefresh(event).run(), "Refresh");
            t.start();
        });

        buttonPanel.add(refreshClass);
        buttonPanel.setVisible(false);
        
        getContentPane().add(buttonPanel, BorderLayout.SOUTH);

        tabs.addContainerListener(new TabRemovalEvent());
        tabs.addChangeListener(arg0 -> buttonPanel.setVisible(tabs.getSelectedIndex() != -1));

        this.setVisible(true);
    }

    //load class resources
    public void addClassResource(final ResourceContainer container, final String name)
    {
        addResource(container, name, new ClassViewer(container, name));
    }

    //Load file resources
    public void addFileResource(final ResourceContainer container, final String name)
    {
        addResource(container, name, new FileViewer(container, name));
    }
    
    private void addResource(final ResourceContainer container, final String name, final ResourceViewer resourceView)
    {
        // Warn user and prevent 'nothing' from opening if no Decompiler is selected
        if(BytecodeViewer.viewer.viewPane1.getSelectedDecompiler() == Decompiler.NONE &&
            BytecodeViewer.viewer.viewPane2.getSelectedDecompiler() == Decompiler.NONE &&
            BytecodeViewer.viewer.viewPane3.getSelectedDecompiler() == Decompiler.NONE)
        {
            BytecodeViewer.showMessage(TranslatedStrings.SUGGESTED_FIX_NO_DECOMPILER_WARNING.toString());
            return;
        }
        
        //unlock the refresh button
        BytecodeViewer.viewer.workPane.refreshClass.setEnabled(true);
        
        final String workingName = container.getWorkingName(name);
        
        //create a new tab if the resource isn't opened currently
        if (!openedTabs.contains(workingName))
        {
            addResourceToTab(resourceView, workingName, container.name, name);
        }
        else //if the resource is already opened select this tab as the active one
        {
            //TODO openedTabs could be changed to a HashMap<String, Integer> for faster lookups
            
            //search through each tab
            for(int i = 0; i < tabs.getTabCount(); i++)
            {
                //find the matching resource and open it
                ResourceViewer tab = ((TabbedPane)tabs.getTabComponentAt(i)).resource;
                if(tab.resource.workingName.equals(workingName))
                {
                    tabs.setSelectedIndex(i);
                    break;
                }
            }
        }
    }
    
    public void addResourceToTab(ResourceViewer resourceView, String workingName, String containerName, String name)
    {
        //start processing the resource to be viewed
        if(resourceView instanceof ClassViewer)
            resourceView.refresh(null);
    
        //add the resource view to the tabs
        tabs.add(resourceView);
    
        //get the resource view index
        final int tabIndex = tabs.indexOfComponent(resourceView);
    
        //create a new tabbed pane
        TabbedPane tabbedPane = new TabbedPane(tabIndex, workingName, containerName, name, tabs, resourceView);
        resourceView.tabbedPane = tabbedPane;
        resourceView.resource.workingName = workingName;
    
        //set the tabs index
        tabs.setTabComponentAt(tabIndex, tabbedPane);
    
        //open the tab that was just added
        tabs.setSelectedIndex(tabIndex);
    
        //set resource as opened in a tab
        openedTabs.add(workingName);
    
        //refresh the tab title
        resourceView.refreshTitle();
    }

    public ResourceViewer getActiveResource() {
        return (ResourceViewer) tabs.getSelectedComponent();
    }

    public Component[] getLoadedViewers() {
        return tabs.getComponents();
    }

    public void resetWorkspace()
    {
        tabs.removeAll();
        tabs.updateUI();
    }
    
    private static final long serialVersionUID = 6542337997679487946L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/WorkspaceRefresh.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer;

import java.awt.event.ActionEvent;
import javax.swing.JButton;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ResourceViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/24/2021
 */
public class WorkspaceRefresh implements Runnable
{
	private final ActionEvent event;
	
	public WorkspaceRefresh(ActionEvent event) {
		this.event = event;
	}
	
	@Override
	public void run()
	{
		if (!BytecodeViewer.autoCompileSuccessful())
			return;
		
		JButton src = null;
		if(event != null && event.getSource() instanceof JButton)
			src = (JButton) event.getSource();
		
		final ResourceViewer tabComp = (ResourceViewer) BytecodeViewer.viewer.workPane.tabs.getSelectedComponent();
		
		if(tabComp == null)
			return;
		
		BytecodeViewer.updateBusyStatus(true);
		tabComp.refresh(src);
		BytecodeViewer.updateBusyStatus(false);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/WorkspaceRefreshEvent.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/21/2021
 */

public class WorkspaceRefreshEvent implements ActionListener
{
	@Override
	public void actionPerformed(ActionEvent e)
	{
		if (BytecodeViewer.viewer.refreshOnChange.isSelected())
		{
			if (!BytecodeViewer.hasActiveResource())
				return;
			
			BytecodeViewer.viewer.workPane.refreshClass.doClick();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/viewer/ClassViewer.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Point;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.HierarchyEvent;
import java.awt.event.HierarchyListener;
import java.util.Arrays;
import java.util.List;
import javax.swing.JButton;
import javax.swing.JSplitPane;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.SettingsSerializer;
import the.bytecode.club.bytecodeviewer.api.ASMUtil;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.BytecodeViewPanel;
import the.bytecode.club.bytecodeviewer.resources.Resource;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.util.MethodParser;

import static the.bytecode.club.bytecodeviewer.util.MethodParser.Method;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * This represents the opened classfile.
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/26/2011
 */

public class ClassViewer extends ResourceViewer
{
    public JSplitPane sp;
    public JSplitPane sp2;
    public BytecodeViewPanel bytecodeViewPanel1 = new BytecodeViewPanel(0, this);
    public BytecodeViewPanel bytecodeViewPanel2 = new BytecodeViewPanel(1, this);
    public BytecodeViewPanel bytecodeViewPanel3 = new BytecodeViewPanel(2, this);
    
    public List<MethodParser> methods = Arrays.asList(new MethodParser(), new MethodParser(), new MethodParser());
    
    public ClassViewer(final ResourceContainer container, final String name)
    {
        super(new Resource(name, container.getWorkingName(name), container));
        
        this.setName(name);
        this.setLayout(new BorderLayout());
        this.sp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, bytecodeViewPanel1, bytecodeViewPanel2);
        this.sp2 = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, sp, bytecodeViewPanel3);
        this.add(sp2, BorderLayout.CENTER);

        this.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                resetDivider();
            }
        });
    }

    @Override
    public void refresh(final JButton button)
    {
        setPanes();
        refreshTitle();

        bytecodeViewPanel1.createPane(this);
        bytecodeViewPanel2.createPane(this);
        bytecodeViewPanel3.createPane(this);

        byte[] classBytes = getResourceBytes();
        
        //TODO remove this once all of the importers have been properly updated to use a FileContainerImporter
        if(classBytes == null || classBytes.length == 0 || Configuration.forceResourceUpdateFromClassNode)
        {
            //TODO remove this error message when all of the importers have been updated
            // only APK and DEX are left
            if(!Configuration.forceResourceUpdateFromClassNode)
            {
                System.err.println("WARNING: Class Resource imported using the old importer!");
                System.err.println("TODO: Update it to use the FileContainerImporter");
            }
            
            classBytes = ASMUtil.nodeToBytes(resource.getResourceClassNode());
        }
        
        bytecodeViewPanel1.updatePane(this, classBytes, button, isPanel1Editable());
        bytecodeViewPanel2.updatePane(this, classBytes, button, isPanel2Editable());
        bytecodeViewPanel3.updatePane(this, classBytes, button, isPanel3Editable());

        Thread dumpBuild = new Thread(() ->
        {
            BytecodeViewer.updateBusyStatus(true);
            
            while (Configuration.currentlyDumping)
            {
                //wait until it's not dumping
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            BytecodeViewer.updateBusyStatus(false);

            if (bytecodeViewPanel1.decompiler != Decompiler.NONE)
                bytecodeViewPanel1.updateThread.startNewThread();
            if (bytecodeViewPanel2.decompiler != Decompiler.NONE)
                bytecodeViewPanel2.updateThread.startNewThread();
            if (bytecodeViewPanel3.decompiler != Decompiler.NONE)
                bytecodeViewPanel3.updateThread.startNewThread();
        }, "ClassViewer Temp Dump");
        dumpBuild.start();

        if (isPanel1Editable() || isPanel2Editable() || isPanel3Editable())
        {
            if (Configuration.warnForEditing)
                return;
    
            Configuration.warnForEditing = true;
            if (!BytecodeViewer.viewer.autoCompileOnRefresh.isSelected()
                    && !BytecodeViewer.viewer.compileOnSave.isSelected())
            {
                BytecodeViewer.showMessage("Make sure to compile (File>Compile or Ctrl + T) whenever you want to "
                        + "test or export your changes.\nYou can set compile automatically on refresh or on save "
                        + "in the settings menu.");
        
                SettingsSerializer.saveSettingsAsync();
            }
        }
    }
    
    public void setPanes() {
        bytecodeViewPanel1.decompiler = BytecodeViewer.viewer.viewPane1.getSelectedDecompiler();
        bytecodeViewPanel2.decompiler = BytecodeViewer.viewer.viewPane2.getSelectedDecompiler();
        bytecodeViewPanel3.decompiler = BytecodeViewer.viewer.viewPane3.getSelectedDecompiler();
    }

    public boolean isPanel1Editable() {
        setPanes();
        return BytecodeViewer.viewer.viewPane1.isPaneEditable();
    }

    public boolean isPanel2Editable() {
        setPanes();
        return BytecodeViewer.viewer.viewPane2.isPaneEditable();
    }

    public boolean isPanel3Editable() {
        setPanes();
        return BytecodeViewer.viewer.viewPane3.isPaneEditable();
    }


    public static void selectMethod(RSyntaxTextArea area, int methodLine) {
        if (methodLine != area.getCaretLineNumber()) {
            setCaretLine(area, methodLine);
            setViewLine(area, methodLine);
        }
    }

    public static void selectMethod(ClassViewer classViewer, int paneId, Method method) {
        RSyntaxTextArea area = null;
        switch (paneId) {
            case 0:
                area = classViewer.bytecodeViewPanel1.updateThread.updateUpdaterTextArea;
                break;
            case 1:
                area = classViewer.bytecodeViewPanel2.updateThread.updateUpdaterTextArea;
                break;
            case 2:
                area = classViewer.bytecodeViewPanel3.updateThread.updateUpdaterTextArea;
                break;
        }

        if (area != null) {
            MethodParser methods = classViewer.methods.get(paneId);
            if (methods != null) {
                int methodLine = methods.findMethod(method);
                if (methodLine != -1) {
                    selectMethod(area, methodLine);
                }
            }
        }
    }

    public static int getMaxViewLine(RSyntaxTextArea area)
    {
        Container parent = area.getParent();
        if (parent instanceof JViewport)
        {
            JViewport viewport = (JViewport) parent;
            int y = viewport.getViewSize().height - viewport.getExtentSize().height;
            int lineHeight = area.getLineHeight();
            return y >= lineHeight ? y / lineHeight : 0;
        }
        
        return 0;
    }

    public static int getViewLine(RSyntaxTextArea area)
    {
        Container parent = area.getParent();
        if (parent instanceof JViewport)
        {
            JViewport viewport = (JViewport) parent;
            Point point = viewport.getViewPosition();
            int lineHeight = area.getLineHeight();
            return point.y >= lineHeight ? point.y / lineHeight : 0;
        }
        
        return 0;
    }

    public static void setViewLine(RSyntaxTextArea area, int line)
    {
        Container parent = area.getParent();
        if (parent instanceof JViewport)
        {
            JViewport viewport = (JViewport) parent;
            int maxLine = ClassViewer.getMaxViewLine(area);
            line = Math.min(line, maxLine);
            viewport.setViewPosition(new Point(0, line * area.getLineHeight()));
        }
    }

    public static void setCaretLine(RSyntaxTextArea area, int line)
    {
        try {
            area.setCaretPosition(area.getLineStartOffset(line));
        } catch (BadLocationException ignored) { }
    }
    
    public void resetDivider()
    {
        SwingUtilities.invokeLater(() ->
        {
            sp.setResizeWeight(0.5);
            
            if (bytecodeViewPanel2.decompiler != Decompiler.NONE && bytecodeViewPanel1.decompiler != Decompiler.NONE) {
                setDividerLocation(sp, 0.5);
            } else if (bytecodeViewPanel1.decompiler != Decompiler.NONE) {
                setDividerLocation(sp, 1);
            } else if (bytecodeViewPanel2.decompiler != Decompiler.NONE) {
                sp.setResizeWeight(1);
                setDividerLocation(sp, 0);
            } else {
                setDividerLocation(sp, 0);
            }
            
            if (bytecodeViewPanel3.decompiler != Decompiler.NONE) {
                sp2.setResizeWeight(0.7);
                setDividerLocation(sp2, 0.7);
                if ((bytecodeViewPanel2.decompiler == Decompiler.NONE && bytecodeViewPanel1.decompiler != Decompiler.NONE)
                        || (bytecodeViewPanel1.decompiler == Decompiler.NONE && bytecodeViewPanel2.decompiler != Decompiler.NONE)) {
                    setDividerLocation(sp2, 0.5);
                } else if (bytecodeViewPanel1.decompiler == Decompiler.NONE) {
                    setDividerLocation(sp2, 0);
                }
            } else {
                sp.setResizeWeight(1);
                sp2.setResizeWeight(0);
                setDividerLocation(sp2, 1);
            }
        });
    }
    
    /**
     * Whoever wrote this function, THANK YOU!
     */
    public static JSplitPane setDividerLocation(final JSplitPane splitter,
                                                final double proportion)
    {
        if (splitter.isShowing()) {
            if (splitter.getWidth() > 0 && splitter.getHeight() > 0) {
                splitter.setDividerLocation(proportion);
            } else {
                splitter.addComponentListener(new ComponentAdapter() {
                    @Override
                    public void componentResized(ComponentEvent ce) {
                        splitter.removeComponentListener(this);
                        setDividerLocation(splitter, proportion);
                    }
                });
            }
        } else {
            splitter.addHierarchyListener(new HierarchyListener() {
                @Override
                public void hierarchyChanged(HierarchyEvent e) {
                    if ((e.getChangeFlags() & HierarchyEvent.SHOWING_CHANGED) != 0
                            && splitter.isShowing()) {
                        splitter.removeHierarchyListener(this);
                        setDividerLocation(splitter, proportion);
                    }
                }
            });
        }
        return splitter;
    }
    
    private static final long serialVersionUID = -8650495368920680024L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/viewer/ComponentViewer.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer;

import java.awt.BorderLayout;
import java.awt.Component;
import javax.swing.JButton;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.Resource;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * This represents a component opened as a tab
 *
 * @author Konloch
 * @since 7/23/2021
 */

public class ComponentViewer extends ResourceViewer
{
	private final Component component;
	private static final String containerName = "internalComponent.";
	
	public ComponentViewer(String title, Component component)
	{
		super(new Resource(title, containerName + title, null));
		
		this.component = component;
		
		setLayout(new BorderLayout());
		setName(title);
		add(component, BorderLayout.CENTER);
	}
	
	public static ComponentViewer addComponentAsTab(String title, Component c)
	{
		String workingName = containerName + title;
		ComponentViewer componentViewer = new ComponentViewer(title, c);
		BytecodeViewer.viewer.workPane.addResourceToTab(componentViewer,
				workingName, containerName, title);
		
		return componentViewer;
	}
	
	@Override
	public void refresh(JButton button) {
		//TODO add a refresh event so the component can be updated
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/viewer/FileViewer.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer;

import java.awt.BorderLayout;
import java.awt.Font;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import org.apache.commons.io.FilenameUtils;
import org.imgscalr.Scalr;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.components.ImageJLabel;
import the.bytecode.club.bytecodeviewer.gui.components.SearchableRSyntaxTextArea;
import the.bytecode.club.bytecodeviewer.gui.hexviewer.HexViewer;
import the.bytecode.club.bytecodeviewer.resources.Resource;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.ResourceType;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;
import the.bytecode.club.bytecodeviewer.util.SyntaxLanguage;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Represents any open non-class file inside of a tab.
 *
 * @author Konloch
 */

public class FileViewer extends ResourceViewer
{
    public static final float ZOOM_STEP_SIZE = 1.5f;
    public final SearchableRSyntaxTextArea textArea = (SearchableRSyntaxTextArea)
            Configuration.rstaTheme.apply(new SearchableRSyntaxTextArea());
    public final JPanel mainPanel = new JPanel(new BorderLayout());
    public BufferedImage originalImage;
    public BufferedImage image;
    public boolean canRefresh;
    public int zoomSteps = 0;

    public FileViewer(final ResourceContainer container, final String name)
    {
        super(new Resource(name, container.getWorkingName(name), container));
        
        this.setName(name);
        this.setLayout(new BorderLayout());
        
        this.add(mainPanel, BorderLayout.CENTER);

        setContents();
    }
    
    public void setContents()
    {
        final byte[] contents = resource.getResourceBytes();
        final String nameLowerCase = this.resource.name.toLowerCase();
        final String onlyName = FilenameUtils.getName(nameLowerCase);
        final boolean hexViewerOnly = BytecodeViewer.viewer.viewPane1.getSelectedDecompiler() == Decompiler.HEXCODE_VIEWER &&
                BytecodeViewer.viewer.viewPane2.getSelectedDecompiler() == Decompiler.NONE &&
                BytecodeViewer.viewer.viewPane3.getSelectedDecompiler() == Decompiler.NONE;
        
        //image viewer
        if (MiscUtils.guessIfBinary(contents) || hexViewerOnly)
        {
            //TODO:
            //  + Add file header checks
            //  + Check for CAFEBABE
            //  + ClassRead then quick-decompile using Pane1 Decompiler
            //      (If none selected, try Pane2, Pane3, default to Procyon)
            
            
            //check by file extension to display image
            if (!onlyName.contains(":") &&
                    ResourceType.imageExtensionMap.containsKey(FilenameUtils.getExtension(onlyName)) &&
                    !hexViewerOnly)
            {
                canRefresh = true;

                image = MiscUtils.loadImage(image, contents);
                if (image == null) {
                    HexViewer hex = new HexViewer(contents);
                    mainPanel.add(hex);
                    return;
                }
                originalImage = image;

                mainPanel.add(new ImageJLabel(image), BorderLayout.CENTER);
                mainPanel.addMouseWheelListener(e -> {
                    int notches = e.getWheelRotation();
                    int width = originalImage.getWidth();
                    int height = originalImage.getHeight();
                    int oldZoomSteps = zoomSteps;

                    if (notches < 0) {
                        //zoom in
                        zoomSteps++;
                    } else {
                        //zoom out
                        zoomSteps--;
                    }

                    try {
                        double factor = Math.pow(ZOOM_STEP_SIZE, zoomSteps);
                        int newWidth = (int) (width * factor);
                        int newHeight = (int) (height * factor);
                        image = Scalr.resize(originalImage, Scalr.Method.SPEED, newWidth, newHeight);

                        mainPanel.removeAll();
                        mainPanel.add(new ImageJLabel(image), BorderLayout.CENTER);
                        mainPanel.updateUI();
                    } catch (Throwable ignored) {
                        zoomSteps = oldZoomSteps;
                    }
                });
                return;
            }
            //hex viewer
            else if (BytecodeViewer.viewer.forcePureAsciiAsText.isSelected() || hexViewerOnly)
            {
                HexViewer hex = new HexViewer(contents);
                mainPanel.add(hex);
                return;
            }
        }
        
        textArea.setCodeFoldingEnabled(true);
        SyntaxLanguage.setLanguage(textArea, nameLowerCase);
        textArea.setText(new String(contents));
        textArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, (int) BytecodeViewer.viewer.fontSpinner.getValue()));
        textArea.setCaretPosition(0);
        
        mainPanel.add(textArea.getScrollPane());
    }
    
    @Override
    public void refresh(JButton src)
    {
        refreshTitle();
        
        if (!canRefresh)
        {
            if(src != null)
                src.setEnabled(true);
            
            return;
        }

        mainPanel.removeAll();
      
        image = MiscUtils.loadImage(image, resource.getResourceBytes());
        
        JLabel label = new JLabel("", new ImageIcon(image), JLabel.CENTER);
        mainPanel.add(label, BorderLayout.CENTER);
        mainPanel.updateUI();
    
        if(src != null)
            src.setEnabled(true);
    }
    
    private static final long serialVersionUID = 6103372882168257164L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/viewer/ResourceViewer.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer;

import javax.swing.JButton;
import javax.swing.JPanel;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.TabbedPane;
import the.bytecode.club.bytecodeviewer.resources.Resource;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Represents an opened tab
 *
 * @author Konloch
 */

public abstract class ResourceViewer extends JPanel
{
    public final Resource resource;
    public TabbedPane tabbedPane;
    
    protected ResourceViewer(Resource resource) {this.resource = resource;}
    
    /**
     * Returns the tab name
     */
    public String getTabName()
    {
        String tabName = resource.name;
        
        if (Configuration.simplifiedTabNames)
            tabName = MiscUtils.getChildFromPath(tabName);
        if (Configuration.displayParentInTab)
            tabName = resource.container.name + ">" + tabName;
        
        return tabName;
    }
    
    /**
     * Returns the resource bytes from the resource container
     */
    public byte[] getResourceBytes()
    {
        return resource.getResourceBytes();
    }
    
    
    public abstract void refresh(final JButton button);
    
    /**
     * Updates the tab's title
     */
    public void refreshTitle()
    {
        if(tabbedPane != null)
            tabbedPane.label.setText(getTabName());
    }

    private static final long serialVersionUID = -2965538493489119191L;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/resourceviewer/viewer/synchronizedscroll/MethodData.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.synchronizedscroll;

import java.util.Arrays;
import java.util.Objects;
import org.objectweb.asm.Type;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/24/2021
 */
public class MethodData
{
	public String name, desc;

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (!(o instanceof MethodData)) return false;
		MethodData that = (MethodData) o;
		return Objects.equals(name, that.name) && Objects.equals(desc, that.desc);
	}

	@Override
	public int hashCode() {
		return Objects.hash(name, desc);
	}

	public String constructPattern()
	{
		final StringBuilder pattern = new StringBuilder();
		pattern.append(name).append(" *\\(");
		final org.objectweb.asm.Type[] types = org.objectweb.asm.Type
				.getArgumentTypes(desc);
		pattern.append("(.*)");
		Arrays.stream(types).map(Type::getClassName)
				.forEach(clazzName -> pattern.append(clazzName.substring(clazzName.lastIndexOf(".") + 1)).append(
						"(.*)"));
		pattern.append("\\) *\\{");
		return pattern.toString();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/theme/LAFTheme.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.theme;

import com.github.weisj.darklaf.LafManager;
import com.github.weisj.darklaf.theme.DarculaTheme;
import com.github.weisj.darklaf.theme.HighContrastDarkTheme;
import com.github.weisj.darklaf.theme.HighContrastLightTheme;
import com.github.weisj.darklaf.theme.IntelliJTheme;
import com.github.weisj.darklaf.theme.OneDarkTheme;
import com.github.weisj.darklaf.theme.SolarizedDarkTheme;
import com.github.weisj.darklaf.theme.SolarizedLightTheme;
import java.awt.Dialog;
import javax.swing.JInternalFrame;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.SettingsDialog;
import the.bytecode.club.bytecodeviewer.gui.components.VisibleComponent;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author ThexXTURBOXx
 * @since 6/24/2021
 */
public enum LAFTheme
{
	SYSTEM("System Theme", RSTATheme.THEME_MATCH, TranslatedComponents.SYSTEM_THEME), //System theme
	DARK("Dark Theme", RSTATheme.THEME_MATCH, TranslatedComponents.DARK_THEME), //DarkLaf
	LIGHT("Light Theme", RSTATheme.THEME_MATCH, TranslatedComponents.LIGHT_THEME), //Intellij theme
	ONE_DARK("One Dark Theme", RSTATheme.THEME_MATCH, TranslatedComponents.ONE_DARK_THEME),
	SOLARIZED_DARK("Solarized Dark Theme", RSTATheme.THEME_MATCH, TranslatedComponents.SOLARIZED_DARK_THEME),
	SOLARIZED_LIGHT("Solarized Light Theme", RSTATheme.THEME_MATCH, TranslatedComponents.SOLARIZED_LIGHT_THEME),
	HIGH_CONTRAST_DARK("High Contrast Dark Theme", RSTATheme.THEME_MATCH, TranslatedComponents.HIGH_CONTRAST_DARK_THEME),
	HIGH_CONTRAST_LIGHT("High Contrast Light Theme", RSTATheme.THEME_MATCH, TranslatedComponents.HIGH_CONTRAST_LIGHT_THEME),
	;
	
	private final String readableName;
	private final RSTATheme rstaTheme;
	private final TranslatedComponents translatedComponents;
	
	LAFTheme(String readableName, RSTATheme rstaTheme, TranslatedComponents translatedComponents)
	{
		this.readableName = readableName;
		this.rstaTheme = rstaTheme;
		this.translatedComponents = translatedComponents;
	}
	
	public String getReadableName()
	{
		return readableName;
	}
	
	public RSTATheme getRSTATheme()
	{
		return rstaTheme;
	}
	
	public TranslatedComponents getTranslation()
	{
		return translatedComponents;
	}
	
	public boolean isDark()
	{
		switch(this)
		{
			case DARK:
			case ONE_DARK:
			case SOLARIZED_DARK:
			case HIGH_CONTRAST_DARK:
				return true;
		}
		
		return false;
	}
	
	public void setLAF() throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException
	{
		boolean darkLAF = true;
		
		switch(this)
		{
			default:
			case SYSTEM:
				UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
				darkLAF = false;
				break;
			
			case DARK:
				LafManager.install(new DarculaTheme());
				break;
			
			case LIGHT:
				LafManager.install(new IntelliJTheme());
				break;
			
			case ONE_DARK:
				LafManager.install(new OneDarkTheme());
				break;
			
			case SOLARIZED_DARK:
				LafManager.install(new SolarizedDarkTheme());
				break;
			
			case SOLARIZED_LIGHT:
				LafManager.install(new SolarizedLightTheme());
				break;
			
			case HIGH_CONTRAST_DARK:
				LafManager.install(new HighContrastDarkTheme());
				break;
			
			case HIGH_CONTRAST_LIGHT:
				LafManager.install(new HighContrastLightTheme());
				break;
		}
		
		//test theme installed correctly
		if(darkLAF)
			failSafe();
		
		Configuration.showDarkLAFComponentIcons = darkLAF;
		
		if(BytecodeViewer.viewer != null)
		{
			BytecodeViewer.viewer.uiComponents.forEach(VisibleComponent::setDefaultIcon);
			
			BytecodeViewer.viewer.resourcePane.rightClickMenu.updateUI();
			BytecodeViewer.viewer.searchBoxPane.rightClickMenu.updateUI();
			
			//update all of the setting dialog components
			SettingsDialog.components.forEach(SwingUtilities::updateComponentTreeUI);
			
			//TODO instead of hiding the currently opened dialogs it should update/rebuild the dialogs
			
			//hide any existing jDialogs
			SettingsDialog.dialogs.forEach(Dialog::dispose);
		}
	}
	
	/**
	 * Attempts to failsafe by forcing an error before the mainviewer is called.
	 * It then defaults to the system theme
	 */
	private static void failSafe() throws ClassNotFoundException, UnsupportedLookAndFeelException, InstantiationException, IllegalAccessException
	{
		try
		{
			JInternalFrame test = new JInternalFrame("Test LAF");
			test.dispose();
		}
		catch(Error e)
		{
			e.printStackTrace();
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/theme/RSTATheme.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.theme;

import com.github.weisj.darklaf.extensions.rsyntaxarea.DarklafRSyntaxTheme;
import java.io.InputStream;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.Theme;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author ThexXTURBOXx
 * @since 6/23/2021
 */

public enum RSTATheme
{
	//uses the darklaf RSyntaxTextArea extension
	THEME_MATCH("Theme Match (Recommended)", null, TranslatedComponents.THEME_MATCH),
	//uses the default theme from RSyntaxTextArea
	DEFAULT("Default (Recommended Light)", "/org/fife/ui/rsyntaxtextarea/themes/default.xml", TranslatedComponents.DEFAULT_RECOMMENDED_LIGHT),
	//uses the default dark theme from RSyntaxTextArea
	DARK("Dark (Recommended Dark)", "/org/fife/ui/rsyntaxtextarea/themes/dark.xml", TranslatedComponents.DARK),
	
	DEFAULT_ALT( "Default-Alt", "/org/fife/ui/rsyntaxtextarea/themes/default-alt.xml", TranslatedComponents.DEFAULT_ALT),
	ECLIPSE("Eclipse", "/org/fife/ui/rsyntaxtextarea/themes/eclipse.xml", TranslatedComponents.ECLIPSE),
	IDEA("IntelliJ", "/org/fife/ui/rsyntaxtextarea/themes/idea.xml", TranslatedComponents.INTELLIJ),
	VS("Visual Studio", "/org/fife/ui/rsyntaxtextarea/themes/vs.xml", TranslatedComponents.VISUAL_STUDIO),
	DRUID( "Druid (Dark)", "/org/fife/ui/rsyntaxtextarea/themes/druid.xml", TranslatedComponents.DRUID_DARK),
	MONOKAI( "Monokai (Dark)", "/org/fife/ui/rsyntaxtextarea/themes/monokai.xml", TranslatedComponents.MONOKAI_DARK),
	;
	
	private final String readableName;
	private final String file;
	private final TranslatedComponents translatedComponents;
	
	RSTATheme(String readableName, String file, TranslatedComponents translatedComponents)
	{
		this.readableName = readableName;
		this.file = file;
		this.translatedComponents = translatedComponents;
	}
	
	public String getReadableName() {
		return readableName;
	}
	
	public TranslatedComponents getTranslation()
	{
		return translatedComponents;
	}
	
	public RSyntaxTextArea apply(RSyntaxTextArea area) {
		try {
			switch(this)
			{
				case THEME_MATCH:
					if (Configuration.lafTheme == LAFTheme.SYSTEM) {
						//on system theme force default theme
						try (InputStream is = Constants.class.getResourceAsStream(DEFAULT.file)) {
							Theme.load(is).apply(area);
						}
					} else
						new DarklafRSyntaxTheme().apply(area);
					break;
					
				default:
					try (InputStream is = Constants.class.getResourceAsStream(file)) {
						Theme.load(is).apply(area);
					}
					break;
			}
		} catch (Throwable ignored) {
		}
		return area;
	}
	
	public static RSTATheme parse(String name) {
		for (RSTATheme t : values()) {
			if (t.name().equals(name)) {
				return t;
			}
		}
		return DEFAULT;
	}
	
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/util/BytecodeViewPanelUpdater.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.util;

import java.awt.BorderLayout;
import java.util.Objects;
import java.util.regex.Matcher;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.SyntaxConstants;
import org.objectweb.asm.ClassWriter;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.compilers.Compiler;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.components.MethodsRenderer;
import the.bytecode.club.bytecodeviewer.gui.components.SearchableRSyntaxTextArea;
import the.bytecode.club.bytecodeviewer.gui.hexviewer.HexViewer;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.BytecodeViewPanel;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ClassViewer;
import the.bytecode.club.bytecodeviewer.util.MethodParser;

import static the.bytecode.club.bytecodeviewer.gui.resourceviewer.TabbedPane.BLANK_COLOR;
import static the.bytecode.club.bytecodeviewer.translation.TranslatedStrings.EDITABLE;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Updates the Bytecode View Panel in a background thread
 *
 * @author Konloch
 * @author WaterWolf
 * @author DreamSworK
 * @since 09/26/2011
 */

public class BytecodeViewPanelUpdater implements Runnable
{
    public final ClassViewer viewer;
    public final BytecodeViewPanel bytecodeViewPanel;
    private final JButton button;
    private final byte[] classBytes;
    
    
    public SearchableRSyntaxTextArea updateUpdaterTextArea;
    public JComboBox<Integer> methodsList;
    public boolean isPanelEditable;
    public boolean waitingFor;
    private Thread thread;
    
    public BytecodeViewPanelUpdater(BytecodeViewPanel bytecodeViewPanel, ClassViewer cv, byte[] classBytes, boolean isPanelEditable, JButton button)
    {
        this.viewer = cv;
        this.bytecodeViewPanel = bytecodeViewPanel;
        this.classBytes = classBytes;
        this.isPanelEditable = isPanelEditable;
        this.button = button;
        waitingFor = true;
    }
    
    public void processDisplay()
    {
        try
        {
            BytecodeViewer.updateBusyStatus(true);
        
            if (bytecodeViewPanel.decompiler != Decompiler.NONE)
            {
                //hex viewer
                if (bytecodeViewPanel.decompiler == Decompiler.HEXCODE_VIEWER)
                {
                    final ClassWriter cw = new ClassWriter(0);
                    viewer.resource.getResourceClassNode().accept(cw);
                
                    SwingUtilities.invokeLater(() ->
                    {
                        final HexViewer hex = new HexViewer(cw.toByteArray());
                        bytecodeViewPanel.add(hex);
                    });
                }
                else
                {
                    final Decompiler decompiler = bytecodeViewPanel.decompiler;
                
                    //perform decompiling inside of this thread
                    final String decompiledSource = decompiler.getDecompiler().decompileClassNode(viewer.resource.getResourceClassNode(), classBytes);
                
                    //set the swing components on the swing thread
                    SwingUtilities.invokeLater(() ->
                    {
                        buildTextArea(decompiler, decompiledSource);
                        waitingFor = false;
                    });
                
                    //hold this thread until the swing thread has finished attaching the components
                    while (waitingFor)
                    {
                        try {
                            Thread.sleep(1);
                        } catch (Exception ignored) {}
                    }
                }
            }
        }
        catch (IndexOutOfBoundsException | NullPointerException e)
        {
            //ignore
        }
        catch (Exception e)
        {
            BytecodeViewer.handleException(e);
        }
        finally
        {
            viewer.resetDivider();
            BytecodeViewer.updateBusyStatus(false);
            SwingUtilities.invokeLater(() ->
            {
                if (button != null)
                    button.setEnabled(true);
            });
        }
    }
    
    public void startNewThread()
    {
        thread = new Thread(this, "Pane Update");
        thread.start();
    }

    @Override
    public void run()
    {
        if(bytecodeViewPanel.decompiler == Decompiler.NONE)
            return;
        
        processDisplay();
    
        if(bytecodeViewPanel.decompiler == Decompiler.HEXCODE_VIEWER)
            return;
        
        //nullcheck broken pane
        if(updateUpdaterTextArea == null || updateUpdaterTextArea.getScrollPane() == null
                || updateUpdaterTextArea.getScrollPane().getViewport() == null)
        {
            //build an error message
            SwingUtilities.invokeLater(() ->
                    buildTextArea(bytecodeViewPanel.decompiler, "Critical BCV Error"));
            return;
        }
        
        //this still freezes the swing UI
        synchronizePane();
    }

    public final CaretListener caretListener = new CaretListener()
    {
        @Override
        public void caretUpdate(CaretEvent e)
        {
            MethodParser methods = viewer.methods.get(bytecodeViewPanel.panelIndex);
            if (methods != null)
            {
                int methodLine = methods.findActiveMethod(updateUpdaterTextArea.getCaretLineNumber());
                
                if (methodLine != -1) {
                    if (BytecodeViewer.viewer.showClassMethods.isSelected()) {
                        if (methodsList != null) {
                            if (methodLine != (int) Objects.requireNonNull(methodsList.getSelectedItem())) {
                                methodsList.setSelectedItem(methodLine);
                            }
                        }
                    }
                    if (BytecodeViewer.viewer.synchronizedViewing.isSelected()) {
                        int panes = 2;
                        if (viewer.bytecodeViewPanel3 != null)
                            panes = 3;

                        for (int i = 0; i < panes; i++) {
                            if (i != bytecodeViewPanel.panelIndex) {
                                ClassViewer.selectMethod(viewer, i, methods.getMethod(methodLine));
                            }
                        }
                    }
                }
            }
        }
    };

    public final ChangeListener viewportListener = new ChangeListener() {
        @Override
        public void stateChanged(ChangeEvent e) {
            int panes = 2;
            if (viewer.bytecodeViewPanel3 != null)
                panes = 3;

            if (BytecodeViewer.viewer.synchronizedViewing.isSelected()) {
                if (updateUpdaterTextArea.isShowing() && (updateUpdaterTextArea.hasFocus() || updateUpdaterTextArea.getMousePosition() != null)) {
                    int caretLine = updateUpdaterTextArea.getCaretLineNumber();
                    int maxViewLine = ClassViewer.getMaxViewLine(updateUpdaterTextArea);
                    int activeViewLine = ClassViewer.getViewLine(updateUpdaterTextArea);
                    int activeLine = (activeViewLine == maxViewLine && caretLine > maxViewLine) ? caretLine :
                            activeViewLine;
                    int activeLineDelta = -1;
                    MethodParser.Method activeMethod = null;
                    MethodParser activeMethods = viewer.methods.get(bytecodeViewPanel.panelIndex);
                    if (activeMethods != null) {
                        int activeMethodLine = activeMethods.findActiveMethod(activeLine);
                        if (activeMethodLine != -1) {
                            activeLineDelta = activeLine - activeMethodLine;
                            activeMethod = activeMethods.getMethod(activeMethodLine);
                            ClassViewer.selectMethod(updateUpdaterTextArea, activeMethodLine);
                        }
                    }
                    for (int i = 0; i < panes; i++) {
                        if (i != bytecodeViewPanel.panelIndex) {
                            int setLine = -1;

                            RSyntaxTextArea area = null;
                            switch (i) {
                            case 0:
                                area = viewer.bytecodeViewPanel1.updateThread.updateUpdaterTextArea;
                                break;
                            case 1:
                                area = viewer.bytecodeViewPanel2.updateThread.updateUpdaterTextArea;
                                break;
                            case 2:
                                area = viewer.bytecodeViewPanel3.updateThread.updateUpdaterTextArea;
                                break;
                            }

                            if (area != null) {
                                if (activeMethod != null && activeLineDelta >= 0) {
                                    MethodParser methods = viewer.methods.get(i);
                                    if (methods != null) {
                                        int methodLine = methods.findMethod(activeMethod);
                                        if (methodLine != -1) {
                                            int viewLine = ClassViewer.getViewLine(area);
                                            if (activeLineDelta != viewLine - methodLine) {
                                                setLine = methodLine + activeLineDelta;
                                            }
                                        }
                                    }
                                } else if (activeLine != ClassViewer.getViewLine(area)) {
                                    setLine = activeLine;
                                }
                                if (setLine >= 0) {
                                    ClassViewer.setViewLine(area, setLine);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    
    public void synchronizePane()
    {
        if(bytecodeViewPanel.decompiler == Decompiler.HEXCODE_VIEWER
                || bytecodeViewPanel.decompiler == Decompiler.NONE)
            return;
        
        SwingUtilities.invokeLater(()->
        {
            JViewport viewport = updateUpdaterTextArea.getScrollPane().getViewport();
            viewport.addChangeListener(viewportListener);
            updateUpdaterTextArea.addCaretListener(caretListener);
        });
        
        final MethodParser methods = viewer.methods.get(bytecodeViewPanel.panelIndex);
        for (int i = 0; i < updateUpdaterTextArea.getLineCount(); i++)
        {
            String lineText = updateUpdaterTextArea.getLineText(i);
            Matcher regexMatcher = MethodParser.regex.matcher(lineText);
            if (regexMatcher.find())
            {
                String methodName = regexMatcher.group("name");
                String methodParams = regexMatcher.group("params");
                methods.addMethod(i, methodName, methodParams);
            }
        }

        //TODO fix this
        if (BytecodeViewer.viewer.showClassMethods.isSelected())
        {
            if (!methods.isEmpty())
            {
                methodsList = new JComboBox<>();
                
                for (Integer line : methods.getMethodsLines())
                    methodsList.addItem(line);
                
                methodsList.setRenderer(new MethodsRenderer(this));
                methodsList.addActionListener(e ->
                {
                    int line = (int) Objects.requireNonNull(methodsList.getSelectedItem());

                    RSyntaxTextArea area = null;
                    switch (bytecodeViewPanel.panelIndex)
                    {
                        case 0:
                            area = viewer.bytecodeViewPanel1.updateThread.updateUpdaterTextArea;
                            break;
                        case 1:
                            area = viewer.bytecodeViewPanel2.updateThread.updateUpdaterTextArea;
                            break;
                        case 2:
                            area = viewer.bytecodeViewPanel3.updateThread.updateUpdaterTextArea;
                            break;
                    }

                    if (area != null)
                        ClassViewer.selectMethod(area, line);
                });

                JPanel panel = new JPanel(new BorderLayout());
                panel.add(updateUpdaterTextArea.getScrollPane().getColumnHeader().getComponent(0), BorderLayout.NORTH);
                panel.add(methodsList, BorderLayout.SOUTH);
                methodsList.setBackground(BLANK_COLOR);
    
                SwingUtilities.invokeLater(()->
                {
                    updateUpdaterTextArea.getScrollPane().getColumnHeader().removeAll();
                    updateUpdaterTextArea.getScrollPane().getColumnHeader().add(panel);
                });
            }
        }
    }
    
    public void buildTextArea(Decompiler decompiler, String decompiledSource)
    {
        updateUpdaterTextArea = new SearchableRSyntaxTextArea();
        
        Configuration.rstaTheme.apply(updateUpdaterTextArea);
        bytecodeViewPanel.add(updateUpdaterTextArea.getScrollPane());
        bytecodeViewPanel.add(updateUpdaterTextArea.getTitleHeader(), BorderLayout.NORTH);
        
        bytecodeViewPanel.textArea = updateUpdaterTextArea;
        bytecodeViewPanel.textArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JAVA);
        bytecodeViewPanel.textArea.setCodeFoldingEnabled(true);
        bytecodeViewPanel.textArea.setAntiAliasingEnabled(true);
        bytecodeViewPanel.textArea.setText(decompiledSource);
        bytecodeViewPanel.textArea.setCaretPosition(0);
        bytecodeViewPanel.textArea.setEditable(isPanelEditable);
        
        if(isPanelEditable && decompiler == Decompiler.SMALI_DISASSEMBLER)
            bytecodeViewPanel.compiler = Compiler.SMALI_ASSEMBLER;
        else if(isPanelEditable && decompiler == Decompiler.KRAKATAU_DISASSEMBLER)
            bytecodeViewPanel.compiler = Compiler.KRAKATAU_ASSEMBLER;
        
        String editable = isPanelEditable ? " - " + EDITABLE : "";
        bytecodeViewPanel.textArea.getTitleHeader().setText(decompiler.getDecompilerName() + editable);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/util/DelayTabbedPaneThread.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.util;

import java.awt.Color;
import javax.swing.SwingUtilities;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.TabbedPane;

/**
 * @author Konloch
 */
public class DelayTabbedPaneThread extends Thread
{
    public boolean stopped = false;
    private final TabbedPane pane;

    public DelayTabbedPaneThread(TabbedPane pane) {
        this.pane = pane;
    }

    @Override
    public void run() {
        try {
            sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (!stopped) {
            SwingUtilities.invokeLater(() -> {
                if (stopped)
                    return;

                pane.label.setOpaque(true);
                pane.label.setBackground(Color.MAGENTA);
                pane.label.updateUI();
            });
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/gui/util/StringMetricsUtil.java`:

```java
package the.bytecode.club.bytecodeviewer.gui.util;

import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.FontRenderContext;
import java.awt.geom.Rectangle2D;

/**
 * @author http://stackoverflow.com/a/18450804
 */
public class StringMetricsUtil
{
	Font font;
	FontRenderContext context;
	
	public StringMetricsUtil(Graphics2D g2)
	{
		font = g2.getFont();
		context = g2.getFontRenderContext();
	}
	
	public Rectangle2D getBounds(String message)
	{
		return font.getStringBounds(message, context);
	}
	
	public double getWidth(String message)
	{
		Rectangle2D bounds = getBounds(message);
		return bounds.getWidth();
	}
	
	public double getHeight(String message)
	{
		Rectangle2D bounds = getBounds(message);
		return bounds.getHeight();
	}
	
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/CodeScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner;

import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */

public interface CodeScanner
{
	void scanningClass(MalwareScan scan, ClassNode cn);
	
	void scanFields(MalwareScan scan, ClassNode cn, FieldNode[] fields);
	
	void scanMethods(MalwareScan scan, ClassNode cn, MethodNode[] methods);
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/MalwareCodeScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.decompilers.bytecode.InstructionPrinter;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.SearchableString;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The base class for the malware code scanners
 *
 * @author Konloch
 * @since 6/27/2021
 */
public abstract class MalwareCodeScanner implements CodeScanner
{
	private final InstructionPrinter instructionPrinter = new InstructionPrinter(null, null);
	public MalwareScanModule module;
	
	public abstract void scanFieldString(MalwareScan scan, ClassNode cn, FieldNode field, SearchableString string);
	
	public abstract void scanMethodString(MalwareScan scan, ClassNode cn, MethodNode method, SearchableString string);
	
	public abstract void scanMethodInstruction(MalwareScan scan, ClassNode cn, MethodNode method, AbstractInsnNode instruction);
	
	@Override
	public void scanningClass(MalwareScan scan, ClassNode cn)
	{
		scanFields(scan, cn, cn.fields.toArray(new FieldNode[0]));
		scanMethods(scan, cn, cn.methods.toArray(new MethodNode[0]));
	}
	
	@Override
	public void scanFields(MalwareScan scan, ClassNode cn, FieldNode[] fields)
	{
		for (FieldNode field : fields)
		{
			Object fieldValue = field.value;
			
			//scan strings
			if (fieldValue instanceof String)
				scanFieldString(scan, cn, field, new SearchableString((String) fieldValue));
			
			//scan string array
			else if (fieldValue instanceof String[])
				for(String s : (String[]) fieldValue)
					scanFieldString(scan, cn, field, new SearchableString(s));
		}
	}
	
	@Override
	public void scanMethods(MalwareScan scan, ClassNode cn, MethodNode[] methods)
	{
		for (MethodNode method : methods)
		{
			InsnList instructionList = method.instructions;
			
			//scan each instruction
			for (AbstractInsnNode instruction : instructionList.toArray())
			{
				scanMethodInstruction(scan, cn, method, instruction);
				
				if (instruction instanceof LdcInsnNode)
				{
					if (((LdcInsnNode) instruction).cst instanceof String)
					{
						final String string = (String) ((LdcInsnNode) instruction).cst;
						scanMethodString(scan, cn, method, new SearchableString(string));
					}
				}
			}
		}
	}
	
	public String fieldToString(ClassNode cn, FieldNode field)
	{
		return cn.name + "." + field.name + "(" + field.desc + ")";
	}
	
	public String methodToString(ClassNode cn, MethodNode method)
	{
		return cn.name + "." + method.name + "(" + method.desc + ")";
	}
	
	public String instructionToString(AbstractInsnNode instruction)
	{
		return instructionPrinter.printInstruction(instruction).trim();
	}
	
	public String header()
	{
		String header = String.format("%30s", (module.getReadableName() + " ->\t"));
		
		//TODO display the resource container for this specific ClassNode
		if(BytecodeViewer.viewer.showFileInTabTitle.isSelected())
			header += "{fileContainerGoesHere}\t";
		
		return header;
	}
	
	public void foundLDC(MalwareScan scan, String ldc, String foundAt)
	{
		scan.sb.append(header()).append(" Found LDC \"").append(ldc).append("\" ").append(foundAt);
	}
	
	public void foundMethod(MalwareScan scan, String foundAt)
	{
		scan.sb.append(header()).append(" Found Method call to ").append(foundAt);
	}
	
	public void found(MalwareScan scan, String found)
	{
		scan.sb.append(header()).append(" Found ").append(found);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/MalwareScan.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner;

import java.util.List;
import java.util.Set;
import org.objectweb.asm.tree.ClassNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A new malware scan object is created any time the MalicousCodeScanner plugin is ran
 *
 * This contains all of the details for the scan, including what should be scanned,
 * and what was detected during the scan.
 *
 * @author Konloch
 * @since 6/27/2021
 */
public class MalwareScan
{
	public final List<ClassNode> classNodeList;
	public final StringBuilder sb;
	public final Set<String> scanOptions;
	
	public MalwareScan(List<ClassNode> classNodeList, StringBuilder sb, Set<String> scanOptions)
	{
		this.classNodeList = classNodeList;
		this.sb = sb;
		this.scanOptions = scanOptions;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/MalwareScanModule.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner;

import org.apache.commons.text.WordUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.malwarescanner.impl.AWTRobotScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.impl.JavaIOScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.impl.JavaNetScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.impl.JavaRuntimeScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.impl.NullSecurityManagerScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.impl.ReflectionScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.impl.URLScanner;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * All of the installed malware scan modules
 *
 * @author Konloch
 * @since 6/27/2021
 */
public enum MalwareScanModule
{
	URL_SCANNER("Scan String URLs", new URLScanner(), true),
	REFLECTION_SCANNER("Scan Java Reflection", new ReflectionScanner(), false),
	JAVA_RUNTIME_SCANNER("Scan Java Runtime", new JavaRuntimeScanner(), true),
	JAVA_NET_SCANNER("Scan Java Net", new JavaNetScanner(), false),
	JAVA_IO_SCANNER("Scan Java IO", new JavaIOScanner(), false),
	AWT_ROBOT_SCANNER("Scan AWT Robot", new AWTRobotScanner(), true),
	NULL_SECURITY_MANAGER("Scan Null SecurityManager", new NullSecurityManagerScanner(), true),
	;
	
	static
	{
		for(MalwareScanModule module : values())
			module.malwareScanner.module = module;
	}
	
	private final String readableName;
	private final String optionText;
	private final MalwareCodeScanner malwareScanner;
	private final boolean toggledByDefault;
	
	MalwareScanModule(String optionText, MalwareCodeScanner malwareScanner, boolean toggledByDefault)
	{
		this.optionText = optionText;
		this.malwareScanner = malwareScanner;
		this.toggledByDefault = toggledByDefault;
		this.readableName = WordUtils.capitalizeFully(name().replace("_", " ").toLowerCase());
	}
	
	public String getOptionText()
	{
		return optionText;
	}
	
	public String getReadableName()
	{
		return readableName;
	}
	
	public CodeScanner getMalwareScanner()
	{
		return malwareScanner;
	}
	
	public boolean isToggledByDefault()
	{
		return toggledByDefault;
	}
	
	public static void performScan(MalwareScan scan)
	{
		for (ClassNode cn : scan.classNodeList)
		{
			for (MalwareScanModule module : values())
				if(scan.scanOptions.contains(module.name()))
					module.malwareScanner.scanningClass(scan, cn);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/impl/AWTRobotScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.impl;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareCodeScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScan;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.SearchableString;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Scans for any trace of java/awt/Robot inside of method instructions and strings
 *
 * @author Konloch
 * @since 6/27/2021
 */
public class AWTRobotScanner extends MalwareCodeScanner
{
	@Override
	public void scanFieldString(MalwareScan scan, ClassNode cn, FieldNode field, SearchableString string)
	{
		if(string.searchable.contains("java/awt/Robot")
				|| string.searchable.contains("java.awt.Robot"))
			foundLDC(scan, string.original, "at field " + fieldToString(cn, field) + nl);
	}
	
	@Override
	public void scanMethodString(MalwareScan scan, ClassNode cn, MethodNode method, SearchableString string)
	{
		if(string.searchable.contains("java/awt/Robot")
				|| string.searchable.contains("java.awt.Robot"))
			foundLDC(scan, string.original, "at method " + methodToString(cn, method) + nl);
	}
	
	@Override
	public void scanMethodInstruction(MalwareScan scan, ClassNode cn, MethodNode method, AbstractInsnNode instruction)
	{
		if (instruction instanceof MethodInsnNode)
		{
			final MethodInsnNode min = (MethodInsnNode) instruction;
			if (min.owner.startsWith("java/awt/Robot"))
				foundMethod(scan, instructionToString(instruction) + " at " + methodToString(cn, method) + nl);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/impl/JavaIOScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.impl;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareCodeScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScan;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.SearchableString;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public class JavaIOScanner extends MalwareCodeScanner
{
	@Override
	public void scanFieldString(MalwareScan scan, ClassNode cn, FieldNode field, SearchableString string) { }
	
	@Override
	public void scanMethodString(MalwareScan scan, ClassNode cn, MethodNode method, SearchableString string) { }
	
	@Override
	public void scanMethodInstruction(MalwareScan scan, ClassNode cn, MethodNode method, AbstractInsnNode instruction)
	{
		if (instruction instanceof MethodInsnNode)
		{
			final MethodInsnNode min = (MethodInsnNode) instruction;
			if (min.owner.startsWith("java/io"))
				foundMethod(scan, instructionToString(instruction) + " at " + methodToString(cn, method) + nl);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/impl/JavaNetScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.impl;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareCodeScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScan;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.SearchableString;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author WaterWolf
 * @since 10/02/2011
 */
public class JavaNetScanner extends MalwareCodeScanner
{
	@Override
	public void scanFieldString(MalwareScan scan, ClassNode cn, FieldNode field, SearchableString string) { }
	
	@Override
	public void scanMethodString(MalwareScan scan, ClassNode cn, MethodNode method, SearchableString string) { }
	
	@Override
	public void scanMethodInstruction(MalwareScan scan, ClassNode cn, MethodNode method, AbstractInsnNode instruction)
	{
		if (instruction instanceof MethodInsnNode)
		{
			final MethodInsnNode min = (MethodInsnNode) instruction;
			if (min.owner.startsWith("java/net"))
				foundMethod(scan, instructionToString(instruction) + " at " + methodToString(cn, method) + nl);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/impl/JavaRuntimeScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.impl;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareCodeScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScan;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.SearchableString;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Scans for any trace of java/lang/Runtime inside of method instructions and strings
 *
 * @author Konloch
 * @since 6/27/2021
 */
public class JavaRuntimeScanner extends MalwareCodeScanner
{
	@Override
	public void scanFieldString(MalwareScan scan, ClassNode cn, FieldNode field, SearchableString string)
	{
		if(string.searchable.contains("java/lang/Runtime")
				|| string.searchable.contains("java.lang.Runtime"))
			foundLDC(scan, string.original, "at field " + fieldToString(cn, field) + nl);
	}
	
	@Override
	public void scanMethodString(MalwareScan scan, ClassNode cn, MethodNode method, SearchableString string)
	{
		if(string.searchable.contains("java/lang/Runtime")
				|| string.searchable.contains("java.lang.Runtime"))
			foundLDC(scan, string.original, "at method " + methodToString(cn, method) + nl);
	}
	
	@Override
	public void scanMethodInstruction(MalwareScan scan, ClassNode cn, MethodNode method, AbstractInsnNode instruction)
	{
		if (instruction instanceof MethodInsnNode)
		{
			final MethodInsnNode min = (MethodInsnNode) instruction;
			if (min.owner.startsWith("java/lang/Runtime"))
				foundMethod(scan, instructionToString(instruction) + " at " + methodToString(cn, method) + nl);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/impl/NullSecurityManagerScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.impl;

import com.strobel.assembler.ir.OpCode;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareCodeScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScan;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.SearchableString;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Checks for the security manager getting set to null
 *
 * @author Konloch
 * @author Adrianherrera
 * @since 6/27/2021
 */
public class NullSecurityManagerScanner extends MalwareCodeScanner
{
	private int lastInstruction;
	
	@Override
	public void scanFieldString(MalwareScan scan, ClassNode cn, FieldNode field, SearchableString string) { }
	
	@Override
	public void scanMethodString(MalwareScan scan, ClassNode cn, MethodNode method, SearchableString string) { }
	
	@Override
	public void scanMethodInstruction(MalwareScan scan, ClassNode cn, MethodNode method, AbstractInsnNode instruction)
	{
		if (instruction instanceof MethodInsnNode && instruction.getOpcode() == Opcodes.INVOKESTATIC)
		{
			final MethodInsnNode min = (MethodInsnNode) instruction;
			final String owner = min.owner;
			final String name =  min.name;
			
			if(lastInstruction == OpCode.ACONST_NULL.getCode()
					&& owner.equals("java/lang/System")
					&& name.equals("setSecurityManager"))
			{
				found(scan, "Security Manager set to null at method " + methodToString(cn, method) + nl);
			}
		}
		
		lastInstruction = instruction.getOpcode();
	}
	
	@Override
	public void scanningClass(MalwareScan scan, ClassNode cn)
	{
		lastInstruction = 0;
		super.scanningClass(scan, cn);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/impl/ReflectionScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.impl;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareCodeScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScan;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.SearchableString;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Scans for method instructions containing java/lang/reflect
 *
 * @author Konloch
 * @author WaterWolf
 * @since 10/02/2011
 */
public class ReflectionScanner extends MalwareCodeScanner
{
	@Override
	public void scanFieldString(MalwareScan scan, ClassNode cn, FieldNode field, SearchableString string) { }
	
	@Override
	public void scanMethodString(MalwareScan scan, ClassNode cn, MethodNode method, SearchableString string) { }
	
	@Override
	public void scanMethodInstruction(MalwareScan scan, ClassNode cn, MethodNode method, AbstractInsnNode instruction)
	{
		if (instruction instanceof MethodInsnNode)
		{
			final MethodInsnNode min = (MethodInsnNode) instruction;
			if (min.owner.startsWith("java/lang/reflect"))
				foundMethod(scan, instructionToString(instruction) + " at " + methodToString(cn, method) + nl);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/impl/URLScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.impl;

import java.util.regex.Pattern;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareCodeScanner;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScan;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.SearchableString;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Scans strings for common URL patterns:
 *  Any string containing www
 *  Any string containing http://
 *  Any string containing https://
 *  Any string matching an IP pattern
 *
 * @author Konloch
 * @author WaterWolf
 * @since 10/02/2011
 */
public class URLScanner extends MalwareCodeScanner
{
	private static final Pattern ipPattern = Pattern.compile("\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b");
	
	@Override
	public void scanFieldString(MalwareScan scan, ClassNode cn, FieldNode field, SearchableString string)
	{
		if (string.searchable.contains("www.")
				|| string.searchable.contains("http://")
				|| string.searchable.contains("https://")
				|| ipPattern.matcher(string.searchable).matches())
			foundLDC(scan, string.original, "at field " + fieldToString(cn, field) + nl);
	}
	
	@Override
	public void scanMethodString(MalwareScan scan, ClassNode cn, MethodNode method, SearchableString string)
	{
		if (string.searchable.contains("www.")
				|| string.searchable.contains("http://")
				|| string.searchable.contains("https://")
				|| ipPattern.matcher(string.searchable).matches())
			foundLDC(scan, string.original, "at method " + methodToString(cn, method) + nl);
	}
	
	@Override
	public void scanMethodInstruction(MalwareScan scan, ClassNode cn, MethodNode method, AbstractInsnNode instruction) { }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/util/MaliciousCodeOptions.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.util;

import javax.swing.JCheckBox;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScanModule;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public class MaliciousCodeOptions
{
	private final MalwareScanModule module;
	private final JCheckBox checkBox;
	
	public MaliciousCodeOptions(MalwareScanModule module, JCheckBox checkBox)
	{
		this.module = module;
		this.checkBox = checkBox;
	}
	
	public JCheckBox getCheckBox()
	{
		return checkBox;
	}
	
	public MalwareScanModule getModule()
	{
		return module;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/malwarescanner/util/SearchableString.java`:

```java
package the.bytecode.club.bytecodeviewer.malwarescanner.util;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public class SearchableString
{
	public final String original;
	public final String searchable;
	
	public SearchableString(String original)
	{
		this.original = original;
		this.searchable = original.toLowerCase();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/JavaObfuscator.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators;

import java.util.ArrayList;
import java.util.List;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * An unfinished obfuscator.
 *
 * @author Konloch
 */

public abstract class JavaObfuscator extends Thread {

    @Override
    public void run() {
        BytecodeViewer.updateBusyStatus(true);
        Configuration.runningObfuscation = true;
        obfuscate();
        BytecodeViewer.refactorer.run();
        Configuration.runningObfuscation = false;
        BytecodeViewer.updateBusyStatus(false);
    }

    public int getStringLength() {
        if (BytecodeViewer.viewer.obfuscatorGroup.isSelected(BytecodeViewer.viewer.strongObf.getModel())) {
            return MAX_STRING_LENGTH;
        } else { // if(BytecodeViewer.viewer.obfuscatorGroup.isSelected(BytecodeViewer.viewer.lightObf.getModel()))
            // {
            return MIN_STRING_LENGTH;
        }
    }

    public static int MAX_STRING_LENGTH = 25;
    public static int MIN_STRING_LENGTH = 5;
    private final List<String> names = new ArrayList<>();

    protected String generateUniqueName(int length) {
        boolean found = false;
        String name = "";
        while (!found) {
            String nameTry = MiscUtils.randomString(1) + MiscUtils.randomStringNum(length - 1);
            if (!Character.isJavaIdentifierStart(nameTry.toCharArray()[0]))
                continue;

            if (!names.contains(nameTry)) {
                names.add(nameTry);
                name = nameTry;
                found = true;
            }
        }
        return name;
    }

    public abstract void obfuscate();
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/RenameClasses.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators;

import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ASMResourceUtil;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Rename classes.
 *
 * @author Konloch
 */

public class RenameClasses extends JavaObfuscator {

    @Override
    public void obfuscate() {
        int stringLength = getStringLength();

        System.out.println("Obfuscating class names...");
        for (ClassNode c : BytecodeViewer.getLoadedClasses()) {
            String newName = generateUniqueName(stringLength);
            ASMResourceUtil.renameClassNode(c.name, newName);
            c.name = newName;
        }

        System.out.println("Obfuscated class names.");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/RenameFields.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators;

import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ASMResourceUtil;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Rename fields.
 *
 * @author Konloch
 */

public class RenameFields extends JavaObfuscator {

    @Override
    public void obfuscate() {
        int stringLength = getStringLength();

        System.out.println("Obfuscating fields names...");
        for (ClassNode c : BytecodeViewer.getLoadedClasses()) {
            for (Object o : c.fields.toArray()) {
                FieldNode f = (FieldNode) o;
                String newName = generateUniqueName(stringLength);
                ASMResourceUtil.renameFieldNode(c.name, f.name, f.desc, null,
                        newName, null);
                f.name = newName;
            }
        }

        System.out.println("Obfuscated field names.");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/RenameMethods.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ASMResourceUtil;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Rename methods.
 *
 * @author Konloch
 */

public class RenameMethods extends JavaObfuscator {

    @Override
    public void obfuscate() {
        int stringLength = getStringLength();

        System.out.println("Obfuscating method names...");
        for (ClassNode c : BytecodeViewer.getLoadedClasses()) {
            for (Object o : c.methods.toArray()) {
                MethodNode m = (MethodNode) o;
                if (m.access != Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_STATIC
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_STATIC + Opcodes.ACC_PUBLIC
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_STATIC + Opcodes.ACC_PRIVATE
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_STATIC + Opcodes.ACC_PROTECTED
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_PUBLIC
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_PRIVATE
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_PROTECTED) {
                    if (!m.name.equals("main") && !m.name.equals("<init>")
                            && !m.name.equals("<clinit>")) {
                        String newName = generateUniqueName(stringLength);
                        ASMResourceUtil.renameMethodNode(c.name, m.name, m.desc,
                                null, newName, null);
                    }
                }
            }
        }

        System.out.println("Obfuscated method names.");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/HookMap.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

import java.util.ArrayList;
import java.util.List;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.FieldMappingData;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.MappingData;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.MethodMappingData;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

public class HookMap {

    protected List<MappingData> classes;
    protected List<FieldMappingData> fields;
    protected List<MethodMappingData> methods;

    public HookMap() {
        classes = new ArrayList<>();
        fields = new ArrayList<>();
        methods = new ArrayList<>();
    }

    public void addClass(MappingData clazz) {
        classes.add(clazz);
    }

    public void addField(FieldMappingData field) {
        fields.add(field);
    }

    public void addMethod(MethodMappingData method) {
        methods.add(method);
    }

    public List<MappingData> getClasses() {
        return classes;
    }

    public List<FieldMappingData> getFields() {
        return fields;
    }

    public List<MethodMappingData> getMethods() {
        return methods;
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/RefactorMapper.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.FieldMappingData;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.MappingData;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.MethodMappingData;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author sc4re
 */
public class RefactorMapper extends Remapper {

    protected final Map<String, MappingData> sortedClasses;
    protected final Map<String, MethodMappingData> sortedMethods;
    protected final Map<String, FieldMappingData> sortedFields;
    protected final List<String> mappingList;

    private final StringBuilder builder;

    public RefactorMapper(HookMap hookMap) {
        sortedClasses = new HashMap<>();
        sortedMethods = new HashMap<>();
        sortedFields = new HashMap<>();
        mappingList = new ArrayList<>();
        builder = new StringBuilder();
        for (MappingData hook : hookMap.getClasses()) {
            if (hook.getObfuscatedName().contains("$"))
                continue;
            String obfuscatedName = hook.getObfuscatedName();
            String refactoredName = hook.getRefactoredName();
            sortedClasses.put(obfuscatedName, hook);
            sortedClasses.put(refactoredName, hook);
        }
        for (MethodMappingData hook : hookMap.getMethods()) {
            String obfuscatedName = hook.getMethodName().getObfuscatedName();
            String obfuscatedDesc = hook.getMethodDesc();
            String obfuscatedCname = hook.getMethodOwner();
            sortedMethods.put(obfuscatedCname + "$$$$" + obfuscatedName + "$$$$" + obfuscatedDesc, hook);
        }
        for (FieldMappingData hook : hookMap.getFields()) {
            String obfuscatedName = hook.getName().getObfuscatedName();
            String obfuscatedDesc = hook.getDesc();
            String obfuscatedCname = hook.getFieldOwner();
            sortedFields.put(obfuscatedCname + "$$$$" + obfuscatedName + "$$$$" + obfuscatedDesc, hook);
        }
    }

    @Override
    public String map(String type) {
        if (sortedClasses.containsKey(type)) {
            String map = type + " --> " + sortedClasses.get(type).getRefactoredName() + "\n";
            if (!mappingList.contains(map))
                mappingList.add(map);

            return sortedClasses.get(type).getRefactoredName();
        }
        return type;
    }

    @Override
    public String mapFieldName(String owner, String name, String desc) {
        String obfKey = owner + "$$$$" + name + "$$$$" + desc;
        if (sortedFields.containsKey(obfKey)) {
            String map =
                    owner + "." + name + " --> " + owner + sortedFields.get(obfKey).getName().getRefactoredName() +
                            "\n";
            if (!mappingList.contains(map))
                mappingList.add(map);
            name = sortedFields.get(obfKey).getName().getRefactoredName();
        }
        return name;
    }

    @Override
    public String mapMethodName(String owner, String name, String desc) {
        String obfKey = owner + "$$$$" + name + "$$$$" + desc;
        if (sortedMethods.containsKey(obfKey)) {
            String map =
                    owner + "." + name + " --> " + owner + sortedMethods.get(obfKey).getMethodName().getRefactoredName() + "\n";
            if (!mappingList.contains(map))
                mappingList.add(map);
            name = sortedMethods.get(obfKey).getMethodName().getRefactoredName();
        }
        return name;
    }

    public void printMap() {
        for (String map : mappingList) {
            builder.append(map);
        }
        System.out.println(builder.toString());
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/Refactorer.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author sc4re
 */
public class Refactorer {

    protected HookMap hooks;

    public Refactorer() {
        hooks = new HookMap();
    }

    public HookMap getHooks() {
        return hooks;
    }

    public void run() {
        if (getHooks() == null)
            return;

        RefactorMapper mapper = new RefactorMapper(getHooks());
        //Map<String, ClassNode> refactored = new HashMap<>();
        for (ClassNode cn : BytecodeViewer.getLoadedClasses()) {
            //String oldName = cn.name;
            ClassReader cr = new ClassReader(getClassNodeBytes(cn));
            ClassWriter cw = new ClassWriter(cr, 0);
            RemappingClassAdapter rca = new RemappingClassAdapter(cw, mapper);
            cr.accept(rca, ClassReader.EXPAND_FRAMES);
            cr = new ClassReader(cw.toByteArray());
            cn = new ClassNode();
            cr.accept(cn, 0);
            //refactored.put(oldName, cn);
        }
        /*for (Map.Entry<String, ClassNode> factor : refactored.entrySet()) {
            BytecodeViewer.relocate(factor.getKey(), factor.getValue());
        }*/
        mapper.printMap();
    }

    private byte[] getClassNodeBytes(ClassNode cn) {
        ClassWriter cw = new ClassWriter(0);
        cn.accept(cw);
        return cw.toByteArray();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/Remapper.java`:

```java
/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

import org.objectweb.asm.Handle;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.signature.SignatureReader;
import org.objectweb.asm.signature.SignatureVisitor;
import org.objectweb.asm.signature.SignatureWriter;

/**
 * A class responsible for remapping types and names. Subclasses can override
 * the following methods:
 * <p>
 * <ul>
 * <li>{@link #map(String)} - map type</li>
 * <li>{@link #mapFieldName(String, String, String)} - map field name</li>
 * <li>{@link #mapMethodName(String, String, String)} - map method name</li>
 * </ul>
 *
 * @author Eugene Kuleshov
 */
public abstract class Remapper extends org.objectweb.asm.commons.Remapper {

    @Override
    public String mapDesc(String desc) {
        Type t = Type.getType(desc);
        switch (t.getSort()) {
        case Type.ARRAY:
            StringBuilder s = new StringBuilder(mapDesc(t.getElementType().getDescriptor()));
            for (int i = 0; i < t.getDimensions(); ++i) {
                s.insert(0, '[');
            }
            return s.toString();
        case Type.OBJECT:
            String newType = map(t.getInternalName());
            if (newType != null) {
                return 'L' + newType + ';';
            }
        }
        return desc;
    }

    private Type mapType(Type t) {
        switch (t.getSort()) {
        case Type.ARRAY:
            StringBuilder s = new StringBuilder(mapDesc(t.getElementType().getDescriptor()));
            for (int i = 0; i < t.getDimensions(); ++i) {
                s.insert(0, '[');
            }
            return Type.getType(s.toString());
        case Type.OBJECT:
            s = new StringBuilder(map(t.getInternalName()));
            return Type.getObjectType(s.toString());
        case Type.METHOD:
            return Type.getMethodType(mapMethodDesc(t.getDescriptor()));
        }
        return t;
    }

    @Override
    public String mapType(String type) {
        if (type == null) {
            return null;
        }
        return mapType(Type.getObjectType(type)).getInternalName();
    }

    @Override
    public String[] mapTypes(String[] types) {
        String[] newTypes = null;
        boolean needMapping = false;
        for (int i = 0; i < types.length; i++) {
            String type = types[i];
            String newType = map(type);
            if (newType != null && newTypes == null) {
                newTypes = new String[types.length];
                if (i > 0) {
                    System.arraycopy(types, 0, newTypes, 0, i);
                }
                needMapping = true;
            }
            if (needMapping) {
                newTypes[i] = newType == null ? type : newType;
            }
        }
        return needMapping ? newTypes : types;
    }

    @Override
    public String mapMethodDesc(String desc) {
        if ("()V".equals(desc)) {
            return desc;
        }

        Type[] args = Type.getArgumentTypes(desc);
        StringBuilder sb = new StringBuilder("(");
        for (Type arg : args) {
            sb.append(mapDesc(arg.getDescriptor()));
        }
        Type returnType = Type.getReturnType(desc);
        if (returnType == Type.VOID_TYPE) {
            sb.append(")V");
            return sb.toString();
        }
        sb.append(')').append(mapDesc(returnType.getDescriptor()));
        return sb.toString();
    }

    @Override
    public Object mapValue(Object value) {
        if (value instanceof Type) {
            return mapType((Type) value);
        }
        if (value instanceof Handle) {
            Handle h = (Handle) value;
            return new Handle(h.getTag(), mapType(h.getOwner()), mapMethodName(
                    h.getOwner(), h.getName(), h.getDesc()),
                    mapMethodDesc(h.getDesc()), h.getTag() == Opcodes.H_INVOKEINTERFACE);
        }
        return value;
    }

    /**
     * @param typeSignature true if signature is a FieldTypeSignature, such as the
     *                      signature parameter of the ClassVisitor.visitField or
     *                      MethodVisitor.visitLocalVariable methods
     */
    @Override
    public String mapSignature(String signature, boolean typeSignature) {
        if (signature == null) {
            return null;
        }
        SignatureReader r = new SignatureReader(signature);
        SignatureWriter w = new SignatureWriter();
        SignatureVisitor a = createSignatureRemapper(w);
        if (typeSignature) {
            r.acceptType(a);
        } else {
            r.accept(a);
        }
        return w.toString();
    }

    @Override
    protected SignatureVisitor createSignatureRemapper(SignatureVisitor v) {
        return new RemappingSignatureAdapter(v, this);
    }

    /**
     * Map method name to the new name. Subclasses can override.
     *
     * @param owner owner of the method.
     * @param name  name of the method.
     * @param desc  descriptor of the method.
     * @return new name of the method
     */
    @Override
    public String mapMethodName(String owner, String name, String desc) {
        return name;
    }

    /**
     * Map invokedynamic method name to the new name. Subclasses can override.
     *
     * @param name name of the invokedynamic.
     * @param desc descriptor of the invokedynamic.
     * @return new invokdynamic name.
     */
    @Override
    public String mapInvokeDynamicMethodName(String name, String desc) {
        return name;
    }

    /**
     * Map field name to the new name. Subclasses can override.
     *
     * @param owner owner of the field.
     * @param name  name of the field
     * @param desc  descriptor of the field
     * @return new name of the field.
     */
    @Override
    public String mapFieldName(String owner, String name, String desc) {
        return name;
    }

    /**
     * Map type name to the new name. Subclasses can override.
     */
    @Override
    public String map(String typeName) {
        return typeName;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/RemappingAnnotationAdapter.java`:

```java
/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.commons.Remapper;
import the.bytecode.club.bytecodeviewer.Constants;

/**
 * An {@link AnnotationVisitor} adapter for type remapping.
 *
 * @author Eugene Kuleshov
 */
public class RemappingAnnotationAdapter extends AnnotationVisitor {

    protected final org.objectweb.asm.commons.Remapper remapper;

    public RemappingAnnotationAdapter(final AnnotationVisitor av,
                                      final org.objectweb.asm.commons.Remapper remapper) {
        this(Constants.ASM_VERSION, av, remapper);
    }

    protected RemappingAnnotationAdapter(final int api,
                                         final AnnotationVisitor av, final Remapper remapper) {
        super(api, av);
        this.remapper = remapper;
    }

    @Override
    public void visit(String name, Object value) {
        av.visit(name, remapper.mapValue(value));
    }

    @Override
    public void visitEnum(String name, String desc, String value) {
        av.visitEnum(name, remapper.mapDesc(desc), value);
    }

    @Override
    public AnnotationVisitor visitAnnotation(String name, String desc) {
        AnnotationVisitor v = av.visitAnnotation(name, remapper.mapDesc(desc));
        return v == null ? null : (v == av ? this
                : new RemappingAnnotationAdapter(v, remapper));
    }

    @Override
    public AnnotationVisitor visitArray(String name) {
        AnnotationVisitor v = av.visitArray(name);
        return v == null ? null : (v == av ? this
                : new RemappingAnnotationAdapter(v, remapper));
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/RemappingClassAdapter.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.TypePath;
import the.bytecode.club.bytecodeviewer.Constants;

/**
 * A {@link ClassVisitor} for type remapping.
 *
 * @author Eugene Kuleshov
 */
public class RemappingClassAdapter extends ClassVisitor {

    protected final Remapper remapper;

    protected String className;

    public RemappingClassAdapter(final ClassVisitor cv, final Remapper remapper) {
        this(Constants.ASM_VERSION, cv, remapper);
    }

    protected RemappingClassAdapter(final int api, final ClassVisitor cv,
                                    final Remapper remapper) {
        super(api, cv);
        this.remapper = remapper;
    }

    @Override
    public void visit(int version, int access, String name, String signature,
                      String superName, String[] interfaces) {
        this.className = name;
        super.visit(version, access, remapper.mapType(name), remapper
                        .mapSignature(signature, false), remapper.mapType(superName),
                interfaces == null ? null : remapper.mapTypes(interfaces));
    }

    @Override
    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
        AnnotationVisitor av = super.visitAnnotation(remapper.mapDesc(desc),
                visible);
        return av == null ? null : createRemappingAnnotationAdapter(av);
    }

    @Override
    public AnnotationVisitor visitTypeAnnotation(int typeRef,
                                                 TypePath typePath, String desc, boolean visible) {
        AnnotationVisitor av = super.visitTypeAnnotation(typeRef, typePath,
                remapper.mapDesc(desc), visible);
        return av == null ? null : createRemappingAnnotationAdapter(av);
    }

    @Override
    public FieldVisitor visitField(int access, String name, String desc,
                                   String signature, Object value) {
        FieldVisitor fv = super.visitField(access,
                remapper.mapFieldName(className, name, desc),
                remapper.mapDesc(desc), remapper.mapSignature(signature, true),
                remapper.mapValue(value));
        return fv == null ? null : createRemappingFieldAdapter(fv);
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String desc,
                                     String signature, String[] exceptions) {
        String newDesc = remapper.mapMethodDesc(desc);
        MethodVisitor mv = super.visitMethod(access, remapper.mapMethodName(
                className, name, desc), newDesc, remapper.mapSignature(
                signature, false),
                exceptions == null ? null : remapper.mapTypes(exceptions));
        return mv == null ? null : createRemappingMethodAdapter(access,
                newDesc, mv);
    }

    @Override
    public void visitInnerClass(String name, String outerName,
                                String innerName, int access) {
        // TODO should innerName be changed?
        super.visitInnerClass(remapper.mapType(name), outerName == null ? null
                : remapper.mapType(outerName), innerName, access);
    }

    @Override
    public void visitOuterClass(String owner, String name, String desc) {
        super.visitOuterClass(remapper.mapType(owner), name == null ? null
                        : remapper.mapMethodName(owner, name, desc),
                desc == null ? null : remapper.mapMethodDesc(desc));
    }

    protected FieldVisitor createRemappingFieldAdapter(FieldVisitor fv) {
        return new RemappingFieldAdapter(fv, remapper);
    }

    protected MethodVisitor createRemappingMethodAdapter(int access,
                                                         String newDesc, MethodVisitor mv) {
        return new RemappingMethodAdapter(access, newDesc, mv, remapper);
    }

    protected AnnotationVisitor createRemappingAnnotationAdapter(
            AnnotationVisitor av) {
        return new RemappingAnnotationAdapter(av, remapper);
    }
}


```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/RemappingFieldAdapter.java`:

```java
/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.commons.Remapper;
import the.bytecode.club.bytecodeviewer.Constants;

/**
 * A {@link FieldVisitor} adapter for type remapping.
 *
 * @author Eugene Kuleshov
 */
public class RemappingFieldAdapter extends FieldVisitor {

    private final org.objectweb.asm.commons.Remapper remapper;

    public RemappingFieldAdapter(final FieldVisitor fv, final org.objectweb.asm.commons.Remapper remapper) {
        this(Constants.ASM_VERSION, fv, remapper);
    }

    protected RemappingFieldAdapter(final int api, final FieldVisitor fv,
                                    final Remapper remapper) {
        super(api, fv);
        this.remapper = remapper;
    }

    @Override
    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
        AnnotationVisitor av = fv.visitAnnotation(remapper.mapDesc(desc),
                visible);
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }

    @Override
    public AnnotationVisitor visitTypeAnnotation(int typeRef,
                                                 TypePath typePath, String desc, boolean visible) {
        AnnotationVisitor av = super.visitTypeAnnotation(typeRef, typePath,
                remapper.mapDesc(desc), visible);
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/RemappingMethodAdapter.java`:

```java
/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.TypePath;
import org.objectweb.asm.commons.LocalVariablesSorter;
import org.objectweb.asm.commons.Remapper;
import the.bytecode.club.bytecodeviewer.Constants;

/**
 * A {@link LocalVariablesSorter} for type mapping.
 *
 * @author Eugene Kuleshov
 */
public class RemappingMethodAdapter extends LocalVariablesSorter {

    protected final org.objectweb.asm.commons.Remapper remapper;

    public RemappingMethodAdapter(final int access, final String desc,
                                  final MethodVisitor mv, final org.objectweb.asm.commons.Remapper remapper) {
        this(Constants.ASM_VERSION, access, desc, mv, remapper);
    }

    protected RemappingMethodAdapter(final int api, final int access,
                                     final String desc, final MethodVisitor mv, final Remapper remapper) {
        super(api, access, desc, mv);
        this.remapper = remapper;
    }

    @Override
    public AnnotationVisitor visitAnnotationDefault() {
        AnnotationVisitor av = super.visitAnnotationDefault();
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }

    @Override
    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
        AnnotationVisitor av = super.visitAnnotation(remapper.mapDesc(desc),
                visible);
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }

    @Override
    public AnnotationVisitor visitTypeAnnotation(int typeRef,
                                                 TypePath typePath, String desc, boolean visible) {
        AnnotationVisitor av = super.visitTypeAnnotation(typeRef, typePath,
                remapper.mapDesc(desc), visible);
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }

    @Override
    public AnnotationVisitor visitParameterAnnotation(int parameter,
                                                      String desc, boolean visible) {
        AnnotationVisitor av = super.visitParameterAnnotation(parameter,
                remapper.mapDesc(desc), visible);
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }

    @Override
    public void visitFrame(int type, int nLocal, Object[] local, int nStack,
                           Object[] stack) {
        super.visitFrame(type, nLocal, remapEntries(nLocal, local), nStack,
                remapEntries(nStack, stack));
    }

    private Object[] remapEntries(int n, Object[] entries) {
        for (int i = 0; i < n; i++) {
            if (entries[i] instanceof String) {
                Object[] newEntries = new Object[n];
                if (i > 0) {
                    System.arraycopy(entries, 0, newEntries, 0, i);
                }
                do {
                    Object t = entries[i];
                    newEntries[i++] = t instanceof String ? remapper
                            .mapType((String) t) : t;
                } while (i < n);
                return newEntries;
            }
        }
        return entries;
    }

    @Override
    public void visitFieldInsn(int opcode, String owner, String name,
                               String desc) {
        super.visitFieldInsn(opcode, remapper.mapType(owner),
                remapper.mapFieldName(owner, name, desc),
                remapper.mapDesc(desc));
    }

    @Deprecated
    @Override
    public void visitMethodInsn(final int opcode, final String owner,
                                final String name, final String desc) {
        if (api >= Constants.ASM_VERSION) {
            super.visitMethodInsn(opcode, owner, name, desc);
            return;
        }
        doVisitMethodInsn(opcode, owner, name, desc,
                opcode == Opcodes.INVOKEINTERFACE);
    }

    @Override
    public void visitMethodInsn(final int opcode, final String owner,
                                final String name, final String desc, final boolean itf) {
        if (api < Constants.ASM_VERSION) {
            super.visitMethodInsn(opcode, owner, name, desc, itf);
            return;
        }
        doVisitMethodInsn(opcode, owner, name, desc, itf);
    }

    private void doVisitMethodInsn(int opcode, String owner, String name,
                                   String desc, boolean itf) {
        // Calling super.visitMethodInsn requires to call the correct version
        // depending on this.api (otherwise infinite loops can occur). To
        // simplify and to make it easier to automatically remove the backward
        // compatibility code, we inline the code of the overridden method here.
        // IMPORTANT: THIS ASSUMES THAT visitMethodInsn IS NOT OVERRIDDEN IN
        // LocalVariableSorter.
        if (mv != null) {
            mv.visitMethodInsn(opcode, remapper.mapType(owner),
                    remapper.mapMethodName(owner, name, desc),
                    remapper.mapMethodDesc(desc), itf);
        }
    }

    @Override
    public void visitInvokeDynamicInsn(String name, String desc, Handle bsm,
                                       Object... bsmArgs) {
        for (int i = 0; i < bsmArgs.length; i++) {
            bsmArgs[i] = remapper.mapValue(bsmArgs[i]);
        }
        super.visitInvokeDynamicInsn(
                remapper.mapInvokeDynamicMethodName(name, desc),
                remapper.mapMethodDesc(desc), (Handle) remapper.mapValue(bsm),
                bsmArgs);
    }

    @Override
    public void visitTypeInsn(int opcode, String type) {
        super.visitTypeInsn(opcode, remapper.mapType(type));
    }

    @Override
    public void visitLdcInsn(Object cst) {
        super.visitLdcInsn(remapper.mapValue(cst));
    }

    @Override
    public void visitMultiANewArrayInsn(String desc, int dims) {
        super.visitMultiANewArrayInsn(remapper.mapDesc(desc), dims);
    }

    @Override
    public AnnotationVisitor visitInsnAnnotation(int typeRef,
                                                 TypePath typePath, String desc, boolean visible) {
        AnnotationVisitor av = super.visitInsnAnnotation(typeRef, typePath,
                remapper.mapDesc(desc), visible);
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }

    @Override
    public void visitTryCatchBlock(Label start, Label end, Label handler,
                                   String type) {
        super.visitTryCatchBlock(start, end, handler, type == null ? null
                : remapper.mapType(type));
    }

    @Override
    public AnnotationVisitor visitTryCatchAnnotation(int typeRef,
                                                     TypePath typePath, String desc, boolean visible) {
        AnnotationVisitor av = super.visitTryCatchAnnotation(typeRef, typePath,
                remapper.mapDesc(desc), visible);
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }

    @Override
    public void visitLocalVariable(String name, String desc, String signature,
                                   Label start, Label end, int index) {
        super.visitLocalVariable(name, remapper.mapDesc(desc),
                remapper.mapSignature(signature, true), start, end, index);
    }

    @Override
    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef,
                                                          TypePath typePath, Label[] start, Label[] end, int[] index,
                                                          String desc, boolean visible) {
        AnnotationVisitor av = super.visitLocalVariableAnnotation(typeRef,
                typePath, start, end, index, remapper.mapDesc(desc), visible);
        return av == null ? null : new RemappingAnnotationAdapter(av, remapper);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/RemappingSignatureAdapter.java`:

```java
/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package the.bytecode.club.bytecodeviewer.obfuscators.mapping;

import org.objectweb.asm.commons.Remapper;
import org.objectweb.asm.signature.SignatureVisitor;
import the.bytecode.club.bytecodeviewer.Constants;

/**
 * A {@link SignatureVisitor} adapter for type mapping.
 *
 * @author Eugene Kuleshov
 */
public class RemappingSignatureAdapter extends SignatureVisitor {

    private final SignatureVisitor v;

    private final org.objectweb.asm.commons.Remapper remapper;

    private String className;

    public RemappingSignatureAdapter(final SignatureVisitor v,
                                     final org.objectweb.asm.commons.Remapper remapper) {
        this(Constants.ASM_VERSION, v, remapper);
    }

    protected RemappingSignatureAdapter(final int api,
                                        final SignatureVisitor v, final Remapper remapper) {
        super(api);
        this.v = v;
        this.remapper = remapper;
    }

    @Override
    public void visitClassType(String name) {
        className = name;
        v.visitClassType(remapper.mapType(name));
    }

    @Override
    public void visitInnerClassType(String name) {
        String remappedOuter = remapper.mapType(className) + '$';
        className += '$' + name;
        String remappedName = remapper.mapType(className);
        int index = remappedName.startsWith(remappedOuter) ? remappedOuter
                .length() : remappedName.lastIndexOf('$') + 1;
        v.visitInnerClassType(remappedName.substring(index));
    }

    @Override
    public void visitFormalTypeParameter(String name) {
        v.visitFormalTypeParameter(name);
    }

    @Override
    public void visitTypeVariable(String name) {
        v.visitTypeVariable(name);
    }

    @Override
    public SignatureVisitor visitArrayType() {
        v.visitArrayType();
        return this;
    }

    @Override
    public void visitBaseType(char descriptor) {
        v.visitBaseType(descriptor);
    }

    @Override
    public SignatureVisitor visitClassBound() {
        v.visitClassBound();
        return this;
    }

    @Override
    public SignatureVisitor visitExceptionType() {
        v.visitExceptionType();
        return this;
    }

    @Override
    public SignatureVisitor visitInterface() {
        v.visitInterface();
        return this;
    }

    @Override
    public SignatureVisitor visitInterfaceBound() {
        v.visitInterfaceBound();
        return this;
    }

    @Override
    public SignatureVisitor visitParameterType() {
        v.visitParameterType();
        return this;
    }

    @Override
    public SignatureVisitor visitReturnType() {
        v.visitReturnType();
        return this;
    }

    @Override
    public SignatureVisitor visitSuperclass() {
        v.visitSuperclass();
        return this;
    }

    @Override
    public void visitTypeArgument() {
        v.visitTypeArgument();
    }

    @Override
    public SignatureVisitor visitTypeArgument(char wildcard) {
        v.visitTypeArgument(wildcard);
        return this;
    }

    @Override
    public void visitEnd() {
        v.visitEnd();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/data/FieldMappingData.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.mapping.data;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

public class FieldMappingData {

    protected String fieldOwner;
    protected MappingData name;
    protected String desc;

    public FieldMappingData(MappingData name, String desc) {
        this("", name, desc);
    }

    public FieldMappingData(String fieldOwner, MappingData name, String desc) {
        this.fieldOwner = fieldOwner;
        this.name = name;
        this.desc = desc;
    }

    public String getFieldOwner() {
        return fieldOwner;
    }

    public FieldMappingData setFieldOwner(String fieldOwner) {
        this.fieldOwner = fieldOwner;
        return this;
    }

    public MappingData getName() {
        return name;
    }

    public FieldMappingData setName(MappingData name) {
        this.name = name;
        return this;
    }

    public String getDesc() {
        return desc;
    }

    public FieldMappingData setDesc(String desc) {
        this.desc = desc;
        return this;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = (prime * result) + ((desc == null) ? 0 : desc.hashCode());
        result = (prime * result) + ((fieldOwner == null) ? 0 : fieldOwner.hashCode());
        result = (prime * result) + ((name == null) ? 0 : name.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        FieldMappingData other = (FieldMappingData) obj;
        if (desc == null) {
            if (other.desc != null)
                return false;
        } else if (!desc.equals(other.desc))
            return false;
        if (fieldOwner == null) {
            if (other.fieldOwner != null)
                return false;
        } else if (!fieldOwner.equals(other.fieldOwner))
            return false;
        if (name == null) {
            return other.name == null;
        } else return name.equals(other.name);
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/data/MappingData.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.mapping.data;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

public class MappingData {

    protected String obfuscatedName;
    protected String refactoredName;

    public MappingData(String refactoredName) {
        this("", refactoredName);
    }

    public MappingData(String obfuscatedName, String refactoredName) {
        this.obfuscatedName = obfuscatedName;
        this.refactoredName = refactoredName;
    }

    public String getObfuscatedName() {
        return obfuscatedName;
    }

    public MappingData setObfuscatedName(String obfuscatedName) {
        this.obfuscatedName = obfuscatedName;
        return this;
    }

    public String getRefactoredName() {
        return refactoredName;
    }

    public MappingData setRefactoredName(String refactoredName) {
        this.refactoredName = refactoredName;
        return this;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = (prime * result) + ((obfuscatedName == null) ? 0 : obfuscatedName.hashCode());
        result = (prime * result) + ((refactoredName == null) ? 0 : refactoredName.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        MappingData other = (MappingData) obj;
        if (obfuscatedName == null) {
            if (other.obfuscatedName != null)
                return false;
        } else if (!obfuscatedName.equals(other.obfuscatedName))
            return false;
        if (refactoredName == null) {
            return other.refactoredName == null;
        } else return refactoredName.equals(other.refactoredName);
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/mapping/data/MethodMappingData.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.mapping.data;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

public class MethodMappingData {

    protected String methodOwner;
    protected MappingData methodName;
    protected String methodDesc;

    public MethodMappingData(MappingData methodName, String methodDesc) {
        this("", methodName, methodDesc);
    }

    public MethodMappingData(String methodOwner, MappingData methodName, String methodDesc) {
        this.methodOwner = methodOwner;
        this.methodName = methodName;
        this.methodDesc = methodDesc;
    }

    public String getMethodOwner() {
        return methodOwner;
    }

    public MethodMappingData setMethodOwner(String methodOwner) {
        this.methodOwner = methodOwner;
        return this;
    }

    public MappingData getMethodName() {
        return methodName;
    }

    public MethodMappingData setMethodName(MappingData methodName) {
        this.methodName = methodName;
        return this;
    }

    public String getMethodDesc() {
        return methodDesc;
    }

    public MethodMappingData setMethodDesc(String methodDesc) {
        this.methodDesc = methodDesc;
        return this;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = (prime * result) + ((methodDesc == null) ? 0 : methodDesc.hashCode());
        result = (prime * result) + ((methodName == null) ? 0 : methodName.hashCode());
        result = (prime * result) + ((methodOwner == null) ? 0 : methodOwner.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        MethodMappingData other = (MethodMappingData) obj;
        if (methodDesc == null) {
            if (other.methodDesc != null)
                return false;
        } else if (!methodDesc.equals(other.methodDesc))
            return false;
        if (methodName == null) {
            if (other.methodName != null)
                return false;
        } else if (!methodName.equals(other.methodName))
            return false;
        if (methodOwner == null) {
            return other.methodOwner == null;
        } else return methodOwner.equals(other.methodOwner);
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/rename/RenameClasses.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.rename;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.obfuscators.JavaObfuscator;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.MappingData;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Rename classes.
 *
 * @author Konloch
 */

public class RenameClasses extends JavaObfuscator {

    public static void open()
    {
        if (Configuration.runningObfuscation) {
            BytecodeViewer.showMessage("You're currently running an obfuscation task, wait for this to finish"
                    + ".");
            return;
        }
        new RenameClasses().start();
        BytecodeViewer.viewer.workPane.refreshClass.doClick();
        BytecodeViewer.viewer.resourcePane.tree.updateUI();
    }
    
    @Override
    public void obfuscate() {
        int stringLength = 5;//getStringLength();

        System.out.println("Obfuscating class names...");
        classLoop:
        for (ClassNode c : BytecodeViewer.getLoadedClasses()) {

            /* As we dont want to rename classes that contain native dll methods */
            for (MethodNode o : c.methods) {
                /* As we dont want to rename any  main-classes */
                if (o.name.equals("main") && o.desc.equals("([Ljava/lang/String;)V")
                        || o.name.equals("init") && c.superName.equals("java/applet/Applet"))
                    continue classLoop;

                /* As we dont want to rename native dll methods */
                if ((o.access & Opcodes.ACC_NATIVE) != 0)
                    continue classLoop;
            }

            String newName = generateUniqueName(stringLength);

            BytecodeViewer.refactorer.getHooks().addClass(new MappingData(c.name, newName));
			
			/*ASMUtil_OLD.renameClassNode(c.name, newName);
			c.name = newName;*/
        }

        System.out.println("Obfuscated class names.");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/rename/RenameFields.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.rename;

import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.obfuscators.JavaObfuscator;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.FieldMappingData;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.MappingData;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Rename fields.
 *
 * @author Konloch
 */

public class RenameFields extends JavaObfuscator {

    public static void open()
    {
        if (Configuration.runningObfuscation) {
            BytecodeViewer.showMessage("You're currently running an obfuscation task, wait for this to finish.");
            return;
        }
        new RenameFields().start();
        BytecodeViewer.viewer.workPane.refreshClass.doClick();
        BytecodeViewer.viewer.resourcePane.tree.updateUI();
    }
    
    @Override
    public void obfuscate() {
        int stringLength = getStringLength();

        System.out.println("Obfuscating fields names...");
        for (ClassNode c : BytecodeViewer.getLoadedClasses()) {
            for (Object o : c.fields.toArray()) {
                FieldNode f = (FieldNode) o;

                String newName = generateUniqueName(stringLength);

                BytecodeViewer.refactorer.getHooks().addField(new FieldMappingData(c.name, new MappingData(f.name,
                        newName), f.desc));
				
				/*ASMUtil_OLD.renameFieldNode(c.name, f.name, f.desc, null, newName, null);
				f.name = newName;*/
            }
        }

        System.out.println("Obfuscated field names.");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/obfuscators/rename/RenameMethods.java`:

```java
package the.bytecode.club.bytecodeviewer.obfuscators.rename;

import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.obfuscators.JavaObfuscator;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.MappingData;
import the.bytecode.club.bytecodeviewer.obfuscators.mapping.data.MethodMappingData;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Rename methods.
 *
 * @author Konloch
 */

public class RenameMethods extends JavaObfuscator {

    public static void open()
    {
        if (Configuration.runningObfuscation) {
            BytecodeViewer.showMessage("You're currently running an obfuscation task, wait for this to finish"
                    + ".");
            return;
        }
        new RenameMethods().start();
        BytecodeViewer.viewer.workPane.refreshClass.doClick();
        BytecodeViewer.viewer.resourcePane.tree.updateUI();
    }
    
    @Override
    public void obfuscate() {
        int stringLength = getStringLength();

        System.out.println("Obfuscating method names...");
        for (ClassNode c : BytecodeViewer.getLoadedClasses()) {
            for (Object o : c.methods.toArray()) {
                MethodNode m = (MethodNode) o;

                /* As we dont want to rename native dll methods */
                if ((m.access & Opcodes.ACC_NATIVE) != 0)
                    continue;

                if (m.access != Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_STATIC
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_STATIC + Opcodes.ACC_PUBLIC
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_STATIC + Opcodes.ACC_PRIVATE
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_STATIC + Opcodes.ACC_PROTECTED
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_PUBLIC
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_PRIVATE
                        && m.access != Opcodes.ACC_ABSTRACT
                        + Opcodes.ACC_PROTECTED) {
                    if (!m.name.equals("main") && !m.name.equals("<init>")
                            && !m.name.equals("<clinit>")) {
                        String newName = generateUniqueName(stringLength);

                        BytecodeViewer.refactorer.getHooks().addMethod(new MethodMappingData(c.name,
                                new MappingData(m.name, newName), m.desc));
						
						/*ASMUtil_OLD.renameMethodNode(c.name, m.name, m.desc,
								null, newName, null);*/
                    }
                }
            }
        }

        System.out.println("Obfuscated method names.");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/PluginLaunchStrategy.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin;

import java.io.File;
import the.bytecode.club.bytecodeviewer.api.Plugin;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Bibl (don't ban me pls)
 * @created 1 Jun 2015
 */
public interface PluginLaunchStrategy {

    Plugin run(File file) throws Throwable;
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/PluginManager.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.swing.filechooser.FileFilter;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.api.ExceptionUI;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;
import the.bytecode.club.bytecodeviewer.gui.components.JFrameConsoleTabbed;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ComponentViewer;
import the.bytecode.club.bytecodeviewer.plugin.strategies.CompiledJavaPluginLaunchStrategy;
import the.bytecode.club.bytecodeviewer.plugin.strategies.GroovyPluginLaunchStrategy;
import the.bytecode.club.bytecodeviewer.plugin.strategies.JavaPluginLaunchStrategy;
import the.bytecode.club.bytecodeviewer.plugin.strategies.JavascriptPluginLaunchStrategy;
import the.bytecode.club.bytecodeviewer.plugin.strategies.PythonPluginLaunchStrategy;
import the.bytecode.club.bytecodeviewer.plugin.strategies.RubyPluginLaunchStrategy;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Supports loading of groovy, python or ruby scripts.
 *
 * Only allows one plugin to be running at once.
 *
 * @author Konloch
 * @author Bibl
 * @since 01/16/16, 14:36, Adaptable PluginLaunchStrategy system.
 */

public final class PluginManager
{
    private static final Map<String, PluginLaunchStrategy> launchStrategies = new HashMap<>();
    private static final PluginFileFilter filter = new PluginFileFilter();
    private static final List<Plugin> pluginInstances = new ArrayList<>();
    
    //TODO this system needs to be redone, currently it will conflict if more than one plugin is ran at the same time
    // the solution is to tie the plugin object into the plugin console,
    // then move all of this into the plugin class as non-static objects
    
    private static Plugin activePlugin;
    private static JFrameConsoleTabbed activeTabbedConsole;
    private static JFrameConsoleTabbed activeTabbedException;
    private static final Map<String, ExceptionUI> exceptionTabs = new HashMap<>();
    private static int consoleCount = 0;
    private static int exceptionCount = 0;
    private static int errorCounter = 1;

    static
    {
        launchStrategies.put("jar", new CompiledJavaPluginLaunchStrategy());
        launchStrategies.put("java", new JavaPluginLaunchStrategy());
        launchStrategies.put("js", new JavascriptPluginLaunchStrategy());

        GroovyPluginLaunchStrategy groovy = new GroovyPluginLaunchStrategy();
        launchStrategies.put("gy", groovy);
        launchStrategies.put("groovy", groovy);

        PythonPluginLaunchStrategy python = new PythonPluginLaunchStrategy();
        launchStrategies.put("py", python);
        launchStrategies.put("python", python);

        RubyPluginLaunchStrategy ruby = new RubyPluginLaunchStrategy();
        launchStrategies.put("rb", ruby);
        launchStrategies.put("ruby", ruby);
    }

    /**
     * Runs a new plugin instance
     *
     * @param newPluginInstance the new plugin instance
     */
    public static void runPlugin(Plugin newPluginInstance)
    {
        if (activePlugin != null && !activePlugin.isFinished())
        {
            BytecodeViewer.showMessage(TranslatedStrings.ONE_PLUGIN_AT_A_TIME.toString());
            return;
        }
        
        //reset the console count
        consoleCount = 0;
        exceptionCount = 0;
        
        //reset the active tabbed console
        activeTabbedConsole = null;
        activeTabbedException = null;
        exceptionTabs.clear();
    
        //reset the active plugin
        activePlugin = newPluginInstance;
        
        //clean the plugin list from dead threads
        pluginInstances.removeIf(Plugin::isFinished);
        
        //add to the list of running instances
        pluginInstances.add(newPluginInstance);
        
        //start the plugin thread
        newPluginInstance.start();
    }

    /**
     * Starts and runs a plugin from file
     *
     * @param f the file of the plugin
     * @throws Exception
     */
    public static void runPlugin(File f) throws Throwable
    {
        String ext = f.getName().substring(f.getName().lastIndexOf('.') + 1);
        PluginLaunchStrategy strategy = launchStrategies.get(ext);

        if (strategy == null)
            throw new RuntimeException(String.format("No launch strategy for extension %s (%s)", ext, f.getAbsolutePath()));

        Plugin p = strategy.run(f);

        if (p != null)
            runPlugin(p);
    }
    
    /**
     * Add an active console from a plugin being ran
     */
    public static void addExceptionUI(ExceptionUI ui)
    {
        if(activePlugin == null)
        {
            ui.setLocationRelativeTo(BytecodeViewer.viewer);
            ui.setVisible(true);
            return;
        }
        
        final String name = activePlugin.activeContainer == null
                ? "#" + (activeTabbedException.getTabbedPane().getTabCount() + 1)
                : activePlugin.activeContainer.name;
        
        ExceptionUI existingUI = exceptionTabs.get(name);
        
        int id = exceptionCount++;
        if(activeTabbedException == null)
        {
            String title = "Error #" + errorCounter++;
            activeTabbedException = new JFrameConsoleTabbed(title);
            
            if(Configuration.pluginConsoleAsNewTab)
                ComponentViewer.addComponentAsTab(title, activeTabbedException.getComponent(0));
            else
                activeTabbedException.setVisible(true);
        }
    
        if(existingUI == null)
        {
            activeTabbedException.addConsole(ui.getComponent(0), name);
            exceptionTabs.put(name, ui);
        }
        else
            existingUI.appendText("\n\r" + ui.getTextArea().getText());
    }
    
    /**
     * Add an active console from a plugin being ran
     */
    public static void addConsole(PluginConsole console)
    {
        int id = consoleCount++;
    
        if(activeTabbedConsole == null)
        {
            activeTabbedConsole = new JFrameConsoleTabbed(console.getTitle());
            
            if(Configuration.pluginConsoleAsNewTab)
                ComponentViewer.addComponentAsTab(console.getTitle(), activeTabbedConsole.getComponent(0));
            else
                activeTabbedConsole.setVisible(true);
        }
    
        console.setConsoleID(id);
        
        final String name = (activePlugin == null || activePlugin.activeContainer == null)
                ? ("#" + (activeTabbedConsole.getTabbedPane().getTabCount() + 1))
                : activePlugin.activeContainer.name;
        
        activeTabbedConsole.addConsole(console.getComponent(0), name);
    }

    public static void register(String name, PluginLaunchStrategy strat) {
        launchStrategies.put(name, strat);
    }

    public static Set<String> pluginExtensions() {
        return launchStrategies.keySet();
    }
    
    public static Map<String, PluginLaunchStrategy> getLaunchStrategies()
    {
        return launchStrategies;
    }
    
    public static FileFilter fileFilter() {
        return filter;
    }

    public static class PluginFileFilter extends FileFilter
    {
        @Override
        public boolean accept(File f) {
            if (f.isDirectory())
                return true;

            return PluginManager.pluginExtensions().contains(MiscUtils.extension(f.getAbsolutePath()));
        }

        @Override
        public String getDescription() {
            return TranslatedStrings.SELECT_EXTERNAL_PLUGIN_DESCRIPTION.toString();
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/PluginTemplate.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin;

import java.io.IOException;
import org.apache.commons.io.FilenameUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/1/2021
 */
public enum PluginTemplate
{
	JAVA("/templates/Template_Plugin.java"),
	JAVASCRIPT("/templates/Template_Plugin.js"),
	;
	
	private final String resourcePath;
	private final String extension;
	private String contents;
	
	PluginTemplate(String resourcePath)
	{
		this.resourcePath = resourcePath;
		this.extension = FilenameUtils.getExtension(resourcePath);
	}
	
	public String getContents() throws IOException
	{
		if(contents == null)
			contents = IconResources.loadResourceAsString(resourcePath);
		
		return contents;
	}
	
	public String getExtension()
	{
		return extension;
	}
	
	public PluginWriter openEditorExceptionHandled()
	{
		try
		{
			return openEditor();
		}
		catch (IOException e)
		{
			BytecodeViewer.handleException(e);
		}
		
		return null;
	}
	
	public PluginWriter openEditor() throws IOException
	{
		PluginWriter writer = new PluginWriter(this);
		writer.setVisible(true);
		return writer;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/PluginWriter.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.io.File;
import java.io.IOException;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import com.google.common.io.Files;
import me.konloch.kontainer.io.DiskReader;
import me.konloch.kontainer.io.DiskWriter;
import org.apache.commons.compress.utils.FileNameUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.gui.components.SearchableRSyntaxTextArea;
import the.bytecode.club.bytecodeviewer.gui.resourceviewer.viewer.ComponentViewer;
import the.bytecode.club.bytecodeviewer.resources.IconResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJMenu;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJMenuItem;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;
import the.bytecode.club.bytecodeviewer.util.SyntaxLanguage;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;
import static the.bytecode.club.bytecodeviewer.Settings.addRecentPlugin;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/1/2021
 */

public class PluginWriter extends JFrame
{
	private SearchableRSyntaxTextArea area;
	private JMenuItem menuSaveAs;
	private JMenuItem menuSave;
	private String content;
	private String pluginName;
	private File savePath;
	
	public PluginWriter(PluginTemplate template) throws IOException
	{
		this.content = template.getContents();
		this.pluginName = "Template." + template.getExtension();
		buildGUI();
	}
	
	public PluginWriter(String content, String pluginName)
	{
		this.content = content;
		this.pluginName = pluginName;
		buildGUI();
	}
	
	public void buildGUI()
	{
		setTitle("Editing BCV Plugin: " + pluginName);
		setIconImages(IconResources.iconList);
		setSize(new Dimension(542, 316));
		
		area = (SearchableRSyntaxTextArea) Configuration.rstaTheme.apply(new SearchableRSyntaxTextArea());
		area.setOnCtrlS(this::save);
		area.setText(content);
		area.setCaretPosition(0);
		SyntaxLanguage.setLanguage(area, pluginName);
		content = null;
		
		JButton run = new JButton("Run");
		
		JMenuBar menuBar = new JMenuBar();
		JMenu menu = new TranslatedJMenu("File", TranslatedComponents.FILE);
		JMenuItem menuOpen = new TranslatedJMenuItem("Open...", TranslatedComponents.OPEN);
		JMenuItem menuRun = new TranslatedJMenuItem("Run", TranslatedComponents.RUN);
		menuSaveAs = new TranslatedJMenuItem("Save As...", TranslatedComponents.SAVE_AS);
		menuSave = new TranslatedJMenuItem("Save...", TranslatedComponents.SAVE);
		menuSave.setVisible(false);
		
		menuBar.add(menu);
		menu.add(menuOpen);
		menu.add(menuSaveAs);
		menu.add(menuSave);
		menu.add(menuRun);
		
		setJMenuBar(menuBar);
		add(area.getScrollPane());
		add(run, BorderLayout.SOUTH);
		
		menuOpen.addActionListener((l)->openPlugin());
		run.addActionListener((l)->runPlugin());
		menuRun.addActionListener((l)->runPlugin());
		menuSaveAs.addActionListener((l)-> save());
		menuSave.addActionListener((l)-> save());
		
		this.setLocationRelativeTo(null);
	}
	
	@Override
	public void setVisible(boolean b)
	{
		if(Configuration.pluginWriterAsNewTab)
		{
			Component component = getComponent(0);
			
			JPanel p = new JPanel(new BorderLayout());
			JPanel p2 = new JPanel(new BorderLayout());
			p.add(p2, BorderLayout.NORTH);
			p.add(component, BorderLayout.CENTER);

			JMenuBar menuBar = getJMenuBar();
			// As the Darklaf windows decorations steal the menu bar from the frame
			// it sets the preferred size to (0,0). Because we want to steal the menu bar ourselves.
			// we have to revert this change.
			// Remove when https://github.com/weisJ/darklaf/issues/258 is fixed and available in a
			// release.
			menuBar.setPreferredSize(null);
			p2.add(menuBar, BorderLayout.CENTER);

			ComponentViewer.addComponentAsTab(pluginName, p);
		}
		else
		{
			super.setVisible(b);
		}
	}
	
	public void setPluginName(String name)
	{
		this.pluginName = name;
		setTitle("Editing BCV Plugin: " + name);
	}
	
	public void openPlugin()
	{
		final File file = DialogUtils.fileChooser("Select External Plugin",
				"External Plugin",
				Configuration.getLastPluginDirectory(),
				PluginManager.fileFilter(),
				Configuration::setLastPluginDirectory,
				FileChooser.EVERYTHING);
		
		if(file == null || !file.exists())
			return;
		
		try
		{
			area.setText(DiskReader.loadAsString(file.getAbsolutePath()));
			area.setCaretPosition(0);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		
		setSourceFile(file);
	}
	
	public void runPlugin()
	{
		File tempFile = new File(tempDirectory + fs + "temp" + MiscUtils.randomString(32) + fs + pluginName);
		tempFile.getParentFile().mkdirs();
		
		try
		{
			//write to temporary file location
			Files.copy(savePath, tempFile);
			//run plugin from that location
			PluginManager.runPlugin(tempFile);
		}
		catch (Exception e)
		{
			BytecodeViewer.handleException(e);
		}
		catch (Throwable t)
		{
			t.printStackTrace();
		}
		finally
		{
			tempFile.getParentFile().delete();
		}
	}
	
	public void save()
	{
		Thread exportThread = new Thread(() ->
		{
			if (!BytecodeViewer.autoCompileSuccessful())
				return;
			
			if(savePath == null)
			{
				final String ext = FileNameUtils.getExtension(pluginName);
				JFileChooser fc = new FileChooser(Configuration.getLastPluginDirectory(),
						"Save Plugin",
						"BCV Plugin",
						ext);
				
				int returnVal = fc.showSaveDialog(BytecodeViewer.viewer);
				if (returnVal == JFileChooser.APPROVE_OPTION)
				{
					Configuration.setLastPluginDirectory(fc.getSelectedFile());
					
					File file = fc.getSelectedFile();
					String path = file.getAbsolutePath();
					
					//auto append extension
					if (!path.endsWith("." + ext))
						path += "." + ext;
					
					if (!DialogUtils.canOverwriteFile(path))
						return;
					
					//swap from save-as to having a defined path each save
					setSourceFile(new File(path));
				}
				else
				{
					return;
				}
			}
			
			DiskWriter.replaceFile(savePath.getAbsolutePath(), area.getText(), false);
			addRecentPlugin(savePath);
		}, "Plugin Editor Save");
		exportThread.start();
	}
	
	public void setSourceFile(File file)
	{
		menuSaveAs.setVisible(false);
		menuSave.setVisible(true);
		menuSaveAs.updateUI();
		menuSave.updateUI();
		savePath = file;
		setPluginName(file.getName());
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/AllatoriStringDecrypter.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.awt.Dimension;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.List;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.InvokeDynamicInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.api.ASMUtil;
import the.bytecode.club.bytecodeviewer.api.BCV;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog;
import the.bytecode.club.bytecodeviewer.plugin.PluginManager;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * An Allatori String Decrypter, targets an unknown (old) version.
 *
 * @author Konloch
 * @author Szperak
 * @since 08/15/2015
 */

public class AllatoriStringDecrypter extends Plugin
{
	final StringBuilder out = new StringBuilder();
	final String className;
	
	public AllatoriStringDecrypter(String className) {this.className = className;}
	
	@Override
	public void execute(List<ClassNode> classNodeList)
	{
		PluginConsole frame = new PluginConsole("Allatori String Decrypter");
		
		MultipleChoiceDialog dialog = new MultipleChoiceDialog("Bytecode Viewer - WARNING",
				"WARNING: This will load the classes into the JVM and execute the allatori decrypter function"
						+ nl + "for each class. IF THE FILE YOU'RE LOADING IS MALICIOUS, DO NOT CONTINUE.",
				new String[]{"Continue", "Cancel"});
		
		if (dialog.promptChoice() == 0)
		{
			try
			{
				if (!className.equals("*"))
				{
					for (ClassNode classNode : classNodeList)
					{
						if (classNode.name.equals(className))
							scanClassNode(classNode);
					}
				}
				else
				{
					for (ClassNode classNode : classNodeList)
					{
						scanClassNode(classNode);
					}
				}
			}
			catch (Exception e)
			{
				BytecodeViewer.handleException(e, "github.com/Szperak");
			}
			finally
			{
				frame.appendText(out.toString());
				frame.setVisible(true);
			}
		}
	}
	
	private void log(String msg)
	{
		out.append(msg);
		out.append(Constants.nl);
	}
	
	public void scanClassNode(ClassNode classNode) throws Exception
	{
		for (MethodNode method : classNode.methods)
			scanMethodNode(classNode, method);
	}
	
	public int readUnsignedShort(byte[] b, final int index)
	{
		return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);
	}
	
	private int getConstantPoolSize(String className)
	{
		byte[] fileContents = activeContainer.getFileContents(className + ".class");
		return readUnsignedShort(fileContents, 8);
	}
	
	public void scanMethodNode(ClassNode classNode, MethodNode methodNode) throws Exception
	{
		InsnList iList = methodNode.instructions;
		
		log("Scanning method " + methodNode.name + " of " + classNode.name);
		
		LdcInsnNode laststringldconstack = null;
		for (AbstractInsnNode i : iList.toArray())
		{
			if (i instanceof LdcInsnNode)
			{
				LdcInsnNode ldcI = (LdcInsnNode) i;
				if (ldcI.cst instanceof String)
					laststringldconstack = ldcI;
				continue;
			}
			else if (i instanceof MethodInsnNode)
			{
				MethodInsnNode methodI = (MethodInsnNode) i;
				
				// Decryption is always a static call - 0xb8 - invokestatic
				if (laststringldconstack != null && methodI.getOpcode() == 0xb8)
				{
					String decrypterClassName = methodI.owner;
					String decrypterMethodName = methodI.name;
					
					// Decrypter is always a static method of other class's inner class
					if (decrypterClassName.contains("$"))
					{
						byte[] decrypterFileContents = activeContainer.getFileContents(decrypterClassName + ".class");
						
						// We have to create new node for editing
						// Also, one decrypter method could be used for multiple methods in code, what gives us only part of string decrypted
						ClassNode decrypterClassNode = ASMUtil.bytesToNode(decrypterFileContents);
						MethodNode decryptermethodnode = ASMUtil.getMethodByName(decrypterClassNode, decrypterMethodName);
						
						if (decryptermethodnode != null)
						{
							String keyString = (getConstantPoolSize(classNode.name) +
									classNode.name +
									methodNode.name +
									getConstantPoolSize(classNode.name)
							);
							
							int newHashCode = keyString.hashCode();
							
							scanDecrypter(decryptermethodnode, newHashCode);
							
							try
							{
								System.out.println("Loading " + decrypterClassName);
								
								Class<?> decrypterClassList = BCV
										.loadClassIntoClassLoader(decrypterClassNode);
								
								String decrypted = invokeDecrypter(decrypterClassList, decrypterMethodName, (String) laststringldconstack.cst);
								
								if (decrypted != null)
								{
									log("Succesfully invoked decrypter method: " + decrypted);
									laststringldconstack.cst = decrypted;
									iList.remove(methodI);
								}
							}
							catch (IndexOutOfBoundsException | ClassNotFoundException | IOException e)
							{
								e.printStackTrace();
								log("Could not load decrypter class: " + decrypterClassName);
							}
							
						}
						else
						{
							log("Could not find decrypter method (" + decrypterMethodName + ") of class " + decrypterClassName);
						}
					}
				}
				
			}
			else if (i instanceof InvokeDynamicInsnNode)
			{
				InvokeDynamicInsnNode methodi = (InvokeDynamicInsnNode) i;
				if (methodi.getOpcode() == 0xba)
				{
					// TODO: Safe-reflection deobfuscator here
					// Allatori replaces invokeinterface and invokestatic with invokedynamic
					
					//log(methodi.bsm.getOwner()+" dot "+methodi.bsm.getName());
					//iList.set(methodi, new MethodInsnNode(0xb8, methodi.bsm.getOwner(), methodi.bsm.getName(), methodi.bsm.getDesc(), false));
					
				}
			}
			
			laststringldconstack = null;
		}
	}
	
	private boolean scanDecrypter(MethodNode decryptermethodnode, int newHashCode)
	{
		InsnList iList = decryptermethodnode.instructions;
		
		AbstractInsnNode insn = null, removeInsn;
		for (AbstractInsnNode i : iList.toArray())
		{
			if (i instanceof MethodInsnNode)
			{
				MethodInsnNode methodi = ((MethodInsnNode) i);
				if ("currentThread".equals(methodi.name)) // find code form this instruction
				{
					insn = i;
					break;
				}
				
			}
			
		}
		
		if (insn == null)
			return false;
		
		while (insn != null)
		{
			if (insn instanceof MethodInsnNode)
			{
				MethodInsnNode methodi = ((MethodInsnNode) insn);
				
				if ("hashCode".equals(methodi.name)) // to this instruction
					break;
			}
			removeInsn = insn;
			insn = insn.getNext();
			iList.remove(removeInsn); // and remove it
		}
		
		if (insn == null)
			return false;
		
		iList.set(insn, new LdcInsnNode(newHashCode)); // then replace it with pre-computed key LDC
		return true;
	}
	
	private String invokeDecrypter(Class<?> decrypterclass, String name, String arg) throws Exception
	{
		try
		{
			Method decrypterMethod = decrypterclass.getDeclaredMethod(name, String.class);
			decrypterMethod.setAccessible(true);
			return (String) decrypterMethod.invoke(null, arg);
		}
		catch (Exception e)
		{
			log("Could not invoke decrypter method: " + name + " of class " + decrypterclass.getName());
			throw e;
		}
	}
	
	public static class AllatoriStringDecrypterOptions extends Plugin
	{
		@Override
		public void execute(List<ClassNode> classNodeList)
		{
			new AllatoriStringDecrypterOptionsFrame().setVisible(true);
		}
	}
	
	public static class AllatoriStringDecrypterOptionsFrame extends JFrame
	{
		private final JTextField textField;
		
		public AllatoriStringDecrypterOptionsFrame()
		{
			this.setIconImages(IconResources.iconList);
			setSize(new Dimension(250, 120));
			setResizable(false);
			setTitle("Allatori String Decrypter");
			getContentPane().setLayout(null);
			
			JButton btnNewButton = new JButton("Decrypt");
			btnNewButton.setBounds(6, 56, 232, 23);
			getContentPane().add(btnNewButton);
			
			JLabel lblNewLabel = new JLabel("Class:");
			lblNewLabel.setBounds(6, 20, 67, 14);
			getContentPane().add(lblNewLabel);
			
			textField = new JTextField();
			textField.setToolTipText("* will search all classes");
			textField.setText("*");
			textField.setBounds(80, 17, 158, 20);
			getContentPane().add(textField);
			textField.setColumns(10);
			
			btnNewButton.addActionListener(arg0 ->
			{
				PluginManager.runPlugin(new the.bytecode.club.bytecodeviewer.plugin.preinstalled.AllatoriStringDecrypter(textField.getText()));
				dispose();
			});
			
			this.setLocationRelativeTo(null);
		}
		
		private static final long serialVersionUID = -2662514582647810868L;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/ChangeClassFileVersions.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.util.List;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.Plugin;

/**
 * As long as there are no new opcodes or API changes you can use this plugin to downgrade compiled code
 *
 * 1) Import a JDK-11 (or higher) Jar resource inside of BCV
 * 2) Run this plugin
 * 3) Export as ZIP, then rename as Jar - Your ClassFiles will now run on JDK-8 (or whatever you selected)
 *
 * @author Konloch
 * @since 07/11/2021
 */
public class ChangeClassFileVersions extends Plugin
{
    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        //prompt dialog for version number
        // TODO: include a little diagram of what JDK is which number
        int newVersion = Integer.parseInt(BytecodeViewer.showInput("Class Version Number: (52 = JDK 8)"));
        
        //update the ClassFile version
        classNodeList.forEach(classNode -> classNode.version = newVersion);
        
        //update the the container's resource byte-arrays
        BytecodeViewer.updateAllClassNodeByteArrays();
        
        //force refresh all tabs (this forces the decompilers to run with the latest resource data)
        BytecodeViewer.refreshAllTabs();
        
        //alert the changes to the user
        BytecodeViewer.showMessage("Set all of the class versions to " + newVersion);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/CodeSequenceDiagram.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.view.mxGraph;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.geom.AffineTransform;
import java.util.List;
import javax.swing.JFrame;
import javax.swing.UIManager;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.plugin.PluginManager;
import the.bytecode.club.bytecodeviewer.resources.IconResources;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple code sequence diagram.
 *
 * @author Konloch
 */

public class CodeSequenceDiagram extends Plugin
{
    public static void open()
    {
        PluginManager.runPlugin(new CodeSequenceDiagram());
    }
    
    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        if (!BytecodeViewer.isActiveResourceClass())
        {
            BytecodeViewer.showMessage(TranslatedStrings.FIRST_VIEW_A_CLASS.toString());
            return;
        }
        
        ClassNode c = BytecodeViewer.getCurrentlyOpenedClassNode();
        JFrame frame = new JFrame("Code Sequence Diagram - " + c.name);

        frame.setIconImages(IconResources.iconList);
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        frame.setSize(400, 320);
        mxGraph graph = new mxGraph();
        graph.setVertexLabelsMovable(false);
        graph.setGridEnabled(true);
        graph.setEnabled(false);
        graph.setCellsEditable(false);
        graph.setCellsSelectable(false);
        graph.setCellsMovable(false);
        graph.setCellsLocked(true);
        Object parent = graph.getDefaultParent();
        Font font = UIManager.getDefaults().getFont("TabbedPane.font");
        AffineTransform affinetransform = new AffineTransform();
        FontRenderContext frc = new FontRenderContext(affinetransform, true, true);

        graph.getModel().beginUpdate();
        try
        {
            int testX = 10;
            int testY = 0;
            double magicNumber = 5.8;

            for (MethodNode m : c.methods)
            {
                String mIdentifier = c.name + "." + m.name + m.desc;
                Object attach = graph.insertVertex(parent, null, mIdentifier, testX, testY,
                        mIdentifier.length() * magicNumber, 30);
                testX += (int) (font.getStringBounds(mIdentifier, frc).getWidth()) + 60;
                for (AbstractInsnNode i : m.instructions.toArray())
                {
                    if (i instanceof MethodInsnNode)
                    {
                        MethodInsnNode mi = (MethodInsnNode) i;
                        String identifier = mi.owner + "." + mi.name + mi.desc;
                        Object node2 = graph.insertVertex(parent, null, identifier, testX, testY, identifier.length() * 5, 30);
                        testX += (int) (font.getStringBounds(identifier, frc).getWidth()) + 60;
                        graph.insertEdge(parent, null, null, attach, node2);
                        attach = node2;
                    }
                }
                
                testY += 60;
                testX = 10;
            }
        }
        finally
        {
            graph.getModel().endUpdate();
        }

        mxGraphComponent graphComponent = new mxGraphComponent(graph);
        frame.getContentPane().add(graphComponent);
        frame.setVisible(true);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/EZInjection.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.BCV;
import the.bytecode.club.bytecodeviewer.api.BytecodeHook;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;
import the.bytecode.club.bytecodeviewer.gui.plugins.GraphicalReflectionKit;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * EZ Injection - This plugin is designed to provide a graphical way for the
 * user to easily change the access modifiers of all fields/methods, insert
 * hooks into all functions, and invoke the main function. It also contains an
 * option to launch the graphical reflection kit, which is pretty much a GUI for
 * reflection.
 *
 * @author Konloch
 */

public class EZInjection extends Plugin
{
    public static List<BytecodeHook> hookArray = new ArrayList<>();
    private static final String version = "1.0";
    private final boolean accessModifiers;
    private final boolean injectHooks;
    private final boolean invokeMethod;
    private final boolean useProxy;
    private final boolean launchKit;
    private final boolean console;
    public static boolean sandboxSystem, sandboxRuntime, printCmdL;
    private static boolean debugHooks, all = false;
    private final String invokeMethodInformation;
    private final String proxy;

    private static String[] debugClasses;

    public EZInjection(boolean accessModifiers, boolean injectHooks,
                       boolean debugHooks, boolean invokeMethod,
                       String invokeMethodInformation, boolean sandboxRuntime,
                       boolean sandboxSystem, String debugClasses, String proxy,
                       boolean useProxy, boolean launchKit, boolean console,
                       boolean printCmdL)
    {
        BCV.createNewClassNodeLoaderInstance();
        this.accessModifiers = accessModifiers;
        this.injectHooks = injectHooks;
        EZInjection.debugHooks = debugHooks;
        this.invokeMethod = invokeMethod;
        this.invokeMethodInformation = invokeMethodInformation + "([Ljava/lang/String;)V";
        EZInjection.sandboxRuntime = sandboxRuntime;
        EZInjection.sandboxSystem = sandboxSystem;
        
        if (debugClasses.equals("*"))
            EZInjection.all = true;
        else
            EZInjection.debugClasses = debugClasses.split(",");
        
        this.proxy = proxy;
        this.useProxy = useProxy;
        this.launchKit = launchKit;
        this.console = console;
        EZInjection.printCmdL = printCmdL;
    }

    public static void setProxy(String host, String port)
    {
        System.setProperty("java.net.useSystemProxies", "true");
        System.setProperty("socksProxyHost", host);
        System.setProperty("socksProxyPort", port);
    }

    private static String lastMessage = "";

    public static void hook(String info)
    {
        for (BytecodeHook hook : hookArray)
            hook.callHook(info);

        if (debugHooks)
        {
            if (lastMessage.equals(info)) // just a small anti spam measurement
                return;

            lastMessage = info;
            boolean print = all;

            if (!all && debugClasses.length >= 1)
            {
                for (String s : debugClasses)
                {
                    if (info.split("\\.")[0].equals(s.replaceAll("\\.", "/")))
                    {
                        print = true;
                        break;
                    }
                }
            }

            if (print)
                print("Method call: " + info);
        }
    }

    public static void print(String message)
    {
        System.out.println(message);
    }

    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        if(console)
            new PluginConsole("EZ Injection v" + version);

        if (accessModifiers)
            print("Setting all of the access modifiers to public/public static.");
        
        if (injectHooks)
            print("Injecting hook...");
        
        if (debugHooks)
            print("Hooks are debugging.");
        else if (injectHooks)
            print("Hooks are not debugging.");
        else
            print("Hooks are disabled completely.");
        
        if (useProxy)
            print("Forcing proxy as '" + proxy + "'.");
        
        if (launchKit)
            print("Launching the Graphicial Reflection Kit upon a succcessful invoke of the main method.");
    
        //force everything to be public
        for (ClassNode classNode : classNodeList)
        {
            for (Object o : classNode.fields.toArray())
            {
                FieldNode f = (FieldNode) o;

                if (accessModifiers)
                {
                    if (f.access == Opcodes.ACC_PRIVATE
                            || f.access == Opcodes.ACC_PROTECTED)
                        f.access = Opcodes.ACC_PUBLIC;

                    if (f.access == Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC
                            || f.access == Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC)
                        f.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC;

                    if (f.access == Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL
                            || f.access == Opcodes.ACC_PROTECTED + Opcodes.ACC_FINAL)
                        f.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL;

                    if (f.access == Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC
                            || f.access == Opcodes.ACC_PROTECTED + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC)
                        f.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC;
                }
            }
            
            for (Object o : classNode.methods.toArray())
            {
                MethodNode m = (MethodNode) o;
                if (accessModifiers)
                {
                    if (m.access == Opcodes.ACC_PRIVATE
                            || m.access == Opcodes.ACC_PROTECTED)
                        m.access = Opcodes.ACC_PUBLIC;

                    if (m.access == Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC
                            || m.access == Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC)
                        m.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC;

                    if (m.access == Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL
                            || m.access == Opcodes.ACC_PROTECTED + Opcodes.ACC_FINAL)
                        m.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL;

                    if (m.access == Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC
                            || m.access == Opcodes.ACC_PROTECTED + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC)
                        m.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC;
                }

                if (injectHooks
                        && m.access != Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PUBLIC + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PRIVATE + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PROTECTED + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_FINAL + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PROTECTED + Opcodes.ACC_FINAL + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC + Opcodes.ACC_ABSTRACT
                        && m.access != Opcodes.ACC_PROTECTED + Opcodes.ACC_FINAL + Opcodes.ACC_STATIC + Opcodes.ACC_ABSTRACT)
                {
                    boolean inject = true;
                    if (m.instructions.size() >= 2
                            && m.instructions.get(1) instanceof MethodInsnNode)
                    {
                        MethodInsnNode mn = (MethodInsnNode) m.instructions.get(1);
    
                        // already been injected
                        if (mn.owner.equals(EZInjection.class.getName().replace(".", "/")))
                            inject = false;
                    }
                    
                    if (inject)
                    {
                        // make this function grab parameters eventually
                        m.instructions
                                .insert(new MethodInsnNode(
                                        Opcodes.INVOKESTATIC,
                                        EZInjection.class.getName().replace(".", "/"),
                                        "hook", "(Ljava/lang/String;)V"));
                        m.instructions.insert(new LdcInsnNode(classNode.name
                                + "." + m.name + m.desc));
                    }
                }
            }
        }

        if (useProxy)
        {
            try
            {
                String[] split = proxy.split(":");
                setProxy(split[0], split[1]);
            } catch (Exception e) {
                // ignore
            }
        }

        print("Done setting up.");

        setFinished();

        if (invokeMethod)
        {
            //start print debugging
            BytecodeViewer.sm.setPrinting(true);
            
            // load all the classnodes into the classloader
            for (ClassNode cn : BytecodeViewer.getLoadedClasses())
                BCV.getClassNodeLoader().addClass(cn);

            print("Attempting to find " + invokeMethodInformation + ":" + nl + nl);

            for (ClassNode classNode : classNodeList)
            {
                for (Object o : classNode.methods.toArray())
                {
                    MethodNode m = (MethodNode) o;
                    String methodInformation = classNode.name + "." + m.name + m.desc;
                    
                    if (invokeMethodInformation.equals(methodInformation))
                    {
                        for (Method m2 : BCV
                                .getClassNodeLoader().nodeToClass(classNode)
                                .getMethods())
                        {
                            if (m2.getName().equals(m.name))
                            {
                                print("Invoking " + invokeMethodInformation + ":" + nl + nl);
                                
                                GraphicalReflectionKit kit = launchKit ? new GraphicalReflectionKit() : null;
                                try
                                {
                                    if(kit != null)
                                        kit.setVisible(true);
                                    
                                    m2.invoke(classNode.getClass().getDeclaredConstructor().newInstance(), (Object[]) new String[1]);
                                    
                                    print("Finished running " + invokeMethodInformation);
                                }
                                catch (Exception e)
                                {
                                    StringWriter sw = new StringWriter();
                                    e.printStackTrace(new PrintWriter(sw));
                                    e.printStackTrace();
                                    print(sw.toString());
                                }
                                finally
                                {
                                    //disable print debugging
                                    BytecodeViewer.sm.setPrinting(false);
                                    
                                    if(kit != null)
                                        kit.setVisible(false);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/MaliciousCodeScanner.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScan;
import the.bytecode.club.bytecodeviewer.malwarescanner.MalwareScanModule;
import the.bytecode.club.bytecodeviewer.malwarescanner.util.MaliciousCodeOptions;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * The Malicious Code Scanner plugin. All of the core components have been moved to the malwarescanner package.
 *
 * This tool is used to help aid reverse engineers in identifying malicious code.
 *
 * @author Konloch
 * @author WaterWolf
 * @since 10/02/2011
 */

public class MaliciousCodeScanner extends Plugin
{
    public final List<MaliciousCodeOptions> options;

    public MaliciousCodeScanner(List<MaliciousCodeOptions> options)
    {
        this.options = options;
    }

    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        PluginConsole frame = new PluginConsole("Malicious Code Scanner");
        StringBuilder sb = new StringBuilder();
        
        Set<String> scanOptions = new HashSet<>();
        
        for(MaliciousCodeOptions option : options)
            if(option.getCheckBox().isSelected())
                scanOptions.add(option.getModule().name());
        
        //create a new code scan object with all of the scan options
        MalwareScan scan = new MalwareScan(classNodeList, sb, scanOptions);
        
        //scan the modules one by one
        MalwareScanModule.performScan(scan);

        frame.appendText(sb.toString());
        frame.setVisible(true);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/ReplaceStrings.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.util.List;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Replaces all string and string[] instances with whatever.
 *
 * @author Konloch
 */

public class ReplaceStrings extends Plugin
{
    PluginConsole frame;
    String originalLDC;
    String newLDC;
    String className;
    boolean contains;

    public ReplaceStrings(String originalLDC, String newLDC, String className, boolean contains)
    {
        this.originalLDC = originalLDC;
        this.newLDC = newLDC;
        this.className = className;
        this.contains = contains;
    }

    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        frame = new PluginConsole("Replace Strings");
        
        if (!className.equals("*"))
        {
            for (ClassNode classNode : classNodeList)
                if (classNode.name.equals(className))
                    scanClassNode(classNode);
        }
        else
        {
            for (ClassNode classNode : classNodeList)
                scanClassNode(classNode);
        }
        
        frame.setVisible(true);
    }

    public void scanClassNode(ClassNode classNode)
    {
        for (Object o : classNode.fields.toArray())
        {
            FieldNode f = (FieldNode) o;
            Object v = f.value;
            if (v instanceof String)
            {
                String s = (String) v;
                if (contains)
                {
                    if (s.contains(originalLDC))
                        f.value = ((String) f.value).replaceAll(originalLDC, newLDC);
                }
                else
                {
                    if (s.equals(originalLDC))
                        f.value = newLDC;
                }
            }
            
            if (v instanceof String[])
            {
                for (int i = 0; i < ((String[]) v).length; i++)
                {
                    String s = ((String[]) v)[i];
                    if (contains)
                    {
                        if (s.contains(originalLDC))
                        {
                            f.value = ((String[]) f.value)[i].replaceAll(originalLDC, newLDC);
                            String ugh = s.replaceAll("\\n", "\\\\n")
                                    .replaceAll("\\r", "\\\\r");
                            frame.appendText(classNode.name + "." + f.name + ""
                                    + f.desc + " -> \"" + ugh + "\" replaced with \""
                                    + s.replaceAll(originalLDC, newLDC) + "\"");
                        }
                    }
                    else
                    {
                        if (s.equals(originalLDC))
                        {
                            ((String[]) f.value)[i] = newLDC;
                            String ugh = s.replaceAll("\\n", "\\\\n")
                                    .replaceAll("\\r", "\\\\r");
                            frame.appendText(classNode.name + "." + f.name + ""
                                    + f.desc + " -> \"" + ugh + "\" replaced with \"" + newLDC + "\"");
                        }
                    }
                }
            }
        }

        for (Object o : classNode.methods.toArray())
        {
            MethodNode m = (MethodNode) o;
            InsnList iList = m.instructions;
            for (AbstractInsnNode a : iList.toArray())
            {
                if (a instanceof LdcInsnNode)
                {
                    if (((LdcInsnNode) a).cst instanceof String)
                    {
                        final String s = (String) ((LdcInsnNode) a).cst;
                        if (contains)
                        {
                            if (s.contains(originalLDC))
                            {
                                ((LdcInsnNode) a).cst = ((String) ((LdcInsnNode) a).cst)
                                        .replaceAll(originalLDC, newLDC);
                                String ugh = s.replaceAll("\\n", "\\\\n")
                                        .replaceAll("\\r", "\\\\r");
                                frame.appendText(classNode.name + "." + m.name + "" + m.desc
                                        + " -> \"" + ugh + "\" replaced with \""
                                        + s.replaceAll(originalLDC, newLDC)
                                        .replaceAll("\\n", "\\\\n")
                                        .replaceAll("\\r", "\\\\r")
                                        + "\"");
                            }
                        }
                        else
                        {
                            if (s.equals(originalLDC))
                            {
                                ((LdcInsnNode) a).cst = newLDC;
                                String ugh = s.replaceAll("\\n", "\\\\n")
                                        .replaceAll("\\r", "\\\\r");
                                frame.appendText(classNode.name + "." + m.name + "" + m.desc
                                        + " -> \"" + ugh + "\" replaced with \""
                                        + newLDC.replaceAll("\\n", "\\\\n")
                                        .replaceAll("\\r", "\\\\r")
                                        + "\"");
                            }
                        }
                    }
                }
            }
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/ShowAllStrings.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.util.List;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Simply shows all the non-empty strings in every single class
 *
 * @author Konloch
 */

public class ShowAllStrings extends Plugin
{
    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        PluginConsole frame = new PluginConsole("Show All Strings");
        StringBuilder sb = new StringBuilder();
        
        for (ClassNode classNode : classNodeList)
        {
            for (Object o : classNode.fields.toArray())
            {
                FieldNode f = (FieldNode) o;
                Object v = f.value;
                
                if (v instanceof String)
                {
                    String s = (String) v;
                    if (!s.isEmpty())
                        sb.append(classNode.name).append(".").append(f.name).append(f.desc).append(" -> \"")
                                .append(s.replaceAll("\\n", "\\\\n").replaceAll("\\r", "\\\\r"))
                                .append("\"").append(nl);
                }
                
                if (v instanceof String[])
                {
                    for (int i = 0; i < ((String[]) v).length; i++)
                    {
                        String s = ((String[]) v)[i];
                        if (!s.isEmpty())
                            sb.append(classNode.name).append(".").append(f.name).append(f.desc).append("[").append(i)
                                    .append("] -> \"").append(s.replaceAll("\\n", "\\\\n").replaceAll("\\r", "\\\\r"))
                                    .append("\"").append(nl);
                    }
                }
            }

            for (Object o : classNode.methods.toArray())
            {
                MethodNode m = (MethodNode) o;
                InsnList iList = m.instructions;
                
                for (AbstractInsnNode a : iList.toArray())
                {
                    if (a instanceof LdcInsnNode)
                    {
                        if (((LdcInsnNode) a).cst instanceof String)
                        {
                            final String s = (String) ((LdcInsnNode) a).cst;
                            if (!s.isEmpty())
                                sb.append(classNode.name).append(".").append(m.name).append(m.desc).append(" -> \"")
                                        .append(s.replaceAll("\\n", "\\\\n").replaceAll("\\r", "\\\\r"))
                                        .append("\"").append(nl);
                        }
                    }
                }
            }
        }
    
        frame.setText(sb.toString());
        frame.setVisible(true);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/ShowMainMethods.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Simply shows all classes that have a public static void main(String[])
 *
 * @author Konloch
 * @author Sh1ftchg
 */

public class ShowMainMethods extends Plugin
{
    private static final int PUBLIC_STATIC = Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC;

    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        PluginConsole frame = new PluginConsole("Show Main Methods");
        StringBuilder sb = new StringBuilder();
        
        for (ClassNode classNode : classNodeList)
        {
            for (Object o : classNode.methods.toArray())
            {
                MethodNode m = (MethodNode) o;

                if ((m.access & (PUBLIC_STATIC)) == PUBLIC_STATIC)
                {
                    if (m.name.equals("main") && m.desc.equals("([Ljava/lang/String;)V"))
                    {
                        sb.append(classNode.name);
                        sb.append(".");
                        sb.append(m.name);
                        sb.append(m.desc);
                        sb.append("\n");
                    }
                }
            }
        }

        if (sb.length() == 0)
            frame.appendText("No main methods found.");
        else
            frame.appendText(sb.toString());

        frame.setVisible(true);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/StackFramesRemover.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FrameNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;

public class StackFramesRemover extends Plugin
{
    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        AtomicInteger counter = new AtomicInteger();
        PluginConsole frame = new PluginConsole("StackFrames Remover");
        for (ClassNode cn : classNodeList)
        {
            for (MethodNode mn : cn.methods)
            {
                for (AbstractInsnNode insn : mn.instructions.toArray())
                {
                    if (insn instanceof FrameNode)
                    {
                        mn.instructions.remove(insn);
                        counter.incrementAndGet();
                    }
                }
            }
        }

        frame.appendText(String.format("Removed %s stackframes.", counter));
        frame.setVisible(true);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/ViewAPKAndroidPermissions.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.nio.charset.StandardCharsets;
import java.util.List;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;

/**
 * @author Konloch
 * @since 07/11/2021
 */
public class ViewAPKAndroidPermissions extends Plugin
{
    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        PluginConsole frame = new PluginConsole("Android Permissions");
        frame.setVisible(true);
        
        byte[] encodedAndroidManifest = activeContainer.getFileContents("AndroidManifest.xml");
        if(encodedAndroidManifest == null)
        {
            frame.appendText("This plugin only works on valid Android APKs");
            return;
        }
        
        byte[] decodedAndroidManifest = activeContainer.getFileContents("Decoded Resources/AndroidManifest.xml");
        if(decodedAndroidManifest != null)
        {
            String manifest = new String(decodedAndroidManifest, StandardCharsets.UTF_8);
            String[] lines = manifest.split("\r?\n");
            for(String line : lines)
                if(line.toLowerCase().contains("uses-permission"))
                {
                    String cleaned = line.trim();
                    if(cleaned.startsWith("<"))
                        cleaned = cleaned.substring(1);
                    if(cleaned.contains(" android:name=\""))
                        cleaned = cleaned.replace(" android:name=\"", ": ");
                    if(cleaned.endsWith("\"/>"))
                        cleaned = cleaned.substring(0, cleaned.length()-3);
                    frame.appendText(cleaned);
                }
        }
        else
            frame.appendText("Enable Settings>Decode APK Resources!");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/ViewManifest.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.nio.charset.StandardCharsets;
import java.util.List;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;

/**
 * @author Konloch
 * @since 07/11/2021
 */
public class ViewManifest extends Plugin
{
    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        PluginConsole frame = new PluginConsole("View Manifest");
        frame.setVisible(true);
        
        //TODO android APKs may have AndroidManifests that can be viewed normally, this should be checked
        byte[] encodedAndroidManifest = activeContainer.getFileContents("AndroidManifest.xml");
        if(encodedAndroidManifest != null)
        {
            frame.appendText("Android APK Manifest:\r");
            byte[] decodedAndroidManifest = activeContainer.getFileContents("Decoded Resources/AndroidManifest.xml");
            if(decodedAndroidManifest != null)
                frame.appendText(new String(decodedAndroidManifest, StandardCharsets.UTF_8));
            else
                frame.appendText("Enable Settings>Decode APK Resources!");
        }
        
        byte[] jarManifest = activeContainer.getFileContents("META-INF/MANIFEST.MF");
        if(jarManifest != null)
        {
            if(!frame.getTextArea().getText().isEmpty())
                frame.appendText("\r\n\r\n");
    
            frame.appendText("Java Jar Manifest:\r");
            frame.appendText(new String(jarManifest, StandardCharsets.UTF_8));
        }
        
        if(frame.getTextArea().getText().isEmpty())
            frame.appendText("Manifest not found!");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/ZKMStringDecrypter.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.util.List;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.Plugin;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Coming soon
 *
 * @author Konloch
 */

public class ZKMStringDecrypter extends Plugin
{
    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        BytecodeViewer.showMessage("This is a planned feature.");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/preinstalled/ZStringArrayDecrypter.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.preinstalled;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Objects;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.BCV;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.api.PluginConsole;
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Runs the classes then simply grabs the static String[] z
 *
 * @author Konloch
 * @author Righteous
 */

public class ZStringArrayDecrypter extends Plugin
{
    @Override
    public void execute(List<ClassNode> classNodeList)
    {
        PluginConsole gui = new PluginConsole("ZStringArray Decrypter");
        StringBuilder out = new StringBuilder();
    
        MultipleChoiceDialog dialog = new MultipleChoiceDialog("Bytecode Viewer - WARNING",
                "WARNING: This will load the classes into the JVM and execute the initialize function"
                        + nl + "for each class. IF THE FILE YOU'RE LOADING IS MALICIOUS, DO NOT CONTINUE.",
                new String[]{"Continue", "Cancel"});

        if (dialog.promptChoice() == 0)
        {
            boolean needsWarning = false;
            for (Class<?> cn :
                    Objects.requireNonNull(BCV.loadClassesIntoClassLoader()))
            {
                try
                {
                    Field[] fields = cn.getDeclaredFields();
                    for (Field field : fields)
                    {
                        if (field.getName().equals("z"))
                        {
                            out.append(cn.getName()).append(":").append(nl);
                            field.setAccessible(true);
                            if (field.get(null) != null && field.get(null) instanceof String[]
                                    && Modifier.isStatic(field.getModifiers()) && Modifier.isFinal(field.getModifiers()))
                            {
                                String[] fieldVal = (String[]) field.get(null);
                                for (int i = 0; i < fieldVal.length; i++)
                                    out.append("  z[").append(i).append("] = ").append(fieldVal[i]).append(nl);
                            }
                        }
                    }
                }
                catch (NoClassDefFoundError | Exception e)
                {
                    System.err.println("Failed loading class " + cn.getName());
                    e.printStackTrace();
                    needsWarning = true;
                }
            }

            if (needsWarning)
            {
                BytecodeViewer.showMessage("Some classes failed to decrypt, if you'd like to decrypt all of them"
                        + nl + "makes sure you include ALL the libraries it requires.");
            }

            gui.setText(out.toString());
            gui.setVisible(true);
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/strategies/CompiledJavaPluginLaunchStrategy.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.strategies;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.plugin.PluginLaunchStrategy;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @created 1 Jun 2015
 */
public class CompiledJavaPluginLaunchStrategy implements PluginLaunchStrategy {

    private static final String PLUGIN_CLASS_NAME = Plugin.class.getCanonicalName().replace(".", "/");

    private final Set<LoadedPluginData> loaded = new HashSet<>();

    @Override
    public Plugin run(File file) throws Throwable {
        Set<LoadedNodeData> set = loadData(file);

        LoadedNodeData pdata = null;
        for (LoadedNodeData d : set) {
            ClassNode cn = d.node;
            if (Objects.equals(cn.superName, PLUGIN_CLASS_NAME)) {
                if (pdata == null) {
                    pdata = d;
                } else {
                    throw new RuntimeException("Multiple plugin subclasses.");
                }
            }
        }

        LoadingClassLoader cl = new LoadingClassLoader(pdata, set);
        Plugin p = cl.pluginKlass.getDeclaredConstructor().newInstance();
        LoadedPluginData npdata = new LoadedPluginData(pdata, cl, p);
        loaded.add(npdata);

        return p;
    }

    public Set<LoadedPluginData> getLoaded() {
        return loaded;
    }

    private static Set<LoadedNodeData> loadData(File jarFile) throws Throwable
    {
        try (FileInputStream fis = new FileInputStream(jarFile);
             ZipInputStream jis = new ZipInputStream(fis)) {
            ZipEntry entry;

            Set<LoadedNodeData> set = new HashSet<>();

            while ((entry = jis.getNextEntry()) != null) {
                try {
                    String name = entry.getName();
                    if (name.endsWith(".class")) {
                        byte[] bytes = MiscUtils.getBytes(jis);
                        if (MiscUtils.getFileHeaderMagicNumber(bytes).equalsIgnoreCase("cafebabe")) {
                            try {
                                ClassReader cr = new ClassReader(bytes);
                                ClassNode cn = new ClassNode();
                                cr.accept(cn, 0);
                                LoadedNodeData data = new LoadedNodeData(bytes, cn);
                                set.add(data);
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        } else {
                            System.out.println(jarFile + ">" + name + ": Header does not start with CAFEBABE, ignoring.");
                        }
                    }
                } catch (Exception e) {
                    BytecodeViewer.handleException(e);
                } finally {
                    jis.closeEntry();
                }
            }

            return set;
        }
    }

    public static class LoadedNodeData {
        private final byte[] bytes;
        private final ClassNode node;

        public LoadedNodeData(byte[] bytes, ClassNode node) {
            this.bytes = bytes;
            this.node = node;
        }
    }

    public static class LoadedPluginData {
        private final LoadedNodeData data;
        private final LoadingClassLoader classLoader;
        private final Plugin plugin;

        public LoadedPluginData(LoadedNodeData data, LoadingClassLoader classLoader, Plugin plugin) {
            this.data = data;
            this.classLoader = classLoader;
            this.plugin = plugin;
        }

        public LoadedNodeData getData() {
            return data;
        }

        public LoadingClassLoader getClassLoader() {
            return classLoader;
        }

        public Plugin getPlugin() {
            return plugin;
        }
    }

    public static class LoadingClassLoader extends ClassLoader {
        private final LoadedNodeData data;
        private final Map<String, LoadedNodeData> cache;
        private final Map<String, Class<?>> ccache;
        private final Class<? extends Plugin> pluginKlass;

        public LoadingClassLoader(LoadedNodeData data, Set<LoadedNodeData> set) throws Throwable {
            this.data = data;

            cache = new HashMap<>();
            ccache = new HashMap<>();

            for (LoadedNodeData d : set) {
                cache.put(d.node.name, d);
            }

            @SuppressWarnings("unchecked")
            Class<? extends Plugin> pluginKlass = (Class<? extends Plugin>) loadClass(data.node.name.replace("/", "."));

            if (pluginKlass == null)
                throw new RuntimeException();

            this.pluginKlass = pluginKlass;
        }

        @Override
        public Class<?> findClass(String name) throws ClassNotFoundException {
            name = name.replace(".", "/");

            System.out.println("finding " + name);

            if (ccache.containsKey(name))
                return ccache.get(name);

            LoadedNodeData data = cache.get(name);
            if (data != null) {
                byte[] bytes = data.bytes;
                Class<?> klass = defineClass(data.node.name.replace("/", "."), bytes, 0, bytes.length);
                ccache.put(name, klass);
                return klass;
            }

            return super.findClass(name);
        }

        public LoadedNodeData getPluginNode() {
            return data;
        }

        public Class<? extends Plugin> getPluginKlass() {
            return pluginKlass;
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/strategies/GroovyPluginLaunchStrategy.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.strategies;

import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.plugin.PluginLaunchStrategy;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @created 1 Jun 2015
 */
public class GroovyPluginLaunchStrategy implements PluginLaunchStrategy {

    @Override
    public Plugin run(File file) throws Throwable {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("groovy");

        if (engine == null)
            throw new Exception(
                    "Cannot find Groovy script engine! Please contact Konloch.");

        Reader reader = new FileReader(file);
        engine.eval(reader);

        return (Plugin) engine.eval("new " + file.getName().replace(".gy", "").replace(".groovy", "") + "();");
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/strategies/JavaPluginLaunchStrategy.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.strategies;

import java.io.File;
import org.codehaus.janino.SimpleCompiler;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.plugin.PluginLaunchStrategy;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @created 1 Jun 2015
 */

public class JavaPluginLaunchStrategy implements PluginLaunchStrategy
{
    @Override
    public Plugin run(File file) throws Throwable
    {
        SimpleCompiler compiler = new SimpleCompiler(file.getCanonicalPath());

        //debug
        //System.out.println(file.getName().substring(0, file.getName().length() - (".java".length())));
        
        //get the class object from the compiler classloader
        Class<?> clazz = Class.forName(
                file.getName().substring(0, file.getName().length() - ".java".length()),
                true,
                compiler.getClassLoader()
        );

        //create a new instance of the class
        return (Plugin) clazz.getDeclaredConstructor().newInstance();
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/strategies/JavascriptPluginLaunchStrategy.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.strategies;

import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import java.util.List;
import javax.script.Bindings;
import javax.script.Invocable;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.plugin.PluginLaunchStrategy;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @since 06/25/2021
 */
public class JavascriptPluginLaunchStrategy implements PluginLaunchStrategy
{
    //attempt to use nashorn
    public static final String firstPickEngine = "nashorn";
    //fallback to graal.js
    public static final String fallBackEngine = "graal.js";
    
    @Override
    public Plugin run(File file) throws Throwable
    {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName(firstPickEngine);
    
        //nashorn compatability with graal
        if (engine == null)
        {
            engine = manager.getEngineByName(fallBackEngine);
            
            if (engine == null)
                throw new Exception("Cannot find Javascript script engine! Please contact Konloch.");
            
            Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);
            bindings.put("polyglot.js.allowHostAccess", true);
            bindings.put("polyglot.js.allowAllAccess", true);
            bindings.put("polyglot.js.allowHostClassLookup", true);
        }

        Reader reader = new FileReader(file);
        engine.eval(reader);
    
        ScriptEngine finalEngine = engine;
        
        return new Plugin()
        {
            @Override
            public void execute(List<ClassNode> classNodeList)
            {
                try
                {
                    //add the active container as a global variable to the JS script
                    finalEngine.put("activeContainer", activeContainer);
                    
                    //invoke the JS function
                    ((Invocable) finalEngine).invokeFunction("execute", classNodeList);
                }
                catch (NoSuchMethodException | ScriptException e)
                {
                    BytecodeViewer.handleException(e);
                }
            }
        };
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/strategies/PythonPluginLaunchStrategy.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.strategies;

import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.plugin.PluginLaunchStrategy;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @created 1 Jun 2015
 */
public class PythonPluginLaunchStrategy implements PluginLaunchStrategy {

    @Override
    public Plugin run(File file) throws Throwable {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("python");

        if (engine == null)
            throw new Exception(
                    "Cannot find Jython script engine! Please contact Konloch.");

        Reader reader = new FileReader(file);
        engine.eval(reader);

        return (Plugin) engine.eval(file.getName().replace(".py", "").replace(".python", "") + "()");
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/plugin/strategies/RubyPluginLaunchStrategy.java`:

```java
package the.bytecode.club.bytecodeviewer.plugin.strategies;

import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import the.bytecode.club.bytecodeviewer.api.Plugin;
import the.bytecode.club.bytecodeviewer.plugin.PluginLaunchStrategy;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @created 1 Jun 2015
 */
public class RubyPluginLaunchStrategy implements PluginLaunchStrategy {

    @Override
    public Plugin run(File file) throws Throwable {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("jruby");

        if (engine == null)
            throw new Exception(
                    "Cannot find jRuby script engine! Please contact Konloch.");

        Reader reader = new FileReader(file);
        engine.eval(reader);

        return (Plugin) engine.eval(file.getName().replace(".rb", "").replace(".ruby", "") + ".new");
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/ExternalResources.java`:

```java
package the.bytecode.club.bytecodeviewer.resources;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.SettingsSerializer;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.JRTExtractor;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.RT_JAR;
import static the.bytecode.club.bytecodeviewer.Constants.RT_JAR_DUMPED;
import static the.bytecode.club.bytecodeviewer.Constants.libsDirectory;
import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Anything that isn't accessible from inside of the JVM is here
 *
 * @author Konloch
 * @since 7/11/2021
 */

public class ExternalResources
{
	private static final ExternalResources SINGLETON = new ExternalResources();
	
	public static ExternalResources getSingleton()
	{
		return SINGLETON;
	}
	
	/**
	 * Auto-detect Java via command-line
	 */
	public String getJavaCommand(boolean blockTillSelected)
	{
		if(!Configuration.java.isEmpty())
			return Configuration.java;
		
		//check CLI for java
		testCommand(new String[]{"java", "-version"}, "java version", ()-> Configuration.java = "java");
		if(!Configuration.java.isEmpty())
			return Configuration.java;
		
		//TODO auto-detect the JRE path
		boolean block = true;
		//while (Configuration.java.isEmpty() && block)
		{
			BytecodeViewer.showMessage("You need to set your Java path, this requires the JRE to be downloaded." +
					nl + "(C:/Program Files/Java/JDK_xx/bin/java.exe)");
			ExternalResources.getSingleton().selectJava();
			block = !blockTillSelected; //signal block flag off
		}
		
		return Configuration.java;
	}
	
	/**
	 * Check if java tools has been set
	 */
	public boolean hasJavaToolsSet()
	{
		return !getJavaTools(false).isEmpty();
	}
	
	/**
	 * Auto-detect Java tools.jar
	 */
	public String getJavaTools(boolean blockTillSelected)
	{
		boolean empty = Configuration.javaTools.isEmpty();
		
		if(!empty)
			return Configuration.javaTools;
		
		//TODO auto-detect the JDK path
		boolean block = true;
		//while (Configuration.javaTools.isEmpty() && block)
		{
			BytecodeViewer.showMessage("You need to set your Java Tools path, this requires the JDK to be downloaded." +
					nl + "(C:/Program Files/Java/JDK_xx/lib/tools.jar)");
			ExternalResources.getSingleton().selectJavaTools();
			block = !blockTillSelected; //signal block flag off
		}
		
		return Configuration.javaTools;
	}
	
	/**
	 * Check if the python 2 command has been set
	 */
	public boolean hasSetPython2Command()
	{
		return !getPython2Command(false).isEmpty();
	}
	
	/**
	 * Auto-detect python 2 via command-line
	 */
	public String getPython2Command(boolean blockTillSelected)
	{
		if(!Configuration.python2.isEmpty())
			return Configuration.python2;
		
		//check using python CLI flag
		testCommand(new String[]{"python", "-2", "--version"}, "python 2", ()->{
			Configuration.python2 = "python";
			Configuration.python2Extra = true;
		});
		if(!Configuration.python2.isEmpty())
			return Configuration.python2;
		
		//check if 'python' command is bound as python 2.X
		testCommand(new String[]{"python", "--version"}, "python 2", ()-> Configuration.python2 = "python");
		if(!Configuration.python2.isEmpty())
			return Configuration.python2;
		
		//TODO auto-detect the Python path (C:/Program Files/Python)
		boolean block = true;
		//while (Configuration.python2.isEmpty() && block)
		{
			BytecodeViewer.showMessage(TranslatedStrings.YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH.toString());
			selectPython2();
			block = !blockTillSelected; //signal block flag off
		}
		
		return Configuration.python2;
	}
	
	/**
	 * Check if the python 3 command has been set
	 */
	public boolean hasSetPython3Command()
	{
		return !getPython3Command(false).isEmpty();
	}
	
	/**
	 * Auto-detect python 3 via command-line
	 */
	public String getPython3Command(boolean blockTillSelected)
	{
		//check if 'pypy3' command is bound as python 3.X
		//TODO test this and re-enable it
		/*testCommand(new String[]{"pypy3", "--version"}, "python 3", ()->{
			Configuration.python3 = "pypy3";
		});
		if(!Configuration.python3.isEmpty())
			return Configuration.python3;*/
		
		
		//check if 'python3' command is bound as python 3.X
		testCommand(new String[]{"python3", "--version"}, "python 3", ()-> Configuration.python3 = "python3");
		if(!Configuration.python3.isEmpty())
			return Configuration.python3;
		
		
		//check if 'python' command is bound as python 3.X
		testCommand(new String[]{"python", "--version"}, "python 3", ()-> Configuration.python3 = "python");
		if(!Configuration.python3.isEmpty())
			return Configuration.python3;
		
		
		//TODO auto-detect the Python path (C:/Program Files/Python)
		boolean block = true;
		//while (Configuration.python3.isEmpty() && block)
		{
			BytecodeViewer.showMessage(TranslatedStrings.YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH.toString());
			selectPython3();
			block = !blockTillSelected; //signal block flag off
		}
		
		return Configuration.python3;
	}
	
	//rt.jar check
	public synchronized void rtCheck()
	{
		if (Configuration.rt.isEmpty())
		{
			if (RT_JAR.exists())
				Configuration.rt = RT_JAR.getAbsolutePath();
			else if (RT_JAR_DUMPED.exists())
				Configuration.rt = RT_JAR_DUMPED.getAbsolutePath();
			else try {
					JRTExtractor.extractRT(RT_JAR_DUMPED.getAbsolutePath());
					Configuration.rt = RT_JAR_DUMPED.getAbsolutePath();
				} catch (Throwable t) {
					t.printStackTrace();
				}
		}
	}
	
	public void selectPython2()
	{
		final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_PYTHON_2.toString(),
				TranslatedStrings.PYTHON_2_EXECUTABLE.toString(),
				FileChooser.EVERYTHING);
		
		if(file == null)
			return;
		
		Configuration.python2 = file.getAbsolutePath();
		Configuration.python2Extra = false;
		SettingsSerializer.saveSettingsAsync();
	}
	
	public void selectPython3()
	{
		final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_PYTHON_3.toString(),
				TranslatedStrings.PYTHON_3_EXECUTABLE.toString(),
				FileChooser.EVERYTHING);
		
		if(file == null)
			return;
		
		Configuration.python3 = file.getAbsolutePath();
		Configuration.python3Extra = false;
		SettingsSerializer.saveSettingsAsync();
	}
	
	public void selectJava()
	{
		final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_JAVA.toString(),
				TranslatedStrings.JAVA_EXECUTABLE.toString(),
				FileChooser.EVERYTHING);
		
		if(file == null)
			return;
		
		Configuration.java = file.getAbsolutePath();
		SettingsSerializer.saveSettingsAsync();
	}
	
	public void selectJavac()
	{
		final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_JAVAC.toString(),
				TranslatedStrings.JAVAC_EXECUTABLE.toString(),
				FileChooser.EVERYTHING);
		
		if(file == null)
			return;
		
		Configuration.javac = file.getAbsolutePath();
		SettingsSerializer.saveSettingsAsync();
	}
	
	public void selectJRERTLibrary()
	{
		final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_JAVA_RT.toString(),
				TranslatedStrings.JAVA_RT_JAR.toString(),
				FileChooser.EVERYTHING);
		
		if(file == null)
			return;
		
		Configuration.rt = file.getAbsolutePath();
		SettingsSerializer.saveSettingsAsync();
	}
	
	public void selectJavaTools()
	{
		final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_JAVA_TOOLS.toString(),
				TranslatedStrings.JAVA_TOOLS_JAR.toString(),
				FileChooser.EVERYTHING);
		
		if(file == null)
			return;
		
		Configuration.javaTools = file.getAbsolutePath();
		SettingsSerializer.saveSettingsAsync();
	}
	
	public void selectOptionalLibraryFolder()
	{
		final File file = DialogUtils.fileChooser(TranslatedStrings.SELECT_LIBRARY_FOLDER.toString(),
				TranslatedStrings.OPTIONAL_LIBRARY_FOLDER.toString(),
				FileChooser.EVERYTHING);
		
		if(file == null)
			return;
		
		Configuration.library = file.getAbsolutePath();
		SettingsSerializer.saveSettingsAsync();
	}
	
	/**
	 * Finds a library from the library folder
	 */
	public String findLibrary(String nameContains)
	{
		for (File f : MiscUtils.listFiles(new File(libsDirectory)))
			if (f.getName().contains(nameContains))
				return f.getAbsolutePath();
		
		return null;
	}
	
	/**
	 * Searches a directory until the extension is found
	 */
	public File findFile(File basePath, String extension)
	{
		for(File f : MiscUtils.listFiles(basePath))
		{
			if(f.isDirectory())
			{
				File child = findFile(f, extension);
				
				if(child != null)
					return child;
				
				continue;
			}
			
			if(f.getName().endsWith(extension))
				return f;
		}
		
		return null;
	}
	
	/**
	 * Used to test the command-line for compatibility
	 */
	private void testCommand(String[] command, String matchingText, Runnable onMatch)
	{
		//prevents reflection calls, the stacktrace can be faked to bypass this, so it's not perfect
		String executedClass = Thread.currentThread().getStackTrace()[2].getClassName();
		if(!executedClass.equals(ExternalResources.class.getCanonicalName()))
			return;
		
		try {
			//read the version output
			ProcessBuilder pb = new ProcessBuilder(command);
			Process p = pb.start();
			p.waitFor();
			
			//check for matching text
			if(readProcess(p).toLowerCase().contains(matchingText))
				onMatch.run();
		} catch (Exception ignored) { } //ignore
	}
	
	/**
	 * @author https://stackoverflow.com/a/16714180
	 */
	public String readProcess(Process process) throws IOException
	{
		try (InputStream is = process.getInputStream();
		InputStreamReader isr = new InputStreamReader(is);
		BufferedReader reader = new BufferedReader(isr)) {
			StringBuilder builder = new StringBuilder();
			String line;

			while ((line = reader.readLine()) != null) {
				builder.append(line);
				builder.append(System.getProperty("line.separator"));
			}

			return builder.toString();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/IconResources.java`:

```java
package the.bytecode.club.bytecodeviewer.resources;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.imageio.ImageIO;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.io.IOUtils;
import org.imgscalr.Scalr;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Any resources loaded by disc or by memory.
 *
 * @author Konloch
 */

public class IconResources
{
    static protected final int HALF_SIZE = 4;
    static protected final int SIZE = 9;
    
    public static List<BufferedImage> iconList;
    public static BufferedImage icon;
    public static ImageIcon nextIcon;
    public static ImageIcon prevIcon;
    public static ImageIcon busyIcon;
    public static ImageIcon busyB64Icon;
    public static ImageIcon batIcon;
    public static ImageIcon shIcon;
    public static ImageIcon csharpIcon;
    public static ImageIcon cplusplusIcon;
    public static ImageIcon configIcon;
    public static ImageIcon jarIcon;
    public static ImageIcon zipIcon;
    public static ImageIcon packagesIcon;
    public static ImageIcon folderIcon;
    public static ImageIcon androidIcon;
    public static ImageIcon unknownFileIcon;
    public static ImageIcon textIcon;
    public static ImageIcon classIcon;
    public static ImageIcon imageIcon;
    public static ImageIcon decodedIcon;
    public static ImageIcon javaIcon;
    
    static
    {
        icon = b642IMG("iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAUd0lEQVR42pWaWXRbVZaGq5iHqgaSeJZsy7YkD7KtwZItebblQfI8x/HseIodO3bixE5iZw4ZSBwyACkCXQ003dD0oigq1UBqFVQ1HSB0wkyvXt1VPNSiavHCC288/b3/I11ZSszQDzuRfO89Z39n/3uffST9BMBP17Dbgna72B1hdmfQ7hK7W+yeoN0btPvE7v8Rdl+Y3Rsc4+7guHcF5wif9/ag3fYd/v70J/zHWlGFcLPRKqth99Yoc1TVKssTc1b74Krxw1Vbh3yxAl+9Mre/QZmnrvFHG+/Xnud4alwxzpEXnJOm+UGfbEH/wv2NAHkwMQ4P6GLk/1hlDyXFKVuXFI/1yQnKolJ0yqLTEhFjTEKsKRlxZgPi01OQkJ6qTJeRBn2mEYlZpjWN13gP7+VzfJ7G8WjRqXo1xwZDQmhe+kBfHhR7QHz7O300fq6LUhYBQkJ1UxDkFggZdEMQIJoTCkCsAhDn6TgdpKMWE5KyzcqSc9JDZsjNCL3WridZAmA3Q3F8zhMVBFpHELGHxJcHk2KVPZAYE4K5BYSkD+hjQuR8kAMQYENKgkwgUTBJFMzJgQhkpIrzRnHKJA6axdl0pFgzkGrNRJotS5nRbokw7e8pco8GRygugk4ixYXhAnGhOF90ml7Nvd5AX7SoRMKsGRElK7mJD9E4SFSqTg1KgLh0wy0AdF5z2uTIRrozV1lmvg2ZBQHLyLfK33KQnifX8nJgFuO9fC5VQaWr8RhRXWaaWijO92NgbAGQ2whyG5NIu0FJag0IDs5JOBkBtJXXnKfjWW47LG4HcgqdyC1yKePrDAFItaSjrrkZlf5aZBXYA4AuawgqHIgLxQXjvFTB98GEg9zOivCglhffAcHBExkFmSyVEZDJzQQQhyyePOSI07aSAjjKPMgrL4SroliZvbgAxpwsxCcnYmFxCecvXESO3J9bnK8gCa8BMaoE4kJpMFRBOMw6gXkoOT6Q0wSRIJCBIHcQRCW43EDqDWEQISkpGUkUZLJwADpkF+ed4nS+twTu6jJ4aspR5KtU5iwrRGqmGdHxsThw6GH8540PYfU4FSShrQIfDqRJjtHRpHYzDP3UYOh7BIjKizCImLBIECItGIV0mYzyCQeg83S6xF+FsvoaVDT6UNHkQ2WzH56qMqRlmRGTEIdXXn0Nn/3XfyOvxKPu98hzrspiNQ6BuDAZIlGTRIdRZ/T1QZjwnFkfBhMEuUOBcPNR0dCqk0psyYkwCA6uRYGTEqCgqlQ5pJwXx6ta61HT1ghfRzPqulrh72xBcXUFjJnikCEZX/71b3j5lcvweMvU/XyOz3MhOJ6t1I1siQ7nYdTDYeLCCgAXW4PhhqmB3EkQXogS2mgJoQbBnOBg5iAEJ+FkXEXKp7SuWjlU3dqgnG7obkdzTyda+zYq87U2wlnkRoopDTc++Bh/+cuXKCorRXldDfwCW9VSr57nOIW1FaHoMN/CYbiY9Id+xQRh1gfzJS8AcidB7mJLsCEsGvGSF1piU043Q2hR8LbUqdVv3NShHO8c6kX35gFsHO5H48Y2FFaUIiM7C+9eu64glvYdQk6eHcXectS3NaO5u0M9z0iWN9SqcZln4TBUAnOT/hAmVvKFix0VlFgECPsbai9cUoSgpJiAlJOCqAhAcFJGgfJp6e1SAD2jg+gbG1IgzRs7UFpVia6Nm1Qk/ud//4yz5x6HMcOM6lofnrz0Dzh3/hfo6utF86ZO1As0x2NucXwtMlw85gwXU5MYFzk8KvSdDAS5mw2bqlJCy8RiLWcZ5P7AxGZZVRASfkaiRiZtkMkZhY2b+9E/sRlDk2MKpLGjFUXlpZjfvgs3PvwEH3/yOfbvPwxjuhm/fOYf8e9vvysgzwhQLfwivc7BXrT1dytZMr+4SJrMuHicfy2JMSrMlXCQe9jFxgabP1Yplj5TUFLc1LgvsMIQolpkUC+RaBMIrv7g5CjGtk1hZOsWtG/qQrFAbN+xC1ffuaZs8/AI0rMy8MaVN/H21fewY24n7K481DT40SPPD2wZQffIINoHNikYRobzMAdZAMIlZpAughILj0oQ5G4FwjY60H6kqd4nPBr2Ug8KRLclPi+8Uk7rJKnDIcbntmJqfhaD4yPw+mrQ2NiE16/8Hr9784/o6elDVrZFVao3//Af6O7ugaekGM0dbRjdOqGem9g+jeGpcSVNRoZyZe6xlLMqUmL0g2U/PCparlBNZCDIfTwXaF0smzmjndGwSzTy4SwvEklVKv3WtjUpTXcN94mcRjA+uxXTu3Zgascs2ro7kV/oxpGDD+OV37yGixefRq7VionxSbz2xu/x9N8/B19DHQZGhrF99y4sHlzGrn17sG1xXsEMTY2pxWmVnGNF43zFzBeJSq4WFVGJIawcMyr54SA85Kg9wxLIDbP0RtluSfASt0SjFKX+alUqlaT6N6F3bBgj01uwded2zC/txuT2GdSKkzaHHXsXlvDiS7/C0p59sOU51PuXX/ktnnn2BYxOTuDQsaM4fuYUDj9yHEtHDwrMXswszKtFYa6xcDQyX0RiLMtuRiWYK1QJ/WMOa70Y1cRTJkHuJ4g+2Ayy32GlYtuQJ+1FoWi1vKEGvvYmVaG6JbmZ2JM7tmHH3gXsObQf2xd3oqG1GQ6XE16vV5L6n3Di2CNwFeSju6sbz7/wr3j+n1/C/gNH8MjZM3j0icdw8uyKgtl75IBajKn5OWyWPNsk+dLau1Gi0qKiwvmZo/SHjSkrqdaLMR0iQArrm0K9VGAHt6vdmzW92FelcoPRYEL2jQ9jdNukksTCgSUcOH4Eew/vx/D4KMq9FXA4nVjYuRtPXHwK3qpquPLzsXLqLC6JtC499QwOHDyIxy5dFJgLOPHoaRw88TB2H9yH2d07g1EZQYdUMs5HFZTI/JSXVZpP+mVy5Cj5Mw14fmFaUFUE+VkAJF2BsNRlMcklyZhsJRJeVhKGm2Fngm9hNJYW1WoePX0Cx8WhveJM56aNKJRkZiQO7T+Co4eOocDjRkVlJc6dewLnH38SS4t7ce7i4wrm1PlHceTUcSwzKsu7VfIPSeIzB5tkk2U5LpUKRj8oc/pF2ROERYkgVJMG8nOCJNsyVGebLocgljx2pu6aMpQ2VKO2owlNvZ1SJgcwPD2BrbvmsFO0ve/oIRw6eQwPnzqJA0cPY3JmGg3NTSguLYGnqBB75hcxsnkMnsJC7J5fwKmV85id3YaVC+fEzmLPgWVMz2/Hlu3bML1zToFsnqa8BpSMKWfKmvKiP9myMbN6pQWrF8twEOT+EIjBlgmjyCpDwpcjna2zskhqeYXqhfydzWiV0tgzOoSRmUlMyaTbJEFp01KxRqcmML5nAVv2L2Fibhua21pRXlmhgFrkdUlpKZb278P8rnlMTm9V0DM75tAiZXho2zTmDu7H7IF9GJb9aLOU5V6Rb5vIuK6rRXXQ3CBVnhQ51WnT6LCoPOHmHQFS1NCMFLu06XIczZBzQW6pdLfeYhT6pew2+VVDyIF7mB+zUypHugf7pBVpx+Dhneh/dDtGji6iV2S3eWwU/UMD8NXXobS8DCXSJBaJ3Ljj1/p96B4dwYgk9qaJUSVBp0jPXVGOscO7MHZ8D/okR/rGN0s+9oRAWP6dFUVKKQGQ1ZblVhChNLnkwORxKBBXVUkARAbyy4BtgwIyIWVXIHqkspRJL0X9dqxsRd2ZLvScmsPwyUUMHV/ExCMSmZNLGDy2gMkTSxgVB2ljx/Zg4uG9GDu0G91Sasu90sIXiWSsufANSJtydExanj6BEZDBntDmWOT3KoXkFAtIgYDkfS+InDmENrMwEqSSHW4YyGbJkY1DfSiuKBMHcpQTnqoK+Po60TEzis7FKWxankPv8nZ0755F5/wU2qZG0CiFoqqlUUXHH9wYB8dGUFvvh1U64s6js2jcJ/f2daNXgYi0NkaC5JbkC4hNpQDbFX12JIiqWioi+bkKxFrmhrN6NSI+GbBFVmzT+BCGZyYwtHUMrbKTl1fLzuspkI1PHNklSbo8g3x3AdyFHpXshcVFyviaVlpThVZpRYYlp3bI7j4kJbuithrt+6ZRd3pMnK5Hx0BgwbhwfpmX89MPSj1HgdgVSHIkyGr5NUhEjAKSoSIiIIxInRcVLX7UdjULiPRXY4MKZGJ+BpPz2zAoeq6u96kmsPPELPLP1sK70o+qlSHUr4yj9/wONJ+eRN3KKGrPDKPqXDfKzrZh+MRuDEk0muQQ1rl3Kxr2TaBICkt9e7N0DUNqwVpl4agEzu8REEdFoQJJl4ikUVpSZfU5kSBqQzTkWWAU/WUUOZBTVgCHt0g2G2nbm+UE2Cnlt1/OHSP9GJBojAvI3NKCql6N7a0qKlaHDcWSM22LW1C9bwydJ+fQviI92LFtqFwaQc3iKHxjvaiRHbu5pwteiYQqrdKMukuL1EGrR1qf/qlRdI32o0mkWiNlv1yqpluqFkGyJUfS3QEQgz0TOqlcESB8Y8iTiBTkIt1jR3ZpPmyVhXDWlMLtkzJaL7t7Wx3quqXXosSCkWGj1yqnvKKyEqXzmr52lLf4VM/FPkszQlrtNtidDlRUV6G5vQ1V0inz2Ov1VauKxkgMz2xB36Ts7Jt7UbepTfLTL3tZOezlHpF7AbKk/JoFJJURsUtEcs3azr7aayULSJpIyywgFgGxlrtV0rNZe/rZX+K996/h2vX38f6N67j+wQ1lNz78ANdv3MB7167htddfx9DFnYifM+PUSxfxzqfX8f5nHyp757PruPr5+3j783dx7fMPcOPjj/DBRx8qY9fM/z/65GM8/9KL2CiLxHz0yrnHKXtHdVMdrr73jti72LZnF8yy2KmiHoLoRFrBXmu1jU/Ky0SKKxsmt1SuYicsYmbpa5IzTHjrj3/At99++4PGHT7N6/pR92rmcLtw6syKev31119jZHZSJXmBHORMVgt+9eqv1bU//flPqv8zyhaRIiCJtnToJCLhIPfyTaIjEwanBWmUl+QJJWaQ/ishLQmv/+4KvvnmG7wh/8clJkBnTkFcmZzWii3QS7/Da7TlfcvYEB0Ver+0zPfRyqJiohEdGwN9UqKcGDORK3LLkvKdYjYiK9+BL//2V/XMv115XQ5VXlhcUgl7u0NjDU+Oq+6DqmEaJNrFt1xTxHnkngBIBpKdWQrEVGhTkUmSDjPOkIhf/+ZVfPXVV3jzrbfglx27fcsAyqe8qJvtQNNEj7pGm5EdOz4lMfR+z/ISdGkGJKYbZXXZWUt5L3HBXOVBqt+DzMZiGCWC8bKyW+dmQs8NSDXkZ8U3RL58z/nV5wguWeh8UYmoR28VEJFW8IQYOLPzjU5CRZBUudEoECzF/FIm1qCXg9K/4IsvvvhBe/vaVaTU2ULvdz55GMZdXmQv+8XqkLfcCveODngmO+EZaUGWvwyJIhWdOKgvtOClV15Wz1195yoW9uwOjZNfXoxUh0VFI8WZjSRRj17Kb7xEJPJTFHlDkPCopIjMdNJdRicn4JnnnsWnn36KK1euYEqavsmtk9gytWpHjh5R12l1XW2h1wvHDqGorxFlo51wDrXAvaUTjplOlC0OoGR5ALZjnXDtakdavQdRqUnSrhSGntVsVhpN7uKEoF/0Ty+JnmA1Iy7XGAGiPteKt5mgE90lOSXp87PVBhlvNiAqMR6/uPQkrkllevKpS4hN0iFaH4/ohFisj4nCA+seUs0hr9N8sqlpr2ePLiOztxbZIw2wjNYjc7wettk2uKc7YOmqgbGhHGZpy3UpyYhL0quxF/buDj1PSWW4pNy6AipJEbUwl3XBaMTmpEV8QKc+Mo2zEkQSOE+i4pJ+X17HyZl4Q2Iczsr54S3Jj8u/vYwLjz8WsvOPXcDZ8+fw1NNPqes0drva6xdefAHn5Pq58+eD/59bfX/hvBojU/Imxy0V0p4NvSkFaZIbly9fVs+zDVJduUBQ8owGVUP1xIu/casgqx9iM0zxNnMQJpBM/HJynS5WDkSn8brsEz9kzz33HAymNJxeWflR99PUuaeuElbZswwWM2KT9eiSanX60TOBz55FHZQUKyohwmUVm50a8SH2HXzDMDEqCazP6maT+gBsnT4WD8VHY11CDNbr4pTUopMSVBFgRYsXbSeI6YwpSDKnKtMbDdCn3Wq61OSQ8R5GwSXdg6fBC7u3ULXn8cZkxBh0MNosSt6MhEGKAfc5vSMSIsaSEvG1gvrGihcYKoaModPxgcwUxPAbVhk4OkWH2NRENVGCSRyTQpAkVS1ZSnRKdjpM/CyM3xvy2yd5bRJHzLbskJlsgb8ZZZMz5sp+YM1SZ3BHVTHyastgqypCZlGe6mrVV3z8ZoxVSiKSREkJCBc4zmoUkDRZeClEqyC3h0BiLKkBGEqMkREQwuhpUueTRGps1FSXLMmXLg0mD2FZMjmbOVuFR/QqTkm77RC55NHktbMqYHzNv7H5s8n5O1daIBtfC4BVopFdXiB7jFPywaYqJsssO41wCEqfqqF6YrIJkhrx1Zv6MpQgNEZFg2FkqEmGleGlVpl43DA5qaUsHznigLXSA5s4Y68WZ0UqTllhl68M+f7ykPE9/87rvM8uAHyGz3McjmcutMPksQXKv0CoUuvQImG6BSJKIhIEuS309TTDFAETJrNwGE6gdn+ZkBNnFOchq9QVgsqtcIfAFJw4rDlN4zXel122CsCWiIujVSctJ1hqVXLbAnlBnwK5ETD6HP6tbghEg9HyRYPhQIENMzMExAk1IDqhQdExDWwt4zXNeS0C4QCMgkps+2qZ1UrtzRBRWQYNZPW3KPxjOEwE0BpS44RahDQoJbswsLVM9XFB5/nMzQCBDS9dLZ4CCEaCdjME7ZYf1WzINIQufh/MzUA3Q4WDrWW8pjmvSehmGYWi8B1y0vxcEyTiJ05r/Mwp7wd+5vRdP2XiMTrc1vqZE8dZ62dOed/zMyfbWj9z+n/+8OyuNX54ds/3/OjsZzfZzT8+uzdsjO/68dkP/vDs/wBUXNeRym9KEQAAAABJRU5ErkJggg==");
        nextIcon = new ImageIcon(b642IMG("iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAMFBMVEX"
                + "///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAABnRSTlMANzlYqPBJSG"
                + "/ZAAAASUlEQVR42mNgwAbS0oAEE4yHyWBmYAzjYDC694OJ4f9"
                + "+BoY3H0BSbz6A2MxA6VciFyDqGAWQTWVkYEkCUrcOsDD8OwtkvMViMwAb8xEUHlHcFAAAAABJRU5ErkJggg=="));
        prevIcon = new ImageIcon(b642IMG("iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAMFBMVEX"
                + "///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAABnRSTlMANzlYgKhxpRi1AAAATElEQVR42mNgwAZYHIAEExA7qUAYLApMDmCGEwODCojByM/A8FEAyPi/moFh9QewYjCAM1iA+D2KqYwMrIlA6tUGFoa/Z4GMt1hsBgCe1wuKber+SwAAAABJRU5ErkJggg=="));
        busyIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/loading.gif")));
        busyB64Icon = new ImageIcon(b642IMG("R0lGODlhEAALAPQAAP"
                + "///wAAANra2tDQ0Orq6gcHBwAAAC8vL4KCgmFhYbq6uiMjI0tLS4qKimVlZb6+vicnJwUFBU9PT"
                + "+bm5tjY2PT09Dk5Odzc3PLy8ra2tqCgoMrKyu7u7gAAAAAAAAAAACH5BAkLAAAAIf4aQ3JlYXRlZCB3aXRoIGFqYXhsb2FkLmluZm8AIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAEAALAAAFLSAgjmRpnqSgCuLKAq5AEIM4zDVw03ve27ifDgfkEYe04kDIDC5zrtYKRa2WQgAh+QQJCwAAACwAAAAAEAALAAAFJGBhGAVgnqhpHIeRvsDawqns0qeN5+y967tYLyicBYE7EYkYAgAh+QQJCwAAACwAAAAAEAALAAAFNiAgjothLOOIJAkiGgxjpGKiKMkbz7SN6zIawJcDwIK9W/HISxGBzdHTuBNOmcJVCyoUlk7CEAAh+QQJCwAAACwAAAAAEAALAAAFNSAgjqQIRRFUAo3jNGIkSdHqPI8Tz3V55zuaDacDyIQ+YrBH+hWPzJFzOQQaeavWi7oqnVIhACH5BAkLAAAALAAAAAAQAAsAAAUyICCOZGme1rJY5kRRk7hI0mJSVUXJtF3iOl7tltsBZsNfUegjAY3I5sgFY55KqdX1GgIAIfkECQsAAAAsAAAAABAACwAABTcgII5kaZ4kcV2EqLJipmnZhWGXaOOitm2aXQ4g7P2Ct2ER4AMul00kj5g0Al8tADY2y6C+4FIIACH5BAkLAAAALAAAAAAQAAsAAAUvICCOZGme5ERRk6iy7qpyHCVStA3gNa/7txxwlwv2isSacYUc+l4tADQGQ1mvpBAAIfkECQsAAAAsAAAAABAACwAABS8gII5kaZ7kRFGTqLLuqnIcJVK0DeA1r/u3HHCXC/aKxJpxhRz6Xi0ANAZDWa+kEAA7"));

        batIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/bat.png")));
        shIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/sh.png")));
        csharpIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/c#.png")));
        cplusplusIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/c++.png")));
        configIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/config.png")));
        jarIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/jar.png")));
        zipIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/zip.png")));
        packagesIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/package.png")));
        folderIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/folder.png")));
        androidIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/android.png")));
        unknownFileIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/file.png")));
        textIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/text.png")));
        classIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/class.png")));
        imageIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/image.png")));
        decodedIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/decoded.png")));
        javaIcon = new ImageIcon(Objects.requireNonNull(IconResources.class.getResource("/gui/java.png")));

        iconList = new ArrayList<>();
        int size = 16;
        for (int i = 0; i < 24; i++)
        {
            iconList.add(resize(icon, size, size));
            size += 2;
        }
    }
    
    public static String loadResourceAsString(String resourcePath) throws IOException
    {
        try (InputStream is = IconResources.class.getResourceAsStream(resourcePath)) {
            if (is == null)
                return null;
            return IOUtils.toString(is, StandardCharsets.UTF_8);
        }
    }

    public static BufferedImage resize(BufferedImage image, int width, int height) {
        return Scalr.resize(image, Scalr.Method.ULTRA_QUALITY, width, height);
    }

    /**
     * Decodes a Base64 String as a BufferedImage
     */
    public static BufferedImage b642IMG(String imageString) {
        BufferedImage image = null;
        byte[] imageByte;

        try {
            imageByte = Base64.decodeBase64(imageString);
            try (ByteArrayInputStream bis = new ByteArrayInputStream(imageByte)) {
                image = ImageIO.read(bis);
            }
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }

        return image;
    }
    
    
    /**
     * The minus sign button icon
     */
    public static class ExpandedIcon implements Icon, Serializable
    {
        static public Icon createExpandedIcon() {
            return new ExpandedIcon();
        }
        
        public void paintIcon(Component c, Graphics g, int x, int y)
        {
            Color backgroundColor = c.getBackground();
            if(backgroundColor != null)
                g.setColor(backgroundColor);
            else
                g.setColor(Color.white);
            
            g.fillRect(x, y, SIZE-1, SIZE-1);
            g.setColor(Color.gray);
            g.drawRect(x, y, SIZE-1, SIZE-1);
            g.setColor(Color.black);
            g.drawLine(x + 2, y + HALF_SIZE, x + (SIZE - 3), y + HALF_SIZE);
        }
        
        public int getIconWidth() {
            return SIZE;
        }
        
        public int getIconHeight() {
            return SIZE;
        }
    }
    
    /**
     * The plus sign button icon
     */
    public static class CollapsedIcon extends ExpandedIcon
    {
        static public Icon createCollapsedIcon() {
            return new CollapsedIcon();
        }
        
        public void paintIcon(Component c, Graphics g, int x, int y)
        {
            super.paintIcon(c, g, x, y);
            g.drawLine(x + HALF_SIZE, y + 2, x + HALF_SIZE, y + (SIZE - 3));
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/Resource.java`:

```java
package the.bytecode.club.bytecodeviewer.resources;

import org.objectweb.asm.tree.ClassNode;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/14/2021
 */
public class Resource
{
	public final String name;
	public String workingName;
	public final ResourceContainer container;
	
	public Resource(String name, String workingName, ResourceContainer container)
	{
		this.name = name;
		this.workingName = workingName;
		this.container = container;
	}
	
	/**
	 * Returns the resource bytes from the resource container
	 */
	public byte[] getResourceBytes()
	{
		return container.getFileContents(name);
	}
	
	/**
	 * Returns the resource bytes from the resource container
	 */
	public ClassNode getResourceClassNode()
	{
		return container.getClassNode(name);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/ResourceContainer.java`:

```java
package the.bytecode.club.bytecodeviewer.resources;

import java.io.File;
import java.util.LinkedHashMap;
import java.util.Map;
import org.apache.commons.io.FilenameUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.api.ASMUtil;
import the.bytecode.club.bytecodeviewer.gui.resourcelist.ResourceTreeNode;
import the.bytecode.club.bytecodeviewer.util.LazyNameUtil;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Represents a loaded file in the form of a resource container
 * with all of the contents inside of it.
 *
 * @author Konloch
 */

public class ResourceContainer
{
    public File file;
    public String name;
    public File APKToolContents;
    public ResourceTreeNode treeNode;
    
    public Map<String, byte[]> resourceFiles = new LinkedHashMap<>();
    public Map<String, byte[]> resourceClassBytes = new LinkedHashMap<>();
    public Map<String, ClassNode> resourceClasses = new LinkedHashMap<>();
    
    public ResourceContainer(File f)
    {
        this(f, f.getName());
    }

    public ResourceContainer(File f, String name)
    {
        this.file = f;
        this.name = LazyNameUtil.applyNameChanges(name);
    }
    
    /**
     * Returns the ClassNode resource for the specified resource key (full name path)
     */
    public ClassNode getClassNode(String resourceName)
    {
        //fallback incase the resource contains the file extension
        if(resourceClassBytes.containsKey(resourceName))
            return resourceClasses.get(FilenameUtils.removeExtension(resourceName));
        
        //TODO check if this is even being called, it's probably not
        return resourceClasses.get(resourceName);
    }
    
    /**
     * Returns the unique 'working' name for container + resource look up.
     * This is used to look up a specific resource inside of this specific
     * container when you need to iterate through all opened containers
     */
    public String getWorkingName(String resourceName)
    {
        return file.getAbsolutePath() + ">" + resourceName;
    }
    
    /**
     * Returns the resource bytes for the specified resource key (full name path)
     */
    public byte[] getFileContents(String resourceName)
    {
        if(resourceClassBytes.containsKey(resourceName))
            return resourceClassBytes.get(resourceName);
        else
            return resourceFiles.get(resourceName);
    }
    
    /**
     * Updates the ClassNode reference on the resourceClass list and resourceClassBytes list
     */
    public ResourceContainer updateNode(String resourceKey, ClassNode newNode)
    {
        String classNodeKey = FilenameUtils.removeExtension(resourceKey);
        
        //update all classnode references for ASM
        if (resourceClasses.containsKey(classNodeKey))
        {
            resourceClasses.remove(classNodeKey);
            resourceClasses.put(classNodeKey, newNode);
        }
        
        //update the resource bytes
        if(resourceClassBytes.containsKey(resourceKey))
        {
            resourceClassBytes.remove(resourceKey);
            resourceClassBytes.put(resourceKey, ASMUtil.nodeToBytes(newNode));
        }
        return this;
    }
    
    /**
     * Clear this container's resources
     */
    public ResourceContainer clear()
    {
        resourceFiles.clear();
        resourceClassBytes.clear();
        resourceClasses.clear();
        return this;
    }
    
    /**
     * Updates this container's class node byte[] map
     */
    public ResourceContainer updateClassNodeBytes()
    {
        resourceClassBytes.clear();
        resourceClasses.forEach((s, cn) ->
                    resourceClassBytes.put(s+".class", ASMUtil.nodeToBytes(cn)));
        return this;
    }
    
    /**
     * Copy a resource container's resources into this container
     */
    public ResourceContainer copy(ResourceContainer copyFrom)
    {
        resourceFiles.putAll(copyFrom.resourceFiles);
        resourceClassBytes.putAll(copyFrom.resourceClassBytes);
        resourceClasses.putAll(copyFrom.resourceClasses);
        return this;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/ResourceContainerImporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.apache.commons.io.FilenameUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.api.ASMUtil;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/10/2021
 */
public class ResourceContainerImporter
{
	private final ResourceContainer container;
	
	public ResourceContainerImporter(ResourceContainer container)
	{
		this.container = container;
	}
	
	/**
	 * Return the linked container
	 */
	public ResourceContainer getContainer()
	{
		return container;
	}
	
	/**
	 * Start importing the container file as a file
	 */
	public ResourceContainerImporter importAsFile() throws IOException
	{
		try (FileInputStream fis = new FileInputStream(container.file)) {
			return addUnknownFile(container.file.getName(), fis, false);
		}
	}
	
	/**
	 * Start importing the container file as a zip archive
	 */
	public ResourceContainerImporter importAsZip() throws IOException
	{
		container.resourceClasses.clear();
		container.resourceClassBytes.clear();
		container.resourceFiles.clear();
		
		try
		{
			//attempt to import using Java ZipInputStream
			return importZipInputStream(false);
		}
		catch (Throwable t)
		{
			try {
				//fallback to apache commons ZipFile
				return importApacheZipFile(false);
			} catch (Throwable t1) {
				t1.addSuppressed(t);
				throw t1;
			}
		}
	}
	
	/**
	 * Adds an unknown resource to the container
	 * This will sort the file and start the file-specific adding process
	 */
	public ResourceContainerImporter addUnknownFile(String name, InputStream stream, boolean classesOnly) throws IOException
	{
		//TODO remove this .class check and just look for cafebabe
		if (name.endsWith(".class"))
			return addClassResource(name, stream);
		else if (!classesOnly)
			return addResource(name, stream);

		return this;
	}
	
	/**
	 * Adds a class resource to the container
	 */
	public ResourceContainerImporter addClassResource(String name, InputStream stream) throws IOException
	{
		byte[] bytes = MiscUtils.getBytes(stream);
		if (MiscUtils.getFileHeaderMagicNumber(bytes).equalsIgnoreCase("cafebabe"))
		{
			try
			{
				final ClassNode cn = ASMUtil.bytesToNode(bytes);
				
				//classes are copied into memory twice
				ClassNode existingNode = container.resourceClasses.put(FilenameUtils.removeExtension(name), cn);
				container.resourceClassBytes.put(name, bytes);
				if( existingNode != null)
				{
					//TODO prompt to ask the user if they would like to overwrite the resource conflict
					// or solve it automatically by creating a new resource container for each conflict (means no editing)
					
					System.err.println("WARNING: Resource Conflict: " + name);
					System.err.println("Suggested Fix: Contact Konloch to add support for resource conflicts");
				}
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		} else {
			System.err.println(container.file + ">" + name + ": Header does not start with CAFEBABE, ignoring.");
		}
		
		return this;
	}
	
	/**
	 * Adds a file resource to the container
	 */
	public ResourceContainerImporter addResource(String name, InputStream stream) throws IOException
	{
		byte[] bytes = MiscUtils.getBytes(stream);
		container.resourceFiles.put(name, bytes);
		return this;
	}
	
	/**
	 * Imports resources from zip archives using ZipInputStream
	 */
	private ResourceContainerImporter importZipInputStream(boolean classesOnly) throws IOException
	{
		try (ZipInputStream jis = new ZipInputStream(new FileInputStream(container.file))) {
			ZipEntry entry;
			while ((entry = jis.getNextEntry()) != null) {
				final String name = entry.getName();

				//skip directories
				if (entry.isDirectory())
					continue;

				addUnknownFile(name, jis, classesOnly);
				jis.closeEntry();
			}

			return this;
		}
	}
	
	/**
	 * Imports resources from zip archives using Apache ZipFile
	 *
	 * TODO if this ever fails: import Sun's jarsigner code from JDK 7, re-sign the jar to rebuild the CRC,
	 *      should also rebuild the archive byte offsets
	 */
	private ResourceContainerImporter importApacheZipFile(boolean classesOnly) throws IOException
	{
		try (ZipFile zipFile = new ZipFile(container.file))
		{
			Enumeration<? extends ZipArchiveEntry> entries = zipFile.getEntries();
			while (entries.hasMoreElements())
			{
				ZipArchiveEntry entry = entries.nextElement();
				String name = entry.getName();
				
				if(entry.isDirectory())
					continue;
				
				try (InputStream in = zipFile.getInputStream(entry))
				{
					addUnknownFile(name, in, classesOnly);
				}
			}
		}
		
		return this;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/ResourceDecompiling.java`:

```java
package the.bytecode.club.bytecodeviewer.resources;

import java.io.File;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import me.konloch.kontainer.io.DiskWriter;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.api.BCV;
import the.bytecode.club.bytecodeviewer.decompilers.Decompiler;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/21/2021
 */
public class ResourceDecompiling
{
	private static final int DECOMPILE_SAVE_ALL = 10;
	private static final int DECOMPILE_SAVE_ALL_PROCYON = 11;
	private static final int DECOMPILE_SAVE_ALL_CFR = 12;
	private static final int DECOMPILE_SAVE_ALL_FERNFLOWER = 13;
	private static final int DECOMPILE_SAVE_ALL_KRAKATAU = 14;
	//TODO JDGUI,JADX
	
	private static final int DECOMPILE_OPENED_ONLY_ALL = 20;
	private static final int DECOMPILE_OPENED_ONLY_PROCYON = 21;
	private static final int DECOMPILE_OPENED_ONLY_CFR = 22;
	private static final int DECOMPILE_OPENED_ONLY_FERNFLOWER = 23;
	private static final int DECOMPILE_OPENED_ONLY_KRAKATAU = 24;
	//TODO JDGUI,JADX
	
	public static void decompileSaveAll()
	{
		//alert the user if no classes have been imported into BCV
		if (BytecodeViewer.promptIfNoLoadedClasses())
			return;
		
		MiscUtils.createNewThread("Decompile Save-All Thread", () ->
		{
			//signal to the user that BCV is performing an action in the background
			BytecodeViewer.updateBusyStatus(true);
			
			//auto compile before decompilation
			if (!BytecodeViewer.autoCompileSuccessful())
				return;
			
			final JFileChooser fc = new FileChooser(Configuration.getLastSaveDirectory(), "Select Zip Export",
					"Zip Archives", "zip");
			
			//if the user doesn't select a file then we should stop while we're ahead
			if (fc.showSaveDialog(BytecodeViewer.viewer) != JFileChooser.APPROVE_OPTION)
				return;
			
			//set the last touched save directory for BCV
			Configuration.setLastSaveDirectory(fc.getSelectedFile());
			
			//get the save file and auto append zip extension
			final File outputZip = MiscUtils.autoAppendFileExtension(".zip", fc.getSelectedFile());
			
			//prompt the user for a dialogue override-this-file option if the file already exists
			if (!DialogUtils.canOverwriteFile(outputZip))
				return;
			
			//this temporary jar file will be used to store the classes while BCV performs decompilation
			File temporaryTargetJar = MiscUtils.deleteExistingFile(new File(tempDirectory + fs + "temp_" + MiscUtils.getRandomizedName() + ".jar"));

			//extract all the loaded classes imported into BCV to the temporary target jar
			JarUtils.saveAsJarClassesOnly(BytecodeViewer.getLoadedClasses(), temporaryTargetJar.getAbsolutePath());
			
			//signal to the user that BCV is finished performing that action
			BytecodeViewer.updateBusyStatus(false);
			
			try
			{
				//handle the result of the user selection
				switch (promptDecompilerUserSelect() + DECOMPILE_SAVE_ALL)
				{
					case DECOMPILE_SAVE_ALL:
						//decompile using procyon
						decompileSaveAll(Decompiler.PROCYON_DECOMPILER, temporaryTargetJar, outputZip, true);
						
						//decompile using CFR
						decompileSaveAll(Decompiler.CFR_DECOMPILER, temporaryTargetJar, outputZip, true);
						
						//decompile using fern
						decompileSaveAll(Decompiler.FERNFLOWER_DECOMPILER, temporaryTargetJar, outputZip, true);
						
						//decompile using krakatau
						decompileSaveAll(Decompiler.KRAKATAU_DECOMPILER, temporaryTargetJar, outputZip, true);
						break;
					
					case DECOMPILE_SAVE_ALL_PROCYON:
						//decompile using procyon
						decompileSaveAll(Decompiler.PROCYON_DECOMPILER, temporaryTargetJar, outputZip, false);
						break;
					
					case DECOMPILE_SAVE_ALL_CFR:
						//decompile using CFR
						decompileSaveAll(Decompiler.CFR_DECOMPILER, temporaryTargetJar, outputZip, false);
						break;
					
					case DECOMPILE_SAVE_ALL_FERNFLOWER:
						//decompile using fern
						decompileSaveAll(Decompiler.FERNFLOWER_DECOMPILER, temporaryTargetJar, outputZip, false);
						break;
					
					case DECOMPILE_SAVE_ALL_KRAKATAU:
						//decompile using krakatau
						decompileSaveAll(Decompiler.KRAKATAU_DECOMPILER, temporaryTargetJar, outputZip, false);
						break;
				}
			}
			catch (Exception e)
			{
				BytecodeViewer.handleException(e);
			}
		});
	}
	
	public static void decompileSaveOpenedResource()
	{
		//alert the user if no classes have been imported into BCV
		if (BytecodeViewer.promptIfNoLoadedClasses())
			return;
		
		//verify the active resource is a valid class file
		if (!BytecodeViewer.isActiveResourceClass())
		{
			BytecodeViewer.showMessage(TranslatedStrings.FIRST_VIEW_A_CLASS.toString());
			return;
		}
		
		MiscUtils.createNewThread("Decompile Save Opened Resource", () ->
		{
			//signal to the user that BCV is performing an action in the background
			BytecodeViewer.updateBusyStatus(true);
			
			//auto compile before decompilation
			if (!BytecodeViewer.autoCompileSuccessful())
				return;
			
			JFileChooser fc = new FileChooser(Configuration.getLastSaveDirectory(), "Select Java Files",
					"Java Source Files", "java");
			
			//if the user doesn't select a file then we should stop while we're ahead
			if(fc.showSaveDialog(BytecodeViewer.viewer) != JFileChooser.APPROVE_OPTION)
				return;
			
			//set the last touched save directory for BCV
			Configuration.setLastSaveDirectory(fc.getSelectedFile());
			
			//get the save file and auto append java extension
			File file = MiscUtils.autoAppendFileExtension(".java", fc.getSelectedFile());
			
			//prompt the user for a dialogue override-this-file option if the file already exists
			if (!DialogUtils.canOverwriteFile(file))
				return;
			
			//signal to the user that BCV is finished performing that action
			BytecodeViewer.updateBusyStatus(false);
			
			try
			{
				//handle the result of the user selection
				switch(promptDecompilerUserSelect() + DECOMPILE_OPENED_ONLY_ALL)
				{
					case DECOMPILE_OPENED_ONLY_ALL:
						//decompile using procyon
						decompileCurrentlyOpenedResource(Decompiler.PROCYON_DECOMPILER, file, true);
						
						//decompile using cfr
						decompileCurrentlyOpenedResource(Decompiler.CFR_DECOMPILER, file, true);
						
						//decompile using fernflower
						decompileCurrentlyOpenedResource(Decompiler.FERNFLOWER_DECOMPILER, file, true);
						
						//decompile using krakatau
						decompileCurrentlyOpenedResource(Decompiler.KRAKATAU_DECOMPILER, file, true);
						break;
						
					case DECOMPILE_OPENED_ONLY_PROCYON:
						//decompile using procyon
						decompileCurrentlyOpenedResource(Decompiler.PROCYON_DECOMPILER, file, false);
						break;
						
					case DECOMPILE_OPENED_ONLY_CFR:
						//decompile using cfr
						decompileCurrentlyOpenedResource(Decompiler.CFR_DECOMPILER, file, false);
						break;
						
					case DECOMPILE_OPENED_ONLY_FERNFLOWER:
						//decompile using fernflower
						decompileCurrentlyOpenedResource(Decompiler.FERNFLOWER_DECOMPILER, file, false);
						break;
						
					case DECOMPILE_OPENED_ONLY_KRAKATAU:
						//decompile using krakatau
						decompileCurrentlyOpenedResource(Decompiler.KRAKATAU_DECOMPILER, file, false);
						break;
				}
			}
			catch (Exception e)
			{
				BytecodeViewer.handleException(e);
			}
		});
	}
	
	public static int promptDecompilerUserSelect()
	{
		final JOptionPane pane = new JOptionPane("Which decompiler would you like to use?");
		final Object[] options = new String[]{ "All", "Procyon", "CFR",
				"Fernflower", "Krakatau", "Cancel"}; //TODO JDGUI,JADX
		
		pane.setOptions(options);
		final JDialog dialog = pane.createDialog(BytecodeViewer.viewer, "Bytecode Viewer - Select Decompiler");
		dialog.setVisible(true);
		final Object obj = pane.getValue();
		
		int result = -1;
		for (int k = 0; k < options.length; k++)
			if (options[k].equals(obj))
				result = k;
		
		return result;
	}
	
	public static void decompileSaveAll(Decompiler decompiler, File targetJar, File outputZip, boolean saveAll)
	{
		//signal to the user that BCV is performing an action in the background
		BytecodeViewer.updateBusyStatus(true);
		
		//decompile all opened classes to zip
		decompiler.getDecompiler().decompileToZip(targetJar.getAbsolutePath(), saveAll
				? MiscUtils.append(outputZip, "-" + decompiler.getDecompilerNameProgrammic() + ".zip")
				: outputZip.getAbsolutePath());
		
		//signal to the user that BCV is finished performing that action
		BytecodeViewer.updateBusyStatus(false);
	}
	
	public static void decompileCurrentlyOpenedResource(Decompiler decompiler, File outputFile, boolean saveAll)
	{
		//signal to the user that BCV is performing an action in the background
		BytecodeViewer.updateBusyStatus(true);
		
		//decompile the currently opened resource and save it to the specified file
		DiskWriter.replaceFile(saveAll
						? MiscUtils.append(outputFile, "-" + decompiler.getDecompilerNameProgrammic() + ".java")
						: outputFile.getAbsolutePath(),
				BCV.decompileCurrentlyOpenedClassNode(decompiler), false);
		
		//signal to the user that BCV is finished performing that action
		BytecodeViewer.updateBusyStatus(false);
	}
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/ResourceType.java`:

```java
package the.bytecode.club.bytecodeviewer.resources;

import java.util.HashMap;
import java.util.Map;
import javax.swing.ImageIcon;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/13/2021
 */

public enum ResourceType
{
	// TODO tar/gzip?
	// TODO add the files icons for the missing files from the.bytecode.club.bytecodeviewer.util.SyntaxLanguage
	//      or from org.fife.ui.rsyntaxtextarea.FileTypeUtil or from org.fife.ui.rsyntaxtextarea.SyntaxConstants

	CLASS_FILE(IconResources.classIcon, "class"),
	JAVA_ARCHIVE(IconResources.jarIcon, "jar", "war", "ear"),
	ZIP_ARCHIVE(IconResources.zipIcon, "zip"),
	ANDROID_ARCHIVE(IconResources.androidIcon, "apk", "wapk", "dex"),
	IMAGE_FILE(IconResources.imageIcon, "png", "jpg", "jpeg", "bmp", "wbmp", "gif", "tif", "webp"),
	CONFIG_TEXT_FILE(IconResources.configIcon, "properties", "xml", "jsp", "mf", "config",
			"csv", "yml", "yaml", "ini", "json", "sql", "gradle", "dockerfile", "htaccess",
			"plugin", "attachprovider", "transportservice", "connector"),
	JAVA_FILE(IconResources.javaIcon, "java"),
	TEXT_FILE(IconResources.textIcon, "txt", "md", "log", "html", "css"),
	CPP_FILE(IconResources.cplusplusIcon, "c", "cpp", "h"),
	CSHARP_FILE(IconResources.csharpIcon, "cs"),
	BAT_FILE(IconResources.batIcon, "bat", "batch"),
	SH_FILE(IconResources.shIcon, "sh", "bash"),
	;
	
	public static final Map<String, ResourceType> extensionMap = new HashMap<>();
	public static final Map<String, ResourceType> imageExtensionMap = new HashMap<>();
	public static final Map<String, ResourceType> supportedBCVExtensionMap = new HashMap<>();
	
	private final ImageIcon icon;
	private final String[] extensions;
	//private final byte[][] headerMagicNumber;
	
	static
	{
		//add all extensions
		for(ResourceType t : values())
			for(String extension : t.extensions)
				extensionMap.put(extension, t);
			
		//add image extensions
		for(String extension : IMAGE_FILE.extensions)
			imageExtensionMap.put(extension, IMAGE_FILE);
			
		//add extensions BCV can be opened with
		for(String extension : CLASS_FILE.extensions)
			supportedBCVExtensionMap.put(extension, CLASS_FILE);
		for(String extension : JAVA_ARCHIVE.extensions)
			supportedBCVExtensionMap.put(extension, JAVA_ARCHIVE);
		for(String extension : ZIP_ARCHIVE.extensions)
			supportedBCVExtensionMap.put(extension, ZIP_ARCHIVE);
		for(String extension : ANDROID_ARCHIVE.extensions)
			supportedBCVExtensionMap.put(extension, ANDROID_ARCHIVE);
	}
	
	ResourceType(ImageIcon icon, String... extensions)
	{
		this.icon = icon;
		this.extensions = extensions;
	}
	
	public ImageIcon getIcon()
	{
		return icon;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/exporting/Export.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.exporting;

import the.bytecode.club.bytecodeviewer.resources.exporting.impl.APKExport;
import the.bytecode.club.bytecodeviewer.resources.exporting.impl.DexExport;
import the.bytecode.club.bytecodeviewer.resources.exporting.impl.RunnableJarExporter;
import the.bytecode.club.bytecodeviewer.resources.exporting.impl.ZipExport;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public enum Export
{
	RUNNABLE_JAR(new RunnableJarExporter()),
	ZIP(new ZipExport()),
	DEX(new DexExport()),
	APK(new APKExport())
	;
	
	private final Exporter exporter;
	
	Export(Exporter exporter) {this.exporter = exporter;}
	
	public Exporter getExporter()
	{
		return exporter;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/exporting/Exporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.exporting;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public interface Exporter
{
	void promptForExport();
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/exporting/impl/APKExport.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.exporting.impl;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.swing.JFileChooser;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.exporting.Exporter;
import the.bytecode.club.bytecodeviewer.util.APKTool;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */

public class APKExport implements Exporter
{
	@Override
	public void promptForExport()
	{
		if (BytecodeViewer.promptIfNoLoadedResources())
			return;
		
		Collection<ResourceContainer> containers = BytecodeViewer.getResourceContainers();
		List<ResourceContainer> validContainers = new ArrayList<>();
		List<String> validContainersNames = new ArrayList<>();
		ResourceContainer container;
		
		for (ResourceContainer resourceContainer : containers)
		{
			if (resourceContainer.APKToolContents != null && resourceContainer.APKToolContents.exists())
			{
				validContainersNames.add(resourceContainer.name);
				validContainers.add(resourceContainer);
			}
		}
		
		if (!validContainers.isEmpty())
		{
			container = validContainers.get(0);
			
			//if theres only one file in the container don't bother asking
			if (validContainers.size() >= 2)
			{
				MultipleChoiceDialog dialog = new MultipleChoiceDialog("Bytecode Viewer - Select APK",
						"Which file would you like to export as an APK?",
						validContainersNames.toArray(new String[0]));
				
				//TODO may be off by one
				container = (ResourceContainer) containers.stream().skip(dialog.promptChoice());
			}
		} else {
			BytecodeViewer.showMessage("You can only export as APK from a valid APK file. Make sure Settings>Decode Resources is ticked on." +
					"\n\nTip: Try exporting as DEX, it doesn't rely on decoded APK resources");
			return;
		}
		
		final ResourceContainer finalContainer = container;
		
		Thread exportThread = new Thread(() ->
		{
			if (!BytecodeViewer.autoCompileSuccessful())
				return;
			
			JFileChooser fc = new FileChooser(Configuration.getLastSaveDirectory(),
					"Select APK Export",
					"Android APK",
					"apk");
			
			int returnVal = fc.showSaveDialog(BytecodeViewer.viewer);
			if (returnVal == JFileChooser.APPROVE_OPTION)
			{
				Configuration.setLastSaveDirectory(fc.getSelectedFile());
				
				final File file = MiscUtils.autoAppendFileExtension(".apk", fc.getSelectedFile());
				
				if (!DialogUtils.canOverwriteFile(file))
					return;
				
				Thread saveThread = new Thread(() ->
				{
					BytecodeViewer.updateBusyStatus(true);
					final String input = tempDirectory + fs + MiscUtils.getRandomizedName() + ".jar";
					JarUtils.saveAsJar(BytecodeViewer.getLoadedClasses(), input);
					
					Thread buildAPKThread = new Thread(() ->
					{
						APKTool.buildAPK(new File(input), file, finalContainer);
						BytecodeViewer.updateBusyStatus(false);
					}, "Process APK");
					buildAPKThread.start();
				}, "Jar Export");
				saveThread.start();
			}
		}, "Resource Export");
		exportThread.start();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/exporting/impl/DexExport.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.exporting.impl;

import java.io.File;
import javax.swing.JFileChooser;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.resources.exporting.Exporter;
import the.bytecode.club.bytecodeviewer.util.Dex2Jar;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public class DexExport implements Exporter
{
	
	@Override
	public void promptForExport()
	{
		if (BytecodeViewer.promptIfNoLoadedResources())
			return;
		
		Thread exportThread = new Thread(() ->
		{
			if (!BytecodeViewer.autoCompileSuccessful())
				return;
			
			JFileChooser fc = new FileChooser(Configuration.getLastSaveDirectory(),
					"Select DEX Export",
					"Android DEX Files",
					"dex");
			
			int returnVal = fc.showSaveDialog(BytecodeViewer.viewer);
			if (returnVal == JFileChooser.APPROVE_OPTION)
			{
				Configuration.setLastSaveDirectory(fc.getSelectedFile());
				
				final File file = fc.getSelectedFile();
				String output = file.getAbsolutePath();
				
				//auto append .dex
				if (!output.endsWith(".dex"))
					output += ".dex";
				
				File outputPath = new File(output);
				if (!DialogUtils.canOverwriteFile(outputPath))
					return;
				
				Thread saveAsJar = new Thread(() ->
				{
					BytecodeViewer.updateBusyStatus(true);
					final String input = tempDirectory + fs + MiscUtils.getRandomizedName() + ".jar";
					JarUtils.saveAsJar(BytecodeViewer.getLoadedClasses(), input);
					
					Thread saveAsDex = new Thread(() ->
					{
						Dex2Jar.saveAsDex(new File(input), outputPath);
						
						BytecodeViewer.updateBusyStatus(false);
					}, "Process DEX");
					saveAsDex.start();
				}, "Jar Export");
				saveAsJar.start();
			}
		}, "Resource Export");
		exportThread.start();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/exporting/impl/RunnableJarExporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.exporting.impl;

import java.io.File;
import javax.swing.JFileChooser;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.ExportJar;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.resources.exporting.Exporter;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public class RunnableJarExporter implements Exporter
{
	@Override
	public void promptForExport()
	{
		if (BytecodeViewer.promptIfNoLoadedResources())
			return;
		
		Thread exportThread = new Thread(() ->
		{
			if (!BytecodeViewer.autoCompileSuccessful())
				return;
			
			JFileChooser fc = new FileChooser(Configuration.getLastSaveDirectory(),
					"Select Jar Export",
					"Jar Archives",
					"jar");
			
			int returnVal = fc.showSaveDialog(BytecodeViewer.viewer);
			if (returnVal == JFileChooser.APPROVE_OPTION)
			{
				Configuration.setLastSaveDirectory(fc.getSelectedFile());
				
				File file = fc.getSelectedFile();
				String path = file.getAbsolutePath();
				
				//auto append .jar
				if (!path.endsWith(".jar"))
					path += ".jar";
				
				if (!DialogUtils.canOverwriteFile(path))
					return;
				
				new ExportJar(path).setVisible(true);
			}
		}, "Runnable Jar Export");
		exportThread.start();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/exporting/impl/ZipExport.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.exporting.impl;

import java.io.File;
import javax.swing.JFileChooser;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.resources.exporting.Exporter;
import the.bytecode.club.bytecodeviewer.util.DialogUtils;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/27/2021
 */
public class ZipExport implements Exporter
{
	@Override
	public void promptForExport()
	{
		if (BytecodeViewer.promptIfNoLoadedResources())
			return;
		
		Thread exportThread = new Thread(() ->
		{
			if (!BytecodeViewer.autoCompileSuccessful())
				return;
			
			JFileChooser fc = new FileChooser(Configuration.getLastSaveDirectory(),
					"Select Zip Export",
					"Zip Archives",
					"zip");
			
			int returnVal = fc.showSaveDialog(BytecodeViewer.viewer);
			if (returnVal == JFileChooser.APPROVE_OPTION)
			{
				Configuration.setLastSaveDirectory(fc.getSelectedFile());
				
				final File file = MiscUtils.autoAppendFileExtension(".zip", fc.getSelectedFile()); //auto append .zip extension
				
				if (!DialogUtils.canOverwriteFile(file))
					return;
				
				BytecodeViewer.updateBusyStatus(true);
				Thread saveThread = new Thread(() ->
				{
					JarUtils.saveAsJar(BytecodeViewer.getLoadedClasses(), file.getAbsolutePath());
					BytecodeViewer.updateBusyStatus(false);
				}, "Jar Export");
				saveThread.start();
			}
		}, "Resource Export");
		exportThread.start();
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/Import.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing;

import java.util.HashMap;
import the.bytecode.club.bytecodeviewer.resources.importing.impl.APKResourceImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.impl.ClassResourceImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.impl.DEXResourceImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.impl.DirectoryResourceImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.impl.FileResourceImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.impl.XAPKResourceImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.impl.ZipResourceImporter;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public enum Import
{
	DIRECTORY(new DirectoryResourceImporter()),
	FILE(new FileResourceImporter()),
	//TODO ear needs to import the same as XAPK
	//TODO war needs to add the /libs correctly similar to XAPK
	ZIP(new ZipResourceImporter(), "zip", "jar", "war", "ear"),
	CLASS(new ClassResourceImporter(), "class"),
	XAPK(new XAPKResourceImporter(), "xapk"),
	APK(new APKResourceImporter(), "apk"),
	DEX(new DEXResourceImporter(), "dex"),
	;
	
	public static final HashMap<String, Import> extensionMap = new HashMap<>();
	
	private final Importer importer;
	private final String[] extensions;
	
	static
	{
		for(Import i : values())
			for(String s : i.extensions)
				extensionMap.put(s, i);
	}
	
	Import(Importer importer, String... extensions) {this.importer = importer;
		this.extensions = extensions;
	}
	
	public Importer getImporter()
	{
		return importer;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/ImportResource.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing;

import java.io.File;
import org.apache.commons.io.FilenameUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Settings;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 */
public class ImportResource implements Runnable
{
	private final File[] files;
	
	public ImportResource(File[] files) {this.files = files;}
	
	@Override
	public void run()
	{
		try
		{
			for (final File file : files)
			{
				final String fn = file.getName();
				System.out.println("Opening..." + file.getAbsolutePath());
				
				//check if file exists
				if (!file.exists())
				{
					BytecodeViewer.showMessage("The file " + file.getAbsolutePath() + " could not be found.");
					Settings.removeRecentFile(file);
					continue;
				}
				
				//check if file is directory
				if (file.isDirectory())
				{
					Import.DIRECTORY.getImporter().open(file);
				}
				//everything else import as a resource
				else if(!importKnownFile(file))
					Import.FILE.getImporter().open(file);
			}
		}
		catch (final Exception e)
		{
			BytecodeViewer.handleException(e);
		}
		finally
		{
			BytecodeViewer.updateBusyStatus(false);
		}
	}
	
	/**
	 * Imports a file using File-Specific importers/decoders
	 */
	public static boolean importKnownFile(File file) throws Exception
	{
		final String fn = FilenameUtils.getName(file.getName()).toLowerCase();
		final String extension = fn.contains(":") ? null : FilenameUtils.getExtension(fn);
		
		Import imp = Import.extensionMap.get(extension);
		
		if(imp == null)
			return false;
		
		//import/decode the file using the file specific importer
		imp.getImporter().open(file);
		
		return true;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/Importer.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing;

import java.io.File;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public interface Importer
{
	void open(File file) throws Exception;
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/impl/APKResourceImporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing.impl;

import java.io.File;
import org.apache.commons.io.FileUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainerImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.Importer;
import the.bytecode.club.bytecodeviewer.util.APKTool;
import the.bytecode.club.bytecodeviewer.util.Dex2Jar;
import the.bytecode.club.bytecodeviewer.util.Enjarify;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public class APKResourceImporter implements Importer
{

	@Override
	public void open(File file) throws Exception
	{
		File tempCopy = new File(tempDirectory + fs + MiscUtils.randomString(32) + ".apk");
		FileUtils.copyFile(file, tempCopy);
		
		ResourceContainer container = new ResourceContainer(tempCopy, file.getName());
		
		// APK Resource Decoding Here
		if (BytecodeViewer.viewer.decodeAPKResources.isSelected())
		{
			File decodedResources = new File(tempDirectory + fs + MiscUtils.randomString(32) + ".apk");
			APKTool.decodeResources(tempCopy, decodedResources, container);
			container.resourceFiles = JarUtils.loadResources(decodedResources);
		}
		
		container.resourceFiles.putAll(JarUtils.loadResources(tempCopy)); // copy and rename
		// to prevent unicode filenames
		
		String name = MiscUtils.getRandomizedName() + ".jar";
		File output = new File(tempDirectory + fs + name);
		
		if (BytecodeViewer.viewer.apkConversionGroup.isSelected(BytecodeViewer.viewer.apkConversionDex.getModel()))
			Dex2Jar.dex2Jar(tempCopy, output);
		else if (BytecodeViewer.viewer.apkConversionGroup.isSelected(BytecodeViewer.viewer.apkConversionEnjarify.getModel()))
			Enjarify.apk2Jar(tempCopy, output);
		
		// create a new resource importer and copy the contents from it
		container.copy(new ResourceContainerImporter(
				new ResourceContainer(output)).importAsZip().getContainer());
		
		BytecodeViewer.addResourceContainer(container);
	}

}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/impl/ClassResourceImporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing.impl;

import java.io.File;
import java.io.FileInputStream;
import org.apache.commons.io.FilenameUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.importing.Importer;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public class ClassResourceImporter implements Importer
{
	@Override
	public void open(File file) throws Exception
	{
		final String name = file.getName();
		try (FileInputStream fis = new FileInputStream(file)) {
			byte[] bytes = MiscUtils.getBytes(fis);
			ResourceContainer container = new ResourceContainer(file);

			if (MiscUtils.getFileHeaderMagicNumber(bytes).equalsIgnoreCase("cafebabe"))
			{
				final ClassNode cn = JarUtils.getNode(bytes);

				container.resourceClasses.put(FilenameUtils.removeExtension(name), cn);
				container.resourceClassBytes.put(name, bytes);
			}
			else
			{
				BytecodeViewer.showMessage(name + "\nHeader does not start with CAFEBABE\nimporting as resource instead.");

				//TODO double check this
				container.resourceFiles.put(name, bytes);
			}
			BytecodeViewer.addResourceContainer(container);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/impl/DEXResourceImporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing.impl;

import java.io.File;
import org.apache.commons.io.FileUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainerImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.Importer;
import the.bytecode.club.bytecodeviewer.util.Dex2Jar;
import the.bytecode.club.bytecodeviewer.util.Enjarify;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public class DEXResourceImporter implements Importer
{
	@Override
	public void open(File file) throws Exception
	{
		File tempCopy = new File(tempDirectory + fs + MiscUtils.randomString(32) + ".dex");
		
		FileUtils.copyFile(file, tempCopy); //copy and rename to prevent unicode filenames
		
		ResourceContainer container = new ResourceContainer(tempCopy, file.getName());
		
		String name = MiscUtils.getRandomizedName() + ".jar";
		File output = new File(tempDirectory + fs + name);
		
		if (BytecodeViewer.viewer.apkConversionGroup.isSelected(BytecodeViewer.viewer.apkConversionDex.getModel()))
			Dex2Jar.dex2Jar(tempCopy, output);
		else if (BytecodeViewer.viewer.apkConversionGroup.isSelected(BytecodeViewer.viewer.apkConversionEnjarify.getModel()))
			Enjarify.apk2Jar(tempCopy, output);
		
		//create a new resource importer and copy the contents from it
		container.copy(new ResourceContainerImporter(
				new ResourceContainer(output)).importAsZip().getContainer());
		
		BytecodeViewer.addResourceContainer(container);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/impl/DirectoryResourceImporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing.impl;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.io.FilenameUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.importing.ImportResource;
import the.bytecode.club.bytecodeviewer.resources.importing.Importer;
import the.bytecode.club.bytecodeviewer.util.JarUtils;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public class DirectoryResourceImporter implements Importer
{
	@Override
	public void open(File file) throws Exception
	{
		ResourceContainer container = new ResourceContainer(file);
		Map<String, byte[]> allDirectoryFiles = new LinkedHashMap<>();
		Map<String, ClassNode> allDirectoryClasses = new LinkedHashMap<>();
		
		boolean finished = false;
		List<File> totalFiles = new ArrayList<>();
		totalFiles.add(file);
		String dir = file.getAbsolutePath();
		
		while (!finished)
		{
			boolean added = false;
			for (int i = 0; i < totalFiles.size(); i++)
			{
				File child = totalFiles.get(i);
				for (File rocket : MiscUtils.listFiles(child))
					if (!totalFiles.contains(rocket))
					{
						totalFiles.add(rocket);
						added = true;
					}
			}
			
			if (!added)
			{
				for (File child : totalFiles)
				{
					if(!child.isFile())
						continue;
					
					final String trimmedPath = child.getAbsolutePath().substring(dir.length() + 1)
							.replaceAll("\\\\", "\\/");
					final String fileName = child.getName();
					
					if (fileName.endsWith(".class"))
					{
						byte[] bytes = Files.readAllBytes(Paths.get(child.getAbsolutePath()));
						if (MiscUtils.getFileHeaderMagicNumber(bytes).equalsIgnoreCase("cafebabe"))
						{
							final ClassNode cn = JarUtils.getNode(bytes);
							allDirectoryClasses.put(FilenameUtils.removeExtension(trimmedPath), cn);
						}
					}
					//attempt to import archives automatically
					else if(ImportResource.importKnownFile(file))
					{
						//let import resource handle it
					}
					else //pack files into a single container
					{
						allDirectoryFiles.put(trimmedPath, Files.readAllBytes(Paths.get(child.getAbsolutePath())));
					}
				}
				
				finished = true;
			}
		}
		
		container.resourceClasses.putAll(allDirectoryClasses);
		container.resourceFiles = allDirectoryFiles;
		BytecodeViewer.addResourceContainer(container);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/impl/FileResourceImporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing.impl;

import java.io.File;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainerImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.Importer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public class FileResourceImporter implements Importer
{
	@Override
	public void open(File file) throws Exception
	{
		//create the new resource container
		ResourceContainer container = new ResourceContainer(file);
		//create the new file importer
		ResourceContainerImporter importer = new ResourceContainerImporter(container);
		//import the file into the resource container
		importer.importAsFile();
		//add the resource container to BCV's total loaded files
		BytecodeViewer.addResourceContainer(container);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/impl/XAPKResourceImporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import me.konloch.kontainer.io.DiskWriter;
import org.apache.commons.io.IOUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.importing.Import;
import the.bytecode.club.bytecodeviewer.resources.importing.Importer;
import the.bytecode.club.bytecodeviewer.util.MiscUtils;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Compressed APKs (XAPK)
 *
 * @author Konloch
 * @since 6/26/2021
 */
public class XAPKResourceImporter implements Importer
{
	@Override
	public void open(File file) throws Exception
	{
		ResourceContainer container = new ResourceContainer(file);
		Map<String, byte[]> allDirectoryFiles = new LinkedHashMap<>();
		
		Configuration.silenceExceptionGUI++; //turn exceptions off
		try (ZipFile zipFile = new ZipFile(file))
		{
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			while (entries.hasMoreElements())
			{
				final ZipEntry entry = entries.nextElement();
				final String fileName = entry.getName();
				
				if(entry.isDirectory())
					continue;
				
				if (fileName.endsWith(".apk"))
				{
					File tempFile = new File(tempDirectory + fs + "temp" + MiscUtils.randomString(32) + fs + entry);
					tempFile.getParentFile().mkdirs();
					
					try (InputStream in = zipFile.getInputStream(entry);
					     OutputStream out = new FileOutputStream(tempFile))
					{
						IOUtils.copy(in, out);
					}
					Import.APK.getImporter().open(tempFile);
				}
				else
				{
					//pack files into a single container
					byte[] bytes;
					try (InputStream in = zipFile.getInputStream(entry))
					{
						bytes = IOUtils.toByteArray(in);
					}
					allDirectoryFiles.put(fileName, bytes);
				}
			}
		}
		
		Configuration.silenceExceptionGUI--; //turn exceptions back on
		BytecodeViewer.viewer.clearBusyStatus(); //clear errant busy signals from failed APK imports
		container.resourceFiles = allDirectoryFiles; //store the file resource
		BytecodeViewer.addResourceContainer(container); //add the resource container to BCV's total loaded files
	}
	
	public File exportTo(File original, String extension, byte[] bytes)
	{
		File file = new File(original.getAbsolutePath() + extension);
		DiskWriter.replaceFileBytes(file.getAbsolutePath(), bytes, false);
		return file;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/resources/importing/impl/ZipResourceImporter.java`:

```java
package the.bytecode.club.bytecodeviewer.resources.importing.impl;

import java.io.File;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainerImporter;
import the.bytecode.club.bytecodeviewer.resources.importing.Importer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/26/2021
 */
public class ZipResourceImporter implements Importer
{
	@Override
	public void open(File file) throws Exception
	{
		//create the new resource container
		ResourceContainer container = new ResourceContainer(file);
		//create the new file importer
		ResourceContainerImporter importer = new ResourceContainerImporter(container);
		//import the file as zip into the resource container
		importer.importAsZip();
		//add the resource container to BCV's total loaded files
		BytecodeViewer.addResourceContainer(container);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/BackgroundSearchThread.java`:

```java
package the.bytecode.club.bytecodeviewer.searching;

import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple class to make searching run in a background thread.
 *
 * @author Konloch
 */

public abstract class BackgroundSearchThread extends Thread
{
    public BackgroundSearchThread() { }

    public BackgroundSearchThread(boolean finished) {
        this.finished = finished;
    }

    public boolean finished = false;

    public abstract void search();

    @Override
    public void run()
    {
        BytecodeViewer.updateBusyStatus(true);
        search();
        finished = true;
        BytecodeViewer.updateBusyStatus(false);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/EnterKeyEvent.java`:

```java
package the.bytecode.club.bytecodeviewer.searching;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * searchBoxPane search triggering via enter key
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/26/2011
 */

public class EnterKeyEvent implements KeyListener
{
    public static final EnterKeyEvent SINGLETON = new EnterKeyEvent();

    @Override
    public void keyTyped(KeyEvent e) { }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_ENTER)
            BytecodeViewer.viewer.searchBoxPane.search();
    }

    @Override
    public void keyReleased(KeyEvent e) { }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/LDCSearchTreeNodeResult.java`:

```java
package the.bytecode.club.bytecodeviewer.searching;

import javax.swing.tree.DefaultMutableTreeNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/29/2021
 */
public class LDCSearchTreeNodeResult extends DefaultMutableTreeNode
{
	public final ResourceContainer container;
	public final String resourceWorkingName;
	public final String ldc;
	public final String ldcType;
	
	public LDCSearchTreeNodeResult(ResourceContainer container, String resourceWorkingName,
	                               ClassNode cn, MethodNode method, FieldNode field,
	                               String ldc, String ldcType)
	{
		super("'"+ldc+"' -> " + cn.name);
		this.container = container;
		this.resourceWorkingName = resourceWorkingName;
		this.ldc = ldc;
		this.ldcType = ldcType;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/RegexInsnFinder.java`:

```java
package the.bytecode.club.bytecodeviewer.searching;

import java.rmi.UnexpectedException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.IincInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.MultiANewArrayInsnNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.VarInsnNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * An instruction finder that finds regex patterns in a method's instruction
 * list and returns an array with the found instructions.
 *
 * @author Frédéric Hannes
 */

public class RegexInsnFinder {

    private static final String[] opcodes = new String[]{"NOP", "ACONST_NULL",
            "ICONST_M1", "ICONST_0", "ICONST_1", "ICONST_2", "ICONST_3",
            "ICONST_4", "ICONST_5", "LCONST_0", "LCONST_1", "FCONST_0",
            "FCONST_1", "FCONST_2", "DCONST_0", "DCONST_1", "BIPUSH", "SIPUSH",
            "LDC", "LDC_W", "LDC2_W", "ILOAD", "LLOAD", "FLOAD", "DLOAD",
            "ALOAD", "ILOAD_0", "ILOAD_1", "ILOAD_2", "ILOAD_3", "LLOAD_0",
            "LLOAD_1", "LLOAD_2", "LLOAD_3", "FLOAD_0", "FLOAD_1", "FLOAD_2",
            "FLOAD_3", "DLOAD_0", "DLOAD_1", "DLOAD_2", "DLOAD_3", "ALOAD_0",
            "ALOAD_1", "ALOAD_2", "ALOAD_3", "IALOAD", "LALOAD", "FALOAD",
            "DALOAD", "AALOAD", "BALOAD", "CALOAD", "SALOAD", "ISTORE",
            "LSTORE", "FSTORE", "DSTORE", "ASTORE", "ISTORE_0", "ISTORE_1",
            "ISTORE_2", "ISTORE_3", "LSTORE_0", "LSTORE_1", "LSTORE_2",
            "LSTORE_3", "FSTORE_0", "FSTORE_1", "FSTORE_2", "FSTORE_3",
            "DSTORE_0", "DSTORE_1", "DSTORE_2", "DSTORE_3", "ASTORE_0",
            "ASTORE_1", "ASTORE_2", "ASTORE_3", "IASTORE", "LASTORE",
            "FASTORE", "DASTORE", "AASTORE", "BASTORE", "CASTORE", "SASTORE",
            "POP", "POP2", "DUP", "DUP_X1", "DUP_X2", "DUP2", "DUP2_X1",
            "DUP2_X2", "SWAP", "IADD", "LADD", "FADD", "DADD", "ISUB", "LSUB",
            "FSUB", "DSUB", "IMUL", "LMUL", "FMUL", "DMUL", "IDIV", "LDIV",
            "FDIV", "DDIV", "IREM", "LREM", "FREM", "DREM", "INEG", "LNEG",
            "FNEG", "DNEG", "ISHL", "LSHL", "ISHR", "LSHR", "IUSHR", "LUSHR",
            "IAND", "LAND", "IOR", "LOR", "IXOR", "LXOR", "IINC", "I2L", "I2F",
            "I2D", "L2I", "L2F", "L2D", "F2I", "F2L", "F2D", "D2I", "D2L",
            "D2F", "I2B", "I2C", "I2S", "LCMP", "FCMPL", "FCMPG", "DCMPL",
            "DCMPG", "IFEQ", "IFNE", "IFLT", "IFGE", "IFGT", "IFLE",
            "IF_ICMPEQ", "IF_ICMPNE", "IF_ICMPLT", "IF_ICMPGE", "IF_ICMPGT",
            "IF_ICMPLE", "IF_ACMPEQ", "IF_ACMPNE", "GOTO", "JSR", "RET",
            "TABLESWITCH", "LOOKUPSWITCH", "IRETURN", "LRETURN", "FRETURN",
            "DRETURN", "ARETURN", "RETURN", "GETSTATIC", "PUTSTATIC",
            "GETFIELD", "PUTFIELD", "INVOKEVIRTUAL", "INVOKESPECIAL",
            "INVOKESTATIC", "INVOKEINTERFACE", "INVOKEDYNAMIC", "NEW",
            "NEWARRAY", "ANEWARRAY", "ARRAYLENGTH", "ATHROW", "CHECKCAST",
            "INSTANCEOF", "MONITORENTER", "MONITOREXIT", "WIDE",
            "MULTIANEWARRAY", "IFNULL", "IFNONNULL", "GOTO_W", "JSR_W"};

    private static final String[] opcodesVar = new String[]{"ILOAD", "LLOAD",
            "FLOAD", "DLOAD", "ALOAD", "ISTORE", "LSTORE", "FSTORE", "DSTORE",
            "ASTORE", "RET"};
    private static final String opcodeVars = buildRegexItems(opcodesVar);

    private static final String[] opcodesInt = new String[]{"BIPUSH", "SIPUSH",
            "NEWARRAY"};
    private static final String opcodesInts = buildRegexItems(opcodesInt);

    private static final String[] opcodesField = new String[]{"GETSTATIC",
            "PUTSTATIC", "GETFIELD", "PUTFIELD"};
    private static final String opcodesFields = buildRegexItems(opcodesField);

    private static final String[] opcodesMethod = new String[]{"INVOKEVIRTUAL",
            "INVOKESPECIAL", "INVOKESTATIC", "INVOKEINTERFACE", "INVOKEDYNAMIC"};
    private static final String opcodesMethods = buildRegexItems(opcodesMethod);

    private static final String[] opcodesType = new String[]{"NEW", "ANEWARRAY",
            "ARRAYLENGTH", "CHECKCAST", "INSTANCEOF"};
    private static final String opcodesTypes = buildRegexItems(opcodesType);

    private static final String[] opcodesIf = new String[]{"IFEQ", "IFNE", "IFLT",
            "IFGE", "IFGT", "IFLE", "IF_ICMPEQ", "IF_ICMPNE", "IF_ICMPLT",
            "IF_ICMPGE", "IF_ICMPGT", "IF_ICMPLE", "IF_ACMPEQ", "IF_ACMPNE"};
    private static final String opcodesIfs = buildRegexItems(opcodesIf, false, false);

    private static final String[] opcodesAny = new String[]{"NOP", "ACONST_NULL",
            "ICONST_M1", "ICONST_0", "ICONST_1", "ICONST_2", "ICONST_3",
            "ICONST_4", "ICONST_5", "LCONST_0", "LCONST_1", "FCONST_0",
            "FCONST_1", "FCONST_2", "DCONST_0", "DCONST_1", "BIPUSH", "SIPUSH",
            "LDC", "LDC_W", "LDC2_W", "ILOAD", "LLOAD", "FLOAD", "DLOAD",
            "ALOAD", "IALOAD", "LALOAD", "FALOAD", "DALOAD", "AALOAD",
            "BALOAD", "CALOAD", "SALOAD", "ISTORE", "LSTORE", "FSTORE",
            "DSTORE", "ASTORE", "IASTORE", "LASTORE", "FASTORE", "DASTORE",
            "AASTORE", "BASTORE", "CASTORE", "SASTORE", "POP", "POP2", "DUP",
            "DUP_X1", "DUP_X2", "DUP2", "DUP2_X1", "DUP2_X2", "SWAP", "IADD",
            "LADD", "FADD", "DADD", "ISUB", "LSUB", "FSUB", "DSUB", "IMUL",
            "LMUL", "FMUL", "DMUL", "IDIV", "LDIV", "FDIV", "DDIV", "IREM",
            "LREM", "FREM", "DREM", "INEG", "LNEG", "FNEG", "DNEG", "ISHL",
            "LSHL", "ISHR", "LSHR", "IUSHR", "LUSHR", "IAND", "LAND", "IOR",
            "LOR", "IXOR", "LXOR", "IINC", "I2L", "I2F", "I2D", "L2I", "L2F",
            "L2D", "F2I", "F2L", "F2D", "D2I", "D2L", "D2F", "I2B", "I2C",
            "I2S", "LCMP", "FCMPL", "FCMPG", "DCMPL", "DCMPG", "IFEQ", "IFNE",
            "IFLT", "IFGE", "IFGT", "IFLE", "IF_ICMPEQ", "IF_ICMPNE",
            "IF_ICMPLT", "IF_ICMPGE", "IF_ICMPGT", "IF_ICMPLE", "IF_ACMPEQ",
            "IF_ACMPNE", "GOTO", "JSR", "RET", "TABLESWITCH", "LOOKUPSWITCH",
            "IRETURN", "LRETURN", "FRETURN", "DRETURN", "ARETURN", "RETURN",
            "GETSTATIC", "PUTSTATIC", "GETFIELD", "PUTFIELD", "INVOKEVIRTUAL",
            "INVOKESPECIAL", "INVOKESTATIC", "INVOKEINTERFACE",
            "INVOKEDYNAMIC", "NEW", "NEWARRAY", "ANEWARRAY", "ARRAYLENGTH",
            "ATHROW", "CHECKCAST", "INSTANCEOF", "MONITORENTER", "MONITOREXIT",
            "MULTIANEWARRAY", "IFNULL", "IFNONNULL"};
    private static final String opcodesAnys = buildRegexItems(opcodesAny, false,
            false);

    private static String buildRegexItems(final String[] items,
                                          final boolean capture, final boolean stdRepl) {
        if (items.length == 0)
            return "()";
        StringBuilder result = new StringBuilder((stdRepl ? "\\b" : "") + "(" + (capture ? "" : "?:")
                + items[0]);
        for (int i = 1; i < items.length; i++) {
            result.append("|").append(items[i]);
        }
        result.append(")");
        return result.toString();
    }

    private static String buildRegexItems(final String[] items) {
        return buildRegexItems(items, true, true);
    }

    public static String processRegex(final String regex) {
        String result = regex.trim();
        result = result.replaceAll("\\bANYINSN *", opcodesAnys);
        result = result.replaceAll(opcodesInts
                + "\\\\\\{\\s*(\\d+)\\s*\\\\} *", "$1\\\\{$2\\\\} ");
        result = result.replaceAll(opcodesInts + " *", "$1\\\\{\\\\d+\\\\} ");
        result = result.replaceAll(
                "\\bLDC\\\\\\{(.*?)\\\\}(?<!\\\\\\\\}) *",
                "LDC\\\\{$1\\\\}(?<!\\\\\\\\\\\\}) ");
        result = result.replaceAll("\\bLDC *",
                "LDC\\\\{.*?\\\\}(?<!\\\\\\\\\\\\}) ");
        result = result.replaceAll(opcodeVars + "(_\\d+) *", "$1$2 ");
        result = result.replaceAll(opcodeVars + "(?!_) *", "$1_\\\\d+ ");
        result = result.replaceAll(
                "\\bIINC\\\\\\{\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\\\} *",
                "IINC\\\\{$1,$2\\\\} ");
        result = result.replaceAll("\\bIINC\\\\\\{\\s*(\\d+)\\s*\\\\} *",
                "IINC\\\\{\\d+,$1\\\\} ");
        result = result.replaceAll("\\bIINC *", "IINC\\\\{\\d+,\\d+\\\\} ");
        result = result.replaceAll(opcodesFields
                        + "\\\\\\{\\s*(.*?)\\s*,\\s*(.*?)\\s*,\\s*(.*?)\\s*\\\\} *",
                "$1\\\\{$2,$3,$4\\\\} ");
        result = result.replaceAll(opcodesFields
                + "\\\\\\{((?:.(?!,))*)\\\\} *", "$1\\\\{$2,.*?,.*?\\\\} ");
        result = result.replaceAll(opcodesFields + " *", "$1\\\\{.*?\\\\} ");
        result = result.replaceAll(opcodesMethods
                        + "\\\\\\{\\s*(.*?)\\s*,\\s*(.*?)\\s*,\\s*(.*?)\\s*\\\\} *",
                "$1\\\\{$2,$3,$4\\\\} ");
        result = result.replaceAll(opcodesMethods
                + "\\\\\\{((?:.(?!,))*)\\\\} *", "$1\\\\{$2,.*?,.*?\\\\} ");
        result = result.replaceAll(opcodesMethods + " *",
                "$1\\\\{.*?,.*?,.*?\\\\} ");
        result = result.replaceAll(opcodesTypes
                + "\\\\\\{\\s*(.*?)\\s*\\\\} +", "$1\\\\{$2\\\\} ");
        result = result.replaceAll(opcodesTypes + " +", "$1\\\\{\\\\.*?\\\\} ");
        result = result
                .replaceAll(
                        "\\bMULTIANEWARRAY\\\\\\{\\s*(\\d+)\\s*,\\s*(.*?)\\s*\\\\} *",
                        "MULTIANEWARRAY\\\\{$1,$2\\\\} ");
        result = result.replaceAll(
                "\\bMULTIANEWARRAY\\\\\\{\\s*(.*?)\\s*\\\\} *",
                "MULTIANEWARRAY\\\\{\\d+,$1\\\\} ");
        result = result.replaceAll("\\bMULTIANEWARRAY *",
                "MULTIANEWARRAY\\\\{\\\\\\d+,.*?\\\\} ");
        result = result.replaceAll("\\bIFINSN *", opcodesIfs + " ");
        return result;
    }

    private MethodNode mn;
    private AbstractInsnNode[] origInstructions;
    private int[] offsets;
    private String insnString;

    public RegexInsnFinder(final ClassNode clazz, final MethodNode method) {
        setMethod(clazz, method);
    }

    private AbstractInsnNode[] cleanInsn(final InsnList insnList) {
        final List<AbstractInsnNode> il = new ArrayList<>();

        for (AbstractInsnNode node : insnList) {
            if (node.getOpcode() >= 0) {
                il.add(node);
            }
        }
        return il.toArray(new AbstractInsnNode[0]);
    }

    /**
     * Refreshes the internal instruction list when you have made changes to the
     * method.
     */
    public void refresh() {
        origInstructions = cleanInsn(mn.instructions);
        final List<AbstractInsnNode> il = new ArrayList<>();
        for (final AbstractInsnNode ain : mn.instructions.toArray())
            if (ain.getOpcode() >= 0) {
                il.add(ain);
            }
        AbstractInsnNode[] instructions = il.toArray(new AbstractInsnNode[0]);
        offsets = new int[instructions.length];
        StringBuilder insnStringBuilder = new StringBuilder();
        for (int i = 0; i < instructions.length; i++) {
            offsets[i] = -1;
            final AbstractInsnNode ain = instructions[i];
            if (ain.getOpcode() >= 0) {
                if (ain.getOpcode() >= opcodes.length) {
                    try {
                        throw new UnexpectedException(
                                "Unknown opcode encountered: "
                                        + ain.getOpcode());
                    } catch (final UnexpectedException e) {
                        BytecodeViewer.handleException(e);
                    }
                }
                offsets[i] = insnStringBuilder.length();
                insnStringBuilder.append(opcodes[ain.getOpcode()]);
                insnStringBuilder = new StringBuilder(getInsString(ain));
                insnStringBuilder.append(" ");
            }
        }
        insnString = insnStringBuilder.toString();
    }

    // Do a pattern check against each instruction directly,
    // without building a string of the whole method.
    public static boolean staticScan(ClassNode node, MethodNode mn, Pattern pattern) {
        final List<AbstractInsnNode> il = new ArrayList<>();
        for (final AbstractInsnNode ain : mn.instructions.toArray())
            if (ain.getOpcode() >= 0) {
                il.add(ain);
            }
        return il.stream().anyMatch(ain -> {
            if (ain.getOpcode() >= 0) {
                if (ain.getOpcode() >= opcodes.length) {
                    try {
                        throw new UnexpectedException(
                                "Unknown opcode encountered: "
                                        + ain.getOpcode());
                    } catch (final UnexpectedException e) {
                        BytecodeViewer.handleException(e);
                    }
                }
                String insnString = getInsString(ain);
                return pattern.matcher(insnString).find();
            }
            return false;
        });
    }

    private static String getInsString(AbstractInsnNode ain) {
        String insnString = "";
        switch (ain.getType()) {
        case AbstractInsnNode.INT_INSN:
            final IntInsnNode iin = (IntInsnNode) ain;
            insnString += "{" + iin.operand + "}";
            break;
        case AbstractInsnNode.LDC_INSN:
            final LdcInsnNode lin = (LdcInsnNode) ain;
            insnString += "{" + lin.cst.toString().replace("}", "\\}")
                    + "}";
            break;
        case AbstractInsnNode.VAR_INSN:
            final VarInsnNode vin = (VarInsnNode) ain;
            insnString += "_" + vin.var;
            break;
        case AbstractInsnNode.IINC_INSN:
            final IincInsnNode iiin = (IincInsnNode) ain;
            insnString += "{" + iiin.var + "," + iiin.incr + "}";
            break;
        case AbstractInsnNode.FIELD_INSN:
            final FieldInsnNode fin = (FieldInsnNode) ain;
            insnString += "{" + fin.desc + "," + fin.owner + ","
                    + fin.name + "}";
            break;
        case AbstractInsnNode.METHOD_INSN:
            final MethodInsnNode min = (MethodInsnNode) ain;
            insnString += "{" + min.desc + "," + min.owner + ","
                    + min.name + "}";
            break;
        case AbstractInsnNode.TYPE_INSN:
            final TypeInsnNode tin = (TypeInsnNode) ain;
            insnString += "{" + tin.desc + "}";
            break;
        case AbstractInsnNode.MULTIANEWARRAY_INSN:
            final MultiANewArrayInsnNode manain = (MultiANewArrayInsnNode) ain;
            insnString += "{" + manain.dims + "," + manain.desc + "}";
            break;
        }
        return insnString;
    }

    public void setMethod(final ClassNode ci, final MethodNode mi) {
        this.mn = mi;
        refresh();
    }

    private AbstractInsnNode[] makeResult(final int start, final int end) {
        int startIndex = 0;
        int endIndex = -1;
        for (int i = 0; i < offsets.length - 1; i++) {
            final int offset = offsets[i];
            if (offset == start) {
                startIndex = i;
            }
            if ((offset < end) && (offsets[i + 1] >= end)) {
                endIndex = i;
                break;
            }
        }
        if (endIndex == -1) {
            endIndex = offsets.length - 1;
        }
        final int length = endIndex - startIndex + 1;
        final AbstractInsnNode[] result = new AbstractInsnNode[length];
        System.arraycopy(origInstructions, startIndex, result, 0, length);
        return result;
    }

    /**
     * Searches for a regex in the instruction list and returns the first match.
     *
     * @param regex the regular expression
     * @return the matching instructions
     */
    public AbstractInsnNode[] find(final String regex) {
        try {
            final Matcher regexMatcher = Pattern.compile(processRegex(regex),
                    Pattern.MULTILINE).matcher(insnString);
            if (regexMatcher.find())
                return makeResult(regexMatcher.start(), regexMatcher.end());
        } catch (final PatternSyntaxException ex) {
            //ignore, they fucked up regex
        }
        return new AbstractInsnNode[0];
    }

    /**
     * Searches a regex in an instruction list and returns all matches.
     *
     * @param regex the regular expression
     * @return a list with all sets of matching instructions
     */
    public List<AbstractInsnNode[]> findAll(final String regex) {
        final List<AbstractInsnNode[]> results = new ArrayList<>();
        try {
            final Matcher regexMatcher = Pattern.compile(processRegex(regex),
                    Pattern.MULTILINE).matcher(insnString);
            while (regexMatcher.find()) {
                results.add(makeResult(regexMatcher.start(), regexMatcher.end()));
            }
        } catch (final PatternSyntaxException ex) {
            BytecodeViewer.handleException(ex);
        }
        return results;
    }

    /**
     * Searches for a regex in the instruction list and returns all groups for
     * the first match.
     *
     * @param regex the regular expression
     * @return the groups with matching instructions
     */
    public AbstractInsnNode[][] findGroups(final String regex) {
        try {
            final Matcher regexMatcher = Pattern.compile(processRegex(regex),
                    Pattern.MULTILINE).matcher(insnString);
            if (regexMatcher.find()) {
                final AbstractInsnNode[][] result = new AbstractInsnNode[regexMatcher
                        .groupCount() + 1][0];
                for (int i = 0; i <= regexMatcher.groupCount(); i++) {
                    result[i] = makeResult(regexMatcher.start(i),
                            regexMatcher.end(i));
                }
                return result;
            }
        } catch (final PatternSyntaxException ex) {
            BytecodeViewer.handleException(ex);
        }
        return new AbstractInsnNode[0][0];
    }

    /**
     * Searches for a regex in the instruction list and returns all groups for
     * all matches.
     *
     * @param regex the regular expression
     * @return a list with all sets of groups with matching instructions
     */
    public List<AbstractInsnNode[][]> findAllGroups(final String regex) {
        final List<AbstractInsnNode[][]> results = new ArrayList<>();
        try {
            final Matcher regexMatcher = Pattern.compile(processRegex(regex),
                    Pattern.MULTILINE).matcher(insnString);
            if (regexMatcher.find()) {
                final AbstractInsnNode[][] result = new AbstractInsnNode[regexMatcher
                        .groupCount() + 1][0];
                for (int i = 0; i <= regexMatcher.groupCount(); i++) {
                    result[i] = makeResult(regexMatcher.start(i),
                            regexMatcher.end(i));
                }
                results.add(result);
            }
        } catch (final PatternSyntaxException ex) {
            BytecodeViewer.handleException(ex);
        }
        return results;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/SearchPanel.java`:

```java
package the.bytecode.club.bytecodeviewer.searching;

import javax.swing.JPanel;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @author WaterWolf
 * @since 09/26/2011
 */
public interface SearchPanel
{
	JPanel getPanel();
	
	void search(ResourceContainer container, String resourceWorkingName, ClassNode node, boolean exact);
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/impl/FieldCallSearch.java`:

```java
package the.bytecode.club.bytecodeviewer.searching.impl;

import java.util.Iterator;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Field call searching
 *
 * @author Konloch
 * @author Water Wolf
 */

public class FieldCallSearch extends MethodCallSearch
{
    @Override
    public void search(ResourceContainer container, String resourceWorkingName, ClassNode node, boolean exact)
    {
        final Iterator<MethodNode> methods = node.methods.iterator();
        
        String searchOwner = mOwner.getText();
        if (searchOwner.isEmpty())
            searchOwner = null;
        
        String searchName = mName.getText();
        if (searchName.isEmpty())
            searchName = null;
        
        String searchDesc = mDesc.getText();
        if (searchDesc.isEmpty())
            searchDesc = null;
        
        while (methods.hasNext())
        {
            final MethodNode method = methods.next();

            final InsnList insnlist = method.instructions;
            for (AbstractInsnNode insnNode : insnlist)
            {
                if (insnNode instanceof FieldInsnNode)
                {
                    final FieldInsnNode min = (FieldInsnNode) insnNode;
                    
                    if (searchName == null && searchOwner == null && searchDesc == null)
                        continue;
                    
                    if (exact)
                    {
                        if (searchName != null && !searchName.equals(min.name))
                            continue;
                        if (searchOwner != null && !searchOwner.equals(min.owner))
                            continue;
                        if (searchDesc != null && !searchDesc.equals(min.desc))
                            continue;
                    }
                    else
                    {
                        if (searchName != null && !min.name.contains(searchName))
                            continue;
                        if (searchOwner != null && !min.owner.contains(searchOwner))
                            continue;
                        if (searchDesc != null && !min.desc.contains(searchDesc))
                            continue;
                    }
    
                    found(container, resourceWorkingName, node, method, insnNode);
                }
            }
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/impl/LDCSearch.java`:

```java
package the.bytecode.club.bytecodeviewer.searching.impl;

import java.awt.*;
import java.util.Iterator;
import javax.swing.JPanel;
import javax.swing.JTextField;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.searching.EnterKeyEvent;
import the.bytecode.club.bytecodeviewer.searching.LDCSearchTreeNodeResult;
import the.bytecode.club.bytecodeviewer.searching.SearchPanel;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJLabel;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * LDC Searching
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/29/2011
 */

public class LDCSearch implements SearchPanel
{
    JTextField searchText;
    JPanel myPanel = null;

    public LDCSearch()
    {
        searchText = new JTextField("");
        searchText.addKeyListener(EnterKeyEvent.SINGLETON);
    }

    @Override
    public JPanel getPanel()
    {
        if (myPanel == null)
        {
            myPanel = new JPanel(new BorderLayout(16, 16));
            myPanel.add(new TranslatedJLabel("Search String: ", TranslatedComponents.SEARCH_STRING), BorderLayout.WEST);
            myPanel.add(searchText, BorderLayout.CENTER);
        }

        return myPanel;
    }

    public void search(final ResourceContainer container, final String resourceWorkingName, final ClassNode node,
                       boolean caseSensitive)
    {
        final Iterator<MethodNode> methods = node.methods.iterator();
        final String srchText = searchText.getText();
        final String srchTextLowerCase = searchText.getText().toLowerCase();
        
        if (srchText.isEmpty())
            return;
        
        while (methods.hasNext())
        {
            final MethodNode method = methods.next();

            final InsnList insnlist = method.instructions;
            for (AbstractInsnNode insnNode : insnlist)
            {
                if (insnNode instanceof LdcInsnNode)
                {
                    final LdcInsnNode ldcObject = ((LdcInsnNode) insnNode);
                    final String ldcString = ldcObject.cst.toString();

                    //TODO re-add this at some point when the search pane is redone
                    boolean exact = false;
                    final boolean exactMatch = exact && ldcString.equals(srchText);
                    final boolean caseInsensitiveMatch = !exact && caseSensitive && ldcString.contains(srchText);
                    final boolean caseSensitiveMatch = !exact && !caseSensitive && ldcString.toLowerCase().contains(srchTextLowerCase);
                    final boolean anyMatch = exactMatch || caseInsensitiveMatch || caseSensitiveMatch;
                    
                    if (anyMatch)
                    {
                        BytecodeViewer.viewer.searchBoxPane.treeRoot.add(new LDCSearchTreeNodeResult(
                                container,
                                resourceWorkingName,
                                node,
                                method,
                                null,
                                ldcString,
                                ldcObject.cst.getClass().getCanonicalName()
                                ));
                    }
                }
            }
        }
        
        final Iterator<FieldNode> fields = node.fields.iterator();
        while (methods.hasNext())
        {
            final FieldNode field = fields.next();
            
            if (field.value instanceof String)
            {
                BytecodeViewer.viewer.resourcePane.treeRoot.add(new LDCSearchTreeNodeResult(container,
                        resourceWorkingName,
                        node,
                        null,
                        field,
                        String.valueOf(field.value),
                        field.value.getClass().getCanonicalName()
                ));
            }
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/impl/MemberWithAnnotationSearch.java`:

```java
package the.bytecode.club.bytecodeviewer.searching.impl;

import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.searching.EnterKeyEvent;
import the.bytecode.club.bytecodeviewer.searching.LDCSearchTreeNodeResult;
import the.bytecode.club.bytecodeviewer.searching.SearchPanel;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJLabel;

import javax.swing.*;
import java.awt.*;
import java.util.List;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Annotation Searching
 *
 * @author GraxCode
 */

public class MemberWithAnnotationSearch implements SearchPanel {
  JTextField annotation;
  JPanel myPanel = null;

  public MemberWithAnnotationSearch() {
    annotation = new JTextField("");
    annotation.addKeyListener(EnterKeyEvent.SINGLETON);
  }

  @Override
  public JPanel getPanel() {
    if (myPanel == null) {
      myPanel = new JPanel(new BorderLayout(16, 16));
      myPanel.add(new TranslatedJLabel("Annotation name: ", TranslatedComponents.ANNOTATION_NAME), BorderLayout.WEST);
      myPanel.add(annotation, BorderLayout.CENTER);
    }

    return myPanel;
  }

  public void search(final ResourceContainer container, final String resourceWorkingName, final ClassNode node, boolean caseSensitive) {
    final String srchText = annotation.getText().trim();

    if (srchText.isEmpty()) return;

    node.fields.stream().filter(fn -> hasAnnotation(srchText, fn.invisibleAnnotations, fn.visibleAnnotations)).forEach(fn -> BytecodeViewer.viewer.searchBoxPane.treeRoot.add(new LDCSearchTreeNodeResult(container, resourceWorkingName, node, null, fn, fn.name + " " + fn.desc, "")));
    node.methods.stream().filter(mn -> hasAnnotation(srchText, mn.invisibleAnnotations, mn.visibleAnnotations)).forEach(mn -> BytecodeViewer.viewer.searchBoxPane.treeRoot.add(new LDCSearchTreeNodeResult(container, resourceWorkingName, node, mn, null, mn.name + mn.desc, "")));
  }

  public static boolean hasAnnotation(String annotation, List<AnnotationNode>... annoLists) {
    if (annoLists == null) return false;
    for (List<AnnotationNode> annos : annoLists) {
      if (annos == null) continue;
      if (annos.stream().anyMatch(ant -> {
        String internalName = Type.getType(ant.desc).getInternalName();
        return internalName.equals(annotation) || internalName.endsWith('/' + annotation) || ant.desc.endsWith('/' + annotation.replace('.', '$'));
        // in case dot is used for inner class annotations
      })) return true;
    }
    return false;
  }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/impl/MethodCallSearch.java`:

```java
package the.bytecode.club.bytecodeviewer.searching.impl;

import eu.bibl.banalysis.asm.desc.OpcodeInfo;

import java.awt.*;
import java.util.Iterator;
import javax.swing.JPanel;
import javax.swing.JTextField;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.searching.EnterKeyEvent;
import the.bytecode.club.bytecodeviewer.searching.LDCSearchTreeNodeResult;
import the.bytecode.club.bytecodeviewer.searching.SearchPanel;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJLabel;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Method call searching
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/29/2011
 */

public class MethodCallSearch implements SearchPanel
{
    JTextField mOwner;
    JTextField mName;
    JTextField mDesc;
    JPanel myPanel = null;

    public MethodCallSearch()
    {
        mOwner = new JTextField("");
        mOwner.addKeyListener(EnterKeyEvent.SINGLETON);
        mName = new JTextField("");
        mName.addKeyListener(EnterKeyEvent.SINGLETON);
        mDesc = new JTextField("");
        mDesc.addKeyListener(EnterKeyEvent.SINGLETON);
    }

    public JPanel getPanel()
    {
        if (myPanel == null)
        {
            myPanel = new JPanel(new BorderLayout(16, 16));

            JPanel left = new JPanel(new GridLayout(3,1));
            JPanel right = new JPanel(new GridLayout(3,1));

            left.add(new TranslatedJLabel("Owner: ", TranslatedComponents.OWNER));
            right.add(mOwner);
            left.add(new TranslatedJLabel("Name: ", TranslatedComponents.NAME));
            right.add(mName);
            left.add(new TranslatedJLabel("Desc: ", TranslatedComponents.DESC));
            right.add(mDesc);
            myPanel.add(left, BorderLayout.WEST);
            myPanel.add(right, BorderLayout.CENTER);
        }

        return myPanel;
    }
    
    @Override
    public void search(ResourceContainer container, String resourceWorkingName, ClassNode node, boolean exact)
    {
        final Iterator<MethodNode> methods = node.methods.iterator();
        
        String searchOwner = mOwner.getText();
        if (searchOwner.isEmpty())
            searchOwner = null;
        
        String searchName = mName.getText();
        if (searchName.isEmpty())
            searchName = null;
        
        String searchDesc = mDesc.getText();
        if (searchDesc.isEmpty())
            searchDesc = null;

        while (methods.hasNext())
        {
            final MethodNode method = methods.next();

            final InsnList insnlist = method.instructions;
            for (AbstractInsnNode insnNode : insnlist)
            {
                if (insnNode instanceof MethodInsnNode)
                {
                    final MethodInsnNode min = (MethodInsnNode) insnNode;
                    
                    if (searchName == null && searchOwner == null && searchDesc == null)
                        continue;
                    
                    if (exact)
                    {
                        if (searchName != null && !searchName.equals(min.name))
                            continue;
                        if (searchOwner != null && !searchOwner.equals(min.owner))
                            continue;
                        if (searchDesc != null && !searchDesc.equals(min.desc))
                            continue;
                    }
                    else
                    {
                        if (searchName != null && !min.name.contains(searchName))
                            continue;
                        if (searchOwner != null && !min.owner.contains(searchOwner))
                            continue;
                        if (searchDesc != null && !min.desc.contains(searchDesc))
                            continue;
                    }
                    
                    found(container, resourceWorkingName, node, method, insnNode);
                }
            }
        }
    }
    
    public void found(final ResourceContainer container, final String resourceWorkingName, final ClassNode node, final MethodNode method, final AbstractInsnNode insnNode)
    {
        BytecodeViewer.viewer.searchBoxPane.treeRoot.add(new LDCSearchTreeNodeResult(
                container,
                resourceWorkingName,
                node,
                method,
                null,
                OpcodeInfo.OPCODES.get(insnNode.getOpcode()).toLowerCase(),
                ""
        ));
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/searching/impl/RegexSearch.java`:

```java
package the.bytecode.club.bytecodeviewer.searching.impl;

import java.awt.*;
import java.util.Iterator;
import java.util.regex.Pattern;
import javax.swing.JPanel;
import javax.swing.JTextField;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.searching.EnterKeyEvent;
import the.bytecode.club.bytecodeviewer.searching.LDCSearchTreeNodeResult;
import the.bytecode.club.bytecodeviewer.searching.RegexInsnFinder;
import the.bytecode.club.bytecodeviewer.searching.SearchPanel;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;
import the.bytecode.club.bytecodeviewer.translation.components.TranslatedJLabel;

import static the.bytecode.club.bytecodeviewer.searching.RegexInsnFinder.processRegex;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Regex Searching
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/29/2011
 */

public class RegexSearch implements SearchPanel
{
    public static JTextField searchText;
    JPanel myPanel = null;

    public RegexSearch()
    {
        searchText = new JTextField("");
        searchText.addKeyListener(EnterKeyEvent.SINGLETON);
    }

    @Override
    public JPanel getPanel()
    {
        if (myPanel == null)
        {
            myPanel = new JPanel(new BorderLayout(16, 16));
            myPanel.add(new TranslatedJLabel("Search Regex: ", TranslatedComponents.SEARCH_REGEX), BorderLayout.WEST);
            myPanel.add(searchText, BorderLayout.CENTER);
        }

        return myPanel;
    }

    @Override
    public void search(final ResourceContainer container, final String resourceWorkingName, final ClassNode node, boolean exact)
    {
        final Iterator<MethodNode> methods = node.methods.iterator();
        final String srchText = searchText.getText();

        if (srchText.isEmpty())
            return;
        
        Pattern pattern = Pattern.compile(processRegex(srchText), Pattern.MULTILINE);
        while (methods.hasNext())
        {
            final MethodNode method = methods.next();

            if (RegexInsnFinder.staticScan(node, method, pattern))
            {
                String desc2 = method.desc;
                try
                {
                    desc2 = Type.getType(method.desc).toString();

                    if (desc2.equals("null"))
                        desc2 = method.desc;
                } catch (java.lang.ArrayIndexOutOfBoundsException ignored) {}
    
                BytecodeViewer.viewer.searchBoxPane.treeRoot.add(new LDCSearchTreeNodeResult(
                        container,
                        resourceWorkingName,
                        node,
                        method,
                        null,
                        node.name + "." + method.name + desc2,
                        ""
                ));
            }
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/Language.java`:

```java
package the.bytecode.club.bytecodeviewer.translation;

import com.google.gson.reflect.TypeToken;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import org.apache.commons.collections4.map.LinkedMap;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.api.BCV;
import the.bytecode.club.bytecodeviewer.resources.IconResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * All of the supported languages
 *
 * TODO: Hindi, Bengali, Korean, Thai & Javanese need fonts to be supplied for them to show.
 *  The default font should be saved so it can be restored for latin-character based languages
 *
 * @author Konloch
 * @since 6/28/2021
 */
public enum Language
{
	ENGLISH("/translations/english.json", "English", "English", "en"),
	ARABIC("/translations/arabic.json", "عربى", "English", "ar"),
	CROATIAN("/translations/croatian.json", "hrvatski", "English", "hr"),
	CZECH("/translations/czech.json", "čeština", "English", "cs"),
	BULGARIAN("/translations/bulgarian.json", "български", "English", "bg"),
	DANISH("/translations/danish.json", "dansk", "English", "da"),
	ESTONIAN("/translations/estonian.json", "Eesti", "English", "et"),
	FARSI("/translations/farsi.json", "فارسی ", "English", "fa"),
	FINNISH("/translations/finnish.json", "Suomen Kieli", "English", "fi"),
	FRENCH("/translations/french.json", "Français", "English", "fr"),
	GERMAN("/translations/german.json", "Deutsch", "German", "de"),
	GEORGIAN("/translations/georgian.json", "ქართული ენა", "English", "ka"),
	GREEK("/translations/greek.json", "ελληνικά", "English", "el"),
	HAUSA("/translations/hausa.json", "Hausa", "English", "ha"),
	HEBREW("/translations/hebrew.json", "עִבְרִית\u200E", "English", "iw", "he"),
	//HINDI("/translations/hindi.json", "हिंदी", "English", "hi"),
	//BENGALI("/translations/bengali.json", "বাংলা", "English", "bn"),
	HUNGARIAN("/translations/hungarian.json", "Magyar Nyelv", "English", "hu"),
	INDONESIAN("/translations/indonesian.json", "bahasa Indonesia", "English", "id"),
	ITALIAN("/translations/italian.json", "Italiano", "English", "it"),
	JAPANESE("/translations/japanese.json", "日本語", "English", "ja"),
	LATIVAN("/translations/lativan.json", "Lativan", "English", "lv"),
	LITHUANIAN("/translations/lithuanian.json", "Lietuvių", "English", "lt"),
	//JAVANESE("/translations/javanese.json", "ꦧꦱꦗꦮ", "English", "jw", "jv"),
	//KOREAN("/translations/korean.json", "Korean", "English", "ko"),
	MALAY("/translations/malay.json", "Bahasa Melayu", "English", "ms"),
	MANDARIN("/translations/mandarin.json", "普通话", "Mandarin", "zh-CN", "zh_cn", "zh"),
	NEDERLANDS("/translations/nederlands.json", "Nederlands", "English", "nl"), //dutch
	NORWEGIAN("/translations/norwegian.json", "Norsk", "English", "no"),
	POLISH("/translations/polish.json", "Polski", "English", "pl"),
	PORTUGUESE("/translations/portuguese.json", "Português", "English", "pt"),
	ROMANIAN("/translations/romanian.json", "Română", "English", "ro"),
	RUSSIAN("/translations/russian.json", "русский", "English", "ru"),
	SLOVAK("/translations/slovak.json", "Slovensky", "English", "sk"),
	SLOVENIAN("/translations/slovenian.json", "Slovenščina", "English", "sl"),
	SPANISH("/translations/spanish.json", "Español", "English", "es"),
	SERBIAN("/translations/serbian.json", "српски језик", "English", "sr"),
	SWAHILI("/translations/swahili.json", "Kiswahili", "English", "sw"),
	SWEDISH("/translations/swedish.json", "svenska", "English", "sv"),
	//THAI("/translations/thai.json", "ภาษาไทย", "English", "th"),
	TURKISH("/translations/turkish.json", "Türkçe", "English", "tr"),
	UKRAINIAN("/translations/ukrainian.json", "украї́нська мо́ва", "English", "uk"),
	VIETNAMESE("/translations/vietnamese.json", "Tiếng Việt", "English", "vi"),
	;
	
	private static final Map<String, Language> languageCodeLookup;
	
	static
	{
		languageCodeLookup = new LinkedHashMap<>();
		for(Language l : values())
			l.languageCode.forEach((langCode)->
					languageCodeLookup.put(langCode, l));
	}
	
	private final String resourcePath;
	private final String readableName;
	private final String htmlIdentifier;
	private final Set<String> languageCode;
	private Map<String, String> translationMap;
	
	Language(String resourcePath, String readableName, String htmlIdentifier, String... languageCodes)
	{
		this.resourcePath = resourcePath;
		this.readableName = readableName;
		this.htmlIdentifier = htmlIdentifier.toLowerCase();
		this.languageCode = new LinkedHashSet<>(Arrays.asList(languageCodes));
	}
	
	public void setLanguageTranslations() throws IOException
	{
		printMissingLanguageKeys();
		
		Map<String, String> translationMap = getTranslation();
		
		for(TranslatedComponents translatedComponents : TranslatedComponents.values())
		{
			TranslatedComponentReference text = translatedComponents.getTranslatedComponentReference();
			
			//skip translating if the language config is missing the translation key
			if(!translationMap.containsKey(text.key))
			{
				BCV.logE(true, resourcePath + " -> " + text.key + " - Missing Translation Key");
				continue;
			}
			
			//update translation text value
			text.value = translationMap.get(text.key);
			
			//translate constant strings
			try {
				TranslatedStrings str = TranslatedStrings.valueOf(text.key);
				str.setText(text.value);
			} catch (IllegalArgumentException ignored) { }
			
			//check if translation key has been assigned to a component,
			//on fail print an error alerting the devs
			if(translatedComponents.getTranslatedComponentReference().runOnUpdate.isEmpty())
					//&& TranslatedStrings.nameSet.contains(translation.name()))
			{
				BCV.logE(true, "TranslatedComponents:" + translatedComponents.name() + " is missing component attachment, skipping...");
				continue;
			}
			
			//trigger translation event
			translatedComponents.getTranslatedComponentReference().translate();
		}
	}
	
	public Map<String, String> getTranslation() throws IOException
	{
		if(translationMap == null)
		{
			translationMap = BytecodeViewer.gson.fromJson(
					IconResources.loadResourceAsString(resourcePath),
					new TypeToken<HashMap<String, String>>() {}.getType());
		}
		
		return translationMap;
	}
	
	//TODO
	// When adding new Translation Components:
	// 1) start by adding the strings into the english.json
	// 2) run this function to get the keys and add them into the Translation.java enum
	// 3) replace the swing component (MainViewerGUI) with a translated component
	//    and reference the correct translation key
	// 4) add the translation key to the rest of the translation files
	public void printMissingLanguageKeys() throws IOException
	{
		if(this != ENGLISH)
			return;
		
		LinkedMap<String, String> translationMap = BytecodeViewer.gson.fromJson(
				IconResources.loadResourceAsString(resourcePath),
				new TypeToken<LinkedMap<String, String>>(){}.getType());
		
		Set<String> existingKeys = new HashSet<>();
		for(TranslatedComponents t : TranslatedComponents.values())
			existingKeys.add(t.name());
		
		for(String key : translationMap.keySet())
			if(!existingKeys.contains(key))
				BCV.logE(true, key + ",");
	}
	
	public String getResourcePath()
	{
		return resourcePath;
	}
	
	public Set<String> getLanguageCode()
	{
		return languageCode;
	}
	
	public String getReadableName()
	{
		return readableName;
	}
	
	public String getHTMLPath(String identifier)
	{
		return "translations/html/" + identifier + "." + htmlIdentifier +  ".html";
	}
	
	public static Map<String, Language> getLanguageCodeLookup()
	{
		return languageCodeLookup;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/TranslatedComponentReference.java`:

```java
package the.bytecode.club.bytecodeviewer.translation;

import java.util.ArrayList;
import java.util.List;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * This class contains the runnable events that update the components for translation
 *
 * @author Konloch
 * @since 6/28/2021
 */
public class TranslatedComponentReference
{
	public String key;
	public String value;
	public List<Runnable> runOnUpdate = new ArrayList<>();
	
	public void translate()
	{
		runOnUpdate.forEach(Runnable::run);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/TranslatedComponents.java`:

```java
package the.bytecode.club.bytecodeviewer.translation;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Translation keys for components (updates the component text on language change).
 *
 * You only need to add a translation key if it is going to be used by a component.
 * If your translation is not tied to a component (Console, Dialogs) use TranslatedStrings
 *
 * @author Konloch
 * @since 6/28/2021
 */

public enum TranslatedComponents
{
	FILE,
	ADD,
	NEW_WORKSPACE,
	RELOAD_RESOURCES,
	RUN,
	OPEN,
	COMPILE,
	SAVE,
	SAVE_AS,
	SAVE_AS_RUNNABLE_JAR,
	SAVE_AS_ZIP,
	SAVE_AS_DEX,
	SAVE_AS_APK,
	DECOMPILE_SAVE_OPENED_CLASSES,
	DECOMPILE_SAVE_ALL_CLASSES,
	RECENT_FILES,
	ABOUT,
	EXIT,
	
	VIEW,
	VISUAL_SETTINGS,
	LANGUAGE,
	WINDOW_THEME,
	SYSTEM_THEME,
	DARK_THEME,
	LIGHT_THEME,
	ONE_DARK_THEME,
	SOLARIZED_DARK_THEME,
	SOLARIZED_LIGHT_THEME,
	HIGH_CONTRAST_DARK_THEME,
	HIGH_CONTRAST_LIGHT_THEME,
	DARK,
	ONE_DARK,
	SOLARIZED_DARK,
	SOLARIZED_LIGHT,
	HIGH_CONTRAST_DARK,
	HIGH_CONTRAST_LIGHT,
	
	TEXT_AREA_THEME,
	DEFAULT_RECOMMENDED_LIGHT,
	THEME_MATCH,
	DARK_ALT,
	DEFAULT_ALT,
	ECLIPSE,
	INTELLIJ,
	VISUAL_STUDIO,
	DRUID_DARK,
	MONOKAI_DARK,
	
	FONT_SIZE,
	SHOW_TAB_FILE_IN_TAB_TITLE,
	SIMPLIFY_NAME_IN_TAB_TITLE,
	SYNCHRONIZED_VIEWING,
	SHOW_CLASS_METHODS,
	
	PANE_1,
	PANE_2,
	PANE_3,
	NONE,
	EDITABLE,
	JAVA,
	BYTECODE,
	HEXCODE,
	ASM_TEXTIFY,
	
	SETTINGS,
	COMPILE_ON_SAVE,
	COMPILE_ON_REFRESH,
	REFRESH_ON_VIEW_CHANGE,
	DECODE_APK_RESOURCES,
	APK_CONVERSION,
	APK_CONVERSION_DECODING,
	UPDATE_CHECK,
	DELETE_UNKNOWN_LIBS,
	FORCE_PURE_ASCII_AS_TEXT,
	SET_PYTHON_27_EXECUTABLE,
	SET_PYTHON_30_EXECUTABLE,
	SET_JRE_RT_LIBRARY,
	SET_OPTIONAL_LIBRARY_FOLDER,
	SET_JAVAC_EXECUTABLE,
	BYTECODE_DECOMPILER,
	DEBUG_HELPERS,
	APPEND_BRACKETS_TO_LABEL,
	
	PLUGINS,
	OPEN_PLUGIN,
	RECENT_PLUGINS,
	NEW_JAVA_PLUGIN,
	NEW_JAVASCRIPT_PLUGIN,
	CODE_SEQUENCE_DIAGRAM,
	MALICIOUS_CODE_SCANNER,
	SHOW_MAIN_METHODS,
	SHOW_ALL_STRINGS,
	REPLACE_STRINGS,
	STACK_FRAMES_REMOVER,
	ZKM_STRING_DECRYPTER,
	ALLATORI_STRING_DECRYPTER,
	ZSTRINGARRAY_DECRYPTER,
	
	
	HIDE_BRIDGE_METHODS,
	HIDE_SYNTHETIC_CLASS_MEMBERS,
	DECOMPILE_INNER_CLASSES,
	COLLAPSE_14_CLASS_REFERENCES,
	DECOMPILE_ASSERTIONS,
	HIDE_EMPTY_SUPER_INVOCATION,
	HIDE_EMPTY_DEFAULT_CONSTRUCTOR,
	DECOMPILE_GENERIC_SIGNATURES,
	ASSUME_RETURN_NOT_THROWING_EXCEPTIONS,
	DECOMPILE_ENUMERATIONS,
	REMOVE_GETCLASS_INVOCATION,
	INTERPRET_INT_1_AS_BOOLEAN_TRUE,
	ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE,
	CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT,
	RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO,
	REMOVE_EMPTY_EXCEPTION_RANGES,
	DEINLINE_FINALLY_STRUCTURES,
	ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS,
	RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS,
	
	DECODE_ENUM_SWITCH,
	SUGARENUMS,
	DECODE_STRING_SWITCH,
	ARRAYITER,
	COLLECTIONITER,
	INNER_CLASSES,
	REMOVE_BOILER_PLATE,
	REMOVE_INNER_CLASS_SYNTHETICS,
	DECODE_LAMBDAS,
	LIFT__CONSTRUCTOR_INIT,
	REMOVE_DEAD_METHODS,
	REMOVE_BAD_GENERICS,
	SUGAR_ASSERTS,
	SUGAR_BOXING,
	SHOW_VERSION,
	DECODE_FINALLY,
	TIDY_MONITORS,
	LENIENT,
	DUMP_CLASSPATH,
	COMMENTS,
	FORCE_TOP_SORT,
	FORCE_TOP_SORT_AGGRESS,
	FORCE_EXCEPTION_PRUNE,
	STRING_BUFFER,
	STRING_BUILDER,
	SILENT,
	RECOVER,
	
	OVERRIDE,
	SHOW_INFERRABLE,
	AEXAGG,
	FORCE_COND_PROPAGATE,
	HIDE_UTF,
	HIDE_LONG_STRINGS,
	COMMENT_MONITORS,
	ALLOW_CORRECTING,
	LABELLED_BLOCKS,
	J14CLASSOBJ,
	HIDE_LANG_IMPORTS,
	RECOVER_TYPE_CLASH,
	RECOVER_TYPE__HINTS,
	FORCE_RETURNING_IFS,
	FOR_LOOP_AGG_CAPTURE,
	
	ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS,
	EXCLUDE_NESTED_TYPES,
	SHOW_DEBUG_LINE_NUMBERS,
	INCLUDE_LINE_NUMBERS_IN_BYTECODE,
	INCLUDE_ERROR_DIAGNOSTICS,
	SHOW_SYNTHETIC_MEMBERS,
	SIMPLIFY_MEMBER_REFERENCES,
	MERGE_VARIABLES,
	FORCE_EXPLICIT_TYPE_ARGUMENTS,
	FORCE_EXPLICIT_IMPORTS,
	FLATTEN_SWITCH_BLOCKS,
	RETAIN_POINTLESS_SWITCHES,
	RETAIN_REDUNDANT_CASTS,
	UNICODE_OUTPUT_ENABLED,
	
	VIEW_ANDROID_PERMISSIONS,
	VIEW_MANIFEST,
	CHANGE_CLASSFILE_VERSIONS,
	
	DEX_TO_JAR,
	ENJARIFY,
	PROCYON_SETTINGS,
	CFR_SETTINGS,
	FERNFLOWER_SETTINGS,
	PROCYON,
	CFR,
	FERNFLOWER,
	KRAKATAU,
	JDGUI,
	JADX,
	SMALI_DEX,
	SMALI,
	DISASSEMBLER,
	ERROR,
	SUGGESTED_FIX_DECOMPILER_ERROR,
	SUGGESTED_FIX_COMPILER_ERROR,
	PROCYON_DECOMPILER,
	CFR_DECOMPILER,
	FERNFLOWER_DECOMPILER,
	JADX_DECOMPILER,
	JD_DECOMPILER,
	BYTECODE_DISASSEMBLER,
	FILES,
	QUICK_FILE_SEARCH_NO_FILE_EXTENSION,
	WORK_SPACE,
	EXACT,
	DRAG_CLASS_JAR,
	SEARCH,
	SEARCH_STRING,
	SEARCH_FROM,
	SEARCH_REGEX,
	OWNER,
	NAME,
	DESC,
	RESULTS,
	REFRESH,
	MIN_SDK_VERSION,
	ANNOTATION_NAME,
	MATCH_CASE,
	EXACT_PATH,
	PRINT_LINE_NUMBERS,
	;
	
	private final TranslatedComponentReference componentReference;
	
	TranslatedComponents()
	{
		this.componentReference = new TranslatedComponentReference();
		this.componentReference.key = name();
	}
	
	public TranslatedComponentReference getTranslatedComponentReference()
	{
		return componentReference;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/TranslatedStrings.java`:

```java
package the.bytecode.club.bytecodeviewer.translation;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import the.bytecode.club.bytecodeviewer.api.BCV;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Translation keys for constant strings (does not change the component text on language change).
 *
 * You need to add your translation key here if it is not tied to any specific component (Console, Dialogs)
 *
 * @author Konloch
 * @since 7/6/2021
 */

public enum TranslatedStrings
{
	PRODUCT("BCV"),
	PRODUCTNAME("BytecodeViewer"),
	PRODUCT_NAME("Bytecode Viewer"),
	PRODUCT_H_NAME("Bytecode-Viewer"),
	WEBSITE("https://bytecodeviewer.com"),
	TBC("https://the.bytecode.club"),
	
	EDITABLE,
	JAVA,
	PROCYON,
	CFR,
	FERNFLOWER,
	KRAKATAU,
	JDGUI,
	JADX,
	SMALI,
	SMALI_DEX,
	HEXCODE,
	BYTECODE,
	ASM_TEXTIFY,
	ERROR,
	DISASSEMBLER,
	RESULTS,
	SEARCH,
	
	
	OPEN_UNSTYLED,
	QUICK_OPEN,
	DELETE,
	NEW,
	EXPAND,
	COLLAPSE,
	RELOAD_RESOURCES_TITLE,
	RELOAD_RESOURCES_CONFIRM,
	SELECT_FILE_TITLE,
	SELECT_FILE_DESCRIPTION,
	SELECT_EXTERNAL_PLUGIN_TITLE,
	SELECT_EXTERNAL_PLUGIN_DESCRIPTION,
	FOREIGN_LIBRARY_WARNING,
	RESET_TITLE,
	RESET_CONFIRM,
	EXIT_TITLE,
	EXIT_CONFIRM,
	ABOUT_TITLE,
	PLUGIN_CONSOLE_TITLE,
	CLOSE_ALL_BUT_THIS,
	CLOSE_TAB,
	PLEASE_SEND_THIS_ERROR_LOG_TO,
	PLEASE_SEND_RESOURCES,
	ONE_PLUGIN_AT_A_TIME,
	ILLEGAL_ACCESS_ERROR,
	
	
	YES,
	NO,
	ERROR2,
	PROCESS2,
	EXIT_VALUE_IS,
	ERROR_COMPILING_CLASS,
	COMPILER_TIP,
	JAVA_COMPILE_FAILED,
	SELECT_LIBRARY_FOLDER,
	SELECT_JAVA_RT,
	SELECT_JAVA,
	SELECT_JAVAC,
	SELECT_JAVA_TOOLS,
	SELECT_PYTHON_2,
	SELECT_PYTHON_3,
	PYTHON_2_EXECUTABLE,
	PYTHON_3_EXECUTABLE,
	YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH,
	YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH,
	YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A,
	YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B,
	JAVA_EXECUTABLE,
	JAVAC_EXECUTABLE,
	JAVA_TOOLS_JAR,
	JAVA_RT_JAR,
	OPTIONAL_LIBRARY_FOLDER,
	QUICK_FILE_SEARCH_NO_FILE_EXTENSION,
	SUGGESTED_FIX_DECOMPILER_ERROR,
	SUGGESTED_FIX_COMPILER_ERROR,
	FIRST_OPEN_A_RESOURCE,
	FIRST_OPEN_A_CLASS,
	FIRST_VIEW_A_CLASS,
	SUGGESTED_FIX_NO_DECOMPILER_WARNING,
	DRAG_CLASS_JAR,
	;
	
	public static final Set<String> nameSet = new HashSet<>();
	
	static
	{
		for(TranslatedStrings s : values())
			nameSet.add(s.name());
	}
	
	private final String TEXT_ERROR = "FAILED_TO_LOAD";
	private String text = TEXT_ERROR;
	
	TranslatedStrings(String text)
	{
		this.text = text;
	}
	
	TranslatedStrings()
	{
		//load english translations by default
		try
		{
			setText(Language.ENGLISH.getTranslation().get(name()));
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
	}
	
	public void setText(String text)
	{
		if(text == null)
		{
			BCV.logE(true, "TranslatedStrings:"+name() + " - Missing Translation");
			text = TEXT_ERROR;
		}
		
		//TODO this should be tokenized against the TranslatedStrings enum
		text = text.replace("{PRODUCTNAME}", PRODUCTNAME.toString())
				.replace("{PRODUCT_NAME}", PRODUCT_NAME.toString())
				.replace("{PRODUCT-NAME}", PRODUCT_H_NAME.toString())
				.replace("{PRODUCT}", PRODUCT.toString())
				.replace("{TBC}", TBC.toString())
				.replace("{WEBSITE}", WEBSITE.toString())
		;
		
		this.text = text;
	}
	
	@Override
	public String toString()
	{
		return text;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedDefaultMutableTreeNode.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/7/2021
 */
public class TranslatedDefaultMutableTreeNode extends DefaultMutableTreeNode
{
	private DefaultTreeModel tree;
	
	public TranslatedDefaultMutableTreeNode(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
				{
					setUserObject(componentReference.value);
					if(tree != null)
						tree.nodeChanged(this);
				}
			});
			componentReference.translate();
		}
	}
	
	public void setTree(DefaultTreeModel tree)
	{
		this.tree = tree;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedJButton.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.JButton;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/7/2021
 */
public class TranslatedJButton extends JButton
{
	public TranslatedJButton(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setText(componentReference.value);
			});
			componentReference.translate();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedJCheckBox.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.JCheckBox;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/30/2021
 */
public class TranslatedJCheckBox extends JCheckBox
{
	public TranslatedJCheckBox(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setText(componentReference.value);
			});
			componentReference.translate();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedJCheckBoxMenuItem.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.JCheckBoxMenuItem;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/28/2021
 */
public class TranslatedJCheckBoxMenuItem extends JCheckBoxMenuItem
{
	public TranslatedJCheckBoxMenuItem(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setText(componentReference.value);
			});
			componentReference.translate();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedJLabel.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.JLabel;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/7/2021
 */
public class TranslatedJLabel extends JLabel
{
	public TranslatedJLabel(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setText(componentReference.value);
			});
			componentReference.translate();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedJMenu.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.JMenu;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/28/2021
 */
public class TranslatedJMenu extends JMenu
{
	public TranslatedJMenu(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setText(componentReference.value);
			});
			componentReference.translate();
		}
	}

	@Override
	public boolean isEnabled()
	{
		return super.isEnabled() && getMenuComponentCount() > 0;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedJMenuItem.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.JMenuItem;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/28/2021
 */
public class TranslatedJMenuItem extends JMenuItem
{
	public TranslatedJMenuItem(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setText(componentReference.value);
			});
			componentReference.translate();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedJRadioButtonMenuItem.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.JRadioButtonMenuItem;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/28/2021
 */
public class TranslatedJRadioButtonMenuItem extends JRadioButtonMenuItem
{
	public TranslatedJRadioButtonMenuItem(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setText(componentReference.value);
			});
			componentReference.translate();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedJTextField.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import javax.swing.JTextField;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/8/2021
 */
public class TranslatedJTextField extends JTextField
{
	public TranslatedJTextField(String text, TranslatedComponents translatedComponents)
	{
		super(text);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setText(componentReference.value);
			});
			componentReference.translate();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/translation/components/TranslatedVisibleComponent.java`:

```java
package the.bytecode.club.bytecodeviewer.translation.components;

import the.bytecode.club.bytecodeviewer.gui.components.VisibleComponent;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponentReference;
import the.bytecode.club.bytecodeviewer.translation.TranslatedComponents;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/7/2021
 */
public class TranslatedVisibleComponent extends VisibleComponent
{
	public TranslatedVisibleComponent(String title, TranslatedComponents translatedComponents)
	{
		super(title);
		
		if(translatedComponents != null)
		{
			TranslatedComponentReference componentReference = translatedComponents.getTranslatedComponentReference();
			componentReference.runOnUpdate.add(()->
			{
				if(componentReference.value != null && !componentReference.value.isEmpty())
					setTitle(componentReference.value);
			});
			componentReference.translate();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/APKTool.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.File;
import org.apache.commons.io.FileUtils;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;

import static the.bytecode.club.bytecodeviewer.Constants.fs;
import static the.bytecode.club.bytecodeviewer.Constants.tempDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 */
public class APKTool {

    public static synchronized void decodeResources(File input, File output, ResourceContainer container) {
        try {
            File dir = new File(tempDirectory + fs + MiscUtils.randomString(32) + fs + "Decoded Resources");
            dir.mkdirs();

            File tempAPKPath = new File(tempDirectory + fs + MiscUtils.randomString(12));
            tempAPKPath.mkdirs();
            brut.apktool.Main.main(new String[]{"r", "--frame-path", tempAPKPath.getAbsolutePath(), "d",
                    input.getAbsolutePath(), "-o", dir.getAbsolutePath(), "-f"});

            File zip = new File(tempDirectory + fs + MiscUtils.randomString(12) + ".zip");
            ZipUtils.zipFolderAPKTool(dir.getAbsolutePath(), zip.getAbsolutePath());

            if (zip.exists())
                zip.renameTo(output);

            container.APKToolContents = dir;
            tempAPKPath.delete();
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }

    public static synchronized void buildAPK(File input, File output, ResourceContainer container) {
        String temp = tempDirectory + fs;
        File tempDir = new File(temp + fs + MiscUtils.getRandomizedName() + fs);
        tempDir.mkdirs();


        File tempAPKPath = new File(tempDirectory + fs + MiscUtils.randomString(12));
        tempAPKPath.mkdirs();

        try {
            File smaliFolder = new File(container.APKToolContents.getAbsolutePath() + fs + "smali");
            FileUtils.deleteDirectory(smaliFolder);


            //save entire jar as smali files
            System.out.println("Building!");
            brut.apktool.Main.main(new String[]{"b", container.APKToolContents.getAbsolutePath(), "--frame-path",
                    tempAPKPath.getAbsolutePath(), "-o", output.getAbsolutePath()});
            tempAPKPath.delete();
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/BootCheck.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.CommandLineInput;
import the.bytecode.club.bytecodeviewer.bootloader.Boot;
import the.bytecode.club.bytecodeviewer.bootloader.loader.ILoader;
import the.bytecode.club.bytecodeviewer.bootloader.resource.external.EmptyExternalResource;
import the.bytecode.club.bytecodeviewer.bootloader.resource.external.ExternalResource;

import static the.bytecode.club.bytecodeviewer.Constants.nl;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Loads the libraries on boot. If booting failed for some reason, this kicks in as a fail safe.
 *
 * This broke with maven so now only FatJar builds will work.
 *
 * To get this system working again for smaller binaries/automatic updating libraries maven support will need to be added.
 *
 * @author Konloch
 * @author Bibl (don't ban me pls)
 * @since 6/21/2021
 */
public class BootCheck implements Runnable
{
	@Override
	public void run()
	{
		long start = System.currentTimeMillis();
		
		//7 second failsafe
		while (System.currentTimeMillis() - start < 7000)
		{
			try {
				Thread.sleep(100);
			} catch (InterruptedException ignored) { }
		}
		
		//if it's failed to boot and it's not downloading attempt to load the libraries
		failSafeLoadLibraries();
	}
	
	@SuppressWarnings({"rawtypes", "unchecked"})
	public void failSafeLoadLibraries()
	{
		if (!Boot.completedboot && !Boot.downloading)
		{
			File libsDir = Boot.libsDir();
			File[] listFiles = libsDir.listFiles();
			
			//first boot failed to download libraries
			if (listFiles == null || listFiles.length <= 0)
			{
				BytecodeViewer.showMessage(
						"Github is loading extremely slow, BCV needs to download libraries from github in order"
								+ nl + "to work, please try adjusting your network settings or manually downloading these libraries"
								+ nl + "if this error persists.");
				return;
			}
			
			Boot.setState("Bytecode Viewer Boot Screen (OFFLINE MODE) - Unable to connect to github, force booting...");
			System.out.println("Unable to connect to github, force booting...");
			
			List<String> libsFileList = new ArrayList<>();
			for (File f : listFiles)
				libsFileList.add(f.getAbsolutePath());
			
			ILoader<?> loader = Boot.findLoader();
			for (String s : libsFileList)
			{
				if (s.endsWith(".jar"))
				{
					File f = new File(s);
					if (f.exists())
					{
						Boot.setState("Bytecode Viewer Boot Screen (OFFLINE MODE) - Force Loading Library " + f.getName());
						System.out.println("Force loading library " + f.getName());
						
						try
						{
							ExternalResource res = new EmptyExternalResource<>(f.toURI().toURL());
							loader.bind(res);
							System.out.println("Successfully loaded " + f.getName());
						}
						catch (Exception e)
						{
							e.printStackTrace();
							f.delete();
							JOptionPane.showMessageDialog(null,
									"Error, Library " + f.getName() + " is corrupt, please restart to re-download it.",
									"Error", JOptionPane.ERROR_MESSAGE);
						}
					}
				}
			}
			
			Boot.checkEnjarify();
			Boot.checkKrakatau();
			
			Boot.globalstop = false;
			Boot.hide();
			
			int CLI = CommandLineInput.parseCommandLine(BytecodeViewer.launchArgs);
			
			
			if (CLI == CommandLineInput.GUI)
				BytecodeViewer.boot(false);
			else {
				BytecodeViewer.boot(true);
				CommandLineInput.executeCommandLine(BytecodeViewer.launchArgs);
			}
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/ClassFileUtils.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Objects;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/6/2021
 */
public class ClassFileUtils
{
	/**
	 * Grab the byte array from the loaded Class object by getting the resource from the classloader
	 */
	public static byte[] getClassFileBytes(Class<?> clazz) throws IOException
	{
		try (InputStream is = clazz.getResourceAsStream("/" + clazz.getName().replace('.', '/') + ".class");
		     ByteArrayOutputStream baos = new ByteArrayOutputStream())
		{
			int r;
			byte[] buffer = new byte[8192];
			while ((r = Objects.requireNonNull(is).read(buffer)) >= 0)
				baos.write(buffer, 0, r);
			return baos.toByteArray();
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/Dex2Jar.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import com.googlecode.d2j.dex.Dex2jar;
import java.io.File;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple wrapper for Dex2Jar.
 *
 * @author Konloch
 */

public class Dex2Jar {

    /**
     * Converts a .apk or .dex to .jar
     *
     * @param input  the input .apk or .dex file
     * @param output the output .jar file
     */
    public static synchronized void dex2Jar(File input, File output) {
        try {
            Dex2jar d2Jar = Dex2jar.from(input);
            d2Jar.to(output.toPath());
        } catch (com.googlecode.d2j.DexException e) {
            e.printStackTrace();
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }

    /**
     * Converts a .jar to .dex
     *
     * @param input  the input .jar file
     * @param output the output .dex file
     */
    public static synchronized void saveAsDex(File input, File output) {
        saveAsDex(input, output, true);
    }

    public static synchronized void saveAsDex(File input, File output, boolean delete) {
        try {
            com.googlecode.dex2jar.tools.Jar2Dex.main(input.getAbsolutePath(),
                    "-o", output.getAbsolutePath(),
                    "-s", BytecodeViewer.viewer.getMinSdkVersion() + "");
            if (delete)
                input.delete();
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/DialogUtils.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.File;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.gui.components.FileChooser;
import the.bytecode.club.bytecodeviewer.gui.components.MultipleChoiceDialog;
import the.bytecode.club.bytecodeviewer.translation.TranslatedStrings;

import static the.bytecode.club.bytecodeviewer.gui.components.FileChooser.EVERYTHING;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 7/1/2021
 */
public class DialogUtils
{
	/**
	 * Asks if the user would like to overwrite the file
	 */
	public static boolean canOverwriteFile(String filePath)
	{
		return canOverwriteFile(new File(filePath));
	}
	
	/**
	 * Asks if the user would like to overwrite the file
	 */
	public static boolean canOverwriteFile(File file) {
		if (file.exists())
		{
			MultipleChoiceDialog dialog = new MultipleChoiceDialog("Bytecode Viewer - Overwrite File",
					"Are you sure you wish to overwrite this existing file?",
					new String[]{TranslatedStrings.YES.toString(), TranslatedStrings.NO.toString()});
			
			if (dialog.promptChoice() == 0) {
				file.delete();
				
				return true;
			} else {
				return false;
			}
		}
		
		return true;
	}
	
	/**
	 * Prompts a File Chooser dilogue
	 */
	public static File fileChooser(String title, String description, String... extensions)
	{
		return fileChooser(title, description, null, extensions);
	}
	
	/**
	 * Prompts a File Chooser dilogue
	 */
	public static File fileChooser(String title, String description, FileFilter filter, String... extensions)
	{
		return fileChooser(title, description, Configuration.getLastOpenDirectory(), filter,
				Configuration::setLastOpenDirectory, extensions);
	}
	
	/**
	 * Prompts a File Chooser dilogue
	 */
	public static File fileChooser(String title, String description, File directory, FileFilter filter, OnOpenEvent onOpen, String... extensions)
	{
		Set<String> extensionSet = new HashSet<>(Arrays.asList(extensions));
		
		final JFileChooser fc = new FileChooser(true,
				directory,
				title,
				description,
				extensions);
		
		if(filter != null)
			fc.addChoosableFileFilter(filter);
		else
			fc.addChoosableFileFilter(new FileFilter()
			{
				@Override
				public boolean accept(File f)
				{
					if (f.isDirectory())
						return true;
					
					if(extensions[0].equals(EVERYTHING))
						return true;
					
					return extensionSet.contains(MiscUtils.extension(f.getAbsolutePath()));
				}
				
				@Override
				public String getDescription() {
					return description;
				}
			});
		
		int returnVal = fc.showOpenDialog(BytecodeViewer.viewer);
		if (returnVal == JFileChooser.APPROVE_OPTION)
			try {
				File file = fc.getSelectedFile();
				onOpen.onOpen(file);
				return file;
			} catch (Exception e1) {
				BytecodeViewer.handleException(e1);
			}
		
		return null;
	}
	
	public interface OnOpenEvent
	{
		void onOpen(File fileSelected);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/EncodeUtils.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang3.StringUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Encoding Convert Utils
 *
 * @author hupan
 * @date 2019-11-19 14:29
 */
public class EncodeUtils {

    public static String stringToUnicode(String s) {
        try {
            StringBuilder out = new StringBuilder();
            byte[] bytes = s.getBytes("unicode");

            for (int i = 0; i < bytes.length - 1; i += 2) {
                out.append("\\u");
                String str = Integer.toHexString(bytes[i + 1] & 0xff);
                for (int j = str.length(); j < 2; j++) {
                    out.append("0");
                }
                String str1 = Integer.toHexString(bytes[i] & 0xff);
                out.append(str1);
                out.append(str);
            }
            return out.toString();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String unicodeToString(String str) {

        Pattern pattern = Pattern.compile("(\\\\u(\\p{XDigit}{4}))");
        Matcher matcher = pattern.matcher(str);
        char ch;
        while (matcher.find()) {
            String group = matcher.group(2);
            ch = (char) Integer.parseInt(group, 16);
            String group1 = matcher.group(1);
            str = str.replace(group1, ch + "");
        }
        return str;
    }

    public static String convertStringToUTF8(String s) {
        if (s == null || StringUtils.EMPTY.equals(s)) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        try {
            char c;
            for (int i = 0; i < s.length(); i++) {
                c = s.charAt(i);
                if (c <= 255) {
                    sb.append(c);
                } else {
                    byte[] b;
                    b = Character.toString(c).getBytes(StandardCharsets.UTF_8);
                    for (int value : b) {
                        int k = value;
                        k = k < 0 ? k + 256 : k;
                        sb.append(Integer.toHexString(k).toUpperCase());
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return sb.toString();
    }

    public static String convertUTF8ToString(String s) {
        if (s == null || StringUtils.EMPTY.equals(s)) {
            return null;
        }
        s = s.toUpperCase();
        int total = s.length() / 2;
        int pos = 0;
        byte[] buffer = new byte[total];
        for (int i = 0; i < total; i++) {
            int start = i * 2;
            buffer[i] = (byte) Integer.parseInt(s.substring(start, start + 2), 16);
            pos++;
        }

        return new String(buffer, 0, pos, StandardCharsets.UTF_8);
    }

}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/Enjarify.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.File;
import java.util.concurrent.atomic.AtomicBoolean;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.resources.ExternalResources;

import static the.bytecode.club.bytecodeviewer.Constants.enjarifyWorkingDirectory;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A simple wrapper for Enjarify.
 *
 * @author Konloch
 */

public class Enjarify {

    /**
     * Converts a .apk or .dex to .jar
     *
     * @param input  the input .apk or .dex file
     * @param output the output .jar file
     */
    public static synchronized void apk2Jar(File input, File output) {
        if(!ExternalResources.getSingleton().hasSetPython3Command())
            return;

        try {
            ProcessBuilder pb = new ProcessBuilder(
                    Configuration.python3,
                    "-O",
                    "-m",
                    "enjarify.main",
                    input.getAbsolutePath(),
                    "-o",
                    output.getAbsolutePath(),
                    "-f"
            );

            pb.directory(new File(enjarifyWorkingDirectory));
            Process process = pb.start();
            BytecodeViewer.createdProcesses.add(process);
    
            AtomicBoolean holdThread = new AtomicBoolean(true);
            
            //wait for the process to finish then signal when done
            new Thread(()->{
                try {
                    process.waitFor();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    holdThread.set(false);
                }
            }, "Enjarify Wait Thread").start();
            
            //if python3 fails to close but it was able to process the APK
            new Thread(()->{
                while(holdThread.get())
                {
                    if(output.length() > 0)
                        holdThread.set(false);
                    
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException ignored) { }
                }
            }, "Enjarify Fail Safe Thread").start();
            
            //hold thread while enjarify is processing
            while(holdThread.get())
            {
                Thread.sleep(100);
            }
            
            //kill the python3 process if it's still alive
            if(process.isAlive())
                process.destroy();
            
            MiscUtils.printProcess(process);

        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/FileDrop.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.Reader;
import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.border.Border;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * This class makes it easy to drag and drop files from the operating system to
 * a Java program. Any <tt>Component</tt> can be dropped onto, but only
 * <tt>JComponent</tt>s will indicate the drop event with a changed
 * border.
 *
 * To use this class, construct a new <tt>FileDrop</tt> by passing it the target
 * component and a <tt>Listener</tt> to receive notification when file(s) have
 * been dropped. Here is an example:
 *
 *      JPanel myPanel = new JPanel();
 *      new FileDrop( myPanel, new FileDrop.Listener()
 *      {   public void filesDropped( File[] files )
 *          {
 *              // handle file drop
 *              ...
 *          }   // end filesDropped
 *      }); // end FileDrop.Listener
 *
 * You can specify the border that will appear when files are being dragged by
 * calling the constructor with a <tt>Border</tt>. Only
 * <tt>JComponent</tt>s will show any indication with a border.
 *
 * You can turn on some debugging features by passing a <tt>PrintStream</tt>
 * object (such as <tt>System.out</tt>) into the full constructor. A
 * <tt>null</tt> value will result in no extra debugging information being
 * output.
 * 
 * I'm releasing this code into the Public Domain. Enjoy.
 *
 * <em>Original author: Robert Harder, rharder@usa.net</em>
 *
 * 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support added.
 *
 * @author Robert Harder
 * @author rharder@users.sf.net
 * @version 1.0.1
 */
@SuppressWarnings({"rawtypes", "unused", "unchecked"})
public class FileDrop {
    private transient Border normalBorder;
    private transient DropTargetListener dropListener;

    /**
     * Discover if the running JVM is modern enough to have drag and drop.
     */
    private static Boolean supportsDnD;

    // Default border color
    private static final Color defaultBorderColor = new Color(0f,
            0f, 1f, 0.25f);

    /**
     * Constructs a {@link FileDrop} with a default light-blue border and, if
     * <var>c</var> is a {@link Container}, recursively sets all
     * elements contained within as drop targets, though only the top level
     * container will change borders.
     *
     * @param c        Component on which files will be dropped.
     * @param listener Listens for <tt>filesDropped</tt>.
     * @since 1.0
     */
    public FileDrop(final Component c, final Listener listener) {
        this(null, // Logging stream
                c, // Drop target
                BorderFactory.createMatteBorder(2, 2, 2, 2,
                        defaultBorderColor), // Drag border
                true, // Recursive
                listener);
    } // end constructor

    /**
     * Constructor with a default border and the option to recursively set drop
     * targets. If your component is a <tt>Container</tt>, then each of
     * its children components will also listen for drops, though only the
     * parent will change borders.
     *
     * @param c         Component on which files will be dropped.
     * @param recursive Recursively set children as drop targets.
     * @param listener  Listens for <tt>filesDropped</tt>.
     * @since 1.0
     */
    public FileDrop(final Component c, final boolean recursive,
                    final Listener listener) {
        this(null, // Logging stream
                c, // Drop target
                BorderFactory.createMatteBorder(2, 2, 2, 2,
                        defaultBorderColor), // Drag border
                recursive, // Recursive
                listener);
    } // end constructor

    /**
     * Constructor with a default border and debugging optionally turned on.
     * With Debugging turned on, more status messages will be displayed to
     * <tt>out</tt>. A common way to use this constructor is with
     * <tt>System.out</tt> or <tt>System.err</tt>. A <tt>null</tt> value for the
     * parameter <tt>out</tt> will result in no debugging output.
     *
     * @param out      PrintStream to record debugging info or null for no debugging.
     * @param c        Component on which files will be dropped.
     * @param listener Listens for <tt>filesDropped</tt>.
     * @since 1.0
     */
    public FileDrop(final PrintStream out, final Component c,
                    final Listener listener) {
        this(out, // Logging stream
                c, // Drop target
                BorderFactory.createMatteBorder(2, 2, 2, 2,
                        defaultBorderColor), false, // Recursive
                listener);
    } // end constructor

    /**
     * Constructor with a default border, debugging optionally turned on and the
     * option to recursively set drop targets. If your component is a
     * <tt>Container</tt>, then each of its children components will
     * also listen for drops, though only the parent will change borders. With
     * Debugging turned on, more status messages will be displayed to
     * <tt>out</tt>. A common way to use this constructor is with
     * <tt>System.out</tt> or <tt>System.err</tt>. A <tt>null</tt> value for the
     * parameter <tt>out</tt> will result in no debugging output.
     *
     * @param out       PrintStream to record debugging info or null for no debugging.
     * @param c         Component on which files will be dropped.
     * @param recursive Recursively set children as drop targets.
     * @param listener  Listens for <tt>filesDropped</tt>.
     * @since 1.0
     */
    public FileDrop(final PrintStream out, final Component c,
                    final boolean recursive, final Listener listener) {
        this(out, // Logging stream
                c, // Drop target
                BorderFactory.createMatteBorder(2, 2, 2, 2,
                        defaultBorderColor), // Drag border
                recursive, // Recursive
                listener);
    } // end constructor

    /**
     * Constructor with a specified border
     *
     * @param c          Component on which files will be dropped.
     * @param dragBorder Border to use on <tt>JComponent</tt> when dragging occurs.
     * @param listener   Listens for <tt>filesDropped</tt>.
     * @since 1.0
     */
    public FileDrop(final Component c,
                    final Border dragBorder, final Listener listener) {
        this(null, // Logging stream
                c, // Drop target
                dragBorder, // Drag border
                false, // Recursive
                listener);
    } // end constructor

    /**
     * Constructor with a specified border and the option to recursively set
     * drop targets. If your component is a <tt>Container</tt>, then
     * each of its children components will also listen for drops, though only
     * the parent will change borders.
     *
     * @param c          Component on which files will be dropped.
     * @param dragBorder Border to use on <tt>JComponent</tt> when dragging occurs.
     * @param recursive  Recursively set children as drop targets.
     * @param listener   Listens for <tt>filesDropped</tt>.
     * @since 1.0
     */
    public FileDrop(final Component c,
                    final Border dragBorder,
                    final boolean recursive, final Listener listener) {
        this(null, c, dragBorder, recursive, listener);
    } // end constructor

    /**
     * Constructor with a specified border and debugging optionally turned on.
     * With Debugging turned on, more status messages will be displayed to
     * <tt>out</tt>. A common way to use this constructor is with
     * <tt>System.out</tt> or <tt>System.err</tt>. A <tt>null</tt> value for the
     * parameter <tt>out</tt> will result in no debugging output.
     *
     * @param out        PrintStream to record debugging info or null for no debugging.
     * @param c          Component on which files will be dropped.
     * @param dragBorder Border to use on <tt>JComponent</tt> when dragging occurs.
     * @param listener   Listens for <tt>filesDropped</tt>.
     * @since 1.0
     */
    public FileDrop(final PrintStream out, final Component c,
                    final Border dragBorder, final Listener listener) {
        this(out, // Logging stream
                c, // Drop target
                dragBorder, // Drag border
                false, // Recursive
                listener);
    } // end constructor

    /**
     * Full constructor with a specified border and debugging optionally turned
     * on. With Debugging turned on, more status messages will be displayed to
     * <tt>out</tt>. A common way to use this constructor is with
     * <tt>System.out</tt> or <tt>System.err</tt>. A <tt>null</tt> value for the
     * parameter <tt>out</tt> will result in no debugging output.
     *
     * @param out        PrintStream to record debugging info or null for no debugging.
     * @param c          Component on which files will be dropped.
     * @param dragBorder Border to use on <tt>JComponent</tt> when dragging occurs.
     * @param recursive  Recursively set children as drop targets.
     * @param listener   Listens for <tt>filesDropped</tt>.
     * @since 1.0
     */
    public FileDrop(final PrintStream out, final Component c,
                    final Border dragBorder,
                    final boolean recursive, final Listener listener) {

        if (supportsDnD()) { // Make a drop listener
            dropListener = new DropTargetListener() {
                @Override
                public void dragEnter(final DropTargetDragEvent evt) {
                    log(out, "FileDrop: dragEnter event.");

                    // Is this an acceptable drag event?
                    if (isDragOk(out, evt)) {
                        // If it's a Swing component, set its border
                        if (c instanceof JComponent) {
                            final JComponent jc = (JComponent) c;
                            normalBorder = jc.getBorder();
                            log(out, "FileDrop: normal border saved.");
                            jc.setBorder(dragBorder);
                            log(out, "FileDrop: drag border set.");
                        } // end if: JComponent

                        // Acknowledge that it's okay to enter
                        // evt.acceptDrag(
                        // DnDConstants.ACTION_COPY_OR_MOVE );
                        evt.acceptDrag(DnDConstants.ACTION_COPY);
                        log(out, "FileDrop: event accepted.");
                    } // end if: drag ok
                    else { // Reject the drag event
                        evt.rejectDrag();
                        log(out, "FileDrop: event rejected.");
                    } // end else: drag not ok
                } // end dragEnter

                @Override
                public void dragOver(final DropTargetDragEvent evt) { // This
                    // is
                    // called
                    // continually
                    // as
                    // long
                    // as
                    // the
                    // mouse
                    // is
                    // over
                    // the
                    // drag
                    // target.
                } // end dragOver

                @Override
                public void drop(final DropTargetDropEvent evt) {
                    log(out, "FileDrop: drop event.");
                    try { // Get whatever was dropped
                        final Transferable tr = evt
                                .getTransferable();

                        // Is it a file list?
                        if (tr.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
                            // Say we'll take it.
                            // evt.acceptDrop (
                            // DnDConstants.ACTION_COPY_OR_MOVE );
                            evt.acceptDrop(DnDConstants.ACTION_COPY);
                            log(out, "FileDrop: file list accepted.");

                            // Get a useful list
                            final java.util.List fileList = (java.util.List) tr
                                    .getTransferData(DataFlavor.javaFileListFlavor);
                            final java.util.Iterator iterator = fileList
                                    .iterator();

                            // Convert list to array
                            final File[] filesTemp = new File[fileList
                                    .size()];
                            fileList.toArray(filesTemp);

                            // Alert listener to drop.
                            if (listener != null) {
                                listener.filesDropped(filesTemp);
                            }

                            // Mark that drop is completed.
                            evt.getDropTargetContext().dropComplete(true);
                            log(out, "FileDrop: drop complete.");
                        } // end if: file list
                        else // this section will check for a reader flavor.
                        {
                            // Thanks, Nathan!
                            // BEGIN 2007-09-12 Nathan Blomquist -- Linux
                            // (KDE/Gnome) support added.
                            final DataFlavor[] flavors = tr
                                    .getTransferDataFlavors();
                            boolean handled = false;
                            for (DataFlavor flavor : flavors) {
                                if (flavor.isRepresentationClassReader()) {
                                    // Say we'll take it.
                                    // evt.acceptDrop (
                                    // DnDConstants.ACTION_COPY_OR_MOVE
                                    // );
                                    evt.acceptDrop(DnDConstants.ACTION_COPY);
                                    log(out, "FileDrop: reader accepted.");

                                    final Reader reader = flavor
                                            .getReaderForText(tr);

                                    final BufferedReader br = new BufferedReader(
                                            reader);

                                    if (listener != null) {
                                        listener.filesDropped(createFileArray(
                                                br, out));
                                    }

                                    // Mark that drop is completed.
                                    evt.getDropTargetContext().dropComplete(
                                            true);
                                    log(out, "FileDrop: drop complete.");
                                    handled = true;
                                    break;
                                }
                            }
                            if (!handled) {
                                log(out,
                                        "FileDrop: not a file list or reader - abort.");
                                evt.rejectDrop();
                            }
                            // END 2007-09-12 Nathan Blomquist -- Linux
                            // (KDE/Gnome) support added.
                        } // end else: not a file list
                    } // end try
                    catch (final IOException io) {
                        log(out, "FileDrop: IOException - abort:");
                        BytecodeViewer.handleException(io);
                        evt.rejectDrop();
                    } // end catch IOException
                    catch (final UnsupportedFlavorException ufe) {
                        log(out,
                                "FileDrop: UnsupportedFlavorException - abort:");
                        BytecodeViewer.handleException(
                                ufe);
                        evt.rejectDrop();
                    } // end catch: UnsupportedFlavorException
                    finally {
                        // If it's a Swing component, reset its border
                        if (c instanceof JComponent) {
                            final JComponent jc = (JComponent) c;
                            jc.setBorder(normalBorder);
                            log(out, "FileDrop: normal border restored.");
                        } // end if: JComponent
                    } // end finally
                } // end drop

                @Override
                public void dragExit(final DropTargetEvent evt) {
                    log(out, "FileDrop: dragExit event.");
                    // If it's a Swing component, reset its border
                    if (c instanceof JComponent) {
                        final JComponent jc = (JComponent) c;
                        jc.setBorder(normalBorder);
                        log(out, "FileDrop: normal border restored.");
                    } // end if: JComponent
                } // end dragExit

                @Override
                public void dropActionChanged(
                        final DropTargetDragEvent evt) {
                    log(out, "FileDrop: dropActionChanged event.");
                    // Is this an acceptable drag event?
                    if (isDragOk(out, evt)) { // evt.acceptDrag(
                        // DnDConstants.ACTION_COPY_OR_MOVE
                        // );
                        evt.acceptDrag(DnDConstants.ACTION_COPY);
                        log(out, "FileDrop: event accepted.");
                    } // end if: drag ok
                    else {
                        evt.rejectDrag();
                        log(out, "FileDrop: event rejected.");
                    } // end else: drag not ok
                } // end dropActionChanged
            }; // end DropTargetListener

            // Make the component (and possibly children) drop targets
            makeDropTarget(out, c, recursive);
        } // end if: supports dnd
        else {
            log(out, "FileDrop: Drag and drop is not supported with this JVM");
        } // end else: does not support DnD
    } // end constructor

    private static boolean supportsDnD() { // Static Boolean
        if (supportsDnD == null) {
            boolean support;
            try {
                final Class arbitraryDndClass = Class
                        .forName("java.awt.dnd.DnDConstants");
                support = true;
            } // end try
            catch (final Throwable t) {
                support = false;
            } // end catch
            supportsDnD = support;
        } // end if: first time through
        return supportsDnD;
    } // end supportsDnD

    // BEGIN 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support added.
    private static final String ZERO_CHAR_STRING = "" + (char) 0;

    private static File[] createFileArray(final BufferedReader bReader,
                                          final PrintStream out) {
        try {
            final java.util.List list = new java.util.ArrayList();
            java.lang.String line;
            while ((line = bReader.readLine()) != null) {
                try {
                    // kde seems to append a 0 char to the end of the reader
                    if (ZERO_CHAR_STRING.equals(line)) {
                        continue;
                    }

                    final File file = new File(
                            new java.net.URI(line));
                    list.add(file);
                } catch (final Exception ex) {
                    log(out, "Error with " + line + ": " + ex.getMessage());
                }
            }

            return (File[]) list.toArray(new File[0]);
        } catch (final IOException ex) {
            log(out, "FileDrop: IOException");
        }
        return new File[0];
    }

    // END 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support added.

    private void makeDropTarget(final PrintStream out,
                                final Component c, final boolean recursive) {
        // Make drop target
        final DropTarget dt = new DropTarget();
        try {
            dt.addDropTargetListener(dropListener);
        } // end try
        catch (final java.util.TooManyListenersException e) {
            BytecodeViewer.handleException(e);
            log(out,
                    "FileDrop: Drop will not work due to previous error. Do you have another listener attached?");
        } // end catch

        // Listen for hierarchy changes and remove the drop target when the
        // parent gets cleared out.
        // end hierarchyChanged
        c.addHierarchyListener(evt -> {
            log(out, "FileDrop: Hierarchy changed.");
            final Component parent = c.getParent();
            if (parent == null) {
                c.setDropTarget(null);
                log(out, "FileDrop: Drop target cleared from component.");
            } // end if: null parent
            else {
                new DropTarget(c, dropListener);
                log(out, "FileDrop: Drop target added to component.");
            } // end else: parent not null
        }); // end hierarchy listener
        if (c.getParent() != null) {
            new DropTarget(c, dropListener);
        }

        if (recursive && (c instanceof Container)) {
            // Get the container
            final Container cont = (Container) c;

            // Get its components
            final Component[] comps = cont.getComponents();

            // Set its components as listeners also
            for (Component comp : comps) {
                makeDropTarget(out, comp, true);
            }
        } // end if: recursively set components as listener
    } // end dropListener

    /**
     * Determine if the dragged data is a file list.
     */
    private boolean isDragOk(final PrintStream out,
                             final DropTargetDragEvent evt) {
        boolean ok = false;

        // Get data flavors being dragged
        final DataFlavor[] flavors = evt
                .getCurrentDataFlavors();

        // See if any of the flavors are a file list
        int i = 0;
        while (!ok && i < flavors.length) {
            // BEGIN 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support
            // added.
            // Is the flavor a file list?
            final DataFlavor curFlavor = flavors[i];
            if (curFlavor
                    .equals(DataFlavor.javaFileListFlavor)
                    || curFlavor.isRepresentationClassReader()) {
                ok = true;
            }
            // END 2007-09-12 Nathan Blomquist -- Linux (KDE/Gnome) support
            // added.
            i++;
        } // end while: through flavors

        // If logging is enabled, show data flavors
        if (out != null) {
            if (flavors.length == 0) {
                log(out, "FileDrop: no data flavors.");
            }
            for (i = 0; i < flavors.length; i++) {
                log(out, flavors[i].toString());
            }
        } // end if: logging enabled

        return ok;
    } // end isDragOk

    /**
     * Outputs <tt>message</tt> to <tt>out</tt> if it's not null.
     */
    private static void log(final PrintStream out, final String message) { // Log
        // message
        // if
        // requested
        if (out != null) {
            out.println(message);
        }
    } // end log

    /**
     * Removes the drag-and-drop hooks from the component and optionally from
     * the all children. You should call this if you add and remove components
     * after you've set up the drag-and-drop. This will recursively unregister
     * all components contained within <var>c</var> if <var>c</var> is a
     * {@link Container}.
     *
     * @param c The component to unregister as a drop target
     * @since 1.0
     */
    public static boolean remove(final Component c) {
        return remove(null, c, true);
    } // end remove

    /**
     * Removes the drag-and-drop hooks from the component and optionally from
     * the all children. You should call this if you add and remove components
     * after you've set up the drag-and-drop.
     *
     * @param out       Optional {@link PrintStream} for logging drag and drop
     *                  messages
     * @param c         The component to unregister
     * @param recursive Recursively unregister components within a container
     * @since 1.0
     */
    public static boolean remove(final PrintStream out,
                                 final Component c, final boolean recursive) { // Make sure
        // we
        // support
        // 
        if (supportsDnD()) {
            log(out, "FileDrop: Removing drag-and-drop hooks.");
            c.setDropTarget(null);
            if (recursive && (c instanceof Container)) {
                final Component[] comps = ((Container) c)
                        .getComponents();
                for (Component comp : comps) {
                    remove(out, comp, true);
                }
                return true;
            } // end if: recursive
            else
                return false;
        } // end if: supports DnD
        else
            return false;
    } // end remove

    /* ******** I N N E R I N T E R F A C E L I S T E N E R ******** */

    /**
     * Implement this inner interface to listen for when files are dropped. For
     * example your class declaration may begin like this: <code><pre>
     *      public class MyClass implements FileDrop.Listener
     *      ...
     *      public void filesDropped( File[] files )
     *      {
     *          ...
     *      }   // end filesDropped
     *      ...
     * </pre></code>
     *
     * @since 1.1
     */
    public interface Listener {

        /**
         * This method is called when files have been successfully dropped.
         *
         * @param files An array of <tt>File</tt>s that were dropped.
         * @since 1.0
         */
        void filesDropped(File[] files);

    } // end inner-interface Listener

    /* ******** I N N E R C L A S S ******** */

    /**
     * This is the event that is passed to the
     * FileDropListener#filesDropped filesDropped(...) method in your
     * FileDropListener when files are dropped onto a registered drop
     * target.
     * <p>
     * <p>
     * I'm releasing this code into the Public Domain. Enjoy.
     * </p>
     *
     * @author Robert Harder
     * @author rob@iharder.net
     * @version 1.2
     */
    public static class Event extends java.util.EventObject {

        private static final long serialVersionUID = -2175361562828864378L;
        private final File[] files;

        /**
         * Constructs an {@link Event} with the array of files that were dropped
         * and the {@link FileDrop} that initiated the event.
         *
         * @param files The array of files that were dropped
         * @param source The event source
         * @since 1.1
         */
        public Event(final File[] files, final Object source) {
            super(source);
            this.files = files;
        } // end constructor

        /**
         * Returns an array of files that were dropped on a registered drop
         * target.
         *
         * @return array of files that were dropped
         * @since 1.1
         */
        public File[] getFiles() {
            return files;
        } // end getFiles

    } // end inner class Event

    /* ******** I N N E R C L A S S ******** */

    /**
     * At last an easy way to encapsulate your custom objects for dragging and
     * dropping in your Java programs! When you need to create a
     * {@link Transferable} object, use this class to wrap
     * your object. For example:
     * <p>
     * <pre>
     * <code>
     *      ...
     *      MyCoolClass myObj = new MyCoolClass();
     *      Transferable xfer = new TransferableObject( myObj );
     *      ...
     * </code>
     * </pre>
     * <p>
     * Or if you need to know when the data was actually dropped, like when
     * you're moving data out of a list, say, you can use the
     * {@link TransferableObject.Fetcher} inner class to return your object Just
     * in Time. For example:
     * <p>
     * <pre>
     * <code>
     *      ...
     *      final MyCoolClass myObj = new MyCoolClass();
     *
     *      TransferableObject.Fetcher fetcher = new TransferableObject.Fetcher()
     *      {   public Object getObject(){ return myObj; }
     *      }; // end fetcher
     *
     *      Transferable xfer = new TransferableObject( fetcher );
     *      ...
     * </code>
     * </pre>
     * <p>
     * The {@link DataFlavor} associated with
     * {@link TransferableObject} has the representation class
     * <tt>net.iharder.TransferableObject.class</tt> and MIME type
     * <tt>application/x-net.iharder.TransferableObject</tt>. This data
     * flavor is accessible via the static {@link #DATA_FLAVOR} property.
     * <p>
     * <p>
     * <p>
     * I'm releasing this code into the Public Domain. Enjoy.
     * </p>
     *
     * @author Robert Harder
     * @author rob@iharder.net
     * @version 1.2
     */
    public static class TransferableObject implements
            Transferable {
        /**
         * The MIME type for {@link #DATA_FLAVOR} is
         * <tt>application/x-net.iharder.TransferableObject</tt>.
         *
         * @since 1.1
         */
        public final static String MIME_TYPE = "application/x-net.iharder.dnd.TransferableObject";

        /**
         * The default {@link DataFlavor} for
         * {@link TransferableObject} has the representation class
         * <tt>net.iharder.TransferableObject.class</tt> and the MIME type
         * <tt>application/x-net.iharder.TransferableObject</tt>.
         *
         * @since 1.1
         */
        public final static DataFlavor DATA_FLAVOR = new DataFlavor(
                FileDrop.TransferableObject.class, MIME_TYPE);

        private Fetcher fetcher;
        private Object data;

        private DataFlavor customFlavor;

        /**
         * Creates a new {@link TransferableObject} that wraps <var>data</var>.
         * Along with the {@link #DATA_FLAVOR} associated with this class, this
         * creates a custom data flavor with a representation class determined
         * from <code>data.getClass()</code> and the MIME type
         * <tt>application/x-net.iharder.TransferableObject</tt>.
         *
         * @param data The data to transfer
         * @since 1.1
         */
        public TransferableObject(final Object data) {
            this.data = data;
            this.customFlavor = new DataFlavor(
                    data.getClass(), MIME_TYPE);
        } // end constructor

        /**
         * Creates a new {@link TransferableObject} that will return the object
         * that is returned by <var>fetcher</var>. No custom data flavor is set
         * other than the default {@link #DATA_FLAVOR}.
         *
         * @param fetcher The {@link Fetcher} that will return the data object
         * @see Fetcher
         * @since 1.1
         */
        public TransferableObject(final Fetcher fetcher) {
            this.fetcher = fetcher;
        } // end constructor

        /**
         * Creates a new {@link TransferableObject} that will return the object
         * that is returned by <var>fetcher</var>. Along with the
         * {@link #DATA_FLAVOR} associated with this class, this creates a
         * custom data flavor with a representation class <var>dataClass</var>
         * and the MIME type
         * <tt>application/x-net.iharder.TransferableObject</tt>.
         *
         * @param dataClass The {@link java.lang.Class} to use in the custom data
         *                  flavor
         * @param fetcher   The {@link Fetcher} that will return the data object
         * @see Fetcher
         * @since 1.1
         */
        public TransferableObject(final Class dataClass, final Fetcher fetcher) {
            this.fetcher = fetcher;
            this.customFlavor = new DataFlavor(dataClass,
                    MIME_TYPE);
        } // end constructor

        /**
         * Returns the custom {@link DataFlavor}
         * associated with the encapsulated object or <tt>null</tt> if the
         * {@link Fetcher} constructor was used without passing a
         * {@link java.lang.Class}.
         *
         * @return The custom data flavor for the encapsulated object
         * @since 1.1
         */
        public DataFlavor getCustomDataFlavor() {
            return customFlavor;
        } // end getCustomDataFlavor

        /* ******** T R A N S F E R A B L E M E T H O D S ******** */

        /**
         * Returns a two- or three-element array containing first the custom
         * data flavor, if one was created in the constructors, second the
         * default {@link #DATA_FLAVOR} associated with
         * {@link TransferableObject}, and third the
         * DataFlavor.stringFlavor.
         *
         * @return An array of supported data flavors
         * @since 1.1
         */
        @Override
        public DataFlavor[] getTransferDataFlavors() {
            if (customFlavor != null)
                return new DataFlavor[]{customFlavor,
                        DATA_FLAVOR,
                        DataFlavor.stringFlavor}; // end
                // flavors
                // array
            else
                return new DataFlavor[]{DATA_FLAVOR,
                        DataFlavor.stringFlavor}; // end
            // flavors
            // array
        } // end getTransferDataFlavors

        /**
         * Returns the data encapsulated in this {@link TransferableObject}. If
         * the {@link Fetcher} constructor was used, then this is when the
         * {@link Fetcher#getObject getObject()} method will be called. If the
         * requested data flavor is not supported, then the
         * {@link Fetcher#getObject getObject()} method will not be called.
         *
         * @param flavor The data flavor for the data to return
         * @return The dropped data
         * @since 1.1
         */
        @Override
        public Object getTransferData(
                final DataFlavor flavor)
                throws UnsupportedFlavorException {
            // Native object
            if (flavor.equals(DATA_FLAVOR))
                return fetcher == null ? data : fetcher.getObject();

            // String
            if (flavor.equals(DataFlavor.stringFlavor))
                return fetcher == null ? data.toString() : fetcher.getObject()
                        .toString();

            // We can't do anything else
            throw new UnsupportedFlavorException(flavor);
        } // end getTransferData

        /**
         * Returns <tt>true</tt> if <var>flavor</var> is one of the supported
         * flavors. Flavors are supported using the <code>equals(...)</code>
         * method.
         *
         * @param flavor The data flavor to check
         * @return Whether or not the flavor is supported
         * @since 1.1
         */
        @Override
        public boolean isDataFlavorSupported(
                final DataFlavor flavor) {
            // Native object
            if (flavor.equals(DATA_FLAVOR))
                return true;

            // String
            return flavor.equals(DataFlavor.stringFlavor);

            // We can't do anything else
        } // end isDataFlavorSupported

        /* ******** I N N E R I N T E R F A C E F E T C H E R ******** */

        /**
         * Instead of passing your data directly to the
         * {@link TransferableObject} constructor, you may want to know exactly
         * when your data was received in case you need to remove it from its
         * source (or do anyting else to it). When the {@link #getTransferData
         * getTransferData(...)} method is called on the
         * {@link TransferableObject}, the {@link Fetcher}'s {@link #getObject
         * getObject()} method will be called.
         *
         * @author Robert Harder
         * @version 1.1
         * @copyright 2001
         * @since 1.1
         */
        public interface Fetcher {
            /**
             * Return the object being encapsulated in the
             * {@link TransferableObject}.
             *
             * @return The dropped object
             * @since 1.1
             */
            Object getObject();
        } // end inner interface Fetcher

    } // end class TransferableObject

} // end class FileDrop

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/JRTExtractor.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

// Copyright 2017 Robert Grosse

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//    http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import java.net.URI;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class JRTExtractor {
    public static void extractRT(String path) throws Throwable {
        FileSystem fs = FileSystems.getFileSystem(URI.create("jrt:/"));

        try (ZipOutputStream zipStream = new ZipOutputStream(Files.newOutputStream(Paths.get(path)));
			Stream<Path> stream =  Files.walk(fs.getPath("/"))) {
            stream.forEach(p -> {
                if (!Files.isRegularFile(p)) {
                    return;
                }

                try {
                    byte[] data = Files.readAllBytes(p);

                    List<String> list = new ArrayList<>();
                    p.iterator().forEachRemaining(p2 -> list.add(p2.toString()));
                    assert list.remove(0).equals("modules");

                    if (!list.get(list.size() - 1).equals("module-info.class")) {
                        list.remove(0);
                    }

                    list.remove(0);
                    String outPath = String.join("/", list);

                    if (!outPath.endsWith("module-info.class")) {
                        ZipEntry ze = new ZipEntry(outPath);
                        zipStream.putNextEntry(ze);
                        zipStream.write(data);
                    }
                } catch (Throwable t) {
                    throw new RuntimeException(t);
                }
            });
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/JTextAreaUtils.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.awt.Color;
import javax.swing.JTextArea;
import javax.swing.text.DefaultHighlighter;
import javax.swing.text.Document;
import javax.swing.text.Highlighter;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * This allows functionality to main the same between JTextArea and RSyntaxTextArea text panels
 *
 * @author Konloch
 * @since 6/25/2021
 */
public class JTextAreaUtils
{
	private static final DefaultHighlighter.DefaultHighlightPainter painter = new DefaultHighlighter.DefaultHighlightPainter(new Color(255, 62, 150));
	
	/**
	 * This was really interesting to write.
	 *
	 * @author Konloch
	 */
	public static void search(JTextArea textArea, String search, boolean forwardSearchDirection, boolean caseSensitiveSearch)
	{
		try
		{
			if (search.isEmpty())
			{
				highlight(textArea, "", caseSensitiveSearch);
				return;
			}
			
			int startLine = textArea.getDocument().getDefaultRootElement()
					.getElementIndex(textArea.getCaretPosition()) + 1;
			
			int currentLine = 1;
			boolean canSearch = false;
			String[] test = textArea.getText().split("\r?\n");
			
			int lastGoodLine = -1;
			int firstPos = -1;
			boolean found = false;
			
			if (forwardSearchDirection)
			{
				for (String s : test)
				{
					if (!caseSensitiveSearch)
					{
						s = s.toLowerCase();
						search = search.toLowerCase();
					}
					
					if (currentLine == startLine)
					{
						canSearch = true;
					}
					else if (s.contains(search))
					{
						if (canSearch)
						{
							textArea.setCaretPosition(textArea.getDocument()
									.getDefaultRootElement()
									.getElement(currentLine - 1)
									.getStartOffset());
							
							canSearch = false;
							found = true;
						}
						
						if (firstPos == -1)
							firstPos = currentLine;
					}
					
					currentLine++;
				}
				
				if (!found && firstPos != -1)
				{
					textArea.setCaretPosition(textArea.getDocument()
							.getDefaultRootElement().getElement(firstPos - 1)
							.getStartOffset());
				}
			}
			else
			{
				canSearch = true;
				for (String s : test)
				{
					if (!caseSensitiveSearch)
					{
						s = s.toLowerCase();
						search = search.toLowerCase();
					}
					
					if (s.contains(search))
					{
						if (lastGoodLine != -1 && canSearch)
							textArea.setCaretPosition(textArea.getDocument()
									.getDefaultRootElement()
									.getElement(lastGoodLine - 1)
									.getStartOffset());
						
						lastGoodLine = currentLine;
						
						if (currentLine >= startLine)
							canSearch = false;
					}
					
					currentLine++;
				}
				
				if (lastGoodLine != -1
						&& textArea.getDocument().getDefaultRootElement()
						.getElementIndex(textArea.getCaretPosition()) + 1 == startLine)
				{
					textArea.setCaretPosition(textArea.getDocument()
							.getDefaultRootElement()
							.getElement(lastGoodLine - 1).getStartOffset());
				}
			}
			
			highlight(textArea, search, caseSensitiveSearch);
		}
		catch (Exception e)
		{
			BytecodeViewer.handleException(e);
		}
	}
	
	public static void highlight(JTextArea textArea,String pattern, boolean caseSensitiveSearch)
	{
		if (pattern.isEmpty())
		{
			textArea.getHighlighter().removeAllHighlights();
			return;
		}
		
		try
		{
			Highlighter highlighter = textArea.getHighlighter();
			highlighter.removeAllHighlights();
			Document doc = textArea.getDocument();
			String text = doc.getText(0, doc.getLength());
			int pos = 0;
			
			if (!caseSensitiveSearch)
			{
				pattern = pattern.toLowerCase();
				text = text.toLowerCase();
			}
			
			// Search for pattern
			while ((pos = text.indexOf(pattern, pos)) >= 0)
			{
				// Create highlighter using private painter and apply around
				// pattern
				highlighter.addHighlight(pos, pos + pattern.length(), painter);
				pos += pattern.length();
			}
		}
		catch (Exception e)
		{
			BytecodeViewer.handleException(e);
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/JarUtils.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.jar.JarOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;
import me.konloch.kontainer.io.DiskWriter;
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.apache.commons.io.FilenameUtils;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.api.ASMUtil;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;

import static the.bytecode.club.bytecodeviewer.Constants.fs;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Loading and saving jars
 *
 * NOTE: This is in the process of being replaced with the Import & Export API
 *
 * @author Konloch
 * @author WaterWolf
 * @since 09/26/2011
 */

@Deprecated
public class JarUtils
{
    public static final Object LOCK = new Object();
    
    /**
     * Loads the classes and resources from the input jar file
     *
     * @param jarFile the input jar file
     * @throws IOException
     */
    public static void importArchiveA(final File jarFile) throws IOException
    {
        ResourceContainer container = new ResourceContainer(jarFile);
        Map<String, byte[]> files = new LinkedHashMap<>();

        try (FileInputStream fis = new FileInputStream(jarFile);
             ZipInputStream jis = new ZipInputStream(fis)) {
            ZipEntry entry;
            while ((entry = jis.getNextEntry()) != null) {
                try {
                    final String name = entry.getName();
                    final byte[] bytes = MiscUtils.getBytes(jis);
                    if (!name.endsWith(".class")) {
                        if (!entry.isDirectory())
                            files.put(name, bytes);
                    } else {
                        if (MiscUtils.getFileHeaderMagicNumber(bytes).equalsIgnoreCase("cafebabe")) {
                            try {
                                final ClassNode cn = getNode(bytes);
                                container.resourceClasses.put(FilenameUtils.removeExtension(name), cn);
                            } catch (Exception e) {
                                System.err.println("Skipping: " + name);
                                e.printStackTrace();
                            }
                        } else {
                            if (!entry.isDirectory())
                                files.put(name, bytes);
                            //System.out.println(jarFile + ">" + name + ": Header does not start with CAFEBABE, ignoring.");
                        }
                    }

                } catch (java.io.EOFException | ZipException e) {
                    //ignore cause apache unzip
                } catch (Exception e) {
                    BytecodeViewer.handleException(e);
                } finally {
                    jis.closeEntry();
                }
            }
        }
        container.resourceFiles = files;
        BytecodeViewer.addResourceContainer(container);
    }
    
    
    /**
     * A fallback solution to zip/jar archive importing if the first fails
     *
     * @param jarFile the input jar file
     * @throws IOException
     */
    public static void importArchiveB(final File jarFile) throws IOException
    {
        //if this ever fails, worst case import Sun's jarsigner code from JDK 7 re-sign the jar to rebuild the CRC,
        // should also rebuild the archive byte offsets

        ResourceContainer container = new ResourceContainer(jarFile);
        Map<String, byte[]> files = new LinkedHashMap<>();

        try (ZipFile zipFile = new ZipFile(jarFile)) {
            Enumeration<? extends ZipArchiveEntry> entries = zipFile.getEntries();
            while (entries.hasMoreElements()) {
                ZipArchiveEntry entry = entries.nextElement();
                String name = entry.getName();
                if (!entry.isDirectory()) {
                    try (InputStream in = zipFile.getInputStream(entry)) {
                        final byte[] bytes = MiscUtils.getBytes(in);

                        if (!name.endsWith(".class")) {
                            files.put(name, bytes);
                        } else {
                            if (MiscUtils.getFileHeaderMagicNumber(bytes).equalsIgnoreCase("cafebabe"))
                            {
                                try {
                                    final ClassNode cn = getNode(bytes);
                                    container.resourceClasses.put(FilenameUtils.removeExtension(name), cn);
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            } else {
                                files.put(name, bytes);
                            }
                        }

                    }
                }
            }
        }

        container.resourceFiles = files;
        BytecodeViewer.addResourceContainer(container);
    }
    
    public static List<ClassNode> loadClasses(final File jarFile) throws IOException
    {
        List<ClassNode> classes = new ArrayList<>();
        try (FileInputStream fis = new FileInputStream(jarFile);
             ZipInputStream jis = new ZipInputStream(fis)) {
            ZipEntry entry;
            while ((entry = jis.getNextEntry()) != null) {
                try {
                    final String name = entry.getName();
                    if (name.endsWith(".class")) {
                        byte[] bytes = MiscUtils.getBytes(jis);
                        if (MiscUtils.getFileHeaderMagicNumber(bytes).equalsIgnoreCase("cafebabe")) {
                            try {
                                final ClassNode cn = getNode(bytes);
                                classes.add(cn);
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        } else {
                            System.out.println(jarFile + ">" + name + ": Header does not start with CAFEBABE, ignoring.");
                        }
                    }

                } catch (Exception e) {
                    BytecodeViewer.handleException(e);
                } finally {
                    jis.closeEntry();
                }
            }
        }

        return classes;
    }

    /**
     * Loads resources only, just for .APK
     *
     * @param zipFile the input zip file
     * @throws IOException
     */
    public static Map<String, byte[]> loadResources(final File zipFile) throws IOException {
        if (!zipFile.exists())
            return new LinkedHashMap<>(); // just ignore (don't return null for null-safety!)
    
        Map<String, byte[]> files = new LinkedHashMap<>();

        try (ZipInputStream jis = new ZipInputStream(new FileInputStream(zipFile))) {
            ZipEntry entry;
            while ((entry = jis.getNextEntry()) != null) {
                try {
                    final String name = entry.getName();
                    if (!name.endsWith(".class") && !name.endsWith(".dex")) {
                        if (!entry.isDirectory())
                            files.put(name, MiscUtils.getBytes(jis));

                        jis.closeEntry();
                    }
                } catch (Exception e) {
                    BytecodeViewer.handleException(e);
                } finally {
                    jis.closeEntry();
                }
            }
        }

        return files;
    }

    /**
     * Creates a new ClassNode instances from the provided byte[]
     *
     * @param bytez the class file's byte[]
     * @return the ClassNode instance
     */
    public static ClassNode getNode(final byte[] bytez)
    {
        //TODO figure out why is this synchronized and if it's actually needed (probably not)
        synchronized (LOCK)
        {
            return ASMUtil.bytesToNode(bytez);
        }
    }

    /**
     * Saves as jar with manifest
     *
     * @param nodeList the loaded ClassNodes
     * @param path     the exact path of the output jar file
     * @param manifest the manifest contents
     */
    public static void saveAsJar(List<ClassNode> nodeList, String path,
                                 String manifest) {
        try (FileOutputStream fos = new FileOutputStream(path);
             JarOutputStream out = new JarOutputStream(fos)) {
            for (ClassNode cn : nodeList) {
                ClassWriter cw = new ClassWriter(0);
                cn.accept(cw);

                out.putNextEntry(new ZipEntry(cn.name + ".class"));
                out.write(cw.toByteArray());
                out.closeEntry();
            }

            out.putNextEntry(new ZipEntry("META-INF/MANIFEST.MF"));
            out.write((manifest.trim() + "\r\n\r\n").getBytes());
            out.closeEntry();

            for (ResourceContainer container : BytecodeViewer.resourceContainers.values()) {
                for (Entry<String, byte[]> entry : container.resourceFiles.entrySet()) {
                    String filename = entry.getKey();
                    if (!filename.startsWith("META-INF")) {
                        out.putNextEntry(new ZipEntry(filename));
                        out.write(entry.getValue());
                        out.closeEntry();
                    }
                }
            }
        } catch (IOException e) {
            BytecodeViewer.handleException(e);
        }
    }

    /**
     * Saves a jar without the manifest
     *
     * @param nodeList The loaded ClassNodes
     * @param path     the exact jar output path
     */
    public static void saveAsJarClassesOnly(Collection<ClassNode> nodeList, String path)
    {
        //TODO figure out why is this synchronized and if it's actually needed (probably not)
        synchronized (LOCK)
        {
            try (FileOutputStream fos = new FileOutputStream(path);
                 JarOutputStream out = new JarOutputStream(fos))
            {
                List<String> noDupe = new ArrayList<>();
                for (ClassNode cn : nodeList)
                {
                    ClassWriter cw = new ClassWriter(0);
                    cn.accept(cw);
            
                    String name = cn.name + ".class";
            
                    if (!noDupe.contains(name))
                    {
                        noDupe.add(name);
                        out.putNextEntry(new ZipEntry(name));
                        out.write(cw.toByteArray());
                        out.closeEntry();
                    }
                }
                noDupe.clear();
            }
            catch (IOException e)
            {
                BytecodeViewer.handleException(e);
            }
        }
    }

    /**
     * Saves a jar without the manifest
     *
     * @param nodeList The loaded ClassNodes
     * @param dir      the exact jar output path
     */
    public static void saveAsJarClassesOnlyToDir(List<ClassNode> nodeList, String dir) {
        try {
            for (ClassNode cn : nodeList) {
                ClassWriter cw = new ClassWriter(0);
                cn.accept(cw);

                String name = dir + fs + cn.name + ".class";
                File f = new File(name);
                f.mkdirs();

                DiskWriter.replaceFileBytes(name, cw.toByteArray(), false);
            }
        } catch (Exception e) {
            BytecodeViewer.handleException(e);
        }
    }

    /**
     * Saves a jar without the manifest
     *
     * @param nodeList The loaded ClassNodes
     * @param path     the exact jar output path
     */
    public static void saveAsJar(List<ClassNode> nodeList, String path) {
        try (FileOutputStream fos = new FileOutputStream(path);
             JarOutputStream out = new JarOutputStream(fos)) {
            List<String> noDupe = new ArrayList<>();
            for (ClassNode cn : nodeList) {
                ClassWriter cw = new ClassWriter(0);
                cn.accept(cw);

                String name = cn.name + ".class";

                if (!noDupe.contains(name)) {
                    noDupe.add(name);
                    out.putNextEntry(new ZipEntry(name));
                    out.write(cw.toByteArray());
                    out.closeEntry();
                }
            }

            for (ResourceContainer container : BytecodeViewer.resourceContainers.values()) {
                for (Entry<String, byte[]> entry : container.resourceFiles.entrySet()) {
                    String filename = entry.getKey();
                    if (!filename.startsWith("META-INF")) {
                        if (!noDupe.contains(filename)) {
                            noDupe.add(filename);
                            out.putNextEntry(new ZipEntry(filename));
                            out.write(entry.getValue());
                            out.closeEntry();
                        }
                    }
                }
            }

            noDupe.clear();
        } catch (IOException e) {
            BytecodeViewer.handleException(e);
        }
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/KeyEventDispatch.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.awt.KeyEventDispatcher;
import java.awt.event.KeyEvent;
import the.bytecode.club.bytecodeviewer.GlobalHotKeys;
import the.bytecode.club.bytecodeviewer.gui.components.SearchableRSyntaxTextArea;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/21/2021
 */
public class KeyEventDispatch implements KeyEventDispatcher
{
	@Override
	public boolean dispatchKeyEvent(KeyEvent e)
	{
		//hardcoded check for searchable syntax panes, this allows specific panels to ctrl + s save externally
		if(e.getSource() instanceof SearchableRSyntaxTextArea)
		{
			SearchableRSyntaxTextArea rSyntaxTextArea = (SearchableRSyntaxTextArea) e.getSource();
			if(rSyntaxTextArea.getOnCtrlS() != null)
				return false;
		}
		
		GlobalHotKeys.keyPressed(e);
		return false;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/LazyNameUtil.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.util.HashMap;
import java.util.Map;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Prevents name path collisions by allowing the same name to be used in multiple resource containers.
 *
 * @author Konloch
 */
public class LazyNameUtil
{
    public static boolean SAME_NAME_JAR_WORKSPACE = false;
    private static final Map<String, SeqAndCount> nameMap = new HashMap<>();

    public static void reset() {
        nameMap.clear();
    }

    public static String applyNameChanges(String name)
    {
        if (nameMap.containsKey(name))
        {
            if (!SAME_NAME_JAR_WORKSPACE)
                SAME_NAME_JAR_WORKSPACE = true;

            SeqAndCount seqAndCount = nameMap.get(name);
            nameMap.put(name, seqAndCount.incrSeqAndCount());
            return FilenameUtils.removeExtension(name) + "#" + seqAndCount.getSeq() + "." + FilenameUtils.getExtension(name);
        }
        else
        {
            nameMap.put(name, SeqAndCount.init());
        }

        return name;
    }

    public static void removeName(String name)
    {
        if (StringUtils.isBlank(name))
            return;

        if (name.contains("#"))
            name = name.substring(0, name.indexOf("#")) + name.substring(name.indexOf("."));

        SeqAndCount seqAndCount = nameMap.get(name);
        if (seqAndCount == null)
            return;

        // sequence remain the same and decrease the count
        // still the count become 1
        if (seqAndCount.getCount() == 1)
            nameMap.remove(name);
        else
            nameMap.put(name, seqAndCount.decrCount());
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/MethodParser.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.regex.Pattern;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Methods parser.
 *
 * @author DreamSworK
 */
public class MethodParser {

    public static class Method {
        public String name;
        public List<String> params;

        public Method(String name, List<String> params) {
            this.name = name;
            this.params = params;
        }

        @Override
        public String toString() {
            String params = this.params.toString();
            return this.name + "(" + params.substring(1, params.length() - 1) + ")";
        }
    }

    public static final Pattern regex = Pattern.compile("\\s*(?:static|public|private|protected|final|abstract)"
            + "[\\w\\s.<>\\[\\]]*\\s+(?<name>[\\w.]+)\\s*\\((?<params>[\\w\\s,.<>\\[\\]$?]*)\\)");

    private final TreeMap<Integer, Method> methods = new TreeMap<>();

    private static String removeBrackets(String string) {
        if (string.indexOf('<') != -1 && string.indexOf('>') != -1) {
            return removeBrackets(string.replaceAll("<[^<>]*>", ""));
        }
        return string;
    }

    private static String getLastPart(String string, int character) {
        int ch = string.lastIndexOf(character);
        if (ch != -1) {
            string = string.substring(ch + 1);
        }
        return string;
    }

    public void addMethod(int line, String name, String params) {
        if (!name.isEmpty()) {
            name = getLastPart(name, '.');
            String[] args = {};
            if (!params.isEmpty()) {
                params = removeBrackets(params);
                args = params.split(",");
                for (int i = 0; i < args.length; i++) {
                    args[i] = args[i].trim();
                    if (args[i].indexOf(' ') != -1) {
                        String[] strings = args[i].split(" ");
                        args[i] = strings[strings.length - 2];
                    }
                    args[i] = getLastPart(args[i], '.');
                    args[i] = getLastPart(args[i], '$');
                }
            }
            Method method = new Method(name, Arrays.asList(args));
            methods.put(line, method);
        }
    }

    public boolean isEmpty() {
        return methods.isEmpty();
    }

    public Method getMethod(int line) {
        return methods.get(line);
    }

    public Integer[] getMethodsLines() {
        Integer[] lines = new Integer[methods.size()];
        return methods.keySet().toArray(lines);
    }

    public String getMethodName(int line) {
        Method method = methods.get(line);
        if (method != null) {
            if (!method.name.isEmpty())
                return method.name;
        }
        return "";
    }

    public List<String> getMethodParams(int line) {
        Method method = methods.get(line);
        if (method != null) {
            if (!method.params.isEmpty())
                return method.params;
        }
        return null;
    }

    public int findMethod(Method method) {
        return findMethod(method.name, method.params);
    }

    public int findMethod(String name, List<String> params) {
        for (Map.Entry<Integer, Method> entry : methods.entrySet()) {
            if (name.equals(entry.getValue().name) && params.size() == entry.getValue().params.size()) {
                if (params.equals(entry.getValue().params)) {
                    return entry.getKey();
                }
            }
        }
        return -1;
    }

    public int findActiveMethod(int line)
    {
        if (!methods.isEmpty())
        {
            Map.Entry<Integer, Method> low = methods.floorEntry(line);
            if (low != null) {
                return low.getKey();
            }
        }
        return -1;
    }

    public int findNearestMethod(int line) {
        if (!methods.isEmpty()) {
            if (methods.size() == 1) {
                return methods.firstKey();
            } else {
                Map.Entry<Integer, Method> low = methods.floorEntry(line);
                Map.Entry<Integer, Method> high = methods.ceilingEntry(line);
                if (low != null && high != null) {
                    return Math.abs(line - low.getKey()) < Math.abs(line - high.getKey()) ? low.getKey() :
                            high.getKey();
                } else if (low != null || high != null) {
                    return low != null ? low.getKey() : high.getKey();
                }
            }
        }
        return -1;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/MiscUtils.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import javax.imageio.ImageIO;
import javax.swing.SwingUtilities;
import org.apache.commons.lang3.StringUtils;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.resources.ResourceContainer;
import the.bytecode.club.bytecodeviewer.translation.Language;

import static the.bytecode.club.bytecodeviewer.BytecodeViewer.gson;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * A collection of Misc Utils.
 *
 * @author Konloch
 */

public class MiscUtils
{
    private static final String AB = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    private static final String AN = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    private static final Random rnd = new Random();
    private static final Set<String> createdRandomizedNames = new HashSet<>();

    /**
     * Returns a random string without numbers
     *
     * @param len the length of the String
     * @return the randomized string
     */
    public static String randomString(int len) {
        StringBuilder sb = new StringBuilder(len);
        for (int i = 0; i < len; i++)
            sb.append(AB.charAt(rnd.nextInt(AB.length())));
        return sb.toString();
    }
    
    /**
     * Ensures it will only return a uniquely generated names, contains a dupe checker to be sure
     *
     * @return the unique randomized name of 25 characters.
     */
    public static String getRandomizedName() {
        boolean generated = false;
        String name = "";
        while (!generated) {
            String randomizedName = MiscUtils.randomString(25);
            if (!createdRandomizedNames.contains(randomizedName)) {
                createdRandomizedNames.add(randomizedName);
                name = randomizedName;
                generated = true;
            }
        }
        return name;
    }

    public static void printProcess(Process process) throws Exception {
        //Read out dir output
        try (InputStream is = process.getInputStream();
        InputStreamReader isr = new InputStreamReader(is);
        BufferedReader br = new BufferedReader(isr)) {
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        }

        try (InputStream is = process.getErrorStream();
             InputStreamReader isr = new InputStreamReader(is);
             BufferedReader br = new BufferedReader(isr)) {
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        }
    }

    /**
     * Returns a random string with numbers
     *
     * @param len the length of the String
     * @return the randomized string
     */
    public static String randomStringNum(int len) {
        StringBuilder sb = new StringBuilder(len);
        for (int i = 0; i < len; i++)
            sb.append(AN.charAt(rnd.nextInt(AN.length())));
        return sb.toString();
    }

    /**
     * Checks the file system to ensure it's a unique name
     *
     * @param start directory it'll be in
     * @param ext   the file extension it'll use
     * @return the unique name
     */
    public static String getUniqueName(String start, String ext) {
        String s = null;
        boolean b = true;
        File f;
        String m;
        while (b) {
            m = MiscUtils.randomString(32);
            f = new File(start + m + ext);
            if (!f.exists()) {
                s = start + m;
                b = false;
            }
        }
        return s;
    }

    /**
     * Checks the file system to ensure it's a unique number
     *
     * @param start directory it'll be in
     * @param ext   the file extension it'll use
     * @return the unique number
     */
    public static int getClassNumber(String start, String ext) {
        boolean b = true;
        int i = 0;
        while (b)
        {
            File tempF = new File(start + i + ext);
            if (!tempF.exists())
                b = false;
            else
                i++;
        }
        return i;
    }

    public static String getFileHeaderMagicNumber(byte[] fileContents)
    {
        if(fileContents == null || fileContents.length < 4)
            return StringUtils.EMPTY;
        
        return String.format("%02X%02X%02X%02X", fileContents[0],
                fileContents[1], fileContents[2],fileContents[3]);
    }
    
    public static File autoAppendFileExtension(String extension, File file)
    {
        if (!file.getName().endsWith(extension))
            file = new File(file.getAbsolutePath() + extension);
        
        return file;
    }
    
    public static String extension(String name) {
        return name.substring(name.lastIndexOf('.') + 1);
    }

    public static String append(File file, String extension) {
        String path = file.getAbsolutePath();
        if (!path.endsWith(extension))
            path += extension;
        return path;
    }
    
    public static int fileContainersHash(List<ResourceContainer> resourceContainers) {
        StringBuilder block = new StringBuilder();
        for (ResourceContainer container : resourceContainers) {
            block.append(container.name);
            for (ClassNode node : container.resourceClasses.values()) {
                block.append(node.name);
            }
        }
        
        return block.hashCode();
    }
    
    /**
     * Converts an array list to a string
     *
     * @param a array
     * @return string with newline per array object
     */
    public static String listToString(List<String> a) {
        return gson.toJson(a);
    }
    
    /**
     * @author JoshTheWolfe
     */
    @SuppressWarnings({"unchecked"})
    public static void updateEnv(String name, String val) throws ReflectiveOperationException {
        Map<String, String> env = System.getenv();
        Field field = env.getClass().getDeclaredField("m");
        field.setAccessible(true);
        ((Map<String, String>) field.get(env)).put(name, val);
    }
    
    public static BufferedImage loadImage(BufferedImage defaultImage, byte[] contents)
    {
        try (ByteArrayInputStream bais = new ByteArrayInputStream(contents)) {
            return ImageIO.read(bais);
        } catch (IOException e) {
            BytecodeViewer.handleException(e);
        }
        
        return defaultImage;
    }
    
    public static void deduplicateAndTrim(List<String> list, int maxLength)
    {
        List<String> temporaryList = new ArrayList<>();
        for(String s : list)
            if(!s.isEmpty() && !temporaryList.contains(s))
                temporaryList.add(s);
            
        list.clear();
        list.addAll(temporaryList);

        while(list.size() > maxLength)
            list.remove(list.size() - 1);
    }

    /**
     * Returns whether the bytes most likely represent binary data.
     * Based on https://stackoverflow.com/a/13533390/5894824
     */
    public static boolean guessIfBinary(byte[] data) {
        double ascii = 0;
        double other = 0;
        for (byte b : data) {
            if (b == 0x09 || b == 0x0A || b == 0x0C || b == 0x0D || (b >= 0x20 && b <= 0x7E)) ascii++;
            else other++;
        }
        return other != 0 && other / (ascii + other) > 0.25;
    }
    
    public static Language guessLanguage()
    {
        String userLanguage = System.getProperty("user.language");
        String systemLanguageCode = userLanguage != null ? userLanguage.toLowerCase() : "";
        
        return Language.getLanguageCodeLookup().getOrDefault(systemLanguageCode, Language.ENGLISH);
    }
    
    public static void setLanguage(Language language)
    {
        Configuration.language = language;
    
        try
        {
            Language.ENGLISH.setLanguageTranslations(); //load english first incase the translation file is missing anything
            language.setLanguageTranslations(); //load translation file and swap text around as needed
            SwingUtilities.updateComponentTreeUI(BytecodeViewer.viewer);
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
    }
    
    /**
     * START's a new thread (Creates a new thread and runs that thread runnable on it)
     */
    public static Thread createNewThread(String threadName, Runnable threadRunnable)
    {
        return createNewThread(threadName, false, threadRunnable);
    }
    
    /**
     * START's a new thread (Creates a new thread and runs that thread runnable on it)
     * RUN's a new thread (Just executes the thread runnable on the active thread)
     */
    public static Thread createNewThread(String threadName, boolean runDontStart, Runnable threadRunnable)
    {
        Thread temporaryThread = new Thread(threadRunnable, threadName);
        
        if(runDontStart)
            temporaryThread.run();
        else
            temporaryThread.start();
        
        return temporaryThread;
    }
    
    public static String getChildFromPath(String path)
    {
        if (path != null && path.contains("/"))
        {
            String[] pathParts = StringUtils.split(path, "/");
            return pathParts[pathParts.length-1];
        }
        
        return path;
    }
    
    /**
     * Reads an InputStream and returns the read byte[]
     *
     * @param is InputStream
     * @return the read byte[]
     * @throws IOException
     */
    public static byte[] getBytes(final InputStream is) throws IOException
    {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            byte[] buffer = new byte[1024];
            int a;
            while ((a = is.read(buffer)) != -1)
                baos.write(buffer, 0, a);

            return baos.toByteArray();
        }
    }

    public static File[] listFiles(File file) {
        if (file == null)
            return new File[0];
        File[] list = file.listFiles();
        if (list != null)
            return list;
        return new File[0];
    }

    public static File deleteExistingFile(File file)
    {
        if (file.exists())
            file.delete();
        
        return file;
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/NewlineOutputStream.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import org.jetbrains.annotations.NotNull;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Convert the various newline conventions to the local platform's newline convention.
 *
 * This stream can be used with the Message.writeTo method to
 * generate a message that uses the local platform's line terminator
 * for the purpose of (e.g.) saving the message to a local file.
 */
public class NewlineOutputStream extends FilterOutputStream {
    private int lastByte = -1;
    private static byte[] newline;

    public NewlineOutputStream(OutputStream os) {
        super(os);
        if (newline == null) {
            String s = System.getProperty("line.separator");
            if (s == null || s.length() <= 0)
                s = "\n";
            newline = s.getBytes(StandardCharsets.ISO_8859_1);    // really us-ascii
        }
    }

    @Override
    public void write(int b) throws IOException {
        if (b == '\r') {
            out.write(newline);
        } else if (b == '\n') {
            if (lastByte != '\r')
                out.write(newline);
        } else {
            out.write(b);
        }
        lastByte = b;
    }

    @Override
    public void write(byte @NotNull [] b) throws IOException {
        write(b, 0, b.length);
    }

    @Override
    public void write(byte @NotNull [] b, int off, int len) throws IOException {
        for (int i = 0; i < len; i++) {
            write(b[off + i]);
        }
    }
}
```

`src/main/java/the/bytecode/club/bytecodeviewer/util/PingBack.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.net.URL;
import me.konloch.kontainer.io.HTTPRequest;
import the.bytecode.club.bytecodeviewer.Configuration;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Pings back to bytecodeviewer.com to be added into the total running statistics
 *
 * @author Konloch
 * @since May 1, 2015
 */
public class PingBack implements Runnable
{
	@Override
	public void run()
	{
		try {
			new HTTPRequest(new URL("https://bytecodeviewer.com/add.php")).read();
		} catch (Exception e) {
			Configuration.pingback = false;
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/SecurityMan.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.File;
import java.io.FileDescriptor;
import java.io.IOException;
import java.net.InetAddress;
import java.security.Permission;
import java.util.concurrent.atomic.AtomicInteger;
import the.bytecode.club.bytecodeviewer.BytecodeViewer;
import the.bytecode.club.bytecodeviewer.Configuration;
import the.bytecode.club.bytecodeviewer.Constants;
import the.bytecode.club.bytecodeviewer.compilers.impl.JavaCompiler;
import the.bytecode.club.bytecodeviewer.compilers.impl.KrakatauAssembler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.CFRDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.FernFlowerDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.JDGUIDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.KrakatauDecompiler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.KrakatauDisassembler;
import the.bytecode.club.bytecodeviewer.decompilers.impl.ProcyonDecompiler;
import the.bytecode.club.bytecodeviewer.resources.ExternalResources;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * An awesome security manager.
 *
 * @author Konloch
 */

public class SecurityMan extends SecurityManager
{
    private static final boolean disableExecSandbox = true;
    private static final boolean disableDiskWriteSandbox = true;
    
    private final AtomicInteger silentExec = new AtomicInteger(1);
    private boolean printing = false;
    private boolean printingPackage = false;
    
    public void silenceExec(boolean b) {
        silentExec.addAndGet(b ? 1 : -1);
    }
    
    public void setPrinting(boolean printing)
    {
        this.printing = printing;
    }
    
    public void setPrintingPackage(boolean printingPackage)
    {
        this.printingPackage = printingPackage;
    }
    
    /**
     * Attempts to secure untrusted code
     *
     * When paired with checkWrite it should prevent most escapes
     * JNI is still possible so make sure to block checkLink as well //TODO for BCV
     *
     * Rewritten on 07/19/2021
     *
     * @author Konloch
     */
    @Override
    public void checkExec(String cmd)
    {
        //This was disabled on 02-13-2022, at some point in the future I will fix the compatibility issues and re-enable it.
        if(disableExecSandbox)
            return;
        
        //incoming command must contain the following or it will be automatically denied
        String[] execWhitelist =
        {
                "attrib",
                "python",
                "pypy",
                "java",
                "brut_util",
        };
        
        //the goal is to make this true
        boolean allow = false;
        //while keeping this false
        boolean blocked = false;

        //normalize all command paths
        final String normalizedPath;
        try
        {
            normalizedPath = new File(cmd.toLowerCase()).getCanonicalPath();
        }
        catch (IOException e)
        {
            throw new SecurityException(e);
        }
    
        //don't trust .jar file extensions being executed
        if(normalizedPath.endsWith(".jar"))
            blocked = true;
        
        //don't trust .js file extensions being executed
        else if(normalizedPath.endsWith(".js"))
            blocked = true;
        
        //block anything executing in system temp
        else if(normalizedPath.startsWith(Constants.systemTempDirectory.toLowerCase()))
            blocked = true;
        
        //can only write into BCV dir, so anything executing from here has probably been dropped
        try
        {
            if(normalizedPath.startsWith(Constants.BCVDir.getCanonicalPath().toLowerCase()))
                blocked = true;
        }
        catch (IOException e)
        {
            throw new SecurityException(e);
        }
    
        //filter exec whitelist
        for (String whiteList : execWhitelist)
        {
            if (normalizedPath.contains(whiteList))
            {
                allow = true;
                break;
            }
        }
        
        //filter class whitelist
        boolean validClassCall = false;
        //JDK-8
        if(canClassExecute(Thread.currentThread().getStackTrace()[3].getClassName()))
            validClassCall = true;
        //JDK-15
        else if(canClassExecute(Thread.currentThread().getStackTrace()[4].getClassName()))
            validClassCall = true;
        //JDK-8
        else if(canClassExecute(Thread.currentThread().getStackTrace()[6].getClassName()))
            validClassCall = true;
        //JDK-15
        else if(canClassExecute(Thread.currentThread().getStackTrace()[7].getClassName()))
            validClassCall = true;
        else
        {
            int index = 0;
            for (StackTraceElement stackTraceElements : Thread.currentThread().getStackTrace())
            {
                System.out.println(index++ + ":" + stackTraceElements.getClassName());
            }
        }
        
        //log exec if allowed
        if (allow && validClassCall && !blocked)
        {
            if(silentExec.get() >= 1)
                System.err.println("Allowing exec: " + cmd);
        } //throw exception stopping execution
        else throw new SecurityException("BCV is awesome! Blocking exec: " + cmd);
    }
    
    /**
     * Class Whitelist goes here
     */
    private boolean canClassExecute(String fullyQualifiedClassName)
    {
        return  fullyQualifiedClassName.equals(KrakatauDecompiler.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(KrakatauDisassembler.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(CFRDecompiler.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(ProcyonDecompiler.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(FernFlowerDecompiler.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(JDGUIDecompiler.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(KrakatauAssembler.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(ExternalResources.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(Enjarify.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(APKTool.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(BytecodeViewer.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(Constants.class.getCanonicalName()) ||
                fullyQualifiedClassName.equals(JavaCompiler.class.getCanonicalName());
    }

    @Override
    public void checkListen(int port) {
        throw new SecurityException("BCV is awesome, blocking port " + port + " from listening");
    }

    @Override
    public void checkPermission(Permission perm) { //expand eventually
    }

    @Override
    public void checkPermission(Permission perm, Object context) {//expand eventually
    }

    @Override
    public void checkAccess(Thread t) {
    }

    @Override
    public void checkAccept(String host, int port) {
    }

    @Override
    public void checkAccess(ThreadGroup g) {
    }
    
    @SuppressWarnings("deprecation")
    public void checkAwtEventQueueAccess() {
    }

    @Override
    public void checkConnect(String host, int port) {
        if(printing)
            System.out.println("Connecting to: " + host + ":" + port);
    }

    @Override
    public void checkConnect(String host, int port, Object context) {
    }

    @Override
    public void checkCreateClassLoader() {
    }

    @Override
    public void checkDelete(String file) {
        if(printing)
            System.out.println("Deleting: " + file);
    }

    @Override
    public void checkExit(int status) {
        if (!Configuration.canExit) {
            throw new SecurityException("BCV is awesome, blocking System.exit(" + status + ");");
        }
    }

    @Override
    public void checkLink(String lib) {
        if(printing)
            System.out.println("Linking: " + lib);
    }
    
    @SuppressWarnings("deprecation")
    public void checkMemberAccess(Class<?> clazz, int which) {
    }

    @Override
    public void checkMulticast(InetAddress maddr) {
    }
    
    @SuppressWarnings("deprecation")
    public void checkMulticast(InetAddress maddr, byte ttl) {
    }

    public void checkPackageAccess(String pkg) {
        if(printingPackage)
            System.out.println("Accessing: " + pkg);
    }

    @Override
    public void checkPackageDefinition(String pkg) {
    }

    @Override
    public void checkPrintJobAccess() {
    }

    @Override
    public void checkPropertiesAccess() {
    }

    @Override
    public void checkPropertyAccess(String key) {
    }

    @Override
    public void checkRead(FileDescriptor fd) {
    }

    @Override
    public void checkRead(String file) {
        if(printing)
            System.out.println("Reading: " + file);
    }

    @Override
    public void checkRead(String file, Object context) {
    }

    @Override
    public void checkSecurityAccess(String target) {
    }

    @Override
    public void checkSetFactory() {
    }
    
    @SuppressWarnings("deprecation")
    public void checkSystemClipboardAccess() {
    }

    @Override
    public void checkWrite(FileDescriptor fd) {
    }

    @Override
    public void checkWrite(String file) {
        if(printing)
            System.out.println("Writing: " + file);
    
        //This was disabled on 02-13-2022, at some point in the future I will fix the compatibility issues and re-enable it.
        if(disableDiskWriteSandbox)
            return;
        
        try
        {
            //can only export as the following extensions
            if(file.endsWith(".zip") || file.endsWith(".jar") || file.endsWith(".apk")
                    || file.endsWith(".dex") || file.endsWith(".class") || file.endsWith("js")
                    || file.endsWith(".java") || file.endsWith(".gy") || file.endsWith(".bcv")
                    || file.endsWith(".json") || file.endsWith(".txt") || file.endsWith(".log"))
                return;
            
            //can only write into BCV dir
            if(file.startsWith(Constants.BCVDir.getCanonicalPath()))
                return;
            
            //can only write into system temp
            if(file.startsWith(Constants.systemTempDirectory))
                return;
        }
        catch (IOException e)
        {
            throw new SecurityException(e);
        }

        throw new SecurityException("BCV is awesome, blocking write(" + file + ");");
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/SeqAndCount.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Hupan
 * @since 11/20/2019
 */
class SeqAndCount
{
	Integer seq;
	Integer count;
	
	public static SeqAndCount init()
	{
		SeqAndCount seqAndCount = new SeqAndCount();
		seqAndCount.setSeq(1);
		seqAndCount.setCount(1);
		return seqAndCount;
	}
	
	public SeqAndCount incrSeq()
	{
		seq++;
		return this;
	}
	
	public SeqAndCount incrCount()
	{
		count++;
		return this;
	}
	
	public SeqAndCount decrCount()
	{
		count--;
		return this;
	}
	
	public SeqAndCount incrSeqAndCount()
	{
		seq++;
		count++;
		return this;
	}
	
	public Integer getSeq()
	{
		return seq;
	}
	
	public void setSeq(Integer seq)
	{
		this.seq = seq;
	}
	
	public Integer getCount()
	{
		return count;
	}
	
	public void setCount(Integer count)
	{
		this.count = count;
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/SyntaxLanguage.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.File;
import java.util.function.BiFunction;
import org.fife.ui.rsyntaxtextarea.FileTypeUtil;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.SyntaxConstants;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author ThexXTURBOXx
 */
public enum SyntaxLanguage {
    XML(SyntaxConstants.SYNTAX_STYLE_XML,
            (n, c) -> n.endsWith(".xml") || c.startsWith("<?xml") || c.startsWith("<xml")),
    PYTHON(SyntaxConstants.SYNTAX_STYLE_PYTHON, (n, c) -> n.endsWith(".py") || n.endsWith(".python")),
    RUBY(SyntaxConstants.SYNTAX_STYLE_RUBY, (n, c) -> n.endsWith(".rb") || n.endsWith(".ruby")),
    JAVA(SyntaxConstants.SYNTAX_STYLE_JAVA, (n, c) -> n.endsWith(".java")),
    HTML(SyntaxConstants.SYNTAX_STYLE_HTML, (n, c) -> n.endsWith(".html")),
    CSS(SyntaxConstants.SYNTAX_STYLE_CSS, (n, c) -> n.endsWith(".css")),
    PROPERTIES(SyntaxConstants.SYNTAX_STYLE_PROPERTIES_FILE,
            (n, c) -> n.endsWith(".properties") || n.endsWith(".mf") || n.endsWith(".sf")
                    || n.endsWith(".plugin") || n.endsWith(".attachprovider") || n.endsWith(".transportservice")
                    || n.endsWith(".connector")),
    PHP(SyntaxConstants.SYNTAX_STYLE_PHP, (n, c) -> n.endsWith(".php") || c.startsWith("<?php")),
    JS(SyntaxConstants.SYNTAX_STYLE_JAVASCRIPT, (n, c) -> n.endsWith(".js")),
    BATCH(SyntaxConstants.SYNTAX_STYLE_WINDOWS_BATCH, (n, c) -> n.endsWith(".bat")),
    SHELL(SyntaxConstants.SYNTAX_STYLE_UNIX_SHELL, (n, c) -> n.endsWith(".sh")),
    C(SyntaxConstants.SYNTAX_STYLE_C, (n, c) -> n.endsWith(".c") || n.endsWith(".h")),
    CPP(SyntaxConstants.SYNTAX_STYLE_CPLUSPLUS, (n, c) -> n.endsWith(".cpp") || n.endsWith(".hpp")),
    SCALA(SyntaxConstants.SYNTAX_STYLE_SCALA, (n, c) -> n.endsWith(".scala")),
    CLOJURE(SyntaxConstants.SYNTAX_STYLE_CLOJURE, (n, c) -> n.endsWith(".clojure")),
    GROOVY(SyntaxConstants.SYNTAX_STYLE_GROOVY, (n, c) -> n.endsWith(".groovy") || n.endsWith(".gradle")),
    LUA(SyntaxConstants.SYNTAX_STYLE_LUA, (n, c) -> n.endsWith(".lua")),
    SQL(SyntaxConstants.SYNTAX_STYLE_SQL, (n, c) -> n.endsWith(".sql")),
    JSON(SyntaxConstants.SYNTAX_STYLE_JSON, (n, c) -> n.endsWith(".json")),
    JSP(SyntaxConstants.SYNTAX_STYLE_JSP, (n, c) -> n.endsWith(".jsp")),
    YAML(SyntaxConstants.SYNTAX_STYLE_YAML, (n, c) -> n.endsWith(".yml") || n.endsWith(".yaml")),
    CS(SyntaxConstants.SYNTAX_STYLE_CSHARP, (n, c) -> n.endsWith(".cs")),
    CSV(SyntaxConstants.SYNTAX_STYLE_CSV, (n, c) -> n.endsWith(".csv")),
    DOCKER(SyntaxConstants.SYNTAX_STYLE_DOCKERFILE, (n, c) -> n.endsWith(".dockerfile")),
    DART(SyntaxConstants.SYNTAX_STYLE_DART, (n, c) -> n.endsWith(".dart")),
    GO(SyntaxConstants.SYNTAX_STYLE_GO, (n, c) -> n.endsWith(".go")),
    HTACCESS(SyntaxConstants.SYNTAX_STYLE_HTACCESS, (n, c) -> n.endsWith(".htaccess")),
    INI(SyntaxConstants.SYNTAX_STYLE_INI, (n, c) -> n.endsWith(".ini")),
    KOTLIN(SyntaxConstants.SYNTAX_STYLE_KOTLIN, (n, c) -> n.endsWith(".kt") || n.endsWith(".kts")),
    LATEX(SyntaxConstants.SYNTAX_STYLE_LATEX, (n, c) -> n.endsWith(".tex")),
    MARKDOWN(SyntaxConstants.SYNTAX_STYLE_MARKDOWN, (n, c) -> n.endsWith(".md")),
    PERL(SyntaxConstants.SYNTAX_STYLE_PERL, (n, c) -> n.endsWith(".pl")),
    TYPESCRIPT(SyntaxConstants.SYNTAX_STYLE_TYPESCRIPT, (n, c) -> n.endsWith(".ts")),
    NONE(SyntaxConstants.SYNTAX_STYLE_NONE, (n, c) -> false);

    public static final SyntaxLanguage[] VALUES = values();

    private static final FileTypeUtil FILE_TYPE_UTIL = FileTypeUtil.get();

    private final BiFunction<String, String, Boolean> criteria;

    private final String syntaxConstant;

    SyntaxLanguage(String syntaxConstant, BiFunction<String, String, Boolean> criteria) {
        this.criteria = criteria;
        this.syntaxConstant = syntaxConstant;
    }

    public boolean isLanguage(String fileName, String content) {
        return criteria.apply(fileName, content);
    }

    public String getSyntaxConstant() {
        return syntaxConstant;
    }

    /**
     * @deprecated See {@link #setLanguage(RSyntaxTextArea, String)}.
     */
    @Deprecated
    public static SyntaxLanguage detectLanguage(String fileName, String content) {
        for (SyntaxLanguage lang : VALUES) {
            if (lang.isLanguage(fileName, content)) {
                return lang;
            }
        }
        return NONE;
    }

    public static void setLanguage(RSyntaxTextArea area, String fileName) {
        String type = FILE_TYPE_UTIL.guessContentType(new File(fileName));
        if (type == null || type.equals(SyntaxConstants.SYNTAX_STYLE_NONE)) {
            type = FILE_TYPE_UTIL.guessContentType(area);
        }
        area.setSyntaxEditingStyle(type);
    }
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/WindowClosingAdapter.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import the.bytecode.club.bytecodeviewer.Configuration;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/21/2021
 */
public class WindowClosingAdapter extends WindowAdapter
{
	@Override
	public void windowClosing(WindowEvent e)
	{
		Configuration.canExit = true;
		System.exit(0);
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/WindowStateChangeAdapter.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.awt.Frame;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import the.bytecode.club.bytecodeviewer.gui.MainViewerGUI;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * @author Konloch
 * @since 6/21/2021
 */
public class WindowStateChangeAdapter extends WindowAdapter
{
	private final MainViewerGUI mainViewerGUI;
	
	public WindowStateChangeAdapter(MainViewerGUI mainViewerGUI) {this.mainViewerGUI = mainViewerGUI;}
	
	@Override
	public void windowStateChanged(WindowEvent evt)
	{
		int oldState = evt.getOldState();
		int newState = evt.getNewState();

        /*if ((oldState & Frame.ICONIFIED) == 0 && (newState & Frame.ICONIFIED) != 0) {
            System.out.println("Frame was iconized");
        } else if ((oldState & Frame.ICONIFIED) != 0 && (newState & Frame.ICONIFIED) == 0) {
            System.out.println("Frame was deiconized");
        }*/
		
		if ((oldState & Frame.MAXIMIZED_BOTH) == 0 && (newState & Frame.MAXIMIZED_BOTH) != 0)
		{
			mainViewerGUI.isMaximized = true;
		}
		else if ((oldState & Frame.MAXIMIZED_BOTH) != 0 && (newState & Frame.MAXIMIZED_BOTH) == 0)
		{
			mainViewerGUI.isMaximized = false;
		}
	}
}

```

`src/main/java/the/bytecode/club/bytecodeviewer/util/ZipUtils.java`:

```java
package the.bytecode.club.bytecodeviewer.util;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Objects;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/***************************************************************************
 * Bytecode Viewer (BCV) - Java & Android Reverse Engineering Suite        *
 * Copyright (C) 2014 Kalen 'Konloch' Kinloch - http://bytecodeviewer.com  *
 *                                                                         *
 * This program is free software: you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

/**
 * Rudimentary utility class for Zip archives.
 */
public final class ZipUtils {

    // TODO: Maybe migrate to org.apache.commons.compress.archivers.examples.Expander?
    /**
     * Unzip files to path.
     *
     * @param jarPath        the zip file name
     * @param destinationDir the file extract path
     * @throws IOException Signals that an I/O exception has occurred.
     */
    public static void unzipFilesToPath(String jarPath, String destinationDir) throws IOException {
        String canonicalDestDir = new File(destinationDir).getCanonicalPath();
        if (!canonicalDestDir.endsWith(File.separator)) {
            canonicalDestDir += File.separator;
        }

        File file = new File(jarPath);
        try (JarFile jar = new JarFile(file)) {

            // fist get all directories,
            // then make those directory on the destination Path
            /*for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {
                JarEntry entry = (JarEntry) enums.nextElement();

                String fileName = destinationDir + File.separator + entry.getName();
                File f = new File(fileName);

                if (fileName.endsWith("/")) {
                    f.mkdirs();
                }

            }*/

            //now create all files
            for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {
                JarEntry entry = enums.nextElement();

                String fileName = destinationDir + File.separator + entry.getName();
                File f = new File(fileName);

                if (!f.getCanonicalPath().startsWith(canonicalDestDir)) {
                    System.out.println("Zip Slip exploit detected. Skipping entry " + entry.getName());
                    continue;
                }

                File parent = f.getParentFile();
                if (!parent.exists()) {
                    parent.mkdirs();
                }

                if (!fileName.endsWith("/")) {
                    try (InputStream is = jar.getInputStream(entry);
                         FileOutputStream fos = new FileOutputStream(f)) {
                        // write contents of 'is' to 'fos'
                        while (is.available() > 0) {
                            fos.write(is.read());
                        }
                    }
                }
            }
        }
    }

    public static void zipFile(File inputFile, File outputZip) {
        byte[] buffer = new byte[1024];

        try (FileOutputStream fos = new FileOutputStream(outputZip);
             ZipOutputStream zos = new ZipOutputStream(fos)) {
            ZipEntry ze = new ZipEntry(inputFile.getName());
            zos.putNextEntry(ze);
            try (FileInputStream in = new FileInputStream(inputFile)) {
                int len;
                while ((len = in.read(buffer)) > 0) {
                    zos.write(buffer, 0, len);
                }
            }
            zos.closeEntry();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void zipFolder(String srcFolder, String destZipFile, String ignore) throws Exception {
        try (FileOutputStream fileWriter = new FileOutputStream(destZipFile);
             ZipOutputStream zip = new ZipOutputStream(fileWriter)) {
            addFolderToZip("", srcFolder, zip, ignore);
            zip.flush();
        }
    }

    public static void zipFolderAPKTool(String srcFolder, String destZipFile) throws Exception {
        try (FileOutputStream fileWriter = new FileOutputStream(destZipFile);
             ZipOutputStream zip = new ZipOutputStream(fileWriter)) {
            addFolderToZipAPKTool("", srcFolder, zip);
            zip.flush();
        }
    }

    public static void addFileToZip(String path, String srcFile, ZipOutputStream zip, String ignore)
            throws Exception {

        File folder = new File(srcFile);
        if (folder.isDirectory()) {
            addFolderToZip(path, srcFile, zip, ignore);
        } else {
            byte[] buf = new byte[1024];
            int len;
            try (FileInputStream in = new FileInputStream(srcFile)) {
                ZipEntry entry;
                if (ignore == null)
                    entry = new ZipEntry(path + "/" + folder.getName());
                else
                    entry = new ZipEntry(path.replace(ignore, "BCV_Krakatau") + "/" + folder.getName());
                zip.putNextEntry(entry);
                while ((len = in.read(buf)) > 0) {
                    zip.write(buf, 0, len);
                }
            }
        }
    }

    public static void addFileToZipAPKTool(String path, String srcFile, ZipOutputStream zip) throws Exception {
        File folder = new File(srcFile);

        String check = path.toLowerCase();
        //if(check.startsWith("decoded unknown") || check.startsWith("decoded lib") || check.startsWith("decoded
        // assets") || check.startsWith("decoded original") || check.startsWith("decoded smali") || check.startsWith
        // ("decoded apktool.yml"))
        if (check.startsWith("decoded original") || check.startsWith("decoded smali") || check.startsWith("decoded "
                + "apktool.yml"))
            return;

        //if(path.equals("original") || path.equals("classes.dex") || path.equals("apktool.yml"))
        //    continue;

        if (folder.isDirectory()) {
            addFolderToZipAPKTool(path, srcFile, zip);
        } else {
            byte[] buf = new byte[1024];
            int len;
            try (FileInputStream in = new FileInputStream(srcFile)) {
                ZipEntry entry;

                entry = new ZipEntry(path + "/" + folder.getName());
                zip.putNextEntry(entry);

                while ((len = in.read(buf)) > 0) {
                    zip.write(buf, 0, len);
                }
            }
        }
    }

    public static void addFolderToZip(String path, String srcFolder, ZipOutputStream zip, String ignore)
            throws Exception {
        File folder = new File(srcFolder);

        for (String fileName : Objects.requireNonNull(folder.list())) {
            if (path.isEmpty()) {
                addFileToZip(folder.getName(), srcFolder + "/" + fileName, zip, ignore);
            } else {
                addFileToZip(path + "/" + folder.getName(), srcFolder + "/" + fileName, zip, ignore);
            }
        }
    }

    public static void addFolderToZipAPKTool(String path, String srcFolder, ZipOutputStream zip) throws Exception {
        File folder = new File(srcFolder);

        for (String fileName : Objects.requireNonNull(folder.list())) {
            if (path.isEmpty()) {
                addFileToZipAPKTool(folder.getName(), srcFolder + "/" + fileName, zip);
            } else {
                addFileToZipAPKTool(path + "/" + folder.getName(), srcFolder + "/" + fileName, zip);
            }
        }
    }
}

```

`src/main/resources/LICENSES/ASM.txt`:

```txt
Copyright (c) 2000-2011 INRIA, France Telecom
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holders nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.
```

`src/main/resources/LICENSES/BCV.txt`:

```txt
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS


    Bytecode Viewer - Java & Android Reverse Engineering Suite
    Copyright (C) 2014  Kalen "Konloch" Kinloch - http://bytecodeviewer.com - http://the.bytecode.club

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
```

`src/main/resources/LICENSES/apktool-license.txt`:

```txt
Sub projects brut.apktool, brut.j.common, brut.dir and brut.j.util are
released under the following license:

*******************************************************************************

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*******************************************************************************

The sub project (brut.apktool.smali) is a clone of the smali project. Its
license can be found at brut.apktool.smali/NOTICE-SMALI
```

`src/main/resources/LICENSES/byteanalysis-license.txt`:

```txt
NONE WHAT THE FUCK BIBL > https://github.com/TheBiblMan/Byte-Engineer-2
```

`src/main/resources/LICENSES/cfr-license.txt`:

```txt
The MIT License (MIT)

Copyright (c) 2011-2019 Lee Benfield - https://www.benf.org/other/cfr

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
```

`src/main/resources/LICENSES/commons-license.txt`:

```txt
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

`src/main/resources/LICENSES/dex2jar-license.txt`:

```txt
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

`src/main/resources/LICENSES/enjarif-license.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

`src/main/resources/LICENSES/fernflower-license.txt`:

```txt
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

`src/main/resources/LICENSES/imgscalr-license.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

`src/main/resources/LICENSES/janino-license.txt`:

```txt
http://opensource.org/licenses/BSD-3-Clause
```

`src/main/resources/LICENSES/jd-gui-license.txt`:

```txt
                     GNU GENERAL PUBLIC LICENSE

                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    JD-GUI, a standalone graphical utility that displays Java sources from
	CLASS files
    Copyright (C) 2008-2015  Emmanuel Dupuy

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    JD-GUI  Copyright (C) 2008-2015  Emmanuel Dupuy
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
```

`src/main/resources/LICENSES/jgraphx-license.txt`:

```txt
Copyright (c) 2001-2014, JGraph Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the JGraph nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JGRAPH BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`src/main/resources/LICENSES/krakata-license.txt`:

```txt
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
```

`src/main/resources/LICENSES/procyon-license.txt`:

```txt
Apache License
Version 2.0, January 2004
http://www.apache.org/licenses/ 

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 

1. Definitions.

"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. 

"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. 

"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. 

"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License. 

"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. 

"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. 

"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). 

"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. 

"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution." 

"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: 

You must give any other recipients of the Work or Derivative Works a copy of this License; and 


You must cause any modified files to carry prominent notices stating that You changed the files; and 


You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and 


If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. 
You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. 
```

`src/main/resources/LICENSES/rsyntaxtextarea-license.txt`:

```txt
Copyright (c) 2012, Robert Futrell
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the author nor the names of its contributors may
      be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`src/main/resources/LICENSES/smali.txt`:

```txt
The majority of smali/baksmali is written and copyrighted by me (Ben Gruver)
and released under the following license:

*******************************************************************************
Copyright (c) 2010 Ben Gruver (JesusFreke)
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of the author may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************


Unless otherwise stated in the code/commit message, any changes with the
committer of bgruv@google.com is copyrighted by Google Inc. and released
under the following license:

*******************************************************************************
Copyright 2011, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************


Various portions of the code are taken from the Android Open Source Project,
and are used in accordance with the following license:

*******************************************************************************
Copyright (C) 2007 The Android Open Source Project

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*******************************************************************************
```

`src/main/resources/templates/Template_Plugin.java`:

```java
import java.util.List;
import org.objectweb.asm.tree.ClassNode;
import the.bytecode.club.bytecodeviewer.api.*;

/**
 ** [Plugin Description Goes Here]
 **
 ** @author [Your Name Goes Here]
 **/

public class Template extends Plugin {

	PluginConsole gui;

	/**
	 * Execute function - this gets executed when the plugin is ran
	 */
	@Override
	public void execute(List<ClassNode> classNodeList) {
		// Create & show the console
		gui = new PluginConsole("Java Template");
		gui.setVisible(true);
		
		// Print out to the console
		print("Class Nodes: " + classNodeList.size());

		// Iterate through each class node
		for (ClassNode cn : classNodeList)
			processClassNode(cn);
		
		// Hide the console after 10 seconds
		BCV.hideFrame(gui, 10000);
	}

	/**
	 * Process each class node
	 */
	public void processClassNode(ClassNode cn) {
		print("Node: " + cn.name + ".class");
		
		//TODO developer plugin code goes here
	}

	/**
	 * Print to console
	 */
	public void print(String text) {
		gui.appendText(text);
	}

}
```

`src/main/resources/templates/Template_Plugin.js`:

```js
var BCV = Java.type("the.bytecode.club.bytecodeviewer.api.BCV");
var PluginConsole = Java.type("the.bytecode.club.bytecodeviewer.api.PluginConsole");
var gui;

/**
 ** [plugin description goes here]
 **
 ** @author [your name goes here]
 **/

/**
 * execute function - this gets executed when the plugin is ran
 */
function execute(classNodeList)
{
    //create & show the console
	gui = new PluginConsole("Javascript Template");
	gui.setVisible(true);

	//print to the console
	print("Class Nodes: " + classNodeList.size());

	//iterate through each class node
    for (index = 0; index < classNodeList.length; index++)
        processClassNode(classNodeList[index]);

    //hide the console after 10 seconds
	BCV.hideFrame(gui, 10000);
}

/**
 * process each class node
 */
function processClassNode(cn)
{
	print("Node: " + cn.name + ".class");

	//TODO developer plugin code goes here
}

/**
 * print to console
 */
function print(text)
{
	gui.appendText(text);
}
```

`src/main/resources/translations/arabic.json`:

```json
{
  "FILE": "ملف",
  "ADD": "أضف...",
  "NEW_WORKSPACE": "مساحة عمل جديدة",
  "RELOAD_RESOURCES": "إعادة تحميل الموارد",
  "RUN": "تشغيل",
  "OPEN": "فتح...",
  "OPEN_UNSTYLED": "افتح",
  "QUICK_OPEN": "فتح سريع",
  "DELETE": "حذف",
  "NEW": "جديد",
  "EXPAND": "يوسع",
  "COLLAPSE": "انهيار",
  "COMPILE": "تجميع",
  "SAVE_AS_RUNNABLE_JAR": "حفظ باسم JAR قابلة للتشغيل ...",
  "SAVE_AS_ZIP": "حفظ بتنسيق Zip ...",
  "SAVE_AS_DEX": "حفظ باسم DEX ...",
  "SAVE_AS_APK": "حفظ باسم APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "فك وحفظ الفئات المفتوحة",
  "DECOMPILE_SAVE_ALL_CLASSES": "فك جميع الفئات وحفظها",
  "RECENT_FILES": "الملفات الأخيرة",
  "ABOUT": "حول",
  "EXIT": "إغلاق",

  "VIEW": "عرض",
  "VISUAL_SETTINGS": "إعدادات العرض",
  "PANE_1": "اللوحة 1",
  "PANE_2": "اللوحة 2",
  "PANE_3": "اللوحة 3",
  "NONE": "بدون",
  "EDITABLE": "قابل للتعديل",

  "LANGUAGE": "اللغة",
  "FONT_SIZE": "حجم الخط",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "إظهار الملف في عنوان علامة التبويب",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "تبسيط الاسم في عنوان علامة التبويب",
  "SYNCHRONIZED_VIEWING": "عرض متزامن",
  "SHOW_CLASS_METHODS": "إظهار طرق الفصل",

  "WINDOW_THEME": "مظهر النافذة",
  "SYSTEM_THEME": "المظهر الإفتراضي",
  "DARK_THEME": "المظهر الداكن",
  "LIGHT_THEME": "المظهر الفاتح",
  "ONE_DARK_THEME": "مظهر مظلم واحد",
  "SOLARIZED_DARK_THEME": "موضوع داكن بالطاقة الشمسية",
  "SOLARIZED_LIGHT_THEME": "موضوع ضوء الشمس",
  "HIGH_CONTRAST_DARK_THEME": "مظهر داكن عالي التباين",
  "HIGH_CONTRAST_LIGHT_THEME": "موضوع ضوء التباين العالي",
  "ONE_DARK": "ظلام واحد",
  "SOLARIZED_DARK": "الظلام الشمسي",
  "SOLARIZED_LIGHT": "ضوء شمسي",
  "HIGH_CONTRAST_DARK": "عالي التباين داكن",
  "HIGH_CONTRAST_LIGHT": "ضوء عالي التباين",
  "TEXT_AREA_THEME": "موضوع منطقة النص",
  "DEFAULT_RECOMMENDED_LIGHT": "افتراضي (فاتح موصى به)",
  "THEME_MATCH": "تطابق الموضوع (موصى به)",
  "DARK": "داكن (موصى به داكن)",
  "DARK_ALT": "الظلام البديل",
  "DEFAULT_ALT": "افتراضي- بديل",
  "ECLIPSE": "ECLIPSE",
  "INTELLIJ": "INTELLIJ",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid Dark",
  "MONOKAI_DARK": "Monokai Dark",

  "SETTINGS": "إعدادات",
  "COMPILE_ON_SAVE": "تجميع عند الحفظ",
  "COMPILE_ON_REFRESH": "تجميع عند التحديث",
  "REFRESH_ON_VIEW_CHANGE": "تحديث عند تغيير العرض",
  "DECODE_APK_RESOURCES": "فك شفرة موارد APK",
  "APK_CONVERSION": "APK التحويل",
  "APK_CONVERSION_DECODING": "APK التحويل / فك",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "التحقق من التحديث",
  "DELETE_UNKNOWN_LIBS": "حذف أخطاء خارجية / قديمة",
  "FORCE_PURE_ASCII_AS_TEXT": "فرض Ascii كنص نقي",
  "SET_PYTHON_27_EXECUTABLE": "قم بتعيين مسار Python 2.7 التنفيذي",
  "SET_PYTHON_30_EXECUTABLE": "قم بتعيين مسار Python 3.X التنفيذي",
  "SET_JRE_RT_LIBRARY": "قم بتعيين مكتبة JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "تعيين مجلد مكتبة اختياري",
  "SET_JAVAC_EXECUTABLE": "تعيين مسار Javac التنفيذي",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "إعدادات Procyon",
  "CFR_SETTINGS": "إعدادات CFR",
  "FERNFLOWER_SETTINGS": "إعدادات FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "Fernflower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "SMALI",
  "SMALI_DEX": "Smali / Dex",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode Decompiler",
  "DEBUG_HELPERS": "مساعدي التصحيح",
  "APPEND_BRACKETS_TO_LABEL": "إلحاق أقواس بالتسمية",

  "PLUGINS": "الإضافات",
  "OPEN_PLUGIN": "فتح البرنامج المساعد ...",
  "RECENT_PLUGINS": "الإضافات الأخيرة",
  "CODE_SEQUENCE_DIAGRAM": "مخطط تسلسل الكود",
  "MALICIOUS_CODE_SCANNER": "ماسح التعليمات البرمجية الخبيثة",
  "SHOW_MAIN_METHODS": "إظهار الطرق الرئيسية",
  "SHOW_ALL_STRINGS": "عرض كل السلاسل",
  "REPLACE_STRINGS": "استبدل السلاسل",
  "STACK_FRAMES_REMOVER": "مزيل إطارات المكدس",
  "ZKM_STRING_DECRYPTER": "ZKM سلسلة ديكريبتر",
  "ALLATORI_STRING_DECRYPTER": "Allatori سلسلة ديكريبتر",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray ديكريبتر",
  "VIEW_ANDROID_PERMISSIONS": "عرض أذونات Android",
  "VIEW_MANIFEST": "مشاهدة ملف Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "تغيير إصدارات ClassFile",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "مجمع بايت كود",
  "DISASSEMBLER": "المفكك",

  "ERROR": "خطأ",
  "NEW_JAVA_PLUGIN": "البرنامج المساعد الجديد جافا",
  "NEW_JAVASCRIPT_PLUGIN": "البرنامج المساعد الجديد لجافا سكريبت",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "الإصلاح المقترح: انقر فوق تحديث فئة ، إذا فشلت مرة أخرى ، فحاول برنامج فك ترجمة آخر.",
  "SUGGESTED_FIX_COMPILER_ERROR": "الإصلاح المقترح: جرب View> Pane> Krakatau> Bytecode وتمكين التحرير.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "تحذير: لم يتم تحديد برنامج فك تشفير حاليا. جرب View> Pane واختر برنامج فك التحويل البرمجي.",
  "COMPILER_TIP": "ضع في اعتبارك أن معظم برامج فك التشفير لا يمكنها إنتاج فئات قابلة للترجمة",
  "FIRST_OPEN_A_RESOURCE": "افتح أولاً موردًا داخل BCV (ملف فئة أو ملف مضغوط أو ملف مضغوط أو ملف apk)",
  "FIRST_OPEN_A_CLASS": "أولاً ، افتح مورد ملف class داخل BCV (jar ، zip ، apk ، dex)",
  "FIRST_VIEW_A_CLASS": "اعرض أولاً ملف فصل دراسي داخل علامة تبويب.",
  "DRAG_CLASS_JAR": "اسحب class / jar / zip / APK / DEX هنا",

  "YES": "نعم",
  "NO": "لا",
  "ERROR2": "خطأ:",
  "PROCESS2": "عملية:",
  "EXIT_VALUE_IS": "قيمة الخروج هي:",
  "JAVA_COMPILE_FAILED": "فشل ترجمة Java",
  "ERROR_COMPILING_CLASS": "خطأ في تجميع فئة",
  "COMPILER": "ضع في اعتبارك أن معظم برامج فك التشفير لا يمكنها إنتاج فئات قابلة للترجمة",
  "SELECT_LIBRARY_FOLDER": "حدد مجلد المكتبة",
  "SELECT_JAVA_RT": "حدد JRE RT Jar",
  "SELECT_JAVA": "حدد Java Executable",
  "SELECT_JAVAC": "حدد Javac Executable",
  "SELECT_JAVA_TOOLS": "حدد جرة أدوات جافا",
  "SELECT_PYTHON_2": "حدد Python 2.7 Executable",
  "SELECT_PYTHON_3": "حدد Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (أو PyPy 2.7 للسرعة) قابلة للتنفيذ",
  "PYTHON_3_EXECUTABLE": "Python 3.x (أو PyPy 3.x للسرعة) قابل للتنفيذ",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "تحتاج إلى تعيين مسار Python 2.7 (أو PyPy 2.7 للسرعة) القابل للتنفيذ.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "تحتاج إلى تعيين المسار القابل للتنفيذ Python 3.x (أو PyPy 3.x للسرعة).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "تحتاج إلى تعيين مكتبة JRE RT الخاصة بك.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "Java قابل للتنفيذ (داخل JRE C: / ملفات البرنامج / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Javac قابل للتنفيذ (يتطلب JDK C: / ملفات البرنامج / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "جرة أدوات جافا (داخل JDK C: / ملفات البرنامج / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (داخل JRE C: / ملفات البرنامج / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "مجلد مكتبة اختياري (مترجم و Krakatau)",

  "HIDE_BRIDGE_METHODS": "طرق إخفاء الجسر",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "إخفاء أعضاء الطبقة الاصطناعية",
  "DECOMPILE_INNER_CLASSES": "تفكيك الطبقات الداخلية",
  "COLLAPSE_14_CLASS_REFERENCES": "طي 1.4 مراجع الفئة",
  "DECOMPILE_ASSERTIONS": "فك التأكيدات",
  "HIDE_EMPTY_SUPER_INVOCATION": "إخفاء طلب السوبر الفارغ",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "إخفاء المُنشئ الافتراضي الفارغ",
  "DECOMPILE_GENERIC_SIGNATURES": "فك التواقيع العامة",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "افترض العودة وليس رمي الاستثناءات",
  "DECOMPILE_ENUMERATIONS": "فك التعداد",
  "REMOVE_GETCLASS_INVOCATION": "قم بإزالة استدعاء getClass ()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "فسر int 1 على أنها صحيحة منطقية",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "السماح بعدم تعيين سمة تركيبية",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "ضع في اعتبارك الأنواع المجهولة مثل java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "إعادة بناء أسماء المتغيرات من معلومات التصحيح",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "إزالة نطاقات الاستثناء الفارغة",
  "DEINLINE_FINALLY_STRUCTURES": "أخيرًا هياكل Deinline",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "السماح فقط بأحرف ASCII في السلاسل",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "إعادة تسمية الفئات الغامضة وعناصر الفصل",

  "DECODE_ENUM_SWITCH": "فك رمز تبديل التعداد",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "فك شفرة تبديل السلسلة",
  "ARRAYITER": "مصفوفة",
  "COLLECTIONITER": "كوليكتر",
  "INNER_CLASSES": "الطبقات الداخلية",
  "REMOVE_BOILER_PLATE": "قم بإزالة لوحة الغلاية",
  "REMOVE_INNER_CLASS_SYNTHETICS": "قم بإزالة المواد التركيبية للطبقة الداخلية",
  "DECODE_LAMBDAS": "فك شفرة Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "رفع منشئ التهيئة",
  "REMOVE_DEAD_METHODS": "إزالة طرق الميت",
  "REMOVE_BAD_GENERICS": "إزالة Bad Generics",
  "SUGAR_ASSERTS": "يؤكد السكر",
  "SUGAR_BOXING": "ملاكمة السكر",
  "SHOW_VERSION": "عرض الإصدار",
  "DECODE_FINALLY": "فك أخيرا",
  "TIDY_MONITORS": "شاشات مرتبة",
  "LENIENT": "متساهل",
  "DUMP_CLASSPATH": "تفريغ Classpath",
  "COMMENTS": "تعليقات",
  "FORCE_TOP_SORT": "فرض أعلى فرز",
  "FORCE_TOP_SORT_AGGRESS": "فرض العدوان من الدرجة الأولى",
  "FORCE_EXCEPTION_PRUNE": "تقليم استثناء القوة",
  "STRING_BUFFER": "سلسلة العازلة",
  "STRING_BUILDER": "منشئ السلسلة",
  "SILENT": "صامتة",
  "RECOVER": "استعادة",
  "OVERRIDE": "تجاوز",
  "SHOW_INFERRABLE": "إظهار الاستدلال",
  "AEXAGG": "اكساج",
  "FORCE_COND_PROPAGATE": "إجبار كوند على الانتشار",
  "HIDE_UTF": "إخفاء UTF",
  "HIDE_LONG_STRINGS": "إخفاء الجمل الطويلة",
  "COMMENT_MONITORS": "شاشات التعليق",
  "ALLOW_CORRECTING": "السماح بالتصحيح",
  "LABELLED_BLOCKS": "الكتل المصنفة",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "إخفاء الواردات لانج",
  "RECOVER_TYPE_CLASH": "استعادة نوع الصدام",
  "RECOVER_TYPE__HINTS": "استعادة نوع تلميحات",
  "FORCE_RETURNING_IFS": "إجبارية إرجاع IFs",
  "FOR_LOOP_AGG_CAPTURE": "للحصول على Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "قم دائمًا بإنشاء متغير استثناء لكتل ​​الصيد",
  "EXCLUDE_NESTED_TYPES": "استبعاد الأنواع المتداخلة",
  "SHOW_DEBUG_LINE_NUMBERS": "إظهار أرقام خطوط التصحيح",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "تضمين أرقام الأسطر في Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "قم بتضمين تشخيص الأخطاء",
  "SHOW_SYNTHETIC_MEMBERS": "إظهار الأعضاء الاصطناعية",
  "SIMPLIFY_MEMBER_REFERENCES": "تبسيط مراجع الأعضاء",
  "MERGE_VARIABLES": "دمج المتغيرات",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "فرض وسيطات النوع الصريح",
  "FORCE_EXPLICIT_IMPORTS": "فرض الواردات الصريحة",
  "FLATTEN_SWITCH_BLOCKS": "تسطيح كتل التبديل",
  "RETAIN_POINTLESS_SWITCHES": "الاحتفاظ بالمفاتيح غير المجدية",
  "RETAIN_REDUNDANT_CASTS": "الاحتفاظ بالقوالب الزائدة عن الحاجة",
  "UNICODE_OUTPUT_ENABLED": "تم تمكين إخراج Unicode",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - إعادة تحميل الموارد",
  "RELOAD_RESOURCES_CONFIRM": "هل أنت متأكد أنك ترغب في إعادة تحميل الموارد؟",
  "SELECT_FILE_TITLE": "حدد ملفًا أو مجلدًا لفتحه في {BCV}",
  "SELECT_FILE_DESCRIPTION": "ملفات APK أو DEX أو ملفات الفصل الدراسي أو أرشيفات Zip / Jar / War",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "حدد البرنامج المساعد الخارجي",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "المكون الإضافي الخارجي BCV في js أو java أو python أو ruby ​​أو groovy",
  "FOREIGN_LIBRARY_WARNING": "تحذير: مع هذا التبديل من المكتبات القديمة لن تتم إزالتها.\n\rإنها أيضًا مشكلة أمنية.\n\rلا توقف تشغيله إلا إذا كنت تعرف ما تفعله.",
  "RESET_TITLE": "{PRODUCT_NAME} - إعادة تعيين مساحة العمل",
  "RESET_CONFIRM": "هل أنت متأكد أنك تريد إعادة تعيين مساحة العمل؟\n\rسيتم أيضًا إعادة تعيين متصفح الملفات والبحث.",
  "EXIT_TITLE": "{PRODUCT_NAME} - خروج",
  "EXIT_CONFIRM": "هل أنت متأكد من انك تريد الخروج؟",
  "ABOUT_TITLE": "{PRODUCT_NAME} - حول - {WEBSITE} | {يحدد لاحقًا}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - وحدة تحكم المكونات الإضافية",
  "CLOSE_ALL_BUT_THIS": "أغلق الكل ما عدا هذا",
  "CLOSE_TAB": "إغلاق علامة التبويب",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "الرجاء إرسال سجل الخطأ هذا إلى",
  "PLEASE_SEND_RESOURCES": "إذا كنت تمتلك حقوقًا قانونية مناسبة لملف class / jar / apk ذي الصلة ، فيرجى تضمين ذلك أيضًا.",
  "ONE_PLUGIN_AT_A_TIME": "يوجد حاليًا مكون إضافي آخر قيد التشغيل الآن ، يرجى الانتظار حتى ينتهي التنفيذ.",
  "ILLEGAL_ACCESS_ERROR": "الرجاء استخدام Java 15 أو أقدم للقيام بذلك.",


  "FILES": "الملفات",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "بحث سريع عن الملفات (لا يوجد امتداد للملف)",
  "WORK_SPACE": "مساحة العمل",
  "EXACT": "بالضبط",
  "SEARCH": "بحث",
  "SEARCH_FROM": "بحث من:",
  "SEARCH_STRING": "دالة البحث:",
  "SEARCH_REGEX": "البحث في Regex:",
  "OWNER": "مالك:",
  "NAME": "اسم:",
  "DESC": "تنازلي:",
  "SAVE": "حفظ...",
  "SAVE_AS": "حفظ باسم ...",
  "RESULTS": "النتائج",
  "REFRESH": "تحديث",
  "ANNOTATION_NAME": "اسم التعليق التوضيحي",
  "MATCH_CASE": "حالة مباراة",
  "EXACT_PATH": "المسار الدقيق",
  "MIN_SDK_VERSION": "الحد الأدنى من إصدار SDK",
  "PRINT_LINE_NUMBERS": "طباعة أرقام الخطوط"
}

```

`src/main/resources/translations/bengali.json`:

```json
{
  "FILE": "ফাইল",
  "ADD": "যুক্ত করুন ...",
  "NEW_WORKSPACE": "নতুন কর্মক্ষেত্র",
  "RELOAD_RESOURCES": "সংস্থানগুলি পুনরায় লোড করুন",
  "RUN": "চালান",
  "OPEN": "Open...",
  "OPEN_UNSTYLED": "Open",
  "QUICK_OPEN": "Quick Open",
  "DELETE": "Delete",
  "NEW": "New",
  "EXPAND": "Expand",
  "COLLAPSE": "Collapse",
  "COMPILE": "সংকলন",
  "SAVE_AS_RUNNABLE_JAR": "চলমান জার হিসাবে সংরক্ষণ করুন ...",
  "SAVE_AS_ZIP": "জিপ হিসাবে সংরক্ষণ করুন ...",
  "SAVE_AS_DEX": "ডেক্স হিসাবে সংরক্ষণ করুন ...",
  "SAVE_AS_APK": "APK হিসাবে সংরক্ষণ করুন ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "খোলা ক্লাসগুলি ডেকম্পাইল এবং সেভ করুন",
  "DECOMPILE_SAVE_ALL_CLASSES": "ডিসকোপাইল এবং সমস্ত ক্লাস সংরক্ষণ করুন",
  "RECENT_FILES": "সাম্প্রতিক নথিপত্র",
  "ABOUT": "সম্পর্কিত",
  "EXIT": "প্রস্থান",

  "VIEW": "দেখুন",
  "VISUAL_SETTINGS": "ভিজ্যুয়াল সেটিংস",
  "PANE_1": "ফলক ঘ",
  "PANE_2": "ফলক 2",
  "PANE_3": "ফলক 3",
  "NONE": "কিছুই না",
  "EDITABLE": "সম্পাদনাযোগ্য",

  "LANGUAGE": "ভাষা",
  "FONT_SIZE": "অক্ষরের আকার",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "ট্যাব শিরোনামে ফাইল দেখান",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "ট্যাব শিরোনামে নাম সরল করুন",
  "SYNCHRONIZED_VIEWING": "সিঙ্ক্রোনাইজ করা দর্শন",
  "SHOW_CLASS_METHODS": "শ্রেণীর পদ্ধতিগুলি দেখান",

  "WINDOW_THEME": "উইন্ডো থিম",
  "SYSTEM_THEME": "সিস্টেম থিম",
  "DARK_THEME": "গাark় থিম",
  "LIGHT_THEME": "হালকা থিম",
  "ONE_DARK_THEME": "One Dark Theme",
  "SOLARIZED_DARK_THEME": "Solarized Dark Theme",
  "SOLARIZED_LIGHT_THEME": "Solarized Light Theme",
  "HIGH_CONTRAST_DARK_THEME": "High Contrast Dark Theme",
  "HIGH_CONTRAST_LIGHT_THEME": "High Contrast Light Theme",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solarized Light",
  "HIGH_CONTRAST_DARK": "High Contrast Dark",
  "HIGH_CONTRAST_LIGHT": "High Contrast Light",
  "TEXT_AREA_THEME": "পাঠ্য অঞ্চল থিম",
  "DEFAULT_RECOMMENDED_LIGHT": "ডিফল্ট (প্রস্তাবিত আলো)",
  "THEME_MATCH": "Theme Match (Recommended)",
  "DARK": "Dark (Recommended Dark)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "ডিফল্ট-অল্ট",
  "ECLIPSE": "গ্রহন",
  "INTELLIJ": "ইন্টেলিজ",
  "VISUAL_STUDIO": "ভিসুয়াল স্টুডিও",
  "DRUID_DARK": "দ্রুড (গাark়)",
  "MONOKAI_DARK": "মনোোকাই (গাark়)",

  "SETTINGS": "সেটিংস",
  "COMPILE_ON_SAVE": "সংরক্ষণের উপর সংকলন করুন",
  "COMPILE_ON_REFRESH": "রিফ্রেশ করুন",
  "REFRESH_ON_VIEW_CHANGE": "দেখুন পরিবর্তনের উপর রিফ্রেশ",
  "DECODE_APK_RESOURCES": "ডিকোড APK সংস্থানসমূহ",
  "APK_CONVERSION": "APK রূপান্তর",
  "APK_CONVERSION_DECODING": "APK Conversion/Decoding",
  "DEX_TO_JAR": "ডেক্স 2 জার",
  "ENJARIFY": "এনজারাইফাই করা",
  "UPDATE_CHECK": "আপডেট চেক",
  "DELETE_UNKNOWN_LIBS": "বিদেশী / পুরানো Libs মুছুন",
  "FORCE_PURE_ASCII_AS_TEXT": "পাঠ্য হিসাবে বিশুদ্ধ আস্কি জোর করুন",
  "SET_PYTHON_27_EXECUTABLE": "পাইথন 2.7 নির্বাহযোগ্য সেট করুন",
  "SET_PYTHON_30_EXECUTABLE": "পাইথন ৩. এক্স এক্সিকিউটেবল সেট করুন",
  "SET_JRE_RT_LIBRARY": "জেআরই আরটি লাইব্রেরি সেট করুন",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Ptionচ্ছিক গ্রন্থাগার ফোল্ডার সেট করুন",
  "SET_JAVAC_EXECUTABLE": "জাভ্যাক এক্সিকিউটেবল সেট করুন",

  "JAVA": "জাভা",
  "PROCYON_SETTINGS": "Procyon Settings",
  "CFR_SETTINGS": "CFR Settings",
  "FERNFLOWER_SETTINGS": "FernFlower Settings",
  "PROCYON": "প্রোসিওন",
  "CFR": "সিএফআর",
  "FERNFLOWER": "ফার্নফ্লোয়ার",
  "KRAKATAU": "ক্রাকটাউ",
  "JDGUI": "জেডি-জিইউআই",
  "JADX": "জেএডএক্স",
  "SMALI": "স্মালি",
  "SMALI_DEX": "স্মালি / ডেক্স",
  "HEXCODE": "হেক্সকোড",
  "BYTECODE": "বাইটকোড",
  "ASM_TEXTIFY": "এএসএম টেক্সটিফাই",

  "BYTECODE_DECOMPILER": "বাইটকোড ডিকম্পিলার",
  "DEBUG_HELPERS": "ডিবাগ সহায়ক",
  "APPEND_BRACKETS_TO_LABEL": "লেবেলে বন্ধনী যুক্ত করুন",

  "PLUGINS": "প্লাগইনস",
  "OPEN_PLUGIN": "প্লাগিন খুলুন ...",
  "RECENT_PLUGINS": "সাম্প্রতিক প্লাগইনগুলি",
  "CODE_SEQUENCE_DIAGRAM": "কোড সিকোয়েন্স ডায়াগ্রাম",
  "MALICIOUS_CODE_SCANNER": "দূষিত কোড স্ক্যানার",
  "SHOW_MAIN_METHODS": "প্রধান পদ্ধতিগুলি দেখান",
  "SHOW_ALL_STRINGS": "সমস্ত স্ট্রিংগুলি দেখান",
  "REPLACE_STRINGS": "স্ট্রিংগুলি প্রতিস্থাপন করুন",
  "STACK_FRAMES_REMOVER": "স্ট্যাক ফ্রেম রিমুভার",
  "ZKM_STRING_DECRYPTER": "জেডকেএম স্ট্রিং ডিক্রিপ্টার",
  "ALLATORI_STRING_DECRYPTER": "আল্লাটোরি স্ট্রিং ডিক্রিপ্টার",
  "ZSTRINGARRAY_DECRYPTER": "জেডস্ট্রিংআরে ডিক্রিপ্টার",
  "VIEW_ANDROID_PERMISSIONS": "View Android Permissions",
  "VIEW_MANIFEST": "View Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Change ClassFile Versions",



  "PROCYON_DECOMPILER": "প্রোসিওন ডিকম্পিলার",
  "CFR_DECOMPILER": "সিএফআর ডিকম্পিলার",
  "FERNFLOWER_DECOMPILER": "ফার্নফ্লোয়ার ডিকম্পিলার",
  "JADX_DECOMPILER": "জেএডএক্স ডিকম্পিলার",
  "JD_DECOMPILER": "জেডি-জিইউআই ডেকম্পিলার",
  "BYTECODE_DISASSEMBLER": "বাইটকোড বিচ্ছিন্ন",
  "DISASSEMBLER": "বিচ্ছিন্ন",

  "ERROR": "ত্রুটি",
  "NEW_JAVA_PLUGIN": "New Java Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "New Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "প্রস্তাবিত ফিক্স: রিফ্রেশ ক্লাসে ক্লিক করুন, যদি এটি আবার ব্যর্থ হয় তবে অন্য একটি ডিকম্পোলার চেষ্টা করুন।",
  "SUGGESTED_FIX_COMPILER_ERROR": "প্রস্তাবিত ফিক্স: ভিউ> ফলক> ক্র্যাকটাউ> বাইটকোড ব্যবহার করে সম্পাদনযোগ্য সক্ষম করুন।",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "WARNING: No decompiler is currently selected. Try View>Pane and choose a decompiler.",
  "COMPILER_TIP": "Keep in mind most decompilers cannot produce compilable classes",
  "FIRST_OPEN_A_RESOURCE": "First open a resource inside of BCV (class, jar, zip or apk file)",
  "FIRST_OPEN_A_CLASS": "First open a classfile resource inside of BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "First view a class file inside of a tab.",
  "DRAG_CLASS_JAR": "ক্লাস / জার / জিপ / এপিএ / ডিএক্স এখানে টেনে আনুন",

  "YES": "Yes",
  "NO": "No",
  "ERROR2": "Error:",
  "PROCESS2": "Process:",
  "EXIT_VALUE_IS": "Exit Value is:",
  "JAVA_COMPILE_FAILED": "Java Compile Failed",
  "ERROR_COMPILING_CLASS": "Error compiling class",
  "COMPILER": "Keep in mind most decompilers cannot produce compilable classes",
  "SELECT_LIBRARY_FOLDER": "Select Library Folder",
  "SELECT_JAVA_RT": "Select JRE RT Jar",
  "SELECT_JAVA": "Select Java Executable",
  "SELECT_JAVAC": "Select Javac Executable",
  "SELECT_JAVA_TOOLS": "Select Java Tools Jar",
  "SELECT_PYTHON_2": "Select Python 2.7 Executable",
  "SELECT_PYTHON_3": "Select Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Or PyPy 2.7 for speed) Executable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Or PyPy 3.x for speed) Executable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "You need to set your Python 2.7 (or PyPy 2.7 for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "You need to set your Python 3.x (or PyPy 3.x for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "You need to set your JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C:/Program Files/Java/JRE_xx/bin/java.exe)",
  "JAVAC_EXECUTABLE": "Javac Executable (Requires JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C:/Program Files/Java/JDK_xx/lib/tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C:/Program Files/Java/JRE_xx/lib/rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Optional Library Folder (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Hide bridge methods",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Hide synthetic class members",
  "DECOMPILE_INNER_CLASSES": "Decompile inner classes",
  "COLLAPSE_14_CLASS_REFERENCES": "Collapse 1.4 class references",
  "DECOMPILE_ASSERTIONS": "Decompile assertions",
  "HIDE_EMPTY_SUPER_INVOCATION": "Hide empty super invocation",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Hide empty default constructor",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompile generic signatures",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Assume return not throwing exceptions",
  "DECOMPILE_ENUMERATIONS": "Decompile enumerations",
  "REMOVE_GETCLASS_INVOCATION": "Remove getClass() invocation",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpret int 1 as boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Allow for not set synthetic attribute",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Consider nameless types as java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruct variable names from debug info",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Remove empty exception ranges",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finally structures",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Allow only ASCII characters in strings",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Rename ambiguous classes and class elements",

  "DECODE_ENUM_SWITCH": "Decode Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Decode String Switch",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Inner Classes",
  "REMOVE_BOILER_PLATE": "Remove Boiler Plate",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Remove Inner Class Synthetics",
  "DECODE_LAMBDAS": "Decode Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift  Constructor Init",
  "REMOVE_DEAD_METHODS": "Remove Dead Methods",
  "REMOVE_BAD_GENERICS": "Remove Bad Generics",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Show Version",
  "DECODE_FINALLY": "Decode Finally",
  "TIDY_MONITORS": "Tidy Monitors",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Comments",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Recover",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Show Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Hide UTF",
  "HIDE_LONG_STRINGS": "Hide Long Strings",
  "COMMENT_MONITORS": "Comment Monitors",
  "ALLOW_CORRECTING": "Allow Correcting",
  "LABELLED_BLOCKS": "Labelled Blocks",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Recover Type Clash",
  "RECOVER_TYPE__HINTS": "Recover Type  Hints",
  "FORCE_RETURNING_IFS": "Force Returning IFs",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Always Generate Exception Variable For Catch Blocks",
  "EXCLUDE_NESTED_TYPES": "Exclude Nested Types",
  "SHOW_DEBUG_LINE_NUMBERS": "Show Debug Line Numbers",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Include Line Numbers In Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Include Error Diagnostics",
  "SHOW_SYNTHETIC_MEMBERS": "Show Synthetic Members",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplify Member References",
  "MERGE_VARIABLES": "Merge Variables",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Force Explicit Imports",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Switch Blocks",
  "RETAIN_POINTLESS_SWITCHES": "Retain Pointless Switches",
  "RETAIN_REDUNDANT_CASTS": "Retain Redundant Casts",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Reload Resources",
  "RELOAD_RESOURCES_CONFIRM": "Are you sure you wish to reload the resources?",
  "SELECT_FILE_TITLE": "Select File or Folder to open in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Class Files or Zip/Jar/War Archives",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Select External Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin in js, java, python, ruby or groovy",
  "FOREIGN_LIBRARY_WARNING": "WARNING: With this being toggled off outdated libraries will NOT be removed.\n\rIt's also a security issue.\n\rONLY TURN IT OFF IF YOU KNOW WHAT YOU'RE DOING.",
  "RESET_TITLE": "{PRODUCT_NAME} - Reset Workspace",
  "RESET_CONFIRM": "Are you sure you want to reset the workspace?\n\rIt will also reset your file navigator and search.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Are you sure you want to exit?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - About - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Close All But This",
  "CLOSE_TAB": "Close Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Please send this error log to",
  "PLEASE_SEND_RESOURCES": "If you hold appropriate legal rights to the relevant class/jar/apk file please include that as well.",
  "ONE_PLUGIN_AT_A_TIME": "There is currently another plugin running right now, please wait for that to finish executing.",
  "ILLEGAL_ACCESS_ERROR": "Please use Java 15 or older to do this.",


  "FILES": "নথি পত্র",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "দ্রুত ফাইল অনুসন্ধান (কোনও ফাইল এক্সটেনশন নেই)",
  "WORK_SPACE": "কাজের জায়গা",
  "EXACT": "ঠিক",
  "SEARCH": "অনুসন্ধান করুন",
  "SEARCH_FROM": "থেকে অনুসন্ধান করুন:",
  "SEARCH_STRING": "অনুসন্ধান স্ট্রিং:",
  "SEARCH_REGEX": "অনুসন্ধান রেজেক্স:",
  "OWNER": "মালিক:",
  "NAME": "নাম:",
  "DESC": "ডেস্ক:",
  "SAVE": "Save...",
  "SAVE_AS": "Save As...",
  "RESULTS": "Results",
  "REFRESH": "রিফ্রেশ",
  "ANNOTATION_NAME": "Annotation Name",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Exact Path",
  "MIN_SDK_VERSION": "Minimum SDK version",
  "PRINT_LINE_NUMBERS": "Print Line Numbers"
}

```

`src/main/resources/translations/bulgarian.json`:

```json
{
  "FILE": "Файл",
  "ADD": "Добавете...",
  "NEW_WORKSPACE": "Ново работно пространство",
  "RELOAD_RESOURCES": "Презареждане на ресурсите",
  "RUN": "Изпълнявайте",
  "OPEN": "Отворено...",
  "OPEN_UNSTYLED": "Отвори",
  "QUICK_OPEN": "Бързо отваряне",
  "DELETE": "Изтриване на",
  "NEW": "Нов",
  "EXPAND": "Разширете",
  "COLLAPSE": "Свиване",
  "COMPILE": "Компилиране",
  "SAVE_AS_RUNNABLE_JAR": "Запазване като изпълним буркан...",
  "SAVE_AS_ZIP": "Запазване като Zip...",
  "SAVE_AS_DEX": "Запазване като DEX...",
  "SAVE_AS_APK": "Запазете като APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Декомпилиране и запазване на отворени класове",
  "DECOMPILE_SAVE_ALL_CLASSES": "Декомпилиране и запазване на всички класове",
  "RECENT_FILES": "Последни файлове",
  "ABOUT": "За",
  "EXIT": "Изход",

  "VIEW": "Вижте",
  "VISUAL_SETTINGS": "Визуални настройки",
  "PANE_1": "Панел 1",
  "PANE_2": "Панел 2",
  "PANE_3": "Панел 3",
  "NONE": "Няма",
  "EDITABLE": "Редактируем",

  "LANGUAGE": "Език",
  "FONT_SIZE": "Размер на шрифта",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Показване на файла в заглавието на раздела",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Опростяване на името в заглавието на раздела",
  "SYNCHRONIZED_VIEWING": "Синхронизирано гледане",
  "SHOW_CLASS_METHODS": "Показване на методите на класа",

  "WINDOW_THEME": "Тема на прозореца",
  "SYSTEM_THEME": "Тема на системата",
  "DARK_THEME": "Тъмна тема",
  "LIGHT_THEME": "Светлинна тема",
  "ONE_DARK_THEME": "Една тъмна тема",
  "SOLARIZED_DARK_THEME": "Соларизирана тъмна тема",
  "SOLARIZED_LIGHT_THEME": "Тема за соларна светлина",
  "HIGH_CONTRAST_DARK_THEME": "Висококонтрастна тъмна тема",
  "HIGH_CONTRAST_LIGHT_THEME": "Висококонтрастна тема за светлина",
  "ONE_DARK": "Един тъмен",
  "SOLARIZED_DARK": "Соларизиран тъмен",
  "SOLARIZED_LIGHT": "Соларна светлина",
  "HIGH_CONTRAST_DARK": "Висококонтрастен тъмен",
  "HIGH_CONTRAST_LIGHT": "Висококонтрастна светлина",
  "TEXT_AREA_THEME": "Тема на текстовата област",
  "DEFAULT_RECOMMENDED_LIGHT": "По подразбиране (препоръчителна светлина)",
  "THEME_MATCH": "Тематичен мач (препоръчително)",
  "DARK": "Dark (Препоръчва се Dark)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Затъмнение",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Друид (тъмен)",
  "MONOKAI_DARK": "Monokai (Dark)",

  "SETTINGS": "Настройки",
  "COMPILE_ON_SAVE": "Компилиране при запазване",
  "COMPILE_ON_REFRESH": "Компилиране при опресняване",
  "REFRESH_ON_VIEW_CHANGE": "Опресняване при промяна на изгледа",
  "DECODE_APK_RESOURCES": "Decode APK ресурси",
  "APK_CONVERSION": "Конвертиране на APK",
  "APK_CONVERSION_DECODING": "Конвертиране на APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Проверка за актуализация",
  "DELETE_UNKNOWN_LIBS": "Изтриване на чуждестранни",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii като текст",
  "SET_PYTHON_27_EXECUTABLE": "Задаване на изпълнимата версия на Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Задаване на изпълнимата версия на Python 3.X",
  "SET_JRE_RT_LIBRARY": "Задаване на библиотека JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Задаване на опционална папка на библиотеката",
  "SET_JAVAC_EXECUTABLE": "Задаване на изпълним Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Настройки на Procyon",
  "CFR_SETTINGS": "Настройки на CFR",
  "FERNFLOWER_SETTINGS": "Настройки на FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Кракатау",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Шестнайсетичен код",
  "BYTECODE": "Байткод",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Декомпилатор на байткод",
  "DEBUG_HELPERS": "Помощници за отстраняване на грешки",
  "APPEND_BRACKETS_TO_LABEL": "Прилагане на скоби към етикета",

  "PLUGINS": "Плъгини",
  "OPEN_PLUGIN": "Отворете плъгина...",
  "RECENT_PLUGINS": "Последни плъгини",
  "CODE_SEQUENCE_DIAGRAM": "Диаграма на последователността на кода",
  "MALICIOUS_CODE_SCANNER": "Сканер за злонамерен код",
  "SHOW_MAIN_METHODS": "Показване на основните методи",
  "SHOW_ALL_STRINGS": "Покажи всички струни",
  "REPLACE_STRINGS": "Замяна на низове",
  "STACK_FRAMES_REMOVER": "Премахване на стекови рамки",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Декриптор",
  "VIEW_ANDROID_PERMISSIONS": "Преглед на разрешенията за Android",
  "VIEW_MANIFEST": "Преглед на манифеста",
  "CHANGE_CLASSFILE_VERSIONS": "Промяна на версиите на файловете с класове",



  "PROCYON_DECOMPILER": "Декомпилатор Procyon",
  "CFR_DECOMPILER": "Декомпилатор на CFR",
  "FERNFLOWER_DECOMPILER": "Декомпилатор FernFlower",
  "JADX_DECOMPILER": "Декомпилатор на JADX",
  "JD_DECOMPILER": "Декомпилатор на JD-GUI",
  "BYTECODE_DISASSEMBLER": "Дезасемблер на байткод",
  "DISASSEMBLER": "Дезасемблер",

  "ERROR": "Грешка",
  "NEW_JAVA_PLUGIN": "Нов плъгин за Java",
  "NEW_JAVASCRIPT_PLUGIN": "Нов плъгин за Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Предложена поправка: Кликнете върху класа за опресняване, ако отново не успее, опитайте с друг декомпилатор.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Предложена поправка: Опитайте View>Pane>Krakatau>Bytecode и разрешете Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ПРЕДУПРЕЖДЕНИЕ: В момента не е избран декомпилатор. Опитайте View>Pane и изберете декомпилатор.",
  "COMPILER_TIP": "Имайте предвид, че повечето декомпилатори не могат да създават компилируеми класове",
  "FIRST_OPEN_A_RESOURCE": "Първо отворете ресурс в BCV (клас, jar, zip или apk файл)",
  "FIRST_OPEN_A_CLASS": "Първо отворете ресурс на classfile в BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Първо прегледайте файла на класа в раздела.",
  "DRAG_CLASS_JAR": "Клас Drag",

  "YES": "Да",
  "NO": "Не",
  "ERROR2": "Грешка:",
  "PROCESS2": "Процес:",
  "EXIT_VALUE_IS": "Стойността на изхода е:",
  "JAVA_COMPILE_FAILED": "Неуспешно компилиране на Java",
  "ERROR_COMPILING_CLASS": "Грешка при компилирането на класа",
  "COMPILER": "Имайте предвид, че повечето декомпилатори не могат да създават компилируеми класове",
  "SELECT_LIBRARY_FOLDER": "Изберете папка на библиотеката",
  "SELECT_JAVA_RT": "Изберете JRE RT Jar",
  "SELECT_JAVA": "Изберете Java Executable",
  "SELECT_JAVAC": "Изберете Javac Executable",
  "SELECT_JAVA_TOOLS": "Изберете Java Tools Jar",
  "SELECT_PYTHON_2": "Изберете Python 2.7 Executable",
  "SELECT_PYTHON_3": "Изберете Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (или PyPy 2.7 за бързина) Изпълним",
  "PYTHON_3_EXECUTABLE": "Python 3.x (или PyPy 3.x за бързина) Изпълним",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Трябва да зададете пътя за изпълнение на Python 2.7 (или PyPy 2.7 за бързина).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Трябва да зададете пътя за изпълнение на Python 3.x (или PyPy 3.x за бързина).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Трябва да зададете своята библиотека JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Изпълним файл на Java (вътре в JRE C:",
  "JAVAC_EXECUTABLE": "Изпълним Javac (изисква JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (вътре в JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (вътре в JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Допълнителна папка на библиотеката (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Скриване на методите за мостове",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Скриване на синтетични членове на класа",
  "DECOMPILE_INNER_CLASSES": "Декомпилиране на вътрешни класове",
  "COLLAPSE_14_CLASS_REFERENCES": "Свиване 1.4 препратки към класове",
  "DECOMPILE_ASSERTIONS": "Декомпилиране на твърденията",
  "HIDE_EMPTY_SUPER_INVOCATION": "Скриване на празно супер извикване",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Скриване на празен конструктор по подразбиране",
  "DECOMPILE_GENERIC_SIGNATURES": "Декомпилиране на генерични подписи",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Предполагаме, че връщането не хвърля изключения",
  "DECOMPILE_ENUMERATIONS": "Декомпилиране на изброявания",
  "REMOVE_GETCLASS_INVOCATION": "Премахване на извикването getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Интерпретиране на int 1 като булева true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Позволява да не се задава синтетичен атрибут",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Разглеждайте безименните типове като java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Възстановяване на имената на променливите от информацията за дебъгване",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Премахване на празни диапазони за изключения",
  "DEINLINE_FINALLY_STRUCTURES": "Окончателно деинлайн структури",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Разрешаване само на ASCII символи в низовете",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Преименуване на двусмислени класове и елементи на класове",

  "DECODE_ENUM_SWITCH": "Превключвател за декодиране на енум",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Декодиране на низовия превключвател",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Вътрешни класове",
  "REMOVE_BOILER_PLATE": "Премахване на плочата на котела",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Премахване на синтетиката на вътрешния клас",
  "DECODE_LAMBDAS": "Декодиране на ламбда",
  "LIFT__CONSTRUCTOR_INIT": "Конструктор Lift Init",
  "REMOVE_DEAD_METHODS": "Премахване на мъртви методи",
  "REMOVE_BAD_GENERICS": "Премахване на лоши генерици",
  "SUGAR_ASSERTS": "Захар твърди",
  "SUGAR_BOXING": "Захарният бокс",
  "SHOW_VERSION": "Показване на версията",
  "DECODE_FINALLY": "Декодиране накрая",
  "TIDY_MONITORS": "Подредени монитори",
  "LENIENT": "Снизходителен",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Коментари",
  "FORCE_TOP_SORT": "Принудително сортиране на върха",
  "FORCE_TOP_SORT_AGGRESS": "Сила Топ Сортиране Агресия",
  "FORCE_EXCEPTION_PRUNE": "Принудително изключване на сливи",
  "STRING_BUFFER": "Буфер за низове",
  "STRING_BUILDER": "Струнен конструктор",
  "SILENT": "Silent",
  "RECOVER": "Възстановяване на",
  "OVERRIDE": "Отмяна на",
  "SHOW_INFERRABLE": "Покажете Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Сила Условие Разпространение",
  "HIDE_UTF": "Скриване на UTF",
  "HIDE_LONG_STRINGS": "Скриване на дълги струни",
  "COMMENT_MONITORS": "Монитори за коментари",
  "ALLOW_CORRECTING": "Позволява коригиране",
  "LABELLED_BLOCKS": "Етикетирани блокове",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Скрийте Lang внос",
  "RECOVER_TYPE_CLASH": "Възстановяване на типа сблъсък",
  "RECOVER_TYPE__HINTS": "Съвети за възстановяване на типа",
  "FORCE_RETURNING_IFS": "Сила за връщане на IF",
  "FOR_LOOP_AGG_CAPTURE": "За цикъл AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Винаги генерирайте променлива за изключения за блоковете Catch",
  "EXCLUDE_NESTED_TYPES": "Изключване на вложени типове",
  "SHOW_DEBUG_LINE_NUMBERS": "Показване на номерата на линиите за дебъгване",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Включване на номера на редове в Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Включване на диагностика на грешки",
  "SHOW_SYNTHETIC_MEMBERS": "Показване на синтетични членове",
  "SIMPLIFY_MEMBER_REFERENCES": "Опростяване на препратките към членовете",
  "MERGE_VARIABLES": "Сливане на променливи",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Форсиране на явни аргументи за тип",
  "FORCE_EXPLICIT_IMPORTS": "Налагане на явен внос",
  "FLATTEN_SWITCH_BLOCKS": "Изравняване на блоковете за превключване",
  "RETAIN_POINTLESS_SWITCHES": "Запазване на безсмислени превключватели",
  "RETAIN_REDUNDANT_CASTS": "Запазване на излишните състави",
  "UNICODE_OUTPUT_ENABLED": "Изходът Unicode е разрешен",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Презареждане на ресурсите",
  "RELOAD_RESOURCES_CONFIRM": "Сигурни ли сте, че искате да презаредите ресурсите?",
  "SELECT_FILE_TITLE": "Изберете Файл или Папка за отваряне в {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, файлове с класове или Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Изберете Външен плъгин",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Външен плъгин на BCV в js, java, python, ruby или groovy",
  "FOREIGN_LIBRARY_WARNING": "ПРЕДУПРЕЖДЕНИЕ: Ако тази опция е изключена, остарелите библиотеки няма да бъдат премахнати.\n\rТова е и проблем на сигурността.\n\rИЗКЛЮЧВАЙТЕ ГО САМО АКО ЗНАЕТЕ КАКВО ПРАВИТЕ.",
  "RESET_TITLE": "{PRODUCT_NAME} - Нулиране на работното пространство",
  "RESET_CONFIRM": "Сигурни ли сте, че искате да възстановите работното пространство?\n\rТова също така ще нулира файловия навигатор и търсенето.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Изход",
  "EXIT_CONFIRM": "Сигурни ли сте, че искате да излезете?",
  "ABOUT_TITLE": "{TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Конзола за плъгини",
  "CLOSE_ALL_BUT_THIS": "Затвори всичко, освен това",
  "CLOSE_TAB": "Затваряне на раздела",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Моля, изпратете този дневник за грешки на адрес",
  "PLEASE_SEND_RESOURCES": "Ако притежавате съответните законни права върху съответния клас",
  "ONE_PLUGIN_AT_A_TIME": "В момента се изпълнява друг плъгин, моля, изчакайте да приключи изпълнението му.",
  "ILLEGAL_ACCESS_ERROR": "Моля, използвайте Java 15 или по-нова версия, за да направите това.",


  "FILES": "Файлове",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Бързо търсене на файлове (без разширение на файла)",
  "WORK_SPACE": "Работно пространство",
  "EXACT": "Точно",
  "SEARCH": "Търсене",
  "SEARCH_FROM": "Търсене от:",
  "SEARCH_STRING": "Редица за търсене:",
  "SEARCH_REGEX": "Речник за търсене:",
  "OWNER": "Собственик:",
  "NAME": "Име:",
  "DESC": "Описание:",
  "SAVE": "Запазете...",
  "SAVE_AS": "Запази като...",
  "RESULTS": "Резултати",
  "REFRESH": "Обновяване",
  "ANNOTATION_NAME": "Име на анотацията",
  "MATCH_CASE": "Случай на мач",
  "EXACT_PATH": "Точен път",
  "MIN_SDK_VERSION": "Минимална версия на SDK",
  "PRINT_LINE_NUMBERS": "Отпечатване на номера на редове"
}

```

`src/main/resources/translations/croatian.json`:

```json
{
  "FILE": "Datoteka",
  "ADD": "Dodati...",
  "NEW_WORKSPACE": "Novi radni prostor",
  "RELOAD_RESOURCES": "Ponovno učitaj resurse",
  "RUN": "Trčanje",
  "OPEN": "Otvorena...",
  "OPEN_UNSTYLED": "Otvorena",
  "QUICK_OPEN": "Brzo otvaranje",
  "DELETE": "Izbrisati",
  "NEW": "Novi",
  "EXPAND": "Proširiti",
  "COLLAPSE": "Kolaps",
  "COMPILE": "Sastaviti",
  "SAVE_AS_RUNNABLE_JAR": "Spremi kao runable Jar...",
  "SAVE_AS_ZIP": "Spremi kao ZIP...",
  "SAVE_AS_DEX": "Spremi kao DEX...",
  "SAVE_AS_APK": "Spremi kao APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompilirajte i spremite otvorene klase",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompilirajte i spremite sve klase",
  "RECENT_FILES": "Nedavne datoteke",
  "ABOUT": "Oko",
  "EXIT": "Izlaz",

  "VIEW": "Pogled",
  "VISUAL_SETTINGS": "Vizualne postavke",
  "PANE_1": "Okno 1",
  "PANE_2": "Okno 2",
  "PANE_3": "Okno 3",
  "NONE": "Nijedan",
  "EDITABLE": "Može se uređivati",

  "LANGUAGE": "Jezik",
  "FONT_SIZE": "Veličina fonta",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Prikaži datoteku u naslovu kartice",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Pojednostavite naziv u naslovu kartice",
  "SYNCHRONIZED_VIEWING": "Sinkronizirano gledanje",
  "SHOW_CLASS_METHODS": "Prikaži metode razreda",

  "WINDOW_THEME": "Tema prozora",
  "SYSTEM_THEME": "Tema sustava",
  "DARK_THEME": "Tamna tema",
  "LIGHT_THEME": "Svjetlosna tema",
  "ONE_DARK_THEME": "Jedna mračna tema",
  "SOLARIZED_DARK_THEME": "Solarizirana tamna tema",
  "SOLARIZED_LIGHT_THEME": "Tema solariziranog svjetla",
  "HIGH_CONTRAST_DARK_THEME": "Tamna tema visokog kontrasta",
  "HIGH_CONTRAST_LIGHT_THEME": "Svjetlosna tema visokog kontrasta",
  "ONE_DARK": "Jedan Tamni",
  "SOLARIZED_DARK": "Solarizirana tamna",
  "SOLARIZED_LIGHT": "Solarizirano svjetlo",
  "HIGH_CONTRAST_DARK": "Visok kontrast Tamno",
  "HIGH_CONTRAST_LIGHT": "Svjetlo visokog kontrasta",
  "TEXT_AREA_THEME": "Tema područja teksta",
  "DEFAULT_RECOMMENDED_LIGHT": "Zadano (preporučeno svjetlo)",
  "THEME_MATCH": "Podudaranje teme (preporučeno)",
  "DARK": "Tamno (preporučeno tamno)",
  "DARK_ALT": "Tamno-Alt",
  "DEFAULT_ALT": "Zadano-Alt",
  "ECLIPSE": "Zasjeniti",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Vizualni studio",
  "DRUID_DARK": "druid (mračni)",
  "MONOKAI_DARK": "Monokai (tamno)",

  "SETTINGS": "Postavke",
  "COMPILE_ON_SAVE": "Sastavite pri spremanju",
  "COMPILE_ON_REFRESH": "Sastavite pri osvježavanju",
  "REFRESH_ON_VIEW_CHANGE": "Osvježi prilikom promjene pogleda",
  "DECODE_APK_RESOURCES": "Dekodirajte APK resurse",
  "APK_CONVERSION": "APK konverzija",
  "APK_CONVERSION_DECODING": "APK konverzija/dekodiranje",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Provjera ažuriranja",
  "DELETE_UNKNOWN_LIBS": "Izbrišite strane/zastarjele biblioteke",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii kao tekst",
  "SET_PYTHON_27_EXECUTABLE": "Postavite izvršnu datoteku Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Postavite izvršnu datoteku Python 3.X",
  "SET_JRE_RT_LIBRARY": "Postavite JRE RT knjižnicu",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Postavite izbornu mapu knjižnice",
  "SET_JAVAC_EXECUTABLE": "Postavite Javac izvršnu datoteku",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon postavke",
  "CFR_SETTINGS": "CFR postavke",
  "FERNFLOWER_SETTINGS": "FernFlower postavke",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali/Dex",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Dekompilator bajtkoda",
  "DEBUG_HELPERS": "Pomoćnici za ispravljanje pogrešaka",
  "APPEND_BRACKETS_TO_LABEL": "Dodaj zagrade na oznaku",

  "PLUGINS": "Dodaci",
  "OPEN_PLUGIN": "Otvori dodatak...",
  "RECENT_PLUGINS": "Nedavni dodaci",
  "CODE_SEQUENCE_DIAGRAM": "Dijagram slijeda koda",
  "MALICIOUS_CODE_SCANNER": "Skener zlonamjernog koda",
  "SHOW_MAIN_METHODS": "Prikaži glavne metode",
  "SHOW_ALL_STRINGS": "Prikaži sve nizove",
  "REPLACE_STRINGS": "Zamijenite nizove",
  "STACK_FRAMES_REMOVER": "Uklanjanje stog okvira",
  "ZKM_STRING_DECRYPTER": "ZKM dešifriranje nizova",
  "ALLATORI_STRING_DECRYPTER": "Allatori string decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Pregledajte dopuštenja za Android",
  "VIEW_MANIFEST": "Prikaži manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Promjena verzija ClassFile",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR dekompilator",
  "FERNFLOWER_DECOMPILER": "FernFlower dekompilator",
  "JADX_DECOMPILER": "JADX dekompilator",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Rastavljač",

  "ERROR": "Greška",
  "NEW_JAVA_PLUGIN": "Novi Java dodatak",
  "NEW_JAVASCRIPT_PLUGIN": "Novi Javascript dodatak",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Predloženi popravak: Kliknite Osvježi klasu, ako ponovno ne uspije pokušajte s drugim dekompilatorom.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Predloženi popravak: pokušajte Pogled>Okno>Krakatau>Bytecode i omogućite Uređivanje.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "UPOZORENJE: Trenutno nije odabran nijedan dekompilator. Pokušajte Pogled> Okno i odaberite dekompilator.",
  "COMPILER_TIP": "Imajte na umu da većina dekompilatora ne može proizvesti klase koje se mogu kompilirati",
  "FIRST_OPEN_A_RESOURCE": "Prvo otvorite resurs unutar BCV-a (klasa, jar, zip ili apk datoteka)",
  "FIRST_OPEN_A_CLASS": "Prvo otvorite izvor datoteke klase unutar BCV-a (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Prvo pogledajte datoteku klase unutar kartice.",
  "DRAG_CLASS_JAR": "Povucite klasu/jar/zip/APK/DEX ovdje",

  "YES": "Da",
  "NO": "Ne",
  "ERROR2": "pogreška:",
  "PROCESS2": "Postupak:",
  "EXIT_VALUE_IS": "Izlazna vrijednost je:",
  "JAVA_COMPILE_FAILED": "Java kompajliranje nije uspjelo",
  "ERROR_COMPILING_CLASS": "Pogreška pri sastavljanju klase",
  "COMPILER": "Imajte na umu da većina dekompilatora ne može proizvesti klase koje se mogu kompilirati",
  "SELECT_LIBRARY_FOLDER": "Odaberite mapu knjižnice",
  "SELECT_JAVA_RT": "Odaberite JRE RT Jar",
  "SELECT_JAVA": "Odaberite Java Executable",
  "SELECT_JAVAC": "Odaberite Javac Executable",
  "SELECT_JAVA_TOOLS": "Odaberite Java Tools Jar",
  "SELECT_PYTHON_2": "Odaberite Python 2.7 Executable",
  "SELECT_PYTHON_3": "Odaberite Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (ili PyPy 2.7 za brzinu) Izvršni",
  "PYTHON_3_EXECUTABLE": "Python 3.x (ili PyPy 3.x za brzinu) Izvršni",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Morate postaviti svoju izvršnu putanju za Python 2.7 (ili PyPy 2.7 za brzinu).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Morate postaviti svoju izvršnu putanju za Python 3.x (ili PyPy 3.x za brzinu).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Morate postaviti svoju JRE RT knjižnicu.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java izvršna (unutar JRE C:/Programske datoteke/Java/JRE_xx/bin/java.exe)",
  "JAVAC_EXECUTABLE": "Javac izvršni (zahtijeva JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (unutar JDK C:/Program Files/Java/JDK_xx/lib/tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (unutar JRE C:/Programske datoteke/Java/JRE_xx/lib/rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Izborna mapa knjižnice (prevoditelj & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Sakrij metode premošćavanja",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Sakrij sintetičke članove klase",
  "DECOMPILE_INNER_CLASSES": "Dekompilirajte unutarnje klase",
  "COLLAPSE_14_CLASS_REFERENCES": "Sažmi reference razreda 1.4",
  "DECOMPILE_ASSERTIONS": "Dekompilirajte tvrdnje",
  "HIDE_EMPTY_SUPER_INVOCATION": "Sakrij prazan superpoziv",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Sakrij prazan zadani konstruktor",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompilirajte generičke potpise",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Pretpostavimo da povratak ne baca iznimke",
  "DECOMPILE_ENUMERATIONS": "Dekompilirajte nabrajanja",
  "REMOVE_GETCLASS_INVOCATION": "Uklonite pozivanje getClass().",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretirajte int 1 kao boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Dopusti sintetički atribut koji nije postavljen",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Razmotrite bezimene tipove kao java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonstruirajte nazive varijabli iz informacija o otklanjanju pogrešaka",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Uklonite prazne raspone izuzetaka",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline konačno strukturira",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Dopusti samo ASCII znakove u nizovima",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Preimenujte dvosmislene klase i elemente klase",

  "DECODE_ENUM_SWITCH": "Dekodiranje Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Prekidač dekodiranja niza",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Kolekcionar",
  "INNER_CLASSES": "Unutarnje klase",
  "REMOVE_BOILER_PLATE": "Uklonite ploču kotla",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Uklonite sintetiku unutarnje klase",
  "DECODE_LAMBDAS": "Dešifrirajte lambda",
  "LIFT__CONSTRUCTOR_INIT": "Konstruktor lifta Init",
  "REMOVE_DEAD_METHODS": "Uklonite mrtve metode",
  "REMOVE_BAD_GENERICS": "Uklonite loše generičke proizvode",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Šećerni boks",
  "SHOW_VERSION": "Prikaži verziju",
  "DECODE_FINALLY": "Dešifrirajte konačno",
  "TIDY_MONITORS": "Uredni monitori",
  "LENIENT": "Blagi",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Komentari",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Prisilna iznimka Obrezivanje",
  "STRING_BUFFER": "Međuspremnik nizova",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Tiho",
  "RECOVER": "Oporavak",
  "OVERRIDE": "Nadjačati",
  "SHOW_INFERRABLE": "Prikaži Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagirati",
  "HIDE_UTF": "Sakrij UTF",
  "HIDE_LONG_STRINGS": "Sakrij duge žice",
  "COMMENT_MONITORS": "Monitori komentara",
  "ALLOW_CORRECTING": "Dopusti ispravljanje",
  "LABELLED_BLOCKS": "Označeni blokovi",
  "J14CLASSOBJ": "J14KlasaOBJ",
  "HIDE_LANG_IMPORTS": "Sakrij uvoz jezika",
  "RECOVER_TYPE_CLASH": "Recover Type Clash",
  "RECOVER_TYPE__HINTS": "Savjeti za oporavak vrste",
  "FORCE_RETURNING_IFS": "Force Returning IF",
  "FOR_LOOP_AGG_CAPTURE": "Za AGG hvatanje petlje",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Uvijek generiraj varijablu izuzetaka za blokove hvatanja",
  "EXCLUDE_NESTED_TYPES": "Isključi ugniježđene vrste",
  "SHOW_DEBUG_LINE_NUMBERS": "Prikaži brojeve redaka za otklanjanje pogrešaka",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Uključite brojeve redaka u bajtkod",
  "INCLUDE_ERROR_DIAGNOSTICS": "Uključuje dijagnostiku grešaka",
  "SHOW_SYNTHETIC_MEMBERS": "Prikaži sintetičke članove",
  "SIMPLIFY_MEMBER_REFERENCES": "Pojednostavite reference članova",
  "MERGE_VARIABLES": "Spoji varijable",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Prisilite eksplicitne argumente tipa",
  "FORCE_EXPLICIT_IMPORTS": "Prisilite eksplicitni uvoz",
  "FLATTEN_SWITCH_BLOCKS": "Izravnajte blokove prekidača",
  "RETAIN_POINTLESS_SWITCHES": "Zadržite besmislene prekidače",
  "RETAIN_REDUNDANT_CASTS": "Zadrži suvišne glumce",
  "UNICODE_OUTPUT_ENABLED": "Unicode izlaz je omogućen",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Ponovno učitaj resurse",
  "RELOAD_RESOURCES_CONFIRM": "Jeste li sigurni da želite ponovno učitati resurse?",
  "SELECT_FILE_TITLE": "Odaberite datoteku ili mapu za otvaranje u {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK-ovi, DEX, Class Files ili Zip/Jar/War arhive",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Odaberite Vanjski dodatak",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV vanjski dodatak u js, java, python, ruby ​​ili groovy",
  "FOREIGN_LIBRARY_WARNING": "UPOZORENJE: Ako se ovo isključi, zastarjele knjižnice NEĆE biti uklonjene.\n\rTo je također sigurnosni problem.\n\rISKLJUČITE SAMO AKO ZNATE ŠTO RADITE.",
  "RESET_TITLE": "{PRODUCT_NAME} – Poništi radni prostor",
  "RESET_CONFIRM": "Jeste li sigurni da želite resetirati radni prostor?\n\rTakođer će poništiti vaš navigator datoteka i pretraživanje.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Izađi",
  "EXIT_CONFIRM": "Jesi li siguran da želiš izaći?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - O - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} – konzola dodataka",
  "CLOSE_ALL_BUT_THIS": "Zatvori sve osim ovoga",
  "CLOSE_TAB": "Zatvori karticu",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Molimo pošaljite ovaj zapisnik grešaka na",
  "PLEASE_SEND_RESOURCES": "Ako posjedujete odgovarajuća zakonska prava na relevantnu datoteku klase/jar/apk, uključite i to.",
  "ONE_PLUGIN_AT_A_TIME": "Trenutačno je pokrenut još jedan dodatak, pričekajte da se završi.",
  "ILLEGAL_ACCESS_ERROR": "Za to koristite Javu 15 ili stariju.",


  "FILES": "Datoteke",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Brzo pretraživanje datoteka (bez ekstenzije datoteke)",
  "WORK_SPACE": "Radni prostor",
  "EXACT": "Točno",
  "SEARCH": "traži",
  "SEARCH_FROM": "Traži od:",
  "SEARCH_STRING": "Niz za pretraživanje:",
  "SEARCH_REGEX": "Redovni izraz pretraživanja:",
  "OWNER": "Vlasnik:",
  "NAME": "Ime:",
  "DESC": "opis:",
  "SAVE": "Uštedjeti...",
  "SAVE_AS": "Spremi kao...",
  "RESULTS": "Rezultati",
  "REFRESH": "Osvježiti",
  "ANNOTATION_NAME": "Naziv napomene",
  "MATCH_CASE": "Kutija šibica",
  "EXACT_PATH": "Točan put",
  "MIN_SDK_VERSION": "Minimalna verzija SDK-a",
  "PRINT_LINE_NUMBERS": "Ispis brojeva redaka"
}

```

`src/main/resources/translations/czech.json`:

```json
{
  "FILE": "Soubor",
  "ADD": "Přidat...",
  "NEW_WORKSPACE": "Nový pracovní prostor",
  "RELOAD_RESOURCES": "Znovunačtení zdrojů",
  "RUN": "Spustit",
  "OPEN": "Otevřete...",
  "OPEN_UNSTYLED": "Otevřít",
  "QUICK_OPEN": "Rychlé otevření",
  "DELETE": "Odstranit",
  "NEW": "Nový",
  "EXPAND": "Rozbalit",
  "COLLAPSE": "Sbalit",
  "COMPILE": "Kompilace",
  "SAVE_AS_RUNNABLE_JAR": "Uložit jako spustitelnou sklenici...",
  "SAVE_AS_ZIP": "Uložit jako Zip...",
  "SAVE_AS_DEX": "Uložit jako DEX...",
  "SAVE_AS_APK": "Uložit jako APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompilace a uložení otevřených tříd",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompilace a uložení všech tříd",
  "RECENT_FILES": "Nedávné soubory",
  "ABOUT": "O stránkách",
  "EXIT": "Exit",

  "VIEW": "Zobrazit",
  "VISUAL_SETTINGS": "Vizuální nastavení",
  "PANE_1": "Panel 1",
  "PANE_2": "Panel 2",
  "PANE_3": "Panel 3",
  "NONE": "Žádné",
  "EDITABLE": "Upravitelné",

  "LANGUAGE": "Jazyk",
  "FONT_SIZE": "Velikost písma",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Zobrazit soubor v názvu karty",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Zjednodušení názvu v názvu karty",
  "SYNCHRONIZED_VIEWING": "Synchronizované zobrazení",
  "SHOW_CLASS_METHODS": "Zobrazit metody třídy",

  "WINDOW_THEME": "Téma okna",
  "SYSTEM_THEME": "Systémové téma",
  "DARK_THEME": "Tmavé téma",
  "LIGHT_THEME": "Téma světla",
  "ONE_DARK_THEME": "Jedno tmavé téma",
  "SOLARIZED_DARK_THEME": "Tmavé téma Solarized",
  "SOLARIZED_LIGHT_THEME": "Téma solárního světla",
  "HIGH_CONTRAST_DARK_THEME": "Vysoce kontrastní tmavé téma",
  "HIGH_CONTRAST_LIGHT_THEME": "Vysoce kontrastní světelné téma",
  "ONE_DARK": "Jedna tma",
  "SOLARIZED_DARK": "Solarizovaná tma",
  "SOLARIZED_LIGHT": "Solární světlo",
  "HIGH_CONTRAST_DARK": "Vysoký kontrast tmavé",
  "HIGH_CONTRAST_LIGHT": "Vysoce kontrastní světlo",
  "TEXT_AREA_THEME": "Téma textové oblasti",
  "DEFAULT_RECOMMENDED_LIGHT": "Výchozí (doporučené světlo)",
  "THEME_MATCH": "Tématická shoda (doporučeno)",
  "DARK": "Tmavý (doporučený tmavý)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Zatmění",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (Temný)",
  "MONOKAI_DARK": "Monokai (Dark)",

  "SETTINGS": "Nastavení",
  "COMPILE_ON_SAVE": "Kompilace při uložení",
  "COMPILE_ON_REFRESH": "Kompilace při obnovení",
  "REFRESH_ON_VIEW_CHANGE": "Obnovit při změně zobrazení",
  "DECODE_APK_RESOURCES": "Dekódovat APK zdroje",
  "APK_CONVERSION": "Převod APK",
  "APK_CONVERSION_DECODING": "Převod APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Kontrola aktualizace",
  "DELETE_UNKNOWN_LIBS": "Odstranit zahraniční",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Nastavení spustitelného souboru Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Nastavení spustitelného souboru Python 3.X",
  "SET_JRE_RT_LIBRARY": "Nastavení knihovny JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Nastavení volitelné složky knihovny",
  "SET_JAVAC_EXECUTABLE": "Nastavení spustitelného souboru Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Nastavení systému Procyon",
  "CFR_SETTINGS": "Nastavení CFR",
  "FERNFLOWER_SETTINGS": "Nastavení FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytový kód",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Dekompilátor bajtového kódu",
  "DEBUG_HELPERS": "Pomocníci pro ladění",
  "APPEND_BRACKETS_TO_LABEL": "Připojení závorek ke štítku",

  "PLUGINS": "Zásuvné moduly",
  "OPEN_PLUGIN": "Otevřít zásuvný modul...",
  "RECENT_PLUGINS": "Nedávné zásuvné moduly",
  "CODE_SEQUENCE_DIAGRAM": "Schéma sekvence kódu",
  "MALICIOUS_CODE_SCANNER": "Skener škodlivého kódu",
  "SHOW_MAIN_METHODS": "Zobrazit hlavní metody",
  "SHOW_ALL_STRINGS": "Zobrazit všechny řetězce",
  "REPLACE_STRINGS": "Nahradit řetězce",
  "STACK_FRAMES_REMOVER": "Odstraňovač stohových rámů",
  "ZKM_STRING_DECRYPTER": "Dešifrátor řetězců ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Zobrazení oprávnění systému Android",
  "VIEW_MANIFEST": "Zobrazit manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Změna verzí souborů tříd",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "Dekompilátor CFR",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "Dekompilátor JADX",
  "JD_DECOMPILER": "Dekompilátor JD-GUI",
  "BYTECODE_DISASSEMBLER": "Disassembler bytového kódu",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Chyba",
  "NEW_JAVA_PLUGIN": "Nový modul pluginu Java",
  "NEW_JAVASCRIPT_PLUGIN": "Nový plugin Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Navrhovaná oprava: Pokud se to znovu nepodaří, zkuste jiný dekompilátor.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Navrhovaná oprava: Zkuste View>Pane>Krakatau>Bytecode a povolte Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "VAROVÁNÍ: V současné době není vybrán žádný dekompilátor. Zkuste View>Pane a vyberte dekompilátor.",
  "COMPILER_TIP": "Mějte na paměti, že většina dekompilátorů nedokáže vytvořit kompilovatelné třídy.",
  "FIRST_OPEN_A_RESOURCE": "Nejprve otevřete zdroj v BCV (třídu, jar, zip nebo apk soubor).",
  "FIRST_OPEN_A_CLASS": "Nejprve otevřete zdroj třídního souboru uvnitř BCV (jar, zip, apk, dex).",
  "FIRST_VIEW_A_CLASS": "Nejprve zobrazte soubor třídy uvnitř karty.",
  "DRAG_CLASS_JAR": "Třída Drag",

  "YES": "Ano",
  "NO": "Ne",
  "ERROR2": "Chyba:",
  "PROCESS2": "Proces:",
  "EXIT_VALUE_IS": "Výstupní hodnota je:",
  "JAVA_COMPILE_FAILED": "Kompilace jazyka Java se nezdařila",
  "ERROR_COMPILING_CLASS": "Chyba při kompilaci třídy",
  "COMPILER": "Mějte na paměti, že většina dekompilátorů nedokáže vytvořit kompilovatelné třídy.",
  "SELECT_LIBRARY_FOLDER": "Vyberte složku knihovny",
  "SELECT_JAVA_RT": "Vyberte JRE RT Jar",
  "SELECT_JAVA": "Vyberte spustitelný soubor Java",
  "SELECT_JAVAC": "Vyberte spustitelný soubor Javac",
  "SELECT_JAVA_TOOLS": "Zvolte Java Tools Jar",
  "SELECT_PYTHON_2": "Vyberte spustitelný soubor Python 2.7",
  "SELECT_PYTHON_3": "Vyberte spustitelný soubor Python 3.x",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (nebo PyPy 2.7 pro rychlost) Spustitelný soubor",
  "PYTHON_3_EXECUTABLE": "Python 3.x (nebo PyPy 3.x pro rychlost) Spustitelný soubor",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Musíte nastavit cestu ke spustitelnému souboru Python 2.7 (nebo PyPy 2.7 pro rychlost).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Musíte nastavit cestu ke spustitelnému souboru Python 3.x (nebo PyPy 3.x pro rychlost).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Je třeba nastavit knihovnu JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Spustitelný soubor Java (uvnitř JRE C:",
  "JAVAC_EXECUTABLE": "Spustitelný soubor Javac (vyžaduje JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (uvnitř JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (uvnitř JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Volitelná složka knihovny (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Skrýt metody přemostění",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Skrýt syntetické členy třídy",
  "DECOMPILE_INNER_CLASSES": "Dekompilace vnitřních tříd",
  "COLLAPSE_14_CLASS_REFERENCES": "Sbalení odkazů na třídy 1.4",
  "DECOMPILE_ASSERTIONS": "Dekompilace tvrzení",
  "HIDE_EMPTY_SUPER_INVOCATION": "Skrýt prázdné volání super",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Skrýt prázdný výchozí konstruktor",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompilace generických podpisů",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Předpokládejte, že návrat nevyhazuje výjimky",
  "DECOMPILE_ENUMERATIONS": "Dekompilace výčtů",
  "REMOVE_GETCLASS_INVOCATION": "Odstranění volání funkce getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretovat int 1 jako boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Povolit nenastavení syntetického atributu",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Uvažujte bezejmenné typy jako java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonstrukce názvů proměnných z informací o ladění",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Odstranění prázdných rozsahů výjimek",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline konečně struktury",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Povolit v řetězcích pouze znaky ASCII",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Přejmenování nejednoznačných tříd a prvků tříd",

  "DECODE_ENUM_SWITCH": "Přepínač dekódování enum",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Přepínač dekódovacího řetězce",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Vnitřní třídy",
  "REMOVE_BOILER_PLATE": "Odstranění kotlové desky",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Odstranění syntetiky vnitřní třídy",
  "DECODE_LAMBDAS": "Dekódování lambd",
  "LIFT__CONSTRUCTOR_INIT": "Konstruktor výtahu Init",
  "REMOVE_DEAD_METHODS": "Odstranění mrtvých metod",
  "REMOVE_BAD_GENERICS": "Odstranění špatných generik",
  "SUGAR_ASSERTS": "Cukr tvrdí",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Zobrazit verzi",
  "DECODE_FINALLY": "Konečně dekódovat",
  "TIDY_MONITORS": "Uklizené monitory",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Komentáře",
  "FORCE_TOP_SORT": "Vynutit nejvyšší třídění",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Vynucení výjimky Prune",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Obnovení",
  "OVERRIDE": "Přepsat",
  "SHOW_INFERRABLE": "Zobrazit Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Skrýt UTF",
  "HIDE_LONG_STRINGS": "Skrýt dlouhé řetězce",
  "COMMENT_MONITORS": "Monitory komentářů",
  "ALLOW_CORRECTING": "Povolit opravu",
  "LABELLED_BLOCKS": "Označené bloky",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Skrýt Lang Imports",
  "RECOVER_TYPE_CLASH": "Obnovit typ střetu",
  "RECOVER_TYPE__HINTS": "Tipy pro obnovení typu",
  "FORCE_RETURNING_IFS": "Force Returning IFs",
  "FOR_LOOP_AGG_CAPTURE": "Pro smyčku AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Vždy generovat proměnnou výjimky pro bloky Catch",
  "EXCLUDE_NESTED_TYPES": "Vyloučení vnořených typů",
  "SHOW_DEBUG_LINE_NUMBERS": "Zobrazit čísla ladicích řádků",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Zahrnutí čísel řádků do bajtkódu",
  "INCLUDE_ERROR_DIAGNOSTICS": "Zahrnout diagnostiku chyb",
  "SHOW_SYNTHETIC_MEMBERS": "Zobrazit syntetické členy",
  "SIMPLIFY_MEMBER_REFERENCES": "Zjednodušení odkazů na členy",
  "MERGE_VARIABLES": "Sloučení proměnných",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Vynucení explicitních typových argumentů",
  "FORCE_EXPLICIT_IMPORTS": "Vynucení explicitních importů",
  "FLATTEN_SWITCH_BLOCKS": "Zploštění spínacích bloků",
  "RETAIN_POINTLESS_SWITCHES": "Zachování zbytečných přepínačů",
  "RETAIN_REDUNDANT_CASTS": "Zachování nadbytečných odlitků",
  "UNICODE_OUTPUT_ENABLED": "Povolený výstup Unicode",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Znovu načíst zdroje",
  "RELOAD_RESOURCES_CONFIRM": "Jste si jisti, že si přejete znovu načíst zdroje?",
  "SELECT_FILE_TITLE": "Vyberte Soubor nebo Složku pro otevření v {BCV}",
  "SELECT_FILE_DESCRIPTION": "Soubory APK, DEX, soubory tříd nebo Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Vyberte externí zásuvný modul",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Externí plugin BCV v js, javě, pythonu, ruby nebo groovy",
  "FOREIGN_LIBRARY_WARNING": "UPOZORNĚNÍ: Pokud je tato funkce vypnutá, zastaralé knihovny nebudou odstraněny.\n\rJedná se také o bezpečnostní problém.\n\rVYPNĚTE JI POUZE V PŘÍPADĚ, ŽE VÍTE, CO DĚLÁTE.",
  "RESET_TITLE": "{PRODUCT_NAME} - Obnovit pracovní prostor",
  "RESET_CONFIRM": "Jste si jisti, že chcete obnovit pracovní prostor?\n\rResetuje se také navigátor souborů a vyhledávání.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Jste si jisti, že chcete odejít?",
  "ABOUT_TITLE": "{TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Konzola zásuvného modulu",
  "CLOSE_ALL_BUT_THIS": "Zavřít vše kromě tohoto",
  "CLOSE_TAB": "Zavřít kartu",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Zašlete prosím tento protokol o chybě na adresu",
  "PLEASE_SEND_RESOURCES": "Pokud máte příslušná zákonná práva na příslušnou třídu.",
  "ONE_PLUGIN_AT_A_TIME": "V současné době je spuštěn jiný zásuvný modul, vyčkejte prosím na jeho dokončení.",
  "ILLEGAL_ACCESS_ERROR": "Použijte k tomu Javu 15 nebo starší.",


  "FILES": "Soubory",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Rychlé vyhledávání souborů (bez přípony)",
  "WORK_SPACE": "Pracovní prostor",
  "EXACT": "Přesně",
  "SEARCH": "Vyhledávání",
  "SEARCH_FROM": "Hledat od:",
  "SEARCH_STRING": "Vyhledávací řetězec:",
  "SEARCH_REGEX": "Regex pro vyhledávání:",
  "OWNER": "Majitel:",
  "NAME": "Jméno:",
  "DESC": "Popis:",
  "SAVE": "Uložit...",
  "SAVE_AS": "Uložit jako...",
  "RESULTS": "Výsledky",
  "REFRESH": "Obnovit",
  "ANNOTATION_NAME": "Název anotace",
  "MATCH_CASE": "Zápasový kufřík",
  "EXACT_PATH": "Přesná cesta",
  "MIN_SDK_VERSION": "Minimální verze SDK",
  "PRINT_LINE_NUMBERS": "Tisk čísel řádků"
}

```

`src/main/resources/translations/danish.json`:

```json
{
  "FILE": "Fil",
  "ADD": "Tilføj...",
  "NEW_WORKSPACE": "Nyt arbejdsområde",
  "RELOAD_RESOURCES": "Genindlæsning af ressourcer",
  "RUN": "Kør",
  "OPEN": "Åbn...",
  "OPEN_UNSTYLED": "Åbn",
  "QUICK_OPEN": "Hurtig åbning",
  "DELETE": "Slet",
  "NEW": "Ny",
  "EXPAND": "Udvid",
  "COLLAPSE": "Kollaps",
  "COMPILE": "Kompilere",
  "SAVE_AS_RUNNABLE_JAR": "Gem som kørbar krukke...",
  "SAVE_AS_ZIP": "Gem som zip...",
  "SAVE_AS_DEX": "Gem som DEX...",
  "SAVE_AS_APK": "Gem som APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompilere og gemme åbnede klasser",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompilere og gemme alle klasser",
  "RECENT_FILES": "Seneste filer",
  "ABOUT": "Om",
  "EXIT": "Afslut",

  "VIEW": "Se",
  "VISUAL_SETTINGS": "Visuelle indstillinger",
  "PANE_1": "rude 1",
  "PANE_2": "rude 2",
  "PANE_3": "rude 3",
  "NONE": "Ingen",
  "EDITABLE": "Redigerbar",

  "LANGUAGE": "Sprog",
  "FONT_SIZE": "Skriftstørrelse",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Vis fil i fanebladets titel",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Forenkling af navnet i fanens titel",
  "SYNCHRONIZED_VIEWING": "Synkroniseret visning",
  "SHOW_CLASS_METHODS": "Vis klassemetoder",

  "WINDOW_THEME": "Vindue tema",
  "SYSTEM_THEME": "Systemtema",
  "DARK_THEME": "Mørkt tema",
  "LIGHT_THEME": "Lys tema",
  "ONE_DARK_THEME": "Et mørkt tema",
  "SOLARIZED_DARK_THEME": "Solarized Dark-tema",
  "SOLARIZED_LIGHT_THEME": "Tema med solariseret lys",
  "HIGH_CONTRAST_DARK_THEME": "Mørkt tema med høj kontrast",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema med høj kontrast og lys",
  "ONE_DARK": "En mørk",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solariseret lys",
  "HIGH_CONTRAST_DARK": "Mørk med høj kontrast",
  "HIGH_CONTRAST_LIGHT": "Lys med høj kontrast",
  "TEXT_AREA_THEME": "Tema for tekstområde",
  "DEFAULT_RECOMMENDED_LIGHT": "Standard (anbefalet lys)",
  "THEME_MATCH": "Temamatch (anbefalet)",
  "DARK": "Mørk (anbefalet mørk)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Standard-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druide (mørk)",
  "MONOKAI_DARK": "Monokai (mørk)",

  "SETTINGS": "Indstillinger",
  "COMPILE_ON_SAVE": "Kompilere ved lagring",
  "COMPILE_ON_REFRESH": "Kompilering ved opdatering",
  "REFRESH_ON_VIEW_CHANGE": "Opdatering ved ændring af visning",
  "DECODE_APK_RESOURCES": "Afkode APK-ressourcer",
  "APK_CONVERSION": "APK-konvertering",
  "APK_CONVERSION_DECODING": "APK-konvertering",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Opdateringskontrol",
  "DELETE_UNKNOWN_LIBS": "Slet udenlandsk",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Indstil Python 2.7 Executable",
  "SET_PYTHON_30_EXECUTABLE": "Indstil Python 3.X Executable",
  "SET_JRE_RT_LIBRARY": "Indstil JRE RT-bibliotek",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Indstil valgfri biblioteksmappe",
  "SET_JAVAC_EXECUTABLE": "Indstil Javac eksekverbar",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon-indstillinger",
  "CFR_SETTINGS": "CFR-indstillinger",
  "FERNFLOWER_SETTINGS": "FernFlower-indstillinger",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexkode",
  "BYTECODE": "Bytekode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode-dekompilering",
  "DEBUG_HELPERS": "Hjælpemidler til fejlfinding",
  "APPEND_BRACKETS_TO_LABEL": "Tilføj parenteser til etiketten",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Åbn Plugin...",
  "RECENT_PLUGINS": "Seneste plugins",
  "CODE_SEQUENCE_DIAGRAM": "Diagram over kodeforløb",
  "MALICIOUS_CODE_SCANNER": "Scanner af skadelig kode",
  "SHOW_MAIN_METHODS": "Vis hovedmetoder",
  "SHOW_ALL_STRINGS": "Vis alle strenge",
  "REPLACE_STRINGS": "Udskift strenge",
  "STACK_FRAMES_REMOVER": "Fjernelse af stakrammer",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray dekrypterer",
  "VIEW_ANDROID_PERMISSIONS": "Se Android-tilladelser",
  "VIEW_MANIFEST": "Se Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Ændre ClassFile-versioner",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR-dekompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX-dekompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Disassembler af bytekode",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Fejl",
  "NEW_JAVA_PLUGIN": "Ny Java-plugin",
  "NEW_JAVASCRIPT_PLUGIN": "Nyt Javascript-plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Foreslået rettelse: Klik på Opdater klasse, hvis det mislykkes igen, prøv en anden dekompiler.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Foreslået løsning: Prøv Vis>rude>Krakatau>Krakatau>Bytekode og aktiver Redigerbar.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ADVARSEL: Der er ikke valgt nogen dekompiler i øjeblikket. Prøv Vis>Feltet og vælg en dekompiler.",
  "COMPILER_TIP": "Husk på, at de fleste dekompilatorer ikke kan producere kompilerbare klasser",
  "FIRST_OPEN_A_RESOURCE": "Åbn først en ressource i BCV (klasse, jar, zip eller apk-fil)",
  "FIRST_OPEN_A_CLASS": "Åbn først en klassefilressource i BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Vis først en klassefil inde i en fane.",
  "DRAG_CLASS_JAR": "Trække klasse",

  "YES": "Ja",
  "NO": "Nej",
  "ERROR2": "Fejl:",
  "PROCESS2": "Proces:",
  "EXIT_VALUE_IS": "Exit-værdien er:",
  "JAVA_COMPILE_FAILED": "Java-kompilering mislykkedes",
  "ERROR_COMPILING_CLASS": "Fejl ved kompilering af klassen",
  "COMPILER": "Husk på, at de fleste dekompilatorer ikke kan producere kompilerbare klasser",
  "SELECT_LIBRARY_FOLDER": "Vælg Biblioteksmappe",
  "SELECT_JAVA_RT": "Vælg JRE RT Jar",
  "SELECT_JAVA": "Vælg Java Executable",
  "SELECT_JAVAC": "Vælg Javac Executable",
  "SELECT_JAVA_TOOLS": "Vælg Java Tools Jar",
  "SELECT_PYTHON_2": "Vælg Python 2.7 Executable",
  "SELECT_PYTHON_3": "Vælg Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (eller PyPy 2.7 for at gøre det hurtigere) Udførbar",
  "PYTHON_3_EXECUTABLE": "Python 3.x (eller PyPy 3.x for at gøre det hurtigere) Udførbar",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Du skal angive stien til din Python 2.7 (eller PyPy 2.7 for at gøre det hurtigere) eksekverbar fil.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Du skal angive stien til Python 3.x (eller PyPy 3.x for at gøre det hurtigere) til din eksekverbare fil.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Du skal indstille dit JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java eksekverbar (inde i JRE C:",
  "JAVAC_EXECUTABLE": "Javac eksekverbar fil (kræver JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (inde i JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (inde i JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Valgfri biblioteksmappe (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Skjul brometoder",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Skjul syntetiske klasseelementer",
  "DECOMPILE_INNER_CLASSES": "Dekompilere indre klasser",
  "COLLAPSE_14_CLASS_REFERENCES": "Kollaps 1.4 klassehenvisninger",
  "DECOMPILE_ASSERTIONS": "Dekompilering af assertioner",
  "HIDE_EMPTY_SUPER_INVOCATION": "Skjul tom superinvokation",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Skjul tom standardkonstruktør",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompilering af generiske signaturer",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Antag, at returnering ikke giver anledning til undtagelser",
  "DECOMPILE_ENUMERATIONS": "Dekompilering af opregninger",
  "REMOVE_GETCLASS_INVOCATION": "Fjern getClass()-invokation",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Fortolke int 1 som boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Tillad, at en syntetisk attribut ikke er indstillet",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Overvej navnløse typer som java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonstruere variabelnavne fra fejlfindingsoplysninger",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Fjern tomme undtagelsesområder",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline endelig strukturer",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Tillad kun ASCII-tegn i strenge",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Omdøb tvetydige klasser og klasseelementer",

  "DECODE_ENUM_SWITCH": "Afkodning af enumskifte",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Afkodning af streng omskifter",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Indre klasser",
  "REMOVE_BOILER_PLATE": "Fjern kedelplade",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Fjern Syntetik i den indre klasse",
  "DECODE_LAMBDAS": "Afkodning af lambdaer",
  "LIFT__CONSTRUCTOR_INIT": "Løftekonstruktør Init",
  "REMOVE_DEAD_METHODS": "Fjern døde metoder",
  "REMOVE_BAD_GENERICS": "Fjern dårlige generiske stoffer",
  "SUGAR_ASSERTS": "Sukker hævder",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Vis version",
  "DECODE_FINALLY": "Afkodning Endelig",
  "TIDY_MONITORS": "Ryddelige skærme",
  "LENIENT": "Lempelig",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Kommentarer",
  "FORCE_TOP_SORT": "Tvinge topsortering",
  "FORCE_TOP_SORT_AGGRESS": "Tvinge top sortering Aggressivitet",
  "FORCE_EXCEPTION_PRUNE": "Tvinge undtagelsen til at blive beskåret",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Genoprette",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Vis Uigennemtrængelig",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagere",
  "HIDE_UTF": "Skjul UTF",
  "HIDE_LONG_STRINGS": "Skjul lange strenge",
  "COMMENT_MONITORS": "Kommentarer Monitorer",
  "ALLOW_CORRECTING": "Tillad at korrigere",
  "LABELLED_BLOCKS": "Mærkede klodser",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Genoprette type sammenstød",
  "RECOVER_TYPE__HINTS": "Tips til at genoprette typen",
  "FORCE_RETURNING_IFS": "Tvinge tilbagevendende IF'er til at vende tilbage",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Generer altid undtagelsesvariabel for Catch-blokke",
  "EXCLUDE_NESTED_TYPES": "Udelukke indlejrede typer",
  "SHOW_DEBUG_LINE_NUMBERS": "Vis fejlfindingslinjernes numre",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Medtag linjenumre i bytekode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Medtag fejldiagnostik",
  "SHOW_SYNTHETIC_MEMBERS": "Vis syntetiske medlemmer",
  "SIMPLIFY_MEMBER_REFERENCES": "Forenkling af referencer til medlemmer",
  "MERGE_VARIABLES": "Sammenlægning af variabler",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Tvinge eksplicitte typeargumenter",
  "FORCE_EXPLICIT_IMPORTS": "Tvinge eksplicit import",
  "FLATTEN_SWITCH_BLOCKS": "Flade switch-blokke",
  "RETAIN_POINTLESS_SWITCHES": "Bevar meningsløse afbrydere",
  "RETAIN_REDUNDANT_CASTS": "Bevar overflødige afstøbninger",
  "UNICODE_OUTPUT_ENABLED": "Unicode-udgang aktiveret",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Genindlæs ressourcer",
  "RELOAD_RESOURCES_CONFIRM": "Er du sikker på, at du ønsker at genindlæse ressourcerne?",
  "SELECT_FILE_TITLE": "Vælg Fil eller mappe, der skal åbnes i {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK'er, DEX, klassefiler eller Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Vælg Eksternt plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin i js, java, python, ruby eller groovy",
  "FOREIGN_LIBRARY_WARNING": "ADVARSEL: Når denne indstilling er slået fra, vil forældede biblioteker IKKE blive fjernet.\n\rDet er også et sikkerhedsproblem.\n\rSLÅ DET KUN FRA, HVIS DU VED, HVAD DU GØR.",
  "RESET_TITLE": "{PRODUCT_NAME} - Nulstil arbejdsområde",
  "RESET_CONFIRM": "Er du sikker på, at du vil nulstille arbejdsområdet?\n\rDet vil også nulstille din filnavigator og søgning.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Afslut",
  "EXIT_CONFIRM": "Er du sikker på, at du vil afslutte?",
  "ABOUT_TITLE": "{TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin-konsol",
  "CLOSE_ALL_BUT_THIS": "Luk alt undtagen dette",
  "CLOSE_TAB": "Luk fanen",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Send venligst denne fejllog til",
  "PLEASE_SEND_RESOURCES": "Hvis du har passende juridiske rettigheder til den relevante gruppe",
  "ONE_PLUGIN_AT_A_TIME": "Der kører i øjeblikket et andet plugin lige nu, vent venligst på, at det er færdig med at blive eksekveret.",
  "ILLEGAL_ACCESS_ERROR": "Du skal bruge Java 15 eller ældre til at gøre dette.",


  "FILES": "Filer",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Hurtig søgning efter filer (ingen filudvidelse)",
  "WORK_SPACE": "Arbejdsområde",
  "EXACT": "Præcis",
  "SEARCH": "Søg på",
  "SEARCH_FROM": "Søg fra:",
  "SEARCH_STRING": "Søgestreng:",
  "SEARCH_REGEX": "Søg Regex:",
  "OWNER": "Ejer:",
  "NAME": "Navn:",
  "DESC": "Desc:",
  "SAVE": "Gem...",
  "SAVE_AS": "Gem som...",
  "RESULTS": "Resultater",
  "REFRESH": "Opdater",
  "ANNOTATION_NAME": "Annotation Navn",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Præcis vej",
  "MIN_SDK_VERSION": "Mindste SDK-version",
  "PRINT_LINE_NUMBERS": "Udskriv linjenumre"
}

```

`src/main/resources/translations/english.json`:

```json
{
  "FILE": "File",
  "ADD": "Add...",
  "NEW_WORKSPACE": "New Workspace",
  "RELOAD_RESOURCES": "Reload Resources",
  "RUN": "Run",
  "OPEN": "Open...",
  "OPEN_UNSTYLED": "Open",
  "QUICK_OPEN": "Quick Open",
  "DELETE": "Delete",
  "NEW": "New",
  "EXPAND": "Expand",
  "COLLAPSE": "Collapse",
  "COMPILE": "Compile",
  "SAVE_AS_RUNNABLE_JAR": "Save As Runnable Jar...",
  "SAVE_AS_ZIP": "Save As Zip...",
  "SAVE_AS_DEX": "Save As DEX...",
  "SAVE_AS_APK": "Save As APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Decompile & Save Opened Classes",
  "DECOMPILE_SAVE_ALL_CLASSES": "Decompile & Save All Classes",
  "RECENT_FILES": "Recent Files",
  "ABOUT": "About",
  "EXIT": "Exit",

  "VIEW": "View",
  "VISUAL_SETTINGS": "Visual Settings",
  "PANE_1": "Pane 1",
  "PANE_2": "Pane 2",
  "PANE_3": "Pane 3",
  "NONE": "None",
  "EDITABLE": "Editable",

  "LANGUAGE": "Language",
  "FONT_SIZE": "Font Size",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Show File In Tab Title",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Simplify Name In Tab Title",
  "SYNCHRONIZED_VIEWING": "Synchronized Viewing",
  "SHOW_CLASS_METHODS": "Show Class Methods",

  "WINDOW_THEME": "Window Theme",
  "SYSTEM_THEME": "System Theme",
  "DARK_THEME": "Dark Theme",
  "LIGHT_THEME": "Light Theme",
  "ONE_DARK_THEME": "One Dark Theme",
  "SOLARIZED_DARK_THEME": "Solarized Dark Theme",
  "SOLARIZED_LIGHT_THEME": "Solarized Light Theme",
  "HIGH_CONTRAST_DARK_THEME": "High Contrast Dark Theme",
  "HIGH_CONTRAST_LIGHT_THEME": "High Contrast Light Theme",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solarized Light",
  "HIGH_CONTRAST_DARK": "High Contrast Dark",
  "HIGH_CONTRAST_LIGHT": "High Contrast Light",
  "TEXT_AREA_THEME": "Text Area Theme",
  "DEFAULT_RECOMMENDED_LIGHT": "Default (Recommended Light)",
  "THEME_MATCH": "Theme Match (Recommended)",
  "DARK": "Dark (Recommended Dark)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (Dark)",
  "MONOKAI_DARK": "Monokai (Dark)",

  "SETTINGS": "Settings",
  "COMPILE_ON_SAVE": "Compile On Save",
  "COMPILE_ON_REFRESH": "Compile On Refresh",
  "REFRESH_ON_VIEW_CHANGE": "Refresh On View Change",
  "DECODE_APK_RESOURCES": "Decode APK Resources",
  "APK_CONVERSION": "APK Conversion",
  "APK_CONVERSION_DECODING": "APK Conversion/Decoding",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Update Check",
  "DELETE_UNKNOWN_LIBS": "Delete Foreign/Outdated Libs",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Set Python 2.7 Executable",
  "SET_PYTHON_30_EXECUTABLE": "Set Python 3.X Executable",
  "SET_JRE_RT_LIBRARY": "Set JRE RT Library",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Set Optional Library Folder",
  "SET_JAVAC_EXECUTABLE": "Set Javac Executable",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon Settings",
  "CFR_SETTINGS": "CFR Settings",
  "FERNFLOWER_SETTINGS": "FernFlower Settings",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali/Dex",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode Decompiler",
  "DEBUG_HELPERS": "Debug Helpers",
  "APPEND_BRACKETS_TO_LABEL": "Append Brackets To Label",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Open Plugin...",
  "RECENT_PLUGINS": "Recent Plugins",
  "CODE_SEQUENCE_DIAGRAM": "Code Sequence Diagram",
  "MALICIOUS_CODE_SCANNER": "Malicious Code Scanner",
  "SHOW_MAIN_METHODS": "Show Main Methods",
  "SHOW_ALL_STRINGS": "Show All Strings",
  "REPLACE_STRINGS": "Replace Strings",
  "STACK_FRAMES_REMOVER": "Stack Frames Remover",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "View Android Permissions",
  "VIEW_MANIFEST": "View Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Change ClassFile Versions",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Error",
  "NEW_JAVA_PLUGIN": "New Java Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "New Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Suggested Fix: Click refresh class, if it fails again try another decompiler.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Suggested Fix: Try View>Pane>Krakatau>Bytecode and enable Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "WARNING: No decompiler is currently selected. Try View>Pane and choose a decompiler.",
  "COMPILER_TIP": "Keep in mind most decompilers cannot produce compilable classes",
  "FIRST_OPEN_A_RESOURCE": "First open a resource inside of BCV (class, jar, zip or apk file)",
  "FIRST_OPEN_A_CLASS": "First open a classfile resource inside of BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "First view a class file inside of a tab.",
  "DRAG_CLASS_JAR": "Drag class/jar/zip/APK/DEX here",

  "YES": "Yes",
  "NO": "No",
  "ERROR2": "Error:",
  "PROCESS2": "Process:",
  "EXIT_VALUE_IS": "Exit Value is:",
  "JAVA_COMPILE_FAILED": "Java Compile Failed",
  "ERROR_COMPILING_CLASS": "Error compiling class",
  "COMPILER": "Keep in mind most decompilers cannot produce compilable classes",
  "SELECT_LIBRARY_FOLDER": "Select Library Folder",
  "SELECT_JAVA_RT": "Select JRE RT Jar",
  "SELECT_JAVA": "Select Java Executable",
  "SELECT_JAVAC": "Select Javac Executable",
  "SELECT_JAVA_TOOLS": "Select Java Tools Jar",
  "SELECT_PYTHON_2": "Select Python 2.7 Executable",
  "SELECT_PYTHON_3": "Select Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Or PyPy 2.7 for speed) Executable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Or PyPy 3.x for speed) Executable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "You need to set your Python 2.7 (or PyPy 2.7 for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "You need to set your Python 3.x (or PyPy 3.x for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "You need to set your JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C:/Program Files/Java/JRE_xx/bin/java.exe)",
  "JAVAC_EXECUTABLE": "Javac Executable (Requires JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C:/Program Files/Java/JDK_xx/lib/tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C:/Program Files/Java/JRE_xx/lib/rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Optional Library Folder (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Hide bridge methods",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Hide synthetic class members",
  "DECOMPILE_INNER_CLASSES": "Decompile inner classes",
  "COLLAPSE_14_CLASS_REFERENCES": "Collapse 1.4 class references",
  "DECOMPILE_ASSERTIONS": "Decompile assertions",
  "HIDE_EMPTY_SUPER_INVOCATION": "Hide empty super invocation",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Hide empty default constructor",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompile generic signatures",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Assume return not throwing exceptions",
  "DECOMPILE_ENUMERATIONS": "Decompile enumerations",
  "REMOVE_GETCLASS_INVOCATION": "Remove getClass() invocation",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpret int 1 as boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Allow for not set synthetic attribute",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Consider nameless types as java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruct variable names from debug info",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Remove empty exception ranges",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finally structures",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Allow only ASCII characters in strings",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Rename ambiguous classes and class elements",

  "DECODE_ENUM_SWITCH": "Decode Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Decode String Switch",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Inner Classes",
  "REMOVE_BOILER_PLATE": "Remove Boiler Plate",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Remove Inner Class Synthetics",
  "DECODE_LAMBDAS": "Decode Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift  Constructor Init",
  "REMOVE_DEAD_METHODS": "Remove Dead Methods",
  "REMOVE_BAD_GENERICS": "Remove Bad Generics",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Show Version",
  "DECODE_FINALLY": "Decode Finally",
  "TIDY_MONITORS": "Tidy Monitors",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Comments",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Recover",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Show Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Hide UTF",
  "HIDE_LONG_STRINGS": "Hide Long Strings",
  "COMMENT_MONITORS": "Comment Monitors",
  "ALLOW_CORRECTING": "Allow Correcting",
  "LABELLED_BLOCKS": "Labelled Blocks",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Recover Type Clash",
  "RECOVER_TYPE__HINTS": "Recover Type  Hints",
  "FORCE_RETURNING_IFS": "Force Returning IFs",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Always Generate Exception Variable For Catch Blocks",
  "EXCLUDE_NESTED_TYPES": "Exclude Nested Types",
  "SHOW_DEBUG_LINE_NUMBERS": "Show Debug Line Numbers",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Include Line Numbers In Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Include Error Diagnostics",
  "SHOW_SYNTHETIC_MEMBERS": "Show Synthetic Members",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplify Member References",
  "MERGE_VARIABLES": "Merge Variables",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Force Explicit Imports",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Switch Blocks",
  "RETAIN_POINTLESS_SWITCHES": "Retain Pointless Switches",
  "RETAIN_REDUNDANT_CASTS": "Retain Redundant Casts",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Reload Resources",
  "RELOAD_RESOURCES_CONFIRM": "Are you sure you wish to reload the resources?",
  "SELECT_FILE_TITLE": "Select File or Folder to open in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Class Files or Zip/Jar/War Archives",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Select External Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin in js, java, python, ruby or groovy",
  "FOREIGN_LIBRARY_WARNING": "WARNING: With this being toggled off outdated libraries will NOT be removed.\n\rIt's also a security issue.\n\rONLY TURN IT OFF IF YOU KNOW WHAT YOU'RE DOING.",
  "RESET_TITLE": "{PRODUCT_NAME} - Reset Workspace",
  "RESET_CONFIRM": "Are you sure you want to reset the workspace?\n\rIt will also reset your file navigator and search.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Are you sure you want to exit?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - About - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Close All But This",
  "CLOSE_TAB": "Close Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Please send this error log to",
  "PLEASE_SEND_RESOURCES": "If you hold appropriate legal rights to the relevant class/jar/apk file please include that as well.",
  "ONE_PLUGIN_AT_A_TIME": "There is currently another plugin running right now, please wait for that to finish executing.",
  "ILLEGAL_ACCESS_ERROR": "Please use Java 15 or older to do this.",


  "FILES": "Files",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Quick file search (no file extension)",
  "WORK_SPACE": "Work Space",
  "EXACT": "Exact",
  "SEARCH": "Search",
  "SEARCH_FROM": "Search From: ",
  "SEARCH_STRING": "Search String: ",
  "SEARCH_REGEX": "Search Regex: ",
  "OWNER": "Owner: ",
  "NAME": "Name: ",
  "DESC": "Desc: ",
  "SAVE": "Save...",
  "SAVE_AS": "Save As...",
  "RESULTS": "Results",
  "REFRESH": "Refresh",
  "ANNOTATION_NAME": "Annotation Name",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Exact Path",
  "MIN_SDK_VERSION": "Minimum SDK version",
  "PRINT_LINE_NUMBERS": "Print Line Numbers"
}

```

`src/main/resources/translations/estonian.json`:

```json
{
  "FILE": "Faili",
  "ADD": "Lisa...",
  "NEW_WORKSPACE": "Uus tööruum",
  "RELOAD_RESOURCES": "Ressursside uuesti laadimine",
  "RUN": "Käivita",
  "OPEN": "Avatud...",
  "OPEN_UNSTYLED": "Avatud",
  "QUICK_OPEN": "Kiire avamine",
  "DELETE": "Kustuta",
  "NEW": "Uus",
  "EXPAND": "Laiendage",
  "COLLAPSE": "Kokkuvarisemine",
  "COMPILE": "Koosta",
  "SAVE_AS_RUNNABLE_JAR": "Save As Runnable Jar...",
  "SAVE_AS_ZIP": "Salvesta kui Zip...",
  "SAVE_AS_DEX": "Salvesta kui DEX...",
  "SAVE_AS_APK": "Salvesta APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Avatud klasside dekompileerimine ja salvestamine",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompileeri ja salvesta kõik klassid",
  "RECENT_FILES": "Viimased failid",
  "ABOUT": "kohta",
  "EXIT": "Väljumine",

  "VIEW": "Vaata",
  "VISUAL_SETTINGS": "Visuaalsed seaded",
  "PANE_1": "Paneel 1",
  "PANE_2": "Paneel 2",
  "PANE_3": "Paneel 3",
  "NONE": "Puudub",
  "EDITABLE": "Redigeeritav",

  "LANGUAGE": "Keel",
  "FONT_SIZE": "Kirjasuurus",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Näita faili vahekaardi pealkirjas",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Lihtsustada nime vahekaardi pealkirjas",
  "SYNCHRONIZED_VIEWING": "Sünkroonitud vaatamine",
  "SHOW_CLASS_METHODS": "Näita klassi meetodeid",

  "WINDOW_THEME": "Aknateema",
  "SYSTEM_THEME": "Süsteemi teema",
  "DARK_THEME": "Tume teema",
  "LIGHT_THEME": "Valgus teema",
  "ONE_DARK_THEME": "Üks tume teema",
  "SOLARIZED_DARK_THEME": "Solariseeritud tume teema",
  "SOLARIZED_LIGHT_THEME": "Solariseeritud valguse teema",
  "HIGH_CONTRAST_DARK_THEME": "Kõrge kontrastiga tume teema",
  "HIGH_CONTRAST_LIGHT_THEME": "Kõrge kontrasti valgus teema",
  "ONE_DARK": "Üks tume",
  "SOLARIZED_DARK": "Solariseeritud tume",
  "SOLARIZED_LIGHT": "Päikesestatud valgus",
  "HIGH_CONTRAST_DARK": "Kõrge kontrasti tume",
  "HIGH_CONTRAST_LIGHT": "Kõrge kontrastsusega valgus",
  "TEXT_AREA_THEME": "Tekstiala teema",
  "DEFAULT_RECOMMENDED_LIGHT": "Vaikimisi (soovitatav valgus)",
  "THEME_MATCH": "Teemamäng (soovitatav)",
  "DARK": "Tume (soovitatav tume)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druiid (tume)",
  "MONOKAI_DARK": "Monokai (tume)",

  "SETTINGS": "Seaded",
  "COMPILE_ON_SAVE": "Compile On Save",
  "COMPILE_ON_REFRESH": "Kompileeri värskendamisel",
  "REFRESH_ON_VIEW_CHANGE": "Värskendamine vaate muutmisel",
  "DECODE_APK_RESOURCES": "Decodeeri APK ressursid",
  "APK_CONVERSION": "APK konverteerimine",
  "APK_CONVERSION_DECODING": "APK konverteerimine",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Ajakohastamise kontroll",
  "DELETE_UNKNOWN_LIBS": "Välismaa kustutamine",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii kui tekst",
  "SET_PYTHON_27_EXECUTABLE": "Python 2.7 käivitatavuse määramine",
  "SET_PYTHON_30_EXECUTABLE": "Python 3.X käivitatavuse määramine",
  "SET_JRE_RT_LIBRARY": "JRE RT raamatukogu seadistamine",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Valikulise raamatukogu kausta määramine",
  "SET_JAVAC_EXECUTABLE": "Set Javac Executable",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyoni seaded",
  "CFR_SETTINGS": "CFR seaded",
  "FERNFLOWER_SETTINGS": "FernFlower seaded",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Baitkoodi dekompilaator",
  "DEBUG_HELPERS": "Kõrvaldamise abivahendid",
  "APPEND_BRACKETS_TO_LABEL": "Sulgude lisamine etiketile",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Ava plugin...",
  "RECENT_PLUGINS": "Viimased pluginad",
  "CODE_SEQUENCE_DIAGRAM": "Koodijärjestuse skeem",
  "MALICIOUS_CODE_SCANNER": "Pahatahtliku koodi skanner",
  "SHOW_MAIN_METHODS": "Näita peamisi meetodeid",
  "SHOW_ALL_STRINGS": "Näita kõiki stringid",
  "REPLACE_STRINGS": "Stringide asendamine",
  "STACK_FRAMES_REMOVER": "Stack Frames eemaldaja",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Androidi õiguste vaatamine",
  "VIEW_MANIFEST": "Manifesti vaatamine",
  "CHANGE_CLASSFILE_VERSIONS": "ClassFile versioonide muutmine",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR dekompilaator",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX dekompilaator",
  "JD_DECOMPILER": "JD-GUI dekompilaator",
  "BYTECODE_DISASSEMBLER": "Baitkoodi lahtimonteerija",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Viga",
  "NEW_JAVA_PLUGIN": "Uus Java plugin",
  "NEW_JAVASCRIPT_PLUGIN": "Uus Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Soovitatav parandus: Kui see ei õnnestu uuesti proovida teist dekompilaatorit.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Soovituslik lahendus: Proovige View>Pane>Krakatau>Bytecode ja lubage Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "HOIATUS: Praegu ei ole dekompilaatorit valitud. Proovige View>Pane ja valige dekompilaator.",
  "COMPILER_TIP": "Pidage meeles, et enamik dekompilaatoreid ei suuda kompileeritavaid klasse toota.",
  "FIRST_OPEN_A_RESOURCE": "Kõigepealt avage BCV-s olev ressurss (klass, jar, zip- või apk-fail).",
  "FIRST_OPEN_A_CLASS": "Kõigepealt avage BCV sees olev klassifaili ressurss (jar, zip, apk, dex).",
  "FIRST_VIEW_A_CLASS": "Vaadake kõigepealt klassifaili sees olevat vahekaarti.",
  "DRAG_CLASS_JAR": "Lohistamise klass",

  "YES": "Jah",
  "NO": "Ei",
  "ERROR2": "Viga:",
  "PROCESS2": "Protsess:",
  "EXIT_VALUE_IS": "Väljumise väärtus on:",
  "JAVA_COMPILE_FAILED": "Java kompileerimine ebaõnnestus",
  "ERROR_COMPILING_CLASS": "Viga klassi kompileerimisel",
  "COMPILER": "Pidage meeles, et enamik dekompilaatoreid ei suuda kompileeritavaid klasse toota.",
  "SELECT_LIBRARY_FOLDER": "Valige raamatukogu kaust",
  "SELECT_JAVA_RT": "Valige JRE RT Jar",
  "SELECT_JAVA": "Valige Java Executable",
  "SELECT_JAVAC": "Valige Javac Executable",
  "SELECT_JAVA_TOOLS": "Valige Java Tools Jar",
  "SELECT_PYTHON_2": "Valige Python 2.7 Executable",
  "SELECT_PYTHON_3": "Valige Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (või PyPy 2.7 kiiruse tagamiseks) Rakendatavus",
  "PYTHON_3_EXECUTABLE": "Python 3.x (või PyPy 3.x kiiruse tagamiseks) Rakendatavus",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Sa pead määrama oma Python 2.7 (või PyPy 2.7 kiiruse tagamiseks) käivitatava teekonna.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Sa pead määrama oma Python 3.x (või PyPy 3.x kiiruse tagamiseks) käivitatava teekonna.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Sa pead seadistama oma JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Programmifailid\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (JRE C-siseselt:",
  "JAVAC_EXECUTABLE": "Javac Executable (nõuab JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (JDK C sees):",
  "JAVA_RT_JAR": "Java RT Jar (JRE C-siseselt:",
  "OPTIONAL_LIBRARY_FOLDER": "Valikuline raamatukogumapp (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Silla meetodite varjamine",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Peida sünteetilised klassiliikmed",
  "DECOMPILE_INNER_CLASSES": "Siseklasside dekompileerimine",
  "COLLAPSE_14_CLASS_REFERENCES": "Kokkuvarisemine 1.4 klassiviited",
  "DECOMPILE_ASSERTIONS": "Dekompileeri väited",
  "HIDE_EMPTY_SUPER_INVOCATION": "Peida tühi superkutsung",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Peida tühi vaikimisi konstruktor",
  "DECOMPILE_GENERIC_SIGNATURES": "Üldiste allkirjade dekompileerimine",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Eeldame, et tagastamine ei tekita erandeid",
  "DECOMPILE_ENUMERATIONS": "Loenduste dekompileerimine",
  "REMOVE_GETCLASS_INVOCATION": "Eemalda getClass() üleskutse",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Tõlgenda int 1 kui boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Võimaldab mitte seatud sünteetilist atribuuti",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Vaadelda nimetuid tüüpe nagu java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Muutujate nimede rekonstrueerimine silumisinfo põhjal",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Tühjade erandite vahemike eemaldamine",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline lõpuks struktuurid",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Luba ainult ASCII tähemärke stringides",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Mitmeti mõistetavate klasside ja klassielementide ümbernimetamine",

  "DECODE_ENUM_SWITCH": "Dekodeerimine Enum lüliti",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Stringi dekodeerimise lüliti",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Siseklassid",
  "REMOVE_BOILER_PLATE": "Eemaldage katlaplaat",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Sisemise klassi sünteetika eemaldamine",
  "DECODE_LAMBDAS": "Lambdade dekodeerimine",
  "LIFT__CONSTRUCTOR_INIT": "Lift Constructor Init",
  "REMOVE_DEAD_METHODS": "Eemaldage surnud meetodid",
  "REMOVE_BAD_GENERICS": "Eemaldage halvad geneerilised ravimid",
  "SUGAR_ASSERTS": "Suhkur kinnitab",
  "SUGAR_BOXING": "Suhkrupoks",
  "SHOW_VERSION": "Näita versiooni",
  "DECODE_FINALLY": "Lõpuks dekodeeri",
  "TIDY_MONITORS": "Korralikud monitorid",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Prügimäe klassirada",
  "COMMENTS": "Kommentaarid",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggressiivsus",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "String Puffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Vaikne",
  "RECOVER": "Taasta",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Näita Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Peida UTF",
  "HIDE_LONG_STRINGS": "Peida pikad stringid",
  "COMMENT_MONITORS": "Kommentaar Monitors",
  "ALLOW_CORRECTING": "Lubage parandamine",
  "LABELLED_BLOCKS": "Märgistatud plokid",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Impordid",
  "RECOVER_TYPE_CLASH": "Tüübi kokkupõrge taastamine",
  "RECOVER_TYPE__HINTS": "Taastada tüübi vihjeid",
  "FORCE_RETURNING_IFS": "Force Tagasipöörduvad investeerimisfondid",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG kinnipüüdmine",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Alati genereeri erandite muutuja Catch plokkide jaoks",
  "EXCLUDE_NESTED_TYPES": "Välja arvatud sisseehitatud tüübid",
  "SHOW_DEBUG_LINE_NUMBERS": "Näita silindri numbreid",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Ridade numbrite lisamine baatkoodis",
  "INCLUDE_ERROR_DIAGNOSTICS": "Sisaldab veadiagnostikat",
  "SHOW_SYNTHETIC_MEMBERS": "Näita sünteetilisi liikmeid",
  "SIMPLIFY_MEMBER_REFERENCES": "Lihtsustada liikmete viiteid",
  "MERGE_VARIABLES": "Muutujate ühendamine",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Argumendid",
  "FORCE_EXPLICIT_IMPORTS": "Eksplitsiitsete importide sundimine",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Switch plokid",
  "RETAIN_POINTLESS_SWITCHES": "Säilitada mõttetud lülitid",
  "RETAIN_REDUNDANT_CASTS": "Üleliigsete osade säilitamine",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled (Unikoodiväljund lubatud)",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Reload Resources",
  "RELOAD_RESOURCES_CONFIRM": "Kas olete kindel, et soovite ressursse uuesti laadida?",
  "SELECT_FILE_TITLE": "Valige Faili või kausta avamiseks {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK-d, DEX, klassifailid või Zip-failid",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Valige Väline pistikprogramm",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin in js, java, python, ruby või groovy",
  "FOREIGN_LIBRARY_WARNING": "HOIATUS: Kui see on välja lülitatud, ei eemaldata vananenud raamatukogusid.\n\rSee on ka turvaprobleem.\n\rLÜLITAGE SEE VÄLJA AINULT SIIS, KUI TEATE, MIDA TEETE.",
  "RESET_TITLE": "{PRODUCT_NAME} - Tööruumi lähtestamine",
  "RESET_CONFIRM": "Kas olete kindel, et soovite tööruumi lähtestada?\n\rSee nullib ka teie failinavigatori ja otsingu.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Kas olete kindel, et soovite väljuda?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Teave - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Sulge kõik peale selle",
  "CLOSE_TAB": "Sulge vahekaart",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Palun saatke see veaprotokoll aadressil",
  "PLEASE_SEND_RESOURCES": "Kui teil on asjakohased seaduslikud õigused asjaomasele klassile",
  "ONE_PLUGIN_AT_A_TIME": "Hetkel töötab veel üks plugin, palun oodake, kuni see lõppeb.",
  "ILLEGAL_ACCESS_ERROR": "Palun kasutage selleks Java 15 või vanemat versiooni.",


  "FILES": "Failid",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Kiire failiotsing (failipikendus puudub)",
  "WORK_SPACE": "Tööruum",
  "EXACT": "Täpne",
  "SEARCH": "Otsi",
  "SEARCH_FROM": "Otsing alates:",
  "SEARCH_STRING": "Otsingu string:",
  "SEARCH_REGEX": "Otsing Regex:",
  "OWNER": "Omanik:",
  "NAME": "Nimi:",
  "DESC": "Desc:",
  "SAVE": "Salvesta...",
  "SAVE_AS": "Salvesta kui...",
  "RESULTS": "Tulemused",
  "REFRESH": "Värskenda",
  "ANNOTATION_NAME": "Märge Nimi",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Täpne tee",
  "MIN_SDK_VERSION": "Minimaalne SDK versioon",
  "PRINT_LINE_NUMBERS": "Prindi rea numbrid"
}

```

`src/main/resources/translations/farsi.json`:

```json
{
  "FILE": "فایل",
  "ADD": "اضافه کردن...",
  "NEW_WORKSPACE": "فضای کاری جدید",
  "RELOAD_RESOURCES": "بارگیری مجدد منابع",
  "RUN": "اجرا کن",
  "OPEN": "باز کن...",
  "OPEN_UNSTYLED": "باز کن",
  "QUICK_OPEN": "باز کردن سریع",
  "DELETE": "حذف",
  "NEW": "جدید",
  "EXPAND": "بسط دادن",
  "COLLAPSE": "سقوط - فروپاشی",
  "COMPILE": "گردآوری",
  "SAVE_AS_RUNNABLE_JAR": "ذخیره به عنوان شیشه قابل اجرا ...",
  "SAVE_AS_ZIP": "ذخیره به عنوان Zip ...",
  "SAVE_AS_DEX": "ذخیره به عنوان DEX ...",
  "SAVE_AS_APK": "ذخیره به عنوان APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "کلاسهای باز شده را دوباره کامپایل و ذخیره کنید",
  "DECOMPILE_SAVE_ALL_CLASSES": "کامپایل و ذخیره تمام کلاس ها",
  "RECENT_FILES": "فایل های اخیر",
  "ABOUT": "در باره",
  "EXIT": "خروج",

  "VIEW": "چشم انداز",
  "VISUAL_SETTINGS": "تنظیمات بصری",
  "PANE_1": "صفحه 1",
  "PANE_2": "پنجره 2",
  "PANE_3": "صفحه 3",
  "NONE": "هیچ یک",
  "EDITABLE": "قابل ویرایش",

  "LANGUAGE": "زبان",
  "FONT_SIZE": "اندازه فونت",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "نمایش پرونده در عنوان برگه",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "نام را در عنوان عنوان ساده کنید",
  "SYNCHRONIZED_VIEWING": "مشاهده همزمان",
  "SHOW_CLASS_METHODS": "روش های کلاس را نشان دهید",

  "WINDOW_THEME": "تم پنجره",
  "SYSTEM_THEME": "تم سیستم",
  "DARK_THEME": "تم تاریک",
  "LIGHT_THEME": "تم سبک",
  "ONE_DARK_THEME": "یک تم تاریک",
  "SOLARIZED_DARK_THEME": "تم تاریک خورشیدی",
  "SOLARIZED_LIGHT_THEME": "تم نور خورشیدی",
  "HIGH_CONTRAST_DARK_THEME": "تم تاریک با کنتراست بالا",
  "HIGH_CONTRAST_LIGHT_THEME": "تم نور با کنتراست بالا",
  "ONE_DARK": "یک تاریک",
  "SOLARIZED_DARK": "تاریک خورشیدی",
  "SOLARIZED_LIGHT": "نور خورشیدی",
  "HIGH_CONTRAST_DARK": "تضاد بالا تیره",
  "HIGH_CONTRAST_LIGHT": "نور با کنتراست بالا",
  "TEXT_AREA_THEME": "طرح زمینه متن",
  "DEFAULT_RECOMMENDED_LIGHT": "پیش فرض (نور توصیه شده)",
  "THEME_MATCH": "مسابقه تم (توصیه می شود)",
  "DARK": "تیره (تاریک توصیه شده)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "پیش فرض-Alt",
  "ECLIPSE": "گرفتگی",
  "INTELLIJ": "اینتلیج",
  "VISUAL_STUDIO": "ویژوال استودیو",
  "DRUID_DARK": "دروید (تیره)",
  "MONOKAI_DARK": "مونوکای (تیره)",

  "SETTINGS": "تنظیمات",
  "COMPILE_ON_SAVE": "در ذخیره ذخیره کنید",
  "COMPILE_ON_REFRESH": "کامپایل در تازه کردن",
  "REFRESH_ON_VIEW_CHANGE": "تازه کردن نمای تغییر",
  "DECODE_APK_RESOURCES": "رمزگشایی منابع APK",
  "APK_CONVERSION": "تبدیل APK",
  "APK_CONVERSION_DECODING": "تبدیل / رمزگشایی APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "بزرگ کردن",
  "UPDATE_CHECK": "بررسی به روزرسانی",
  "DELETE_UNKNOWN_LIBS": "پاک کردن کتابهای خارجی / منسوخ شده",
  "FORCE_PURE_ASCII_AS_TEXT": "Ascii خالص را به عنوان متن مجبور کنید",
  "SET_PYTHON_27_EXECUTABLE": "تنظیم Python 2.7 قابل اجرا",
  "SET_PYTHON_30_EXECUTABLE": "Python 3.X را اجرا کنید",
  "SET_JRE_RT_LIBRARY": "کتابخانه JRE RT را تنظیم کنید",
  "SET_OPTIONAL_LIBRARY_FOLDER": "پوشه کتابخانه اختیاری را تنظیم کنید",
  "SET_JAVAC_EXECUTABLE": "Javac را اجرا کنید",

  "JAVA": "جاوا",
  "PROCYON_SETTINGS": "تنظیمات Procyon",
  "CFR_SETTINGS": "تنظیمات CFR",
  "FERNFLOWER_SETTINGS": "تنظیمات FernFlower",
  "PROCYON": "پروسیون",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "کراکتائو",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "اسمالی",
  "SMALI_DEX": "اسمالی / دکس",
  "HEXCODE": "کد هگز",
  "BYTECODE": "کد Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "رمزگشایی Bytecode",
  "DEBUG_HELPERS": "راهنمای اشکال زدایی",
  "APPEND_BRACKETS_TO_LABEL": "براکت ها را به برچسب اضافه کنید",

  "PLUGINS": "پلاگین ها",
  "OPEN_PLUGIN": "افزونه را باز کنید ...",
  "RECENT_PLUGINS": "پلاگین های اخیر",
  "CODE_SEQUENCE_DIAGRAM": "نمودار دنباله کد",
  "MALICIOUS_CODE_SCANNER": "اسکنر کد مخرب",
  "SHOW_MAIN_METHODS": "روشهای اصلی را نشان دهید",
  "SHOW_ALL_STRINGS": "نمایش همه رشته ها",
  "REPLACE_STRINGS": "رشته ها را جایگزین کنید",
  "STACK_FRAMES_REMOVER": "پاک کننده قاب های پشته ای",
  "ZKM_STRING_DECRYPTER": "رمزگشای رشته ای ZKM",
  "ALLATORI_STRING_DECRYPTER": "رمزگشای رشته ای Allatori",
  "ZSTRINGARRAY_DECRYPTER": "رمزگشای ZStringArray",
  "VIEW_ANDROID_PERMISSIONS": "مجوزهای Android را مشاهده کنید",
  "VIEW_MANIFEST": "مشاهده آشکار",
  "CHANGE_CLASSFILE_VERSIONS": "نسخه های ClassFile را تغییر دهید",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "جداکننده Bytecode",
  "DISASSEMBLER": "جدا کردن دستگاه",

  "ERROR": "خطا",
  "NEW_JAVA_PLUGIN": "پلاگین جاوا جدید",
  "NEW_JAVASCRIPT_PLUGIN": "پلاگین Javascript جدید",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "رفع پیشنهاد: در صورت عدم موفقیت دوباره در کلاس ، تازه سازی را کلیک کنید.",
  "SUGGESTED_FIX_COMPILER_ERROR": "رفع پیشنهاد: مشاهده> صفحه> Krakatau> Bytecode را امتحان کنید و قابلیت ویرایش را فعال کنید.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "هشدار: در حال حاضر هیچ کامپایلری انتخاب نشده است. View> Pane را امتحان کنید و یک decompiler را انتخاب کنید.",
  "COMPILER_TIP": "به خاطر داشته باشید که اکثر decompiler ها نمی توانند کلاس های سازگار تولید کنند",
  "FIRST_OPEN_A_RESOURCE": "ابتدا یک منبع در داخل BCV (کلاس ، jar ، zip یا apk) باز کنید",
  "FIRST_OPEN_A_CLASS": "ابتدا یک منبع طبقه بندی درون BCV (jar ، zip ، apk ، dex) باز کنید",
  "FIRST_VIEW_A_CLASS": "ابتدا یک فایل کلاس را در داخل یک برگه مشاهده کنید.",
  "DRAG_CLASS_JAR": "کلاس / jar / zip / APK / DEX را به اینجا بکشید",

  "YES": "آره",
  "NO": "نه",
  "ERROR2": "خطا:",
  "PROCESS2": "روند:",
  "EXIT_VALUE_IS": "مقدار خروجی:",
  "JAVA_COMPILE_FAILED": "جاوا کامپایل نشد",
  "ERROR_COMPILING_CLASS": "خطا در تنظیم کلاس",
  "COMPILER": "به خاطر داشته باشید که اکثر decompiler ها نمی توانند کلاس های سازگار تولید کنند",
  "SELECT_LIBRARY_FOLDER": "پوشه کتابخانه را انتخاب کنید",
  "SELECT_JAVA_RT": "JRE RT Jar را انتخاب کنید",
  "SELECT_JAVA": "Java Executable را انتخاب کنید",
  "SELECT_JAVAC": "Javac Executable را انتخاب کنید",
  "SELECT_JAVA_TOOLS": "Java Tools Jar را انتخاب کنید",
  "SELECT_PYTHON_2": "Python 2.7 Executable را انتخاب کنید",
  "SELECT_PYTHON_3": "Python 3.x Executable را انتخاب کنید",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (یا PyPy 2.7 برای سرعت) قابل اجرا",
  "PYTHON_3_EXECUTABLE": "Python 3.x (یا PyPy 3.x برای سرعت) قابل اجرا",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "شما باید مسیر اجرایی Python 2.7 (یا PyPy 2.7 برای سرعت) را تنظیم کنید.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "شما باید مسیر اجرایی Python 3.x خود را تنظیم کنید (یا PyPy 3.x برای سرعت).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "شما باید کتابخانه JRE RT خود را تنظیم کنید.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "جاوا قابل اجرا (در داخل JRE C: / Program Files / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Javac قابل اجرا (به JDK C نیاز دارد: / برنامه های پرونده / جاوا / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside of JDK C: / Program Files / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C: / Program Files / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "پوشه کتابخانه اختیاری (کامپایلر و Krakatau)",

  "HIDE_BRIDGE_METHODS": "روش های پل را مخفی کنید",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "اعضای کلاس مصنوعی را مخفی کنید",
  "DECOMPILE_INNER_CLASSES": "کلاسهای داخلی را دوباره کامپایل کنید",
  "COLLAPSE_14_CLASS_REFERENCES": "جمع کردن منابع کلاس 1.4",
  "DECOMPILE_ASSERTIONS": "ادعاها را دوباره کامپایل کنید",
  "HIDE_EMPTY_SUPER_INVOCATION": "فراخوانی فوق العاده خالی را پنهان کنید",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "سازنده پیش فرض خالی را پنهان کنید",
  "DECOMPILE_GENERIC_SIGNATURES": "امضای عمومی را دوباره کامپایل کنید",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "فرض کنید بازگشت استثنا ندارد",
  "DECOMPILE_ENUMERATIONS": "از شمارش مجدد کامپایل کنید",
  "REMOVE_GETCLASS_INVOCATION": "فراخوانی getClass () را حذف کنید",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "int 1 را به صورت boolean true تفسیر کنید",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "مجاز نیست ویژگی صاف تنظیم شود",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "انواع بدون نام را به عنوان java.lang.Object در نظر بگیرید",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "نام متغیرها را از اطلاعات اشکال زدایی بازسازی کنید",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "دامنه های استثنای خالی را حذف کنید",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline بالاخره ساختار می دهد",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "فقط نویسه های ASCII به صورت رشته ای مجاز باشند",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "تغییر نام کلاسها و عناصر کلاس مبهم",

  "DECODE_ENUM_SWITCH": "رمزگشایی Enum سوئیچ",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "رمزگشایی رشته سوئیچ",
  "ARRAYITER": "آرایه کننده",
  "COLLECTIONITER": "جمع کننده",
  "INNER_CLASSES": "کلاسهای داخلی",
  "REMOVE_BOILER_PLATE": "صفحه دیگ بخار را بردارید",
  "REMOVE_INNER_CLASS_SYNTHETICS": "مصنوعات کلاس داخلی را حذف کنید",
  "DECODE_LAMBDAS": "رمزگشایی لامبدا",
  "LIFT__CONSTRUCTOR_INIT": "سازنده آسانسور",
  "REMOVE_DEAD_METHODS": "روش های مرده را حذف کنید",
  "REMOVE_BAD_GENERICS": "عرفان بد را حذف کنید",
  "SUGAR_ASSERTS": "قند ادعا می کند",
  "SUGAR_BOXING": "شکر بوکس",
  "SHOW_VERSION": "نمایش نسخه",
  "DECODE_FINALLY": "سرانجام رمزگشایی کنید",
  "TIDY_MONITORS": "مانیتورهای مرتب",
  "LENIENT": "نرم",
  "DUMP_CLASSPATH": "Classpath را رها کنید",
  "COMMENTS": "نظرات",
  "FORCE_TOP_SORT": "مرتب سازی بر بالا",
  "FORCE_TOP_SORT_AGGRESS": "تجمیع مرتب سازی بر اساس بالا",
  "FORCE_EXCEPTION_PRUNE": "هرس استثنای نیرو",
  "STRING_BUFFER": "بافر رشته ای",
  "STRING_BUILDER": "ساز ساز",
  "SILENT": "بی صدا",
  "RECOVER": "بازیابی",
  "OVERRIDE": "لغو کردن",
  "SHOW_INFERRABLE": "نمایش غیر قابل تحمل",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate کنید",
  "HIDE_UTF": "UTF را مخفی کنید",
  "HIDE_LONG_STRINGS": "رشته های بلند را پنهان کنید",
  "COMMENT_MONITORS": "مانیتورهای نظر",
  "ALLOW_CORRECTING": "اجازه تصحیح را بدهید",
  "LABELLED_BLOCKS": "بلوک های دارای برچسب",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "واردات لانگ را مخفی کنید",
  "RECOVER_TYPE_CLASH": "بازیابی نوع برخورد",
  "RECOVER_TYPE__HINTS": "بازیابی نکات نوع",
  "FORCE_RETURNING_IFS": "بازگرداندن IF ها",
  "FOR_LOOP_AGG_CAPTURE": "برای Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "همیشه متغیر استثنا برای بلوکهای Catch ایجاد کنید",
  "EXCLUDE_NESTED_TYPES": "انواع Nested را حذف کنید",
  "SHOW_DEBUG_LINE_NUMBERS": "نمایش شماره خط اشکال زدایی",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "شماره های خط را در Bytecode بگنجانید",
  "INCLUDE_ERROR_DIAGNOSTICS": "موارد عیب یابی را وارد کنید",
  "SHOW_SYNTHETIC_MEMBERS": "نمایش اعضای مصنوعی",
  "SIMPLIFY_MEMBER_REFERENCES": "مراجع اعضا را ساده کنید",
  "MERGE_VARIABLES": "ادغام متغیرها",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "استدلالهای نوع صریح را مجبور کنید",
  "FORCE_EXPLICIT_IMPORTS": "واردات صریح را مجبور کنید",
  "FLATTEN_SWITCH_BLOCKS": "بلوک های تخت سوئیچ",
  "RETAIN_POINTLESS_SWITCHES": "سوئیچ های بی هدف را حفظ کنید",
  "RETAIN_REDUNDANT_CASTS": "گچ های اضافی را حفظ کنید",
  "UNICODE_OUTPUT_ENABLED": "خروجی یونیکد فعال است",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - بارگیری مجدد منابع",
  "RELOAD_RESOURCES_CONFIRM": "آیا مطمئن هستید که می خواهید منابع را دوباره بارگیری کنید؟",
  "SELECT_FILE_TITLE": "پرونده یا پوشه را انتخاب کنید تا در {BCV} باز شود",
  "SELECT_FILE_DESCRIPTION": "APK ، DEX ، فایلهای کلاس یا بایگانی های ZIP / Jar / War",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "پلاگین خارجی را انتخاب کنید",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "پلاگین خارجی BCV در js ، java ، python ، ruby ​​یا groovy",
  "FOREIGN_LIBRARY_WARNING": "هشدار: با تغییر این کار ، کتابخانه های قدیمی حذف نمی شوند.\n\rاین نیز یک مسئله امنیتی است.\n\rاگر می دانید چه کاری انجام می دهید فقط آن را خاموش کنید.",
  "RESET_TITLE": "{PRODUCT_NAME} - بازنشانی فضای کاری",
  "RESET_CONFIRM": "آیا مطمئن هستید که می خواهید فضای کاری را دوباره تنظیم کنید؟\n\rهمچنین مرورگر پرونده شما را بازنشانی و جستجو می کند.",
  "EXIT_TITLE": "{PRODUCT_NAME} - خروج",
  "EXIT_CONFIRM": "آیا مطمئن هستید که میخواهید خارج شوید؟",
  "ABOUT_TITLE": "{PRODUCT_NAME} - درباره - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - کنسول پلاگین",
  "CLOSE_ALL_BUT_THIS": "همه را ببند اما",
  "CLOSE_TAB": "بستن برگه",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "لطفا این گزارش خطا را به",
  "PLEASE_SEND_RESOURCES": "اگر از حقوق قانونی مناسبی برای پرونده مربوط به کلاس / jar / apk برخوردار هستید ، آن را نیز وارد کنید.",
  "ONE_PLUGIN_AT_A_TIME": "در حال حاضر افزونه دیگری در حال اجرا است، لطفاً منتظر بمانید تا اجرای آن به پایان برسد.",
  "ILLEGAL_ACCESS_ERROR": "لطفاً برای این کار از جاوا 15 یا بالاتر استفاده کنید.",


  "FILES": "فایل ها",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "جستجوی سریع پرونده (بدون پسوند پرونده)",
  "WORK_SPACE": "فضای کاری",
  "EXACT": "دقیق",
  "SEARCH": "جستجو کردن",
  "SEARCH_FROM": "جستجو از:",
  "SEARCH_STRING": "رشته جستجو:",
  "SEARCH_REGEX": "جستجو Regex:",
  "OWNER": "مالک:",
  "NAME": "نام:",
  "DESC": "جدول:",
  "SAVE": "صرفه جویی...",
  "SAVE_AS": "ذخیره به عنوان...",
  "RESULTS": "نتایج",
  "REFRESH": "تازه کردن",
  "ANNOTATION_NAME": "نام حاشیه نویسی",
  "MATCH_CASE": "مورد مطابقت",
  "EXACT_PATH": "مسیر دقیق",
  "MIN_SDK_VERSION": "حداقل نسخه SDK",
  "PRINT_LINE_NUMBERS": "چاپ شماره خطوط"
}

```

`src/main/resources/translations/finnish.json`:

```json
{
  "FILE": "Tiedosto",
  "ADD": "Lisää...",
  "NEW_WORKSPACE": "Uusi työtila",
  "RELOAD_RESOURCES": "Lataa resurssit uudelleen",
  "RUN": "Suorita",
  "OPEN": "Avaa...",
  "OPEN_UNSTYLED": "Avaa",
  "QUICK_OPEN": "Nopea avaaminen",
  "DELETE": "Poista",
  "NEW": "Uusi",
  "EXPAND": "Laajenna",
  "COLLAPSE": "Romahdus",
  "COMPILE": "Käännä",
  "SAVE_AS_RUNNABLE_JAR": "Save As Runnable Jar...",
  "SAVE_AS_ZIP": "Tallenna Zip-tiedostona...",
  "SAVE_AS_DEX": "Tallenna DEX...",
  "SAVE_AS_APK": "Tallenna APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Avattujen luokkien purkaminen ja tallentaminen",
  "DECOMPILE_SAVE_ALL_CLASSES": "Purkaa ja tallenna kaikki luokat",
  "RECENT_FILES": "Viimeisimmät tiedostot",
  "ABOUT": "Tietoja",
  "EXIT": "Poistu",

  "VIEW": "Näytä",
  "VISUAL_SETTINGS": "Visuaaliset asetukset",
  "PANE_1": "Paneeli 1",
  "PANE_2": "Paneeli 2",
  "PANE_3": "Paneeli 3",
  "NONE": "Ei ole",
  "EDITABLE": "Muokattavissa",

  "LANGUAGE": "Kieli",
  "FONT_SIZE": "Kirjasinkoko",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Näytä tiedosto välilehden otsikossa",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Yksinkertaista nimi välilehden otsikossa",
  "SYNCHRONIZED_VIEWING": "Synkronoitu katselu",
  "SHOW_CLASS_METHODS": "Näytä luokan menetelmät",

  "WINDOW_THEME": "Ikkuna-teema",
  "SYSTEM_THEME": "Järjestelmän teema",
  "DARK_THEME": "Tumma teema",
  "LIGHT_THEME": "Valo teema",
  "ONE_DARK_THEME": "Yksi tumma teema",
  "SOLARIZED_DARK_THEME": "Solarized tumma teema",
  "SOLARIZED_LIGHT_THEME": "Solarized Light teema",
  "HIGH_CONTRAST_DARK_THEME": "Korkea kontrasti tumma teema",
  "HIGH_CONTRAST_LIGHT_THEME": "Korkea kontrasti Light teema",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized tumma",
  "SOLARIZED_LIGHT": "Solarized valo",
  "HIGH_CONTRAST_DARK": "Korkea kontrasti tumma",
  "HIGH_CONTRAST_LIGHT": "Korkean kontrastin valo",
  "TEXT_AREA_THEME": "Tekstialueen teema",
  "DEFAULT_RECOMMENDED_LIGHT": "Oletusarvo (suositeltu valo)",
  "THEME_MATCH": "Teemaottelu (suositeltava)",
  "DARK": "Tumma (suositeltava tumma)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druidi (Tumma)",
  "MONOKAI_DARK": "Monokai (tumma)",

  "SETTINGS": "Asetukset",
  "COMPILE_ON_SAVE": "Compile On Save",
  "COMPILE_ON_REFRESH": "Käännä päivityksen yhteydessä",
  "REFRESH_ON_VIEW_CHANGE": "Päivitä näkymän vaihtuessa",
  "DECODE_APK_RESOURCES": "Decode APK Resurssit",
  "APK_CONVERSION": "APK-muunnos",
  "APK_CONVERSION_DECODING": "APK-muunnos",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Päivityksen tarkistus",
  "DELETE_UNKNOWN_LIBS": "Poista ulkomainen",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Aseta Python 2.7 Executable",
  "SET_PYTHON_30_EXECUTABLE": "Set Python 3.X Executable",
  "SET_JRE_RT_LIBRARY": "Aseta JRE RT Library",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Aseta valinnainen kirjastokansio",
  "SET_JAVAC_EXECUTABLE": "Set Javac Executable",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyonin asetukset",
  "CFR_SETTINGS": "CFR-asetukset",
  "FERNFLOWER_SETTINGS": "FernFlower asetukset",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Heksakoodi",
  "BYTECODE": "Bytekoodi",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytekoodin purkuohjelma",
  "DEBUG_HELPERS": "Vianmäärityksen apuohjelmat",
  "APPEND_BRACKETS_TO_LABEL": "Liitä hakasulkeet etikettiin",

  "PLUGINS": "Liitännäiset",
  "OPEN_PLUGIN": "Avaa Plugin...",
  "RECENT_PLUGINS": "Viimeisimmät liitännäiset",
  "CODE_SEQUENCE_DIAGRAM": "Koodijaksokaavio",
  "MALICIOUS_CODE_SCANNER": "Haitallisen koodin skanneri",
  "SHOW_MAIN_METHODS": "Näytä tärkeimmät menetelmät",
  "SHOW_ALL_STRINGS": "Näytä kaikki jouset",
  "REPLACE_STRINGS": "Korvaa merkkijonot",
  "STACK_FRAMES_REMOVER": "Pino kehykset Remover",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Näytä Androidin käyttöoikeudet",
  "VIEW_MANIFEST": "Näytä manifesti",
  "CHANGE_CLASSFILE_VERSIONS": "ClassFile-versioiden muuttaminen",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Bytekoodin purkuohjelma",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Virhe",
  "NEW_JAVA_PLUGIN": "Uusi Java-liitännäinen",
  "NEW_JAVASCRIPT_PLUGIN": "Uusi Javascript-liitännäinen",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Ehdotettu korjaus: Napsauta päivitä luokka, jos se epäonnistuu uudelleen kokeile toista dekompilaattoria.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Korjausehdotus: Kokeile View>Pane>Krakatau>Bytecode ja ota Editable käyttöön.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "VAROITUS: Dekompileria ei ole valittu. Kokeile Näytä>Ruutu ja valitse dekompilaattori.",
  "COMPILER_TIP": "Muista, että useimmat dekompilaattorit eivät pysty tuottamaan käännettäviä luokkia.",
  "FIRST_OPEN_A_RESOURCE": "Avaa ensin resurssi BCV:n sisällä (luokka, jar-, zip- tai apk-tiedosto).",
  "FIRST_OPEN_A_CLASS": "Avaa ensin luokkatiedoston resurssi BCV:n sisällä (jar, zip, apk, dex).",
  "FIRST_VIEW_A_CLASS": "Näytä ensin luokkatiedosto välilehden sisällä.",
  "DRAG_CLASS_JAR": "Vedä luokka",

  "YES": "Kyllä",
  "NO": "Ei",
  "ERROR2": "Virhe:",
  "PROCESS2": "Prosessi:",
  "EXIT_VALUE_IS": "Exit Value on:",
  "JAVA_COMPILE_FAILED": "Java Compile epäonnistui",
  "ERROR_COMPILING_CLASS": "Virhe luokan kääntämisessä",
  "COMPILER": "Muista, että useimmat dekompilaattorit eivät pysty tuottamaan käännettäviä luokkia.",
  "SELECT_LIBRARY_FOLDER": "Valitse kirjastokansio",
  "SELECT_JAVA_RT": "Valitse JRE RT Jar",
  "SELECT_JAVA": "Valitse Java Executable",
  "SELECT_JAVAC": "Valitse Javac Executable",
  "SELECT_JAVA_TOOLS": "Valitse Java Tools Jar",
  "SELECT_PYTHON_2": "Valitse Python 2.7 Executable",
  "SELECT_PYTHON_3": "Valitse Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (tai PyPy 2.7 nopeuden vuoksi) Suoritettava tiedosto",
  "PYTHON_3_EXECUTABLE": "Python 3.x (tai PyPy 3.x nopeuden vuoksi) Suoritettava tiedosto",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Sinun on määritettävä Python 2.7:n (tai PyPy 2.7:n nopeuden vuoksi) suorituspolku.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Sinun on määritettävä Python 3.x:n (tai PyPy 3.x:n nopeuden vuoksi) suorituspolku.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Sinun on asetettava JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (JRE C:n sisällä:",
  "JAVAC_EXECUTABLE": "Javac Executable (Vaatii JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (JDK C:n sisällä:",
  "JAVA_RT_JAR": "Java RT Jar (JRE C:n sisällä):",
  "OPTIONAL_LIBRARY_FOLDER": "Valinnainen kirjastokansio (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Piilota siltamenetelmät",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Piilota synteettiset luokan jäsenet",
  "DECOMPILE_INNER_CLASSES": "Sisäisten luokkien purkaminen",
  "COLLAPSE_14_CLASS_REFERENCES": "Romahdus 1.4 luokkaviittaukset",
  "DECOMPILE_ASSERTIONS": "Väitteiden purkaminen",
  "HIDE_EMPTY_SUPER_INVOCATION": "Piilota tyhjä superkutsu",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Piilota tyhjä oletuskonstruktori",
  "DECOMPILE_GENERIC_SIGNATURES": "Yleisten allekirjoitusten purkaminen",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Oletetaan, että paluu ei aiheuta poikkeuksia",
  "DECOMPILE_ENUMERATIONS": "Luetteloiden purkaminen",
  "REMOVE_GETCLASS_INVOCATION": "Poista getClass()-kutsu",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Tulkitse int 1 boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Salli synteettisen attribuutin asettamatta jättäminen",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Pidä nimettömiä tyyppejä java.lang.Objectina",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Muuttujien nimien rekonstruointi vikailmoituksesta",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Tyhjien poikkeusalueiden poistaminen",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline lopuksi rakenteet",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Salli vain ASCII-merkit merkkijonoissa.",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Epäselvien luokkien ja luokkaelementtien uudelleennimeäminen",

  "DECODE_ENUM_SWITCH": "Decode Enum -kytkin",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dekoodaa merkkijono Kytkin",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Sisäiset luokat",
  "REMOVE_BOILER_PLATE": "Poista kattilalevy",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Poista sisäisen luokan synteettiset aineet",
  "DECODE_LAMBDAS": "Lambdojen purkaminen",
  "LIFT__CONSTRUCTOR_INIT": "Lift Constructor Init",
  "REMOVE_DEAD_METHODS": "Poista kuolleet menetelmät",
  "REMOVE_BAD_GENERICS": "Poista huonot geneeriset tuotteet",
  "SUGAR_ASSERTS": "Sokeri väittää",
  "SUGAR_BOXING": "Sokerinyrkkeily",
  "SHOW_VERSION": "Näytä versio",
  "DECODE_FINALLY": "Decode Lopuksi",
  "TIDY_MONITORS": "Siistit näytöt",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Tyhjennä luokkapolku",
  "COMMENTS": "Kommentit",
  "FORCE_TOP_SORT": "Pakota ylin lajittelu",
  "FORCE_TOP_SORT_AGGRESS": "Voima Top Lajittelu Aggressio",
  "FORCE_EXCEPTION_PRUNE": "Pakko Poikkeus Prune",
  "STRING_BUFFER": "String Puskuri",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Hiljainen",
  "RECOVER": "Palauta",
  "OVERRIDE": "Ohita",
  "SHOW_INFERRABLE": "Näytä Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Voima Cond Propagate",
  "HIDE_UTF": "Piilota UTF",
  "HIDE_LONG_STRINGS": "Piilota pitkät jouset",
  "COMMENT_MONITORS": "Kommentti Monitorit",
  "ALLOW_CORRECTING": "Salli korjaaminen",
  "LABELLED_BLOCKS": "Merkityt lohkot",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang maahantuojat",
  "RECOVER_TYPE_CLASH": "Palauta tyyppi Clash",
  "RECOVER_TYPE__HINTS": "Palauta tyyppivihjeitä",
  "FORCE_RETURNING_IFS": "Pakottaa palaavat sijoitusrahastot",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Luo aina poikkeusmuuttuja Catch-lohkoille",
  "EXCLUDE_NESTED_TYPES": "Sulje pois sisäkkäiset tyypit",
  "SHOW_DEBUG_LINE_NUMBERS": "Näytä vianmääritysrivien numerot",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Rivinumeroiden sisällyttäminen tavukoodiin",
  "INCLUDE_ERROR_DIAGNOSTICS": "Sisällytä virheen diagnostiikka",
  "SHOW_SYNTHETIC_MEMBERS": "Näytä synteettiset jäsenet",
  "SIMPLIFY_MEMBER_REFERENCES": "Yksinkertaista jäsenviittauksia",
  "MERGE_VARIABLES": "Muuttujien yhdistäminen",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Pakota eksplisiittiset tyyppiargumentit",
  "FORCE_EXPLICIT_IMPORTS": "Pakota eksplisiittinen tuonti",
  "FLATTEN_SWITCH_BLOCKS": "Litistä kytkinlohkot",
  "RETAIN_POINTLESS_SWITCHES": "Säilytä turhat kytkimet",
  "RETAIN_REDUNDANT_CASTS": "Ylimääräisten valukappaleiden säilyttäminen",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Lataa resurssit uudelleen",
  "RELOAD_RESOURCES_CONFIRM": "Haluatko varmasti ladata resurssit uudelleen?",
  "SELECT_FILE_TITLE": "Valitse avattava tiedosto tai kansio {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Luokkatiedostot tai Zip-tiedostot",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Valitse External Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin in js, java, python, ruby tai groovy",
  "FOREIGN_LIBRARY_WARNING": "VAROITUS: Kun tämä on kytketty pois päältä, vanhentuneita kirjastoja EI poisteta.\n\rSe on myös tietoturvaongelma.\n\rKYTKE SE POIS PÄÄLTÄ VAIN, JOS TIEDÄT MITÄ OLET TEKEMÄSSÄ.",
  "RESET_TITLE": "{PRODUCT_NAME} - Nollaa työtila",
  "RESET_CONFIRM": "Haluatko varmasti nollata työtilan?\n\rSe nollaa myös tiedostonavigaattorin ja haun.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Haluatko varmasti poistua?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Tietoja - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Liitännäisen konsoli",
  "CLOSE_ALL_BUT_THIS": "Sulje kaikki paitsi tämä",
  "CLOSE_TAB": "Sulje välilehti",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Lähetä tämä virheloki osoitteeseen",
  "PLEASE_SEND_RESOURCES": "Jos sinulla on asianmukaiset lailliset oikeudet kyseiseen luokkaan.",
  "ONE_PLUGIN_AT_A_TIME": "Parhaillaan on käynnissä toinen lisäosa, odota, että sen suoritus päättyy.",
  "ILLEGAL_ACCESS_ERROR": "Käytä tähän Java 15:tä tai vanhempaa Java-ohjelmaa.",


  "FILES": "Tiedostot",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Tiedoston pikahaku (ei tiedostopäätettä)",
  "WORK_SPACE": "Työtila",
  "EXACT": "Tarkka",
  "SEARCH": "Etsi",
  "SEARCH_FROM": "Haku osoitteesta:",
  "SEARCH_STRING": "Hakujono:",
  "SEARCH_REGEX": "Etsi Regex:",
  "OWNER": "Omistaja:",
  "NAME": "Nimi:",
  "DESC": "Desc:",
  "SAVE": "Tallenna...",
  "SAVE_AS": "Tallenna nimellä...",
  "RESULTS": "Tulokset",
  "REFRESH": "Päivitä",
  "ANNOTATION_NAME": "Merkinnän nimi",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Tarkka polku",
  "MIN_SDK_VERSION": "SDK:n vähimmäisversio",
  "PRINT_LINE_NUMBERS": "Tulosta rivinumerot"
}

```

`src/main/resources/translations/french.json`:

```json
{
  "FILE": "Fichier",
  "ADD": "Ajouter...",
  "NEW_WORKSPACE": "Nouvel espace de travail",
  "RELOAD_RESOURCES": "Recharger les ressources",
  "RUN": "Exécuter",
  "OPEN": "Ouvrez...",
  "OPEN_UNSTYLED": "Ouvrir",
  "QUICK_OPEN": "Ouverture rapide",
  "DELETE": "Supprimer",
  "NEW": "Nouveau",
  "EXPAND": "Développez",
  "COLLAPSE": "Collapse",
  "COMPILE": "Compiler",
  "SAVE_AS_RUNNABLE_JAR": "Enregistrer en tant que pot exécutable...",
  "SAVE_AS_ZIP": "Enregistrer comme Zip...",
  "SAVE_AS_DEX": "Enregistrer en tant que DEX...",
  "SAVE_AS_APK": "Enregistrer sous APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Décompilation et sauvegarde des classes ouvertes",
  "DECOMPILE_SAVE_ALL_CLASSES": "Décompilation et sauvegarde de toutes les classes",
  "RECENT_FILES": "Fichiers récents",
  "ABOUT": "À propos de",
  "EXIT": "Sortie",

  "VIEW": "Voir",
  "VISUAL_SETTINGS": "Paramètres visuels",
  "PANE_1": "Volet 1",
  "PANE_2": "Volet 2",
  "PANE_3": "Volet 3",
  "NONE": "Aucun",
  "EDITABLE": "Modifiable",

  "LANGUAGE": "Langue",
  "FONT_SIZE": "Taille de la police",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Afficher le fichier dans le titre de l'onglet",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Simplifier le nom dans le titre de l'onglet",
  "SYNCHRONIZED_VIEWING": "Visualisation synchronisée",
  "SHOW_CLASS_METHODS": "Afficher les méthodes de la classe",

  "WINDOW_THEME": "Thème de la fenêtre",
  "SYSTEM_THEME": "Thème du système",
  "DARK_THEME": "Thème sombre",
  "LIGHT_THEME": "Thème de la lumière",
  "ONE_DARK_THEME": "Un thème sombre",
  "SOLARIZED_DARK_THEME": "Thème sombre Solarized",
  "SOLARIZED_LIGHT_THEME": "Thème de la lumière solarisée",
  "HIGH_CONTRAST_DARK_THEME": "Thème foncé à fort contraste",
  "HIGH_CONTRAST_LIGHT_THEME": "Thème lumineux à fort contraste",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Dark Solarized",
  "SOLARIZED_LIGHT": "Lumière solaire",
  "HIGH_CONTRAST_DARK": "Foncé à fort contraste",
  "HIGH_CONTRAST_LIGHT": "Lumière à fort contraste",
  "TEXT_AREA_THEME": "Thème de la zone de texte",
  "DEFAULT_RECOMMENDED_LIGHT": "Par défaut (lumière recommandée)",
  "THEME_MATCH": "Match à thème (recommandé)",
  "DARK": "Foncé (Foncé recommandé)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Allocation par défaut",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druide (Sombre)",
  "MONOKAI_DARK": "Monokai (Dark)",

  "SETTINGS": "Paramètres",
  "COMPILE_ON_SAVE": "Compiler sur l'enregistrement",
  "COMPILE_ON_REFRESH": "Compilation sur rafraîchissement",
  "REFRESH_ON_VIEW_CHANGE": "Rafraîchir en cas de changement de vue",
  "DECODE_APK_RESOURCES": "Décoder les ressources APK",
  "APK_CONVERSION": "Conversion APK",
  "APK_CONVERSION_DECODING": "Conversion APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Vérification de la mise à jour",
  "DELETE_UNKNOWN_LIBS": "Supprimer les étrangers",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Définir l'exécutable Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Définir l'exécutable Python 3.X",
  "SET_JRE_RT_LIBRARY": "Définir la bibliothèque JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Définir le dossier de bibliothèque facultatif",
  "SET_JAVAC_EXECUTABLE": "Définir l'exécutable Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Paramètres de Procyon",
  "CFR_SETTINGS": "Paramètres du CFR",
  "FERNFLOWER_SETTINGS": "Paramètres de FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Décompilateur de bytecode",
  "DEBUG_HELPERS": "Aides au débogage",
  "APPEND_BRACKETS_TO_LABEL": "Ajouter des parenthèses à l'étiquette",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Ouvrir le plugin...",
  "RECENT_PLUGINS": "Plugins récents",
  "CODE_SEQUENCE_DIAGRAM": "Diagramme de la séquence des codes",
  "MALICIOUS_CODE_SCANNER": "Scanner de codes malveillants",
  "SHOW_MAIN_METHODS": "Afficher les méthodes principales",
  "SHOW_ALL_STRINGS": "Afficher toutes les cordes",
  "REPLACE_STRINGS": "Remplacer les cordes",
  "STACK_FRAMES_REMOVER": "Suppression des cadres d'empilage",
  "ZKM_STRING_DECRYPTER": "Décrypteur de chaîne ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "Décrypteur ZStringArray",
  "VIEW_ANDROID_PERMISSIONS": "Voir les permissions Android",
  "VIEW_MANIFEST": "Voir le manifeste",
  "CHANGE_CLASSFILE_VERSIONS": "Modifier les versions des fichiers de classe",



  "PROCYON_DECOMPILER": "Décompilateur Procyon",
  "CFR_DECOMPILER": "Décompilateur CFR",
  "FERNFLOWER_DECOMPILER": "Décompilateur FernFlower",
  "JADX_DECOMPILER": "Décompilateur JADX",
  "JD_DECOMPILER": "Décompilateur JD-GUI",
  "BYTECODE_DISASSEMBLER": "Désassembleur de bytecode",
  "DISASSEMBLER": "Désassembleur",

  "ERROR": "Erreur",
  "NEW_JAVA_PLUGIN": "Nouveau plugin Java",
  "NEW_JAVASCRIPT_PLUGIN": "Nouveau plugin Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Correction suggérée : Cliquez sur rafraîchir la classe, si cela échoue à nouveau, essayez un autre décompilateur.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Correction suggérée : Essayez View>Pane>Krakatau>Bytecode et activez Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ATTENTION : Aucun décompilateur n'est actuellement sélectionné. Essayez View>Pane et choisissez un décompilateur.",
  "COMPILER_TIP": "Gardez à l'esprit que la plupart des décompilateurs ne peuvent pas produire des classes compilables.",
  "FIRST_OPEN_A_RESOURCE": "Ouvrez d'abord une ressource dans le BCV (classe, jar, zip ou fichier apk).",
  "FIRST_OPEN_A_CLASS": "Ouvrez d'abord un fichier de classe dans le BCV (jar, zip, apk, dex).",
  "FIRST_VIEW_A_CLASS": "Visualisez d'abord un fichier de classe à l'intérieur d'un onglet.",
  "DRAG_CLASS_JAR": "Classe d'entraînement",

  "YES": "Oui",
  "NO": "Non",
  "ERROR2": "Erreur :",
  "PROCESS2": "Processus :",
  "EXIT_VALUE_IS": "La valeur de sortie est :",
  "JAVA_COMPILE_FAILED": "La compilation de Java a échoué",
  "ERROR_COMPILING_CLASS": "Erreur de compilation de la classe",
  "COMPILER": "Gardez à l'esprit que la plupart des décompilateurs ne peuvent pas produire des classes compilables.",
  "SELECT_LIBRARY_FOLDER": "Sélectionnez le dossier de la bibliothèque",
  "SELECT_JAVA_RT": "Sélectionnez JRE RT Jar",
  "SELECT_JAVA": "Sélectionnez l'exécutable Java",
  "SELECT_JAVAC": "Sélectionnez l'exécutable Javac",
  "SELECT_JAVA_TOOLS": "Sélectionnez Java Tools Jar",
  "SELECT_PYTHON_2": "Sélectionnez l'exécutable Python 2.7",
  "SELECT_PYTHON_3": "Sélectionnez l'exécutable Python 3.x",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (ou PyPy 2.7 pour plus de rapidité) Exécutable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (ou PyPy 3.x pour la vitesse) Exécutable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Vous devez définir le chemin de votre exécutable Python 2.7 (ou PyPy 2.7 pour plus de rapidité).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Vous devez définir le chemin de votre exécutable Python 3.x (ou PyPy 3.x pour plus de rapidité).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Vous devez définir votre bibliothèque JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Exécutable Java (à l'intérieur de JRE C) :",
  "JAVAC_EXECUTABLE": "Exécutable Javac (nécessite le JDK C.)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (dans le JDK C) :",
  "JAVA_RT_JAR": "Java RT Jar (à l'intérieur de JRE C) :",
  "OPTIONAL_LIBRARY_FOLDER": "Dossier de bibliothèque optionnel (Compilateur et Krakatau)",

  "HIDE_BRIDGE_METHODS": "Cacher les méthodes de pontage",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Masquer les membres de la classe synthétique",
  "DECOMPILE_INNER_CLASSES": "Décompilation des classes internes",
  "COLLAPSE_14_CLASS_REFERENCES": "Collapse 1.4 références de classe",
  "DECOMPILE_ASSERTIONS": "Décompiler les assertions",
  "HIDE_EMPTY_SUPER_INVOCATION": "Masquer les invocations de super vide",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Cacher le constructeur vide par défaut",
  "DECOMPILE_GENERIC_SIGNATURES": "Décompilation des signatures génériques",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Supposons que le retour ne lève pas d'exceptions",
  "DECOMPILE_ENUMERATIONS": "Décompiler les énumérations",
  "REMOVE_GETCLASS_INVOCATION": "Suppression de l'invocation de getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpréter int 1 comme booléen vrai",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Permet de ne pas définir d'attribut synthétique",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Considérer les types sans nom comme des objets java.lang.",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruire les noms de variables à partir des informations de débogage",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Suppression des plages d'exceptions vides",
  "DEINLINE_FINALLY_STRUCTURES": "Désinlinez enfin les structures",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "N'autoriser que les caractères ASCII dans les chaînes de caractères",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Renommer les classes et les éléments de classe ambigus",

  "DECODE_ENUM_SWITCH": "Décodeur Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Décoder l'interrupteur à chaîne",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectionneur",
  "INNER_CLASSES": "Classes intérieures",
  "REMOVE_BOILER_PLATE": "Retirer la plaque de la chaudière",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Enlever les synthétiques de la classe intérieure",
  "DECODE_LAMBDAS": "Décoder les lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Init du constructeur de l'ascenseur",
  "REMOVE_DEAD_METHODS": "Supprimer les méthodes mortes",
  "REMOVE_BAD_GENERICS": "Supprimer les mauvais génériques",
  "SUGAR_ASSERTS": "Les affirmations du sucre",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Afficher la version",
  "DECODE_FINALLY": "Décoder enfin",
  "TIDY_MONITORS": "Moniteurs Tidy",
  "LENIENT": "Indulgence",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Commentaires",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Agressivité",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "Tampon de chaîne",
  "STRING_BUILDER": "Constructeur de cordes",
  "SILENT": "Silencieux",
  "RECOVER": "Récupérer",
  "OVERRIDE": "Remplacer",
  "SHOW_INFERRABLE": "Montrer Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagation",
  "HIDE_UTF": "Cacher l'UTF",
  "HIDE_LONG_STRINGS": "Cacher les longues cordes",
  "COMMENT_MONITORS": "Moniteurs de commentaires",
  "ALLOW_CORRECTING": "Permettre la correction",
  "LABELLED_BLOCKS": "Blocs étiquetés",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Récupérer le type d'affrontement",
  "RECOVER_TYPE__HINTS": "Conseils pour récupérer le type",
  "FORCE_RETURNING_IFS": "Force de retour des FI",
  "FOR_LOOP_AGG_CAPTURE": "Capture AGG en boucle",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Toujours générer une variable d'exception pour les blocs Catch",
  "EXCLUDE_NESTED_TYPES": "Exclure les types imbriqués",
  "SHOW_DEBUG_LINE_NUMBERS": "Afficher les numéros de ligne de débogage",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Inclure les numéros de ligne dans le bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Inclure les diagnostics d'erreur",
  "SHOW_SYNTHETIC_MEMBERS": "Afficher les membres synthétiques",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplifier les références des membres",
  "MERGE_VARIABLES": "Fusionner les variables",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Forcer les importations explicites",
  "FLATTEN_SWITCH_BLOCKS": "Aplatir les blocs d'interrupteurs",
  "RETAIN_POINTLESS_SWITCHES": "Conserver les interrupteurs inutiles",
  "RETAIN_REDUNDANT_CASTS": "Conserver les casques redondants",
  "UNICODE_OUTPUT_ENABLED": "Sortie Unicode activée",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Recharger les ressources",
  "RELOAD_RESOURCES_CONFIRM": "Êtes-vous sûr de vouloir recharger les ressources ?",
  "SELECT_FILE_TITLE": "Sélectionnez le fichier ou le dossier à ouvrir dans {BCV}.",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, fichiers de classe ou Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Sélectionner le plugin externe",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Plugin externe BCV en js, java, python, ruby ou groovy",
  "FOREIGN_LIBRARY_WARNING": "AVERTISSEMENT : Si cette option est désactivée, les bibliothèques obsolètes ne seront PAS supprimées.\n\rC'est aussi un problème de sécurité.\n\rNE LE DÉSACTIVEZ QUE SI VOUS SAVEZ CE QUE VOUS FAITES.",
  "RESET_TITLE": "{PRODUCT_NAME} - Réinitialiser l'espace de travail",
  "RESET_CONFIRM": "Vous êtes sûr de vouloir réinitialiser l'espace de travail ?\n\rCela réinitialisera également votre navigateur de fichiers et votre recherche.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Sortie",
  "EXIT_CONFIRM": "Vous êtes sûr de vouloir sortir ?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - À propos - {SITE WEB} | {à confirmer}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Console de plugins",
  "CLOSE_ALL_BUT_THIS": "Fermez tout sauf ceci",
  "CLOSE_TAB": "Fermer l'onglet",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Veuillez envoyer ce journal d'erreurs à",
  "PLEASE_SEND_RESOURCES": "Si vous détenez des droits légaux appropriés à la classe concernée",
  "ONE_PLUGIN_AT_A_TIME": "Un autre plugin est en cours d'exécution en ce moment, veuillez attendre qu'il finisse de s'exécuter.",
  "ILLEGAL_ACCESS_ERROR": "Pour ce faire, veuillez utiliser Java 15 ou plus.",


  "FILES": "Fichiers",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Recherche rapide de fichiers (sans extension de fichier)",
  "WORK_SPACE": "Espace de travail",
  "EXACT": "Exact",
  "SEARCH": "Recherche",
  "SEARCH_FROM": "Recherche à partir de :",
  "SEARCH_STRING": "Chaîne de recherche :",
  "SEARCH_REGEX": "Recherche Regex :",
  "OWNER": "Propriétaire :",
  "NAME": "Nom :",
  "DESC": "Desc :",
  "SAVE": "Sauvez...",
  "SAVE_AS": "Enregistrer sous...",
  "RESULTS": "Résultats",
  "REFRESH": "Rafraîchir",
  "ANNOTATION_NAME": "Nom de l'annotation",
  "MATCH_CASE": "Cas d'allumage",
  "EXACT_PATH": "Chemin exact",
  "MIN_SDK_VERSION": "Version minimale du SDK",
  "PRINT_LINE_NUMBERS": "Imprimer les numéros de ligne"
}

```

`src/main/resources/translations/georgian.json`:

```json
{
  "FILE": "ფაილი",
  "ADD": "დამატება ...",
  "NEW_WORKSPACE": "ახალი სამუშაო სივრცე",
  "RELOAD_RESOURCES": "გადატვირთეთ რესურსები",
  "RUN": "გაიქეცი",
  "OPEN": "ღია ...",
  "OPEN_UNSTYLED": "გახსენით",
  "QUICK_OPEN": "სწრაფი გახსნა",
  "DELETE": "წაშლა",
  "NEW": "ახალი",
  "EXPAND": "გაფართოება",
  "COLLAPSE": "კოლაფსი",
  "COMPILE": "შედგენას",
  "SAVE_AS_RUNNABLE_JAR": "დაზოგე როგორც Runnable Jar ...",
  "SAVE_AS_ZIP": "Zip- ით შენახვა ...",
  "SAVE_AS_DEX": "შეინახეთ როგორც DEX ...",
  "SAVE_AS_APK": "შენახვა როგორც APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "გახსენით კლასების დეკომპილირება და შენახვა",
  "DECOMPILE_SAVE_ALL_CLASSES": "ჩამოაყალიბეთ და შეინახეთ ყველა კლასი",
  "RECENT_FILES": "ბოლო ფაილები",
  "ABOUT": "დაახლოებით",
  "EXIT": "გასვლა",

  "VIEW": "ხედი",
  "VISUAL_SETTINGS": "ვიზუალური პარამეტრები",
  "PANE_1": "სარკმელი 1",
  "PANE_2": "სარკმელი 2",
  "PANE_3": "სარკმელი 3",
  "NONE": "არცერთი",
  "EDITABLE": "რედაქტირებადი",

  "LANGUAGE": "Ენა",
  "FONT_SIZE": "Შრიფტის ზომა",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "აჩვენეთ ფაილი ჩანართის სათაურში",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "გაუმარტივეთ სახელი ჩანართის სათაურში",
  "SYNCHRONIZED_VIEWING": "სინქრონული დათვალიერება",
  "SHOW_CLASS_METHODS": "აჩვენეთ კლასის მეთოდები",

  "WINDOW_THEME": "ფანჯრის თემა",
  "SYSTEM_THEME": "სისტემის თემა",
  "DARK_THEME": "მუქი თემა",
  "LIGHT_THEME": "მსუბუქი თემა",
  "ONE_DARK_THEME": "ერთი ბნელი თემა",
  "SOLARIZED_DARK_THEME": "სოლარიზებული მუქი თემა",
  "SOLARIZED_LIGHT_THEME": "სოლარიზებული მსუბუქი თემა",
  "HIGH_CONTRAST_DARK_THEME": "მაღალი კონტრასტული მუქი თემა",
  "HIGH_CONTRAST_LIGHT_THEME": "მაღალი კონტრასტული სინათლის თემა",
  "ONE_DARK": "ერთი ბნელი",
  "SOLARIZED_DARK": "სოლარიზებული ბნელი",
  "SOLARIZED_LIGHT": "სოლარიზებული შუქი",
  "HIGH_CONTRAST_DARK": "მაღალი კონტრასტული მუქი",
  "HIGH_CONTRAST_LIGHT": "მაღალი კონტრასტული შუქი",
  "TEXT_AREA_THEME": "ტექსტის არეალის თემა",
  "DEFAULT_RECOMMENDED_LIGHT": "ნაგულისხმევი (რეკომენდებული შუქი)",
  "THEME_MATCH": "თემის მატჩი (რეკომენდებულია)",
  "DARK": "მუქი (რეკომენდებულია მუქი)",
  "DARK_ALT": "მუქი-ალტ",
  "DEFAULT_ALT": "ნაგულისხმევი- Alt",
  "ECLIPSE": "დაბნელება",
  "INTELLIJ": "ინტელიჯი",
  "VISUAL_STUDIO": "Ვიზუალური სტუდია",
  "DRUID_DARK": "დრუიდი (მუქი)",
  "MONOKAI_DARK": "მონოკაი (მუქი)",

  "SETTINGS": "პარამეტრები",
  "COMPILE_ON_SAVE": "შედგენას შენახვაზე",
  "COMPILE_ON_REFRESH": "შედგენას განახლებაზე",
  "REFRESH_ON_VIEW_CHANGE": "განაახლეთ ხედის ცვლილება",
  "DECODE_APK_RESOURCES": "APK რესურსების გაშიფვრა",
  "APK_CONVERSION": "APK კონვერტაცია",
  "APK_CONVERSION_DECODING": "APK კონვერტაცია / დეკოდირება",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "განახლების შემოწმება",
  "DELETE_UNKNOWN_LIBS": "უცხო / მოძველებული წიგნების წაშლა",
  "FORCE_PURE_ASCII_AS_TEXT": "სუფთა Ascii აიძულო ტექსტად",
  "SET_PYTHON_27_EXECUTABLE": "დააყენეთ Python 2.7 შესრულებადი",
  "SET_PYTHON_30_EXECUTABLE": "დააყენეთ Python 3.X შესრულებადი",
  "SET_JRE_RT_LIBRARY": "დააყენეთ JRE RT ბიბლიოთეკა",
  "SET_OPTIONAL_LIBRARY_FOLDER": "ფაილის არჩევითი ბიბლიოთეკის დაყენება",
  "SET_JAVAC_EXECUTABLE": "დააყენეთ ჯავაკი შესრულებადი",

  "JAVA": "ჯავა",
  "PROCYON_SETTINGS": "Procyon პარამეტრები",
  "CFR_SETTINGS": "CFR პარამეტრები",
  "FERNFLOWER_SETTINGS": "FernFlower პარამეტრები",
  "PROCYON": "პროციონი",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "კრაკატაუ",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "სმალი",
  "SMALI_DEX": "სმალი / დექსი",
  "HEXCODE": "ჰექსკოდი",
  "BYTECODE": "ბიტეკოდი",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode დეკომპილერი",
  "DEBUG_HELPERS": "Debug Helpers",
  "APPEND_BRACKETS_TO_LABEL": "დაამატეთ ფრჩხილები ლეიბლზე",

  "PLUGINS": "დანამატები",
  "OPEN_PLUGIN": "მოდულის გახსნა ...",
  "RECENT_PLUGINS": "ბოლო დანამატები",
  "CODE_SEQUENCE_DIAGRAM": "კოდის თანმიმდევრობის სქემა",
  "MALICIOUS_CODE_SCANNER": "მავნე კოდის სკანერი",
  "SHOW_MAIN_METHODS": "აჩვენეთ ძირითადი მეთოდები",
  "SHOW_ALL_STRINGS": "ყველა სტრიქონის ჩვენება",
  "REPLACE_STRINGS": "შეცვალეთ სიმები",
  "STACK_FRAMES_REMOVER": "დასტის ჩარჩოების მოსაშორებელი",
  "ZKM_STRING_DECRYPTER": "ZKM სიმების დეკორიტერი",
  "ALLATORI_STRING_DECRYPTER": "ალატორი სიმების დეკორიტერი",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray დეკორიტერი",
  "VIEW_ANDROID_PERMISSIONS": "იხილეთ Android ნებართვები",
  "VIEW_MANIFEST": "მანიფესტის ნახვა",
  "CHANGE_CLASSFILE_VERSIONS": "ClassFile ვერსიების შეცვლა",



  "PROCYON_DECOMPILER": "Procyon დეკომპილერი",
  "CFR_DECOMPILER": "CFR დეკომპილერი",
  "FERNFLOWER_DECOMPILER": "FernFlower დეკომპილერი",
  "JADX_DECOMPILER": "JADX დეკომპილერი",
  "JD_DECOMPILER": "JD-GUI დეკომპილერი",
  "BYTECODE_DISASSEMBLER": "Bytecode დემონტაჟი",
  "DISASSEMBLER": "დემონტაჟი",

  "ERROR": "შეცდომა",
  "NEW_JAVA_PLUGIN": "ახალი ჯავა მოდული",
  "NEW_JAVASCRIPT_PLUGIN": "ახალი Javascript მოდული",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "შემოთავაზებული შეკეთება: დააჭირეთ განახლების კლასს, თუ იგი კვლავ ვერ მოხერხდა, სცადეთ სხვა დეკომპილერი.",
  "SUGGESTED_FIX_COMPILER_ERROR": "შემოთავაზებული შეკეთება: სცადეთ ნახვა> სარკმელი> კრაკათაუ> Bytecode და ჩართეთ რედაქტირება.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "გაფრთხილება: ამჟამად არ არის არჩეული დეკომპილერი. სცადეთ View> Pane და შეარჩიეთ decompiler.",
  "COMPILER_TIP": "გაითვალისწინეთ, რომ decompiler– ის უმეტესობას არ შეუძლია აწარმოოს შესაკრები კლასები",
  "FIRST_OPEN_A_RESOURCE": "პირველ რიგში გახსენით რესურსი BCV (კლასის, jar, zip ან apk ფაილი)",
  "FIRST_OPEN_A_CLASS": "პირველ რიგში გახსენით კლასში მოცემული რესურსი BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "თავდაპირველად იხილეთ ჩანართის კლასის ფაილი.",
  "DRAG_CLASS_JAR": "გადაიტანეთ კლასი / jar / zip / APK / DEX აქ",

  "YES": "დიახ",
  "NO": "არა",
  "ERROR2": "შეცდომა:",
  "PROCESS2": "პროცესი:",
  "EXIT_VALUE_IS": "გასვლის მნიშვნელობა არის:",
  "JAVA_COMPILE_FAILED": "ჯავის შედგენა ვერ მოხერხდა",
  "ERROR_COMPILING_CLASS": "შეცდომა კლასის შედგენისას",
  "COMPILER": "გაითვალისწინეთ, რომ decompiler– ის უმეტესობას არ შეუძლია აწარმოოს შესაკრები კლასები",
  "SELECT_LIBRARY_FOLDER": "აირჩიეთ ბიბლიოთეკის საქაღალდე",
  "SELECT_JAVA_RT": "აირჩიეთ JRE RT Jar",
  "SELECT_JAVA": "აირჩიეთ Java Executable",
  "SELECT_JAVAC": "აირჩიეთ Javac შესრულებადი",
  "SELECT_JAVA_TOOLS": "აირჩიეთ Java Tools Jar",
  "SELECT_PYTHON_2": "აირჩიეთ Python 2.7 შესრულებადი",
  "SELECT_PYTHON_3": "აირჩიეთ Python 3.x შესრულებადი",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (ან PyPy 2.7 სიჩქარისთვის) შესრულებადი",
  "PYTHON_3_EXECUTABLE": "Python 3.x (ან PyPy 3.x სიჩქარისთვის) შესრულებადი",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "თქვენ უნდა დააყენოთ თქვენი Python 2.7 (ან PyPy 2.7 სიჩქარისთვის) შესრულებადი გზა.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "თქვენ უნდა დააყენოთ თქვენი Python 3.x (ან PyPy 3.x სიჩქარისთვის) შესრულებადი გზა.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "თქვენ უნდა დააყენოთ თქვენი JRE RT ბიბლიოთეკა.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "Java შესრულებადი (JRE C– ის შიგნით: / პროგრამის ფაილები / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Javac შესრულებადი (მოითხოვს JDK C: / პროგრამის ფაილები / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C: / Program Files / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C: / Program Files / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "არჩევითი ბიბლიოთეკის საქაღალდე (შემდგენელი და კრაკატაუ)",

  "HIDE_BRIDGE_METHODS": "ხიდის მეთოდების დამალვა",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "სინთეზური კლასის წევრების დამალვა",
  "DECOMPILE_INNER_CLASSES": "შინაგანი კლასების დეკომპილირება",
  "COLLAPSE_14_CLASS_REFERENCES": "ჩავარდნა 1.4 კლასის ცნობები",
  "DECOMPILE_ASSERTIONS": "დაამტკიცეთ მტკიცებები",
  "HIDE_EMPTY_SUPER_INVOCATION": "დამალეთ ცარიელი სუპერ გამოძახება",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "ცარიელი ნაგულისხმევი კონსტრუქტორის დამალვა",
  "DECOMPILE_GENERIC_SIGNATURES": "ზოგადი ხელმოწერების დეკომპილირება",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "ვივარაუდოთ, რომ არ არის გამონაკლისი",
  "DECOMPILE_ENUMERATIONS": "ჩამოთვლის ჩამოთვლა",
  "REMOVE_GETCLASS_INVOCATION": "GetClass () გამოძახების ამოღება",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "ინტერპრეტაცია 1, როგორც ლოგიკური სიმართლე",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "ნებადართული არ არის მითითებული სინთეზური ატრიბუტი",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "გაითვალისწინეთ უსახელო ტიპები, როგორც java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "შეცვალეთ ცვლადების სახელები გამართვის ინფორმაციის შესახებ",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "ამოიღეთ გამონაკლისის ცარიელი დიაპაზონები",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline საბოლოოდ სტრუქტურებს",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "სტრიქონებში მხოლოდ ASCII სიმბოლოების დაშვება",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "ორაზროვანი კლასებისა და კლასის ელემენტების გადარქმევა",

  "DECODE_ENUM_SWITCH": "გაშიფვრა Enum შეცვლა",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "დეკოდირება სიმების შეცვლა",
  "ARRAYITER": "არიიტერი",
  "COLLECTIONITER": "კოლექციონერი",
  "INNER_CLASSES": "შიდა კლასები",
  "REMOVE_BOILER_PLATE": "ქვაბის ფირფიტის ამოღება",
  "REMOVE_INNER_CLASS_SYNTHETICS": "ამოიღეთ შიდა კლასის სინთეტიკა",
  "DECODE_LAMBDAS": "ლამბდას დეკოდირება",
  "LIFT__CONSTRUCTOR_INIT": "ლიფტის კონსტრუქტორი ინიცი",
  "REMOVE_DEAD_METHODS": "მკვდარი მეთოდების ამოღება",
  "REMOVE_BAD_GENERICS": "წაშალეთ Bad Generics",
  "SUGAR_ASSERTS": "შაქრის მტკიცებით",
  "SUGAR_BOXING": "შაქრის კრივი",
  "SHOW_VERSION": "აჩვენე ვერსია",
  "DECODE_FINALLY": "საბოლოოდ გაშიფვრა",
  "TIDY_MONITORS": "მოწესრიგებული მონიტორები",
  "LENIENT": "მსუბუქი",
  "DUMP_CLASSPATH": "გადააგდეთ Classpath",
  "COMMENTS": "კომენტარები",
  "FORCE_TOP_SORT": "იძულებითი დალაგება",
  "FORCE_TOP_SORT_AGGRESS": "იძულებითი დასალაგებლად აგრესია",
  "FORCE_EXCEPTION_PRUNE": "ძალის გამონაკლისი Prune",
  "STRING_BUFFER": "სიმების ბუფერი",
  "STRING_BUILDER": "სიმების მშენებელი",
  "SILENT": "ჩუმი",
  "RECOVER": "აღდგენა",
  "OVERRIDE": "უგულებელყოფა",
  "SHOW_INFERRABLE": "აჩვენეთ შეუვალი",
  "AEXAGG": "აეგასგი",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "UTF- ის დამალვა",
  "HIDE_LONG_STRINGS": "გრძელი სტრიქონების დამალვა",
  "COMMENT_MONITORS": "კომენტარის მონიტორები",
  "ALLOW_CORRECTING": "შესწორების დაშვება",
  "LABELLED_BLOCKS": "იარლიყით ბლოკები",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "ლანგის იმპორტის დამალვა",
  "RECOVER_TYPE_CLASH": "ტიპის შეჯახების აღდგენა",
  "RECOVER_TYPE__HINTS": "ტიპის მინიშნებების აღდგენა",
  "FORCE_RETURNING_IFS": "აიძულოს დაბრუნდეს IF",
  "FOR_LOOP_AGG_CAPTURE": "იყიდება Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "ყოველთვის შექმენით გამონაკლისის ცვლადი დაჭერის ბლოკებისთვის",
  "EXCLUDE_NESTED_TYPES": "გამორიცხეთ წყობილი ტიპები",
  "SHOW_DEBUG_LINE_NUMBERS": "აჩვენეთ გამართვის ხაზის ნომრები",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "ხაზის ნომრების ჩართვა Bytecode- ში",
  "INCLUDE_ERROR_DIAGNOSTICS": "ჩართეთ შეცდომების დიაგნოსტიკა",
  "SHOW_SYNTHETIC_MEMBERS": "აჩვენეთ სინთეტიკური წევრები",
  "SIMPLIFY_MEMBER_REFERENCES": "გაამარტივეთ მომხმარებლების მითითებები",
  "MERGE_VARIABLES": "ცვლადების შერწყმა",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "აშკარა ტიპის არგუმენტების იძულება",
  "FORCE_EXPLICIT_IMPORTS": "აიძულოთ აშკარა იმპორტი",
  "FLATTEN_SWITCH_BLOCKS": "ბრტყელი გადამრთველის ბლოკები",
  "RETAIN_POINTLESS_SWITCHES": "შეინარჩუნეთ უაზრო კონცენტრატორები",
  "RETAIN_REDUNDANT_CASTS": "შეინარჩუნეთ ზედმეტი კასტები",
  "UNICODE_OUTPUT_ENABLED": "უნიკოდის გამომუშავება ჩართულია",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - რესურსების გადატვირთვა",
  "RELOAD_RESOURCES_CONFIRM": "დარწმუნებული ხართ, რომ გსურთ რესურსების გადატვირთვა?",
  "SELECT_FILE_TITLE": "აირჩიეთ ფაილი ან საქაღალდე {BCV} - ში გასახსნელად",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, კლასის ფაილები ან Zip / Jar / War არქივები",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "აირჩიეთ გარე მოდული",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV გარე მოდული js, java, python, ruby ​​ან groovy- ში",
  "FOREIGN_LIBRARY_WARNING": "გაფრთხილება: ამ შემთხვევაში მოძველებული ბიბლიოთეკები აღარ წაიშლება.\n\rეს ასევე უსაფრთხოების პრობლემაა.\n\rმხოლოდ ის გამორთეთ, თუ იცით რას აკეთებთ.",
  "RESET_TITLE": "{PRODUCT_NAME} - სამუშაო სივრცის გადაყენება",
  "RESET_CONFIRM": "დარწმუნებული ხართ, რომ გსურთ სამუშაო ადგილის გადაყენება?\n\rის ასევე აღადგენს ფაილების ნავიგატორს და ძიებას.",
  "EXIT_TITLE": "{PRODUCT_NAME} - გასასვლელი",
  "EXIT_CONFIRM": "დარწმუნებული ხართ, რომ გსურთ გასვლა?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - შესახებ - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - მოდულის კონსოლი",
  "CLOSE_ALL_BUT_THIS": "ყველაფრის დახურვა",
  "CLOSE_TAB": "ჩანართის დახურვა",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "გთხოვთ, გააგზავნოთ ეს შეცდომის ჟურნალი",
  "PLEASE_SEND_RESOURCES": "თუ თქვენ ფლობთ შესაბამის იურიდიულ უფლებებს შესაბამის კლასში / jar / apk ფაილზე, გთხოვთ, მიუთითოთ ისიც.",
  "ONE_PLUGIN_AT_A_TIME": "ამჟამად მუშაობს სხვა დანამატი, გთხოვთ, დაელოდოთ მისი შესრულების დასრულებას.",
  "ILLEGAL_ACCESS_ERROR": "ამისათვის გამოიყენეთ Java 15 ან უფრო ძველი.",


  "FILES": "ფაილები",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "ფაილის სწრაფი ძებნა (ფაილის გაფართოება არ არის)",
  "WORK_SPACE": "სამუშაო სივრცე",
  "EXACT": "ზუსტი",
  "SEARCH": "ძებნა",
  "SEARCH_FROM": "ძიება:",
  "SEARCH_STRING": "ძებნა სტრიქონი:",
  "SEARCH_REGEX": "Regex– ის ძებნა:",
  "OWNER": "მფლობელი:",
  "NAME": "სახელი:",
  "DESC": "აღწერილობა:",
  "SAVE": "Გადარჩენა...",
  "SAVE_AS": "Შეინახე როგორც...",
  "RESULTS": "შედეგები",
  "REFRESH": "განახლება",
  "ANNOTATION_NAME": "ანოტაციის სახელი",
  "MATCH_CASE": "მატჩის საქმე",
  "EXACT_PATH": "ზუსტი გზა",
  "MIN_SDK_VERSION": "მინიმალური SDK ვერსია",
  "PRINT_LINE_NUMBERS": "ხაზის ნომრების დაბეჭდვა"
}

```

`src/main/resources/translations/german.json`:

```json
{
  "FILE": "Datei",
  "ADD": "Hinzufügen...",
  "NEW_WORKSPACE": "Neuer Arbeitsbereich",
  "RELOAD_RESOURCES": "Ressourcen neu laden",
  "RUN": "Ausführen",
  "OPEN": "Öffnen...",
  "OPEN_UNSTYLED": "Öffnen",
  "QUICK_OPEN": "Schnell öffnen",
  "DELETE": "Löschen",
  "NEW": "Neu",
  "EXPAND": "Erweitern",
  "COLLAPSE": "Zusammenklappen",
  "COMPILE": "Kompilieren",
  "SAVE_AS_RUNNABLE_JAR": "Speichern als ausführbare Jar...",
  "SAVE_AS_ZIP": "Speichern als Zip...",
  "SAVE_AS_DEX": "Speichern als DEX...",
  "SAVE_AS_APK": "Speichern als APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Alle geöffneten Klassen dekompilieren & speichern",
  "DECOMPILE_SAVE_ALL_CLASSES": "Alle Klassen dekompilieren & speichern",
  "RECENT_FILES": "Letzte geöffnete Dateien",
  "ABOUT": "Über Bytecode Viewer",
  "EXIT": "Bytecode Viewer beenden",

  "VIEW": "Ansicht",
  "VISUAL_SETTINGS": "Grafikeinstellungen",
  "PANE_1": "Fenster 1",
  "PANE_2": "Fenster 2",
  "PANE_3": "Fenster 3",
  "NONE": "Keins",
  "EDITABLE": "Editierbar",

  "LANGUAGE": "Sprache",
  "FONT_SIZE": "Schriftgröße",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Dateinamen in Reiter-Titel anzeigen",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Namen in Reiter-Titel simplifizieren",
  "SYNCHRONIZED_VIEWING": "Synchronisierte Ansicht",
  "SHOW_CLASS_METHODS": "Zeige Klassenmethoden",

  "WINDOW_THEME": "Fenster-Erscheinungsbild",
  "SYSTEM_THEME": "Wie Betriebssystem",
  "DARK_THEME": "Dunkler Modus",
  "LIGHT_THEME": "Heller Modus",
  "ONE_DARK_THEME": "One (Dunkler Modus)",
  "SOLARIZED_DARK_THEME": "Solarized (Dunkler Modus)",
  "SOLARIZED_LIGHT_THEME": "Solarized",
  "HIGH_CONTRAST_DARK_THEME": "Dunkler Modus mit hohem Kontrast",
  "HIGH_CONTRAST_LIGHT_THEME": "Heller Modus mit hohem Kontrast",
  "ONE_DARK": "One (Dunkel)",
  "SOLARIZED_DARK": "Solarized (Dunkel)",
  "SOLARIZED_LIGHT": "Solarized",
  "HIGH_CONTRAST_DARK": "Hoher Kontrast (Dunkel)",
  "HIGH_CONTRAST_LIGHT": "Hoher Kontrast",
  "TEXT_AREA_THEME": "Textbereich-Erscheinungsbild",
  "DEFAULT_RECOMMENDED_LIGHT": "Hell (Empfohlen bei hellem Modus)",
  "THEME_MATCH": "Mit Fenster abgleichen (empfohlen)",
  "DARK": "Dunkel (Empfohlen bei dunklem Modus)",
  "DARK_ALT": "Dunkel Alternativ",
  "DEFAULT_ALT": "Standard Alternativ",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "IntelliJ",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (Dunkler Modus)",
  "MONOKAI_DARK": "Monokai (Dunkler Modus)",

  "SETTINGS": "Einstellungen",
  "COMPILE_ON_SAVE": "Bei Speichern kompilieren",
  "COMPILE_ON_REFRESH": "Bei Aktualisierung kompilieren",
  "REFRESH_ON_VIEW_CHANGE": "Bei Änderung der Ansicht aktualisieren",
  "DECODE_APK_RESOURCES": "APK Ressourcen dekodieren",
  "APK_CONVERSION": "APK-Umwandlung",
  "APK_CONVERSION_DECODING": "APK-Konvertierung",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Nach Updates suchen",
  "DELETE_UNKNOWN_LIBS": "Unbekannte/Veraltete Bibliotheken löschen",
  "FORCE_PURE_ASCII_AS_TEXT": "ASCII als Zeichenkodierung erzwingen",
  "SET_PYTHON_27_EXECUTABLE": "Ausführbare Python 2.7 Datei festlegen",
  "SET_PYTHON_30_EXECUTABLE": "Ausführbare Python 3.X Datei festlegen",
  "SET_JRE_RT_LIBRARY": "JRE RT Bibliothek festlegen",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Optionalen Bibliothekenordner festlegen",
  "SET_JAVAC_EXECUTABLE": "Ausführbare Javac Datei festlegen",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon-Einstellungen",
  "CFR_SETTINGS": "CFR-Einstellungen",
  "FERNFLOWER_SETTINGS": "FernFlower Einstellungen",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali/Dex",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode-Dekompilierer",
  "DEBUG_HELPERS": "Debug-Helfer",
  "APPEND_BRACKETS_TO_LABEL": "Klammern zu Label hinzufügen",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Plugin öffnen...",
  "RECENT_PLUGINS": "Zuletzt verwendete Plugins",
  "CODE_SEQUENCE_DIAGRAM": "Code-Ablaufdiagramm anzeigen",
  "MALICIOUS_CODE_SCANNER": "Scanner für bösartigen Code öffnen",
  "SHOW_MAIN_METHODS": "Main-Methoden anzeigen",
  "SHOW_ALL_STRINGS": "Alle Strings anzeigen",
  "REPLACE_STRINGS": "Strings ersetzen",
  "STACK_FRAMES_REMOVER": "Stack-Frames-Entferner ausführen",
  "ZKM_STRING_DECRYPTER": "ZKM-String-Decrypter ausführen",
  "ALLATORI_STRING_DECRYPTER": "Allatori-String-Decrypter ausführen",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray-Decrypter ausführen",
  "VIEW_ANDROID_PERMISSIONS": "Android-Berechtigungen anzeigen",
  "VIEW_MANIFEST": "Ansicht Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "ClassFile-Versionen ändern",



  "PROCYON_DECOMPILER": "Procyon-Dekompilierer",
  "CFR_DECOMPILER": "CFR-Dekompilierer",
  "FERNFLOWER_DECOMPILER": "FernFlower-Dekompilierer",
  "JADX_DECOMPILER": "JADX-Dekompilierer",
  "JD_DECOMPILER": "JD-GUI-Dekompilierer",
  "BYTECODE_DISASSEMBLER": "Bytecode-Disassembler",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Fehler",
  "NEW_JAVA_PLUGIN": "Neues Java-Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "Neues Javascript-Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Vorgeschlagene Lösung: Klicken Sie auf Klasse aktualisieren und wenn es wieder fehlschlägt, versuchen Sie einen anderen Dekompilierer.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Vorgeschlagene Lösung: Aktivieren Sie unter Ansicht>Fenster>Krakatau>Bytecode Editierbar.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ACHTUNG: Derzeit ist kein Dekompilierer ausgewählt. Versuchen Sie unter Ansicht>Fenster einen Dekompilierer auszuwählen.",
  "COMPILER_TIP": "Beachten Sie, dass die meisten Decompiler keine kompilierbaren Klassen erzeugen können",
  "FIRST_OPEN_A_RESOURCE": "Öffnen Sie zunächst eine Ressource innerhalb der BCV (Klasse, Jar-, Zip- oder Apk-Datei)",
  "FIRST_OPEN_A_CLASS": "Öffnen Sie zunächst eine Classfile-Ressource in der BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Betrachten Sie zunächst eine Klassendatei innerhalb einer Registerkarte.",
  "DRAG_CLASS_JAR": "class/jar/zip/APK/DEX hierher ziehen",

  "YES": "Ja",
  "NO": "Nein",
  "ERROR2": "Fehler:",
  "PROCESS2": "Prozess:",
  "EXIT_VALUE_IS": "Exit Value ist:",
  "JAVA_COMPILE_FAILED": "Java-Kompilierung fehlgeschlagen",
  "ERROR_COMPILING_CLASS": "Fehler beim Kompilieren der Klasse",
  "COMPILER": "Beachten Sie, dass die meisten Decompiler keine kompilierbaren Klassen erzeugen können",
  "SELECT_LIBRARY_FOLDER": "Bibliotheksordner auswählen",
  "SELECT_JAVA_RT": "JRE RT Jar auswählen",
  "SELECT_JAVA": "Java-Executable auswählen",
  "SELECT_JAVAC": "Javac Executable auswählen",
  "SELECT_JAVA_TOOLS": "Java Tools Jar auswählen",
  "SELECT_PYTHON_2": "Wählen Sie Python 2.7 Executable",
  "SELECT_PYTHON_3": "Wählen Sie Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (oder PyPy 2.7 für Geschwindigkeit) Ausführbar",
  "PYTHON_3_EXECUTABLE": "Python 3.x (oder PyPy 3.x für Geschwindigkeit) Ausführbar",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Sie müssen Ihren Python 2.7 (oder PyPy 2.7 für Geschwindigkeit) Ausführungspfad einstellen.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Sie müssen Ihren Python 3.x (oder PyPy 3.x für Geschwindigkeit) Ausführungspfad einstellen.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Sie müssen Ihre JRE RT Library einstellen.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Programmdateien\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Innerhalb von JRE C:",
  "JAVAC_EXECUTABLE": "Javac Executable (Erfordert JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (innerhalb von JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (innerhalb von JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Optionaler Bibliotheksordner (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Brückenmethoden ausblenden",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Synthetische Klassenmitglieder ausblenden",
  "DECOMPILE_INNER_CLASSES": "Innere Klassen dekompilieren",
  "COLLAPSE_14_CLASS_REFERENCES": "Kollabieren 1.4 Klassenreferenzen",
  "DECOMPILE_ASSERTIONS": "Dekompilieren von Assertionen",
  "HIDE_EMPTY_SUPER_INVOCATION": "Leeren super-Aufruf ausblenden",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Leeren Standardkonstruktor ausblenden",
  "DECOMPILE_GENERIC_SIGNATURES": "Generische Signaturen dekompilieren",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Annahme, dass die Rückgabe keine Ausnahmen auslöst",
  "DECOMPILE_ENUMERATIONS": "Aufzählungen dekompilieren",
  "REMOVE_GETCLASS_INVOCATION": "getClass()-Aufruf entfernen",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "int 1 als boolesches true interpretieren",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Nicht gesetztes synthetisches Attribut zulassen",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Betrachten Sie namenlose Typen als java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Variablennamen aus Debug-Informationen rekonstruieren",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Leere Ausnahmebereiche entfernen",
  "DEINLINE_FINALLY_STRUCTURES": "Strukturen endgültig deinstallieren",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Nur ASCII-Zeichen in Zeichenketten zulassen",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Mehrdeutige Klassen und Klassenelemente umbenennen",

  "DECODE_ENUM_SWITCH": "Dekodieren Enum Schalter",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "String dekodieren Schalter",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Abholer",
  "INNER_CLASSES": "Innere Klassen",
  "REMOVE_BOILER_PLATE": "Kesselplatte entfernen",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Innere Klasse Synthetik entfernen",
  "DECODE_LAMBDAS": "Lambdas dekodieren",
  "LIFT__CONSTRUCTOR_INIT": "Lift-Konstruktor Init",
  "REMOVE_DEAD_METHODS": "Tote Methoden entfernen",
  "REMOVE_BAD_GENERICS": "Schlechte Generika entfernen",
  "SUGAR_ASSERTS": "Zucker behauptet",
  "SUGAR_BOXING": "Zucker-Boxen",
  "SHOW_VERSION": "Version anzeigen",
  "DECODE_FINALLY": "Endlich dekodieren",
  "TIDY_MONITORS": "Aufgeräumte Monitore",
  "LENIENT": "Nachsichtig",
  "DUMP_CLASSPATH": "Dump-Klassenpfad",
  "COMMENTS": "Kommentare",
  "FORCE_TOP_SORT": "Top-Sortierung erzwingen",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "String-Puffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Stumm",
  "RECOVER": "Wiederherstellen",
  "OVERRIDE": "Überschreiben Sie",
  "SHOW_INFERRABLE": "Inferrable anzeigen",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Kraftkonditionen ausbreiten",
  "HIDE_UTF": "UTF ausblenden",
  "HIDE_LONG_STRINGS": "Lange Strings ausblenden",
  "COMMENT_MONITORS": "Kommentar Monitore",
  "ALLOW_CORRECTING": "Korrigieren zulassen",
  "LABELLED_BLOCKS": "Beschriftete Blöcke",
  "J14CLASSOBJ": "J14KlasseOBJ",
  "HIDE_LANG_IMPORTS": "Lang Importe ausblenden",
  "RECOVER_TYPE_CLASH": "Wiederherstellen des Typs Clash",
  "RECOVER_TYPE__HINTS": "Hinweise zur Wiederherstellung des Typs",
  "FORCE_RETURNING_IFS": "Kraftrückkehrende IFs",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG-Aufnahme",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Ausnahmevariable für Catch-Blöcke immer generieren",
  "EXCLUDE_NESTED_TYPES": "Verschachtelte Typen ausschließen",
  "SHOW_DEBUG_LINE_NUMBERS": "Debug-Zeilennummern anzeigen",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Zeilennummern in Bytecode einbinden",
  "INCLUDE_ERROR_DIAGNOSTICS": "Fehlerdiagnose einbeziehen",
  "SHOW_SYNTHETIC_MEMBERS": "Synthetische Mitglieder anzeigen",
  "SIMPLIFY_MEMBER_REFERENCES": "Mitgliederreferenzen vereinfachen",
  "MERGE_VARIABLES": "Variablen zusammenführen",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Explizite Typ-Argumente erzwingen",
  "FORCE_EXPLICIT_IMPORTS": "Explizite Importe erzwingen",
  "FLATTEN_SWITCH_BLOCKS": "Switch-Blöcke abflachen",
  "RETAIN_POINTLESS_SWITCHES": "Sinnlose Schalter beibehalten",
  "RETAIN_REDUNDANT_CASTS": "Redundante Gussteile beibehalten",
  "UNICODE_OUTPUT_ENABLED": "Unicode-Ausgabe aktiviert",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Ressourcen neu laden",
  "RELOAD_RESOURCES_CONFIRM": "Sind Sie sicher, dass Sie die Ressourcen neu laden möchten?",
  "SELECT_FILE_TITLE": "Wählen Sie Datei oder Ordner zum Öffnen in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Klassen oder Zip/Jar/War-Archive",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Externes Plugin auswählen",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV Externes Plugin in js, java, python, ruby oder groovy",
  "FOREIGN_LIBRARY_WARNING": "ACHTUNG: Wenn dies ausgeschaltet ist, werden veraltete Bibliotheken NICHT entfernt.\nDies stellt auch ein Sicherheitsproblem dar.\nSCHALTEN SIE ES NUR AUS, WENN SIE WISSEN, WAS SIE TUN.",
  "RESET_TITLE": "{PRODUCT_NAME} - Arbeitsbereich zurücksetzen",
  "RESET_CONFIRM": "Sind Sie sicher, dass Sie den Arbeitsbereich zurücksetzen wollen?\n\rDadurch werden auch der Datei-Navigator und die Suche zurückgesetzt.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Beenden",
  "EXIT_CONFIRM": "Sind Sie sicher, dass Sie das Programm beenden wollen?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Über - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin-Konsole",
  "CLOSE_ALL_BUT_THIS": "Alle außer diesen schließen",
  "CLOSE_TAB": "Tab schließen",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Bitte senden Sie dieses Fehlerprotokoll an",
  "PLEASE_SEND_RESOURCES": "Wenn Sie entsprechende gesetzliche Rechte an der jeweiligen Klasse besitzen",
  "ONE_PLUGIN_AT_A_TIME": "Es wird gerade ein anderes Plugin ausgeführt, bitte warten Sie, bis dieses fertig ist.",
  "ILLEGAL_ACCESS_ERROR": "Bitte benutzen Sie Java 15 oder älter, um dies zu tun.",


  "FILES": "Dateien",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Dateien-Schnellsuche öffnen (ohne Dateiendungen)",
  "WORK_SPACE": "Arbeitsbereich",
  "EXACT": "Exakt",
  "SEARCH": "Suchen",
  "SEARCH_FROM": "Suche nach: ",
  "SEARCH_STRING": "Suchbegriff: ",
  "SEARCH_REGEX": "Regex suchen: ",
  "OWNER": "Inhaber: ",
  "NAME": "Name: ",
  "DESC": "Beschreibung: ",
  "SAVE": "Speichern...",
  "SAVE_AS": "Speichern als...",
  "RESULTS": "Ergebnisse",
  "REFRESH": "Aktualisieren",
  "ANNOTATION_NAME": "Annotation Name",
  "MATCH_CASE": "Groß-/Kleinschreibung beachten",
  "EXACT_PATH": "Genauer Pfad",
  "MIN_SDK_VERSION": "Minimale SDK-Version",
  "PRINT_LINE_NUMBERS": "Zeilennummern einschließen"
}

```

`src/main/resources/translations/greek.json`:

```json
{
  "FILE": "Αρχείο",
  "ADD": "Προσθέστε...",
  "NEW_WORKSPACE": "Νέος χώρος εργασίας",
  "RELOAD_RESOURCES": "Επαναφόρτωση πόρων",
  "RUN": "Εκτέλεση",
  "OPEN": "Ανοίξτε...",
  "OPEN_UNSTYLED": "Ανοίξτε το",
  "QUICK_OPEN": "Γρήγορο άνοιγμα",
  "DELETE": "Διαγραφή",
  "NEW": "Νέο",
  "EXPAND": "Επεκτείνετε το",
  "COLLAPSE": "Κατάρρευση",
  "COMPILE": "Μεταγλώττιση",
  "SAVE_AS_RUNNABLE_JAR": "Αποθήκευση ως εκτελέσιμο βάζο...",
  "SAVE_AS_ZIP": "Αποθήκευση ως Zip...",
  "SAVE_AS_DEX": "Αποθήκευση ως DEX...",
  "SAVE_AS_APK": "Αποθήκευση ως APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Απομεταγλώττιση & Αποθήκευση ανοιγμένων κλάσεων",
  "DECOMPILE_SAVE_ALL_CLASSES": "Απομεταγλώττιση & Αποθήκευση όλων των κλάσεων",
  "RECENT_FILES": "Πρόσφατα αρχεία",
  "ABOUT": "Σχετικά με το",
  "EXIT": "Έξοδος",

  "VIEW": "Προβολή",
  "VISUAL_SETTINGS": "Οπτικές ρυθμίσεις",
  "PANE_1": "Παράθυρο 1",
  "PANE_2": "Παράθυρο 2",
  "PANE_3": "Παράθυρο 3",
  "NONE": "Κανένα",
  "EDITABLE": "Επεξεργάσιμο",

  "LANGUAGE": "Γλώσσα",
  "FONT_SIZE": "Μέγεθος γραμματοσειράς",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Εμφάνιση αρχείου στον τίτλο καρτέλας",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Απλοποίηση ονόματος στον τίτλο καρτέλας",
  "SYNCHRONIZED_VIEWING": "Συγχρονισμένη προβολή",
  "SHOW_CLASS_METHODS": "Εμφάνιση μεθόδων κλάσης",

  "WINDOW_THEME": "Θέμα παραθύρου",
  "SYSTEM_THEME": "Θέμα συστήματος",
  "DARK_THEME": "Σκοτεινό θέμα",
  "LIGHT_THEME": "Θέμα φωτός",
  "ONE_DARK_THEME": "Ένα σκοτεινό θέμα",
  "SOLARIZED_DARK_THEME": "Solarized σκοτεινό θέμα",
  "SOLARIZED_LIGHT_THEME": "Θέμα ηλιακού φωτός",
  "HIGH_CONTRAST_DARK_THEME": "Σκοτεινό θέμα υψηλής αντίθεσης",
  "HIGH_CONTRAST_LIGHT_THEME": "Θέμα φωτός υψηλής αντίθεσης",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Ηλιακό σκοτάδι",
  "SOLARIZED_LIGHT": "Ηλιακό φως",
  "HIGH_CONTRAST_DARK": "Υψηλή αντίθεση Σκούρο",
  "HIGH_CONTRAST_LIGHT": "Φως υψηλής αντίθεσης",
  "TEXT_AREA_THEME": "Θέμα περιοχής κειμένου",
  "DEFAULT_RECOMMENDED_LIGHT": "Προεπιλογή (Συνιστώμενο φως)",
  "THEME_MATCH": "Θεματικός αγώνας (Συνιστάται)",
  "DARK": "Σκούρο (Συνιστάται Σκούρο)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Έκλειψη",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Δρυίδης (Σκοτεινός)",
  "MONOKAI_DARK": "Monokai (Dark)",

  "SETTINGS": "Ρυθμίσεις",
  "COMPILE_ON_SAVE": "Μεταγλώττιση κατά την αποθήκευση",
  "COMPILE_ON_REFRESH": "Μεταγλώττιση κατά την ανανέωση",
  "REFRESH_ON_VIEW_CHANGE": "Ανανέωση κατά την αλλαγή προβολής",
  "DECODE_APK_RESOURCES": "Αποκωδικοποίηση πόρων APK",
  "APK_CONVERSION": "Μετατροπή APK",
  "APK_CONVERSION_DECODING": "Μετατροπή APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Έλεγχος ενημέρωσης",
  "DELETE_UNKNOWN_LIBS": "Διαγραφή αλλοδαπών",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Ορισμός εκτελέσιμου αρχείου Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Ορισμός εκτελέσιμου αρχείου Python 3.X",
  "SET_JRE_RT_LIBRARY": "Ορισμός βιβλιοθήκης JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Ορισμός προαιρετικού φακέλου βιβλιοθήκης",
  "SET_JAVAC_EXECUTABLE": "Ορισμός εκτελέσιμου Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Ρυθμίσεις Procyon",
  "CFR_SETTINGS": "Ρυθμίσεις CFR",
  "FERNFLOWER_SETTINGS": "Ρυθμίσεις FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Αποσυμπιεστής bytecode",
  "DEBUG_HELPERS": "Βοηθοί εντοπισμού σφαλμάτων",
  "APPEND_BRACKETS_TO_LABEL": "Προσθέστε αγκύλες στην ετικέτα",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Open Plugin...",
  "RECENT_PLUGINS": "Πρόσφατα Plugins",
  "CODE_SEQUENCE_DIAGRAM": "Διάγραμμα ακολουθίας κώδικα",
  "MALICIOUS_CODE_SCANNER": "Ανιχνευτής κακόβουλου κώδικα",
  "SHOW_MAIN_METHODS": "Εμφάνιση κύριων μεθόδων",
  "SHOW_ALL_STRINGS": "Εμφάνιση όλων των χορδών",
  "REPLACE_STRINGS": "Αντικατάσταση συμβολοσειρών",
  "STACK_FRAMES_REMOVER": "Αφαίρεση πλαισίων στοίβας",
  "ZKM_STRING_DECRYPTER": "Αποκρυπτογράφηση συμβολοσειρών ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Προβολή δικαιωμάτων Android",
  "VIEW_MANIFEST": "Προβολή μανιφέστου",
  "CHANGE_CLASSFILE_VERSIONS": "Αλλαγή εκδόσεων ClassFile",



  "PROCYON_DECOMPILER": "Αποσυμπιεστής Procyon",
  "CFR_DECOMPILER": "Αποσυμπιεστής CFR",
  "FERNFLOWER_DECOMPILER": "Αποσυμπιεστής FernFlower",
  "JADX_DECOMPILER": "Αποσυμπιεστής JADX",
  "JD_DECOMPILER": "Αποσυμπιεστής JD-GUI",
  "BYTECODE_DISASSEMBLER": "Αποσυναρμολογητής bytecode",
  "DISASSEMBLER": "Αποσυναρμολογητής",

  "ERROR": "Σφάλμα",
  "NEW_JAVA_PLUGIN": "Νέο Java Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "Νέο πρόσθετο Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Προτεινόμενη διόρθωση: Εάν αποτύχει ξανά, δοκιμάστε έναν άλλο αποσυμπιεστή.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Προτεινόμενη διόρθωση: Δοκιμάστε View>Pane>Krakatau>Bytecode και ενεργοποιήστε Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ΠΡΟΕΙΔΟΠΟΙΗΣΗ: Δεν έχει επιλεγεί κανένας αποσυμπιεστής. Δοκιμάστε View>Pane και επιλέξτε έναν αποσυμπιεστή.",
  "COMPILER_TIP": "Λάβετε υπόψη ότι οι περισσότεροι αποσυμπιεστές δεν μπορούν να παράγουν μεταγλωττίσιμες κλάσεις",
  "FIRST_OPEN_A_RESOURCE": "Πρώτα ανοίξτε έναν πόρο μέσα στο BCV (class, jar, zip ή apk αρχείο)",
  "FIRST_OPEN_A_CLASS": "Πρώτα ανοίξτε έναν πόρο classfile μέσα στο BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Πρώτα δείτε ένα αρχείο κλάσης μέσα σε μια καρτέλα.",
  "DRAG_CLASS_JAR": "Κατηγορία Drag",

  "YES": "Ναι",
  "NO": "Όχι",
  "ERROR2": "Σφάλμα:",
  "PROCESS2": "Διαδικασία:",
  "EXIT_VALUE_IS": "Η τιμή εξόδου είναι:",
  "JAVA_COMPILE_FAILED": "Η μεταγλώττιση της Java απέτυχε",
  "ERROR_COMPILING_CLASS": "Σφάλμα μεταγλώττισης κλάσης",
  "COMPILER": "Λάβετε υπόψη ότι οι περισσότεροι αποσυμπιεστές δεν μπορούν να παράγουν μεταγλωττίσιμες κλάσεις",
  "SELECT_LIBRARY_FOLDER": "Επιλέξτε φάκελο βιβλιοθήκης",
  "SELECT_JAVA_RT": "Επιλέξτε JRE RT Jar",
  "SELECT_JAVA": "Επιλέξτε Java Executable",
  "SELECT_JAVAC": "Επιλέξτε Javac Executable",
  "SELECT_JAVA_TOOLS": "Επιλέξτε Java Tools Jar",
  "SELECT_PYTHON_2": "Επιλέξτε Python 2.7 Executable",
  "SELECT_PYTHON_3": "Επιλέξτε Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (ή PyPy 2.7 για ταχύτητα) Εκτελέσιμο αρχείο",
  "PYTHON_3_EXECUTABLE": "Python 3.x (ή PyPy 3.x για ταχύτητα) Εκτελέσιμο αρχείο",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Πρέπει να ορίσετε τη διαδρομή εκτέλεσης της Python 2.7 (ή PyPy 2.7 για ταχύτητα).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Πρέπει να ορίσετε τη διαδρομή εκτέλεσης της Python 3.x (ή PyPy 3.x για ταχύτητα).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Πρέπει να ορίσετε τη βιβλιοθήκη JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Εκτελέσιμο Java (μέσα στο JRE C:",
  "JAVAC_EXECUTABLE": "Εκτελέσιμο Javac (Απαιτεί JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (μέσα στο JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (μέσα στο JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Προαιρετικός φάκελος βιβλιοθήκης (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Απόκρυψη μεθόδων γέφυρας",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Απόκρυψη συνθετικών μελών κλάσης",
  "DECOMPILE_INNER_CLASSES": "Απομεταγλώττιση εσωτερικών κλάσεων",
  "COLLAPSE_14_CLASS_REFERENCES": "Κατάρρευση 1.4 αναφορές κλάσεων",
  "DECOMPILE_ASSERTIONS": "Αποσυμπίληση ισχυρισμών",
  "HIDE_EMPTY_SUPER_INVOCATION": "Απόκρυψη κενής επίκλησης super",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Απόκρυψη άδειου προεπιλεγμένου κατασκευαστή",
  "DECOMPILE_GENERIC_SIGNATURES": "Αποσυμπίληση γενικών υπογραφών",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Υποθέστε ότι η επιστροφή δεν πετάει εξαιρέσεις",
  "DECOMPILE_ENUMERATIONS": "Αποσυμπίληση απαριθμήσεων",
  "REMOVE_GETCLASS_INVOCATION": "Κατάργηση της κλήσης getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Ερμηνεία του int 1 ως boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Επιτρέψτε τη μη ρύθμιση συνθετικού χαρακτηριστικού",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Θεωρήστε τους ανώνυμους τύπους ως java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Ανακατασκευή ονομάτων μεταβλητών από πληροφορίες εντοπισμού σφαλμάτων",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Αφαίρεση κενών περιοχών εξαιρέσεων",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline τελικά δομές",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Επιτρέπει μόνο χαρακτήρες ASCII σε συμβολοσειρές",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Μετονομασία διφορούμενων κλάσεων και στοιχείων κλάσεων",

  "DECODE_ENUM_SWITCH": "Διακόπτης Enum αποκωδικοποίησης",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Διακόπτης αποκωδικοποίησης συμβολοσειράς",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Συλλέκτης",
  "INNER_CLASSES": "Εσωτερικές κλάσεις",
  "REMOVE_BOILER_PLATE": "Αφαιρέστε την πλάκα λέβητα",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Αφαίρεση συνθετικών εσωτερικής κατηγορίας",
  "DECODE_LAMBDAS": "Αποκωδικοποίηση Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift Constructor Init",
  "REMOVE_DEAD_METHODS": "Αφαίρεση νεκρών μεθόδων",
  "REMOVE_BAD_GENERICS": "Αφαιρέστε τα κακά γενόσημα",
  "SUGAR_ASSERTS": "Η ζάχαρη ισχυρίζεται",
  "SUGAR_BOXING": "Πυγμαχία ζάχαρης",
  "SHOW_VERSION": "Εμφάνιση έκδοσης",
  "DECODE_FINALLY": "Αποκωδικοποιήστε τελικά",
  "TIDY_MONITORS": "Τακτοποιημένες οθόνες",
  "LENIENT": "Επιεικής",
  "DUMP_CLASSPATH": "Απορρίψτε το μονοπάτι τάξης",
  "COMMENTS": "Σχόλια",
  "FORCE_TOP_SORT": "Επιβολή κορυφαίας ταξινόμησης",
  "FORCE_TOP_SORT_AGGRESS": "Δύναμη Κορυφαία ταξινόμηση Επιθετικότητα",
  "FORCE_EXCEPTION_PRUNE": "Εξαναγκασμός Εξαίρεσης Κλάδεμα",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "Κατασκευαστής συμβολοσειρών",
  "SILENT": "Σιωπηλή",
  "RECOVER": "Ανάκτηση",
  "OVERRIDE": "Παράκαμψη",
  "SHOW_INFERRABLE": "Εμφάνιση Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Δύναμη Cond Propagate",
  "HIDE_UTF": "Απόκρυψη UTF",
  "HIDE_LONG_STRINGS": "Απόκρυψη μακρών χορδών",
  "COMMENT_MONITORS": "Σχόλιο Οθόνες",
  "ALLOW_CORRECTING": "Επιτρέψτε τη διόρθωση",
  "LABELLED_BLOCKS": "Μπλοκ με ετικέτες",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Εισαγωγές",
  "RECOVER_TYPE_CLASH": "Ανάκτηση σύγκρουσης τύπου",
  "RECOVER_TYPE__HINTS": "Υποδείξεις ανάκτησης τύπου",
  "FORCE_RETURNING_IFS": "Δύναμη επιστροφής IFs",
  "FOR_LOOP_AGG_CAPTURE": "For Loop Σύλληψη AGG",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Πάντα να δημιουργείτε μεταβλητή Εξαίρεσης για τα μπλοκ Catch",
  "EXCLUDE_NESTED_TYPES": "Εξαίρεση φωλιασμένων τύπων",
  "SHOW_DEBUG_LINE_NUMBERS": "Εμφάνιση αριθμών γραμμών εντοπισμού σφαλμάτων",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Συμπεριλάβετε αριθμούς γραμμών σε bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Συμπεριλάβετε διαγνωστικά σφαλμάτων",
  "SHOW_SYNTHETIC_MEMBERS": "Εμφάνιση συνθετικών μελών",
  "SIMPLIFY_MEMBER_REFERENCES": "Απλοποίηση των αναφορών μελών",
  "MERGE_VARIABLES": "Συγχώνευση μεταβλητών",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Επιβολή ρητών επιχειρημάτων τύπου",
  "FORCE_EXPLICIT_IMPORTS": "Επιβολή ρητών εισαγωγών",
  "FLATTEN_SWITCH_BLOCKS": "Επίπεδα μπλοκ διακόπτη",
  "RETAIN_POINTLESS_SWITCHES": "Διατήρηση άσκοπων διακοπτών",
  "RETAIN_REDUNDANT_CASTS": "Διατήρηση περιττών εκμαγείων",
  "UNICODE_OUTPUT_ENABLED": "Ενεργοποιημένη έξοδος Unicode",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Επαναφόρτωση πόρων",
  "RELOAD_RESOURCES_CONFIRM": "Είστε σίγουροι ότι θέλετε να επαναφορτώσετε τους πόρους;",
  "SELECT_FILE_TITLE": "Επιλέξτε αρχείο ή φάκελο για άνοιγμα σε {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Class Files ή Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Επιλέξτε External Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin σε js, java, python, ruby ή groovy",
  "FOREIGN_LIBRARY_WARNING": "ΠΡΟΕΙΔΟΠΟΙΗΣΗ: Με την απενεργοποίηση αυτής της λειτουργίας οι ξεπερασμένες βιβλιοθήκες ΔΕΝ θα αφαιρεθούν.\n\rΕίναι επίσης ένα ζήτημα ασφάλειας.\n\rΑΠΕΝΕΡΓΟΠΟΙΉΣΤΕ ΤΟ ΜΌΝΟ ΑΝ ΞΈΡΕΤΕ ΤΙ ΚΆΝΕΤΕ.",
  "RESET_TITLE": "{PRODUCT_NAME} - Επαναφορά χώρου εργασίας",
  "RESET_CONFIRM": "Είστε σίγουροι ότι θέλετε να επαναφέρετε τον χώρο εργασίας;\n\rΘα επαναφέρει επίσης τον πλοηγό και την αναζήτηση αρχείων.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Έξοδος",
  "EXIT_CONFIRM": "Είστε σίγουρος ότι θέλετε να βγείτε;",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Σχετικά - {ΙΣΤΟΣΕΛΙΔΑ} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Κονσόλα plugin",
  "CLOSE_ALL_BUT_THIS": "Κλείστε όλα εκτός από αυτό",
  "CLOSE_TAB": "Κλείσιμο καρτέλας",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Παρακαλούμε στείλτε αυτό το αρχείο καταγραφής σφαλμάτων στη διεύθυνση",
  "PLEASE_SEND_RESOURCES": "Εάν έχετε τα κατάλληλα νομικά δικαιώματα στη σχετική κατηγορία",
  "ONE_PLUGIN_AT_A_TIME": "Αυτή τη στιγμή εκτελείται ένα άλλο πρόσθετο, περιμένετε να τελειώσει η εκτέλεσή του.",
  "ILLEGAL_ACCESS_ERROR": "Παρακαλούμε χρησιμοποιήστε Java 15 ή παλαιότερη έκδοση για να το κάνετε αυτό.",


  "FILES": "Αρχεία",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Γρήγορη αναζήτηση αρχείων (χωρίς επέκταση αρχείου)",
  "WORK_SPACE": "Χώρος εργασίας",
  "EXACT": "Ακριβώς",
  "SEARCH": "Αναζήτηση",
  "SEARCH_FROM": "Αναζήτηση από:",
  "SEARCH_STRING": "Συμβολοσειρά αναζήτησης:",
  "SEARCH_REGEX": "Αναζήτηση Regex:",
  "OWNER": "Ιδιοκτήτης:",
  "NAME": "Όνομα:",
  "DESC": "Desc:",
  "SAVE": "Αποθήκευση...",
  "SAVE_AS": "Αποθήκευση ως...",
  "RESULTS": "Αποτελέσματα",
  "REFRESH": "Ανανέωση",
  "ANNOTATION_NAME": "Όνομα σχολιασμού",
  "MATCH_CASE": "Περίπτωση αγώνα",
  "EXACT_PATH": "Ακριβής διαδρομή",
  "MIN_SDK_VERSION": "Ελάχιστη έκδοση SDK",
  "PRINT_LINE_NUMBERS": "Εκτύπωση αριθμών γραμμής"
}

```

`src/main/resources/translations/hausa.json`:

```json
{
  "FILE": "Fayil",
  "ADD": "Ara ...",
  "NEW_WORKSPACE": "Sabuwar Wurin Aiki",
  "RELOAD_RESOURCES": "Sake shigar da Albarkatu",
  "RUN": "Gudu",
  "OPEN": "Buɗe ...",
  "OPEN_UNSTYLED": "Bude",
  "QUICK_OPEN": "Saurin Buɗewa",
  "DELETE": "Share",
  "NEW": "Sabo",
  "EXPAND": "Fadada",
  "COLLAPSE": "Rushewa",
  "COMPILE": "Tattara",
  "SAVE_AS_RUNNABLE_JAR": "Ajiye Kamar Jariyar Gudu ...",
  "SAVE_AS_ZIP": "Ajiye As Zip ...",
  "SAVE_AS_DEX": "Ajiye As DEX ...",
  "SAVE_AS_APK": "Ajiye azaman apk ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Rabawa & Ajiye Karatun Da Aka Bude",
  "DECOMPILE_SAVE_ALL_CLASSES": "Tattara & Ajiye Duk Ajujuwa",
  "RECENT_FILES": "Fayilolin kwanan nan",
  "ABOUT": "Game da",
  "EXIT": "Mafita",

  "VIEW": "Duba",
  "VISUAL_SETTINGS": "Saitunan Kayayyaki",
  "PANE_1": "Pane 1",
  "PANE_2": "Pane 2",
  "PANE_3": "Pane 3",
  "NONE": "Babu",
  "EDITABLE": "Daidai",

  "LANGUAGE": "Harshe",
  "FONT_SIZE": "Girman rubutu",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Nuna Fayil A cikin Tab Tab",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Sauƙaƙe Suna A Tab Title",
  "SYNCHRONIZED_VIEWING": "Aiki tare Dubawa",
  "SHOW_CLASS_METHODS": "Nuna Hanyoyin Aji",

  "WINDOW_THEME": "Jigo taga",
  "SYSTEM_THEME": "Tsarin Tsarin",
  "DARK_THEME": "Jigon Duhu",
  "LIGHT_THEME": "Haske Jigo",
  "ONE_DARK_THEME": "Jigo Guda Daya",
  "SOLARIZED_DARK_THEME": "Haske Mai duhu",
  "SOLARIZED_LIGHT_THEME": "Jigon Hasken Haske",
  "HIGH_CONTRAST_DARK_THEME": "Babban Bambancin Duhu",
  "HIGH_CONTRAST_LIGHT_THEME": "Babban Haske Haske",
  "ONE_DARK": "Daya Duhu",
  "SOLARIZED_DARK": "Duhun dare",
  "SOLARIZED_LIGHT": "Haske mai haske",
  "HIGH_CONTRAST_DARK": "Babban Bambanci Duhu",
  "HIGH_CONTRAST_LIGHT": "Babban Bambancin Haske",
  "TEXT_AREA_THEME": "Jigon Yankin Rubutu",
  "DEFAULT_RECOMMENDED_LIGHT": "Tsoho (Nagari Haske)",
  "THEME_MATCH": "Matsalar Jigo (Nagari)",
  "DARK": "Duhu (Nagari mai duhu)",
  "DARK_ALT": "Duhu-Alt",
  "DEFAULT_ALT": "Tsoho-Alt",
  "ECLIPSE": "Hasken rana",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Kayayyakin aikin hurumin kallo",
  "DRUID_DARK": "Druid (Duhu)",
  "MONOKAI_DARK": "Monokai (Duhu)",

  "SETTINGS": "Saituna",
  "COMPILE_ON_SAVE": "Tattara Ajiye",
  "COMPILE_ON_REFRESH": "Tattara A Wartsake",
  "REFRESH_ON_VIEW_CHANGE": "Shakata kan Canjin Canji",
  "DECODE_APK_RESOURCES": "Odeaddamar da kayan aikin APK",
  "APK_CONVERSION": "Sauya APK",
  "APK_CONVERSION_DECODING": "Apc Juyawa / Mahimmanci",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Sabunta Dubawa",
  "DELETE_UNKNOWN_LIBS": "Share Libs na /asashen waje / na da",
  "FORCE_PURE_ASCII_AS_TEXT": "Parfafa Ascii Tsarkake Kamar Rubutu",
  "SET_PYTHON_27_EXECUTABLE": "Sanya Python 2.7 Mai aiwatarwa",
  "SET_PYTHON_30_EXECUTABLE": "Saita Python 3.X Ana aiwatarwa",
  "SET_JRE_RT_LIBRARY": "Kafa JRE RT Library",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Saita Zaɓin Littattafan Zaɓi",
  "SET_JAVAC_EXECUTABLE": "Saita Javac zartarwa",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Saitunan Procyon",
  "CFR_SETTINGS": "Saitunan CFR",
  "FERNFLOWER_SETTINGS": "Saitunan FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "MaidaM",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali / Dex",
  "HEXCODE": "Lambar waya",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Rubutu",

  "BYTECODE_DECOMPILER": "Kamfanin Bytecode",
  "DEBUG_HELPERS": "Cire kuskure Taimakawa",
  "APPEND_BRACKETS_TO_LABEL": "Endara cketsaura zuwa Rubuta",

  "PLUGINS": "Ugarin abubuwa",
  "OPEN_PLUGIN": "Bude Bulogi ...",
  "RECENT_PLUGINS": "Bayanai na kwanan nan",
  "CODE_SEQUENCE_DIAGRAM": "Zane mai lamba Code",
  "MALICIOUS_CODE_SCANNER": "Scanner Code mai ƙeta",
  "SHOW_MAIN_METHODS": "Nuna Babban Hanyoyi",
  "SHOW_ALL_STRINGS": "Nuna Duk Kirtani",
  "REPLACE_STRINGS": "Sauya Kirtani",
  "STACK_FRAMES_REMOVER": "Tari Fitowa Fitowa",
  "ZKM_STRING_DECRYPTER": "ZKM Kirtani Mai Sanda",
  "ALLATORI_STRING_DECRYPTER": "Allatori Kirtani Mai yanke hukunci",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Mai yanke hukunci",
  "VIEW_ANDROID_PERMISSIONS": "Duba Izinin Android",
  "VIEW_MANIFEST": "Duba Bayyanar",
  "CHANGE_CLASSFILE_VERSIONS": "Canza Fassarorin ClassFile",



  "PROCYON_DECOMPILER": "Rarraba Procyon",
  "CFR_DECOMPILER": "CFR Rarrabawa",
  "FERNFLOWER_DECOMPILER": "Rarraba FernFlower",
  "JADX_DECOMPILER": "JADX Rarrabawa",
  "JD_DECOMPILER": "Rarraba JD-GUI",
  "BYTECODE_DISASSEMBLER": "Bytecode Mai Rarrabawa",
  "DISASSEMBLER": "Mai watsa shiri",

  "ERROR": "Kuskure",
  "NEW_JAVA_PLUGIN": "Sabon fulogin Java",
  "NEW_JAVASCRIPT_PLUGIN": "Sabon Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Shawara Gyara: Danna wartsakewa aji, idan ta kasa sake gwada wani decompiler.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Shawara Gyara: Gwada Duba> Pane> Krakatau> Bytecode kuma kunna Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "GARGADI: A halin yanzu ba'a zabi mai hada kayan kwalliya ba. Gwada Duba> Pane kuma zaɓi mai ba da labari.",
  "COMPILER_TIP": "Ka tuna yawancin decompilers ba za su iya samar da azuzuwan hade ba",
  "FIRST_OPEN_A_RESOURCE": "Da farko buɗe kayan aiki a cikin BCV (aji, jar, zip ko apk fayil)",
  "FIRST_OPEN_A_CLASS": "Da farko buɗe tushen kayan aiki a cikin cikin BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Da farko duba fayil ɗin aji a cikin shafin.",
  "DRAG_CLASS_JAR": "Ja aji / jar / zip / APK / DEX nan",

  "YES": "Ee",
  "NO": "A'a",
  "ERROR2": "Kuskure:",
  "PROCESS2": "Aiwatar:",
  "EXIT_VALUE_IS": "Valimar fita ita ce:",
  "JAVA_COMPILE_FAILED": "Tattara Java",
  "ERROR_COMPILING_CLASS": "Kuskuren tattara aji",
  "COMPILER": "Ka tuna yawancin decompilers ba za su iya samar da azuzuwan hade ba",
  "SELECT_LIBRARY_FOLDER": "Zaɓi Jakar Laburare",
  "SELECT_JAVA_RT": "Zaɓi JRE RT Jar",
  "SELECT_JAVA": "Zaɓi Java mai aiwatarwa",
  "SELECT_JAVAC": "Zaɓi Javac Executable",
  "SELECT_JAVA_TOOLS": "Zaɓi Jar Kayan aiki",
  "SELECT_PYTHON_2": "Zaɓi Python 2.7 Mai aiwatarwa",
  "SELECT_PYTHON_3": "Zaɓi Python 3.x Kashewa",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Ko PyPy 2.7 don sauri) Ana aiwatarwa",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Ko PyPy 3.x don hanzari) Ana aiwatarwa",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Kuna buƙatar saita Python 2.7 (ko PyPy 2.7 don saurin) hanyar aiwatarwa.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Kuna buƙatar saita Python 3.x (ko PyPy 3.x don saurin) hanyar aiwatarwa.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Kuna buƙatar saita JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Fayilolin Shirye-shiryen Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "Java Mai aiwatarwa (A cikin JRE C: / Fayilolin Shirye-shirye / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Javac wanda ake zartarwa (Ana buƙatar JDK C: / Fayilolin Shirye-shirye / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "Java Kayan aikin Jar (A cikin JDK C: / Fayilolin Shirye-shirye / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (A Cikin JRE C: / Fayilolin Shirye-shirye / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Zabin Littattafan Zaba (Mai tarawa & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Boye hanyoyin gada",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Ideoye membobin aji na roba",
  "DECOMPILE_INNER_CLASSES": "Rarraba azuzuwan ciki",
  "COLLAPSE_14_CLASS_REFERENCES": "Rushe bayanan nassoshi na 1.4",
  "DECOMPILE_ASSERTIONS": "Tattara maganganu",
  "HIDE_EMPTY_SUPER_INVOCATION": "Ideoye kiran babba",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Boye tsoffin maginin gini",
  "DECOMPILE_GENERIC_SIGNATURES": "Rattara sa hannu na al'ada",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Tsammani dawowa ba jifa ban da",
  "DECOMPILE_ENUMERATIONS": "Tattara lissafi",
  "REMOVE_GETCLASS_INVOCATION": "Cire addu'ar getClass ()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Fassara int 1 azaman boolean gaskiya",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Bada izinin saita sifa ta roba",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Yi la'akari da nau'ikan mara suna kamar java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Sake sake fasalin sunaye daga bayanan cire kuskure",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Cire kewayon keɓaɓɓun fanko",
  "DEINLINE_FINALLY_STRUCTURES": "Inarshen tsarin Deinline",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Bada izinin haruffan ASCII kawai a cikin kirtani",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Sake suna azuzuwan da ba su dace ba da abubuwan aji",

  "DECODE_ENUM_SWITCH": "Odeaddamar da Canjin Enum",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Odearfafa Kirtani Canjawa",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Mai tattarawa",
  "INNER_CLASSES": "Azuzuwan ciki",
  "REMOVE_BOILER_PLATE": "Cire farantin jirgi",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Cire Ciki Masu Aikin Ciki",
  "DECODE_LAMBDAS": "Rarraba Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Iftaukaka Init Constitctor",
  "REMOVE_DEAD_METHODS": "Cire Hanyar Matattu",
  "REMOVE_BAD_GENERICS": "Cire Abubuwa marasa kyau",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Dambe Sugar",
  "SHOW_VERSION": "Nuna Shafi",
  "DECODE_FINALLY": "Odearfafawa A ƙarshe",
  "TIDY_MONITORS": "Shirya Kula",
  "LENIENT": "Mai sassauci",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Sharhi",
  "FORCE_TOP_SORT": "Toparfin Toparfin ƙarfi",
  "FORCE_TOP_SORT_AGGRESS": "Toparfafa Babban Ta'addanci",
  "FORCE_EXCEPTION_PRUNE": "Exarfafa Exarfin Forcearfi",
  "STRING_BUFFER": "Kirtaccen Buffer",
  "STRING_BUILDER": "Mai Kirtani",
  "SILENT": "Shiru",
  "RECOVER": "Maida",
  "OVERRIDE": "Shafe",
  "SHOW_INFERRABLE": "Nuna ferarshe",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Karfin Cond Condpagate",
  "HIDE_UTF": "Uoye UTF",
  "HIDE_LONG_STRINGS": "Ideoye Dogon Kirtani",
  "COMMENT_MONITORS": "Bayanin Kula",
  "ALLOW_CORRECTING": "Bada Gyara",
  "LABELLED_BLOCKS": "Tubalan Lakabi",
  "J14CLASSOBJ": "J14ManabinJJ",
  "HIDE_LANG_IMPORTS": "Boye shigo da kaya",
  "RECOVER_TYPE_CLASH": "Maida Rubutawa irin",
  "RECOVER_TYPE__HINTS": "Maida Alamar Rubuta",
  "FORCE_RETURNING_IFS": "Returnarfin dawo da IFs",
  "FOR_LOOP_AGG_CAPTURE": "Don Madauki AGG Kama",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Koyaushe Geneaukaka keɓaɓɓiyar Bambanta Don Kama Tubalan",
  "EXCLUDE_NESTED_TYPES": "Banda Nested Nau'in",
  "SHOW_DEBUG_LINE_NUMBERS": "Nuna Lissafin Lissafin Lissafi",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Hada Lambobin Layi A Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Haɗa Diididdigar Kuskure",
  "SHOW_SYNTHETIC_MEMBERS": "Nuna mambobin roba",
  "SIMPLIFY_MEMBER_REFERENCES": "Sauƙaƙe Bayanan Membobi",
  "MERGE_VARIABLES": "Haɗa Masu canji",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Exparfafa Hujjojin Nau'in Bayyananne",
  "FORCE_EXPLICIT_IMPORTS": "Forcearfafa shigo da kayayyaki bayyane",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Switch Blocks",
  "RETAIN_POINTLESS_SWITCHES": "Riƙe sauyawa mara ma'ana",
  "RETAIN_REDUNDANT_CASTS": "Riƙe Casananan Casts",
  "UNICODE_OUTPUT_ENABLED": "An kunna fitarwa na Unicode",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Sake shigar da kayan aiki",
  "RELOAD_RESOURCES_CONFIRM": "Shin kun tabbata kuna son sake loda albarkatun?",
  "SELECT_FILE_TITLE": "Zaɓi Fayil ko Jaka don buɗewa a cikin {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Fayilolin Aji ko Zip / Jar / Gidan Tarihi",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Zaɓi Plara na waje",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Abinda ke ciki na BCV a cikin js, java, python, ruby ​​ko groovy",
  "FOREIGN_LIBRARY_WARNING": "GARGADI: Da wannan za'a canza dakunan karatun dakunan karatu na da ba za'a cire ba.\n\rShima batun tsaro ne. {LABARAI} KAWAI KA KASHE SHI IDAN KA SAN ABINDA KAKE AIKATAWA.",
  "RESET_TITLE": "{PRODUCT_NAME} - Sake saita Wurin Aiki",
  "RESET_CONFIRM": "Shin kun tabbata kuna son sake saita filin aiki?\n\rHakanan zata sake saita mai binciken fayil dinta da bincike.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Fita",
  "EXIT_CONFIRM": "Ka tabbata kana son fita?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Game da - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Toshin na'ura mai kwakwalwa",
  "CLOSE_ALL_BUT_THIS": "Rufe Duk Amma Wannan",
  "CLOSE_TAB": "Rufe Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Da fatan za a aika da wannan kuskuren shiga zuwa",
  "PLEASE_SEND_RESOURCES": "Idan kun riƙe haƙƙin haƙƙin doka na dacewa da fayil ɗin da ya dace / jar / apk don Allah a haɗa hakan shima.",
  "ONE_PLUGIN_AT_A_TIME": "A halin yanzu akwai wani plugin da ke gudana a yanzu, da fatan za a jira hakan ya gama aiwatarwa.",
  "ILLEGAL_ACCESS_ERROR": "Da fatan za a yi amfani da Java 15 ko fiye don yin wannan.",


  "FILES": "Fayiloli",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Bincike fayil mai sauri (babu ƙarar fayil)",
  "WORK_SPACE": "Space Space",
  "EXACT": "Daidai",
  "SEARCH": "Bincika",
  "SEARCH_FROM": "Binciko Daga:",
  "SEARCH_STRING": "Search Kirtani:",
  "SEARCH_REGEX": "Binciko Regex:",
  "OWNER": "Mai mallaka:",
  "NAME": "Suna:",
  "DESC": "Desc:",
  "SAVE": "Ajiye ...",
  "SAVE_AS": "Ajiye Kamar ...",
  "RESULTS": "Sakamako",
  "REFRESH": "Shaƙata",
  "ANNOTATION_NAME": "Sunan Bayani",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Madaidaicin Hanya",
  "MIN_SDK_VERSION": "Mafi ƙarancin sigar SDK",
  "PRINT_LINE_NUMBERS": "Buga Lambobin Layi"
}

```

`src/main/resources/translations/hebrew.json`:

```json
{
  "FILE": "קוֹבֶץ",
  "ADD": "לְהוֹסִיף...",
  "NEW_WORKSPACE": "מרחב עבודה חדש",
  "RELOAD_RESOURCES": "טען משאבים מחדש",
  "RUN": "לָרוּץ",
  "OPEN": "לִפְתוֹחַ...",
  "OPEN_UNSTYLED": "לִפְתוֹחַ",
  "QUICK_OPEN": "פתיחה מהירה",
  "DELETE": "לִמְחוֹק",
  "NEW": "חָדָשׁ",
  "EXPAND": "לְהַרְחִיב",
  "COLLAPSE": "הִתמוֹטְטוּת",
  "COMPILE": "לְלַקֵט",
  "SAVE_AS_RUNNABLE_JAR": "שמור כצנצנת ניתנת לריצה ...",
  "SAVE_AS_ZIP": "שמור כ- Zip ...",
  "SAVE_AS_DEX": "שמור כ- DEX ...",
  "SAVE_AS_APK": "שמור כ- APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "פורק ושמור שיעורים שנפתחו",
  "DECOMPILE_SAVE_ALL_CLASSES": "פירוק ושמור את כל השיעורים",
  "RECENT_FILES": "קבצים אחרונים",
  "ABOUT": "על אודות",
  "EXIT": "יְצִיאָה",

  "VIEW": "נוף",
  "VISUAL_SETTINGS": "הגדרות חזותיות",
  "PANE_1": "חלונית 1",
  "PANE_2": "חלונית 2",
  "PANE_3": "חלונית 3",
  "NONE": "אף אחד",
  "EDITABLE": "ניתן לעריכה",

  "LANGUAGE": "שפה",
  "FONT_SIZE": "גודל גופן",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "הצג קובץ בכותרת הכרטיסייה",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "פשט את השם בכותרת הכרטיסייה",
  "SYNCHRONIZED_VIEWING": "צפייה מסונכרנת",
  "SHOW_CLASS_METHODS": "הראה שיטות כיתה",

  "WINDOW_THEME": "נושא חלון",
  "SYSTEM_THEME": "ערכת נושא מערכת",
  "DARK_THEME": "ערכת נושא כהה",
  "LIGHT_THEME": "נושא קל",
  "ONE_DARK_THEME": "נושא אפל אחד",
  "SOLARIZED_DARK_THEME": "נושא אפל שמש",
  "SOLARIZED_LIGHT_THEME": "נושא אור סולארי",
  "HIGH_CONTRAST_DARK_THEME": "נושא כהה בעל ניגודיות גבוהה",
  "HIGH_CONTRAST_LIGHT_THEME": "נושא אור בעל ניגודיות גבוהה",
  "ONE_DARK": "אפל אחד",
  "SOLARIZED_DARK": "חשוך שמש",
  "SOLARIZED_LIGHT": "אור שמש",
  "HIGH_CONTRAST_DARK": "ניגודיות גבוהה כהה",
  "HIGH_CONTRAST_LIGHT": "אור ניגודיות גבוה",
  "TEXT_AREA_THEME": "נושא אזור הטקסט",
  "DEFAULT_RECOMMENDED_LIGHT": "ברירת מחדל (אור מומלץ)",
  "THEME_MATCH": "התאמת נושא (מומלץ)",
  "DARK": "כהה (מומלץ כהה)",
  "DARK_ALT": "כהה-אלט",
  "DEFAULT_ALT": "ברירת מחדל- Alt",
  "ECLIPSE": "ליקוי חמה",
  "INTELLIJ": "אינטליג '",
  "VISUAL_STUDIO": "סטודיו חזותי",
  "DRUID_DARK": "דרואיד (כהה)",
  "MONOKAI_DARK": "מונוקאי (כהה)",

  "SETTINGS": "הגדרות",
  "COMPILE_ON_SAVE": "הידור בעת שמירה",
  "COMPILE_ON_REFRESH": "הידור על רענון",
  "REFRESH_ON_VIEW_CHANGE": "רענן בשינוי תצוגה",
  "DECODE_APK_RESOURCES": "לפענח משאבי APK",
  "APK_CONVERSION": "המרת APK",
  "APK_CONVERSION_DECODING": "המרה / פענוח של APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "להגדיל",
  "UPDATE_CHECK": "בדיקת עדכון",
  "DELETE_UNKNOWN_LIBS": "מחק ליבות זרות / מיושנות",
  "FORCE_PURE_ASCII_AS_TEXT": "כפה אסצ'י טהור כטקסט",
  "SET_PYTHON_27_EXECUTABLE": "הגדר את Python 2.7 להפעלה",
  "SET_PYTHON_30_EXECUTABLE": "הגדר את Python 3.X להפעלה",
  "SET_JRE_RT_LIBRARY": "הגדר את ספריית JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "הגדר תיקיית ספריה אופציונלית",
  "SET_JAVAC_EXECUTABLE": "הגדר את Javac הפעלה",

  "JAVA": "ג'אווה",
  "PROCYON_SETTINGS": "הגדרות Procyon",
  "CFR_SETTINGS": "הגדרות CFR",
  "FERNFLOWER_SETTINGS": "הגדרות FernFlower",
  "PROCYON": "פרוקיון",
  "CFR": "CFR",
  "FERNFLOWER": "פרנפלור",
  "KRAKATAU": "קרקטאו",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "סמאלי",
  "SMALI_DEX": "סמאלי / דקס",
  "HEXCODE": "הקסקוד",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Decompiler Bytecode",
  "DEBUG_HELPERS": "עוזרי איתור באגים",
  "APPEND_BRACKETS_TO_LABEL": "הוסף סוגריים לתווית",

  "PLUGINS": "תוספים",
  "OPEN_PLUGIN": "פתח תוסף ...",
  "RECENT_PLUGINS": "תוספים אחרונים",
  "CODE_SEQUENCE_DIAGRAM": "תרשים רצף קוד",
  "MALICIOUS_CODE_SCANNER": "סורק קוד זדוני",
  "SHOW_MAIN_METHODS": "הראה שיטות עיקריות",
  "SHOW_ALL_STRINGS": "הצג את כל המיתרים",
  "REPLACE_STRINGS": "החלף מיתרים",
  "STACK_FRAMES_REMOVER": "מסיר מסגרות מחסנית",
  "ZKM_STRING_DECRYPTER": "מפענח מחרוזת ZKM",
  "ALLATORI_STRING_DECRYPTER": "מפענח מחרוזות אלטורי",
  "ZSTRINGARRAY_DECRYPTER": "מפענח ZStringArray",
  "VIEW_ANDROID_PERMISSIONS": "הצג הרשאות Android",
  "VIEW_MANIFEST": "צפה במניפסט",
  "CHANGE_CLASSFILE_VERSIONS": "שנה גרסאות ClassFile",



  "PROCYON_DECOMPILER": "פרוקיון דקומפילר",
  "CFR_DECOMPILER": "Decompiler CFR",
  "FERNFLOWER_DECOMPILER": "מפרק פרנפלוור",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "מפרק Bytecode",
  "DISASSEMBLER": "מפרק",

  "ERROR": "שְׁגִיאָה",
  "NEW_JAVA_PLUGIN": "תוסף Java חדש",
  "NEW_JAVASCRIPT_PLUGIN": "תוסף Javascript חדש",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "תיקון מוצע: לחץ על כיתת הרענון, אם הוא נכשל שוב נסה מפזר אחר.",
  "SUGGESTED_FIX_COMPILER_ERROR": "תיקון מוצע: נסה להציג> חלונית> קרקאטאו> Bytecode והפעל לעריכה.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "אזהרה: לא נבחר כרגע פורץ decompiler. נסה View> Pane ובחר decompiler.",
  "COMPILER_TIP": "זכור שרוב המפזרים לא יכולים לייצר שיעורים הניתנים לבידור",
  "FIRST_OPEN_A_RESOURCE": "ראשית פתח משאב בתוך BCV (קובץ class, jar, zip או apk)",
  "FIRST_OPEN_A_CLASS": "ראשית פתח משאב לקבצי כיתות בתוך BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "ראשית צפה בקובץ מחלקה בתוך כרטיסייה.",
  "DRAG_CLASS_JAR": "גרור לכיתה / צנצנת / zip / APK / DEX לכאן",

  "YES": "כן",
  "NO": "לא",
  "ERROR2": "שְׁגִיאָה:",
  "PROCESS2": "תהליך:",
  "EXIT_VALUE_IS": "ערך היציאה הוא:",
  "JAVA_COMPILE_FAILED": "הידור של Java נכשל",
  "ERROR_COMPILING_CLASS": "שגיאה בהרכבת הכיתה",
  "COMPILER": "זכור שרוב המפזרים לא יכולים לייצר שיעורים הניתנים לבידור",
  "SELECT_LIBRARY_FOLDER": "בחר תיקיית ספרייה",
  "SELECT_JAVA_RT": "בחר JRE RT Jar",
  "SELECT_JAVA": "בחר Java Executable",
  "SELECT_JAVAC": "בחר Javac Executable",
  "SELECT_JAVA_TOOLS": "בחר צנצנת כלים של Java",
  "SELECT_PYTHON_2": "בחר Python 2.7 הפעלה",
  "SELECT_PYTHON_3": "בחר Python 3.x הפעלה",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (או PyPy 2.7 למהירות) הפעלה",
  "PYTHON_3_EXECUTABLE": "Python 3.x (או PyPy 3.x למהירות) הפעלה",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "עליך להגדיר את נתיב ההפעלה של Python 2.7 (או PyPy 2.7 למהירות).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "עליך להגדיר את נתיב ההפעלה של Python 3.x (או PyPy 3.x עבור מהירות).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "עליך להגדיר את ספריית JRE RT שלך.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "הפעלה של Java (בתוך JRE C: / קבצי תוכנה / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "הפעלה Javac (דורשת JDK C: / קבצי תוכנה / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "צנצנת כלים של Java (בתוך JDK C: / קבצי תוכנה / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "צנצנת Java RT (בתוך JRE C: / קבצי תוכנה / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "תיקיית ספרייה אופציונלית (מהדר וקרקאטאו)",

  "HIDE_BRIDGE_METHODS": "הסתר שיטות גשר",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "הסתר את חברי הכיתה הסינתטית",
  "DECOMPILE_INNER_CLASSES": "פורק שיעורים פנימיים",
  "COLLAPSE_14_CLASS_REFERENCES": "כווץ 1.4 הפניות לכיתה",
  "DECOMPILE_ASSERTIONS": "פירוט טענות",
  "HIDE_EMPTY_SUPER_INVOCATION": "הסתר קריאת סופר ריקה",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "הסתר בנאי ברירת מחדל ריק",
  "DECOMPILE_GENERIC_SIGNATURES": "פירוק חתימות כלליות",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "נניח להחזיר ולא לזרוק חריגים",
  "DECOMPILE_ENUMERATIONS": "פירוט ספירות",
  "REMOVE_GETCLASS_INVOCATION": "הסר את קריאת getClass ()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "פרש את int 1 כנכון בוליאני",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "אפשר לא להגדיר תכונה סינטטית",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "שקול סוגים חסרי שם כמו java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "בנה מחדש שמות משתנים ממידע באגים",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "הסר טווחי חריגים ריקים",
  "DEINLINE_FINALLY_STRUCTURES": "סוף סוף דיינליין מבנים",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "אפשר רק תווי ASCII במחרוזות",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "שנה שם של כיתות ואלמנטים כיתתיים דו-משמעיים",

  "DECODE_ENUM_SWITCH": "פענוח מתג Enum",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "פענוח מתג מחרוזת",
  "ARRAYITER": "מעריך",
  "COLLECTIONITER": "אוסף",
  "INNER_CLASSES": "שיעורים פנימיים",
  "REMOVE_BOILER_PLATE": "הסר את לוחית הדוד",
  "REMOVE_INNER_CLASS_SYNTHETICS": "הסר את הסינתטיים של הכיתה הפנימית",
  "DECODE_LAMBDAS": "לפענח למבדות",
  "LIFT__CONSTRUCTOR_INIT": "בניית הרמה ראשונית",
  "REMOVE_DEAD_METHODS": "הסר שיטות מתות",
  "REMOVE_BAD_GENERICS": "הסר את הגנריות הרעות",
  "SUGAR_ASSERTS": "תביעות סוכר",
  "SUGAR_BOXING": "אגרוף סוכר",
  "SHOW_VERSION": "הצגת גרסה",
  "DECODE_FINALLY": "סוף סוף לפענח",
  "TIDY_MONITORS": "מסכים מסודרים",
  "LENIENT": "וַתְרָן",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "הערות",
  "FORCE_TOP_SORT": "כוח מיון עליון",
  "FORCE_TOP_SORT_AGGRESS": "כפה תוקפנות מיון עליון",
  "FORCE_EXCEPTION_PRUNE": "גזום חריגה בכוח",
  "STRING_BUFFER": "חיץ מחרוזות",
  "STRING_BUILDER": "בונה מיתרים",
  "SILENT": "שקט",
  "RECOVER": "לְהַחלִים",
  "OVERRIDE": "לבטל",
  "SHOW_INFERRABLE": "הראה בלתי נראה",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "כוח הפצת כוחות",
  "HIDE_UTF": "הסתר UTF",
  "HIDE_LONG_STRINGS": "הסתר מיתרים ארוכים",
  "COMMENT_MONITORS": "צגי הערות",
  "ALLOW_CORRECTING": "אפשר תיקון",
  "LABELLED_BLOCKS": "בלוקים שכותרתו",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "הסתר יבוא לאנג",
  "RECOVER_TYPE_CLASH": "התאושש סוג התנגשות",
  "RECOVER_TYPE__HINTS": "שחזר רמזים מסוג",
  "FORCE_RETURNING_IFS": "כוח IF חוזרים",
  "FOR_LOOP_AGG_CAPTURE": "עבור לכידת לולאה AGG",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "צור תמיד משתנה חריג עבור בלוקי תפיסה",
  "EXCLUDE_NESTED_TYPES": "אל תכלול סוגים מקוננים",
  "SHOW_DEBUG_LINE_NUMBERS": "הצג מספרי שגיאות איתור באגים",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "כלול מספרי שורות ב- Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "כלול אבחון שגיאות",
  "SHOW_SYNTHETIC_MEMBERS": "הראה חברים סינתטיים",
  "SIMPLIFY_MEMBER_REFERENCES": "לפשט הפניות לחברים",
  "MERGE_VARIABLES": "מיזוג משתנים",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "כוח ארגומנטים מסוג מפורש",
  "FORCE_EXPLICIT_IMPORTS": "כוח ייבוא ​​מפורש",
  "FLATTEN_SWITCH_BLOCKS": "פסי בלוקים למתגים",
  "RETAIN_POINTLESS_SWITCHES": "שמור על מתגים חסרי טעם",
  "RETAIN_REDUNDANT_CASTS": "שמור על שחקנים מיותרים",
  "UNICODE_OUTPUT_ENABLED": "פלט Unicode מופעל",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - טען משאבים מחדש",
  "RELOAD_RESOURCES_CONFIRM": "האם אתה בטוח שברצונך לטעון מחדש את המשאבים?",
  "SELECT_FILE_TITLE": "בחר קובץ או תיקיה לפתיחה ב- {BCV}",
  "SELECT_FILE_DESCRIPTION": "חבילות APK, DEX, קבצי כיתה או ארכיון מיקוד / צנצנת / מלחמה",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "בחר תוסף חיצוני",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "תוסף BCV חיצוני ב- js, java, python, ruby ​​או groovy",
  "FOREIGN_LIBRARY_WARNING": "אזהרה: עם ביטול זה הספריות המיושנות לא יוסרו.\n\rזו גם בעיית אבטחה.\n\rכבה את זה רק אם אתה יודע מה אתה עושה.",
  "RESET_TITLE": "{PRODUCT_NAME} - אפס את סביבת העבודה",
  "RESET_CONFIRM": "האם אתה בטוח שברצונך לאפס את שטח העבודה?\n\rזה יאפס גם את נווט הקבצים שלך ואת החיפוש שלך.",
  "EXIT_TITLE": "{PRODUCT_NAME} - יציאה",
  "EXIT_CONFIRM": "אתה בטוח שאתה רוצה לצאת?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - מידע על - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - מסוף התוספים",
  "CLOSE_ALL_BUT_THIS": "סגור הכל חוץ מזה",
  "CLOSE_TAB": "סגור את הכרטיסייה",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "אנא שלח את יומן השגיאות אל",
  "PLEASE_SEND_RESOURCES": "אם אתה מחזיק בזכויות חוקיות מתאימות לקובץ class / jar / apk הרלוונטי, אנא כלול גם את זה.",
  "ONE_PLUGIN_AT_A_TIME": "יש כרגע תוסף נוסף שפועל כעת, אנא המתן עד שיסיים להפעיל אותו.",
  "ILLEGAL_ACCESS_ERROR": "השתמש ב-Java 15 ומעלה כדי לעשות זאת.",


  "FILES": "קבצים",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "חיפוש קבצים מהיר (ללא סיומת קובץ)",
  "WORK_SPACE": "שטח עבודה",
  "EXACT": "מְדוּיָק",
  "SEARCH": "לחפש",
  "SEARCH_FROM": "חיפוש מ:",
  "SEARCH_STRING": "מחרוזת חיפוש:",
  "SEARCH_REGEX": "חפש ב- Regex:",
  "OWNER": "בעלים:",
  "NAME": "שֵׁם:",
  "DESC": "Desc:",
  "SAVE": "להציל...",
  "SAVE_AS": "שמור כ...",
  "RESULTS": "תוצאות",
  "REFRESH": "לְרַעֲנֵן",
  "ANNOTATION_NAME": "שם הערה",
  "MATCH_CASE": "מארז התאמה",
  "EXACT_PATH": "נתיב מדויק",
  "MIN_SDK_VERSION": "גרסת SDK מינימלית",
  "PRINT_LINE_NUMBERS": "הדפס מספרי שורה"
}

```

`src/main/resources/translations/hindi.json`:

```json
{
  "FILE": "फ़ाइल",
  "ADD": "जोड़ें...",
  "NEW_WORKSPACE": "नया कार्यक्षेत्र",
  "RELOAD_RESOURCES": "संसाधन पुनः लोड करें",
  "RUN": "चलाना",
  "OPEN": "Open...",
  "OPEN_UNSTYLED": "Open",
  "QUICK_OPEN": "Quick Open",
  "DELETE": "Delete",
  "NEW": "New",
  "EXPAND": "Expand",
  "COLLAPSE": "Collapse",
  "COMPILE": "संकलन",
  "SAVE_AS_RUNNABLE_JAR": "रननेबल जार के रूप में सहेजें ...",
  "SAVE_AS_ZIP": "ज़िप के रूप में सहेजें...",
  "SAVE_AS_DEX": "DEX के रूप में सहेजें...",
  "SAVE_AS_APK": "APK के रूप में सहेजें...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "खुली कक्षाओं को डीकंपाइल और सेव करें",
  "DECOMPILE_SAVE_ALL_CLASSES": "सभी वर्गों को डीकंपाइल और सेव करें",
  "RECENT_FILES": "हाल हीं के फाइल",
  "ABOUT": "तकरीबन",
  "EXIT": "बाहर जाएं",

  "VIEW": "राय",
  "VISUAL_SETTINGS": "दृश्य सेटिंग्स",
  "PANE_1": "फलक १",
  "PANE_2": "फलक २",
  "PANE_3": "फलक ३",
  "NONE": "कोई नहीं",
  "EDITABLE": "संपादन योग्य",

  "LANGUAGE": "भाषा: हिन्दी",
  "FONT_SIZE": "फ़ॉन्ट आकार",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "टैब शीर्षक में फ़ाइल दिखाएं",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "टैब शीर्षक में नाम को सरल बनाएं",
  "SYNCHRONIZED_VIEWING": "सिंक्रोनाइज़्ड व्यूइंग",
  "SHOW_CLASS_METHODS": "कक्षा के तरीके दिखाएं",

  "WINDOW_THEME": "विंडो थीम",
  "SYSTEM_THEME": "सिस्टम थीम",
  "DARK_THEME": "डार्क थीम",
  "LIGHT_THEME": "लाइट थीम",
  "ONE_DARK_THEME": "One Dark Theme",
  "SOLARIZED_DARK_THEME": "Solarized Dark Theme",
  "SOLARIZED_LIGHT_THEME": "Solarized Light Theme",
  "HIGH_CONTRAST_DARK_THEME": "High Contrast Dark Theme",
  "HIGH_CONTRAST_LIGHT_THEME": "High Contrast Light Theme",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solarized Light",
  "HIGH_CONTRAST_DARK": "High Contrast Dark",
  "HIGH_CONTRAST_LIGHT": "High Contrast Light",
  "TEXT_AREA_THEME": "टेक्स्ट एरिया थीम",
  "DEFAULT_RECOMMENDED_LIGHT": "डिफ़ॉल्ट (अनुशंसित प्रकाश)",
  "THEME_MATCH": "Theme Match (Recommended)",
  "DARK": "Dark (Recommended Dark)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "डिफ़ॉल्ट-Alt",
  "ECLIPSE": "ग्रहण",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "दृश्य स्टूडियो",
  "DRUID_DARK": "ड्र्यूड (डार्क)",
  "MONOKAI_DARK": "मोनोकै (डार्क)",

  "SETTINGS": "समायोजन",
  "COMPILE_ON_SAVE": "सहेजें पर संकलित करें",
  "COMPILE_ON_REFRESH": "ताज़ा करने पर संकलित करें",
  "REFRESH_ON_VIEW_CHANGE": "दृश्य परिवर्तन पर ताज़ा करें",
  "DECODE_APK_RESOURCES": "डीकोड एपीके संसाधन",
  "APK_CONVERSION": "एपीके रूपांतरण",
  "APK_CONVERSION_DECODING": "APK Conversion/Decoding",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "एनजारिफाइ",
  "UPDATE_CHECK": "अद्यतन की जाँच करें",
  "DELETE_UNKNOWN_LIBS": "विदेशी/पुरानी लिब्स हटाएं",
  "FORCE_PURE_ASCII_AS_TEXT": "पाठ के रूप में शुद्ध Ascii को बल दें",
  "SET_PYTHON_27_EXECUTABLE": "पायथन 2.7 निष्पादन योग्य सेट करें",
  "SET_PYTHON_30_EXECUTABLE": "पायथन 3.X निष्पादन योग्य सेट करें",
  "SET_JRE_RT_LIBRARY": "जेआरई आरटी लाइब्रेरी सेट करें",
  "SET_OPTIONAL_LIBRARY_FOLDER": "वैकल्पिक लाइब्रेरी फ़ोल्डर सेट करें",
  "SET_JAVAC_EXECUTABLE": "जावैक निष्पादन योग्य सेट करें",

  "JAVA": "जावा",
  "PROCYON_SETTINGS": "Procyon Settings",
  "CFR_SETTINGS": "CFR Settings",
  "FERNFLOWER_SETTINGS": "FernFlower Settings",
  "PROCYON": "प्रोसिओन",
  "CFR": "सीएफआर",
  "FERNFLOWER": "फर्नफ्लावर",
  "KRAKATAU": "Krakatau",
  "JDGUI": "जद-जीयूआई",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "स्माली/डेक्स",
  "HEXCODE": "हेक्सकोड",
  "BYTECODE": "बाईटकोड",
  "ASM_TEXTIFY": "एएसएम टेक्स्टिफाई",

  "BYTECODE_DECOMPILER": "बाइटकोड डीकंपेलर",
  "DEBUG_HELPERS": "डिबग हेल्पर्स",
  "APPEND_BRACKETS_TO_LABEL": "ब्रैकेट को लेबल में जोड़ें",

  "PLUGINS": "प्लग-इन",
  "OPEN_PLUGIN": "प्लगइन खोलें...",
  "RECENT_PLUGINS": "हाल के प्लगइन्स",
  "CODE_SEQUENCE_DIAGRAM": "कोड अनुक्रम आरेख",
  "MALICIOUS_CODE_SCANNER": "दुर्भावनापूर्ण कोड स्कैनर",
  "SHOW_MAIN_METHODS": "मुख्य तरीके दिखाएं",
  "SHOW_ALL_STRINGS": "सभी तार दिखाएं",
  "REPLACE_STRINGS": "स्ट्रिंग्स बदलें",
  "STACK_FRAMES_REMOVER": "स्टैक फ्रेम्स रिमूवर",
  "ZKM_STRING_DECRYPTER": "ZKM स्ट्रिंग डिक्रिप्टर",
  "ALLATORI_STRING_DECRYPTER": "एलाटोरी स्ट्रिंग डिक्रिप्टर",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray डिक्रिप्टर",
  "VIEW_ANDROID_PERMISSIONS": "View Android Permissions",
  "VIEW_MANIFEST": "View Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Change ClassFile Versions",



  "PROCYON_DECOMPILER": "प्रोसीओन डीकंपाइलर",
  "CFR_DECOMPILER": "सीएफआर डीकंपाइलर",
  "FERNFLOWER_DECOMPILER": "फर्नाफ्लावर डीकंपेलर",
  "JADX_DECOMPILER": "JADX डीकंपेलर",
  "JD_DECOMPILER": "जद-जीयूआई डीकंपेलर",
  "BYTECODE_DISASSEMBLER": "बाइटकोड डिस्सेबलर",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Error",
  "NEW_JAVA_PLUGIN": "New Java Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "New Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Suggested Fix: Click refresh class, if it fails again try another decompiler.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Suggested Fix: Try View>Pane>Krakatau>Bytecode and enable Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "WARNING: No decompiler is currently selected. Try View>Pane and choose a decompiler.",
  "COMPILER_TIP": "Keep in mind most decompilers cannot produce compilable classes",
  "FIRST_OPEN_A_RESOURCE": "First open a resource inside of BCV (class, jar, zip or apk file)",
  "FIRST_OPEN_A_CLASS": "First open a classfile resource inside of BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "First view a class file inside of a tab.",
  "DRAG_CLASS_JAR": "Drag class/jar/zip/APK/DEX here",

  "YES": "Yes",
  "NO": "No",
  "ERROR2": "Error:",
  "PROCESS2": "Process:",
  "EXIT_VALUE_IS": "Exit Value is:",
  "JAVA_COMPILE_FAILED": "Java Compile Failed",
  "ERROR_COMPILING_CLASS": "Error compiling class",
  "COMPILER": "Keep in mind most decompilers cannot produce compilable classes",
  "SELECT_LIBRARY_FOLDER": "Select Library Folder",
  "SELECT_JAVA_RT": "Select JRE RT Jar",
  "SELECT_JAVA": "Select Java Executable",
  "SELECT_JAVAC": "Select Javac Executable",
  "SELECT_JAVA_TOOLS": "Select Java Tools Jar",
  "SELECT_PYTHON_2": "Select Python 2.7 Executable",
  "SELECT_PYTHON_3": "Select Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Or PyPy 2.7 for speed) Executable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Or PyPy 3.x for speed) Executable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "You need to set your Python 2.7 (or PyPy 2.7 for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "You need to set your Python 3.x (or PyPy 3.x for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "You need to set your JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C:/Program Files/Java/JRE_xx/bin/java.exe)",
  "JAVAC_EXECUTABLE": "Javac Executable (Requires JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C:/Program Files/Java/JDK_xx/lib/tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C:/Program Files/Java/JRE_xx/lib/rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Optional Library Folder (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Hide bridge methods",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Hide synthetic class members",
  "DECOMPILE_INNER_CLASSES": "Decompile inner classes",
  "COLLAPSE_14_CLASS_REFERENCES": "Collapse 1.4 class references",
  "DECOMPILE_ASSERTIONS": "Decompile assertions",
  "HIDE_EMPTY_SUPER_INVOCATION": "Hide empty super invocation",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Hide empty default constructor",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompile generic signatures",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Assume return not throwing exceptions",
  "DECOMPILE_ENUMERATIONS": "Decompile enumerations",
  "REMOVE_GETCLASS_INVOCATION": "Remove getClass() invocation",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpret int 1 as boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Allow for not set synthetic attribute",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Consider nameless types as java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruct variable names from debug info",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Remove empty exception ranges",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finally structures",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Allow only ASCII characters in strings",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Rename ambiguous classes and class elements",

  "DECODE_ENUM_SWITCH": "Decode Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Decode String Switch",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Inner Classes",
  "REMOVE_BOILER_PLATE": "Remove Boiler Plate",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Remove Inner Class Synthetics",
  "DECODE_LAMBDAS": "Decode Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift  Constructor Init",
  "REMOVE_DEAD_METHODS": "Remove Dead Methods",
  "REMOVE_BAD_GENERICS": "Remove Bad Generics",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Show Version",
  "DECODE_FINALLY": "Decode Finally",
  "TIDY_MONITORS": "Tidy Monitors",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Comments",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Recover",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Show Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Hide UTF",
  "HIDE_LONG_STRINGS": "Hide Long Strings",
  "COMMENT_MONITORS": "Comment Monitors",
  "ALLOW_CORRECTING": "Allow Correcting",
  "LABELLED_BLOCKS": "Labelled Blocks",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Recover Type Clash",
  "RECOVER_TYPE__HINTS": "Recover Type  Hints",
  "FORCE_RETURNING_IFS": "Force Returning IFs",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Always Generate Exception Variable For Catch Blocks",
  "EXCLUDE_NESTED_TYPES": "Exclude Nested Types",
  "SHOW_DEBUG_LINE_NUMBERS": "Show Debug Line Numbers",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Include Line Numbers In Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Include Error Diagnostics",
  "SHOW_SYNTHETIC_MEMBERS": "Show Synthetic Members",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplify Member References",
  "MERGE_VARIABLES": "Merge Variables",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Force Explicit Imports",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Switch Blocks",
  "RETAIN_POINTLESS_SWITCHES": "Retain Pointless Switches",
  "RETAIN_REDUNDANT_CASTS": "Retain Redundant Casts",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Reload Resources",
  "RELOAD_RESOURCES_CONFIRM": "Are you sure you wish to reload the resources?",
  "SELECT_FILE_TITLE": "Select File or Folder to open in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Class Files or Zip/Jar/War Archives",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Select External Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin in js, java, python, ruby or groovy",
  "FOREIGN_LIBRARY_WARNING": "WARNING: With this being toggled off outdated libraries will NOT be removed.\n\rIt's also a security issue.\n\rONLY TURN IT OFF IF YOU KNOW WHAT YOU'RE DOING.",
  "RESET_TITLE": "{PRODUCT_NAME} - Reset Workspace",
  "RESET_CONFIRM": "Are you sure you want to reset the workspace?\n\rIt will also reset your file navigator and search.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Are you sure you want to exit?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - About - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Close All But This",
  "CLOSE_TAB": "Close Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Please send this error log to",
  "PLEASE_SEND_RESOURCES": "If you hold appropriate legal rights to the relevant class/jar/apk file please include that as well.",
  "ONE_PLUGIN_AT_A_TIME": "There is currently another plugin running right now, please wait for that to finish executing.",
  "ILLEGAL_ACCESS_ERROR": "Please use Java 15 or older to do this.",


  "FILES": "फ़ाइलें",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "त्वरित फ़ाइल खोज (कोई फ़ाइल एक्सटेंशन नहीं)",
  "WORK_SPACE": "कार्य स्थान",
  "EXACT": "सटीक",
  "SEARCH": "खोज",
  "SEARCH_FROM": "Search From: ",
  "SEARCH_STRING": "Search String: ",
  "SEARCH_REGEX": "Search Regex: ",
  "OWNER": "Owner: ",
  "NAME": "Name: ",
  "DESC": "Desc: ",
  "SAVE": "Save...",
  "SAVE_AS": "Save As...",
  "RESULTS": "परिणाम",
  "REFRESH": "ताज़ा करना",
  "ANNOTATION_NAME": "Annotation Name",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Exact Path",
  "MIN_SDK_VERSION": "Minimum SDK version",
  "PRINT_LINE_NUMBERS": "Print Line Numbers"
}

```

`src/main/resources/translations/html/intro.english.html`:

```html
<html lang="en">
<h2>About</h2>

Bytecode Viewer (BCV) is an easy-to-use Java & Android Reverse Engineering Suite!<br>
BCV is designed to be extremely user and beginner-friendly, this means everything is accessible through an interface such as settings, tools, etc.

<br><br>To start, simply drag your Jar/APK/Class file into the resource list.

<h2>How To - Java Importing</h2>
<pre>
Java resources have no special preprocessing before you open them.
Import your Jar/Class/WAR/EAR file via the File>Open menu in Bytecode Viewer. (CTRL + O)
</pre>

<h2>How To - Android Importing</h2>
<pre>
Android resources have three options for preprocessing:
    1). Decode Resources
    2). Enjarify
    3). Dex2Jar (d2j)
1). Decode Resources will run APKTool to decode any packed android-specific resources
2). Enjarify will convert the Android Dalvik Bytecode to Java Bytecode
3). Dex2Jar will convert the Android Dalvik Bytecode to Java Bytecode

Import your APK/WAPK/DEX file via the File>Open menu in Bytecode Viewer. (CTRL + O)
</pre>

<h2>How To - File Navigation</h2>

<pre>
To use the resource list - (Note: it will say "Files" on the title bar) - you can select all of the resources added into BCV.
Any archive (Zip, Jar, ETC.) will opened.
To select a resource click + button for each folder.
Using the search pane inside of the resource list you can search by file name and extension.
For case-sensitivity enable the checkbox labeled "Exact".
</pre>

<h2>Settings</h2>
<ul>
    <li>Fat Jar: {fatJar}</li>
    <li>Java: {java}</li>
    <li>Javac: {javac}</li>
    <li>Python 2.7 (or PyPy): {python}</li>
    <li>Python 3.X (or PyPy): {python3}</li>
    <li>RT.jar: {rt}</li>
    <li>Optional Lib: {lib}</li>
    <li>BCV Dir: {bcvDir}</li>
    <li>Temp Dir: {tempDir}</li>
    <li>Krakatau Dir: {krakatauDir}</li>
    <li>Enjarify Dir: {enjarifyDir}</li>
    <li>BCV Krakatau version: v{krakatauVersion}</li>
    <li>BCV Enjarify version: v{enjarifyVersion}</li>
</ul>

<h2>Command Line Interface (CLI)</h2>
<ul>
    <li> -help Displays the help menu</li>
    <li> -list Displays the available decompilers</li>
    <li> -decompiler [decompiler] Selects the decompiler, procyon by default</li>
    <li> -i [input file] Selects the input file (Jar, Class, APK, ZIP, DEX all work automatically)</li>
    <li> -o [output file] Selects the output file (Java or Java-Bytecode)</li>
    <li> -t [target classname] Must either be the fully qualified classname or "all" to decompile all as zip</li>
    <li> -nowait Doesn't wait for the user to read the CLI messages</li>
</ul>

<h2>File</h2>
<ul>
    <li>Add (Ctrl + O) - If you add a jar/zip BCV will unzip it, if you add an APK or DEX file, BCV will run dex2jar
        then run the jar input process.
    </li>
    <li>Reopen Recent File (Ctrl + L) - Reopens your last recent opened file.</li>
    <li>New Workspace (Ctrl + N) - It clears the opened jars/resources.</li>
    <li>Run (Ctrl + R) - Runs the classfiles you've loaded into BCV in a secure sandboxed JVM instance that you can
        fully debug.
    </li>
    <li>Compile (Ctrl + T) - Tries to compile all of the editable panes you've selected, if it's Java it'll compile with
        Ranino. Krakatau and *Smali use their own assemblers.
    </li>
    <li>Save As Jar - Export the class files and loaded resources as a runnable Jar file.</li>
    <li>Save As DEX - Run jar2dex and export the Classfiles as DEX.</li>
    <li>Save Files As - Save all the Classfiles and resources as a zip.</li>
    <li>Save Java File As - Save the currently opened decompiled Classfile.</li>
    <li>Save Java Files As - Save all of the decompiled Classfiles as a zip.</li>
    <li>Recent Files - Last 25 files/directories you've opened with BCV.</li>
    <li>About - A small information window about BCV.</li>
    <li>Exit - Closes BCV.</li>
</ul>

<h2>View Panes</h2>
<ul>
    <li>Editable - Defines if that viewing pane will be editable.</li>
    <li>None - Nothing will be displayed.</li>
    <li>Procyon - Decompiles with Procyon decompiler.</li>
    <li>CFR - Decompilers with CFR decompiler.</li>
    <li>FernFlower - Decompiles with FernFlower decompiler.</li>
    <li>JD-GUI - Decompiles with JD-GUI decompiler.</li>
    <li>Krakatau Java - Decompiles with Krakatau decompiler.</li>
    <li>Krakatau Bytecode - Disassembles with Krakatau disassembler.</li>
    <li>Smali - Disassembles with Smali.</li>
    <li>Bytecode - Decompiles the Bytecode via CFIDE. Not Editable.</li>
    <li>Hexcode - Shows the classfile in a hex viewer. Not Editable.</li>
</ul>

<h2>Settings</h2>
<ul>
    <li>Compile On Save - If selected whenever you do one of the File>Save * functions it will try to compile before it
        saves.
    </li>
    <li>Compile On Refresh - If selected whenever you press refresh it compile before it reloads the resource/class.
    </li>
    <li>Update Check - If selected it queries https://github.com/Konloch/bytecode-viewer to ensure you've got the latest
        version.
    </li>
    <li>Refresh On View Change - If selected whenever you change an option in the View Panes it will refresh the
        currently opened resources/class.
    </li>
    <li>Decode APK Resources - If selected whenever you add an APK, it will first run APKTool.jar to decode the
        resources.
    </li>
    <li>Set Python 2.7 Executable - Set the Python 2.7 executable if you want Krakatau decompiler/disassembler/assembler
        to work.
    </li>
    <li>Set JRE RT Library - Set the JRE RT library for Krakatau decompiler.</li>
</ul>

<h2>Plugins</h2>
<ul>
    <li>Open Plugin - Open a .java plugin created for BCV.</li>
    <li>Recent Plugins - Last 25 plugins you've opened with BCV.</li>
    <li>Code Sequence Diagram - Builds a crude code sequence diagram for the classfile that's currently opened.</li>
    <li>Malicious Code Scanner - Allows you to define what to search for, and outputs what it found.</li>
    <li>Show Main Methods - Detects and outputs all of the public static void main(String[]) functions.</li>
    <li>Show All Strings - Grabs then outputs all of the strings in every classfile.</li>
    <li>Replace Strings - Allows you to do a simple permanent .replace on the classfile strings, very useful for URL swapping.</li>
    <li>Allatori String Decrypter - Decrypts the Allatori obfuscated/encrypted strings.</li>
    <li>ZKM String Decrypter - Decrypts the ZKM obfuscated/encrypted strings.</li>
    <li>ZStringArray String Decrypter - Decrypts the ZStringArray obfuscated/encrypted strings.</li>
</ul>

<h2>Code from various projects has been used, including but not limited to</h2>
<ul>
    <li>J-RET by WaterWolf</li>
    <li>JHexPane by Sam Koivu</li>
    <li>RSynaxPane by Robert Futrell</li>
    <li>Commons IO by Apache</li>
    <li>ASM by OW2</li>
    <li>FernFlower by Stiver</li>
    <li>Procyon by Mstrobel</li>
    <li>CFR by Lee Benfield</li>
    <li>CFIDE by Bibl</li>
    <li>Smali by JesusFreke</li>
    <li>Dex2Jar by pxb1988</li>
    <li>Krakatau by Storyyeller</li>
    <li>JD-GUI + JD-Core by The Java-Decompiler Team</li>
    <li>Enjarify by Storyyeller</li>
</ul>

<h2>Notes</h2>
<ul>
    <li>If BCV fails to boot simply append -clean as an argument to clean the lib directory.</li>
    <li>Relax and take notes</li>
    <li>BCV was created out of love for Java Reverse engineering.</li>
    <li>You can join our Discord server at <a href="https://discord.gg/aexsYpfMEf">https://discord.gg/aexsYpfMEf</a>!</li>
    <li>Bytecode Viewer's Homepage is <a href="https://bytecodeviewer.com">https://bytecodeviewer.com</a></li>
</ul>

</html>
```

`src/main/resources/translations/html/intro.german.html`:

```html
<html lang="de">
<h2>Über uns</h2>

Der Bytecode Viewer (BCV) wurde extrem benutzer- und einsteigerfreundlich gestaltet, deshalb ist fast alles
über eine Schnittstelle zugänglich, wie z.B. Einstellungen, Werkzeuge, etc.

<br><br>Um loszulegen einfach eine Jar/APK/Class-Datei in die Ressourcenliste ziehen.

<h2>Einstellungen</h2>
<ul>
    <li>Fat Jar: {fatJar}</li>
    <li>Java: {java}</li>
    <li>Javac: {javac}</li>
    <li>BCV Dir: {bcvDir}</li>
    <li>Python 2.7 (oder PyPy): {python}</li>
    <li>Python 3.X (oder PyPy): {python3}</li>
    <li>RT.jar: {rt}</li>
    <li>Optional Lib: {lib}</li>
    <li>BCV Krakatau: v{krakatauVersion}</li>
    <li>Krakatau Dir: {krakatauDir}</li>
    <li>BCV Enjarify: v{enjarifyVersion}</li>
    <li>Enjarify Dir: {enjarifyDir}</li>
</ul>

<h2>Kommandozeilen-Schnittstelle (CLI)</h2>
<ul>
    <li> -help Zeigt das Hilfemenü an</li>
    <li> -list Zeigt die verfügbaren Dekompilierer an</li>
    <li> -decompiler [decompiler] Wählt einen Decompiler aus, standardmäßig procyon</li>
    <li> -i [input file] Wählt die Eingabedatei aus (Jar, Class, APK, ZIP, DEX funktionieren alle automatisch)</li>
    <li> -o [Ausgabedatei] Wählt die Ausgabedatei aus (Java oder Java-Bytecode)</li>
    <li> -t [target classname] Muss entweder der voll qualifizierte Klassenname sein oder "all", um alle als zip zu dekompilieren</li>
    <li> -nowait Wartet nicht auf den Benutzer, um die CLI-Meldungen zu lesen</li>
</ul>

<h2>Datei</h2>
<ul>
    <li>Hinzufügen (Strg + O) - Wenn Sie ein jar/zip hinzufügen, wird BCV es entpacken, wenn Sie eine APK- oder DEX-Datei hinzufügen, führt BCV dex2jar
        und dann den Jar-Eingabeprozess aus.
    </li>
    <li>Neue Datei öffnen (Strg + L) - Öffnet die zuletzt geöffnete Datei erneut.</li>
    <li>Neuer Arbeitsbereich (Strg + N) - Löscht die geöffneten Jars/Ressourcen.</li>
    <li>Ausführen (Strg + R) - Führt die in BCV geladenen Klassendateien in einer sicheren, sandboxed und vollständig debugbaren JVM-Instanz aus.
    </li>
    <li>Kompilieren (Strg + T) - Versucht, alle bearbeitbaren Bereiche, die Sie ausgewählt haben, zu kompilieren. Wenn es sich um Java handelt, geschieht dies mit
        Ranino. Krakatau und *Smali verwenden ihre eigenen Assembler.
    </li>
    <li>Speichern als Jar - Exportiert die Klassendateien und geladenen Ressourcen als lauffähige Jar-Datei.</li>
    <li>Speichern als DEX - Führt jar2dex aus und exportiert die Klassendateien als DEX.</li>
    <li>Dateien speichern unter - Speichert alle Klassendateien und Ressourcen als Zip-Datei.</li>
    <li>Java-Datei speichern unter - Speichert die aktuell geöffnete dekompilierte Klassendatei.</li>
    <li>Java-Dateien speichern unter - Alle dekompilierten Klassendateien als Zip-Datei speichern.</li>
    <li>Aktuelle Dateien - Die letzten 25 Dateien/Verzeichnisse, die mit BCV geöffnet wurden.</li>
    <li>About - Ein kleines Informationsfenster über BCV.</li>
    <li>Beenden - Schließt BCV.</li>
</ul>

<h2>Ansichtsfenster</h2>
<ul>
    <li>Editierbar - Legt fest, ob das Sichtfenster editierbar ist.</li>
    <li>Keins - Es wird nichts angezeigt.</li>
    <li>Procyon - Dekompiliert mit dem Procyon-Decompiler.</li>
    <li>CFR - Dekompiliert mit dem CFR-Decompiler.</li>
    <li>FernFlower - Dekompiliert mit dem FernFlower-Decompiler.</li>
    <li>JD-GUI - Dekompiliert mit dem JD-GUI-Decompiler.</li>
    <li>Krakatau Java - Dekompiliert mit dem Krakatau Decompiler.</li>
    <li>Krakatau Bytecode - Disassembliert mit Krakatau Disassembler.</li>
    <li>Smali - Disassembliert mit Smali.</li>
    <li>Bytecode - Dekompiliert den Bytecode mit CFIDE. Nicht editierbar.</li>
    <li>Hexcode - Zeigt die Klassendatei in einem Hex-Viewer an. Nicht editierbar.</li>
</ul>

<h2>Einstellungen</h2>
<ul>
    <li>Beim Speichern kompilieren - Wenn diese Option aktiviert ist, wird bei jedem Aufruf einer der Funktionen Datei>Speichern * versucht, vor dem Speichern zu kompilieren.
    </li>
    <li>Beim Aktualisieren kompilieren - Wenn diese Option ausgewählt ist, wird bei jedem Aktualisieren kompiliert, bevor die Ressource/Klasse neu geladen wird.
    </li>
    <li>Aktualisierungsprüfung - Wenn ausgewählt, wird https://github.com/Konloch/bytecode-viewer abgefragt, um sicherzustellen, dass Sie die neueste Version haben.
    </li>
    <li>Auffrischen bei Ansichtsänderung - Wenn diese Option ausgewählt ist, werden bei jeder Änderung einer Option in den Ansichtsfenstern die
        aktuell geöffneten Ressourcen/Klasse aktualisiert.
    </li>
    <li>APK-Ressourcen dekodieren - Wenn diese Option ausgewählt ist, wird beim Hinzufügen einer APK zuerst APKTool.jar ausgeführt, um die Ressourcen zu dekodieren.
    </li>
    <li>Set Python 2.7 Executable - Setzen Sie das Python 2.7 Executable, wenn Sie möchten, dass Krakatau Decompiler/Disassembler/Assembler
        funktionieren soll.
    </li>
    <li>Set JRE RT Library - Stellen Sie die JRE RT Library für Krakatau Decompiler ein.</li>
</ul>

<h2>Plugins</h2>
<ul>
    <li>Plugin öffnen - Öffnen Sie ein für BCV erstelltes .java-Plugin.</li>
    <li>Zuletzt verwendete Plugins - Die letzten 25 Plugins, die Sie mit BCV geöffnet haben.</li>
    <li>Code-Ablaufdiagramm - Erstellt ein grobes Codefolgediagramm für die aktuell geöffnete Klassendatei.</li>
    <li>Scanner für bösartigen Code - Ermöglicht es Ihnen, zu definieren, wonach gesucht werden soll, und gibt aus, was gefunden wurde.</li>
    <li>Main-Methoden anzeigen - Erkennt und gibt alle öffentlichen statischen void main(String[]) Funktionen aus.</li>
    <li>Alle Strings anzeigen - Erkennt alle Zeichenketten in jeder Klassendatei und gibt sie aus.</li>
    <li>Strings ersetzen - Ermöglicht ein einfaches, permanentes Ersetzen der Strings in der Klassendatei. Sehr nützlich für URL-Swapping.</li>
    <li>Allatori-String-Decrypter - Entschlüsselt die mit Allatori verdeckten/verschlüsselten Strings.</li>
    <li>ZKM-String-Decrypter - Entschlüsselt die ZKM-verschleierten/verschlüsselten Strings.</li>
    <li>ZStringArray-String-Decrypter - Entschlüsselt die ZStringArray-verschleierten/verschlüsselten Strings.</li>
</ul>

<h2>Code aus verschiedenen Projekten wurde verwendet: Einschließlich, aber nicht beschränkt auf</h2>
<ul>
    <li>J-RET von WaterWolf</li>
    <li>JHexPane von Sam Koivu</li>
    <li>RSynaxPane von Robert Futrell</li>
    <li>Commons IO von Apache</li>
    <li>ASM von OW2</li>
    <li>FernFlower von Stiver</li>
    <li>Procyon von Mstrobel</li>
    <li>CFR von Lee Benfield</li>
    <li>CFIDE von Bibl</li>
    <li>Smali von JesusFreke</li>
    <li>Dex2Jar von pxb1988</li>
    <li>Krakatau von Storyyeller</li>
    <li>JD-GUI + JD-Core von The Java-Decompiler Team</li>
    <li>Enjarify von Storyyeller</li>
</ul>

<h2>Hinweise</h2>
<ul>
    <li>Wenn BCV nicht startet, fügen Sie einfach -clean als Argument an, um das lib-Verzeichnis zu bereinigen.</li>
    <li>Ruhen Sie sich aus und machen Sie sich Notizen</li>
    <li>BCV wurde aus Liebe zum Java Reverse Engineering entwickelt.</li>
    <li>Du kannst dem Discord-Server unter <a href="https://discord.gg/aexsYpfMEf">https://discord.gg/aexsYpfMEf</a> beitreten!</li>
    <li>Die Homepage von Bytecode Viewer ist unter <a href="https://bytecodeviewer.com">https://bytecodeviewer.com</a> zu finden.</li>
</ul>

</html>

```

`src/main/resources/translations/html/intro.mandarin.html`:

```html
<html lang="zh">
<h2>关于</h2>

Bytecode Viewer (BCV)被设计成对用户和初学者非常友好，因此，几乎所有的东西都可以通过界面、设置、工具等方式进行访问。

<br><br>将Jar/APK/Class文件拖到资源列表中。

<h2>设置</h2>
<ul>
    <li>Fat Jar: {fatJar}</li>
    <li>Java: {java}</li>
    <li>Javac: {javac}</li>
    <li>BCV 目录: {bcvDir}</li>
    <li>Python 2.7 (or PyPy): {python}</li>
    <li>Python 3.X (or PyPy): {python3}</li>
    <li>RT.jar: {rt}</li>
    <li>可选库: {lib}</li>
    <li>BCV Krakatau: {krakatauVersion}</li>
    <li>Krakatau 目录: {krakatauDir}</li>
    <li>BCV Enjarify: {enjarifyVersion}</li>
    <li>Enjarify 目录: {enjarifyDir}</li>
</ul>

<h2>命令行界面 (CLI)</h2>
<ul>
    <li> -帮助  显示帮助菜单</li>
    <li> -列表显示可用的反编译程序</li>
    <li> -反编译 [decompiler]选择反编译器，默认为procyon</li>
    <li> -i [input file] 选择输入文件 (Jar, Class, APK, ZIP, DEX all work automatically)</li>
    <li> -o [output file] 选择输出文件 (Java or Java-Bytecode)</li>
    <li> -t [target classname] 必须是完全合格的类名，或者是 "all "来反编译所有的zip</li>
    <li> -nowait 不要等待用户阅读命令行界面消息</li>
</ul>

<h2>文件</h2>
<ul>
    <li>Add (Ctrl + O) - I如果你添加了一个jar/zip，BCV将解压它，如果你添加了一个APK或DEX文件，BCV将运行dex2jar，然后运行jar输入进程。
    </li>
    <li>重新打开最近的文件(Ctrl + L) -重新打开最近打开的文件。</li>
    <li>新工作区域(Ctrl + N) -它清除打开的罐子/资源。</li>
    <li>运行(Ctrl + R) -在一个安全的沙盒JVM实例中运行您已经加载到BCV的类文件，您可以完全调试该实例。</li>
    <li>编译(Ctrl + T) -尝试编译您选择的所有可编辑面板，如果是Java，它将使用Ranino编译。Krakatau和*Smali使用自己的装配工。
    </li>
    <li>另存为Jar - 将类文件和加载的资源导出为可运行的Jar文件。</li>
    <li>另存为DEX - 运行jar2dex并将类文件导出为dex。</li>
    <li>将文件另存为 - 将所有的类文件和资源保存为zip文件。</li>
    <li>将 Java 文件另存为- 保存当前打开的反编译类文件。</li>
    <li>将 Java 文件另存为zip  - 将所有反编译的类文件保存为zip文件。</li>
    <li>最近打开的文件 - 你在BCV打开的最后25个文件/目录。</li>
    <li>关于 - 一个关于BCV的小信息窗口。</li>
    <li>退出 - 关闭BCV。</li>
</ul>

<h2>视图面板</h2>
<ul>
    <li>Editable - 预定义视图面板是否可编辑。</li>
    <li>无 - 不会显示任何内容。</li>
    <li>Procyon - 使用Procyon反编译程序反编译。</li>
    <li>CFR - 使用CFR反编译程序反编译。</li>
    <li>FernFlower - 使用FernFlower反编译程序反编译。</li>
    <li>JD-GUI - 使用JD-GUI反编译程序反编译.</li>
    <li>Krakatau Java - 用Krakatau反编译程序反编译。</li>
    <li>Krakatau Bytecode - 用Krakatau反汇编程序反汇编.</li>
    <li>Smali - 用 Smali反汇编</li>
    <li>字节码 - 通过CFIDE反编译字节码。不可编辑。</li>
    <li>十六进制代码 - 在十六进制查看器中显示类文件。不可编辑。</li>
</ul>

<h2>设置</h2>
<ul>
    <li>编译在保存 —— 如果您在执行File>Save *函数时被选中，它将在保存之前尝试编译。</li>
    <li>编译在刷新 —— 如果在按下refresh时选中，则在重新加载资源/类之前编译。</li>
    <li>检查更新 ——如果您选择了它，请查询https://github.com/Konloch/bytecode-viewer以确保您获得了最新的的版本。</li>
    <li>视图更改时刷新 —— 如果您在视图窗格中更改一个选项时选中，它将刷新当前打开的资源/类。</li>
    <li>解码的APK资源 —— 如果在添加APK时选中，它将首先运行APKTool.jar来解码资源。</li>
    <li>设置Python 2.7可执行文件 —— 如果你想要Krakatau反编译器/反汇编器/汇编器，请设置Python 2.7可执行文件去工作。</li>
    <li>设置JRE RT库 —— 设置Krakatau反编译器的JRE RT库。</li>
</ul>

<h2>插件</h2>
<ul>
    <li>打开插件 —— 打开为BCV创建的.java插件。</li>
    <li>最近的插件 —— 你用BCV打开的最后25个插件。</li>
    <li>代码程序表 —— 为当前打开的类文件构建一个原始的代码序列图。</li>
    <li>恶意代码扫描 —— 允许您定义要搜索的内容，并输出找到的内容。</li>
    <li>显示主要方法 —— 检测并输出所有的public static void main(String[])函数。</li>
    <li>显示所有字符串 —— 抓取然后输出每个类文件中的所有字符串。</li>
    <li>替换字符串 —— 允许您对类文件字符串执行简单的永久.replace操作，这对URL交换非常有用。</li>
    <li>Allatori 字符串解码器 —— 解密Allatori混淆/加密字符串。</li>
    <li>ZKM 字符串解码器 —— 解密ZKM混淆/加密字符串。</li>
    <li>ZStringArray字符串解码器 —— 解密ZStringArray混淆/加密字符串。</li>
</ul>

<h2>已使用来自不同项目的代码，包括但不限于</h2>
<ul>
    <li>J-RET作者WaterWolf</li>
    <li>JHexPane作者Sam Koivu</li>
    <li>RSynaxPane作者Robert Futrell</li>
    <li>Commons IO作者Apache</li>
    <li>ASM作者OW2</li>
    <li>FernFlower作者Stiver</li>
    <li>Procyon作者Mstrobel</li>
    <li>CFR作者Lee Benfield</li>
    <li>CFIDE作者 Bibl</li>
    <li>Smali作者JesusFreke</li>
    <li>Dex2Jar作者pxb1988</li>
    <li>Krakatau作者Storyyeller</li>
    <li>JJava-Decompiler团队的JD-GUI + JD-Core</li>
    <li>用Storyyeller的话来形容</li>
</ul>

<h2>笔记</h2>
<ul>
    <li>如果BCV无法启动，只需将-clean作为参数附加到lib目录中即可。</li>
    <li>放松并记笔记</li>
    <li>BCV是出于对Java逆向工程的热爱而创建的。</li>
    <li>你可以加入我们的Discord服务器 <a href="https://discord.gg/aexsYpfMEf">https://discord.gg/aexsYpfMEf</a>!</li>
    <li>Bytecode Viewer的主页是 <a href="https://bytecodeviewer.com">https://bytecodeviewer.com</a></li>
</ul>

</html>

```

`src/main/resources/translations/hungarian.json`:

```json
{
  "FILE": "Fájl",
  "ADD": "Add...",
  "NEW_WORKSPACE": "Új munkaterület",
  "RELOAD_RESOURCES": "Erőforrások újratöltése",
  "RUN": "Fuss",
  "OPEN": "Nyisd ki...",
  "OPEN_UNSTYLED": "Nyissa meg a címet.",
  "QUICK_OPEN": "Gyors nyitás",
  "DELETE": "Törlés",
  "NEW": "Új",
  "EXPAND": "Expand",
  "COLLAPSE": "Összeomlás",
  "COMPILE": "Compile",
  "SAVE_AS_RUNNABLE_JAR": "Save As Runnable Jar...",
  "SAVE_AS_ZIP": "Mentés zipként...",
  "SAVE_AS_DEX": "Mentés DEX-ként...",
  "SAVE_AS_APK": "Mentés APK-ként...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Megnyitott osztályok dekompilálása és mentése",
  "DECOMPILE_SAVE_ALL_CLASSES": "Minden osztály dekompilálása és mentése",
  "RECENT_FILES": "Legutóbbi fájlok",
  "ABOUT": "A oldalról",
  "EXIT": "Kilépés",

  "VIEW": "A megtekintése",
  "VISUAL_SETTINGS": "Vizuális beállítások",
  "PANE_1": "1. ablak",
  "PANE_2": "2. ablak",
  "PANE_3": "3. ablak",
  "NONE": "Nincs",
  "EDITABLE": "Szerkeszthető",

  "LANGUAGE": "Nyelv",
  "FONT_SIZE": "Betűméret",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Fájl megjelenítése a lap címében",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Név egyszerűsítése a lap címében",
  "SYNCHRONIZED_VIEWING": "Szinkronizált megtekintés",
  "SHOW_CLASS_METHODS": "Osztály metódusok megjelenítése",

  "WINDOW_THEME": "Ablak téma",
  "SYSTEM_THEME": "Rendszer téma",
  "DARK_THEME": "Sötét téma",
  "LIGHT_THEME": "Light téma",
  "ONE_DARK_THEME": "Egy sötét téma",
  "SOLARIZED_DARK_THEME": "Solarized sötét téma",
  "SOLARIZED_LIGHT_THEME": "Solarizált fény téma",
  "HIGH_CONTRAST_DARK_THEME": "Nagy kontrasztú sötét téma",
  "HIGH_CONTRAST_LIGHT_THEME": "Nagy kontrasztú Light téma",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Szolarizált sötét",
  "SOLARIZED_LIGHT": "Szolarizált fény",
  "HIGH_CONTRAST_DARK": "Nagy kontrasztú sötét",
  "HIGH_CONTRAST_LIGHT": "Nagy kontrasztú fény",
  "TEXT_AREA_THEME": "Szövegterület téma",
  "DEFAULT_RECOMMENDED_LIGHT": "Alapértelmezett (ajánlott fény)",
  "THEME_MATCH": "Tematikus mérkőzés (ajánlott)",
  "DARK": "Sötét (ajánlott sötét)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Napfogyatkozás",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druida (sötét)",
  "MONOKAI_DARK": "Monokai (sötét)",

  "SETTINGS": "Beállítások",
  "COMPILE_ON_SAVE": "Compile On Save",
  "COMPILE_ON_REFRESH": "Fordítás frissítéskor",
  "REFRESH_ON_VIEW_CHANGE": "Frissítés nézetváltáskor",
  "DECODE_APK_RESOURCES": "APK erőforrások dekódolása",
  "APK_CONVERSION": "APK átalakítás",
  "APK_CONVERSION_DECODING": "APK átalakítás",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Frissítés ellenőrzése",
  "DELETE_UNKNOWN_LIBS": "Külföldi törlése",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Python 2.7 futtatható beállítása",
  "SET_PYTHON_30_EXECUTABLE": "Python 3.X futtatható beállítása",
  "SET_JRE_RT_LIBRARY": "JRE RT könyvtár beállítása",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Opcionális könyvtármappa beállítása",
  "SET_JAVAC_EXECUTABLE": "Javac futtatható beállítása",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon beállítások",
  "CFR_SETTINGS": "CFR beállítások",
  "FERNFLOWER_SETTINGS": "FernFlower beállítások",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexkód",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode dekompiláló",
  "DEBUG_HELPERS": "Hibakeresési segédprogramok",
  "APPEND_BRACKETS_TO_LABEL": "Zárójelek hozzáadása a címkéhez",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Plugin megnyitása...",
  "RECENT_PLUGINS": "Legutóbbi bővítmények",
  "CODE_SEQUENCE_DIAGRAM": "Kódsorozat diagram",
  "MALICIOUS_CODE_SCANNER": "Rosszindulatú kód szkenner",
  "SHOW_MAIN_METHODS": "Fő módszerek megjelenítése",
  "SHOW_ALL_STRINGS": "Minden húr megjelenítése",
  "REPLACE_STRINGS": "Húrok cseréje",
  "STACK_FRAMES_REMOVER": "Stack Frames eltávolító",
  "ZKM_STRING_DECRYPTER": "ZKM string dekódoló",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray dekódoló",
  "VIEW_ANDROID_PERMISSIONS": "Android engedélyek megtekintése",
  "VIEW_MANIFEST": "Manifeszt megtekintése",
  "CHANGE_CLASSFILE_VERSIONS": "ClassFile verziók módosítása",



  "PROCYON_DECOMPILER": "Procyon dekompilátor",
  "CFR_DECOMPILER": "CFR dekompilátor",
  "FERNFLOWER_DECOMPILER": "FernFlower dekompilátor",
  "JADX_DECOMPILER": "JADX dekompilátor",
  "JD_DECOMPILER": "JD-GUI dekompilátor",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Hiba",
  "NEW_JAVA_PLUGIN": "Új Java Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "Új Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Javasolt javítás: Kattintson az osztály frissítésére, ha ismét nem sikerül, próbáljon meg egy másik dekompilátort.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Javasolt javítás: Próbálja ki a View>Pane>Krakatau>Bytecode és engedélyezze a szerkeszthetőséget.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "FIGYELMEZTETÉS: Jelenleg nincs dekompilátor kiválasztva. Próbálja meg a Nézet>Rács, és válasszon ki egy dekompilátort.",
  "COMPILER_TIP": "Ne feledje, hogy a legtöbb dekompilátor nem tud fordítható osztályokat előállítani.",
  "FIRST_OPEN_A_RESOURCE": "Először nyisson meg egy erőforrást a BCV-n belül (class, jar, zip vagy apk fájl).",
  "FIRST_OPEN_A_CLASS": "Először nyisson meg egy classfile erőforrást a BCV-ben (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Először tekintsünk meg egy osztályfájlt egy lapon belül.",
  "DRAG_CLASS_JAR": "Drag osztály",

  "YES": "Igen",
  "NO": "Nem",
  "ERROR2": "Hiba:",
  "PROCESS2": "Folyamat:",
  "EXIT_VALUE_IS": "A kilépési érték:",
  "JAVA_COMPILE_FAILED": "A Java fordítása sikertelen",
  "ERROR_COMPILING_CLASS": "Hiba az osztály fordításában",
  "COMPILER": "Ne feledje, hogy a legtöbb dekompilátor nem tud fordítható osztályokat előállítani.",
  "SELECT_LIBRARY_FOLDER": "Könyvtár mappa kiválasztása",
  "SELECT_JAVA_RT": "JRE RT Jar kiválasztása",
  "SELECT_JAVA": "Java futtatható kiválasztása",
  "SELECT_JAVAC": "Javac Végrehajtható kiválasztása",
  "SELECT_JAVA_TOOLS": "Java Tools Jar kiválasztása",
  "SELECT_PYTHON_2": "Python 2.7 futtatható program kiválasztása",
  "SELECT_PYTHON_3": "Python 3.x futtatható kiválasztása",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (vagy PyPy 2.7 a gyorsaság kedvéért) Végrehajtható",
  "PYTHON_3_EXECUTABLE": "Python 3.x (vagy PyPy 3.x a gyorsaság kedvéért) Végrehajtható",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Be kell állítanod a Python 2.7 (vagy PyPy 2.7 a gyorsaság érdekében) futtatható elérési útvonalát.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Be kell állítanod a Python 3.x (vagy PyPy 3.x a gyorsaság érdekében) futtatható elérési útvonalát.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Be kell állítania a JRE RT Library-t.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java futtatható (a JRE C-en belül:",
  "JAVAC_EXECUTABLE": "Javac futtatható (JDK C-t igényel:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (a JDK C-en belül:",
  "JAVA_RT_JAR": "Java RT Jar (a JRE C-en belül:",
  "OPTIONAL_LIBRARY_FOLDER": "Opcionális könyvtár mappa (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Híd módszerek elrejtése",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Szintetikus osztálytagok elrejtése",
  "DECOMPILE_INNER_CLASSES": "Belső osztályok dekompilálása",
  "COLLAPSE_14_CLASS_REFERENCES": "Összeomlás 1.4 osztályhivatkozások",
  "DECOMPILE_ASSERTIONS": "Állítások dekompilálása",
  "HIDE_EMPTY_SUPER_INVOCATION": "Üres szuperhívás elrejtése",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Üres alapértelmezett konstruktor elrejtése",
  "DECOMPILE_GENERIC_SIGNATURES": "Általános aláírások dekompilálása",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Feltételezzük, hogy a visszatérés nem dob kivételeket",
  "DECOMPILE_ENUMERATIONS": "A felsorolások dekompilálása",
  "REMOVE_GETCLASS_INVOCATION": "GetClass() hívás eltávolítása",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Az int 1 értelmezése boolean true-ként",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Engedélyezze a nem beállított szintetikus attribútumot",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Tekintsük a névtelen típusokat java.lang.Object-nek",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Változónevek rekonstruálása hibakeresési információból",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Üres kivételi tartományok eltávolítása",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline végül struktúrák",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Csak ASCII karakterek engedélyezése a karakterláncokban",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Többértelmű osztályok és osztályelemek átnevezése",

  "DECODE_ENUM_SWITCH": "Decode Enum kapcsoló",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dekódoló karakterlánc kapcsoló",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Belső osztályok",
  "REMOVE_BOILER_PLATE": "Kazánlemez eltávolítása",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Belső osztályú szintetikus anyagok eltávolítása",
  "DECODE_LAMBDAS": "Lambdák dekódolása",
  "LIFT__CONSTRUCTOR_INIT": "Lift konstruktor Init",
  "REMOVE_DEAD_METHODS": "Holt módszerek eltávolítása",
  "REMOVE_BAD_GENERICS": "Rossz generikumok eltávolítása",
  "SUGAR_ASSERTS": "Cukor állítja",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Mutasd a verziót",
  "DECODE_FINALLY": "Decode Finally",
  "TIDY_MONITORS": "Tidy monitorok",
  "LENIENT": "Engedékeny",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Megjegyzések",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggresszivitás",
  "FORCE_EXCEPTION_PRUNE": "Kényszer Kivétel Prune",
  "STRING_BUFFER": "String puffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Csendes",
  "RECOVER": "Visszaállítani",
  "OVERRIDE": "Felülbírálás",
  "SHOW_INFERRABLE": "Show Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Erő Cond Propagate",
  "HIDE_UTF": "UTF elrejtése",
  "HIDE_LONG_STRINGS": "Hosszú húrok elrejtése",
  "COMMENT_MONITORS": "Megjegyzés Monitorok",
  "ALLOW_CORRECTING": "Engedélyezze a korrekciót",
  "LABELLED_BLOCKS": "Címkézett blokkok",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang import",
  "RECOVER_TYPE_CLASH": "Típus összeütközés helyreállítása",
  "RECOVER_TYPE__HINTS": "Típus helyreállítása Tippek",
  "FORCE_RETURNING_IFS": "Visszatérő IF-ek kényszerítése",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG rögzítés",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Mindig generáljon kivételváltozót a Catch blokkokhoz",
  "EXCLUDE_NESTED_TYPES": "Beágyazott típusok kizárása",
  "SHOW_DEBUG_LINE_NUMBERS": "A hibakeresési sorszámok megjelenítése",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Sorszámok felvétele a bytecode-ba",
  "INCLUDE_ERROR_DIAGNOSTICS": "Hibadiagnosztika beépítése",
  "SHOW_SYNTHETIC_MEMBERS": "Szintetikus tagok megjelenítése",
  "SIMPLIFY_MEMBER_REFERENCES": "Tagi hivatkozások egyszerűsítése",
  "MERGE_VARIABLES": "Változók összevonása",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Explicit típusargumentumok kényszerítése",
  "FORCE_EXPLICIT_IMPORTS": "Explicit importálás kikényszerítése",
  "FLATTEN_SWITCH_BLOCKS": "Lapos kapcsolóblokkok",
  "RETAIN_POINTLESS_SWITCHES": "Értelmetlen kapcsolók megtartása",
  "RETAIN_REDUNDANT_CASTS": "A felesleges szereposztások megtartása",
  "UNICODE_OUTPUT_ENABLED": "Unicode kimenet engedélyezve",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Erőforrások újratöltése",
  "RELOAD_RESOURCES_CONFIRM": "Biztos, hogy újra kívánja tölteni az erőforrásokat?",
  "SELECT_FILE_TITLE": "Válassza ki a Fájl vagy mappa megnyitását {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, Class Files vagy Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Külső bővítmény kiválasztása",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV külső plugin js, java, python, ruby vagy groovy nyelven",
  "FOREIGN_LIBRARY_WARNING": "FIGYELMEZTETÉS: Ha ez ki van kapcsolva, az elavult könyvtárak NEM lesznek eltávolítva.\n\rEz egyúttal biztonsági kérdés is.\n\rCSAK AKKOR KAPCSOLJA KI, HA TUDJA, MIT CSINÁL.",
  "RESET_TITLE": "{PRODUCT_NAME} - Munkatér visszaállítása",
  "RESET_CONFIRM": "Biztos, hogy vissza akarja állítani a munkaterületet?\n\rEz a fájlnavigátort és a keresést is visszaállítja.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Kilépés",
  "EXIT_CONFIRM": "Biztos, hogy ki akarsz lépni?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Névjegy - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin konzol",
  "CLOSE_ALL_BUT_THIS": "Mindent bezárni, kivéve ezt",
  "CLOSE_TAB": "Bezárja a lapot",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Kérjük, küldje el ezt a hibanaplót a következő címre",
  "PLEASE_SEND_RESOURCES": "Ha az adott osztályra vonatkozóan megfelelő jogi jogosultsággal rendelkezik",
  "ONE_PLUGIN_AT_A_TIME": "Jelenleg egy másik plugin fut, kérjük, várd meg, amíg az befejezi a futtatást.",
  "ILLEGAL_ACCESS_ERROR": "Ehhez kérjük, használja a Java 15-ös vagy annál régebbi változatát.",


  "FILES": "Fájlok",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Gyors fájlkeresés (fájlkiterjesztés nélkül)",
  "WORK_SPACE": "Munkaterület",
  "EXACT": "Exact",
  "SEARCH": "Keresés",
  "SEARCH_FROM": "Keresés a következő címen:",
  "SEARCH_STRING": "Keresési karakterlánc:",
  "SEARCH_REGEX": "Keresés Regex:",
  "OWNER": "Tulajdonos:",
  "NAME": "Név:",
  "DESC": "Desc:",
  "SAVE": "Mentsd...",
  "SAVE_AS": "Mentés másként...",
  "RESULTS": "Eredmények",
  "REFRESH": "Frissítés",
  "ANNOTATION_NAME": "Megjegyzések neve",
  "MATCH_CASE": "Gyufa eset",
  "EXACT_PATH": "Pontos útvonal",
  "MIN_SDK_VERSION": "Minimális SDK verzió",
  "PRINT_LINE_NUMBERS": "Sorszámok nyomtatása"
}

```

`src/main/resources/translations/indonesian.json`:

```json
{
  "FILE": "Mengajukan",
  "ADD": "Menambahkan...",
  "NEW_WORKSPACE": "Ruang Kerja Baru",
  "RELOAD_RESOURCES": "Muat Ulang Sumber Daya",
  "RUN": "Lari",
  "OPEN": "Buka...",
  "OPEN_UNSTYLED": "Membuka",
  "QUICK_OPEN": "Buka Cepat",
  "DELETE": "Menghapus",
  "NEW": "Baru",
  "EXPAND": "Mengembangkan",
  "COLLAPSE": "Runtuh",
  "COMPILE": "Menyusun",
  "SAVE_AS_RUNNABLE_JAR": "Simpan Sebagai Jar yang Dapat Dijalankan...",
  "SAVE_AS_ZIP": "Simpan Sebagai Zip...",
  "SAVE_AS_DEX": "Simpan Sebagai DEX...",
  "SAVE_AS_APK": "Simpan Sebagai APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompilasi & Simpan Kelas yang Dibuka",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompilasi & Simpan Semua Kelas",
  "RECENT_FILES": "File Terbaru",
  "ABOUT": "Tentang",
  "EXIT": "keluar",

  "VIEW": "Melihat",
  "VISUAL_SETTINGS": "Pengaturan Visual",
  "PANE_1": "Panel 1",
  "PANE_2": "Panel 2",
  "PANE_3": "Panel 3",
  "NONE": "Tidak ada",
  "EDITABLE": "Dapat diedit",

  "LANGUAGE": "Bahasa",
  "FONT_SIZE": "Ukuran huruf",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Tampilkan File Dalam Judul Tab",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Sederhanakan Nama Di Judul Tab",
  "SYNCHRONIZED_VIEWING": "Tampilan Tersinkronisasi",
  "SHOW_CLASS_METHODS": "Tampilkan Metode Kelas",

  "WINDOW_THEME": "Tema Jendela",
  "SYSTEM_THEME": "Tema Sistem",
  "DARK_THEME": "Tema gelap",
  "LIGHT_THEME": "Tema Cahaya",
  "ONE_DARK_THEME": "Satu Tema Gelap",
  "SOLARIZED_DARK_THEME": "Tema Gelap Solarized",
  "SOLARIZED_LIGHT_THEME": "Tema Cahaya Solarisasi",
  "HIGH_CONTRAST_DARK_THEME": "Tema Gelap Kontras Tinggi",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema Cahaya Kontras Tinggi",
  "ONE_DARK": "Satu Gelap",
  "SOLARIZED_DARK": "Solarisasi Gelap",
  "SOLARIZED_LIGHT": "Cahaya Solarisasi",
  "HIGH_CONTRAST_DARK": "Kontras Tinggi Gelap",
  "HIGH_CONTRAST_LIGHT": "Cahaya Kontras Tinggi",
  "TEXT_AREA_THEME": "Tema Area Teks",
  "DEFAULT_RECOMMENDED_LIGHT": "Default (Cahaya yang Direkomendasikan)",
  "THEME_MATCH": "Pencocokan Tema (Disarankan)",
  "DARK": "Gelap (Direkomendasikan Gelap)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Gerhana",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Studio visual",
  "DRUID_DARK": "Druid (Gelap)",
  "MONOKAI_DARK": "Monokai (Gelap)",

  "SETTINGS": "Pengaturan",
  "COMPILE_ON_SAVE": "Kompilasi Di Simpan",
  "COMPILE_ON_REFRESH": "Kompilasi Saat Segarkan",
  "REFRESH_ON_VIEW_CHANGE": "Segarkan Saat Lihat Perubahan",
  "DECODE_APK_RESOURCES": "Decode Sumber Daya APK",
  "APK_CONVERSION": "Konversi APK",
  "APK_CONVERSION_DECODING": "Konversi/Dekode APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Perbarui Periksa",
  "DELETE_UNKNOWN_LIBS": "Hapus Lib Asing/Kedaluwarsa",
  "FORCE_PURE_ASCII_AS_TEXT": "Paksa Ascii Murni Sebagai Teks",
  "SET_PYTHON_27_EXECUTABLE": "Setel Python 2.7 Dapat Dieksekusi",
  "SET_PYTHON_30_EXECUTABLE": "Setel Python 3.X Dapat Dieksekusi",
  "SET_JRE_RT_LIBRARY": "Setel Perpustakaan JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Setel Folder Perpustakaan Opsional",
  "SET_JAVAC_EXECUTABLE": "Setel Javac yang Dapat Dieksekusi",

  "JAVA": "Jawa",
  "PROCYON_SETTINGS": "Pengaturan Procyon",
  "CFR_SETTINGS": "Pengaturan CFR",
  "FERNFLOWER_SETTINGS": "Pengaturan Bunga Pakis",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "PakisBunga",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali/Dex",
  "HEXCODE": "Kode heksadesimal",
  "BYTECODE": "Kode byte",
  "ASM_TEXTIFY": "Teks ASM",

  "BYTECODE_DECOMPILER": "Dekompiler Bytecode",
  "DEBUG_HELPERS": "Pembantu Debug",
  "APPEND_BRACKETS_TO_LABEL": "Tambahkan Kurung Ke Label",

  "PLUGINS": "Plugin",
  "OPEN_PLUGIN": "Buka Plugin...",
  "RECENT_PLUGINS": "Plugin Terbaru",
  "CODE_SEQUENCE_DIAGRAM": "Diagram Urutan Kode",
  "MALICIOUS_CODE_SCANNER": "Pemindai Kode Berbahaya",
  "SHOW_MAIN_METHODS": "Tampilkan Metode Utama",
  "SHOW_ALL_STRINGS": "Tampilkan Semua String",
  "REPLACE_STRINGS": "Ganti String",
  "STACK_FRAMES_REMOVER": "Penghapus Bingkai Tumpukan",
  "ZKM_STRING_DECRYPTER": "Dekripsi String ZKM",
  "ALLATORI_STRING_DECRYPTER": "Dekripsi String Allatori",
  "ZSTRINGARRAY_DECRYPTER": "Dekripsi ZStringArray",
  "VIEW_ANDROID_PERMISSIONS": "Lihat Izin Android",
  "VIEW_MANIFEST": "Lihat Manifes",
  "CHANGE_CLASSFILE_VERSIONS": "Ubah Versi ClassFile",



  "PROCYON_DECOMPILER": "Dekompiler Procyon",
  "CFR_DECOMPILER": "Dekompiler CFR",
  "FERNFLOWER_DECOMPILER": "Dekompiler FernFlower",
  "JADX_DECOMPILER": "Dekompiler JADX",
  "JD_DECOMPILER": "Dekompiler JD-GUI",
  "BYTECODE_DISASSEMBLER": "Pembongkaran Bytecode",
  "DISASSEMBLER": "Pembongkaran",

  "ERROR": "Kesalahan",
  "NEW_JAVA_PLUGIN": "Plugin Java Baru",
  "NEW_JAVASCRIPT_PLUGIN": "Plugin Javascript baru",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Perbaikan yang Disarankan: Klik refresh class, jika gagal lagi coba decompiler lain.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Perbaikan yang Disarankan: Coba Lihat>Pane>Krakatau>Bytecode dan aktifkan Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "PERINGATAN: Saat ini tidak ada dekompiler yang dipilih. Coba View>Pane dan pilih decompiler.",
  "COMPILER_TIP": "Ingatlah bahwa sebagian besar dekompiler tidak dapat menghasilkan kelas yang dapat dikompilasi",
  "FIRST_OPEN_A_RESOURCE": "Pertama buka sumber daya di dalam BCV (kelas, jar, zip atau file apk)",
  "FIRST_OPEN_A_CLASS": "Pertama buka sumber daya classfile di dalam BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Pertama lihat file kelas di dalam tab.",
  "DRAG_CLASS_JAR": "Seret kelas/jar/zip/APK/DEX di sini",

  "YES": "Iya",
  "NO": "Tidak",
  "ERROR2": "Kesalahan:",
  "PROCESS2": "Proses:",
  "EXIT_VALUE_IS": "Nilai Keluar adalah:",
  "JAVA_COMPILE_FAILED": "Kompilasi Java Gagal",
  "ERROR_COMPILING_CLASS": "Kesalahan saat mengkompilasi kelas",
  "COMPILER": "Ingatlah bahwa sebagian besar dekompiler tidak dapat menghasilkan kelas yang dapat dikompilasi",
  "SELECT_LIBRARY_FOLDER": "Pilih Folder Perpustakaan",
  "SELECT_JAVA_RT": "Pilih JRE RT Jar",
  "SELECT_JAVA": "Pilih Java yang Dapat Dieksekusi",
  "SELECT_JAVAC": "Pilih Javac yang Dapat Dieksekusi",
  "SELECT_JAVA_TOOLS": "Pilih Jar Alat Java",
  "SELECT_PYTHON_2": "Pilih Python 2.7 yang Dapat Dieksekusi",
  "SELECT_PYTHON_3": "Pilih Python 3.x Dapat Dieksekusi",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Atau PyPy 2.7 untuk kecepatan) Dapat dieksekusi",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Atau PyPy 3.x untuk kecepatan) Dapat dieksekusi",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Anda perlu mengatur jalur eksekusi Python 2.7 (atau PyPy 2.7 untuk kecepatan).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Anda perlu mengatur jalur eksekusi Python 3.x (atau PyPy 3.x untuk kecepatan).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Anda perlu mengatur Perpustakaan JRE RT Anda.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Dapat Dieksekusi (Di Dalam JRE C:/Program Files/Java/JRE_xx/bin/java.exe)",
  "JAVAC_EXECUTABLE": "Javac Dapat Dieksekusi (Memerlukan JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Jar Alat Java (Di Dalam JDK C:/Program Files/Java/JDK_xx/lib/tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Di Dalam JRE C:/Program Files/Java/JRE_xx/lib/rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Folder Perpustakaan Opsional (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Sembunyikan metode jembatan",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Sembunyikan anggota kelas sintetis",
  "DECOMPILE_INNER_CLASSES": "Dekompilasi kelas dalam",
  "COLLAPSE_14_CLASS_REFERENCES": "Ciutkan 1.4 referensi kelas",
  "DECOMPILE_ASSERTIONS": "Dekompilasi pernyataan",
  "HIDE_EMPTY_SUPER_INVOCATION": "Sembunyikan doa super kosong",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Sembunyikan konstruktor default kosong",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompilasi tanda tangan generik",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Asumsikan pengembalian tidak melempar pengecualian",
  "DECOMPILE_ENUMERATIONS": "Dekompilasi enumerasi",
  "REMOVE_GETCLASS_INVOCATION": "Hapus pemanggilan getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Tafsirkan int 1 sebagai boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Izinkan untuk tidak menyetel atribut sintetis",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Pertimbangkan tipe tanpa nama sebagai java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonstruksi nama variabel dari info debug",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Hapus rentang pengecualian kosong",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline akhirnya struktur",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Izinkan hanya karakter ASCII dalam string",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Ganti nama kelas dan elemen kelas yang ambigu",

  "DECODE_ENUM_SWITCH": "Dekode Enum Beralih",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dekode String Switch",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Pengumpul",
  "INNER_CLASSES": "Kelas Dalam",
  "REMOVE_BOILER_PLATE": "Lepaskan Pelat Boiler",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Hapus Sintetis Kelas Dalam",
  "DECODE_LAMBDAS": "Dekode Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Angkat Konstruktor Init",
  "REMOVE_DEAD_METHODS": "Hapus Metode Mati",
  "REMOVE_BAD_GENERICS": "Hapus Generik Buruk",
  "SUGAR_ASSERTS": "Gula Asersi",
  "SUGAR_BOXING": "tinju gula",
  "SHOW_VERSION": "Tampilkan Versi",
  "DECODE_FINALLY": "Dekode Akhirnya",
  "TIDY_MONITORS": "Monitor Rapi",
  "LENIENT": "Lunak",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Komentar",
  "FORCE_TOP_SORT": "Paksa Urutan Atas",
  "FORCE_TOP_SORT_AGGRESS": "Paksa Agresi Urutan Teratas",
  "FORCE_EXCEPTION_PRUNE": "Pangkas Pengecualian Paksa",
  "STRING_BUFFER": "Penyangga Tali",
  "STRING_BUILDER": "Pembuat Tali",
  "SILENT": "Diam",
  "RECOVER": "Memulihkan",
  "OVERRIDE": "Mengesampingkan",
  "SHOW_INFERRABLE": "Tampilkan Inferrable",
  "AEXAGG": "aexagg",
  "FORCE_COND_PROPAGATE": "Memaksa Cond Menyebarkan",
  "HIDE_UTF": "Sembunyikan UTF",
  "HIDE_LONG_STRINGS": "Sembunyikan String Panjang",
  "COMMENT_MONITORS": "Monitor Komentar",
  "ALLOW_CORRECTING": "Izinkan Koreksi",
  "LABELLED_BLOCKS": "Blok berlabel",
  "J14CLASSOBJ": "J14KelasOBJ",
  "HIDE_LANG_IMPORTS": "Sembunyikan Lang Impor",
  "RECOVER_TYPE_CLASH": "Pulihkan Jenis Bentrokan",
  "RECOVER_TYPE__HINTS": "Petunjuk Jenis Pulihkan",
  "FORCE_RETURNING_IFS": "Paksa Pengembalian JIKA",
  "FOR_LOOP_AGG_CAPTURE": "Untuk Pengambilan AGG Loop",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Selalu Hasilkan Variabel Pengecualian Untuk Blok Tangkap",
  "EXCLUDE_NESTED_TYPES": "Kecualikan Jenis Bersarang",
  "SHOW_DEBUG_LINE_NUMBERS": "Tampilkan Nomor Baris Debug",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Sertakan Nomor Baris Dalam Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Sertakan Diagnostik Kesalahan",
  "SHOW_SYNTHETIC_MEMBERS": "Tampilkan Anggota Sintetis",
  "SIMPLIFY_MEMBER_REFERENCES": "Sederhanakan Referensi Anggota",
  "MERGE_VARIABLES": "Gabungkan Variabel",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Paksa Argumen Tipe Eksplisit",
  "FORCE_EXPLICIT_IMPORTS": "Paksa Impor Eksplisit",
  "FLATTEN_SWITCH_BLOCKS": "Ratakan Blok Saklar",
  "RETAIN_POINTLESS_SWITCHES": "Pertahankan Sakelar Tak Berguna",
  "RETAIN_REDUNDANT_CASTS": "Pertahankan Pemeran yang Berlebihan",
  "UNICODE_OUTPUT_ENABLED": "Output Unicode Diaktifkan",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Muat Ulang Sumber Daya",
  "RELOAD_RESOURCES_CONFIRM": "Apakah Anda yakin ingin memuat ulang sumber daya?",
  "SELECT_FILE_TITLE": "Pilih File atau Folder untuk dibuka di {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, File Kelas, atau Arsip Zip/Jar/Perang",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Pilih Plugin Eksternal",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Plugin Eksternal BCV di js, java, python, ruby ​​atau groovy",
  "FOREIGN_LIBRARY_WARNING": "PERINGATAN: Dengan ini dimatikan, perpustakaan usang TIDAK akan dihapus.\n\rIni juga masalah keamanan.\n\rHANYA MATIKAN JIKA ANDA TAHU APA YANG ANDA LAKUKAN.",
  "RESET_TITLE": "{PRODUCT_NAME} - Setel Ulang Ruang Kerja",
  "RESET_CONFIRM": "Anda yakin ingin menyetel ulang ruang kerja?\n\rIni juga akan mengatur ulang navigator dan pencarian file Anda.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Keluar",
  "EXIT_CONFIRM": "Anda yakin ingin keluar?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Tentang - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Konsol Plugin",
  "CLOSE_ALL_BUT_THIS": "Tutup Semua Tapi Ini",
  "CLOSE_TAB": "Tutup Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Silakan kirim log kesalahan ini ke",
  "PLEASE_SEND_RESOURCES": "Jika Anda memegang hak hukum yang sesuai untuk file class/jar/apk yang relevan, harap sertakan juga.",
  "ONE_PLUGIN_AT_A_TIME": "Saat ini ada plugin lain yang berjalan sekarang, harap tunggu sampai selesai dieksekusi.",
  "ILLEGAL_ACCESS_ERROR": "Silakan gunakan Java 15 atau lebih lama untuk melakukan ini.",


  "FILES": "File",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Pencarian file cepat (tanpa ekstensi file)",
  "WORK_SPACE": "Ruang Kerja",
  "EXACT": "Tepat",
  "SEARCH": "Cari",
  "SEARCH_FROM": "Cari Dari:",
  "SEARCH_STRING": "String Pencarian:",
  "SEARCH_REGEX": "Pencarian Regex:",
  "OWNER": "Pemilik:",
  "NAME": "Nama:",
  "DESC": "Desc:",
  "SAVE": "Menyimpan...",
  "SAVE_AS": "Simpan Sebagai...",
  "RESULTS": "Hasil",
  "REFRESH": "Menyegarkan",
  "ANNOTATION_NAME": "Nama Anotasi",
  "MATCH_CASE": "Kasus Pertandingan",
  "EXACT_PATH": "Jalur Tepat",
  "MIN_SDK_VERSION": "Versi SDK minimum",
  "PRINT_LINE_NUMBERS": "Cetak Nomor Baris"
}

```

`src/main/resources/translations/italian.json`:

```json
{
  "FILE": "File",
  "ADD": "Aggiungere...",
  "NEW_WORKSPACE": "Nuovo spazio di lavoro",
  "RELOAD_RESOURCES": "Ricaricare le risorse",
  "RUN": "Esegui",
  "OPEN": "Aprire...",
  "OPEN_UNSTYLED": "Aprire",
  "QUICK_OPEN": "Apertura rapida",
  "DELETE": "Cancellare",
  "NEW": "Nuovo",
  "EXPAND": "Espandi",
  "COLLAPSE": "Crollo",
  "COMPILE": "Compilare",
  "SAVE_AS_RUNNABLE_JAR": "Salva come vaso eseguibile...",
  "SAVE_AS_ZIP": "Salva come Zip...",
  "SAVE_AS_DEX": "Salva come DEX...",
  "SAVE_AS_APK": "Salva come APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Decompilare e salvare le classi aperte",
  "DECOMPILE_SAVE_ALL_CLASSES": "Decompilare e salvare tutte le classi",
  "RECENT_FILES": "File recenti",
  "ABOUT": "Informazioni su",
  "EXIT": "Uscita",

  "VIEW": "Vedi",
  "VISUAL_SETTINGS": "Impostazioni visive",
  "PANE_1": "Riquadro 1",
  "PANE_2": "Riquadro 2",
  "PANE_3": "Riquadro 3",
  "NONE": "Nessuno",
  "EDITABLE": "Modificabile",

  "LANGUAGE": "Lingua",
  "FONT_SIZE": "Dimensione del carattere",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Mostra il file nel titolo della scheda",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Semplificare il nome nel titolo della scheda",
  "SYNCHRONIZED_VIEWING": "Visualizzazione sincronizzata",
  "SHOW_CLASS_METHODS": "Mostra i metodi della classe",

  "WINDOW_THEME": "Tema della finestra",
  "SYSTEM_THEME": "Tema del sistema",
  "DARK_THEME": "Tema scuro",
  "LIGHT_THEME": "Tema della luce",
  "ONE_DARK_THEME": "Un tema scuro",
  "SOLARIZED_DARK_THEME": "Tema scuro solarizzato",
  "SOLARIZED_LIGHT_THEME": "Tema Luce Solarizzata",
  "HIGH_CONTRAST_DARK_THEME": "Tema scuro ad alto contrasto",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema luminoso ad alto contrasto",
  "ONE_DARK": "Uno scuro",
  "SOLARIZED_DARK": "Scuro solarizzato",
  "SOLARIZED_LIGHT": "Luce solarizzata",
  "HIGH_CONTRAST_DARK": "Alto contrasto scuro",
  "HIGH_CONTRAST_LIGHT": "Luce ad alto contrasto",
  "TEXT_AREA_THEME": "Tema dell'area di testo",
  "DEFAULT_RECOMMENDED_LIGHT": "Default (luce raccomandata)",
  "THEME_MATCH": "Partita a tema (raccomandata)",
  "DARK": "Scuro (raccomandato scuro)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Studio visivo",
  "DRUID_DARK": "Druido (Oscuro)",
  "MONOKAI_DARK": "Monokai (scuro)",

  "SETTINGS": "Impostazioni",
  "COMPILE_ON_SAVE": "Compilare al salvataggio",
  "COMPILE_ON_REFRESH": "Compilazione su aggiornamento",
  "REFRESH_ON_VIEW_CHANGE": "Aggiorna al cambio di vista",
  "DECODE_APK_RESOURCES": "Decodifica risorse APK",
  "APK_CONVERSION": "Conversione APK",
  "APK_CONVERSION_DECODING": "Conversione APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Controllo dell'aggiornamento",
  "DELETE_UNKNOWN_LIBS": "Cancellare l'estero",
  "FORCE_PURE_ASCII_AS_TEXT": "Forza Ascii puro come testo",
  "SET_PYTHON_27_EXECUTABLE": "Impostare Python 2.7 eseguibile",
  "SET_PYTHON_30_EXECUTABLE": "Impostare Python 3.X eseguibile",
  "SET_JRE_RT_LIBRARY": "Impostare la libreria JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Imposta cartella della libreria opzionale",
  "SET_JAVAC_EXECUTABLE": "Imposta eseguibile Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Impostazioni Procyon",
  "CFR_SETTINGS": "Impostazioni CFR",
  "FERNFLOWER_SETTINGS": "Impostazioni di FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Decompilatore di bytecode",
  "DEBUG_HELPERS": "Aiuti per il debug",
  "APPEND_BRACKETS_TO_LABEL": "Aggiungere parentesi all'etichetta",

  "PLUGINS": "Plugin",
  "OPEN_PLUGIN": "Aprire Plugin...",
  "RECENT_PLUGINS": "Plugin recenti",
  "CODE_SEQUENCE_DIAGRAM": "Diagramma di sequenza del codice",
  "MALICIOUS_CODE_SCANNER": "Scanner di codici maligni",
  "SHOW_MAIN_METHODS": "Mostra i metodi principali",
  "SHOW_ALL_STRINGS": "Mostra tutte le stringhe",
  "REPLACE_STRINGS": "Sostituire le stringhe",
  "STACK_FRAMES_REMOVER": "Stack Frames Remover",
  "ZKM_STRING_DECRYPTER": "Decrittatore di stringhe ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Visualizza i permessi di Android",
  "VIEW_MANIFEST": "Visualizza manifesto",
  "CHANGE_CLASSFILE_VERSIONS": "Cambiare le versioni dei file di classe",



  "PROCYON_DECOMPILER": "Decompilatore Procyon",
  "CFR_DECOMPILER": "Decompilatore CFR",
  "FERNFLOWER_DECOMPILER": "Decompilatore FernFlower",
  "JADX_DECOMPILER": "Decompilatore JADX",
  "JD_DECOMPILER": "Decompilatore JD-GUI",
  "BYTECODE_DISASSEMBLER": "Disassemblatore di bytecode",
  "DISASSEMBLER": "Disassemblatore",

  "ERROR": "Errore",
  "NEW_JAVA_PLUGIN": "Nuovo plugin Java",
  "NEW_JAVASCRIPT_PLUGIN": "Nuovo plugin Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Correzione suggerita: Fare clic su aggiorna classe, se non riesce di nuovo prova un altro decompilatore.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Correzione suggerita: provare View>Pane>Krakatau>Bytecode e abilitare Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ATTENZIONE: Nessun decompilatore è attualmente selezionato. Prova View>Pane e scegli un decompilatore.",
  "COMPILER_TIP": "Tenete presente che la maggior parte dei decompilatori non può produrre classi compilabili",
  "FIRST_OPEN_A_RESOURCE": "Prima apri una risorsa all'interno di BCV (classe, jar, zip o file apk)",
  "FIRST_OPEN_A_CLASS": "Prima apri una risorsa classfile dentro BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Per prima cosa visualizzate un file di classe all'interno di una scheda.",
  "DRAG_CLASS_JAR": "Classe di trascinamento",

  "YES": "Sì",
  "NO": "No",
  "ERROR2": "Errore:",
  "PROCESS2": "Processo:",
  "EXIT_VALUE_IS": "Il valore di uscita è:",
  "JAVA_COMPILE_FAILED": "Compilazione Java fallita",
  "ERROR_COMPILING_CLASS": "Errore nella compilazione della classe",
  "COMPILER": "Tenete presente che la maggior parte dei decompilatori non può produrre classi compilabili",
  "SELECT_LIBRARY_FOLDER": "Seleziona la cartella della libreria",
  "SELECT_JAVA_RT": "Selezionare JRE RT Jar",
  "SELECT_JAVA": "Seleziona l'eseguibile Java",
  "SELECT_JAVAC": "Selezionare l'eseguibile Javac",
  "SELECT_JAVA_TOOLS": "Selezionare Java Tools Jar",
  "SELECT_PYTHON_2": "Selezionare l'eseguibile di Python 2.7",
  "SELECT_PYTHON_3": "Selezionare l'eseguibile di Python 3.x",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (o PyPy 2.7 per la velocità) Eseguibile",
  "PYTHON_3_EXECUTABLE": "Python 3.x (o PyPy 3.x per la velocità) Eseguibile",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "È necessario impostare il percorso dell'eseguibile di Python 2.7 (o PyPy 2.7 per la velocità).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "È necessario impostare il percorso dell'eseguibile di Python 3.x (o PyPy 3.x per la velocità).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "È necessario impostare la libreria JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\File di programma\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Eseguibile Java (all'interno di JRE C:",
  "JAVAC_EXECUTABLE": "Javac eseguibile (richiede JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (all'interno di JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (all'interno di JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Cartella della libreria opzionale (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Nascondere i metodi del ponte",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Nascondere i membri sintetici della classe",
  "DECOMPILE_INNER_CLASSES": "Decompilare le classi interne",
  "COLLAPSE_14_CLASS_REFERENCES": "Crollo 1.4 riferimenti di classe",
  "DECOMPILE_ASSERTIONS": "Decompilare le asserzioni",
  "HIDE_EMPTY_SUPER_INVOCATION": "Nascondere la super invocazione vuota",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Nascondere il costruttore predefinito vuoto",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompilare le firme generiche",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Supponiamo che il ritorno non lanci eccezioni",
  "DECOMPILE_ENUMERATIONS": "Decompilare le enumerazioni",
  "REMOVE_GETCLASS_INVOCATION": "Rimuovere l'invocazione getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretare int 1 come booleano vero",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Permettere di non impostare l'attributo sintetico",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Considerare i tipi senza nome come java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Ricostruire i nomi delle variabili dalle informazioni di debug",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Rimuovere gli intervalli di eccezione vuoti",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline infine le strutture",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Permettere solo caratteri ASCII nelle stringhe",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Rinominare classi ed elementi di classe ambigui",

  "DECODE_ENUM_SWITCH": "Decodificare l'interruttore Enum",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Interruttore di decodifica delle stringhe",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Classi interne",
  "REMOVE_BOILER_PLATE": "Rimuovere la piastra della caldaia",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Rimuovere i sintetici di classe interna",
  "DECODE_LAMBDAS": "Decodificare i lambda",
  "LIFT__CONSTRUCTOR_INIT": "Ascensore costruttore Init",
  "REMOVE_DEAD_METHODS": "Rimuovere i metodi morti",
  "REMOVE_BAD_GENERICS": "Rimuovere i cattivi generici",
  "SUGAR_ASSERTS": "Zucchero asserisce",
  "SUGAR_BOXING": "Boxe dello zucchero",
  "SHOW_VERSION": "Mostra la versione",
  "DECODE_FINALLY": "Decodificare finalmente",
  "TIDY_MONITORS": "Monitor ordinati",
  "LENIENT": "Indulgente",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Commenti",
  "FORCE_TOP_SORT": "Forza l'ordinamento superiore",
  "FORCE_TOP_SORT_AGGRESS": "Forzare l'ordine superiore aggredire",
  "FORCE_EXCEPTION_PRUNE": "Forzare la potatura delle eccezioni",
  "STRING_BUFFER": "Buffer di stringhe",
  "STRING_BUILDER": "Costruttore di stringhe",
  "SILENT": "Silent",
  "RECOVER": "Recupera",
  "OVERRIDE": "Sovrascrivere",
  "SHOW_INFERRABLE": "Mostra Inferibile",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Forza Cond Propagare",
  "HIDE_UTF": "Nascondi UTF",
  "HIDE_LONG_STRINGS": "Nascondere le stringhe lunghe",
  "COMMENT_MONITORS": "Monitoraggio dei commenti",
  "ALLOW_CORRECTING": "Consentire la correzione",
  "LABELLED_BLOCKS": "Blocchi etichettati",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Nascondi Lang Imports",
  "RECOVER_TYPE_CLASH": "Recuperare il tipo di scontro",
  "RECOVER_TYPE__HINTS": "Recuperare suggerimenti sul tipo",
  "FORCE_RETURNING_IFS": "Forzare il ritorno degli IF",
  "FOR_LOOP_AGG_CAPTURE": "Per il ciclo AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Generare sempre la variabile Exception per i blocchi Catch",
  "EXCLUDE_NESTED_TYPES": "Escludi i tipi annidati",
  "SHOW_DEBUG_LINE_NUMBERS": "Mostra i numeri delle linee di debug",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Includere i numeri di linea nel bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Includi la diagnostica degli errori",
  "SHOW_SYNTHETIC_MEMBERS": "Mostra i membri sintetici",
  "SIMPLIFY_MEMBER_REFERENCES": "Semplificare i riferimenti ai membri",
  "MERGE_VARIABLES": "Unire le variabili",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Forzare gli argomenti di tipo esplicito",
  "FORCE_EXPLICIT_IMPORTS": "Forzare le importazioni esplicite",
  "FLATTEN_SWITCH_BLOCKS": "Appiattire i blocchi di interruttori",
  "RETAIN_POINTLESS_SWITCHES": "Mantenere gli interruttori inutili",
  "RETAIN_REDUNDANT_CASTS": "Mantenere i cast ridondanti",
  "UNICODE_OUTPUT_ENABLED": "Uscita Unicode abilitata",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Ricarica le risorse",
  "RELOAD_RESOURCES_CONFIRM": "Sei sicuro di voler ricaricare le risorse?",
  "SELECT_FILE_TITLE": "Selezionare File o Cartella da aprire in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, file di classe o Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Seleziona il plugin esterno",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Plugin esterno BCV in js, java, python, ruby o groovy",
  "FOREIGN_LIBRARY_WARNING": "ATTENZIONE: Se questo è disattivato, le librerie obsolete NON saranno rimosse.\n\rÈ anche un problema di sicurezza.\n\rDISATTIVALA SOLO SE SAI COSA STAI FACENDO.",
  "RESET_TITLE": "{PRODUCT_NAME} - Ripristinare lo spazio di lavoro",
  "RESET_CONFIRM": "Sei sicuro di voler resettare lo spazio di lavoro?\n\rResetterà anche il tuo navigatore di file e la ricerca.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Uscire",
  "EXIT_CONFIRM": "Sei sicuro di voler uscire?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Informazioni su - {WEBSITE} | {data da confermare}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Console dei Plugin",
  "CLOSE_ALL_BUT_THIS": "Chiudi tutto tranne questo",
  "CLOSE_TAB": "Chiudi scheda",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Si prega di inviare questo registro degli errori a",
  "PLEASE_SEND_RESOURCES": "Se siete in possesso di diritti legali appropriati alla classe in questione",
  "ONE_PLUGIN_AT_A_TIME": "Attualmente c'è un altro plugin in esecuzione in questo momento, per favore aspetta che finisca di essere eseguito.",
  "ILLEGAL_ACCESS_ERROR": "Si prega di utilizzare Java 15 o più vecchio per fare questo.",


  "FILES": "File",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Ricerca rapida di file (senza estensione)",
  "WORK_SPACE": "Spazio di lavoro",
  "EXACT": "Esattamente",
  "SEARCH": "Cerca",
  "SEARCH_FROM": "Cerca da:",
  "SEARCH_STRING": "Stringa di ricerca:",
  "SEARCH_REGEX": "Ricerca Regex:",
  "OWNER": "Proprietario:",
  "NAME": "Nome:",
  "DESC": "Desc:",
  "SAVE": "Salva...",
  "SAVE_AS": "Salva con nome...",
  "RESULTS": "Risultati",
  "REFRESH": "Aggiorna",
  "ANNOTATION_NAME": "Nome dell'annotazione",
  "MATCH_CASE": "Caso di partita",
  "EXACT_PATH": "Percorso esatto",
  "MIN_SDK_VERSION": "Versione minima SDK",
  "PRINT_LINE_NUMBERS": "Stampa i numeri di linea"
}

```

`src/main/resources/translations/japanese.json`:

```json
{
  "FILE": "ファイル",
  "ADD": "追加...",
  "NEW_WORKSPACE": "新しいワークスペース",
  "RELOAD_RESOURCES": "リソースの再読み込み",
  "RUN": "ラン",
  "OPEN": "オープン...",
  "OPEN_UNSTYLED": "オープン",
  "QUICK_OPEN": "クイックオープン",
  "DELETE": "削除",
  "NEW": "新規",
  "EXPAND": "拡大する",
  "COLLAPSE": "崩壊",
  "COMPILE": "コンパイル",
  "SAVE_AS_RUNNABLE_JAR": "Runnable Jarとして保存...",
  "SAVE_AS_ZIP": "Zipとして保存...",
  "SAVE_AS_DEX": "DEXとして保存...",
  "SAVE_AS_APK": "APKとして保存...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "オープンクラスのデコンパイルと保存",
  "DECOMPILE_SAVE_ALL_CLASSES": "全クラスのデコンパイルと保存",
  "RECENT_FILES": "最近のファイル",
  "ABOUT": "について",
  "EXIT": "出口",

  "VIEW": "ビュー",
  "VISUAL_SETTINGS": "ビジュアル設定",
  "PANE_1": "ペイン1",
  "PANE_2": "ペイン2",
  "PANE_3": "ペイン3",
  "NONE": "なし",
  "EDITABLE": "編集可能",

  "LANGUAGE": "言語",
  "FONT_SIZE": "フォントサイズ",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "タブのタイトルにファイルを表示",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "タブのタイトルに名前を表示する",
  "SYNCHRONIZED_VIEWING": "シンクロナイズドビューイング",
  "SHOW_CLASS_METHODS": "クラスメソッドの表示",

  "WINDOW_THEME": "ウィンドウテーマ",
  "SYSTEM_THEME": "システムテーマ",
  "DARK_THEME": "ダークテーマ",
  "LIGHT_THEME": "ライトテーマ",
  "ONE_DARK_THEME": "1つのダークテーマ",
  "SOLARIZED_DARK_THEME": "ソラライズド・ダーク・テーマ",
  "SOLARIZED_LIGHT_THEME": "ソーラーライトのテーマ",
  "HIGH_CONTRAST_DARK_THEME": "ハイコントラストなダークテーマ",
  "HIGH_CONTRAST_LIGHT_THEME": "ハイコントラストな光のテーマ",
  "ONE_DARK": "ワンダーク",
  "SOLARIZED_DARK": "ソラライズドダーク",
  "SOLARIZED_LIGHT": "ソーラーライト",
  "HIGH_CONTRAST_DARK": "ハイコントラスト・ダーク",
  "HIGH_CONTRAST_LIGHT": "ハイコントラストライト",
  "TEXT_AREA_THEME": "テキストエリアのテーマ",
  "DEFAULT_RECOMMENDED_LIGHT": "デフォルト（推奨光",
  "THEME_MATCH": "テーママッチ（推奨",
  "DARK": "ダーク（推奨ダーク",
  "DARK_ALT": "ダークアルト",
  "DEFAULT_ALT": "デフォルト-ALT",
  "ECLIPSE": "エクリプス",
  "INTELLIJ": "インテリジ",
  "VISUAL_STUDIO": "ビジュアルスタジオ",
  "DRUID_DARK": "ドルイド（ダーク",
  "MONOKAI_DARK": "モノカイ（ダーク",

  "SETTINGS": "設定",
  "COMPILE_ON_SAVE": "保存時にコンパイルする",
  "COMPILE_ON_REFRESH": "リフレッシュ時にコンパイルする",
  "REFRESH_ON_VIEW_CHANGE": "ビュー変更時のリフレッシュ",
  "DECODE_APK_RESOURCES": "Decode APKリソース",
  "APK_CONVERSION": "APK変換",
  "APK_CONVERSION_DECODING": "APK変換",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "更新チェック",
  "DELETE_UNKNOWN_LIBS": "外国人の削除",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Set Python 2.7 Executable",
  "SET_PYTHON_30_EXECUTABLE": "Set Python 3.X Executable",
  "SET_JRE_RT_LIBRARY": "JRE RTライブラリの設定",
  "SET_OPTIONAL_LIBRARY_FOLDER": "任意のライブラリフォルダの設定",
  "SET_JAVAC_EXECUTABLE": "セットJavac実行可能",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "プロキオンの設定",
  "CFR_SETTINGS": "CFR設定",
  "FERNFLOWER_SETTINGS": "ファーンフラワーの設定",
  "PROCYON": "プロキオン",
  "CFR": "CFR",
  "FERNFLOWER": "ファーンフラワー",
  "KRAKATAU": "クラカタウ",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "スマリ",
  "SMALI_DEX": "スマリ",
  "HEXCODE": "ヘックスコード",
  "BYTECODE": "バイトコード",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "バイトコードデコンパイラー",
  "DEBUG_HELPERS": "デバッグヘルパー",
  "APPEND_BRACKETS_TO_LABEL": "ラベルに括弧をつける",

  "PLUGINS": "プラグイン",
  "OPEN_PLUGIN": "Open Plugin...",
  "RECENT_PLUGINS": "最近のプラグイン",
  "CODE_SEQUENCE_DIAGRAM": "コードシーケンス図",
  "MALICIOUS_CODE_SCANNER": "悪質コードスキャナ",
  "SHOW_MAIN_METHODS": "主要メソッドの表示",
  "SHOW_ALL_STRINGS": "すべてのストリングスを表示",
  "REPLACE_STRINGS": "ストリングスの交換",
  "STACK_FRAMES_REMOVER": "スタックフレームリムーバー",
  "ZKM_STRING_DECRYPTER": "ZKM文字列復号器",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Androidのパーミッションの表示",
  "VIEW_MANIFEST": "マニフェストを見る",
  "CHANGE_CLASSFILE_VERSIONS": "クラスファイルのバージョン変更",



  "PROCYON_DECOMPILER": "プロキオンデコンパイラ",
  "CFR_DECOMPILER": "CFRデコンパイラー",
  "FERNFLOWER_DECOMPILER": "FernFlowerデコンパイラ",
  "JADX_DECOMPILER": "JADXデコンパイラー",
  "JD_DECOMPILER": "JD-GUIデコンパイラー",
  "BYTECODE_DISASSEMBLER": "バイトコード・ディスアセンブラ",
  "DISASSEMBLER": "逆アセンブラ",

  "ERROR": "エラー",
  "NEW_JAVA_PLUGIN": "新しいJavaプラグイン",
  "NEW_JAVASCRIPT_PLUGIN": "新しいJavascriptプラグイン",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "推奨される修正方法 クラスの更新」をクリックし、再度失敗した場合は別のデコンパイラを試します。",
  "SUGGESTED_FIX_COMPILER_ERROR": "推奨される修正方法：「表示」→「ペイン」→「クラカトゥ」→「バイトコード」を選択し、「編集可能」を有効にしてください。",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "警告：現在、デコンパイラが選択されていません。表示」→「ペイン」を選択し、デコンパイラを選択してください。",
  "COMPILER_TIP": "ほとんどのデコンパイラはコンパイル可能なクラスを生成できないことに留意してください。",
  "FIRST_OPEN_A_RESOURCE": "まず、BCV内のリソース（class、jar、zip、apkファイル）を開きます。",
  "FIRST_OPEN_A_CLASS": "まず、BCV内のクラスファイルリソース（jar, zip, apk, dex）を開きます。",
  "FIRST_VIEW_A_CLASS": "最初に、タブの中のクラスファイルを表示します。",
  "DRAG_CLASS_JAR": "ドラッグクラス",

  "YES": "はい。",
  "NO": "いいえ",
  "ERROR2": "エラーです。",
  "PROCESS2": "プロセス。",
  "EXIT_VALUE_IS": "Exit Valueは。",
  "JAVA_COMPILE_FAILED": "Javaのコンパイルに失敗しました。",
  "ERROR_COMPILING_CLASS": "クラスのコンパイルエラー",
  "COMPILER": "ほとんどのデコンパイラはコンパイル可能なクラスを生成できないことに留意してください。",
  "SELECT_LIBRARY_FOLDER": "ライブラリフォルダの選択",
  "SELECT_JAVA_RT": "JRE RT Jarの選択",
  "SELECT_JAVA": "Java Executableを選択",
  "SELECT_JAVAC": "Javac Executableの選択",
  "SELECT_JAVA_TOOLS": "Java Tools Jar」を選択",
  "SELECT_PYTHON_2": "Python 2.7の実行ファイルを選択",
  "SELECT_PYTHON_3": "Python 3.x Executableを選択",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (または PyPy 2.7 for speed) Executable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (または PyPy 3.x for speed) Executable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Python 2.7 (またはPyPy 2.7 for speed)の実行パスを設定する必要があります。",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Python 3.x (またはPyPy 3.x for speed)の実行パスを設定する必要があります。",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "JREのRTライブラリを設定する必要があります。",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:Program Files\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C.):",
  "JAVAC_EXECUTABLE": "Javac Executable（要JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar（JDK C.の内部。",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C.):",
  "OPTIONAL_LIBRARY_FOLDER": "オプションのライブラリフォルダ（Compiler & Krakatau",

  "HIDE_BRIDGE_METHODS": "ブリッジメソッドを隠す",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "合成クラスのメンバーを隠す",
  "DECOMPILE_INNER_CLASSES": "内部クラスのデコンパイル",
  "COLLAPSE_14_CLASS_REFERENCES": "崩壊 1.4 クラスの参照",
  "DECOMPILE_ASSERTIONS": "アサーションのデコンパイル",
  "HIDE_EMPTY_SUPER_INVOCATION": "空のスーパーインヴォケーションを隠す",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "空のデフォルトコンストラクタを隠す",
  "DECOMPILE_GENERIC_SIGNATURES": "ジェネリック・シグネチャーのデコンパイル",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "例外を発生させないリターンを想定",
  "DECOMPILE_ENUMERATIONS": "列挙のデコンパイル",
  "REMOVE_GETCLASS_INVOCATION": "getClass()呼び出しの削除",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "int 1をtrueのブール値として解釈する",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "合成属性を設定しないようにする",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "名前のない型をjava.lang.Objectとみなす",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "デバッグ情報から変数名を再構築",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "空の例外範囲の削除",
  "DEINLINE_FINALLY_STRUCTURES": "最終的な構造体のデインライン",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "文字列にASCII文字のみを使用する",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "曖昧なクラスやクラス要素の名称変更",

  "DECODE_ENUM_SWITCH": "デコードイナムスイッチ",
  "SUGARENUMS": "SugarEnum",
  "DECODE_STRING_SWITCH": "デコード ストリングス スイッチ",
  "ARRAYITER": "アレイター",
  "COLLECTIONITER": "収集家",
  "INNER_CLASSES": "インナークラス",
  "REMOVE_BOILER_PLATE": "ボイラープレートの取り外し",
  "REMOVE_INNER_CLASS_SYNTHETICS": "インナークラスの合成樹脂の除去",
  "DECODE_LAMBDAS": "ラムダのデコード",
  "LIFT__CONSTRUCTOR_INIT": "リフトコンストラクタの初期化",
  "REMOVE_DEAD_METHODS": "死んだメソッドの削除",
  "REMOVE_BAD_GENERICS": "不良ジェネリックの除去",
  "SUGAR_ASSERTS": "シュガーアサート",
  "SUGAR_BOXING": "シュガーボクシング",
  "SHOW_VERSION": "表示バージョン",
  "DECODE_FINALLY": "遂にデコード",
  "TIDY_MONITORS": "Tidy Monitors",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "ダンプクラスパス",
  "COMMENTS": "コメント",
  "FORCE_TOP_SORT": "強制トップソート",
  "FORCE_TOP_SORT_AGGRESS": "フォース トップ ソート アグレッシブ",
  "FORCE_EXCEPTION_PRUNE": "フォース・エクセプション・プルーン",
  "STRING_BUFFER": "文字列バッファ",
  "STRING_BUILDER": "ストリングスビルダー",
  "SILENT": "サイレント",
  "RECOVER": "回復",
  "OVERRIDE": "オーバーライド",
  "SHOW_INFERRABLE": "Show Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "フォース・コンド・プロパゲート",
  "HIDE_UTF": "Hide UTF",
  "HIDE_LONG_STRINGS": "ロングストリングスを隠す",
  "COMMENT_MONITORS": "コメントモニター",
  "ALLOW_CORRECTING": "修正を許可する",
  "LABELLED_BLOCKS": "ラベル付きブロック",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "タイプクラッシュの回復",
  "RECOVER_TYPE__HINTS": "Recover Typeのヒント",
  "FORCE_RETURNING_IFS": "強制的にIFを返す",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "キャッチブロックでは常に例外変数を生成する",
  "EXCLUDE_NESTED_TYPES": "ネストされたタイプを除外する",
  "SHOW_DEBUG_LINE_NUMBERS": "デバッグ行番号の表示",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "バイトコードに行番号を含める",
  "INCLUDE_ERROR_DIAGNOSTICS": "エラー診断機能の搭載",
  "SHOW_SYNTHETIC_MEMBERS": "合成メンバーの表示",
  "SIMPLIFY_MEMBER_REFERENCES": "メンバーリファレンスの簡素化",
  "MERGE_VARIABLES": "変数のマージ",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "明示的な型の引数を強制する",
  "FORCE_EXPLICIT_IMPORTS": "明示的なインポートの強制",
  "FLATTEN_SWITCH_BLOCKS": "スイッチブロックを平らにする",
  "RETAIN_POINTLESS_SWITCHES": "無意味なスイッチの保持",
  "RETAIN_REDUNDANT_CASTS": "冗長キャストの保持",
  "UNICODE_OUTPUT_ENABLED": "ユニコード出力の有効化",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - リソースの再読み込み",
  "RELOAD_RESOURCES_CONFIRM": "リソースを再読み込みしてもよろしいですか？",
  "SELECT_FILE_TITLE": "ファイルやフォルダを選択して{BCV}で開きます。",
  "SELECT_FILE_DESCRIPTION": "APK、DEX、クラスファイルまたはZip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "外部プラグインの選択",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "js、java、python、ruby、groovyによるBCV External Plugin",
  "FOREIGN_LIBRARY_WARNING": "警告：この設定をオフにすると、古いライブラリは削除されません。{NEWLINE}。これはセキュリティ上の問題でもあります。NEWLINE} {NEWLINE 自分が何をしているか分かっている場合のみ、この機能をオフにしてください。",
  "RESET_TITLE": "{PRODUCT_NAME} - ワークスペースのリセット",
  "RESET_CONFIRM": "ワークスペースをリセットしてもいいのか？{NEWLINE}。また、ファイルナビゲーターや検索もリセットされます。",
  "EXIT_TITLE": "{PRODUCT_NAME} - 終了",
  "EXIT_CONFIRM": "本当に終了してもいいのか？",
  "ABOUT_TITLE": "{PRODUCT_NAME}-概要-{WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - プラグインコンソール",
  "CLOSE_ALL_BUT_THIS": "これ以外はすべて閉じる",
  "CLOSE_TAB": "タブを閉じる",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "このエラーログを下記にお送りください。",
  "PLEASE_SEND_RESOURCES": "お客様が該当するクラスの適切な法的権利を持っている場合",
  "ONE_PLUGIN_AT_A_TIME": "現在、別のプラグインが起動していますので、そちらの実行が終了するのをお待ちください。",
  "ILLEGAL_ACCESS_ERROR": "Java 15 以上で行ってください。",


  "FILES": "ファイル",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "クイックファイル検索（拡張子なし",
  "WORK_SPACE": "ワークスペース",
  "EXACT": "正確",
  "SEARCH": "検索",
  "SEARCH_FROM": "から検索します。",
  "SEARCH_STRING": "検索文字列。",
  "SEARCH_REGEX": "Search Regexです。",
  "OWNER": "オーナーです。",
  "NAME": "名前を教えてください。",
  "DESC": "降臨。",
  "SAVE": "保存...",
  "SAVE_AS": "Save As...",
  "RESULTS": "結果",
  "REFRESH": "リフレッシュ",
  "ANNOTATION_NAME": "アノテーション名",
  "MATCH_CASE": "マッチケース",
  "EXACT_PATH": "正確なパス",
  "MIN_SDK_VERSION": "SDKの最小バージョン",
  "PRINT_LINE_NUMBERS": "行番号の印刷"
}

```

`src/main/resources/translations/javanese.json`:

```json
{
  "FILE": "File",
  "ADD": "Tambah ...",
  "NEW_WORKSPACE": "Ruang Kerja Anyar",
  "RELOAD_RESOURCES": "Muat maneh Sumber Daya",
  "RUN": "Mbukak",
  "OPEN": "Open...",
  "OPEN_UNSTYLED": "Open",
  "QUICK_OPEN": "Quick Open",
  "DELETE": "Delete",
  "NEW": "New",
  "EXPAND": "Expand",
  "COLLAPSE": "Collapse",
  "COMPILE": "Nyusun",
  "SAVE_AS_RUNNABLE_JAR": "Simpen Minangka Jar sing Bisa Dijalankan ...",
  "SAVE_AS_ZIP": "Simpen Minangka Zip ...",
  "SAVE_AS_DEX": "Simpen Minangka DEX ...",
  "SAVE_AS_APK": "Save As APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Nyusun & Simpen Kelas sing Dibukak",
  "DECOMPILE_SAVE_ALL_CLASSES": "Decompile & Simpen Kabeh Kelas",
  "RECENT_FILES": "File Anyar",
  "ABOUT": "Babagan",
  "EXIT": "Metu",

  "VIEW": "Ndeleng",
  "VISUAL_SETTINGS": "Setelan Visual",
  "PANE_1": "Pane 1",
  "PANE_2": "Pane 2",
  "PANE_3": "Pane 3",
  "NONE": "Ora ana",
  "EDITABLE": "Bisa diowahi",

  "LANGUAGE": "Basa",
  "FONT_SIZE": "Ukuran Font",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Tampilake File ing Judhul Tab",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Sederhana Jeneng Ing Judhul Tab",
  "SYNCHRONIZED_VIEWING": "Ndeleng sing Disinkronake",
  "SHOW_CLASS_METHODS": "Tampilake Metode Kelas",

  "WINDOW_THEME": "Tema Jendela",
  "SYSTEM_THEME": "Tema Sistem",
  "DARK_THEME": "Tema Peteng",
  "LIGHT_THEME": "Tema Cahya",
  "ONE_DARK_THEME": "One Dark Theme",
  "SOLARIZED_DARK_THEME": "Solarized Dark Theme",
  "SOLARIZED_LIGHT_THEME": "Solarized Light Theme",
  "HIGH_CONTRAST_DARK_THEME": "High Contrast Dark Theme",
  "HIGH_CONTRAST_LIGHT_THEME": "High Contrast Light Theme",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solarized Light",
  "HIGH_CONTRAST_DARK": "High Contrast Dark",
  "HIGH_CONTRAST_LIGHT": "High Contrast Light",
  "TEXT_AREA_THEME": "Tema Area Teks",
  "DEFAULT_RECOMMENDED_LIGHT": "Default (Cahya sing Disaranake)",
  "THEME_MATCH": "Theme Match (Recommended)",
  "DARK": "Dark (Recommended Dark)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Studio Visual",
  "DRUID_DARK": "Druid (Peteng)",
  "MONOKAI_DARK": "Monokai (Peteng)",

  "SETTINGS": "Setelan",
  "COMPILE_ON_SAVE": "Tulis ing Simpen",
  "COMPILE_ON_REFRESH": "Nyusun On Refresh",
  "REFRESH_ON_VIEW_CHANGE": "Refresh On Ganti Tampilan",
  "DECODE_APK_RESOURCES": "Decode APK Sumber Daya",
  "APK_CONVERSION": "Konversi APK",
  "APK_CONVERSION_DECODING": "APK Conversion/Decoding",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Nganyari Priksa",
  "DELETE_UNKNOWN_LIBS": "Busak Libs Asing / Usang",
  "FORCE_PURE_ASCII_AS_TEXT": "Meksa Ascii Murni Minangka Teks",
  "SET_PYTHON_27_EXECUTABLE": "Setel Python 2.7 Eksekusi",
  "SET_PYTHON_30_EXECUTABLE": "Setel Python 3.X Eksekusi",
  "SET_JRE_RT_LIBRARY": "Setel JRE RT Library",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Setel Folder Library Opsional",
  "SET_JAVAC_EXECUTABLE": "Setel Javac Executable",

  "JAVA": "Jawa",
  "PROCYON_SETTINGS": "Procyon Settings",
  "CFR_SETTINGS": "CFR Settings",
  "FERNFLOWER_SETTINGS": "FernFlower Settings",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "KembangBunga",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali / Dex",
  "HEXCODE": "Hekscode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode Decompiler",
  "DEBUG_HELPERS": "Penolong Debug",
  "APPEND_BRACKETS_TO_LABEL": "Nambah Kurung Kanggo Label",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Bukak Plugin ...",
  "RECENT_PLUGINS": "Plugin Anyar",
  "CODE_SEQUENCE_DIAGRAM": "Diagram Urutan Urutan",
  "MALICIOUS_CODE_SCANNER": "Scanner Code Mbebayani",
  "SHOW_MAIN_METHODS": "Tampilake Metode Utama",
  "SHOW_ALL_STRINGS": "Tampilake Kabeh Senar",
  "REPLACE_STRINGS": "Ganti Senar",
  "STACK_FRAMES_REMOVER": "Remover Frames Stack",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "View Android Permissions",
  "VIEW_MANIFEST": "View Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Change ClassFile Versions",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "Decompiler FernFlower",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Kesalahan",
  "NEW_JAVA_PLUGIN": "New Java Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "New Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Ndandani Saran: Klik kelas refresh, yen gagal maneh coba dekompiler liyane.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Ndandani Disaranake: Coba Deleng> Pane> Krakatau> Bytecode lan aktifake sing bisa Diowahi.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "WARNING: No decompiler is currently selected. Try View>Pane and choose a decompiler.",
  "COMPILER_TIP": "Keep in mind most decompilers cannot produce compilable classes",
  "FIRST_OPEN_A_RESOURCE": "First open a resource inside of BCV (class, jar, zip or apk file)",
  "FIRST_OPEN_A_CLASS": "First open a classfile resource inside of BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "First view a class file inside of a tab.",
  "DRAG_CLASS_JAR": "Seret kelas / jar / zip / APK / DEX ing kene",

  "YES": "Yes",
  "NO": "No",
  "ERROR2": "Error:",
  "PROCESS2": "Process:",
  "EXIT_VALUE_IS": "Exit Value is:",
  "JAVA_COMPILE_FAILED": "Java Compile Failed",
  "ERROR_COMPILING_CLASS": "Error compiling class",
  "COMPILER": "Keep in mind most decompilers cannot produce compilable classes",
  "SELECT_LIBRARY_FOLDER": "Select Library Folder",
  "SELECT_JAVA_RT": "Select JRE RT Jar",
  "SELECT_JAVA": "Select Java Executable",
  "SELECT_JAVAC": "Select Javac Executable",
  "SELECT_JAVA_TOOLS": "Select Java Tools Jar",
  "SELECT_PYTHON_2": "Select Python 2.7 Executable",
  "SELECT_PYTHON_3": "Select Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Or PyPy 2.7 for speed) Executable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Or PyPy 3.x for speed) Executable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "You need to set your Python 2.7 (or PyPy 2.7 for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "You need to set your Python 3.x (or PyPy 3.x for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "You need to set your JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C:/Program Files/Java/JRE_xx/bin/java.exe)",
  "JAVAC_EXECUTABLE": "Javac Executable (Requires JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C:/Program Files/Java/JDK_xx/lib/tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C:/Program Files/Java/JRE_xx/lib/rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Optional Library Folder (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Hide bridge methods",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Hide synthetic class members",
  "DECOMPILE_INNER_CLASSES": "Decompile inner classes",
  "COLLAPSE_14_CLASS_REFERENCES": "Collapse 1.4 class references",
  "DECOMPILE_ASSERTIONS": "Decompile assertions",
  "HIDE_EMPTY_SUPER_INVOCATION": "Hide empty super invocation",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Hide empty default constructor",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompile generic signatures",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Assume return not throwing exceptions",
  "DECOMPILE_ENUMERATIONS": "Decompile enumerations",
  "REMOVE_GETCLASS_INVOCATION": "Remove getClass() invocation",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpret int 1 as boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Allow for not set synthetic attribute",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Consider nameless types as java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruct variable names from debug info",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Remove empty exception ranges",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finally structures",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Allow only ASCII characters in strings",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Rename ambiguous classes and class elements",

  "DECODE_ENUM_SWITCH": "Decode Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Decode String Switch",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Inner Classes",
  "REMOVE_BOILER_PLATE": "Remove Boiler Plate",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Remove Inner Class Synthetics",
  "DECODE_LAMBDAS": "Decode Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift  Constructor Init",
  "REMOVE_DEAD_METHODS": "Remove Dead Methods",
  "REMOVE_BAD_GENERICS": "Remove Bad Generics",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Show Version",
  "DECODE_FINALLY": "Decode Finally",
  "TIDY_MONITORS": "Tidy Monitors",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Comments",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Recover",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Show Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Hide UTF",
  "HIDE_LONG_STRINGS": "Hide Long Strings",
  "COMMENT_MONITORS": "Comment Monitors",
  "ALLOW_CORRECTING": "Allow Correcting",
  "LABELLED_BLOCKS": "Labelled Blocks",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Recover Type Clash",
  "RECOVER_TYPE__HINTS": "Recover Type  Hints",
  "FORCE_RETURNING_IFS": "Force Returning IFs",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Always Generate Exception Variable For Catch Blocks",
  "EXCLUDE_NESTED_TYPES": "Exclude Nested Types",
  "SHOW_DEBUG_LINE_NUMBERS": "Show Debug Line Numbers",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Include Line Numbers In Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Include Error Diagnostics",
  "SHOW_SYNTHETIC_MEMBERS": "Show Synthetic Members",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplify Member References",
  "MERGE_VARIABLES": "Merge Variables",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Force Explicit Imports",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Switch Blocks",
  "RETAIN_POINTLESS_SWITCHES": "Retain Pointless Switches",
  "RETAIN_REDUNDANT_CASTS": "Retain Redundant Casts",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Reload Resources",
  "RELOAD_RESOURCES_CONFIRM": "Are you sure you wish to reload the resources?",
  "SELECT_FILE_TITLE": "Select File or Folder to open in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Class Files or Zip/Jar/War Archives",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Select External Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin in js, java, python, ruby or groovy",
  "FOREIGN_LIBRARY_WARNING": "WARNING: With this being toggled off outdated libraries will NOT be removed.\n\rIt's also a security issue.\n\rONLY TURN IT OFF IF YOU KNOW WHAT YOU'RE DOING.",
  "RESET_TITLE": "{PRODUCT_NAME} - Reset Workspace",
  "RESET_CONFIRM": "Are you sure you want to reset the workspace?\n\rIt will also reset your file navigator and search.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Are you sure you want to exit?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - About - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Close All But This",
  "CLOSE_TAB": "Close Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Please send this error log to",
  "PLEASE_SEND_RESOURCES": "If you hold appropriate legal rights to the relevant class/jar/apk file please include that as well.",
  "ONE_PLUGIN_AT_A_TIME": "There is currently another plugin running right now, please wait for that to finish executing.",
  "ILLEGAL_ACCESS_ERROR": "Please use Java 15 or older to do this.",


  "FILES": "File",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Panelusuran file cepet (ora ana ekstensi file)",
  "WORK_SPACE": "Ruang Kerja",
  "EXACT": "Persis",
  "SEARCH": "Nggoleki",
  "SEARCH_FROM": "Telusuri Saka:",
  "SEARCH_STRING": "Telusuri String:",
  "SEARCH_REGEX": "Telusuri Regex:",
  "OWNER": "Pamilik:",
  "NAME": "Jeneng:",
  "DESC": "Desc:",
  "SAVE": "Save...",
  "SAVE_AS": "Save As...",
  "RESULTS": "Results",
  "REFRESH": "Refresh",
  "ANNOTATION_NAME": "Annotation Name",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Exact Path",
  "MIN_SDK_VERSION": "Minimum SDK version",
  "PRINT_LINE_NUMBERS": "Print Line Numbers"
}

```

`src/main/resources/translations/korean.json`:

```json
{
  "FILE": "파일",
  "ADD": "더하다...",
  "NEW_WORKSPACE": "새 작업 공간",
  "RELOAD_RESOURCES": "리소스 다시 로드",
  "RUN": "운영",
  "OPEN": "Open...",
  "OPEN_UNSTYLED": "Open",
  "QUICK_OPEN": "Quick Open",
  "DELETE": "Delete",
  "NEW": "New",
  "EXPAND": "Expand",
  "COLLAPSE": "Collapse",
  "COMPILE": "엮다",
  "SAVE_AS_RUNNABLE_JAR": "실행 가능한 항아리로 저장...",
  "SAVE_AS_ZIP": "Zip으로 저장...",
  "SAVE_AS_DEX": "DEX로 저장...",
  "SAVE_AS_APK": "APK로 저장...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "열린 클래스 디컴파일 및 저장",
  "DECOMPILE_SAVE_ALL_CLASSES": "모든 클래스 디컴파일 및 저장",
  "RECENT_FILES": "최근 파일",
  "ABOUT": "약",
  "EXIT": "출구",

  "VIEW": "전망",
  "VISUAL_SETTINGS": "시각적 설정",
  "PANE_1": "창 1",
  "PANE_2": "창 2",
  "PANE_3": "창 3",
  "NONE": "없음",
  "EDITABLE": "편집 가능",

  "LANGUAGE": "언어",
  "FONT_SIZE": "글꼴 크기",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "탭 제목에 파일 표시",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "탭 제목의 이름 단순화",
  "SYNCHRONIZED_VIEWING": "동기화된 보기",
  "SHOW_CLASS_METHODS": "클래스 메서드 표시",

  "WINDOW_THEME": "창 테마",
  "SYSTEM_THEME": "시스템 테마",
  "DARK_THEME": "어두운 테마",
  "LIGHT_THEME": "밝은 테마",
  "ONE_DARK_THEME": "One Dark Theme",
  "SOLARIZED_DARK_THEME": "Solarized Dark Theme",
  "SOLARIZED_LIGHT_THEME": "Solarized Light Theme",
  "HIGH_CONTRAST_DARK_THEME": "High Contrast Dark Theme",
  "HIGH_CONTRAST_LIGHT_THEME": "High Contrast Light Theme",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solarized Light",
  "HIGH_CONTRAST_DARK": "High Contrast Dark",
  "HIGH_CONTRAST_LIGHT": "High Contrast Light",
  "TEXT_AREA_THEME": "텍스트 영역 테마",
  "DEFAULT_RECOMMENDED_LIGHT": "기본(권장 조명)",
  "THEME_MATCH": "Theme Match (Recommended)",
  "DARK": "Dark (Recommended Dark)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "기본 Alt",
  "ECLIPSE": "식",
  "INTELLIJ": "인텔리",
  "VISUAL_STUDIO": "비주얼 스튜디오",
  "DRUID_DARK": "드루이드(어둠)",
  "MONOKAI_DARK": "모노카이(어둠)",

  "SETTINGS": "설정",
  "COMPILE_ON_SAVE": "저장 시 컴파일",
  "COMPILE_ON_REFRESH": "새로 고침 시 컴파일",
  "REFRESH_ON_VIEW_CHANGE": "보기 변경 시 새로 고침",
  "DECODE_APK_RESOURCES": "APK 리소스 디코딩",
  "APK_CONVERSION": "APK 변환",
  "APK_CONVERSION_DECODING": "APK Conversion/Decoding",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "업데이트 확인",
  "DELETE_UNKNOWN_LIBS": "외부/오래된 라이브러리 삭제",
  "FORCE_PURE_ASCII_AS_TEXT": "순수 ASCII를 텍스트로 강제 실행",
  "SET_PYTHON_27_EXECUTABLE": "Python 2.7 실행 파일 설정",
  "SET_PYTHON_30_EXECUTABLE": "Python 3.X 실행 파일 설정",
  "SET_JRE_RT_LIBRARY": "JRE RT 라이브러리 설정",
  "SET_OPTIONAL_LIBRARY_FOLDER": "선택적 라이브러리 폴더 설정",
  "SET_JAVAC_EXECUTABLE": "Javac 실행 파일 설정",

  "JAVA": "자바",
  "PROCYON_SETTINGS": "Procyon Settings",
  "CFR_SETTINGS": "CFR Settings",
  "FERNFLOWER_SETTINGS": "FernFlower Settings",
  "PROCYON": "프로키온",
  "CFR": "CFR",
  "FERNFLOWER": "고사리꽃",
  "KRAKATAU": "크라카타우",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "스말리",
  "SMALI_DEX": "스말리/덱스",
  "HEXCODE": "16진수",
  "BYTECODE": "바이트코드",
  "ASM_TEXTIFY": "ASM 텍스트파이",

  "BYTECODE_DECOMPILER": "바이트코드 디컴파일러",
  "DEBUG_HELPERS": "디버그 도우미",
  "APPEND_BRACKETS_TO_LABEL": "레이블에 대괄호 추가",

  "PLUGINS": "플러그인",
  "OPEN_PLUGIN": "플러그인 열기...",
  "RECENT_PLUGINS": "최근 플러그인",
  "CODE_SEQUENCE_DIAGRAM": "코드 시퀀스 다이어그램",
  "MALICIOUS_CODE_SCANNER": "악성코드 스캐너",
  "SHOW_MAIN_METHODS": "주요 방법 표시",
  "SHOW_ALL_STRINGS": "모든 문자열 표시",
  "REPLACE_STRINGS": "문자열 바꾸기",
  "STACK_FRAMES_REMOVER": "스택 프레임 리무버",
  "ZKM_STRING_DECRYPTER": "ZKM 문자열 해독기",
  "ALLATORI_STRING_DECRYPTER": "알라토리 문자열 해독기",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray 해독기",
  "VIEW_ANDROID_PERMISSIONS": "View Android Permissions",
  "VIEW_MANIFEST": "View Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Change ClassFile Versions",



  "PROCYON_DECOMPILER": "프로키온 디컴파일러",
  "CFR_DECOMPILER": "CFR 디컴파일러",
  "FERNFLOWER_DECOMPILER": "FernFlower 디컴파일러",
  "JADX_DECOMPILER": "JADX 디컴파일러",
  "JD_DECOMPILER": "JD-GUI 디컴파일러",
  "BYTECODE_DISASSEMBLER": "바이트코드 디스어셈블러",
  "DISASSEMBLER": "분해기",

  "ERROR": "오류",
  "NEW_JAVA_PLUGIN": "새로운 자바 플러그인",
  "NEW_JAVASCRIPT_PLUGIN": "새로운 자바스크립트 플러그인",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "수정 제안: 클래스 새로 고침을 클릭하고 실패하면 다른 디컴파일러를 다시 시도하십시오.",
  "SUGGESTED_FIX_COMPILER_ERROR": "수정 제안: 보기>창>크라카타우>바이트코드를 시도하고 편집 가능을 활성화하십시오.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "WARNING: No decompiler is currently selected. Try View>Pane and choose a decompiler.",
  "COMPILER_TIP": "Keep in mind most decompilers cannot produce compilable classes",
  "FIRST_OPEN_A_RESOURCE": "First open a resource inside of BCV (class, jar, zip or apk file)",
  "FIRST_OPEN_A_CLASS": "First open a classfile resource inside of BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "First view a class file inside of a tab.",
  "DRAG_CLASS_JAR": "클래스/jar/zip/APK/DEX를 여기로 드래그하세요.",

  "YES": "Yes",
  "NO": "No",
  "ERROR2": "Error:",
  "PROCESS2": "Process:",
  "EXIT_VALUE_IS": "Exit Value is:",
  "JAVA_COMPILE_FAILED": "Java Compile Failed",
  "ERROR_COMPILING_CLASS": "Error compiling class",
  "COMPILER": "Keep in mind most decompilers cannot produce compilable classes",
  "SELECT_LIBRARY_FOLDER": "Select Library Folder",
  "SELECT_JAVA_RT": "Select JRE RT Jar",
  "SELECT_JAVA": "Select Java Executable",
  "SELECT_JAVAC": "Select Javac Executable",
  "SELECT_JAVA_TOOLS": "Select Java Tools Jar",
  "SELECT_PYTHON_2": "Select Python 2.7 Executable",
  "SELECT_PYTHON_3": "Select Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Or PyPy 2.7 for speed) Executable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Or PyPy 3.x for speed) Executable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "You need to set your Python 2.7 (or PyPy 2.7 for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "You need to set your Python 3.x (or PyPy 3.x for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "You need to set your JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C:/Program Files/Java/JRE_xx/bin/java.exe)",
  "JAVAC_EXECUTABLE": "Javac Executable (Requires JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C:/Program Files/Java/JDK_xx/lib/tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C:/Program Files/Java/JRE_xx/lib/rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Optional Library Folder (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Hide bridge methods",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Hide synthetic class members",
  "DECOMPILE_INNER_CLASSES": "Decompile inner classes",
  "COLLAPSE_14_CLASS_REFERENCES": "Collapse 1.4 class references",
  "DECOMPILE_ASSERTIONS": "Decompile assertions",
  "HIDE_EMPTY_SUPER_INVOCATION": "Hide empty super invocation",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Hide empty default constructor",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompile generic signatures",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Assume return not throwing exceptions",
  "DECOMPILE_ENUMERATIONS": "Decompile enumerations",
  "REMOVE_GETCLASS_INVOCATION": "Remove getClass() invocation",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpret int 1 as boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Allow for not set synthetic attribute",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Consider nameless types as java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruct variable names from debug info",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Remove empty exception ranges",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finally structures",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Allow only ASCII characters in strings",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Rename ambiguous classes and class elements",

  "DECODE_ENUM_SWITCH": "Decode Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Decode String Switch",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Inner Classes",
  "REMOVE_BOILER_PLATE": "Remove Boiler Plate",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Remove Inner Class Synthetics",
  "DECODE_LAMBDAS": "Decode Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift  Constructor Init",
  "REMOVE_DEAD_METHODS": "Remove Dead Methods",
  "REMOVE_BAD_GENERICS": "Remove Bad Generics",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Show Version",
  "DECODE_FINALLY": "Decode Finally",
  "TIDY_MONITORS": "Tidy Monitors",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Comments",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Recover",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Show Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Hide UTF",
  "HIDE_LONG_STRINGS": "Hide Long Strings",
  "COMMENT_MONITORS": "Comment Monitors",
  "ALLOW_CORRECTING": "Allow Correcting",
  "LABELLED_BLOCKS": "Labelled Blocks",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Recover Type Clash",
  "RECOVER_TYPE__HINTS": "Recover Type  Hints",
  "FORCE_RETURNING_IFS": "Force Returning IFs",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Always Generate Exception Variable For Catch Blocks",
  "EXCLUDE_NESTED_TYPES": "Exclude Nested Types",
  "SHOW_DEBUG_LINE_NUMBERS": "Show Debug Line Numbers",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Include Line Numbers In Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Include Error Diagnostics",
  "SHOW_SYNTHETIC_MEMBERS": "Show Synthetic Members",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplify Member References",
  "MERGE_VARIABLES": "Merge Variables",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Force Explicit Imports",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Switch Blocks",
  "RETAIN_POINTLESS_SWITCHES": "Retain Pointless Switches",
  "RETAIN_REDUNDANT_CASTS": "Retain Redundant Casts",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Reload Resources",
  "RELOAD_RESOURCES_CONFIRM": "Are you sure you wish to reload the resources?",
  "SELECT_FILE_TITLE": "Select File or Folder to open in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Class Files or Zip/Jar/War Archives",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Select External Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin in js, java, python, ruby or groovy",
  "FOREIGN_LIBRARY_WARNING": "WARNING: With this being toggled off outdated libraries will NOT be removed.\n\rIt's also a security issue.\n\rONLY TURN IT OFF IF YOU KNOW WHAT YOU'RE DOING.",
  "RESET_TITLE": "{PRODUCT_NAME} - Reset Workspace",
  "RESET_CONFIRM": "Are you sure you want to reset the workspace?\n\rIt will also reset your file navigator and search.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Are you sure you want to exit?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - About - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Close All But This",
  "CLOSE_TAB": "Close Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Please send this error log to",
  "PLEASE_SEND_RESOURCES": "If you hold appropriate legal rights to the relevant class/jar/apk file please include that as well.",
  "ONE_PLUGIN_AT_A_TIME": "There is currently another plugin running right now, please wait for that to finish executing.",
  "ILLEGAL_ACCESS_ERROR": "Please use Java 15 or older to do this.",


  "FILES": "파일",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "빠른 파일 검색(파일 확장자 없음)",
  "WORK_SPACE": "작업 공간",
  "EXACT": "정확한",
  "SEARCH": "검색",
  "SEARCH_FROM": "검색 위치:",
  "SEARCH_STRING": "검색 문자열:",
  "SEARCH_REGEX": "정규식 검색:",
  "OWNER": "소유자:",
  "NAME": "이름:",
  "DESC": "설명:",
  "SAVE": "Save...",
  "SAVE_AS": "Save As...",
  "RESULTS": "Results",
  "REFRESH": "새롭게 하다",
  "ANNOTATION_NAME": "Annotation Name",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Exact Path",
  "MIN_SDK_VERSION": "Minimum SDK version",
  "PRINT_LINE_NUMBERS": "Print Line Numbers"
}

```

`src/main/resources/translations/lativan.json`:

```json
{
  "FILE": "Faili",
  "ADD": "Pievienot...",
  "NEW_WORKSPACE": "Jauna darbvieta",
  "RELOAD_RESOURCES": "Pārlādēt resursus",
  "RUN": "Palaist",
  "OPEN": "Atvērt...",
  "OPEN_UNSTYLED": "Atvērt",
  "QUICK_OPEN": "Ātrā atvēršana",
  "DELETE": "Dzēst",
  "NEW": "Jauns",
  "EXPAND": "Izvērst",
  "COLLAPSE": "Collapse",
  "COMPILE": "Sastādīt",
  "SAVE_AS_RUNNABLE_JAR": "Saglabāt kā izpildāmu burku...",
  "SAVE_AS_ZIP": "Saglabāt kā Zip...",
  "SAVE_AS_DEX": "Saglabāt kā DEX...",
  "SAVE_AS_APK": "Saglabāt kā APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Atklāto klašu dekompilēšana un saglabāšana",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompilēt un saglabāt visas klases",
  "RECENT_FILES": "Jaunākie faili",
  "ABOUT": "Par",
  "EXIT": "Iziet",

  "VIEW": "Skatīt",
  "VISUAL_SETTINGS": "Vizuālie iestatījumi",
  "PANE_1": "1. logs",
  "PANE_2": "2. logs",
  "PANE_3": "3. logs",
  "NONE": "Nav",
  "EDITABLE": "Rediģējams",

  "LANGUAGE": "Valoda",
  "FONT_SIZE": "Fonta lielums",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Rādīt failu cilnes nosaukumā",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Vārda vienkāršošana cilnes nosaukumā",
  "SYNCHRONIZED_VIEWING": "Sinhronizēta skatīšana",
  "SHOW_CLASS_METHODS": "Rādīt klases metodes",

  "WINDOW_THEME": "Logu tēma",
  "SYSTEM_THEME": "Sistēmas tēma",
  "DARK_THEME": "Tumšā tēma",
  "LIGHT_THEME": "Gaismas tēma",
  "ONE_DARK_THEME": "Viena tumša tēma",
  "SOLARIZED_DARK_THEME": "Solarizēta tumšā tēma",
  "SOLARIZED_LIGHT_THEME": "Saules gaismas tēma",
  "HIGH_CONTRAST_DARK_THEME": "Augsta kontrasta tumšā tēma",
  "HIGH_CONTRAST_LIGHT_THEME": "Augsta kontrasta gaismas tēma",
  "ONE_DARK": "Viens tumšs",
  "SOLARIZED_DARK": "Solarizēts tumšs",
  "SOLARIZED_LIGHT": "Saules gaisma",
  "HIGH_CONTRAST_DARK": "Augsts kontrasts Dark",
  "HIGH_CONTRAST_LIGHT": "Augsta kontrasta gaisma",
  "TEXT_AREA_THEME": "Teksta apgabala tēma",
  "DEFAULT_RECOMMENDED_LIGHT": "Noklusējuma iestatījumi (Ieteicamā gaisma)",
  "THEME_MATCH": "Tēmas sakritība (ieteicams)",
  "DARK": "Tumšs (ieteicams tumšs)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druīds (Tumšais)",
  "MONOKAI_DARK": "Monokai (tumšs)",

  "SETTINGS": "Iestatījumi",
  "COMPILE_ON_SAVE": "Salikt uz Saglabāt",
  "COMPILE_ON_REFRESH": "Salikt pēc atsvaidzināšanas",
  "REFRESH_ON_VIEW_CHANGE": "Atsvaidzināt pie skata maiņas",
  "DECODE_APK_RESOURCES": "Dekodēt APK resursi",
  "APK_CONVERSION": "APK konvertēšana",
  "APK_CONVERSION_DECODING": "APK konvertēšana",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Atjaunināšanas pārbaude",
  "DELETE_UNKNOWN_LIBS": "Dzēst ārzemju",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii kā teksts",
  "SET_PYTHON_27_EXECUTABLE": "Iestatiet Python 2.7 izpildāmo",
  "SET_PYTHON_30_EXECUTABLE": "Iestatiet Python 3.X izpildāmo",
  "SET_JRE_RT_LIBRARY": "JRE RT bibliotēkas iestatīšana",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Izvēles bibliotēkas mapes iestatīšana",
  "SET_JAVAC_EXECUTABLE": "Iestatiet Javac izpildāmo failu",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon iestatījumi",
  "CFR_SETTINGS": "CFR iestatījumi",
  "FERNFLOWER_SETTINGS": "FernFlower iestatījumi",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode dekompilētājs",
  "DEBUG_HELPERS": "Dzesēšanas palīgierīces",
  "APPEND_BRACKETS_TO_LABEL": "Etiķetes pievienošana iekavās",

  "PLUGINS": "Spraudņi",
  "OPEN_PLUGIN": "Atvērt spraudni...",
  "RECENT_PLUGINS": "Jaunākie spraudņi",
  "CODE_SEQUENCE_DIAGRAM": "Koda secības shēma",
  "MALICIOUS_CODE_SCANNER": "Ļaunprātīga koda skeneris",
  "SHOW_MAIN_METHODS": "Rādīt galvenās metodes",
  "SHOW_ALL_STRINGS": "Rādīt visas virknes",
  "REPLACE_STRINGS": "Aizstāt virknes",
  "STACK_FRAMES_REMOVER": "Stack Frames Remover",
  "ZKM_STRING_DECRYPTER": "ZKM virknes atšifrētājs",
  "ALLATORI_STRING_DECRYPTER": "Allatori virknes atšifrētājs",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Dešifrētājs",
  "VIEW_ANDROID_PERMISSIONS": "Android atļauju skatīšana",
  "VIEW_MANIFEST": "Apskatīt manifestu",
  "CHANGE_CLASSFILE_VERSIONS": "Mainīt klases datņu versijas",



  "PROCYON_DECOMPILER": "Procyon dekompilētājs",
  "CFR_DECOMPILER": "CFR dekompilētājs",
  "FERNFLOWER_DECOMPILER": "FernFlower dekompilētājs",
  "JADX_DECOMPILER": "JADX dekompilētājs",
  "JD_DECOMPILER": "JD-GUI dekompilētājs",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Kļūda",
  "NEW_JAVA_PLUGIN": "Jauns Java spraudnis",
  "NEW_JAVASCRIPT_PLUGIN": "Jauns Javascript spraudnis",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Ieteicamais labojums: Noklikšķiniet uz atsvaidzināt klasi, ja tas atkal neizdodas, mēģiniet citu dekompilatoru.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Ieteicamais labojums: Izmēģiniet View>Pane>Krakatau>Bytecode un iespējojiet Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "BRĪDINĀJUMS: Pašlaik nav izvēlēts neviens dekompilētājs. Izmēģiniet View>Pane un izvēlieties dekompilatoru.",
  "COMPILER_TIP": "Paturiet prātā, ka lielākā daļa dekompilatoru nevar izveidot kompilējamas klases.",
  "FIRST_OPEN_A_RESOURCE": "Vispirms atveriet resursu BCV iekšpusē (klases, jar, zip vai apk failu).",
  "FIRST_OPEN_A_CLASS": "Vispirms atveriet klases faila resursu BCV iekšpusē (jar, zip, apk, dex).",
  "FIRST_VIEW_A_CLASS": "Vispirms skatiet klases failu cilnē.",
  "DRAG_CLASS_JAR": "Velciet klase",

  "YES": "Jā",
  "NO": "Nē",
  "ERROR2": "Kļūda:",
  "PROCESS2": "Process:",
  "EXIT_VALUE_IS": "Iziešanas vērtība ir:",
  "JAVA_COMPILE_FAILED": "Java kompilēt neizdevās",
  "ERROR_COMPILING_CLASS": "Kļūda, kompilējot klasi",
  "COMPILER": "Paturiet prātā, ka lielākā daļa dekompilatoru nevar izveidot kompilējamas klases.",
  "SELECT_LIBRARY_FOLDER": "Atlasiet bibliotēkas mapi",
  "SELECT_JAVA_RT": "Izvēlieties JRE RT Jar",
  "SELECT_JAVA": "Izvēlieties Java izpildāmo programmu",
  "SELECT_JAVAC": "Izvēlieties Javac izpildāmo failu",
  "SELECT_JAVA_TOOLS": "Izvēlieties Java rīki Jar",
  "SELECT_PYTHON_2": "Izvēlieties Python 2.7 izpildāmo failu",
  "SELECT_PYTHON_3": "Atlasiet Python 3.x izpildāmo programmu",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (vai PyPy 2.7 ātrumam) Izpildāms",
  "PYTHON_3_EXECUTABLE": "Python 3.x (vai PyPy 3.x ātrumam) Izpildāms",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Jums ir jāiestata Python 2.7 (vai PyPy 2.7 ātrumam) izpildāmās programmas ceļš.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Jums ir jāiestata Python 3.x (vai PyPy 3.x ātrumam) izpildāmās programmas ceļš.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Jums ir jāiestata JRE RT bibliotēka.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Programmu faili\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java izpildāmā programma (iekšpusē JRE C:",
  "JAVAC_EXECUTABLE": "Javac izpildāmā programma (nepieciešams JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (JDK C iekšpusē:",
  "JAVA_RT_JAR": "Java RT Jar (JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Izvēles bibliotēkas mape (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Slēpt tilta metodes",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Slēpt sintētiskās klases locekļus",
  "DECOMPILE_INNER_CLASSES": "Dekompilēt iekšējās klases",
  "COLLAPSE_14_CLASS_REFERENCES": "Sakļaut 1.4 klases atsauces",
  "DECOMPILE_ASSERTIONS": "Dekompilēt apgalvojumus",
  "HIDE_EMPTY_SUPER_INVOCATION": "Paslēpt tukšu super izsaukumu",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Paslēpt tukšu noklusējuma konstruktoru",
  "DECOMPILE_GENERIC_SIGNATURES": "Vispārīgo parakstu dekompilēšana",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Pieņemt, ka atgriešanās nemet izņēmumus",
  "DECOMPILE_ENUMERATIONS": "Uzskaitījumu dekompilēšana",
  "REMOVE_GETCLASS_INVOCATION": "Noņemt getClass() izsaukumu",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretēt int 1 kā boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Atļaut nenoteikt sintētisko atribūtu",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Apsveriet beznosaukuma tipus kā java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Mainīgo nosaukumu atjaunošana no atkļūdošanas informācijas",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Tukšu izņēmumu diapazonu noņemšana",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline beidzot struktūras",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Atļaut tikai ASCII rakstzīmes virknēs",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Divdomīgu klašu un klases elementu pārdēvēšana",

  "DECODE_ENUM_SWITCH": "Dekodēšanas enuma slēdzis",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dekodēšanas virknes slēdzis",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Iekšējās klases",
  "REMOVE_BOILER_PLATE": "Katla plāksnes noņemšana",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Iekšējās klases sintētikas noņemšana",
  "DECODE_LAMBDAS": "Lambdas atšifrēšana",
  "LIFT__CONSTRUCTOR_INIT": "Pacelšanas konstruktors Init",
  "REMOVE_DEAD_METHODS": "Mirušo metožu noņemšana",
  "REMOVE_BAD_GENERICS": "Noņemiet sliktos ģenēriskos nosaukumus",
  "SUGAR_ASSERTS": "Cukurs apgalvo",
  "SUGAR_BOXING": "Cukura bokss",
  "SHOW_VERSION": "Rādīt versiju",
  "DECODE_FINALLY": "Atšifrējiet beidzot",
  "TIDY_MONITORS": "Kārtīgi monitori",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Komentāri",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "Stīgu buferis",
  "STRING_BUILDER": "Stīgu konstruktors",
  "SILENT": "Klusais",
  "RECOVER": "Atgūt",
  "OVERRIDE": "Pārslēgt",
  "SHOW_INFERRABLE": "Rādīt Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Spēka nosacījums Propagate",
  "HIDE_UTF": "Paslēpt UTF",
  "HIDE_LONG_STRINGS": "Slēpt garas virknes",
  "COMMENT_MONITORS": "Komentāru monitori",
  "ALLOW_CORRECTING": "Atļaut labošanu",
  "LABELLED_BLOCKS": "Bloki ar marķējumu",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Paslēpt Lang imports",
  "RECOVER_TYPE_CLASH": "Atgūt tipa sadursme",
  "RECOVER_TYPE__HINTS": "Atjaunošanas tipa norādījumi",
  "FORCE_RETURNING_IFS": "Spēks, kas atgriež IF",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Vienmēr ģenerēt izņēmuma mainīgo Catch blokiem",
  "EXCLUDE_NESTED_TYPES": "Izslēgt ieliktos tipus",
  "SHOW_DEBUG_LINE_NUMBERS": "Rādīt atkļūdošanas rindu numurus",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Iekļaut rindu numurus blokkodā",
  "INCLUDE_ERROR_DIAGNOSTICS": "Iekļaut kļūdu diagnostiku",
  "SHOW_SYNTHETIC_MEMBERS": "Rādīt sintētiskos elementus",
  "SIMPLIFY_MEMBER_REFERENCES": "Dalībnieku atsauču vienkāršošana",
  "MERGE_VARIABLES": "Apvienot mainīgos",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Piespiedu tiešs imports",
  "FLATTEN_SWITCH_BLOCKS": "Izlīdzināt slēdžu blokus",
  "RETAIN_POINTLESS_SWITCHES": "Saglabāt bezjēdzīgus slēdžus",
  "RETAIN_REDUNDANT_CASTS": "Saglabāt lieko aktieru sastāvu",
  "UNICODE_OUTPUT_ENABLED": "Ieslēgts Unicode izvades režīms",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Pārlādēt resursus",
  "RELOAD_RESOURCES_CONFIRM": "Vai esat pārliecināts, ka vēlaties atkārtoti ielādēt resursus?",
  "SELECT_FILE_TITLE": "Izvēlieties failu vai mapi, lai atvērtu {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, klases faili vai Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Izvēlieties Ārējais spraudnis",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV ārējais spraudnis js, java, python, ruby vai groovy valodā",
  "FOREIGN_LIBRARY_WARNING": "Brīdinājums: Ja šī opcija ir izslēgta, novecojušās bibliotēkas netiks noņemtas.\n\rTas ir arī drošības jautājums.\n\rIZSLĒDZIET TO TIKAI TAD, JA ZINĀT, KO DARĀT.",
  "RESET_TITLE": "{PRODUCT_NAME} - Atiestatīt darbvietu",
  "RESET_CONFIRM": "Vai esat pārliecināts, ka vēlaties atiestatīt darbvietu?\n\rTas arī atiestatīs failu navigatoru un meklēšanu.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Iziet",
  "EXIT_CONFIRM": "Vai esat pārliecināts, ka vēlaties iziet?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Par - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Spraudņa konsole",
  "CLOSE_ALL_BUT_THIS": "Aizvērt visu, izņemot šo",
  "CLOSE_TAB": "Aizvērt cilni",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Lūdzu, nosūtiet šo kļūdu žurnālu uz",
  "PLEASE_SEND_RESOURCES": "Ja jums ir attiecīgas likumīgas tiesības uz attiecīgo klasi.",
  "ONE_PLUGIN_AT_A_TIME": "Pašlaik darbojas cits spraudnis, lūdzu, pagaidiet, līdz tas tiks izpildīts.",
  "ILLEGAL_ACCESS_ERROR": "Lai to izdarītu, izmantojiet Java 15 vai jaunāku versiju.",


  "FILES": "Faili",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Ātra failu meklēšana (bez faila paplašinājuma)",
  "WORK_SPACE": "Darba telpa",
  "EXACT": "Precīzs",
  "SEARCH": "Meklēšana",
  "SEARCH_FROM": "Meklēt no:",
  "SEARCH_STRING": "Meklēšanas virkne:",
  "SEARCH_REGEX": "Meklēšanas regekss:",
  "OWNER": "Īpašnieks:",
  "NAME": "Vārds un uzvārds:",
  "DESC": "Apraksts:",
  "SAVE": "Saglabāt...",
  "SAVE_AS": "Saglabāt kā...",
  "RESULTS": "Rezultāti",
  "REFRESH": "Atsvaidzināt",
  "ANNOTATION_NAME": "Anotācijas nosaukums",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Precīzs ceļš",
  "MIN_SDK_VERSION": "Minimālā SDK versija",
  "PRINT_LINE_NUMBERS": "Drukāt rindu numurus"
}

```

`src/main/resources/translations/lithuanian.json`:

```json
{
  "FILE": "Failas",
  "ADD": "Pridėti...",
  "NEW_WORKSPACE": "Nauja darbo vieta",
  "RELOAD_RESOURCES": "Išteklių perkrovimas",
  "RUN": "Paleisti",
  "OPEN": "Atviras...",
  "OPEN_UNSTYLED": "Atviras",
  "QUICK_OPEN": "Greitas atidarymas",
  "DELETE": "Ištrinti",
  "NEW": "Naujas",
  "EXPAND": "Išplėsti",
  "COLLAPSE": "Žlugti",
  "COMPILE": "Kompiliavimas",
  "SAVE_AS_RUNNABLE_JAR": "Išsaugoti kaip paleidžiamą stiklainį...",
  "SAVE_AS_ZIP": "Išsaugoti kaip Zip...",
  "SAVE_AS_DEX": "Išsaugoti kaip DEX...",
  "SAVE_AS_APK": "Išsaugoti kaip APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompiliuoti ir išsaugoti atidarytas klases",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompiliuoti ir išsaugoti visas klases",
  "RECENT_FILES": "Naujausi failai",
  "ABOUT": "Apie",
  "EXIT": "Išeiti",

  "VIEW": "Peržiūrėti",
  "VISUAL_SETTINGS": "Vizualiniai nustatymai",
  "PANE_1": "1 langelis",
  "PANE_2": "2 langelis",
  "PANE_3": "3 langelis",
  "NONE": "Nėra",
  "EDITABLE": "Redaguojamas",

  "LANGUAGE": "Kalba",
  "FONT_SIZE": "Šrifto dydis",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Rodyti failą skirtuko pavadinime",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Pavadinimo supaprastinimas skirtuko pavadinime",
  "SYNCHRONIZED_VIEWING": "Sinchronizuota peržiūra",
  "SHOW_CLASS_METHODS": "Rodyti klasės metodus",

  "WINDOW_THEME": "Langų tema",
  "SYSTEM_THEME": "Sistemos tema",
  "DARK_THEME": "Tamsioji tema",
  "LIGHT_THEME": "Šviesos tema",
  "ONE_DARK_THEME": "Viena tamsi tema",
  "SOLARIZED_DARK_THEME": "Saulėtoji tamsioji tema",
  "SOLARIZED_LIGHT_THEME": "Saulės šviesos tema",
  "HIGH_CONTRAST_DARK_THEME": "Didelio kontrasto tamsi tema",
  "HIGH_CONTRAST_LIGHT_THEME": "Didelio kontrasto šviesos tema",
  "ONE_DARK": "Vienas tamsus",
  "SOLARIZED_DARK": "Tamsus saulės apšviestas",
  "SOLARIZED_LIGHT": "Saulės šviesos",
  "HIGH_CONTRAST_DARK": "Didelio kontrasto tamsus",
  "HIGH_CONTRAST_LIGHT": "Didelio kontrasto šviesa",
  "TEXT_AREA_THEME": "Teksto srities tema",
  "DEFAULT_RECOMMENDED_LIGHT": "Numatytoji (rekomenduojama šviesa)",
  "THEME_MATCH": "Temos rungtynės (rekomenduojama)",
  "DARK": "Tamsus (Rekomenduojamas tamsus)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druidas (Tamsusis)",
  "MONOKAI_DARK": "Monokai (tamsus)",

  "SETTINGS": "Nustatymai",
  "COMPILE_ON_SAVE": "Kompiliuoti išsaugojus",
  "COMPILE_ON_REFRESH": "Kompiliuoti atnaujinus",
  "REFRESH_ON_VIEW_CHANGE": "Atnaujinti pasikeitus vaizdui",
  "DECODE_APK_RESOURCES": "Dekoduoti APK ištekliai",
  "APK_CONVERSION": "APK konversija",
  "APK_CONVERSION_DECODING": "APK konversija",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Atnaujinimo patikra",
  "DELETE_UNKNOWN_LIBS": "Ištrinti užsienio",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii kaip tekstas",
  "SET_PYTHON_27_EXECUTABLE": "Nustatyti Python 2.7 Executable",
  "SET_PYTHON_30_EXECUTABLE": "Nustatyti Python 3.X vykdomąją programą",
  "SET_JRE_RT_LIBRARY": "Nustatyti JRE RT biblioteką",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Nustatyti pasirinktinį bibliotekos aplanką",
  "SET_JAVAC_EXECUTABLE": "Nustatyti Javac vykdomąją programą",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon nustatymai",
  "CFR_SETTINGS": "CFR nustatymai",
  "FERNFLOWER_SETTINGS": "FernFlower nustatymai",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Šešiaženklis kodas",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytekodo dekompiliatorius",
  "DEBUG_HELPERS": "Derinimo pagalbininkai",
  "APPEND_BRACKETS_TO_LABEL": "Prie etiketės pridėkite skliaustelius",

  "PLUGINS": "Įskiepiai",
  "OPEN_PLUGIN": "Atidaryti įskiepį...",
  "RECENT_PLUGINS": "Naujausi įskiepiai",
  "CODE_SEQUENCE_DIAGRAM": "Kodo sekos diagrama",
  "MALICIOUS_CODE_SCANNER": "Kenkėjiško kodo skaitytuvas",
  "SHOW_MAIN_METHODS": "Rodyti pagrindinius metodus",
  "SHOW_ALL_STRINGS": "Rodyti visas stygas",
  "REPLACE_STRINGS": "Pakeisti eilutes",
  "STACK_FRAMES_REMOVER": "Kamino rėmų šalintuvas",
  "ZKM_STRING_DECRYPTER": "ZKM styginių dešifratorius",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Peržiūrėti Android leidimus",
  "VIEW_MANIFEST": "Peržiūrėti manifestą",
  "CHANGE_CLASSFILE_VERSIONS": "Klasių failų versijų keitimas",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR dekompiliatorius",
  "FERNFLOWER_DECOMPILER": "FernFlower dekompiliatorius",
  "JADX_DECOMPILER": "JADX dekompiliatorius",
  "JD_DECOMPILER": "JD-GUI dekompiliatorius",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Klaida",
  "NEW_JAVA_PLUGIN": "Naujas Java įskiepis",
  "NEW_JAVASCRIPT_PLUGIN": "Naujas Javascript įskiepis",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Siūlomas pataisymas: Spustelėkite atnaujinti klasę, jei vėl nepavyksta, pabandykite kitą dekompiliatorių.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Siūlomas pataisymas: pabandykite View>Pane>Krakatau>Bytecode ir įjunkite Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ĮSPĖJIMAS: šiuo metu nėra pasirinktas joks dekompiliatorius. Pabandykite View>Pane ir pasirinkite dekompilatorių.",
  "COMPILER_TIP": "Atminkite, kad dauguma dekompiliatorių negali sukurti kompiliuojamų klasių",
  "FIRST_OPEN_A_RESOURCE": "Pirmiausia atidarykite BCV viduje esantį išteklių (klasę, jar, zip arba apk failą).",
  "FIRST_OPEN_A_CLASS": "Pirmiausia atidarykite klasės failo išteklių BCV viduje (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Pirmiausia peržiūrėkite klasės failą skirtuko viduje.",
  "DRAG_CLASS_JAR": "Vilkimo klasė",

  "YES": "Taip",
  "NO": "Ne",
  "ERROR2": "Klaida:",
  "PROCESS2": "Procesas:",
  "EXIT_VALUE_IS": "Išėjimo vertė yra:",
  "JAVA_COMPILE_FAILED": "Java kompiliavimas nepavyko",
  "ERROR_COMPILING_CLASS": "Klaida kompiliuojant klasę",
  "COMPILER": "Atminkite, kad dauguma dekompiliatorių negali sukurti kompiliuojamų klasių",
  "SELECT_LIBRARY_FOLDER": "Pasirinkite bibliotekos aplanką",
  "SELECT_JAVA_RT": "Pasirinkite JRE RT Jar",
  "SELECT_JAVA": "Pasirinkite Java vykdomąją programą",
  "SELECT_JAVAC": "Pasirinkite Javac vykdomąją programą",
  "SELECT_JAVA_TOOLS": "Pasirinkite Java Tools Jar",
  "SELECT_PYTHON_2": "Pasirinkite Python 2.7 Executable",
  "SELECT_PYTHON_3": "Pasirinkite Python 3.x vykdomąją programą",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (arba PyPy 2.7 dėl greičio) Vykdomoji programa",
  "PYTHON_3_EXECUTABLE": "Python 3.x (arba PyPy 3.x dėl greičio) Vykdomoji programa",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Reikia nustatyti Python 2.7 (arba PyPy 2.7, kad būtų greitesnis) vykdomosios programos kelią.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Reikia nustatyti Python 3.x (arba PyPy 3.x, kad būtų greitesnis) vykdomosios programos kelią.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Reikia nustatyti JRE RT biblioteką.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java vykdomoji programa (JRE C viduje):",
  "JAVAC_EXECUTABLE": "Javac vykdomoji programa (reikia JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (JDK C viduje):",
  "JAVA_RT_JAR": "Java RT Jar (JRE C viduje):",
  "OPTIONAL_LIBRARY_FOLDER": "Neprivalomas bibliotekos aplankas (Kompiuteris ir Krakatau)",

  "HIDE_BRIDGE_METHODS": "Paslėpti tilto metodus",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Sintetinių klasių narių slėpimas",
  "DECOMPILE_INNER_CLASSES": "Dekompiliuoti vidines klases",
  "COLLAPSE_14_CLASS_REFERENCES": "Žlugimas 1.4 klasės nuorodos",
  "DECOMPILE_ASSERTIONS": "Dekompiliuoti teiginius",
  "HIDE_EMPTY_SUPER_INVOCATION": "Paslėpti tuščią super iškvietimą",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Paslėpti tuščią numatytąjį konstruktorių",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompiliuoti bendruosius parašus",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Darykime prielaidą, kad grąžinimas nemeta išimčių",
  "DECOMPILE_ENUMERATIONS": "Dekompiliuoti išvardijimus",
  "REMOVE_GETCLASS_INVOCATION": "Pašalinti getClass() iškvietimą",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretuoti int 1 kaip loginis true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Leidimas nenustatyti sintetinio atributo",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Bevardžius tipus laikykite java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Kintamųjų vardų atkūrimas iš derinimo informacijos",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Pašalinti tuščius išimčių intervalus",
  "DEINLINE_FINALLY_STRUCTURES": "Galiausiai ištrinti struktūras",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "eilutėse leisti tik ASCII simbolius",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Dviprasmiškų klasių ir klasių elementų pavadinimų keitimas",

  "DECODE_ENUM_SWITCH": "Dekodavimo sąrašo perjungiklis",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dekoduoti eilutės jungiklį",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Vidinės klasės",
  "REMOVE_BOILER_PLATE": "Pašalinti katilo plokštę",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Pašalinti vidinės klasės sintetiką",
  "DECODE_LAMBDAS": "Iššifruoti lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Keltuvo konstruktorius Init",
  "REMOVE_DEAD_METHODS": "Pašalinti negyvus metodus",
  "REMOVE_BAD_GENERICS": "Pašalinti blogus bendrinius pavadinimus",
  "SUGAR_ASSERTS": "Cukrus teigia",
  "SUGAR_BOXING": "Cukraus boksas",
  "SHOW_VERSION": "Rodyti versiją",
  "DECODE_FINALLY": "Galiausiai iššifruokite",
  "TIDY_MONITORS": "Tvarkingi monitoriai",
  "LENIENT": "Lengvatinis",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Komentarai",
  "FORCE_TOP_SORT": "Priversti rūšiuoti iš viršaus",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "Styginių buferis",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Tylusis",
  "RECOVER": "Atkurti",
  "OVERRIDE": "Pakeisti",
  "SHOW_INFERRABLE": "Rodyti Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Jėgos sąlyga Skleisti",
  "HIDE_UTF": "Paslėpti UTF",
  "HIDE_LONG_STRINGS": "Paslėpti ilgas stygas",
  "COMMENT_MONITORS": "Komentarų monitoriai",
  "ALLOW_CORRECTING": "Leisti taisyti",
  "LABELLED_BLOCKS": "Etiketėmis paženklinti blokai",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Paslėpti Lang importas",
  "RECOVER_TYPE_CLASH": "Atkurti tipo susidūrimą",
  "RECOVER_TYPE__HINTS": "Atkurti tipo užuominos",
  "FORCE_RETURNING_IFS": "Priversti grąžinti IF",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG fiksavimas",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Visada generuokite išimties kintamąjį Catch blokams",
  "EXCLUDE_NESTED_TYPES": "Išskirti įterptinius tipus",
  "SHOW_DEBUG_LINE_NUMBERS": "Rodyti derinimo eilučių numerius",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Įtraukti eilučių numerius į baitekodą",
  "INCLUDE_ERROR_DIAGNOSTICS": "Įtraukti klaidų diagnostiką",
  "SHOW_SYNTHETIC_MEMBERS": "Rodyti sintetinius narius",
  "SIMPLIFY_MEMBER_REFERENCES": "Supaprastinti narių nuorodas",
  "MERGE_VARIABLES": "Sujungti kintamuosius",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Priversti naudoti aiškius tipo argumentus",
  "FORCE_EXPLICIT_IMPORTS": "Priverstinis aiškus importas",
  "FLATTEN_SWITCH_BLOCKS": "Suplokštinti jungiklių blokai",
  "RETAIN_POINTLESS_SWITCHES": "Išlaikyti nereikalingus jungiklius",
  "RETAIN_REDUNDANT_CASTS": "Išlaikyti nereikalingus liejinius",
  "UNICODE_OUTPUT_ENABLED": "Įjungtas Unicode išvedimas",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Perkrauti išteklius",
  "RELOAD_RESOURCES_CONFIRM": "Ar tikrai norite iš naujo įkelti išteklius?",
  "SELECT_FILE_TITLE": "Pasirinkite failą arba aplanką, kurį norite atidaryti {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, klasės failai arba Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Pasirinkite Išorinis įskiepis",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV išorinis įskiepis js, java, python, ruby arba groovy",
  "FOREIGN_LIBRARY_WARNING": "ĮSPĖJIMAS: Jei ši funkcija išjungta, pasenusios bibliotekos NEBUS pašalintos.\n\rTai taip pat yra saugumo problema.\n\rIŠJUNKITE JĄ TIK JEI ŽINOTE, KĄ DAROTE.",
  "RESET_TITLE": "{PRODUCT_NAME} - Iš naujo nustatyti darbo vietą",
  "RESET_CONFIRM": "Ar tikrai norite iš naujo nustatyti darbo erdvę?\n\rTaip pat bus iš naujo nustatyta failų naršyklė ir paieška.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Išeiti",
  "EXIT_CONFIRM": "Ar tikrai norite išeiti?",
  "ABOUT_TITLE": "„{PRODUCT_NAME}“ - apie - „{WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Įskiepio konsolė",
  "CLOSE_ALL_BUT_THIS": "Uždaryti viską, išskyrus šį",
  "CLOSE_TAB": "Uždaryti skirtuką",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Atsiųskite šį klaidų žurnalą adresu",
  "PLEASE_SEND_RESOURCES": "Jei turite atitinkamas teisines teises į atitinkamą klasę.",
  "ONE_PLUGIN_AT_A_TIME": "Šiuo metu veikia kitas įskiepis, palaukite, kol jis bus baigtas vykdyti.",
  "ILLEGAL_ACCESS_ERROR": "Naudokite \"Java 15\" arba naujesnę versiją.",


  "FILES": "Failai",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Greita failų paieška (be failo plėtinio)",
  "WORK_SPACE": "Darbo erdvė",
  "EXACT": "Tiksli",
  "SEARCH": "Paieška",
  "SEARCH_FROM": "Ieškoti iš:",
  "SEARCH_STRING": "Paieškos eilutė:",
  "SEARCH_REGEX": "Paieška Regex:",
  "OWNER": "Savininkas:",
  "NAME": "Vardas ir pavardė:",
  "DESC": "Aprašymas:",
  "SAVE": "Išsaugoti...",
  "SAVE_AS": "Išsaugoti kaip...",
  "RESULTS": "Rezultatai",
  "REFRESH": "Atnaujinti",
  "ANNOTATION_NAME": "Anotacijos pavadinimas",
  "MATCH_CASE": "Rungtynių atvejis",
  "EXACT_PATH": "Tikslus kelias",
  "MIN_SDK_VERSION": "Minimali SDK versija",
  "PRINT_LINE_NUMBERS": "Spausdinti eilučių numerius"
}

```

`src/main/resources/translations/malay.json`:

```json
{
  "FILE": "Fail",
  "ADD": "Tambah...",
  "NEW_WORKSPACE": "Ruang Kerja Baru",
  "RELOAD_RESOURCES": "Muat Semula Sumber",
  "RUN": "Lari",
  "OPEN": "Buka...",
  "OPEN_UNSTYLED": "Buka",
  "QUICK_OPEN": "Buka Cepat",
  "DELETE": "Padam",
  "NEW": "Baru",
  "EXPAND": "Kembangkan",
  "COLLAPSE": "Runtuh",
  "COMPILE": "Menyusun",
  "SAVE_AS_RUNNABLE_JAR": "Simpan Sebagai Jar yang Boleh Dijalankan ...",
  "SAVE_AS_ZIP": "Simpan Sebagai Zip ...",
  "SAVE_AS_DEX": "Simpan Sebagai DEX ...",
  "SAVE_AS_APK": "Simpan Sebagai APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Susun & Simpan Kelas Dibuka",
  "DECOMPILE_SAVE_ALL_CLASSES": "Susun & Simpan Semua Kelas",
  "RECENT_FILES": "Fail Terkini",
  "ABOUT": "Mengenai",
  "EXIT": "Keluar",

  "VIEW": "Pandangan",
  "VISUAL_SETTINGS": "Tetapan Visual",
  "PANE_1": "Panel 1",
  "PANE_2": "Panel 2",
  "PANE_3": "Panel 3",
  "NONE": "Tiada",
  "EDITABLE": "Boleh diedit",

  "LANGUAGE": "Bahasa",
  "FONT_SIZE": "Saiz huruf",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Tunjukkan Fail Dalam Tajuk Tab",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Permudahkan Nama Dalam Tajuk Tab",
  "SYNCHRONIZED_VIEWING": "Paparan Disegerakkan",
  "SHOW_CLASS_METHODS": "Tunjukkan Kaedah Kelas",

  "WINDOW_THEME": "Tema Tetingkap",
  "SYSTEM_THEME": "Tema Sistem",
  "DARK_THEME": "Tema gelap",
  "LIGHT_THEME": "Tema Cahaya",
  "ONE_DARK_THEME": "Tema Satu Gelap",
  "SOLARIZED_DARK_THEME": "Tema Gelap Solarized",
  "SOLARIZED_LIGHT_THEME": "Tema Cahaya Terpolarisasi",
  "HIGH_CONTRAST_DARK_THEME": "Tema Gelap Kontras Tinggi",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema Cahaya Kontras Tinggi",
  "ONE_DARK": "Satu Gelap",
  "SOLARIZED_DARK": "Gelap terpolarisasi",
  "SOLARIZED_LIGHT": "Cahaya Terpolarisasi",
  "HIGH_CONTRAST_DARK": "Gelap Kontras Tinggi",
  "HIGH_CONTRAST_LIGHT": "Lampu Kontras Tinggi",
  "TEXT_AREA_THEME": "Tema Kawasan Teks",
  "DEFAULT_RECOMMENDED_LIGHT": "Lalai (Cahaya yang Disyorkan)",
  "THEME_MATCH": "Padanan Tema (Disyorkan)",
  "DARK": "Gelap (Gelap Disyorkan)",
  "DARK_ALT": "Gelap-Alt",
  "DEFAULT_ALT": "Lalai-Alt",
  "ECLIPSE": "Gerhana",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Studio Visual",
  "DRUID_DARK": "Druid (Gelap)",
  "MONOKAI_DARK": "Monokai (Gelap)",

  "SETTINGS": "Tetapan",
  "COMPILE_ON_SAVE": "Susun Semasa Simpan",
  "COMPILE_ON_REFRESH": "Kompilasi Semasa Segarkan",
  "REFRESH_ON_VIEW_CHANGE": "Segarkan Perubahan Paparan",
  "DECODE_APK_RESOURCES": "Decode Sumber APK",
  "APK_CONVERSION": "Penukaran APK",
  "APK_CONVERSION_DECODING": "Penukaran / Penyahkodan APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Nyatakan",
  "UPDATE_CHECK": "Periksa Kemas kini",
  "DELETE_UNKNOWN_LIBS": "Padamkan Lib yang Asing / ketinggalan zaman",
  "FORCE_PURE_ASCII_AS_TEXT": "Paksa Ascii Murni Sebagai Teks",
  "SET_PYTHON_27_EXECUTABLE": "Tetapkan Python 2.7 Boleh Dilaksanakan",
  "SET_PYTHON_30_EXECUTABLE": "Tetapkan Python 3.X Boleh Dilaksanakan",
  "SET_JRE_RT_LIBRARY": "Tetapkan Perpustakaan JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Tetapkan Folder Perpustakaan Pilihan",
  "SET_JAVAC_EXECUTABLE": "Tetapkan Javac Boleh Dilaksanakan",

  "JAVA": "Jawa",
  "PROCYON_SETTINGS": "Tetapan Procyon",
  "CFR_SETTINGS": "Tetapan CFR",
  "FERNFLOWER_SETTINGS": "Tetapan FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali / Dex",
  "HEXCODE": "Kod Hex",
  "BYTECODE": "Kod byk",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Pengurai Bytecode",
  "DEBUG_HELPERS": "Pembantu Debug",
  "APPEND_BRACKETS_TO_LABEL": "Lampirkan Kurungan ke Label",

  "PLUGINS": "Pemalam",
  "OPEN_PLUGIN": "Buka Pemalam ...",
  "RECENT_PLUGINS": "Plugin Terkini",
  "CODE_SEQUENCE_DIAGRAM": "Rajah Urutan Kod",
  "MALICIOUS_CODE_SCANNER": "Pengimbas Kod Berbahaya",
  "SHOW_MAIN_METHODS": "Tunjukkan Kaedah Utama",
  "SHOW_ALL_STRINGS": "Tunjukkan Semua Rentetan",
  "REPLACE_STRINGS": "Ganti Rentetan",
  "STACK_FRAMES_REMOVER": "Penghilang Bingkai Tumpukan",
  "ZKM_STRING_DECRYPTER": "Decrypter Rentetan ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Lihat Kebenaran Android",
  "VIEW_MANIFEST": "Lihat Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Tukar Versi ClassFile",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "Pengurai CFR",
  "FERNFLOWER_DECOMPILER": "Pengurai FernFlower",
  "JADX_DECOMPILER": "Pengurai JADX",
  "JD_DECOMPILER": "Pengurai JD-GUI",
  "BYTECODE_DISASSEMBLER": "Pembongkaran Bytecode",
  "DISASSEMBLER": "Pembongkar",

  "ERROR": "Ralat",
  "NEW_JAVA_PLUGIN": "Plugin Java Baru",
  "NEW_JAVASCRIPT_PLUGIN": "Plugin Javascript Baru",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Perbaikan yang Disarankan: Klik kelas muat semula, jika gagal sekali lagi, cubalah penyahkompilasi lain.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Pembaikan yang Disarankan: Cuba Lihat> Panel> Krakatau> Bytecode dan aktifkan Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "AMARAN: Tidak ada penyahkompilasi yang dipilih. Cuba Lihat> Panel dan pilih penyahkompilasi.",
  "COMPILER_TIP": "Perlu diingat bahawa kebanyakan pengurai tidak dapat menghasilkan kelas yang dapat disusun",
  "FIRST_OPEN_A_RESOURCE": "Pertama buka sumber di dalam BCV (kelas, balang, zip atau fail apk)",
  "FIRST_OPEN_A_CLASS": "Pertama buka sumber classfile di dalam BCV (balang, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Mula-mula melihat fail kelas di dalam tab.",
  "DRAG_CLASS_JAR": "Seret kelas / balang / zip / APK / DEX di sini",

  "YES": "Ya",
  "NO": "Tidak",
  "ERROR2": "Ralat:",
  "PROCESS2": "Proses:",
  "EXIT_VALUE_IS": "Nilai Keluar adalah:",
  "JAVA_COMPILE_FAILED": "Kompilasi Java Gagal",
  "ERROR_COMPILING_CLASS": "Ralat menyusun kelas",
  "COMPILER": "Perlu diingat bahawa kebanyakan pengurai tidak dapat menghasilkan kelas yang dapat disusun",
  "SELECT_LIBRARY_FOLDER": "Pilih Folder Perpustakaan",
  "SELECT_JAVA_RT": "Pilih JRE RT Jar",
  "SELECT_JAVA": "Pilih Java Boleh Dilaksanakan",
  "SELECT_JAVAC": "Pilih Javac Executable",
  "SELECT_JAVA_TOOLS": "Pilih Jar Alat Java",
  "SELECT_PYTHON_2": "Pilih Python 2.7 Boleh Dilaksanakan",
  "SELECT_PYTHON_3": "Pilih Python 3.x Boleh Dilaksanakan",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Atau PyPy 2.7 untuk kelajuan) Boleh dilaksanakan",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Atau PyPy 3.x untuk kelajuan) Boleh dilaksanakan",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Anda perlu menetapkan jalan pelaksanaan Python 2.7 (atau PyPy 2.7 untuk kelajuan) anda.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Anda perlu menetapkan jalan pelaksanaan Python 3.x (atau PyPy 3.x for speed) anda.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Anda perlu menetapkan Perpustakaan JRE RT anda.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "Java Dapat Dilaksanakan (Di Dalam JRE C: / Fail Program / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Javac Boleh Dilaksanakan (Memerlukan JDK C: / Fail Program / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "Jar Alat Java (Di Dalam JDK C: / Fail Program / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Di Dalam JRE C: / File Program / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Folder Perpustakaan Pilihan (Penyusun & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Sembunyikan kaedah jambatan",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Sembunyikan ahli kelas sintetik",
  "DECOMPILE_INNER_CLASSES": "Menguraikan kelas dalaman",
  "COLLAPSE_14_CLASS_REFERENCES": "Runtuhkan 1.4 rujukan kelas",
  "DECOMPILE_ASSERTIONS": "Tegaskan penyataan",
  "HIDE_EMPTY_SUPER_INVOCATION": "Sembunyikan ajakan super kosong",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Sembunyikan pembina lalai kosong",
  "DECOMPILE_GENERIC_SIGNATURES": "Susun tandatangan generik",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Anggap kembali tidak membuang pengecualian",
  "DECOMPILE_ENUMERATIONS": "Menghuraikan penghitungan",
  "REMOVE_GETCLASS_INVOCATION": "Keluarkan permintaan getClass ()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Tafsirkan int 1 sebagai boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Benarkan untuk tidak menetapkan atribut sintetik",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Pertimbangkan jenis tanpa nama sebagai java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Bina semula nama pemboleh ubah dari maklumat debug",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Keluarkan julat pengecualian kosong",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline akhirnya membina",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Benarkan watak ASCII sahaja dalam rentetan",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Ganti nama kelas dan elemen kelas yang tidak jelas",

  "DECODE_ENUM_SWITCH": "Decode Enum Switch",
  "SUGARENUMS": "GulaEnum",
  "DECODE_STRING_SWITCH": "Suis Rentetan Dekod",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Pengumpul",
  "INNER_CLASSES": "Kelas Dalam",
  "REMOVE_BOILER_PLATE": "Tanggalkan Boiler Plate",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Buang Sintetik Kelas Dalam",
  "DECODE_LAMBDAS": "Menyahkod Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift Konstruktor Angkat",
  "REMOVE_DEAD_METHODS": "Keluarkan Kaedah Mati",
  "REMOVE_BAD_GENERICS": "Buang Generik Buruk",
  "SUGAR_ASSERTS": "Tegasan Gula",
  "SUGAR_BOXING": "Tinju Gula",
  "SHOW_VERSION": "Tunjukkan Versi",
  "DECODE_FINALLY": "Nyahkod Akhirnya",
  "TIDY_MONITORS": "Monitor yang kemas",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Komen",
  "FORCE_TOP_SORT": "Susun Atas Paksa",
  "FORCE_TOP_SORT_AGGRESS": "Paksaan Jenis Atas Paksa",
  "FORCE_EXCEPTION_PRUNE": "Prune Pengecualian Paksa",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "Pembina tali",
  "SILENT": "Senyap",
  "RECOVER": "Pulihkan",
  "OVERRIDE": "Tolak",
  "SHOW_INFERRABLE": "Tunjukkan Kesimpulan",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Sembunyikan UTF",
  "HIDE_LONG_STRINGS": "Sembunyikan Rentetan Panjang",
  "COMMENT_MONITORS": "Monitor Komen",
  "ALLOW_CORRECTING": "Benarkan Membetulkan",
  "LABELLED_BLOCKS": "Blok berlabel",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Sembunyikan Import Lang",
  "RECOVER_TYPE_CLASH": "Pulihkan Jenis Pertembungan",
  "RECOVER_TYPE__HINTS": "Pulihkan Petua Jenis",
  "FORCE_RETURNING_IFS": "Paksa IF Returning",
  "FOR_LOOP_AGG_CAPTURE": "Untuk Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Sentiasa Menjana Pembolehubah Pengecualian Untuk Catch Blocks",
  "EXCLUDE_NESTED_TYPES": "Kecualikan Jenis Bersarang",
  "SHOW_DEBUG_LINE_NUMBERS": "Tunjukkan Nombor Garisan Debug",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Sertakan Nombor Baris Dalam Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Sertakan Diagnostik Ralat",
  "SHOW_SYNTHETIC_MEMBERS": "Tunjukkan Ahli Sintetik",
  "SIMPLIFY_MEMBER_REFERENCES": "Permudahkan Rujukan Anggota",
  "MERGE_VARIABLES": "Gabungkan Pemboleh ubah",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Hujah Jenis Eksplisit Paksa",
  "FORCE_EXPLICIT_IMPORTS": "Paksa Import Eksplisit",
  "FLATTEN_SWITCH_BLOCKS": "Ratakan Blok Suis",
  "RETAIN_POINTLESS_SWITCHES": "Kekalkan Suis Tanpa Titik",
  "RETAIN_REDUNDANT_CASTS": "Kekalkan Pelbagai Kelebihan",
  "UNICODE_OUTPUT_ENABLED": "Output Unicode Diaktifkan",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Muat semula Sumber",
  "RELOAD_RESOURCES_CONFIRM": "Adakah anda pasti mahu memuatkan semula sumber?",
  "SELECT_FILE_TITLE": "Pilih Fail atau Folder untuk dibuka di {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, Fail Kelas atau Arkib Zip / Jar / Perang",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Pilih Pemalam Luaran",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin dalam js, java, python, ruby ​​atau groovy",
  "FOREIGN_LIBRARY_WARNING": "PERINGATAN: Dengan ini, perpustakaan yang sudah lapuk tidak akan dikeluarkan.\n\rIni juga masalah keselamatan.\n\rHANYA NONAKTIFKAN JIKA ANDA TAHU APA YANG ANDA LAKUKAN.",
  "RESET_TITLE": "{PRODUCT_NAME} - Tetapkan semula Ruang Kerja",
  "RESET_CONFIRM": "Adakah anda pasti mahu menetapkan semula ruang kerja?\n\rIni juga akan menetapkan semula navigator dan carian fail anda.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Keluar",
  "EXIT_CONFIRM": "Anda pasti untuk keluar?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Tentang - {LAMAN WEB} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Konsol Pemalam",
  "CLOSE_ALL_BUT_THIS": "Tutup Semua Tetapi Ini",
  "CLOSE_TAB": "Tutup Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Hantarkan log ralat ini ke",
  "PLEASE_SEND_RESOURCES": "Sekiranya anda mempunyai hak undang-undang yang sesuai untuk fail kelas / balang / apk yang berkaitan, sila sertakan juga.",
  "ONE_PLUGIN_AT_A_TIME": "Pada masa ini terdapat satu lagi pemalam yang sedang berjalan sekarang, sila tunggu sehingga ia selesai dilaksanakan.",
  "ILLEGAL_ACCESS_ERROR": "Sila gunakan Java 15 atau lebih lama untuk melakukan ini.",


  "FILES": "Fail",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Pencarian fail pantas (tiada peluasan fail)",
  "WORK_SPACE": "Ruang Kerja",
  "EXACT": "Tepat",
  "SEARCH": "Cari",
  "SEARCH_FROM": "Cari Dari: ",
  "SEARCH_STRING": "Rentetan Carian: ",
  "SEARCH_REGEX": "Cari Regex: ",
  "OWNER": "Pemilik: ",
  "NAME": "Nama: ",
  "DESC": "Huraian: ",
  "SAVE": "Jimat ...",
  "SAVE_AS": "Simpan sebagai...",
  "RESULTS": "Keputusan",
  "REFRESH": "Segarkan",
  "ANNOTATION_NAME": "Nama Anotasi",
  "MATCH_CASE": "Kes Perlawanan",
  "EXACT_PATH": "Laluan Tepat",
  "MIN_SDK_VERSION": "Versi SDK minimum",
  "PRINT_LINE_NUMBERS": "Cetak Nombor Baris"
}

```

`src/main/resources/translations/mandarin.json`:

```json
{
  "FILE": "文件",
  "ADD": "打开文件",
  "NEW_WORKSPACE": "新建工作区",
  "RELOAD_RESOURCES": "重新加载资源",
  "RUN": "运行",
  "OPEN": "打开",
  "OPEN_UNSTYLED": "打开",
  "QUICK_OPEN": "快速打开",
  "DELETE": "删除",
  "NEW": "新的",
  "EXPAND": "扩张",
  "COLLAPSE": "坍塌",
  "COMPILE": "编译",
  "SAVE_AS_RUNNABLE_JAR": "另存为可运行 JAR",
  "SAVE_AS_ZIP": "另存为 ZIP",
  "SAVE_AS_DEX": "另存为 DEX",
  "SAVE_AS_APK": "另存为 APK",
  "DECOMPILE_SAVE_OPENED_CLASSES": "反编译并保存打开的类",
  "DECOMPILE_SAVE_ALL_CLASSES": "反编译并保存所有类",
  "RECENT_FILES": "最近的文件",
  "ABOUT": "关于",
  "EXIT": "退出",

  "VIEW": "显示",
  "VISUAL_SETTINGS": "界面设置",
  "PANE_1": "面板 1",
  "PANE_2": "面板 2",
  "PANE_3": "面板 3",
  "NONE": "无",
  "EDITABLE": "可编辑",

  "LANGUAGE": "语言",
  "FONT_SIZE": "字体大小",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "标签页标题显示文件名",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "简化标签页标题文件名",
  "SYNCHRONIZED_VIEWING": "同步视图",
  "SHOW_CLASS_METHODS": "显示类方法",

  "WINDOW_THEME": "窗口主题",
  "SYSTEM_THEME": "系统主题",
  "DARK_THEME": "深色主题",
  "LIGHT_THEME": "浅色主题",
  "ONE_DARK_THEME": "一个黑暗主题",
  "SOLARIZED_DARK_THEME": "Solarized 深色主题",
  "SOLARIZED_LIGHT_THEME": "Solarized 浅色主题",
  "HIGH_CONTRAST_DARK_THEME": "高对比度深色主题",
  "HIGH_CONTRAST_LIGHT_THEME": "High Contrast Light 主题",
  "ONE_DARK": "一个黑暗",
  "SOLARIZED_DARK": "Solarized 深色",
  "SOLARIZED_LIGHT": "Solarized Light",
  "HIGH_CONTRAST_DARK": "高对比度暗",
  "HIGH_CONTRAST_LIGHT": "High Contrast Light",
  "TEXT_AREA_THEME": "文本区主题",
  "DEFAULT_RECOMMENDED_LIGHT": "浅色(默认推荐)",
  "THEME_MATCH": "主题搭配（推荐)",
  "DARK": "深色",
  "DARK_ALT": "暗色",
  "DEFAULT_ALT": "默认",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid(深色)",
  "MONOKAI_DARK": "Monokai(深色)",

  "SETTINGS": "设置",
  "COMPILE_ON_SAVE": "保存时编译",
  "COMPILE_ON_REFRESH": "刷新时编译",
  "REFRESH_ON_VIEW_CHANGE": "视图更改时刷新",
  "DECODE_APK_RESOURCES": "解码 APK 资源",
  "APK_CONVERSION": "APK 转换",
  "APK_CONVERSION_DECODING": "APK 转换/解码",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "检查更新",
  "DELETE_UNKNOWN_LIBS": "删除外库和过时库",
  "FORCE_PURE_ASCII_AS_TEXT": "强制纯 ASCII 文本",
  "SET_PYTHON_27_EXECUTABLE": "设置 Python 2.7 可执行文件",
  "SET_PYTHON_30_EXECUTABLE": "设置 Python 3.x 可执行文件",
  "SET_JRE_RT_LIBRARY": "设置 JRE RT 库",
  "SET_OPTIONAL_LIBRARY_FOLDER": "设置可选的库文件夹",
  "SET_JAVAC_EXECUTABLE": "设置 javac 可执行文件",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon 设置",
  "CFR_SETTINGS": "CFR 设置",
  "FERNFLOWER_SETTINGS": "FernFlower 设置",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali/Dex",
  "HEXCODE": "十六进制",
  "BYTECODE": "字节码",
  "ASM_TEXTIFY": "汇编文本",

  "BYTECODE_DECOMPILER": "字节码反编译器",
  "DEBUG_HELPERS": "调试辅助器",
  "APPEND_BRACKETS_TO_LABEL": "标签带花括号",

  "PLUGINS": "插件",
  "OPEN_PLUGIN": "打开插件",
  "RECENT_PLUGINS": "最近的插件",
  "CODE_SEQUENCE_DIAGRAM": "代码流程图解",
  "MALICIOUS_CODE_SCANNER": "恶意代码扫描器",
  "SHOW_MAIN_METHODS": "显示主方法",
  "SHOW_ALL_STRINGS": "显示所有字符串",
  "REPLACE_STRINGS": "替换字符串",
  "STACK_FRAMES_REMOVER": "栈帧移除器",
  "ZKM_STRING_DECRYPTER": "ZKM 字符串解密器",
  "ALLATORI_STRING_DECRYPTER": "Allatori String 解密器",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray 解密器",
  "VIEW_ANDROID_PERMISSIONS": "查看 Android 权限",
  "VIEW_MANIFEST": "查看 MANIFEST 清单",
  "CHANGE_CLASSFILE_VERSIONS": "更改类文件编译版本",



  "PROCYON_DECOMPILER": "Procyon 反编译器",
  "CFR_DECOMPILER": "CFR 反编译器",
  "FERNFLOWER_DECOMPILER": "FernFlower 反编译器",
  "JADX_DECOMPILER": "JADX 反编译器",
  "JD_DECOMPILER": "JD-GUI 反编译器",
  "BYTECODE_DISASSEMBLER": "字节码反汇编",
  "DISASSEMBLER": "反汇编",

  "ERROR": "错误",
  "NEW_JAVA_PLUGIN": "新 Java 插件",
  "NEW_JAVASCRIPT_PLUGIN": "新 Javascript 插件",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "建议的办法：单击刷新类。如果又失败请尝试别的反编译器。",
  "SUGGESTED_FIX_COMPILER_ERROR": "建议的办法：尝试“视图>面板>Krakatau>字节码”并启用可编辑。",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "警告：当前没有选择反编译器。尝试查看>窗格并选择一个反编译器。",
  "COMPILER_TIP": "请记住，大多数反编译器无法生成可编译的类",
  "FIRST_OPEN_A_RESOURCE": "首先打开 ByteCodeViewer 里一个资源(class/jar/zip/apk/dex)",
  "FIRST_OPEN_A_CLASS": "首先打开 ByteCodeViewer 里一个类资源(jar、zip、apk、dex)",
  "FIRST_VIEW_A_CLASS": "首先查看选项卡内的类文件。",
  "DRAG_CLASS_JAR": "拖放 class/jar/zip/apk/dex 到这",

  "YES": "是",
  "NO": "否",
  "ERROR2": "错误：",
  "PROCESS2": "过程：",
  "EXIT_VALUE_IS": "退出值为：",
  "JAVA_COMPILE_FAILED": "Java 编译失败",
  "ERROR_COMPILING_CLASS": "编译类时出错",
  "COMPILER": "请记住，大多数反编译器无法生成可编译的类",
  "SELECT_LIBRARY_FOLDER": "选择库文件夹",
  "SELECT_JAVA_RT": "选择 JRE RT Jar",
  "SELECT_JAVA": "选择 Java 可执行文件",
  "SELECT_JAVAC": "选择 javac 可执行文件",
  "SELECT_JAVA_TOOLS": "选择 Java 工具 Jar",
  "SELECT_PYTHON_2": "选择 Python 2.7 可执行文件",
  "SELECT_PYTHON_3": "选择 Python 3.x 可执行文件",
  "PYTHON_2_EXECUTABLE": "Python 2.7（或 PyPy 2.7 以提高速度)可执行文件",
  "PYTHON_3_EXECUTABLE": "Python 3.x(或 PyPy 3.x 以提高速度)可执行文件",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "您需要设置 Python 2.7(或 PyPy 2.7 以提高速度)可执行路径。",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "您需要设置 Python 3.x(或 PyPy 3.x 以提高速度)可执行路径。",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "您需要设置 JRE RT 库。",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java 可执行文件（JRE C:/Program Files/Java/JRE_xx/bin/java.exe 内部)",
  "JAVAC_EXECUTABLE": "Javac 可执行文件（需要 JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Java 工具 Jar(JDK C:/Program Files/Java/JDK_xx/lib/tools.jar 内部)",
  "JAVA_RT_JAR": "Java RT Jar(JRE C:/Program Files/Java/JRE_xx/lib/rt.jar 内部)",
  "OPTIONAL_LIBRARY_FOLDER": "可选库文件夹(编译器和 Krakatau)",

  "HIDE_BRIDGE_METHODS": "隐藏桥接方法",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "隐藏合成类成员",
  "DECOMPILE_INNER_CLASSES": "反编译内部类",
  "COLLAPSE_14_CLASS_REFERENCES": "折叠 1.4 类引用",
  "DECOMPILE_ASSERTIONS": "反编译断言",
  "HIDE_EMPTY_SUPER_INVOCATION": "隐藏 super() 调用",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "隐藏空的默认构造函数",
  "DECOMPILE_GENERIC_SIGNATURES": "反编译泛型签名",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "假设返回不抛出异常",
  "DECOMPILE_ENUMERATIONS": "反编译枚举",
  "REMOVE_GETCLASS_INVOCATION": "删除 getClass() 调用",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "将 int 1 解释为 boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "允许不设置合成属性",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "将无名类型视为 java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "从调试信息重建变量名",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "删除空的异常捕获",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finally 结构",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "字符串中只允许 ASCII 字符",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "重命名不明确的类和类元素",

  "DECODE_ENUM_SWITCH": "解码 枚举 开关",
  "SUGARENUMS": "断言语法糖",
  "DECODE_STRING_SWITCH": "解码字符串开关",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "内部类",
  "REMOVE_BOILER_PLATE": "移除样板代码",
  "REMOVE_INNER_CLASS_SYNTHETICS": "删除内部类合成",
  "DECODE_LAMBDAS": "解码 Lambda 表达式",
  "LIFT__CONSTRUCTOR_INIT": "提升构造函数初始化",
  "REMOVE_DEAD_METHODS": "删除无用方法",
  "REMOVE_BAD_GENERICS": "删除错误的泛型",
  "SUGAR_ASSERTS": "断言语法糖",
  "SUGAR_BOXING": "自动装箱 语法糖",
  "SHOW_VERSION": "显示版本",
  "DECODE_FINALLY": "译解 finally",
  "TIDY_MONITORS": "微小监视器",
  "LENIENT": "宽容",
  "DUMP_CLASSPATH": "转储类路径",
  "COMMENTS": "注释",
  "FORCE_TOP_SORT": "强制顶部排序",
  "FORCE_TOP_SORT_AGGRESS": "强制顶部排序攻击",
  "FORCE_EXCEPTION_PRUNE": "强制清除异常",
  "STRING_BUFFER": "字符串缓冲区",
  "STRING_BUILDER": "String Builder",
  "SILENT": "静默",
  "RECOVER": "还原",
  "OVERRIDE": "override",
  "SHOW_INFERRABLE": "显示可推断",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "强制条件传播",
  "HIDE_UTF": "隐藏 UTF",
  "HIDE_LONG_STRINGS": "隐藏长字符串",
  "COMMENT_MONITORS": "评论监视器",
  "ALLOW_CORRECTING": "允许更正",
  "LABELLED_BLOCKS": "标记块",
  "J14CLASSOBJ": "J14类OBJ",
  "HIDE_LANG_IMPORTS": "隐藏 lang 导包",
  "RECOVER_TYPE_CLASH": "还原类型冲突",
  "RECOVER_TYPE__HINTS": "恢复类型提示",
  "FORCE_RETURNING_IFS": "强制返回 IF",
  "FOR_LOOP_AGG_CAPTURE": "For 循环 AGG 捕获",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "始终为 Catch 块生成异常变量",
  "EXCLUDE_NESTED_TYPES": "排除嵌套类型",
  "SHOW_DEBUG_LINE_NUMBERS": "显示调试行号",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "在字节码中包含行号",
  "INCLUDE_ERROR_DIAGNOSTICS": "包括错误诊断",
  "SHOW_SYNTHETIC_MEMBERS": "显示合成成员",
  "SIMPLIFY_MEMBER_REFERENCES": "简化成员引用",
  "MERGE_VARIABLES": "合并变量",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "强制显示明确的类型参数",
  "FORCE_EXPLICIT_IMPORTS": "强制显式导入",
  "FLATTEN_SWITCH_BLOCKS": "展平开关块",
  "RETAIN_POINTLESS_SWITCHES": "保留无意义的开关",
  "RETAIN_REDUNDANT_CASTS": "保留多余的强制转换",
  "UNICODE_OUTPUT_ENABLED": "启用 Unicode 输出",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - 重新加载资源",
  "RELOAD_RESOURCES_CONFIRM": "您确定要重新加载资源吗？",
  "SELECT_FILE_TITLE": "选择要在 {BCV} 中打开的文件或文件夹",
  "SELECT_FILE_DESCRIPTION": "APK、DEX、类文件或 Zip/Jar/War 档案",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "选择外部插件",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "js、java、python、ruby 或 groovy 中的 BCV 外部插件",
  "FOREIGN_LIBRARY_WARNING": "警告：关闭此功能后，将不会删除过时的库。 {NEWLINE}这也是一个安全问题。\n\r仅当您知道自己在做什么时才将其关闭。",
  "RESET_TITLE": "{PRODUCT_NAME} - 重置工作区",
  "RESET_CONFIRM": "您确定要重置工作区吗？ {NEWLINE}它还会重置您的文件导航器和搜索。",
  "EXIT_TITLE": "{PRODUCT_NAME} - 退出",
  "EXIT_CONFIRM": "你确定要退出？",
  "ABOUT_TITLE": "{PRODUCT_NAME} - 关于 - {WEBSITE} | {待定}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - 插件控制台",
  "CLOSE_ALL_BUT_THIS": "除此关闭所有",
  "CLOSE_TAB": "关闭标签",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "请将此错误日志发送至",
  "PLEASE_SEND_RESOURCES": "如果您对相关 class/jar/apk 文件拥有适当的合法权利，请也包括在内。",
  "ONE_PLUGIN_AT_A_TIME": "目前正在运行另一个插件，请等待它完成执行。",
  "ILLEGAL_ACCESS_ERROR": "请使用 Java 15 或更早版本来执行此操作。",


  "FILES": "文件",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "快速文件搜索 (无扩展名)",
  "WORK_SPACE": "工作区",
  "EXACT": "精确",
  "SEARCH": "搜索",
  "SEARCH_FROM": "搜索自：",
  "SEARCH_STRING": "搜索字符串：",
  "SEARCH_REGEX": "搜索正则：",
  "OWNER": "所有者：",
  "NAME": "名称：",
  "DESC": "描述：",
  "SAVE": "保存",
  "SAVE_AS": "另存为",
  "RESULTS": "结果",
  "REFRESH": "刷新",
  "ANNOTATION_NAME": "注释名称",
  "MATCH_CASE": "相符",
  "EXACT_PATH": "确切路径",
  "MIN_SDK_VERSION": "最低 SDK 版本",
  "PRINT_LINE_NUMBERS": "打印行号"
}

```

`src/main/resources/translations/nederlands.json`:

```json
{
  "FILE": "Bestand",
  "ADD": "Voeg toe...",
  "NEW_WORKSPACE": "Nieuwe Werkruimte",
  "RELOAD_RESOURCES": "Hulpbronnen opnieuw laden",
  "RUN": "Run",
  "OPEN": "Open...",
  "OPEN_UNSTYLED": "Open",
  "QUICK_OPEN": "Snel Open",
  "DELETE": "Delete",
  "NEW": "Nieuw",
  "EXPAND": "Uitbreiden",
  "COLLAPSE": "Instorten",
  "COMPILE": "Compileren",
  "SAVE_AS_RUNNABLE_JAR": "Save As Runnable Jar...",
  "SAVE_AS_ZIP": "Opslaan als Zip...",
  "SAVE_AS_DEX": "Opslaan als DEX...",
  "SAVE_AS_APK": "Opslaan als APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Geopende klassen decompileren en opslaan",
  "DECOMPILE_SAVE_ALL_CLASSES": "Decompileer en bewaar alle klassen",
  "RECENT_FILES": "Recente bestanden",
  "ABOUT": "Over",
  "EXIT": "Exit",

  "VIEW": "Bekijk",
  "VISUAL_SETTINGS": "Visuele instellingen",
  "PANE_1": "Deelvenster 1",
  "PANE_2": "Deelvenster 2",
  "PANE_3": "Deelvenster 3",
  "NONE": "Geen",
  "EDITABLE": "Bewerkbaar",

  "LANGUAGE": "Taal",
  "FONT_SIZE": "Lettergrootte",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Toon bestand in tabblad titel",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Vereenvoudig naam in tabblad titel",
  "SYNCHRONIZED_VIEWING": "Gesynchroniseerd Bekijken",
  "SHOW_CLASS_METHODS": "Klasse-methoden tonen",

  "WINDOW_THEME": "Venster Thema",
  "SYSTEM_THEME": "Systeem Thema",
  "DARK_THEME": "Donker Thema",
  "LIGHT_THEME": "Licht Thema",
  "ONE_DARK_THEME": "Een donker thema",
  "SOLARIZED_DARK_THEME": "Zonnig Donker Thema",
  "SOLARIZED_LIGHT_THEME": "Thema Licht op Zonne-energie",
  "HIGH_CONTRAST_DARK_THEME": "Donker thema met hoog contrast",
  "HIGH_CONTRAST_LIGHT_THEME": "Lichtthema met hoog contrast",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Donker op zonne-energie",
  "SOLARIZED_LIGHT": "Licht op zonne-energie",
  "HIGH_CONTRAST_DARK": "Hoog Contrast Donker",
  "HIGH_CONTRAST_LIGHT": "Licht met hoog contrast",
  "TEXT_AREA_THEME": "Thema tekstgebied",
  "DEFAULT_RECOMMENDED_LIGHT": "Standaard (Aanbevolen licht)",
  "THEME_MATCH": "Thema Wedstrijd (Aanbevolen)",
  "DARK": "Donker (Aanbevolen Donker)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Standaard-Alt",
  "ECLIPSE": "Eclips",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druïde (donker)",
  "MONOKAI_DARK": "Monokai (Dark)",

  "SETTINGS": "Instellingen",
  "COMPILE_ON_SAVE": "Compileren bij opslaan",
  "COMPILE_ON_REFRESH": "Compileren bij vernieuwen",
  "REFRESH_ON_VIEW_CHANGE": "Vernieuwen bij verandering van weergave",
  "DECODE_APK_RESOURCES": "Decodeer APK middelen",
  "APK_CONVERSION": "APK conversie",
  "APK_CONVERSION_DECODING": "APK conversie",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Bijwerk Check",
  "DELETE_UNKNOWN_LIBS": "Wis Buitenlands",
  "FORCE_PURE_ASCII_AS_TEXT": "Forceer zuiver Ascii als tekst",
  "SET_PYTHON_27_EXECUTABLE": "Stel Python 2.7 Uitvoerbaar",
  "SET_PYTHON_30_EXECUTABLE": "Stel Python 3.X Uitvoerbaar",
  "SET_JRE_RT_LIBRARY": "JRE RT-bibliotheek instellen",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Optionele bibliotheekmap instellen",
  "SET_JAVAC_EXECUTABLE": "Stel Javac Uitvoerbaar",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon Instellingen",
  "CFR_SETTINGS": "CFR-instellingen",
  "FERNFLOWER_SETTINGS": "FernFlower Instellingen",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode decompiler",
  "DEBUG_HELPERS": "Debug helpers",
  "APPEND_BRACKETS_TO_LABEL": "Haakjes toevoegen aan label",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Open Plugin...",
  "RECENT_PLUGINS": "Recente Plugins",
  "CODE_SEQUENCE_DIAGRAM": "Codevolgordeschema",
  "MALICIOUS_CODE_SCANNER": "Scanner voor kwaadaardige code",
  "SHOW_MAIN_METHODS": "Toon hoofdmethoden",
  "SHOW_ALL_STRINGS": "Toon alle snaren",
  "REPLACE_STRINGS": "Vervangen Strings",
  "STACK_FRAMES_REMOVER": "Stack Frames Verwijderaar",
  "ZKM_STRING_DECRYPTER": "ZKM String Ontcijferaar",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Android-toestemmingen bekijken",
  "VIEW_MANIFEST": "Bekijk Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Verander ClassFile Versies",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Bytecode disassembler",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Fout",
  "NEW_JAVA_PLUGIN": "Nieuwe Java Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "Nieuwe Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Voorgestelde oplossing: Klik op refresh class, als het opnieuw mislukt probeer dan een andere decompiler.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Voorgestelde oplossing: Probeer View>Pane>Krakatau>Bytecode en schakel Bewerkbaar in.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "WAARSCHUWING: Er is momenteel geen decompiler geselecteerd. Probeer Beeld>Venster en kies een decompiler.",
  "COMPILER_TIP": "Onthoud dat de meeste decompilers geen compileerbare klassen kunnen produceren",
  "FIRST_OPEN_A_RESOURCE": "Open eerst een bron in BCV (class, jar, zip of apk bestand)",
  "FIRST_OPEN_A_CLASS": "Open eerst een classfile bron in BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Bekijk eerst een klassebestand in een tabblad.",
  "DRAG_CLASS_JAR": "Sleep klasse",

  "YES": "Ja",
  "NO": "Geen",
  "ERROR2": "Fout:",
  "PROCESS2": "Proces:",
  "EXIT_VALUE_IS": "Exit Waarde is:",
  "JAVA_COMPILE_FAILED": "Java Compile mislukt",
  "ERROR_COMPILING_CLASS": "Fout bij het compileren van de klasse",
  "COMPILER": "Onthoud dat de meeste decompilers geen compileerbare klassen kunnen produceren",
  "SELECT_LIBRARY_FOLDER": "Selecteer Bibliotheek Map",
  "SELECT_JAVA_RT": "Selecteer JRE RT Jar",
  "SELECT_JAVA": "Selecteer Java Executable",
  "SELECT_JAVAC": "Selecteer Javac Uitvoerbaar",
  "SELECT_JAVA_TOOLS": "Selecteer Java Tools Jar",
  "SELECT_PYTHON_2": "Selecteer Python 2.7 Executable",
  "SELECT_PYTHON_3": "Selecteer Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (of PyPy 2.7 voor snelheid) Uitvoerbaar",
  "PYTHON_3_EXECUTABLE": "Python 3.x (of PyPy 3.x voor snelheid) Uitvoerbaar",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "U moet uw Python 2.7 (of PyPy 2.7 voor snelheid) uitvoerbaar pad instellen.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "U moet uw Python 3.x (of PyPy 3.x voor snelheid) uitvoerbaar pad instellen.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Je moet je JRE RT Library instellen.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:ProgrammabestandenJavaJre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (binnen JRE C:",
  "JAVAC_EXECUTABLE": "Javac Uitvoerbaar (vereist JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Binnenin JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (Binnenin JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Optionele bibliotheekmap (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Verberg brugmethoden",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Verberg synthetische klasse leden",
  "DECOMPILE_INNER_CLASSES": "Decompileer binnenklassen",
  "COLLAPSE_14_CLASS_REFERENCES": "Instorting 1.4 klasse referenties",
  "DECOMPILE_ASSERTIONS": "Decompileer beweringen",
  "HIDE_EMPTY_SUPER_INVOCATION": "Verberg lege super aanroep",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Verberg lege standaard constructor",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompileer generische handtekeningen",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Veronderstel dat terugkeer geen uitzonderingen werpt",
  "DECOMPILE_ENUMERATIONS": "Decompileer opsommingen",
  "REMOVE_GETCLASS_INVOCATION": "Verwijder getClass() aanroep",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpreteer int 1 als boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Toestaan van niet ingesteld synthetisch kenmerk",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Beschouw naamloze types als java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Variabelennamen reconstrueren uit debug info",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Lege uitzonderingsreeksen verwijderen",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline eindelijk structuren",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Sta alleen ASCII tekens toe in strings",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Hernoem dubbelzinnige klassen en klasse-elementen",

  "DECODE_ENUM_SWITCH": "Decodeer Enum Schakelaar",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Decodeer String Schakelaar",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Binnenklassen",
  "REMOVE_BOILER_PLATE": "Ketelplaat verwijderen",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Verwijder Synthetisch Binnenklas",
  "DECODE_LAMBDAS": "Lambdas decoderen",
  "LIFT__CONSTRUCTOR_INIT": "Lift Constructor Init",
  "REMOVE_DEAD_METHODS": "Dode methoden verwijderen",
  "REMOVE_BAD_GENERICS": "Slechte Generieken verwijderen",
  "SUGAR_ASSERTS": "Suiker beweringen",
  "SUGAR_BOXING": "Suiker Boksen",
  "SHOW_VERSION": "Toon versie",
  "DECODE_FINALLY": "Decodeer eindelijk",
  "TIDY_MONITORS": "Opgeruimde Monitoren",
  "LENIENT": "Lenig",
  "DUMP_CLASSPATH": "Dump Klassenpad",
  "COMMENTS": "Opmerkingen",
  "FORCE_TOP_SORT": "Forceer bovensorteren",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Forceer uitzondering snoeien",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Bouwer",
  "SILENT": "Stil",
  "RECOVER": "Herstel",
  "OVERRIDE": "Overschrijven",
  "SHOW_INFERRABLE": "Toon Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Verberg UTF",
  "HIDE_LONG_STRINGS": "Lange snaren verbergen",
  "COMMENT_MONITORS": "Commentaar Monitors",
  "ALLOW_CORRECTING": "Laat corrigeren",
  "LABELLED_BLOCKS": "Gelabelde Blokken",
  "J14CLASSOBJ": "J14KlasseOBJ",
  "HIDE_LANG_IMPORTS": "Verberg Lang Imports",
  "RECOVER_TYPE_CLASH": "Herstel Type Clash",
  "RECOVER_TYPE__HINTS": "Herstel Type Hints",
  "FORCE_RETURNING_IFS": "Forceer terugkerende IF's",
  "FOR_LOOP_AGG_CAPTURE": "Voor lus AGG-opname",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Genereer altijd Uitzondering Variabele voor Catch Blokken",
  "EXCLUDE_NESTED_TYPES": "Geneste Types uitsluiten",
  "SHOW_DEBUG_LINE_NUMBERS": "Debug regelnummers tonen",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Regelnummers opnemen in Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Foutdiagnose opnemen",
  "SHOW_SYNTHETIC_MEMBERS": "Synthetische leden tonen",
  "SIMPLIFY_MEMBER_REFERENCES": "Vereenvoudigen van verwijzingen naar leden",
  "MERGE_VARIABLES": "Variabelen samenvoegen",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Expliciete type-argumenten afdwingen",
  "FORCE_EXPLICIT_IMPORTS": "Expliciete import afdwingen",
  "FLATTEN_SWITCH_BLOCKS": "Platte schakelaarblokken",
  "RETAIN_POINTLESS_SWITCHES": "Behoud Zinloze Schakelaars",
  "RETAIN_REDUNDANT_CASTS": "Overbodige Casts behouden",
  "UNICODE_OUTPUT_ENABLED": "Unicode uitvoer ingeschakeld",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Herlaad bronnen",
  "RELOAD_RESOURCES_CONFIRM": "Weet je zeker dat je de bronnen opnieuw wilt laden?",
  "SELECT_FILE_TITLE": "Selecteer Bestand of Map om te openen in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK's, DEX, Klasse Bestanden of Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Selecteer Externe Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV Externe Plugin in js, java, python, ruby of groovy",
  "FOREIGN_LIBRARY_WARNING": "WAARSCHUWING: Als deze optie uit staat, worden verouderde bibliotheken NIET verwijderd. {NNEWLINE} Het is ook een veiligheidsprobleem. {SCHAKEL HET} ZET HET ALLEEN UIT ALS JE WEET WAT JE DOET.",
  "RESET_TITLE": "{PRODUCT_NAME} - Reset Werkruimte",
  "RESET_CONFIRM": "Weet je zeker dat je de werkruimte wilt resetten? {NNEWLINE} Het zal ook uw bestandsnavigator en zoeken resetten.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Afsluiten",
  "EXIT_CONFIRM": "Weet je zeker dat je wilt stoppen?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Over - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Sluit alles behalve dit",
  "CLOSE_TAB": "Tab sluiten",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Stuur deze foutmelding naar",
  "PLEASE_SEND_RESOURCES": "Indien u over de nodige wettelijke rechten beschikt voor de betrokken klasse",
  "ONE_PLUGIN_AT_A_TIME": "Er is op dit moment een andere plugin bezig, wacht alstublieft tot die klaar is met uitvoeren.",
  "ILLEGAL_ACCESS_ERROR": "Gebruik Java 15 of ouder om dit te doen.",


  "FILES": "Bestanden",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Snel bestanden zoeken (geen bestandsextensie)",
  "WORK_SPACE": "Werkruimte",
  "EXACT": "Exact",
  "SEARCH": "Zoeken op",
  "SEARCH_FROM": "Zoeken vanaf:",
  "SEARCH_STRING": "Zoek String:",
  "SEARCH_REGEX": "Zoek Regex:",
  "OWNER": "Eigenaar:",
  "NAME": "Naam:",
  "DESC": "Desc:",
  "SAVE": "Save...",
  "SAVE_AS": "Opslaan als...",
  "RESULTS": "Resultaten",
  "REFRESH": "Vernieuwen",
  "ANNOTATION_NAME": "Annotatie Naam",
  "MATCH_CASE": "Wedstrijd geval",
  "EXACT_PATH": "Exact pad",
  "MIN_SDK_VERSION": "Minimale SDK-versie",
  "PRINT_LINE_NUMBERS": "Regelnummers afdrukken"
}

```

`src/main/resources/translations/norwegian.json`:

```json
{
  "FILE": "Fil",
  "ADD": "Legge til...",
  "NEW_WORKSPACE": "Nytt arbeidsområde",
  "RELOAD_RESOURCES": "Last inn ressurser på nytt",
  "RUN": "Løpe",
  "OPEN": "Åpen...",
  "OPEN_UNSTYLED": "Åpen",
  "QUICK_OPEN": "Rask åpning",
  "DELETE": "Slett",
  "NEW": "Ny",
  "EXPAND": "Utvide",
  "COLLAPSE": "Kollapse",
  "COMPILE": "Kompilere",
  "SAVE_AS_RUNNABLE_JAR": "Lagre som løpbar krukke ...",
  "SAVE_AS_ZIP": "Lagre som zip ...",
  "SAVE_AS_DEX": "Lagre som DEX ...",
  "SAVE_AS_APK": "Lagre som APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompiler og lagre åpnede klasser",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompiler og lagre alle klasser",
  "RECENT_FILES": "Nylige filer",
  "ABOUT": "Om",
  "EXIT": "Exit",

  "VIEW": "Utsikt",
  "VISUAL_SETTINGS": "Visuelle innstillinger",
  "PANE_1": "Rute 1",
  "PANE_2": "Rute 2",
  "PANE_3": "Rute 3",
  "NONE": "Ingen",
  "EDITABLE": "Kan redigeres",

  "LANGUAGE": "Språk",
  "FONT_SIZE": "Skriftstørrelse",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Vis fil i kategoritittel",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Forenkle navnet i fanen Tittel",
  "SYNCHRONIZED_VIEWING": "Synkronisert visning",
  "SHOW_CLASS_METHODS": "Vis klassemetoder",

  "WINDOW_THEME": "Vinduetema",
  "SYSTEM_THEME": "Systemtema",
  "DARK_THEME": "Mørkt tema",
  "LIGHT_THEME": "Lett tema",
  "ONE_DARK_THEME": "Ett mørkt tema",
  "SOLARIZED_DARK_THEME": "Solarized Dark Theme",
  "SOLARIZED_LIGHT_THEME": "Solarized Light Theme",
  "HIGH_CONTRAST_DARK_THEME": "Mørkt tema med høy kontrast",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema med høyt kontrastlys",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solarisert lys",
  "HIGH_CONTRAST_DARK": "Høy kontrast mørk",
  "HIGH_CONTRAST_LIGHT": "Høyt kontrastlys",
  "TEXT_AREA_THEME": "Tekstområdetema",
  "DEFAULT_RECOMMENDED_LIGHT": "Standard (anbefalt lys)",
  "THEME_MATCH": "Temakamp (anbefalt)",
  "DARK": "Mørk (anbefalt mørk)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Standard-Alt",
  "ECLIPSE": "Formørkelse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visuelt studio",
  "DRUID_DARK": "Druid (mørk)",
  "MONOKAI_DARK": "Monokai (mørk)",

  "SETTINGS": "Innstillinger",
  "COMPILE_ON_SAVE": "Kompilere ved lagring",
  "COMPILE_ON_REFRESH": "Kompilere på oppdatering",
  "REFRESH_ON_VIEW_CHANGE": "Oppdater ved visningsendring",
  "DECODE_APK_RESOURCES": "Dekode APK-ressurser",
  "APK_CONVERSION": "APK-konvertering",
  "APK_CONVERSION_DECODING": "APK-konvertering / dekoding",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Oppdateringssjekk",
  "DELETE_UNKNOWN_LIBS": "Slett utenlandske / utdaterte Libs",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii som tekst",
  "SET_PYTHON_27_EXECUTABLE": "Sett Python 2.7 kjørbar",
  "SET_PYTHON_30_EXECUTABLE": "Sett Python 3.X kjørbar",
  "SET_JRE_RT_LIBRARY": "Sett JRE RT-biblioteket",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Angi valgfri biblioteksmappe",
  "SET_JAVAC_EXECUTABLE": "Sett Javac Executable",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon-innstillinger",
  "CFR_SETTINGS": "CFR-innstillinger",
  "FERNFLOWER_SETTINGS": "FernFlower-innstillinger",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali / Dex",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode Decompiler",
  "DEBUG_HELPERS": "Feilsøkingshjelpere",
  "APPEND_BRACKETS_TO_LABEL": "Legg til braketter for å merke",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Åpne plugin ...",
  "RECENT_PLUGINS": "Nylige plugins",
  "CODE_SEQUENCE_DIAGRAM": "Kodesekvensdiagram",
  "MALICIOUS_CODE_SCANNER": "Skadelig kodeskanner",
  "SHOW_MAIN_METHODS": "Vis hovedmetoder",
  "SHOW_ALL_STRINGS": "Vis alle strenger",
  "REPLACE_STRINGS": "Bytt ut strenger",
  "STACK_FRAMES_REMOVER": "Stack Frames Remover",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Se Android-tillatelser",
  "VIEW_MANIFEST": "Vis manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Endre ClassFile-versjoner",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX dekompilator",
  "JD_DECOMPILER": "JD-GUI dekompilator",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Demonterer",

  "ERROR": "Feil",
  "NEW_JAVA_PLUGIN": "Ny Java-plugin",
  "NEW_JAVASCRIPT_PLUGIN": "Ny Javascript-plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Foreslått løsning: Klikk på oppdateringsklasse, hvis den mislykkes igjen, prøv en annen dekompilator.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Foreslått løsning: Prøv Vis> Rute> Krakatau> Bytecode og aktiver Redigerbar.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ADVARSEL: Ingen dekompilator er valgt for øyeblikket. Prøv Vis> Rute og velg en dekompilator.",
  "COMPILER_TIP": "Husk at de fleste dekompilatorer ikke kan produsere kompilerbare klasser",
  "FIRST_OPEN_A_RESOURCE": "Åpne først en ressurs i BCV (klasse, jar, zip eller apk-fil)",
  "FIRST_OPEN_A_CLASS": "Åpne først en klassefileressurs inne i BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Se først en klassefil inne i en fane.",
  "DRAG_CLASS_JAR": "Dra klasse / jar / zip / APK / DEX hit",

  "YES": "Ja",
  "NO": "Nei",
  "ERROR2": "Feil:",
  "PROCESS2": "Prosess:",
  "EXIT_VALUE_IS": "Utgangsverdi er:",
  "JAVA_COMPILE_FAILED": "Java-kompilering mislyktes",
  "ERROR_COMPILING_CLASS": "Feil ved kompilering av klassen",
  "COMPILER": "Husk at de fleste dekompilatorer ikke kan produsere kompilerbare klasser",
  "SELECT_LIBRARY_FOLDER": "Velg Biblioteksmappe",
  "SELECT_JAVA_RT": "Velg JRE RT Jar",
  "SELECT_JAVA": "Velg Java Executable",
  "SELECT_JAVAC": "Velg Javac Executable",
  "SELECT_JAVA_TOOLS": "Velg Java Tools Jar",
  "SELECT_PYTHON_2": "Velg Python 2.7 Executable",
  "SELECT_PYTHON_3": "Velg Python 3.x kjørbar",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Eller PyPy 2.7 for hastighet) Kjørbar",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Eller PyPy 3.x for hastighet) Kjørbar",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Du må angi din kjørbare bane for Python 2.7 (eller PyPy 2.7 for hastighet).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Du må angi kjørbar bane for Python 3.x (eller PyPy 3.x for hastighet).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Du må stille inn JRE RT-biblioteket ditt.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "Java-kjørbar (innsiden av JRE C: / programfiler / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Javac kjørbar (krever JDK C: / programfiler / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside of JDK C: / Program Files / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C: / Program Files / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Valgfri biblioteksmappe (kompilator og Krakatau)",

  "HIDE_BRIDGE_METHODS": "Skjul brometoder",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Skjul syntetiske klassemedlemmer",
  "DECOMPILE_INNER_CLASSES": "Dekompiler indre klasser",
  "COLLAPSE_14_CLASS_REFERENCES": "Skjul 1,4 klassereferanser",
  "DECOMPILE_ASSERTIONS": "Dekompiler påstander",
  "HIDE_EMPTY_SUPER_INVOCATION": "Skjul tom superanrop",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Skjul tomme standardkonstruktører",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompiler generiske signaturer",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Anta at retur ikke kaster unntak",
  "DECOMPILE_ENUMERATIONS": "Dekompiler oppregninger",
  "REMOVE_GETCLASS_INVOCATION": "Fjern getClass () påkallelse",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Tolk int 1 som boolsk sant",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Tillat at ikke angitt syntetisk attributt",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Betrakt navnløse typer som java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonstruer variabelnavn fra feilsøkingsinfo",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Fjern tomme unntaksområder",
  "DEINLINE_FINALLY_STRUCTURES": "Endelig strukturer Deinline",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Tillat bare ASCII-tegn i strenger",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Gi nytt navn til tvetydige klasser og klasseelementer",

  "DECODE_ENUM_SWITCH": "Dekoder Enum-bryter",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dekode strengbryter",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Indre klasser",
  "REMOVE_BOILER_PLATE": "Fjern kjeleplaten",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Fjern syntetiske stoffer i indre klasse",
  "DECODE_LAMBDAS": "Dekode Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift Constructor Init",
  "REMOVE_DEAD_METHODS": "Fjern døde metoder",
  "REMOVE_BAD_GENERICS": "Fjern Bad Generics",
  "SUGAR_ASSERTS": "Sukker påstander",
  "SUGAR_BOXING": "Sukkerboksing",
  "SHOW_VERSION": "Vis versjon",
  "DECODE_FINALLY": "Dekoder til slutt",
  "TIDY_MONITORS": "Ryddige skjermer",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Kommentarer",
  "FORCE_TOP_SORT": "Tving topp sortering",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "Strengbuffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Stille",
  "RECOVER": "Komme seg",
  "OVERRIDE": "Overstyring",
  "SHOW_INFERRABLE": "Vis Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Tving kondensforplantning",
  "HIDE_UTF": "Skjul UTF",
  "HIDE_LONG_STRINGS": "Skjul lange strenger",
  "COMMENT_MONITORS": "Kommentarmonitorer",
  "ALLOW_CORRECTING": "Tillat korrigering",
  "LABELLED_BLOCKS": "Merkede blokker",
  "J14CLASSOBJ": "J14KlasseOBJ",
  "HIDE_LANG_IMPORTS": "Skjul Lang Import",
  "RECOVER_TYPE_CLASH": "Gjenopprett Type Clash",
  "RECOVER_TYPE__HINTS": "Gjenopprett typetips",
  "FORCE_RETURNING_IFS": "Tving tilbake IF-er",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Generer alltid unntaksvariabler for fangstblokker",
  "EXCLUDE_NESTED_TYPES": "Ekskluder nestede typer",
  "SHOW_DEBUG_LINE_NUMBERS": "Vis feilsøkingsnumre",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Inkluder linjenumre i Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Inkluder feildiagnostikk",
  "SHOW_SYNTHETIC_MEMBERS": "Vis syntetiske medlemmer",
  "SIMPLIFY_MEMBER_REFERENCES": "Forenkle medlemsreferanser",
  "MERGE_VARIABLES": "Slå sammen variabler",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Tving eksplisitt import",
  "FLATTEN_SWITCH_BLOCKS": "Flate bryterblokker",
  "RETAIN_POINTLESS_SWITCHES": "Behold meningsløse brytere",
  "RETAIN_REDUNDANT_CASTS": "Behold overflødige rollebesetninger",
  "UNICODE_OUTPUT_ENABLED": "Unicode-utgang aktivert",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Last inn ressurser på nytt",
  "RELOAD_RESOURCES_CONFIRM": "Er du sikker på at du vil laste inn ressursene på nytt?",
  "SELECT_FILE_TITLE": "Velg Fil eller mappe for å åpne i {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK-filer, DEX, klassefiler eller zip / jar / krigsarkiv",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Velg Eksternt plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV eksternt plugin i js, java, python, ruby ​​eller groovy",
  "FOREIGN_LIBRARY_WARNING": "ADVARSEL: Når dette er slått av, vil IKKE fjernede biblioteker fjernes.\n\rDet er også et sikkerhetsproblem.\n\rSLÅ KUN DET AV Hvis du vet hva du gjør.",
  "RESET_TITLE": "{PRODUCT_NAME} - Tilbakestill arbeidsområdet",
  "RESET_CONFIRM": "Er du sikker på at du vil tilbakestille arbeidsområdet?\n\rDen tilbakestiller også filnavigatoren og søker.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Avslutt",
  "EXIT_CONFIRM": "Er du sikker på at du vil avslutte?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Om - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin-konsoll",
  "CLOSE_ALL_BUT_THIS": "Lukk alt annet enn dette",
  "CLOSE_TAB": "Lukk fanen",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Send denne feilloggen til",
  "PLEASE_SEND_RESOURCES": "Hvis du har passende juridiske rettigheter til den aktuelle klassen / jar / apk-filen, må du også inkludere det.",
  "ONE_PLUGIN_AT_A_TIME": "Det er for øyeblikket en annen plugin som kjører akkurat nå, vennligst vent til den fullføres.",
  "ILLEGAL_ACCESS_ERROR": "Bruk Java 15 eller eldre for å gjøre dette.",


  "FILES": "Filer",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Raskt filsøk (ingen filtype)",
  "WORK_SPACE": "Arbeidsplass",
  "EXACT": "Nøyaktig",
  "SEARCH": "Søk",
  "SEARCH_FROM": "Søk fra:",
  "SEARCH_STRING": "Søkestreng:",
  "SEARCH_REGEX": "Søk i Regex:",
  "OWNER": "Eieren:",
  "NAME": "Navn:",
  "DESC": "Beskrivelse:",
  "SAVE": "Lagre...",
  "SAVE_AS": "Lagre som...",
  "RESULTS": "Resultater",
  "REFRESH": "Forfriske",
  "ANNOTATION_NAME": "Annoteringsnavn",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Nøyaktig vei",
  "MIN_SDK_VERSION": "Minimum SDK-versjon",
  "PRINT_LINE_NUMBERS": "Skriv ut linjenumre"
}

```

`src/main/resources/translations/polish.json`:

```json
{
  "FILE": "Plik",
  "ADD": "Dodaj...",
  "NEW_WORKSPACE": "Nowa przestrzeń robocza",
  "RELOAD_RESOURCES": "Przeładuj zasoby",
  "RUN": "Uruchom",
  "OPEN": "Otwórz...",
  "OPEN_UNSTYLED": "Otwórz",
  "QUICK_OPEN": "Szybkie otwieranie",
  "DELETE": "Usuń",
  "NEW": "Nowy",
  "EXPAND": "Rozwiń stronę",
  "COLLAPSE": "Zapadnij się",
  "COMPILE": "Skompiluj",
  "SAVE_AS_RUNNABLE_JAR": "Zapisz jako uruchomiony słoik...",
  "SAVE_AS_ZIP": "Zapisz jako Zip...",
  "SAVE_AS_DEX": "Zapisz jako DEX...",
  "SAVE_AS_APK": "Zapisz jako APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompiluj i zapisz otwarte klasy",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompiluj i zapisz wszystkie klasy",
  "RECENT_FILES": "Ostatnie pliki",
  "ABOUT": "O",
  "EXIT": "Wyjście",

  "VIEW": "Zobacz",
  "VISUAL_SETTINGS": "Ustawienia wizualne",
  "PANE_1": "Pane 1",
  "PANE_2": "Pane 2",
  "PANE_3": "Pane 3",
  "NONE": "Brak",
  "EDITABLE": "Edytowalna strona",

  "LANGUAGE": "Język",
  "FONT_SIZE": "Rozmiar czcionki",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Pokaż plik w tytule karty",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Uprość nazwę w tytule karty",
  "SYNCHRONIZED_VIEWING": "Przeglądanie zsynchronizowane",
  "SHOW_CLASS_METHODS": "Pokaż metody klasy",

  "WINDOW_THEME": "Motyw okna",
  "SYSTEM_THEME": "Temat systemowy",
  "DARK_THEME": "Ciemny motyw",
  "LIGHT_THEME": "Temat światła",
  "ONE_DARK_THEME": "Jeden ciemny motyw",
  "SOLARIZED_DARK_THEME": "Nasłoneczniony ciemny motyw",
  "SOLARIZED_LIGHT_THEME": "Światło słoneczne Temat",
  "HIGH_CONTRAST_DARK_THEME": "Ciemny motyw o wysokim kontraście",
  "HIGH_CONTRAST_LIGHT_THEME": "Jasny motyw o wysokim kontraście",
  "ONE_DARK": "Jeden mrok",
  "SOLARIZED_DARK": "Nasłoneczniony ciemny",
  "SOLARIZED_LIGHT": "Światło słoneczne",
  "HIGH_CONTRAST_DARK": "Wysoki Kontrast Ciemny",
  "HIGH_CONTRAST_LIGHT": "Światło o wysokim kontraście",
  "TEXT_AREA_THEME": "Obszar tekstu Temat",
  "DEFAULT_RECOMMENDED_LIGHT": "Domyślne (zalecane światło)",
  "THEME_MATCH": "Mecz tematyczny (zalecany)",
  "DARK": "Ciemny (Zalecany Ciemny)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (Mroczny)",
  "MONOKAI_DARK": "Monokai (Mroczny)",

  "SETTINGS": "Ustawienia",
  "COMPILE_ON_SAVE": "Kompiluj przy zapisie",
  "COMPILE_ON_REFRESH": "Kompiluj przy odświeżaniu",
  "REFRESH_ON_VIEW_CHANGE": "Odświeżanie przy zmianie widoku",
  "DECODE_APK_RESOURCES": "Odkoduj zasoby APK",
  "APK_CONVERSION": "Konwersja APK",
  "APK_CONVERSION_DECODING": "Konwersja APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Kontrola aktualizacji",
  "DELETE_UNKNOWN_LIBS": "Usuń Zagranica",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Ustawienie Python 2.7 Executable",
  "SET_PYTHON_30_EXECUTABLE": "Ustawienie Python 3.X Executable",
  "SET_JRE_RT_LIBRARY": "Ustaw bibliotekę JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Ustawianie opcjonalnego folderu biblioteki",
  "SET_JAVAC_EXECUTABLE": "Ustaw Javac Executable",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Ustawienia Procyona",
  "CFR_SETTINGS": "Ustawienia CFR",
  "FERNFLOWER_SETTINGS": "Ustawienia kwiatu paproci",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Tekstylia",

  "BYTECODE_DECOMPILER": "Dekompilator bajtkodu",
  "DEBUG_HELPERS": "Pomocnicy debugowania",
  "APPEND_BRACKETS_TO_LABEL": "Dołącz nawiasy do etykiety",

  "PLUGINS": "Wtyczki",
  "OPEN_PLUGIN": "Otwórz Plugin...",
  "RECENT_PLUGINS": "Ostatnie wtyczki",
  "CODE_SEQUENCE_DIAGRAM": "Schemat sekwencji kodu",
  "MALICIOUS_CODE_SCANNER": "Skaner złośliwych kodów",
  "SHOW_MAIN_METHODS": "Pokaż główne metody",
  "SHOW_ALL_STRINGS": "Pokaż wszystkie struny",
  "REPLACE_STRINGS": "Wymień ciągi znaków",
  "STACK_FRAMES_REMOVER": "Usuwacz ramek stosu",
  "ZKM_STRING_DECRYPTER": "Dekrypter ciągów ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Dekrypter",
  "VIEW_ANDROID_PERMISSIONS": "Wyświetl uprawnienia systemu Android",
  "VIEW_MANIFEST": "Zobacz manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Zmiana wersji pliku ClassFile",



  "PROCYON_DECOMPILER": "Dekompilator Procyon",
  "CFR_DECOMPILER": "Dekompilator CFR",
  "FERNFLOWER_DECOMPILER": "Dekompilator FernFlower",
  "JADX_DECOMPILER": "Dekompilator JADX",
  "JD_DECOMPILER": "Dekompilator JD-GUI",
  "BYTECODE_DISASSEMBLER": "Dezasembler bajtkodu",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Błąd",
  "NEW_JAVA_PLUGIN": "Nowy plugin Java",
  "NEW_JAVASCRIPT_PLUGIN": "Nowy plugin Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Sugerowana poprawka: Kliknij odśwież klasę, jeśli nie powiedzie się ponownie spróbuj innego dekompilatora.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Sugerowana poprawka: Spróbuj View>Pane>Krakatau>Bytecode i włącz Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "OSTRZEŻENIE: Żaden dekompilator nie jest obecnie wybrany. Spróbuj Widok>Panewka i wybierz dekompilator.",
  "COMPILER_TIP": "Należy pamiętać, że większość dekompilatorów nie jest w stanie wyprodukować kompilowalnych klas.",
  "FIRST_OPEN_A_RESOURCE": "Najpierw otwórz zasób wewnątrz BCV (plik class, jar, zip lub apk).",
  "FIRST_OPEN_A_CLASS": "Najpierw otwórz zasób pliku klasowego wewnątrz BCV (jar, zip, apk, dex).",
  "FIRST_VIEW_A_CLASS": "Najpierw wyświetl plik klasy wewnątrz zakładki.",
  "DRAG_CLASS_JAR": "Klasa przeciągania",

  "YES": "Tak",
  "NO": "Nie",
  "ERROR2": "Błąd:",
  "PROCESS2": "Proces:",
  "EXIT_VALUE_IS": "Exit Value to:",
  "JAVA_COMPILE_FAILED": "Kompilacja Javy nie powiodła się",
  "ERROR_COMPILING_CLASS": "Błąd kompilacji klasy",
  "COMPILER": "Należy pamiętać, że większość dekompilatorów nie jest w stanie wyprodukować kompilowalnych klas.",
  "SELECT_LIBRARY_FOLDER": "Wybierz folder biblioteki",
  "SELECT_JAVA_RT": "Wybierz JRE RT Jar",
  "SELECT_JAVA": "Wybierz Java Executable",
  "SELECT_JAVAC": "Wybierz Javac Executable",
  "SELECT_JAVA_TOOLS": "Wybierz Narzędzia Java Jar",
  "SELECT_PYTHON_2": "Wybierz Python 2.7 Executable",
  "SELECT_PYTHON_3": "Wybierz Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (lub PyPy 2.7 dla szybkości) Wykonywalny",
  "PYTHON_3_EXECUTABLE": "Python 3.x (lub PyPy 3.x dla szybkości) Wykonywalny",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Musisz ustawić ścieżkę wykonywalną Pythona 2.7 (lub PyPy 2.7 dla szybkości).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Musisz ustawić ścieżkę wykonywalną Pythona 3.x (lub PyPy 3.x dla szybkości).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Musisz ustawić swoją bibliotekę JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C:",
  "JAVAC_EXECUTABLE": "Javac Executable (Wymaga JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Wewnątrz JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Opcjonalny folder biblioteki (Compiler i Krakatau)",

  "HIDE_BRIDGE_METHODS": "Ukryj metody mostkowe",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Ukryj syntetycznych członków klasy",
  "DECOMPILE_INNER_CLASSES": "Dekompilacja klas wewnętrznych",
  "COLLAPSE_14_CLASS_REFERENCES": "Upadek 1.4 odniesienia do klas",
  "DECOMPILE_ASSERTIONS": "Dekompilacja asercji",
  "HIDE_EMPTY_SUPER_INVOCATION": "Ukryj puste wywołanie super",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Ukryj pusty konstruktor domyślny",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompilacja sygnatur generycznych",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Załóż, że return nie rzuca wyjątków",
  "DECOMPILE_ENUMERATIONS": "Dekompilacja wyliczeń",
  "REMOVE_GETCLASS_INVOCATION": "Usuń wywołanie getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretuj int 1 jako boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Zezwolenie na nieokreślenie atrybutu syntetycznego",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Traktuj bezimienne typy jako java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonstrukcja nazw zmiennych z informacji o debugu",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Usuń puste zakresy wyjątków",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finally structures",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Zezwalaj na stosowanie w łańcuchach tylko znaków ASCII",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Zmiana nazw niejednoznacznych klas i elementów klas",

  "DECODE_ENUM_SWITCH": "Decode Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dekoduj ciąg znaków Przełącznik",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Kolekcjoner",
  "INNER_CLASSES": "Klasy wewnętrzne",
  "REMOVE_BOILER_PLATE": "Zdjąć płytę kotła",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Usuń Syntetyki klasy wewnętrznej",
  "DECODE_LAMBDAS": "Dekodowanie lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Konstruktor podnoszący Init",
  "REMOVE_DEAD_METHODS": "Usuń martwe metody",
  "REMOVE_BAD_GENERICS": "Usuń złe generyki",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Pokaż wersję",
  "DECODE_FINALLY": "Odkoduj wreszcie",
  "TIDY_MONITORS": "Porządek w monitorach",
  "LENIENT": "Łagodny",
  "DUMP_CLASSPATH": "Ścieżka zrzutu",
  "COMMENTS": "Uwagi",
  "FORCE_TOP_SORT": "Wymuś górne sortowanie",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Agresja",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "Bufor ciągów znaków",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Odzyskaj",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Pokaż Niewykonalne",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Kondensacja siły Propagacja",
  "HIDE_UTF": "Ukryj UTF",
  "HIDE_LONG_STRINGS": "Ukryj długie struny",
  "COMMENT_MONITORS": "Monitory komentarzy",
  "ALLOW_CORRECTING": "Umożliwić korektę",
  "LABELLED_BLOCKS": "Bloki z etykietami",
  "J14CLASSOBJ": "J14KlasaOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Odzyskaj Typ Starcia",
  "RECOVER_TYPE__HINTS": "Wskazówki dotyczące odzyskiwania typu",
  "FORCE_RETURNING_IFS": "Siły powracających FI",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Zawsze generuj zmienną wyjątku dla bloków Catch",
  "EXCLUDE_NESTED_TYPES": "Wykluczanie typów zagnieżdżonych",
  "SHOW_DEBUG_LINE_NUMBERS": "Pokaż numery linii debugowania",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Dołączanie numerów linii do kodu bajtowego",
  "INCLUDE_ERROR_DIAGNOSTICS": "Dołączanie diagnostyki błędów",
  "SHOW_SYNTHETIC_MEMBERS": "Pokaż Członków Syntetycznych",
  "SIMPLIFY_MEMBER_REFERENCES": "Uproszczenie odwołań do członków",
  "MERGE_VARIABLES": "Łączenie zmiennych",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Wymuszenie jawnych argumentów typu",
  "FORCE_EXPLICIT_IMPORTS": "Wymuś jawny import",
  "FLATTEN_SWITCH_BLOCKS": "Spłaszczenie bloków łączników",
  "RETAIN_POINTLESS_SWITCHES": "Zachowaj bezsensowne przełączniki",
  "RETAIN_REDUNDANT_CASTS": "Zatrzymanie zbędnych odlewów",
  "UNICODE_OUTPUT_ENABLED": "Wyjście Unicode włączone",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Przeładuj zasoby",
  "RELOAD_RESOURCES_CONFIRM": "Czy na pewno chcesz ponownie załadować zasoby?",
  "SELECT_FILE_TITLE": "Wybierz plik lub folder do otwarcia w {BCV}.",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, pliki klasowe lub Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Wybierz zewnętrzną wtyczkę",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV Zewnętrzny plugin w js, java, python, ruby lub groovy",
  "FOREIGN_LIBRARY_WARNING": "OSTRZEŻENIE: Po wyłączeniu tej opcji przestarzałe biblioteki NIE zostaną usunięte.\n\rJest to również problem bezpieczeństwa.\n\rWYŁĄCZAJ TO TYLKO JEŚLI WIESZ CO ROBISZ.",
  "RESET_TITLE": "{PRODUCT_NAME} - Resetuj przestrzeń roboczą",
  "RESET_CONFIRM": "Czy na pewno chcesz zresetować przestrzeń roboczą?\n\rSpowoduje to również zresetowanie nawigatora plików i wyszukiwania.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Wyjście",
  "EXIT_CONFIRM": "Czy na pewno chcesz wyjść?",
  "ABOUT_TITLE": "{PRODUCT_NAME} – Informacje – {WITRYNA} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Zamknij wszystko oprócz tego",
  "CLOSE_TAB": "Zamknij kartę",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Proszę wysłać ten dziennik błędów na adres",
  "PLEASE_SEND_RESOURCES": "Jeśli posiadają Państwo odpowiednie prawa do odpowiedniej klasy",
  "ONE_PLUGIN_AT_A_TIME": "W tej chwili działa inny plugin, poczekaj, aż zakończy działanie.",
  "ILLEGAL_ACCESS_ERROR": "W tym celu należy korzystać z oprogramowania Java 15 lub starszego.",


  "FILES": "Pliki",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Szybkie wyszukiwanie plików (bez rozszerzenia pliku)",
  "WORK_SPACE": "Miejsce pracy",
  "EXACT": "Exact",
  "SEARCH": "Szukaj",
  "SEARCH_FROM": "Search From:",
  "SEARCH_STRING": "Search String:",
  "SEARCH_REGEX": "Regex wyszukiwania:",
  "OWNER": "Właściciel:",
  "NAME": "Nazwa:",
  "DESC": "Desc:",
  "SAVE": "Zapisz...",
  "SAVE_AS": "Zapisz jako...",
  "RESULTS": "Wyniki",
  "REFRESH": "Odśwież",
  "ANNOTATION_NAME": "Nazwa adnotacji",
  "MATCH_CASE": "Sprawa meczu",
  "EXACT_PATH": "Dokładna ścieżka",
  "MIN_SDK_VERSION": "Minimalna wersja SDK",
  "PRINT_LINE_NUMBERS": "Drukowanie numerów linii"
}

```

`src/main/resources/translations/portuguese.json`:

```json
{
  "FILE": "Ficheiro",
  "ADD": "Acrescentar...",
  "NEW_WORKSPACE": "Novo Espaço de Trabalho",
  "RELOAD_RESOURCES": "Recarregar Recursos",
  "RUN": "Corre",
  "OPEN": "Aberto...",
  "OPEN_UNSTYLED": "Aberto",
  "QUICK_OPEN": "Abertura rápida",
  "DELETE": "Eliminar",
  "NEW": "Novo",
  "EXPAND": "Expandir",
  "COLLAPSE": "Colapso",
  "COMPILE": "Compilar",
  "SAVE_AS_RUNNABLE_JAR": "Guardar como frasco executável...",
  "SAVE_AS_ZIP": "Guardar como Zip...",
  "SAVE_AS_DEX": "Salvar Como DEX...",
  "SAVE_AS_APK": "Salvar Como APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Descompilar & Salvar Classes Abertas",
  "DECOMPILE_SAVE_ALL_CLASSES": "Descompilar e salvar todas as classes",
  "RECENT_FILES": "Ficheiros recentes",
  "ABOUT": "Sobre",
  "EXIT": "Saída",

  "VIEW": "Ver",
  "VISUAL_SETTINGS": "Definições visuais",
  "PANE_1": "Painel 1",
  "PANE_2": "Painel 2",
  "PANE_3": "Painel 3",
  "NONE": "Nenhum",
  "EDITABLE": "editável",

  "LANGUAGE": "Idioma",
  "FONT_SIZE": "Tamanho de letra",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Mostrar ficheiro no título do separador",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Simplificar nome no título do separador",
  "SYNCHRONIZED_VIEWING": "Visualização Sincronizada",
  "SHOW_CLASS_METHODS": "Mostrar métodos de classe",

  "WINDOW_THEME": "Tema da Janela",
  "SYSTEM_THEME": "Tema do Sistema",
  "DARK_THEME": "Tema Negro",
  "LIGHT_THEME": "Tema Leve",
  "ONE_DARK_THEME": "Um Tema Negro",
  "SOLARIZED_DARK_THEME": "Tema Solarizado Escuro",
  "SOLARIZED_LIGHT_THEME": "Tema da Luz Solarizada",
  "HIGH_CONTRAST_DARK_THEME": "Tema de Alto Contraste Escuro",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema de Luz de Alto Contraste",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Luz Solarizada",
  "HIGH_CONTRAST_DARK": "Escuro de Alto Contraste",
  "HIGH_CONTRAST_LIGHT": "Luz de Alto Contraste",
  "TEXT_AREA_THEME": "Tema Área de Texto",
  "DEFAULT_RECOMMENDED_LIGHT": "Default (Luz recomendada)",
  "THEME_MATCH": "Jogo Temático (Recomendado)",
  "DARK": "Dark (Escuro Recomendado)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Estúdio Visual",
  "DRUID_DARK": "Druida (Escuro)",
  "MONOKAI_DARK": "Monokai (Escuro)",

  "SETTINGS": "Definições",
  "COMPILE_ON_SAVE": "Compilação em Salvar",
  "COMPILE_ON_REFRESH": "Compilar em Actualização",
  "REFRESH_ON_VIEW_CHANGE": "Actualizar em Ver Mudança",
  "DECODE_APK_RESOURCES": "Descodificar recursos APK",
  "APK_CONVERSION": "Conversão APK",
  "APK_CONVERSION_DECODING": "Conversão APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Verificação de actualização",
  "DELETE_UNKNOWN_LIBS": "Eliminar Estrangeiro",
  "FORCE_PURE_ASCII_AS_TEXT": "Forçar Puro Ascii Como Texto",
  "SET_PYTHON_27_EXECUTABLE": "Conjunto Python 2.7 Executável",
  "SET_PYTHON_30_EXECUTABLE": "Conjunto Python 3.X Executável",
  "SET_JRE_RT_LIBRARY": "Conjunto JRE RT Biblioteca",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Conjunto Pasta Opcional da Biblioteca",
  "SET_JAVAC_EXECUTABLE": "Conjunto Javac Executável",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Definições de Procyon",
  "CFR_SETTINGS": "Definições do CFR",
  "FERNFLOWER_SETTINGS": "Definições FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Código Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textificar",

  "BYTECODE_DECOMPILER": "Descompilador de Bytecode",
  "DEBUG_HELPERS": "Ajudantes de Depuração",
  "APPEND_BRACKETS_TO_LABEL": "Anexar parênteses ao rótulo",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Plugin aberto...",
  "RECENT_PLUGINS": "Plugins recentes",
  "CODE_SEQUENCE_DIAGRAM": "Diagrama de Sequência de Códigos",
  "MALICIOUS_CODE_SCANNER": "Leitor de Código Malicioso",
  "SHOW_MAIN_METHODS": "Mostrar métodos principais",
  "SHOW_ALL_STRINGS": "Mostrar todas as cordas",
  "REPLACE_STRINGS": "Substituir Cordas",
  "STACK_FRAMES_REMOVER": "Removedor de armações de empilhamento",
  "ZKM_STRING_DECRYPTER": "Decodificador de Cordas ZKM",
  "ALLATORI_STRING_DECRYPTER": "Descriptor de Cordas Allatori",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decripter",
  "VIEW_ANDROID_PERMISSIONS": "Ver permissões do Android",
  "VIEW_MANIFEST": "Ver Manifesto",
  "CHANGE_CLASSFILE_VERSIONS": "Mudar Versões de Arquivo de Classe",



  "PROCYON_DECOMPILER": "Descompilador Procyon",
  "CFR_DECOMPILER": "Descompilador CFR",
  "FERNFLOWER_DECOMPILER": "Descompilador FernFlower",
  "JADX_DECOMPILER": "Descompilador JADX",
  "JD_DECOMPILER": "Descompilador JD-GUI",
  "BYTECODE_DISASSEMBLER": "Bytecode Desassembler",
  "DISASSEMBLER": "Desassemblador",

  "ERROR": "Erro",
  "NEW_JAVA_PLUGIN": "Novo Plugin Java",
  "NEW_JAVASCRIPT_PLUGIN": "Novo Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Sugestão de reparação: Clique em refresh class, se falhar novamente tente outro descompilador.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Sugestão de correcção: Experimente Ver>Painel>Krakatau>Bytecode e habilite Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ADVERTÊNCIA: Nenhum descompilador está actualmente seleccionado. Experimente View>Paneta e escolha um descompilador.",
  "COMPILER_TIP": "Ter em mente que a maioria dos descompiladores não pode produzir classes compiláveis",
  "FIRST_OPEN_A_RESOURCE": "Primeiro abra um recurso dentro do BCV (classe, frasco, zip ou ficheiro apk)",
  "FIRST_OPEN_A_CLASS": "Primeiro abrir um recurso de classfile dentro do BCV (jarro, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Primeiro ver um ficheiro de classe dentro de um separador.",
  "DRAG_CLASS_JAR": "Classe de arrastamento",

  "YES": "Sim",
  "NO": "Não",
  "ERROR2": "Erro:",
  "PROCESS2": "Processo:",
  "EXIT_VALUE_IS": "O Valor de Saída é:",
  "JAVA_COMPILE_FAILED": "Java Compile Failed",
  "ERROR_COMPILING_CLASS": "Classe de compilação de erros",
  "COMPILER": "Ter em mente que a maioria dos descompiladores não pode produzir classes compiláveis",
  "SELECT_LIBRARY_FOLDER": "Seleccionar pasta da biblioteca",
  "SELECT_JAVA_RT": "Seleccionar JRE RT Jarro",
  "SELECT_JAVA": "Seleccione Java Executável",
  "SELECT_JAVAC": "Seleccione Javac Executável",
  "SELECT_JAVA_TOOLS": "Seleccionar Jarro de Ferramentas Java",
  "SELECT_PYTHON_2": "Seleccionar Python 2.7 Executável",
  "SELECT_PYTHON_3": "Seleccionar Python 3.x Executável",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (ou PyPy 2.7 para velocidade) Executável",
  "PYTHON_3_EXECUTABLE": "Python 3.x (ou PyPy 3.x para velocidade) Executável",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "É necessário definir o seu caminho executável Python 2.7 (ou PyPy 2.7 para velocidade).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Tem de definir o seu caminho executável Python 3.x (ou PyPy 3.x para velocidade).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "É necessário criar a sua Biblioteca JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:Ficheiros de programa Java Jre7librt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Dentro do JRE C:",
  "JAVAC_EXECUTABLE": "Javac Executável (Requer JDK C:",
  "JAVA_TOOLS_JAR": "Jarro de Ferramentas Java (Dentro do JDK C:",
  "JAVA_RT_JAR": "Java RT Jarro (Dentro do JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Pasta opcional de biblioteca (Compilador & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Esconder métodos de ponte",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Ocultar membros da classe sintética",
  "DECOMPILE_INNER_CLASSES": "Descompilar classes internas",
  "COLLAPSE_14_CLASS_REFERENCES": "Colapso de referências de classe 1.4",
  "DECOMPILE_ASSERTIONS": "Afirmações descompiladas",
  "HIDE_EMPTY_SUPER_INVOCATION": "Esconder super invocação vazia",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Esconder construtor por defeito vazio",
  "DECOMPILE_GENERIC_SIGNATURES": "Descompilar as assinaturas genéricas",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Assumir que o retorno não lança excepções",
  "DECOMPILE_ENUMERATIONS": "Contagens de descompilação",
  "REMOVE_GETCLASS_INVOCATION": "Remover a invocação getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretar o int 1 como verdadeiro booleano",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Permitir não definir atributo sintético",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Considere tipos sem nome como java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruir nomes de variáveis a partir de informações de depuração",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Remover intervalos de excepção vazios",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finalmente estruturas",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Permitir apenas caracteres ASCII em cordas",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Renomear classes e elementos de classe ambíguos",

  "DECODE_ENUM_SWITCH": "Interruptor Enum de descodificação",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Interruptor de Cordas de Descodificação",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Coleccionador",
  "INNER_CLASSES": "Aulas Internas",
  "REMOVE_BOILER_PLATE": "Remover placa da caldeira",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Remover Sintéticos de Classe Interior",
  "DECODE_LAMBDAS": "Descodificar Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Construtor de Elevadores Init",
  "REMOVE_DEAD_METHODS": "Remover Métodos Mortos",
  "REMOVE_BAD_GENERICS": "Remover Genéricos Maus",
  "SUGAR_ASSERTS": "Afirmações sobre o açúcar",
  "SUGAR_BOXING": "Boxe do açúcar",
  "SHOW_VERSION": "Mostrar Versão",
  "DECODE_FINALLY": "Decodificar finalmente",
  "TIDY_MONITORS": "Monitores Tidy",
  "LENIENT": "Leniente",
  "DUMP_CLASSPATH": "Classpath de lixeira",
  "COMMENTS": "Comentários",
  "FORCE_TOP_SORT": "Forçar o Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Forçar o Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Forçar a Poda de Excepção",
  "STRING_BUFFER": "Buffer de Cordas",
  "STRING_BUILDER": "Construtor de cordas",
  "SILENT": "Silencioso",
  "RECOVER": "Recuperar",
  "OVERRIDE": "Anular",
  "SHOW_INFERRABLE": "Mostrar Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Forçar a Propagação do Condado",
  "HIDE_UTF": "Ocultar UTF",
  "HIDE_LONG_STRINGS": "Esconder Cordas Longas",
  "COMMENT_MONITORS": "Monitores de Comentários",
  "ALLOW_CORRECTING": "Permitir Correcção",
  "LABELLED_BLOCKS": "Blocos etiquetados",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Ocultar Importações de Lang",
  "RECOVER_TYPE_CLASH": "Recuperar tipo Clash",
  "RECOVER_TYPE__HINTS": "Dicas de recuperação do tipo",
  "FORCE_RETURNING_IFS": "Força de Retorno IFs",
  "FOR_LOOP_AGG_CAPTURE": "Para Captura de Loop AGG",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Gerar Sempre Variável de Excepção para Blocos de Captura",
  "EXCLUDE_NESTED_TYPES": "Excluir tipos aninhados",
  "SHOW_DEBUG_LINE_NUMBERS": "Mostrar números de linhas de depuração",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Incluir números de linha em Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Incluir diagnóstico de erros",
  "SHOW_SYNTHETIC_MEMBERS": "Mostrar Membros Sintéticos",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplificar as Referências dos Membros",
  "MERGE_VARIABLES": "Fundir Variáveis",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Argumentos do tipo Força Explicita",
  "FORCE_EXPLICIT_IMPORTS": "Forçar Importações Explícitas",
  "FLATTEN_SWITCH_BLOCKS": "Blocos de Interruptor achatados",
  "RETAIN_POINTLESS_SWITCHES": "Interruptores sem pontas de retenção",
  "RETAIN_REDUNDANT_CASTS": "Retenção de Castas Redundantes",
  "UNICODE_OUTPUT_ENABLED": "Saída Unicode Activada",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Recarregar Recursos",
  "RELOAD_RESOURCES_CONFIRM": "Tem a certeza de que deseja recarregar os recursos?",
  "SELECT_FILE_TITLE": "Seleccione File ou Folder para abrir em {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Arquivos de Classe ou Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Seleccionar Plugin Externo",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV Plugin externo em js, java, python, ruby ou groovy",
  "FOREIGN_LIBRARY_WARNING": "ADVERTÊNCIA: Com isto a ser alternado bibliotecas desactualizadas, NÃO será removido.\n\rÉ também uma questão de segurança.\n\rSÓ O DESLIGUE SE SOUBER O QUE ESTÁ A FAZER.",
  "RESET_TITLE": "{PRODUCT_NAME} - Repor o espaço de trabalho",
  "RESET_CONFIRM": "Tem a certeza de que quer redefinir o espaço de trabalho?\n\rTambém reiniciará o seu navegador de ficheiros e a sua pesquisa.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Saída",
  "EXIT_CONFIRM": "Tem a certeza de que quer sair?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Sobre - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Consola de Plugin",
  "CLOSE_ALL_BUT_THIS": "Fechar tudo menos isto",
  "CLOSE_TAB": "Aba fechar",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Por favor envie este registo de erros para",
  "PLEASE_SEND_RESOURCES": "Se detém os direitos legais adequados à classe em questão",
  "ONE_PLUGIN_AT_A_TIME": "Existe actualmente outro plugin em funcionamento neste momento, por favor aguarde que este termine a execução.",
  "ILLEGAL_ACCESS_ERROR": "Por favor, utilize Java 15 ou mais antigo para o fazer.",


  "FILES": "Ficheiros",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Pesquisa rápida de ficheiros (sem extensão de ficheiro)",
  "WORK_SPACE": "Espaço de trabalho",
  "EXACT": "Exacto",
  "SEARCH": "Pesquisa",
  "SEARCH_FROM": "Procurar desde:",
  "SEARCH_STRING": "Pesquisar String:",
  "SEARCH_REGEX": "Pesquisa Regex:",
  "OWNER": "Proprietário:",
  "NAME": "Nome:",
  "DESC": "Desc:",
  "SAVE": "Salvar...",
  "SAVE_AS": "Salvar Como...",
  "RESULTS": "Resultados",
  "REFRESH": "Actualizar",
  "ANNOTATION_NAME": "Nome da anotação",
  "MATCH_CASE": "Caso de jogo",
  "EXACT_PATH": "Caminho Exacto",
  "MIN_SDK_VERSION": "Versão mínima SDK",
  "PRINT_LINE_NUMBERS": "Números de linha de impressão"
}

```

`src/main/resources/translations/romanian.json`:

```json
{
  "FILE": "Fișier",
  "ADD": "Adăugați...",
  "NEW_WORKSPACE": "Spațiu de lucru nou",
  "RELOAD_RESOURCES": "Reîncărcați resursele",
  "RUN": "Rulați",
  "OPEN": "Deschideți...",
  "OPEN_UNSTYLED": "Deschideți",
  "QUICK_OPEN": "Deschidere rapidă",
  "DELETE": "Ștergeți",
  "NEW": "Nou",
  "EXPAND": "Extindeți",
  "COLLAPSE": "Colaps",
  "COMPILE": "Compilați",
  "SAVE_AS_RUNNABLE_JAR": "Salvați ca un borcan executabil...",
  "SAVE_AS_ZIP": "Salvați ca Zip...",
  "SAVE_AS_DEX": "Salvați ca DEX...",
  "SAVE_AS_APK": "Salvați ca APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Decompilați și salvați clasele deschise",
  "DECOMPILE_SAVE_ALL_CLASSES": "Decompilați și salvați toate clasele",
  "RECENT_FILES": "Fișiere recente",
  "ABOUT": "Despre",
  "EXIT": "Ieșire",

  "VIEW": "Vezi",
  "VISUAL_SETTINGS": "Setări vizuale",
  "PANE_1": "Panoul 1",
  "PANE_2": "Panoul 2",
  "PANE_3": "Panoul 3",
  "NONE": "Nici unul",
  "EDITABLE": "Editabil",

  "LANGUAGE": "Limba",
  "FONT_SIZE": "Mărimea fontului",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Afișați fișierul în titlul filei",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Simplificarea numelui în titlul filei",
  "SYNCHRONIZED_VIEWING": "Vizualizare sincronizată",
  "SHOW_CLASS_METHODS": "Afișați metodele clasei",

  "WINDOW_THEME": "Tema ferestrei",
  "SYSTEM_THEME": "Tema sistemului",
  "DARK_THEME": "Tema întunecată",
  "LIGHT_THEME": "Tema luminii",
  "ONE_DARK_THEME": "O temă întunecată",
  "SOLARIZED_DARK_THEME": "Solarized Dark Theme",
  "SOLARIZED_LIGHT_THEME": "Tema luminii solarizate",
  "HIGH_CONTRAST_DARK_THEME": "Tema întunecată cu contrast ridicat",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema de lumină cu contrast ridicat",
  "ONE_DARK": "Un întuneric",
  "SOLARIZED_DARK": "Întuneric solarizat",
  "SOLARIZED_LIGHT": "Lumină solarizată",
  "HIGH_CONTRAST_DARK": "Contrast ridicat întunecat",
  "HIGH_CONTRAST_LIGHT": "Lumină cu contrast ridicat",
  "TEXT_AREA_THEME": "Tema zonei de text",
  "DEFAULT_RECOMMENDED_LIGHT": "Implicit (lumină recomandată)",
  "THEME_MATCH": "Meci tematic (recomandat)",
  "DARK": "Întunecat (recomandat întunecat)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (Întuneric)",
  "MONOKAI_DARK": "Monokai (Întuneric)",

  "SETTINGS": "Setări",
  "COMPILE_ON_SAVE": "Compilare la salvare",
  "COMPILE_ON_REFRESH": "Compilare la reîmprospătare",
  "REFRESH_ON_VIEW_CHANGE": "Actualizare la schimbarea vizualizării",
  "DECODE_APK_RESOURCES": "Decode APK Resurse",
  "APK_CONVERSION": "Conversia APK",
  "APK_CONVERSION_DECODING": "Conversia APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Verificarea actualizării",
  "DELETE_UNKNOWN_LIBS": "Ștergeți Externe",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii As Text",
  "SET_PYTHON_27_EXECUTABLE": "Setați Python 2.7 Executabil",
  "SET_PYTHON_30_EXECUTABLE": "Setați Python 3.X Executabil",
  "SET_JRE_RT_LIBRARY": "Setați biblioteca JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Setați folderul opțional al bibliotecii",
  "SET_JAVAC_EXECUTABLE": "Setați Javac Executabil",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Setări Procyon",
  "CFR_SETTINGS": "Setări CFR",
  "FERNFLOWER_SETTINGS": "FernFlower Setări",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Codul hexagonal",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Descompilator de Bytecode",
  "DEBUG_HELPERS": "Ajutoare de depanare",
  "APPEND_BRACKETS_TO_LABEL": "Adăugați paranteze la etichetă",

  "PLUGINS": "Plugin-uri",
  "OPEN_PLUGIN": "Deschideți Plugin...",
  "RECENT_PLUGINS": "Plugin-uri recente",
  "CODE_SEQUENCE_DIAGRAM": "Diagramă de secvență de cod",
  "MALICIOUS_CODE_SCANNER": "Scanner de coduri malițioase",
  "SHOW_MAIN_METHODS": "Afișați metodele principale",
  "SHOW_ALL_STRINGS": "Afișați toate corzile",
  "REPLACE_STRINGS": "Înlocuirea șirurilor de caractere",
  "STACK_FRAMES_REMOVER": "Eliminarea cadrelor de stivă",
  "ZKM_STRING_DECRYPTER": "ZKM String Decripter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decripter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Vizualizați permisiunile Android",
  "VIEW_MANIFEST": "Vezi Manifestul",
  "CHANGE_CLASSFILE_VERSIONS": "Schimbarea versiunilor ClassFile",



  "PROCYON_DECOMPILER": "Descompilatorul Procyon",
  "CFR_DECOMPILER": "Descompilator CFR",
  "FERNFLOWER_DECOMPILER": "Descompilatorul FernFlower",
  "JADX_DECOMPILER": "Descompilator JADX",
  "JD_DECOMPILER": "Decompilator JD-GUI",
  "BYTECODE_DISASSEMBLER": "Dezasamblatorul de bytecode",
  "DISASSEMBLER": "Dezasamblatorul",

  "ERROR": "Eroare",
  "NEW_JAVA_PLUGIN": "Noul Plugin Java",
  "NEW_JAVASCRIPT_PLUGIN": "Noul Plugin Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Soluție sugerată: Faceți clic pe refresh class, dacă nu reușește din nou, încercați un alt descompilator.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Soluție sugerată: Încercați View>Pane>Krakatau>Bytecode și activați Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "AVERTISMENT: În prezent nu este selectat niciun descompilator. Încercați View>Pane și alegeți un decompiler.",
  "COMPILER_TIP": "Rețineți că majoritatea decompilatoarelor nu pot produce clase compilabile.",
  "FIRST_OPEN_A_RESOURCE": "Mai întâi deschideți o resursă în interiorul BCV (fișier class, jar, zip sau apk)",
  "FIRST_OPEN_A_CLASS": "Mai întâi deschideți o resursă classfile în interiorul BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Vizualizați mai întâi un fișier de clasă în interiorul unei file.",
  "DRAG_CLASS_JAR": "Clasa Drag",

  "YES": "Da",
  "NO": "Nu",
  "ERROR2": "Eroare:",
  "PROCESS2": "Proces:",
  "EXIT_VALUE_IS": "Valoarea de ieșire este:",
  "JAVA_COMPILE_FAILED": "Compilarea Java a eșuat",
  "ERROR_COMPILING_CLASS": "Eroare la compilarea clasei",
  "COMPILER": "Rețineți că majoritatea decompilatoarelor nu pot produce clase compilabile.",
  "SELECT_LIBRARY_FOLDER": "Selectați dosarul bibliotecii",
  "SELECT_JAVA_RT": "Selectați JRE RT Jar",
  "SELECT_JAVA": "Selectați Java Executable",
  "SELECT_JAVAC": "Selectați Javac Executable",
  "SELECT_JAVA_TOOLS": "Selectați Java Tools Jar",
  "SELECT_PYTHON_2": "Selectați Python 2.7 Executabil",
  "SELECT_PYTHON_3": "Selectați Python 3.x Executabil",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (sau PyPy 2.7 pentru viteză) Executabil",
  "PYTHON_3_EXECUTABLE": "Python 3.x (sau PyPy 3.x pentru viteză) Executabil",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Trebuie să setați calea executabilului Python 2.7 (sau PyPy 2.7 pentru viteză).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Trebuie să setați calea executabilului Python 3.x (sau PyPy 3.x pentru viteză).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Trebuie să setați JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executabil (în interiorul JRE C:",
  "JAVAC_EXECUTABLE": "Javac Executabil (Necesită JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (în interiorul JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (în interiorul JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Dosar de bibliotecă opțional (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Ascundeți metodele de pod",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Ascundeți membrii clasei sintetice",
  "DECOMPILE_INNER_CLASSES": "Decompilați clasele interioare",
  "COLLAPSE_14_CLASS_REFERENCES": "Colaps 1.4 referințe de clasă",
  "DECOMPILE_ASSERTIONS": "Decompilați afirmațiile",
  "HIDE_EMPTY_SUPER_INVOCATION": "Ascunde invocarea goală a super-invocării",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Ascundeți constructorul implicit gol",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompilați semnăturile generice",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Să presupunem că returnarea nu aruncă excepții",
  "DECOMPILE_ENUMERATIONS": "Descompunerea enumerărilor",
  "REMOVE_GETCLASS_INVOCATION": "Eliminarea invocării getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretează int 1 ca boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Permiteți să nu setați atributul sintetic",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Luați în considerare tipurile fără nume ca java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstituie numele variabilelor din informațiile de depanare",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Eliminarea intervalelor de excepție goale",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline în cele din urmă structuri",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Permite numai caractere ASCII în șiruri de caractere",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Redenumirea claselor și a elementelor de clasă ambigue",

  "DECODE_ENUM_SWITCH": "Decodare Enum Comutator",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Decodificarea șirului de caractere Comutator",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Clase interioare",
  "REMOVE_BOILER_PLATE": "Îndepărtați placa cazanului",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Îndepărtați sinteticele din clasa interioară",
  "DECODE_LAMBDAS": "Decodificarea Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift Constructor Init",
  "REMOVE_DEAD_METHODS": "Eliminați metodele moarte",
  "REMOVE_BAD_GENERICS": "Eliminați genericele rele",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Arată versiunea",
  "DECODE_FINALLY": "Decodare În sfârșit",
  "TIDY_MONITORS": "Monitoarele Tidy",
  "LENIENT": "Lenent",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Comentarii",
  "FORCE_TOP_SORT": "Forțați sortarea de sus",
  "FORCE_TOP_SORT_AGGRESS": "Forța Top Sort Agresivitate",
  "FORCE_EXCEPTION_PRUNE": "Forțarea excepției Prune",
  "STRING_BUFFER": "Buffer de șiruri",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Recuperează",
  "OVERRIDE": "Anulare",
  "SHOW_INFERRABLE": "Arată Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Forța Cond Propagare",
  "HIDE_UTF": "Ascundeți UTF",
  "HIDE_LONG_STRINGS": "Ascundeți corzile lungi",
  "COMMENT_MONITORS": "Monitoare de comentarii",
  "ALLOW_CORRECTING": "Permiteți corectarea",
  "LABELLED_BLOCKS": "Blocuri etichetate",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Ascundeți Lang Imports",
  "RECOVER_TYPE_CLASH": "Recuperează tipul Clash",
  "RECOVER_TYPE__HINTS": "Sugestii de tip Recover",
  "FORCE_RETURNING_IFS": "Forța de întoarcere a IF-urilor",
  "FOR_LOOP_AGG_CAPTURE": "Pentru bucla de captură AGG",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Generarea întotdeauna a unei variabile de excepție pentru blocurile Catch",
  "EXCLUDE_NESTED_TYPES": "Excluderea tipurilor imbricate",
  "SHOW_DEBUG_LINE_NUMBERS": "Afișați numerele de linie de depanare",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Includeți numere de linie în Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Includeți diagnosticarea erorilor",
  "SHOW_SYNTHETIC_MEMBERS": "Afișați membrii sintetici",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplificați referințele membrilor",
  "MERGE_VARIABLES": "Combinarea variabilelor",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Forțarea argumentelor explicite de tip",
  "FORCE_EXPLICIT_IMPORTS": "Forțați importurile explicite",
  "FLATTEN_SWITCH_BLOCKS": "Aplatizați blocurile de comutare",
  "RETAIN_POINTLESS_SWITCHES": "Rețineți comutatoarele inutile",
  "RETAIN_REDUNDANT_CASTS": "Păstrați distribuțiile redundante",
  "UNICODE_OUTPUT_ENABLED": "Ieșire Unicode activată",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Reîncărcați resursele",
  "RELOAD_RESOURCES_CONFIRM": "Sunteți sigur că doriți să reîncărcați resursele?",
  "SELECT_FILE_TITLE": "Selectați File sau Folder pentru a deschide în {BCV}.",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Fișiere de clasă sau Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Selectați Plugin extern",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Plugin extern BCV în js, java, python, ruby sau groovy",
  "FOREIGN_LIBRARY_WARNING": "AVERTISMENT: Dacă această opțiune este dezactivată, bibliotecile învechite NU vor fi eliminate.\n\rEste, de asemenea, o problemă de securitate.\n\rDEZACTIVAȚI-O DOAR DACĂ ȘTIȚI CE FACEȚI.",
  "RESET_TITLE": "{PRODUCT_NAME} - Resetare spațiu de lucru",
  "RESET_CONFIRM": "Sunteți sigur că doriți să resetați spațiul de lucru?\n\rDe asemenea, se va reseta navigatorul de fișiere și căutarea.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Ieșire",
  "EXIT_CONFIRM": "Ești sigur că vrei să ieși?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Despre - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Consola Plugin",
  "CLOSE_ALL_BUT_THIS": "Închideți totul în afară de asta",
  "CLOSE_TAB": "Închideți fila",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Vă rugăm să trimiteți acest jurnal de erori la",
  "PLEASE_SEND_RESOURCES": "În cazul în care dețineți drepturi legale corespunzătoare pentru clasa respectivă",
  "ONE_PLUGIN_AT_A_TIME": "În prezent, un alt plugin rulează în acest moment, vă rugăm să așteptați ca acesta să se termine de executat.",
  "ILLEGAL_ACCESS_ERROR": "Vă rugăm să utilizați Java 15 sau o versiune mai veche pentru a face acest lucru.",


  "FILES": "Fișiere",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Căutare rapidă a fișierelor (fără extensie de fișier)",
  "WORK_SPACE": "Spațiu de lucru",
  "EXACT": "Exact",
  "SEARCH": "Căutare",
  "SEARCH_FROM": "Căutare de la:",
  "SEARCH_STRING": "Șir de căutare:",
  "SEARCH_REGEX": "Căutare Regex:",
  "OWNER": "Proprietar:",
  "NAME": "Numele:",
  "DESC": "Desc:",
  "SAVE": "Salvați...",
  "SAVE_AS": "Salvați ca...",
  "RESULTS": "Rezultate",
  "REFRESH": "Reîmprospătați",
  "ANNOTATION_NAME": "Denumire adnotare",
  "MATCH_CASE": "Caz de meci",
  "EXACT_PATH": "Calea exactă",
  "MIN_SDK_VERSION": "Versiunea minimă a SDK",
  "PRINT_LINE_NUMBERS": "Imprimă numere de linie"
}

```

`src/main/resources/translations/russian.json`:

```json
{
  "FILE": "Файл",
  "ADD": "Добавить...",
  "NEW_WORKSPACE": "Новое рабочее пространство",
  "RELOAD_RESOURCES": "Перезагрузить ресурсы",
  "RUN": "Запустить",
  "OPEN": "Открыть...",
  "OPEN_UNSTYLED": "Открыть",
  "QUICK_OPEN": "Быстрое открытие",
  "DELETE": "Удалить",
  "NEW": "Новый",
  "EXPAND": "Развернуть",
  "COLLAPSE": "Коллапс",
  "COMPILE": "Компилировать",
  "SAVE_AS_RUNNABLE_JAR": "Сохранить как запускаемый JAR ...",
  "SAVE_AS_ZIP": "Сохранить как Zip ...",
  "SAVE_AS_DEX": "Сохранить как DEX ...",
  "SAVE_AS_APK": "Сохранить как APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Декомпилировать и сохранить открытые классы",
  "DECOMPILE_SAVE_ALL_CLASSES": "Декомпилировать и сохранить все классы",
  "RECENT_FILES": "Недавние файлы",
  "ABOUT": "О программе",
  "EXIT": "Выход",

  "VIEW": "Вид",
  "VISUAL_SETTINGS": "Визуальные настройки",
  "PANE_1": "Панель 1",
  "PANE_2": "Панель 2",
  "PANE_3": "Панель 3",
  "NONE": "Нет",
  "EDITABLE": "Редактируемый",

  "LANGUAGE": "Язык",
  "FONT_SIZE": "Размер шрифта",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Показать файл в заголовке вкладки",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Упростить имя в заголовке вкладки",
  "SYNCHRONIZED_VIEWING": "Синхронизировать просмотр",
  "SHOW_CLASS_METHODS": "Показать методы класса",

  "WINDOW_THEME": "Тема окна",
  "SYSTEM_THEME": "Системная тема",
  "DARK_THEME": "Темная тема",
  "LIGHT_THEME": "Светлая тема",
  "ONE_DARK_THEME": "Одна темная тема",
  "SOLARIZED_DARK_THEME": "Соляризованная темная тема",
  "SOLARIZED_LIGHT_THEME": "Тема солнечного света",
  "HIGH_CONTRAST_DARK_THEME": "Темная тема с высокой контрастностью",
  "HIGH_CONTRAST_LIGHT_THEME": "Тема с высокой контрастностью света",
  "ONE_DARK": "Один темный",
  "SOLARIZED_DARK": "Соляризованная тьма",
  "SOLARIZED_LIGHT": "Соляризованный свет",
  "HIGH_CONTRAST_DARK": "Высококонтрастный темный",
  "HIGH_CONTRAST_LIGHT": "Высококонтрастный свет",
  "TEXT_AREA_THEME": "Тема текстовой области",
  "DEFAULT_RECOMMENDED_LIGHT": "Тема по умолчанию (рекомендуется светлая)",
  "THEME_MATCH": "Соответствие темы (рекомендуется)",
  "DARK": "Темный (рекомендуется темный)",
  "DARK_ALT": "Темный-Альт",
  "DEFAULT_ALT": "По умолчанию-альтернативная",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (Темная)",
  "MONOKAI_DARK": "Monokai (Темная)",

  "SETTINGS": "Настройки",
  "COMPILE_ON_SAVE": "Скомпилировать при сохранении",
  "COMPILE_ON_REFRESH": "Скомпилировать при обновлении",
  "REFRESH_ON_VIEW_CHANGE": "Обновлять при изменении просмотра",
  "DECODE_APK_RESOURCES": "Расшифровать ресурсы APK",
  "APK_CONVERSION": "Конвертация APK",
  "APK_CONVERSION_DECODING": "Конвертация APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Проверка обновления",
  "DELETE_UNKNOWN_LIBS": "Удалить чужие / устаревшие библиотеки",
  "FORCE_PURE_ASCII_AS_TEXT": "Принудительно использовать чистый ASCII как текст",
  "SET_PYTHON_27_EXECUTABLE": "Указать исполняемый файл Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Указать исполняемый файл Python 3.X",
  "SET_JRE_RT_LIBRARY": "Указать библиотеку JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Указать папку дополнительных библиотек",
  "SET_JAVAC_EXECUTABLE": "Указать исполняемый файл Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Настройки Procyon",
  "CFR_SETTINGS": "Настройки CFR",
  "FERNFLOWER_SETTINGS": "Параметры цветка папоротника",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali/Dex",
  "HEXCODE": "Шестнадцатеричный код",
  "BYTECODE": "Байт-код",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Декомпилятор байт-кода",
  "DEBUG_HELPERS": "Помощники отладки",
  "APPEND_BRACKETS_TO_LABEL": "Добавить скобки к названию",

  "PLUGINS": "Плагины",
  "OPEN_PLUGIN": "Открыть плагин ...",
  "RECENT_PLUGINS": "Недавние плагины",
  "CODE_SEQUENCE_DIAGRAM": "Диаграмма последовательности кода",
  "MALICIOUS_CODE_SCANNER": "Сканер вредоносного кода",
  "SHOW_MAIN_METHODS": "Показать методы Main",
  "SHOW_ALL_STRINGS": "Показать все строки",
  "REPLACE_STRINGS": "Заменить строки",
  "STACK_FRAMES_REMOVER": "Убрать стековые кадры (фреймы)",
  "ZKM_STRING_DECRYPTER": "Расшифровать строки (ZKM)",
  "ALLATORI_STRING_DECRYPTER": "Расшифровать строки (Allatori)",
  "ZSTRINGARRAY_DECRYPTER": "Расшифровать (ZStringArray)",
  "VIEW_ANDROID_PERMISSIONS": "Просмотр разрешений Android",
  "VIEW_MANIFEST": "Посмотреть манифест",
  "CHANGE_CLASSFILE_VERSIONS": "Изменение версий файлов классов",



  "PROCYON_DECOMPILER": "Декомпилятор Procyon",
  "CFR_DECOMPILER": "Декомпилятор CFR",
  "FERNFLOWER_DECOMPILER": "Декомпилятор FernFlower",
  "JADX_DECOMPILER": "Декомпилятор JADX",
  "JD_DECOMPILER": "Декомпилятор JD-GUI",
  "BYTECODE_DISASSEMBLER": "Дизассемблер байт-кода",
  "DISASSEMBLER": "Дизассемблер",

  "ERROR": "Ошибка",
  "NEW_JAVA_PLUGIN": "Новый плагин Java",
  "NEW_JAVASCRIPT_PLUGIN": "Новый плагин Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Предлагаемое исправление: нажмите «Обновить класс», если не получится снова, то попробуйте другой декомпилятор.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Предлагаемое исправление: попробуйте «Вид»> «Панель»> «Krakatau»> «Байт-код» и включите «Редактируемый».",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ВНИМАНИЕ: В настоящее время не выбран ни один декомпилятор. Попробуйте Вид>Панель и выберите декомпилятор.",
  "COMPILER_TIP": "Следует помнить, что большинство декомпиляторов не могут создавать компилируемые классы",
  "FIRST_OPEN_A_RESOURCE": "Сначала откройте ресурс внутри BCV (класс, jar, zip или apk файл).",
  "FIRST_OPEN_A_CLASS": "Сначала откройте ресурс classfile внутри BCV (jar, zip, apk, dex).",
  "FIRST_VIEW_A_CLASS": "Сначала просмотрите файл класса внутри вкладки.",
  "DRAG_CLASS_JAR": "Перетащите сюда class / jar / zip / APK / DEX",

  "YES": "Да",
  "NO": "Нет",
  "ERROR2": "Ошибка:",
  "PROCESS2": "Процесс:",
  "EXIT_VALUE_IS": "Exit Value - это:",
  "JAVA_COMPILE_FAILED": "Java Compile Failed",
  "ERROR_COMPILING_CLASS": "Ошибка компиляции класса",
  "COMPILER": "Следует помнить, что большинство декомпиляторов не могут создавать компилируемые классы",
  "SELECT_LIBRARY_FOLDER": "Выберите папку библиотеки",
  "SELECT_JAVA_RT": "Выберите JRE RT Jar",
  "SELECT_JAVA": "Выберите исполняемый файл Java",
  "SELECT_JAVAC": "Выберите исполняемый файл Javac",
  "SELECT_JAVA_TOOLS": "Выберите Java Tools Jar",
  "SELECT_PYTHON_2": "Выберите исполняемый файл Python 2.7",
  "SELECT_PYTHON_3": "Выберите исполняемый файл Python 3.x",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (или PyPy 2.7 для скорости) Исполняемый файл",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Или PyPy 3.x для скорости) Исполняемый файл",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Вам нужно установить путь к исполняемому файлу Python 2.7 (или PyPy 2.7 для скорости).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Вам нужно установить путь к исполняемому файлу Python 3.x (или PyPy 3.x для скорости).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Вам необходимо установить библиотеку JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C:",
  "JAVAC_EXECUTABLE": "Исполняемый файл Javac (требуется JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (внутри JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Дополнительная папка библиотеки (Компилятор и Кракатау)",

  "HIDE_BRIDGE_METHODS": "Методы скрытия мостов",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Скрыть синтетические члены класса",
  "DECOMPILE_INNER_CLASSES": "Декомпиляция внутренних классов",
  "COLLAPSE_14_CLASS_REFERENCES": "Свернуть 1.4 ссылки на классы",
  "DECOMPILE_ASSERTIONS": "Декомпиляция утверждений",
  "HIDE_EMPTY_SUPER_INVOCATION": "Скрыть пустой вызов суперприложения",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Скрыть пустой конструктор по умолчанию",
  "DECOMPILE_GENERIC_SIGNATURES": "Декомпиляция типовых сигнатур",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Предположим, что возврат не приводит к исключениям",
  "DECOMPILE_ENUMERATIONS": "Декомпиляция перечислений",
  "REMOVE_GETCLASS_INVOCATION": "Удалить вызов getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Интерпретируйте int 1 как boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Разрешить не устанавливать синтетический атрибут",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Рассматривайте безымянные типы как java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Восстановление имен переменных из отладочной информации",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Удаление пустых диапазонов исключений",
  "DEINLINE_FINALLY_STRUCTURES": "Деинлайн окончательных структур",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Разрешить использование в строках только символов ASCII",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Переименование неоднозначных классов и элементов классов",

  "DECODE_ENUM_SWITCH": "Декодирование переключателя перечислений",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Переключатель строк декодирования",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Коллекционер",
  "INNER_CLASSES": "Внутренние классы",
  "REMOVE_BOILER_PLATE": "Снимите плиту котла",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Удалить синтетику внутреннего класса",
  "DECODE_LAMBDAS": "Декодирование ламбд",
  "LIFT__CONSTRUCTOR_INIT": "Подъемный конструктор Init",
  "REMOVE_DEAD_METHODS": "Удаление мертвых методов",
  "REMOVE_BAD_GENERICS": "Удаление плохих дженериков",
  "SUGAR_ASSERTS": "Сахарные утверждения",
  "SUGAR_BOXING": "Сахарный бокс",
  "SHOW_VERSION": "Показать версию",
  "DECODE_FINALLY": "Наконец-то декодировать",
  "TIDY_MONITORS": "Аккуратные мониторы",
  "LENIENT": "Снисходительный",
  "DUMP_CLASSPATH": "Сбросить класспат",
  "COMMENTS": "Комментарии",
  "FORCE_TOP_SORT": "Принудительная сортировка сверху",
  "FORCE_TOP_SORT_AGGRESS": "Форс Топ Сорт Агрессия",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "Строковый буфер",
  "STRING_BUILDER": "Строкостроитель",
  "SILENT": "Silent",
  "RECOVER": "Восстановить",
  "OVERRIDE": "Переопределение",
  "SHOW_INFERRABLE": "Показать Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Распространение силы",
  "HIDE_UTF": "Скрыть UTF",
  "HIDE_LONG_STRINGS": "Прячьте длинные струны",
  "COMMENT_MONITORS": "Мониторы комментариев",
  "ALLOW_CORRECTING": "Разрешить коррекцию",
  "LABELLED_BLOCKS": "Маркированные блоки",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Восстановить тип столкновения",
  "RECOVER_TYPE__HINTS": "Подсказки по восстановлению типа",
  "FORCE_RETURNING_IFS": "Силы, возвращающие ПЧ",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Всегда генерируйте переменную исключения для блоков Catch",
  "EXCLUDE_NESTED_TYPES": "Исключение вложенных типов",
  "SHOW_DEBUG_LINE_NUMBERS": "Показать номера строк отладки",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Включение номеров строк в байткод",
  "INCLUDE_ERROR_DIAGNOSTICS": "Включить диагностику ошибок",
  "SHOW_SYNTHETIC_MEMBERS": "Показать синтетические члены",
  "SIMPLIFY_MEMBER_REFERENCES": "Упростить ссылки на участников",
  "MERGE_VARIABLES": "Объединить переменные",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Принуждение явных аргументов типа",
  "FORCE_EXPLICIT_IMPORTS": "Принудительный явный импорт",
  "FLATTEN_SWITCH_BLOCKS": "Расплющить блоки выключателей",
  "RETAIN_POINTLESS_SWITCHES": "Сохраняйте бессмысленные переключатели",
  "RETAIN_REDUNDANT_CASTS": "Сохраняйте лишние ролики",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Перезагрузка ресурсов",
  "RELOAD_RESOURCES_CONFIRM": "Вы уверены, что хотите перезагрузить ресурсы?",
  "SELECT_FILE_TITLE": "Выберите файл или папку для открытия в {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, файлы классов или Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Выберите внешний плагин",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin на js, java, python, ruby или groovy",
  "FOREIGN_LIBRARY_WARNING": "ПРЕДУПРЕЖДЕНИЕ: При отключении этого параметра устаревшие библиотеки НЕ будут удалены.\n\rЭто также является проблемой безопасности.\n\rВЫКЛЮЧАЙТЕ ЕГО, ТОЛЬКО ЕСЛИ ВЫ ЗНАЕТЕ, ЧТО ДЕЛАЕТЕ.",
  "RESET_TITLE": "{PRODUCT_NAME} - Сброс рабочего пространства",
  "RESET_CONFIRM": "Вы уверены, что хотите сбросить рабочее пространство?\n\rЭто также приведет к сбросу навигатора файлов и поиска.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Выход",
  "EXIT_CONFIRM": "Вы уверены, что хотите выйти?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - О компании - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Консоль плагинов",
  "CLOSE_ALL_BUT_THIS": "Закрыть все, кроме этого",
  "CLOSE_TAB": "Закрыть вкладку",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Пожалуйста, отправьте этот журнал ошибок по адресу",
  "PLEASE_SEND_RESOURCES": "Если вы обладаете соответствующими юридическими правами на соответствующий класс",
  "ONE_PLUGIN_AT_A_TIME": "В данный момент работает другой плагин, пожалуйста, дождитесь его завершения.",
  "ILLEGAL_ACCESS_ERROR": "Для этого используйте Java 15 или старше.",


  "FILES": "Файлы",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Быстрый поиск файлов (без расширения)",
  "WORK_SPACE": "Рабочее пространство",
  "EXACT": "Точное совпадение",
  "SEARCH": "Поиск",
  "SEARCH_FROM": "Искать в: ",
  "SEARCH_STRING": "Строка поиска: ",
  "SEARCH_REGEX": "Искать Regex: ",
  "OWNER": "Владелец: ",
  "NAME": "Имя: ",
  "DESC": "Описание: ",
  "SAVE": "Сохранить...",
  "SAVE_AS": "Сохранить как...",
  "RESULTS": "Полученные результаты",
  "REFRESH": "Обновить",
  "ANNOTATION_NAME": "Имя аннотации",
  "MATCH_CASE": "Спичечный коробок",
  "EXACT_PATH": "Точный путь",
  "MIN_SDK_VERSION": "Минимальная версия SDK",
  "PRINT_LINE_NUMBERS": "Печать номеров строк"
}

```

`src/main/resources/translations/serbian.json`:

```json
{
  "FILE": "Филе",
  "ADD": "Додати...",
  "NEW_WORKSPACE": "Нови радни простор",
  "RELOAD_RESOURCES": "Релоад Ресоурцес",
  "RUN": "Трцати",
  "OPEN": "Отвори...",
  "OPEN_UNSTYLED": "Отвори",
  "QUICK_OPEN": "Куицк Опен",
  "DELETE": "Избриши",
  "NEW": "Нова",
  "EXPAND": "Проширити",
  "COLLAPSE": "Колапс",
  "COMPILE": "Саставити",
  "SAVE_AS_RUNNABLE_JAR": "Сачувај као теглу за покретање...",
  "SAVE_AS_ZIP": "Сачувај као зип...",
  "SAVE_AS_DEX": "Сачувај као ДЕКС...",
  "SAVE_AS_APK": "Сачувај као АПК...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Декомпилирајте и сачувајте отворене класе",
  "DECOMPILE_SAVE_ALL_CLASSES": "Декомпилирајте и сачувајте све класе",
  "RECENT_FILES": "Недавне датотеке",
  "ABOUT": "О томе",
  "EXIT": "Изађи",

  "VIEW": "Поглед",
  "VISUAL_SETTINGS": "Визуелна подешавања",
  "PANE_1": "Окно 1",
  "PANE_2": "Окно 2",
  "PANE_3": "Окно 3",
  "NONE": "Ниједан",
  "EDITABLE": "Едитабле",

  "LANGUAGE": "Језик",
  "FONT_SIZE": "Величина фонта",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Прикажи датотеку у наслову картице",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Поједноставите назив у наслову картице",
  "SYNCHRONIZED_VIEWING": "Синхронизовано гледање",
  "SHOW_CLASS_METHODS": "Прикажи методе класе",

  "WINDOW_THEME": "Виндов Тхеме",
  "SYSTEM_THEME": "Системска тема",
  "DARK_THEME": "Мрачна тема",
  "LIGHT_THEME": "Лигхт Тхеме",
  "ONE_DARK_THEME": "Једна мрачна тема",
  "SOLARIZED_DARK_THEME": "Соларизована тамна тема",
  "SOLARIZED_LIGHT_THEME": "Соларизована светлосна тема",
  "HIGH_CONTRAST_DARK_THEME": "Тамна тема високог контраста",
  "HIGH_CONTRAST_LIGHT_THEME": "Светла тема високог контраста",
  "ONE_DARK": "Оне Дарк",
  "SOLARIZED_DARK": "Соларизед Дарк",
  "SOLARIZED_LIGHT": "Соларизед Лигхт",
  "HIGH_CONTRAST_DARK": "Висок контраст Тамно",
  "HIGH_CONTRAST_LIGHT": "Светло високог контраста",
  "TEXT_AREA_THEME": "Тема области текста",
  "DEFAULT_RECOMMENDED_LIGHT": "Подразумевано (препоручено светло)",
  "THEME_MATCH": "Подударање теме (препоручено)",
  "DARK": "Тамно (препоручено тамно)",
  "DARK_ALT": "Дарк-Алт",
  "DEFAULT_ALT": "Подразумевано-Алт",
  "ECLIPSE": "Ецлипсе",
  "INTELLIJ": "Интеллиј",
  "VISUAL_STUDIO": "Визуелни студио",
  "DRUID_DARK": "друид (мрачни)",
  "MONOKAI_DARK": "Монокаи (тамно)",

  "SETTINGS": "Подешавања",
  "COMPILE_ON_SAVE": "Цомпиле Он Саве",
  "COMPILE_ON_REFRESH": "Компајлирајте при освежавању",
  "REFRESH_ON_VIEW_CHANGE": "Освежи при промени погледа",
  "DECODE_APK_RESOURCES": "Декодирајте АПК ресурсе",
  "APK_CONVERSION": "АПК конверзија",
  "APK_CONVERSION_DECODING": "АПК конверзија/декодирање",
  "DEX_TO_JAR": "Дек2Јар",
  "ENJARIFY": "Ењарифи",
  "UPDATE_CHECK": "Ажурирање провера",
  "DELETE_UNKNOWN_LIBS": "Избришите стране/застареле библиотеке",
  "FORCE_PURE_ASCII_AS_TEXT": "Форце Пуре Асции као текст",
  "SET_PYTHON_27_EXECUTABLE": "Поставите извршну датотеку Питхон 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Поставите извршну датотеку Питхон 3.Кс",
  "SET_JRE_RT_LIBRARY": "Поставите ЈРЕ РТ библиотеку",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Поставите опционалну фасциклу библиотеке",
  "SET_JAVAC_EXECUTABLE": "Поставите Јавац извршну датотеку",

  "JAVA": "Јава",
  "PROCYON_SETTINGS": "Процион Сеттингс",
  "CFR_SETTINGS": "ЦФР подешавања",
  "FERNFLOWER_SETTINGS": "ФернФловер Сеттингс",
  "PROCYON": "Процион",
  "CFR": "ЦФР",
  "FERNFLOWER": "ФернФловер",
  "KRAKATAU": "Кракатау",
  "JDGUI": "ЈД-ГУИ",
  "JADX": "ЈАДКС",
  "SMALI": "Смали",
  "SMALI_DEX": "Смали/Дек",
  "HEXCODE": "Хекцоде",
  "BYTECODE": "Битецоде",
  "ASM_TEXTIFY": "АСМ Тектифи",

  "BYTECODE_DECOMPILER": "Битецоде Децомпилер",
  "DEBUG_HELPERS": "Дебуг Хелперс",
  "APPEND_BRACKETS_TO_LABEL": "Додај заграде на ознаку",

  "PLUGINS": "Плугинс",
  "OPEN_PLUGIN": "Отвори додатак...",
  "RECENT_PLUGINS": "Недавни додаци",
  "CODE_SEQUENCE_DIAGRAM": "Дијаграм секвенце кода",
  "MALICIOUS_CODE_SCANNER": "Скенер злонамерног кода",
  "SHOW_MAIN_METHODS": "Прикажи главне методе",
  "SHOW_ALL_STRINGS": "Прикажи све низове",
  "REPLACE_STRINGS": "Замените низове",
  "STACK_FRAMES_REMOVER": "Стацк Фрамес Ремовер",
  "ZKM_STRING_DECRYPTER": "ЗКМ стринг децриптер",
  "ALLATORI_STRING_DECRYPTER": "Аллатори стринг децриптер",
  "ZSTRINGARRAY_DECRYPTER": "ЗСтрингАрраи Децриптер",
  "VIEW_ANDROID_PERMISSIONS": "Погледајте дозволе за Андроид",
  "VIEW_MANIFEST": "Прикажи манифест",
  "CHANGE_CLASSFILE_VERSIONS": "Промените верзије ЦлассФиле-а",



  "PROCYON_DECOMPILER": "Процион Децомпилер",
  "CFR_DECOMPILER": "ЦФР Децомпилер",
  "FERNFLOWER_DECOMPILER": "ФернФловер Децомпилер",
  "JADX_DECOMPILER": "ЈАДКС Децомпилер",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Битецоде Дисассемблер",
  "DISASSEMBLER": "Дисассемблер",

  "ERROR": "Грешка",
  "NEW_JAVA_PLUGIN": "Нови Јава додатак",
  "NEW_JAVASCRIPT_PLUGIN": "Нови Јавасцрипт додатак",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Предложена поправка: Кликните на освежи класу, ако поново не успе, покушајте са другим декомпајлером.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Предложена исправка: Пробајте Виев>Пане>Кракатау>Битецоде и омогућите опцију за уређивање.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "УПОЗОРЕЊЕ: Тренутно није изабран ниједан декомпајлер. Пробајте Виев>Пане и изаберите декомпајлер.",
  "COMPILER_TIP": "Имајте на уму да већина декомпајлера не може да произведе класе које се могу компајлирати",
  "FIRST_OPEN_A_RESOURCE": "Прво отворите ресурс унутар БЦВ-а (класа, јар, зип или апк датотека)",
  "FIRST_OPEN_A_CLASS": "Прво отворите ресурс датотеке класе унутар БЦВ-а (јар, зип, апк, дек)",
  "FIRST_VIEW_A_CLASS": "Прво погледајте датотеку класе унутар картице.",
  "DRAG_CLASS_JAR": "Превуците класу/јар/зип/АПК/ДЕКС овде",

  "YES": "да",
  "NO": "Не",
  "ERROR2": "Грешка:",
  "PROCESS2": "Процес:",
  "EXIT_VALUE_IS": "Излазна вредност је:",
  "JAVA_COMPILE_FAILED": "Јава компајлирање није успело",
  "ERROR_COMPILING_CLASS": "Грешка при компајлирању класе",
  "COMPILER": "Имајте на уму да већина декомпајлера не може да произведе класе које се могу компајлирати",
  "SELECT_LIBRARY_FOLDER": "Изаберите фасциклу библиотеке",
  "SELECT_JAVA_RT": "Изаберите ЈРЕ РТ Јар",
  "SELECT_JAVA": "Изаберите Јава Екецутабле",
  "SELECT_JAVAC": "Изаберите Јавац Екецутабле",
  "SELECT_JAVA_TOOLS": "Изаберите Јава Тоолс Јар",
  "SELECT_PYTHON_2": "Изаберите Извршни Питхон 2.7",
  "SELECT_PYTHON_3": "Изаберите Извршни Питхон 3.к",
  "PYTHON_2_EXECUTABLE": "Питхон 2.7 (или ПиПи 2.7 за брзину) Извршни",
  "PYTHON_3_EXECUTABLE": "Питхон 3.к (или ПиПи 3.к за брзину) Извршни",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Морате да подесите своју извршну путању за Питхон 2.7 (или ПиПи 2.7 за брзину).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Морате да подесите своју извршну путању за Питхон 3.к (или ПиПи 3.к за брзину).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Морате да подесите своју ЈРЕ РТ библиотеку.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(Ц:\\Програм Филес\\Јава\\јре7\\либ\\рт.јар)",
  "JAVA_EXECUTABLE": "Јава извршни (унутар ЈРЕ Ц:/Програм Филес/Јава/ЈРЕ_кк/бин/јава.еке)",
  "JAVAC_EXECUTABLE": "Јавац извршни (захтева ЈДК Ц:/Програм Филес/Јава/ЈДК_кк/бин/јавац.еке)",
  "JAVA_TOOLS_JAR": "Јава Тоолс Јар (унутар ЈДК Ц:/Програм Филес/Јава/ЈДК_кк/либ/тоолс.јар)",
  "JAVA_RT_JAR": "Јава РТ Јар (унутар ЈРЕ Ц:/Програм Филес/Јава/ЈРЕ_кк/либ/рт.јар)",
  "OPTIONAL_LIBRARY_FOLDER": "Опциони фолдер библиотеке (компајлер и Кракатау)",

  "HIDE_BRIDGE_METHODS": "Сакриј методе премошћавања",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Сакриј синтетичке чланове класе",
  "DECOMPILE_INNER_CLASSES": "Декомпилирајте унутрашње класе",
  "COLLAPSE_14_CLASS_REFERENCES": "Скупи референце класа 1.4",
  "DECOMPILE_ASSERTIONS": "Декомпилирајте тврдње",
  "HIDE_EMPTY_SUPER_INVOCATION": "Сакриј празну супер инвокацију",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Сакриј празан подразумевани конструктор",
  "DECOMPILE_GENERIC_SIGNATURES": "Декомпилирајте генеричке потписе",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Претпоставимо да повратак не баца изузетке",
  "DECOMPILE_ENUMERATIONS": "Декомпилирајте набрајања",
  "REMOVE_GETCLASS_INVOCATION": "Уклоните позивање гетЦласс().",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Интерпретирајте инт 1 као логичку вредност труе",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Дозволи синтетички атрибут који није постављен",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Размотрите безимене типове као јава.ланг.Објецт",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Реконструишите имена променљивих из информација о отклањању грешака",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Уклоните празне опсеге изузетака",
  "DEINLINE_FINALLY_STRUCTURES": "Деинлине коначно структурира",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Дозволите само АСЦИИ знакове у низовима",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Преименујте двосмислене класе и елементе класе",

  "DECODE_ENUM_SWITCH": "Децоде Енум Свитцх",
  "SUGARENUMS": "СугарЕнумс",
  "DECODE_STRING_SWITCH": "Прекидач декодирања низа",
  "ARRAYITER": "Арраиитер",
  "COLLECTIONITER": "Цоллецтионитер",
  "INNER_CLASSES": "Унутрашње класе",
  "REMOVE_BOILER_PLATE": "Уклоните плочу котла",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Уклоните синтетику унутрашње класе",
  "DECODE_LAMBDAS": "Децоде Ламбдас",
  "LIFT__CONSTRUCTOR_INIT": "Лифт Цонструцтор Инит",
  "REMOVE_DEAD_METHODS": "Уклоните мртве методе",
  "REMOVE_BAD_GENERICS": "Уклоните лоше генеричке производе",
  "SUGAR_ASSERTS": "Сугар Ассертс",
  "SUGAR_BOXING": "Сугар Бокинг",
  "SHOW_VERSION": "Прикажи верзију",
  "DECODE_FINALLY": "Децоде Финалли",
  "TIDY_MONITORS": "Тиди Мониторс",
  "LENIENT": "Попустљив",
  "DUMP_CLASSPATH": "Думп Цласспатх",
  "COMMENTS": "Коментари",
  "FORCE_TOP_SORT": "Форце Топ Сорт",
  "FORCE_TOP_SORT_AGGRESS": "Форце Топ Сорт Аггресс",
  "FORCE_EXCEPTION_PRUNE": "Форце Екцептион Пруне",
  "STRING_BUFFER": "Стринг Буффер",
  "STRING_BUILDER": "Стринг Буилдер",
  "SILENT": "Тихо",
  "RECOVER": "Опоравити се",
  "OVERRIDE": "Прегазити",
  "SHOW_INFERRABLE": "Схов Инферрабле",
  "AEXAGG": "Аекагг",
  "FORCE_COND_PROPAGATE": "Форце Цонд Пропагате",
  "HIDE_UTF": "Сакриј УТФ",
  "HIDE_LONG_STRINGS": "Сакриј дуге жице",
  "COMMENT_MONITORS": "Цоммент Мониторс",
  "ALLOW_CORRECTING": "Дозволи исправљање",
  "LABELLED_BLOCKS": "Означени блокови",
  "J14CLASSOBJ": "Ј14ЦлассОБЈ",
  "HIDE_LANG_IMPORTS": "Сакриј увоз језика",
  "RECOVER_TYPE_CLASH": "Рецовер Типе Цласх",
  "RECOVER_TYPE__HINTS": "Рецовер Типе Хинтс",
  "FORCE_RETURNING_IFS": "Форце Ретурнинг ИФ",
  "FOR_LOOP_AGG_CAPTURE": "За Лооп АГГ Цаптуре",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Увек генерише променљиву изузетка за блокове хватања",
  "EXCLUDE_NESTED_TYPES": "Изузми угнежђене типове",
  "SHOW_DEBUG_LINE_NUMBERS": "Прикажи бројеве линија за отклањање грешака",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Укључите бројеве линија у бајткод",
  "INCLUDE_ERROR_DIAGNOSTICS": "Укључује дијагностику грешака",
  "SHOW_SYNTHETIC_MEMBERS": "Прикажи синтетичке чланове",
  "SIMPLIFY_MEMBER_REFERENCES": "Поједноставите референце чланова",
  "MERGE_VARIABLES": "Спајање променљивих",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Присилите експлицитне аргументе типа",
  "FORCE_EXPLICIT_IMPORTS": "Присилите експлицитни увоз",
  "FLATTEN_SWITCH_BLOCKS": "Изравнајте блокове прекидача",
  "RETAIN_POINTLESS_SWITCHES": "Задржите бесмислене прекидаче",
  "RETAIN_REDUNDANT_CASTS": "Задржи сувишне улоге",
  "UNICODE_OUTPUT_ENABLED": "Уницоде излаз је омогућен",


  "RELOAD_RESOURCES_TITLE": "{ПРОДУЦТ_НАМЕ} – Поново учитај ресурсе",
  "RELOAD_RESOURCES_CONFIRM": "Да ли сте сигурни да желите да поново учитате ресурсе?",
  "SELECT_FILE_TITLE": "Изаберите датотеку или фасциклу за отварање у {БЦВ}",
  "SELECT_FILE_DESCRIPTION": "АПК-ови, ДЕКС, Цласс Филес или Зип/Јар/Вар архиве",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Изаберите Екстерни додатак",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "БЦВ спољни додатак у јс, јава, питхон, руби или гроови",
  "FOREIGN_LIBRARY_WARNING": "УПОЗОРЕЊЕ: Када је ово искључено, застареле библиотеке НЕЋЕ бити уклоњене. {НЕВЛИНЕ} То је такође безбедносни проблем. {НЕВЛИНЕ} ИСКЉУЧИТЕ ЈЕ САМО АКО ЗНАТЕ ШТА РАДИТЕ.",
  "RESET_TITLE": "{ПРОДУЦТ_НАМЕ} – Ресетујте радни простор",
  "RESET_CONFIRM": "Да ли сте сигурни да желите да ресетујете радни простор? {НЕВЛИНЕ} Такође ће ресетовати навигатор датотека и претрагу.",
  "EXIT_TITLE": "{ПРОДУЦТ_НАМЕ} – Изађи",
  "EXIT_CONFIRM": "Јеси сигуран да желиш да изађеш?",
  "ABOUT_TITLE": "{ПРОДУЦТ_НАМЕ} - О - {ВЕБСИТЕ} | {ТБЦ}",
  "PLUGIN_CONSOLE_TITLE": "{ПРОДУЦТ_НАМЕ} – Конзола додатних компоненти",
  "CLOSE_ALL_BUT_THIS": "Затвори све осим овога",
  "CLOSE_TAB": "Затвори картицу",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Пошаљите овај дневник грешака на",
  "PLEASE_SEND_RESOURCES": "Ако поседујете одговарајућа законска права на релевантну датотеку класе/јар/апк, укључите и то.",
  "ONE_PLUGIN_AT_A_TIME": "Тренутно је у току још један додатак, сачекајте да се заврши.",
  "ILLEGAL_ACCESS_ERROR": "За ово користите Јава 15 или старију верзију.",


  "FILES": "Фајлови",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Брза претрага датотека (без екстензије датотеке)",
  "WORK_SPACE": "Радни простор",
  "EXACT": "Тачно",
  "SEARCH": "Претрага",
  "SEARCH_FROM": "Тражи од:",
  "SEARCH_STRING": "Стринг за претрагу:",
  "SEARCH_REGEX": "Претрага Регек:",
  "OWNER": "Власник:",
  "NAME": "име:",
  "DESC": "десц:",
  "SAVE": "Сачувати...",
  "SAVE_AS": "Сачувај као...",
  "RESULTS": "Резултати",
  "REFRESH": "Освјежи",
  "ANNOTATION_NAME": "Назив напомене",
  "MATCH_CASE": "Матцх Цасе",
  "EXACT_PATH": "Тачан пут",
  "MIN_SDK_VERSION": "Минимална верзија СДК-а",
  "PRINT_LINE_NUMBERS": "Штампајте бројеве редова"
}

```

`src/main/resources/translations/slovak.json`:

```json
{
  "FILE": "Súbor",
  "ADD": "Pridať...",
  "NEW_WORKSPACE": "Nový pracovný priestor",
  "RELOAD_RESOURCES": "Znovunačítanie zdrojov",
  "RUN": "Spustiť",
  "OPEN": "Otvorené...",
  "OPEN_UNSTYLED": "Otvorte stránku",
  "QUICK_OPEN": "Rýchle otvorenie",
  "DELETE": "Odstrániť",
  "NEW": "Nový",
  "EXPAND": "Rozšíriť",
  "COLLAPSE": "Zrútenie",
  "COMPILE": "Zostaviť",
  "SAVE_AS_RUNNABLE_JAR": "Uložiť ako spustiteľnú nádobu...",
  "SAVE_AS_ZIP": "Uložiť ako Zip...",
  "SAVE_AS_DEX": "Uložiť ako DEX...",
  "SAVE_AS_APK": "Uložiť ako APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompilácia a uloženie otvorených tried",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompilácia a uloženie všetkých tried",
  "RECENT_FILES": "Nedávne súbory",
  "ABOUT": "O stránke",
  "EXIT": "Exit",

  "VIEW": "Zobraziť",
  "VISUAL_SETTINGS": "Vizuálne nastavenia",
  "PANE_1": "Panel 1",
  "PANE_2": "Panel 2",
  "PANE_3": "Panel 3",
  "NONE": "Žiadne",
  "EDITABLE": "Upraviteľné",

  "LANGUAGE": "Jazyk",
  "FONT_SIZE": "Veľkosť písma",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Zobraziť súbor v názve karty",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Zjednodušenie názvu v názve karty",
  "SYNCHRONIZED_VIEWING": "Synchronizované zobrazenie",
  "SHOW_CLASS_METHODS": "Zobraziť metódy triedy",

  "WINDOW_THEME": "Téma okna",
  "SYSTEM_THEME": "Systémová téma",
  "DARK_THEME": "Tmavá téma",
  "LIGHT_THEME": "Téma svetla",
  "ONE_DARK_THEME": "Jedna tmavá téma",
  "SOLARIZED_DARK_THEME": "Tmavá téma Solarized",
  "SOLARIZED_LIGHT_THEME": "Téma solárneho svetla",
  "HIGH_CONTRAST_DARK_THEME": "Tmavá téma s vysokým kontrastom",
  "HIGH_CONTRAST_LIGHT_THEME": "Svetlá téma s vysokým kontrastom",
  "ONE_DARK": "Jedna tma",
  "SOLARIZED_DARK": "Solarizovaná tma",
  "SOLARIZED_LIGHT": "Solárne svetlo",
  "HIGH_CONTRAST_DARK": "Vysoký kontrast Dark",
  "HIGH_CONTRAST_LIGHT": "Vysokokontrastné svetlo",
  "TEXT_AREA_THEME": "Téma textovej oblasti",
  "DEFAULT_RECOMMENDED_LIGHT": "Predvolené nastavenie (odporúčané svetlo)",
  "THEME_MATCH": "Téma zápasu (odporúčané)",
  "DARK": "Tmavá (odporúčaná tmavá)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Zatmenie",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (Temný)",
  "MONOKAI_DARK": "Monokai (Dark)",

  "SETTINGS": "Nastavenia",
  "COMPILE_ON_SAVE": "Kompilácia pri ukladaní",
  "COMPILE_ON_REFRESH": "Kompilácia pri obnovení",
  "REFRESH_ON_VIEW_CHANGE": "Obnovenie pri zmene zobrazenia",
  "DECODE_APK_RESOURCES": "Dekódovať APK zdroje",
  "APK_CONVERSION": "Konverzia APK",
  "APK_CONVERSION_DECODING": "Konverzia APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Kontrola aktualizácie",
  "DELETE_UNKNOWN_LIBS": "Vymazať zahraničné",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii ako text",
  "SET_PYTHON_27_EXECUTABLE": "Nastavenie spustiteľného programu Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Nastavenie spustiteľného programu Python 3.X",
  "SET_JRE_RT_LIBRARY": "Nastavenie knižnice JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Nastavenie voliteľného priečinka knižnice",
  "SET_JAVAC_EXECUTABLE": "Nastaviť spustiteľný súbor Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Nastavenia Procyonu",
  "CFR_SETTINGS": "Nastavenia CFR",
  "FERNFLOWER_SETTINGS": "Nastavenia FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Šesťmiestny kód",
  "BYTECODE": "Bytový kód",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Dekompilátor bytového kódu",
  "DEBUG_HELPERS": "Pomocníci ladenia",
  "APPEND_BRACKETS_TO_LABEL": "Pripojenie zátvoriek k štítku",

  "PLUGINS": "Pluginy",
  "OPEN_PLUGIN": "Otvoriť zásuvný modul...",
  "RECENT_PLUGINS": "Nedávne zásuvné moduly",
  "CODE_SEQUENCE_DIAGRAM": "Schéma postupnosti kódu",
  "MALICIOUS_CODE_SCANNER": "Skener škodlivého kódu",
  "SHOW_MAIN_METHODS": "Zobraziť hlavné metódy",
  "SHOW_ALL_STRINGS": "Zobraziť všetky reťazce",
  "REPLACE_STRINGS": "Nahradiť reťazce",
  "STACK_FRAMES_REMOVER": "Odstránenie stohových rámov",
  "ZKM_STRING_DECRYPTER": "Dešifrovač reťazcov ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Zobrazenie oprávnení systému Android",
  "VIEW_MANIFEST": "Zobraziť manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Zmena verzií súborov triedy",



  "PROCYON_DECOMPILER": "Dekompilátor Procyon",
  "CFR_DECOMPILER": "Dekompilátor CFR",
  "FERNFLOWER_DECOMPILER": "Dekompilátor FernFlower",
  "JADX_DECOMPILER": "Dekompilátor JADX",
  "JD_DECOMPILER": "Dekompilátor JD-GUI",
  "BYTECODE_DISASSEMBLER": "Disassembler bytového kódu",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Chyba",
  "NEW_JAVA_PLUGIN": "Nový zásuvný modul Java",
  "NEW_JAVASCRIPT_PLUGIN": "Nový zásuvný modul Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Navrhovaná oprava: Ak sa to opäť nepodarí, skúste iný dekompilátor.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Navrhovaná oprava: Skúste View>Pane>Krakatau>Bytecode a zapnite Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "VAROVANIE: V súčasnosti nie je vybraný žiadny dekompilátor. Skúste View>Pane a vyberte dekompilátor.",
  "COMPILER_TIP": "Majte na pamäti, že väčšina dekompilátorov nedokáže vytvoriť kompilovateľné triedy",
  "FIRST_OPEN_A_RESOURCE": "Najprv otvorte zdroj v BCV (trieda, jar, zip alebo apk súbor)",
  "FIRST_OPEN_A_CLASS": "Najprv otvorte zdroj súboru triedy v BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Najprv zobrazte súbor triedy v karte.",
  "DRAG_CLASS_JAR": "Trieda Drag",

  "YES": "Áno",
  "NO": "Nie",
  "ERROR2": "Chyba:",
  "PROCESS2": "Proces:",
  "EXIT_VALUE_IS": "Exit Value je:",
  "JAVA_COMPILE_FAILED": "Kompilácia jazyka Java zlyhala",
  "ERROR_COMPILING_CLASS": "Chyba pri kompilácii triedy",
  "COMPILER": "Majte na pamäti, že väčšina dekompilátorov nedokáže vytvoriť kompilovateľné triedy",
  "SELECT_LIBRARY_FOLDER": "Vyberte priečinok knižnice",
  "SELECT_JAVA_RT": "Vyberte JRE RT Jar",
  "SELECT_JAVA": "Vyberte spustiteľný súbor Java",
  "SELECT_JAVAC": "Vyberte spustiteľný súbor Javac",
  "SELECT_JAVA_TOOLS": "Vyberte položku Nástroje Java Jar",
  "SELECT_PYTHON_2": "Vyberte spustiteľný súbor Python 2.7",
  "SELECT_PYTHON_3": "Vyberte spustiteľný súbor Python 3.x",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (alebo PyPy 2.7 pre rýchlosť)",
  "PYTHON_3_EXECUTABLE": "Python 3.x (alebo PyPy 3.x pre rýchlosť)",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Musíte nastaviť cestu k spustiteľnému programu Python 2.7 (alebo PyPy 2.7 pre rýchlosť).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Musíte nastaviť cestu k spustiteľnému programu Python 3.x (alebo PyPy 3.x pre rýchlosť).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Musíte nastaviť knižnicu JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Spustiteľný súbor Java (vnútri JRE C:",
  "JAVAC_EXECUTABLE": "Spustiteľný súbor Javac (vyžaduje JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (vnútri JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (vnútri JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Voliteľný priečinok knižnice (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Skryť metódy premostenia",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Skryť syntetické členy triedy",
  "DECOMPILE_INNER_CLASSES": "Dekompilácia vnútorných tried",
  "COLLAPSE_14_CLASS_REFERENCES": "Zrútenie odkazov na triedy 1.4",
  "DECOMPILE_ASSERTIONS": "Dekompilácia tvrdení",
  "HIDE_EMPTY_SUPER_INVOCATION": "Skryť prázdne vyvolanie super",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Skryť prázdny predvolený konštruktor",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompilácia generických podpisov",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Predpokladajme, že návrat nebude hádzať výnimky",
  "DECOMPILE_ENUMERATIONS": "Dekompilácia enumerácií",
  "REMOVE_GETCLASS_INVOCATION": "Odstránenie volania funkcie getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretovať int 1 ako boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Umožniť nenastavenie syntetického atribútu",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Považujte bezmenné typy za java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonštrukcia názvov premenných z informácií o ladení",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Odstránenie prázdnych rozsahov výnimiek",
  "DEINLINE_FINALLY_STRUCTURES": "Odstránenie konečne štruktúr",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Povolenie iba znakov ASCII v reťazcoch",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Premenovanie nejednoznačných tried a prvkov tried",

  "DECODE_ENUM_SWITCH": "Prepínač dekódovania enum",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dekódovanie reťazca Prepínač",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Vnútorné triedy",
  "REMOVE_BOILER_PLATE": "Odstránenie kotlovej dosky",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Odstránenie syntetiky vnútornej triedy",
  "DECODE_LAMBDAS": "Dekódovanie lambd",
  "LIFT__CONSTRUCTOR_INIT": "Konštruktor výťahu Init",
  "REMOVE_DEAD_METHODS": "Odstránenie mŕtvych metód",
  "REMOVE_BAD_GENERICS": "Odstránenie zlých generík",
  "SUGAR_ASSERTS": "Cukor tvrdí",
  "SUGAR_BOXING": "Cukrový box",
  "SHOW_VERSION": "Zobraziť verziu",
  "DECODE_FINALLY": "Konečne dekódovať",
  "TIDY_MONITORS": "Poriadne monitory",
  "LENIENT": "Zhovievavosť",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Komentáre",
  "FORCE_TOP_SORT": "Vynútiť najvyššie triedenie",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Vynútenie výnimky Prune",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Tichý",
  "RECOVER": "Obnovenie",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Zobraziť Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Skryť UTF",
  "HIDE_LONG_STRINGS": "Skrývanie dlhých reťazcov",
  "COMMENT_MONITORS": "Monitory komentárov",
  "ALLOW_CORRECTING": "Povoliť opravu",
  "LABELLED_BLOCKS": "Označené bloky",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Skryť Lang Dovoz",
  "RECOVER_TYPE_CLASH": "Obnovenie typu Clash",
  "RECOVER_TYPE__HINTS": "Tipy na obnovenie typu",
  "FORCE_RETURNING_IFS": "Force Returning IFs",
  "FOR_LOOP_AGG_CAPTURE": "Pre slučku AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Vždy generovať premennú výnimky pre bloky Catch",
  "EXCLUDE_NESTED_TYPES": "Vylúčenie vnorených typov",
  "SHOW_DEBUG_LINE_NUMBERS": "Zobraziť čísla ladiacich riadkov",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Zahrnutie čísel riadkov do bajtkódu",
  "INCLUDE_ERROR_DIAGNOSTICS": "Zahrnúť diagnostiku chýb",
  "SHOW_SYNTHETIC_MEMBERS": "Zobrazenie syntetických členov",
  "SIMPLIFY_MEMBER_REFERENCES": "Zjednodušenie odkazov na členov",
  "MERGE_VARIABLES": "Zlúčenie premenných",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Vynútenie explicitných typových argumentov",
  "FORCE_EXPLICIT_IMPORTS": "Vynútiť explicitný dovoz",
  "FLATTEN_SWITCH_BLOCKS": "Sploštenie spínacích blokov",
  "RETAIN_POINTLESS_SWITCHES": "Zachovanie bezpredmetných prepínačov",
  "RETAIN_REDUNDANT_CASTS": "Zachovanie nadbytočných obsadení",
  "UNICODE_OUTPUT_ENABLED": "Povolený výstup Unicode",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Načítať zdroje",
  "RELOAD_RESOURCES_CONFIRM": "Ste si istí, že chcete znovu načítať zdroje?",
  "SELECT_FILE_TITLE": "Vyberte súbor alebo priečinok, ktorý chcete otvoriť v {BCV}",
  "SELECT_FILE_DESCRIPTION": "Súbory APK, DEX, Class Files alebo Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Vyberte externý zásuvný modul",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Externý plugin BCV v js, jave, pythone, ruby alebo groovy",
  "FOREIGN_LIBRARY_WARNING": "UPOZORNENIE: Ak je táto funkcia vypnutá, zastarané knižnice sa neodstránia.\n\rJe to aj bezpečnostný problém.\n\rVYPNITE JU LEN VTEDY, AK VIETE, ČO ROBÍTE.",
  "RESET_TITLE": "{PRODUCT_NAME} - Obnoviť pracovný priestor",
  "RESET_CONFIRM": "Ste si istí, že chcete obnoviť pracovný priestor?\n\rResetuje sa aj navigátor súborov a vyhľadávanie.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Ste si istí, že chcete odísť?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Informácie - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Konzola zásuvného modulu",
  "CLOSE_ALL_BUT_THIS": "Zatvoriť všetko okrem tohto",
  "CLOSE_TAB": "Zatvoriť kartu",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Prosím, pošlite tento protokol o chybe na adresu",
  "PLEASE_SEND_RESOURCES": "Ak máte príslušné zákonné práva na príslušnú triedu",
  "ONE_PLUGIN_AT_A_TIME": "V súčasnosti je spustený iný doplnok, počkajte, kým sa dokončí.",
  "ILLEGAL_ACCESS_ERROR": "Na tento účel použite Javu 15 alebo staršiu.",


  "FILES": "Súbory",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Rýchle vyhľadávanie súborov (bez prípon)",
  "WORK_SPACE": "Pracovný priestor",
  "EXACT": "Presne",
  "SEARCH": "Vyhľadávanie",
  "SEARCH_FROM": "Vyhľadávanie od:",
  "SEARCH_STRING": "Vyhľadávací reťazec:",
  "SEARCH_REGEX": "Vyhľadávací regex:",
  "OWNER": "Majiteľ:",
  "NAME": "Názov:",
  "DESC": "Popis:",
  "SAVE": "Uložiť...",
  "SAVE_AS": "Uložiť ako...",
  "RESULTS": "Výsledky",
  "REFRESH": "Obnoviť",
  "ANNOTATION_NAME": "Názov anotácie",
  "MATCH_CASE": "Prípad zápasu",
  "EXACT_PATH": "Presná cesta",
  "MIN_SDK_VERSION": "Minimálna verzia SDK",
  "PRINT_LINE_NUMBERS": "Tlač čísiel riadkov"
}

```

`src/main/resources/translations/slovenian.json`:

```json
{
  "FILE": "Datoteka",
  "ADD": "Dodajte...",
  "NEW_WORKSPACE": "Nov delovni prostor",
  "RELOAD_RESOURCES": "Ponovno polnjenje virov",
  "RUN": "Spustite",
  "OPEN": "Odprto...",
  "OPEN_UNSTYLED": "Odpri",
  "QUICK_OPEN": "Hitro odprtje",
  "DELETE": "Izbriši",
  "NEW": "Novo",
  "EXPAND": "Razširite",
  "COLLAPSE": "Zbijanje",
  "COMPILE": "Sestavljanje",
  "SAVE_AS_RUNNABLE_JAR": "Shrani kot izvedljiv kozarec...",
  "SAVE_AS_ZIP": "Shrani kot Zip...",
  "SAVE_AS_DEX": "Shrani kot DEX...",
  "SAVE_AS_APK": "Shrani kot APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompiliranje in shranjevanje odprtih razredov",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompiliranje in shranjevanje vseh razredov",
  "RECENT_FILES": "Nedavne datoteke",
  "ABOUT": "O",
  "EXIT": "Izhod",

  "VIEW": "Oglejte si",
  "VISUAL_SETTINGS": "Vizualne nastavitve",
  "PANE_1": "Podokno 1",
  "PANE_2": "Podokno 2",
  "PANE_3": "Podokno 3",
  "NONE": "Ni",
  "EDITABLE": "Urejanje",

  "LANGUAGE": "Jezik",
  "FONT_SIZE": "Velikost pisave",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Prikaži datoteko v naslovu zavihka",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Poenostavitev imena v naslovu zavihka",
  "SYNCHRONIZED_VIEWING": "Sinhronizirano gledanje",
  "SHOW_CLASS_METHODS": "Prikaži metode razreda",

  "WINDOW_THEME": "Tema okna",
  "SYSTEM_THEME": "Tema sistema",
  "DARK_THEME": "Temna tema",
  "LIGHT_THEME": "Tema svetlobe",
  "ONE_DARK_THEME": "Ena temna tema",
  "SOLARIZED_DARK_THEME": "Solarizirana temna tema",
  "SOLARIZED_LIGHT_THEME": "Solarizirana svetlobna tema",
  "HIGH_CONTRAST_DARK_THEME": "Temna tema z visokim kontrastom",
  "HIGH_CONTRAST_LIGHT_THEME": "Svetlobna tema z visokim kontrastom",
  "ONE_DARK": "Ena temna",
  "SOLARIZED_DARK": "Solarizirano temno",
  "SOLARIZED_LIGHT": "Solarizirana svetloba",
  "HIGH_CONTRAST_DARK": "Visoko kontrastno temno",
  "HIGH_CONTRAST_LIGHT": "Visoko kontrastna svetloba",
  "TEXT_AREA_THEME": "Tema območja besedila",
  "DEFAULT_RECOMMENDED_LIGHT": "Privzeto (priporočena svetloba)",
  "THEME_MATCH": "Tematska tekma (priporočeno)",
  "DARK": "Temno (priporočeno temno)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (temni)",
  "MONOKAI_DARK": "Monokai (temno)",

  "SETTINGS": "Nastavitve",
  "COMPILE_ON_SAVE": "Kompiliranje ob shranjevanju",
  "COMPILE_ON_REFRESH": "Sestavljanje ob osvežitvi",
  "REFRESH_ON_VIEW_CHANGE": "Osvežitev ob spremembi pogleda",
  "DECODE_APK_RESOURCES": "Dekodirati APK viri",
  "APK_CONVERSION": "Pretvorba APK",
  "APK_CONVERSION_DECODING": "Pretvorba APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Preverjanje posodobitve",
  "DELETE_UNKNOWN_LIBS": "Izbriši tuje",
  "FORCE_PURE_ASCII_AS_TEXT": "Sila Čista Ascii kot besedilo",
  "SET_PYTHON_27_EXECUTABLE": "Nastavitev izvajalnega programa Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Nastavitev izvajalnega programa Python 3.X",
  "SET_JRE_RT_LIBRARY": "Nastavitev knjižnice JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Nastavitev izbirne mape knjižnice",
  "SET_JAVAC_EXECUTABLE": "Nastavitev izvedljivega programa Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Nastavitve Procyona",
  "CFR_SETTINGS": "Nastavitve CFR",
  "FERNFLOWER_SETTINGS": "Nastavitve FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Šestmestna koda",
  "BYTECODE": "Bajtokoda",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Dekompiliator bajtkode",
  "DEBUG_HELPERS": "Pomočniki za odpravljanje napak",
  "APPEND_BRACKETS_TO_LABEL": "Dodajanje oklepajev k oznaki",

  "PLUGINS": "Vtičniki",
  "OPEN_PLUGIN": "Odprite vtičnik...",
  "RECENT_PLUGINS": "Nedavni vtičniki",
  "CODE_SEQUENCE_DIAGRAM": "Diagram zaporedja kod",
  "MALICIOUS_CODE_SCANNER": "Skener zlonamerne kode",
  "SHOW_MAIN_METHODS": "Prikaži glavne metode",
  "SHOW_ALL_STRINGS": "Prikaži vse strune",
  "REPLACE_STRINGS": "Nadomeščanje nizov",
  "STACK_FRAMES_REMOVER": "Odstranjevalec okvirjev kupa",
  "ZKM_STRING_DECRYPTER": "Dešifrirnik nizov ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Ogled pooblastil za operacijski sistem Android",
  "VIEW_MANIFEST": "Oglejte si manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Spreminjanje različic datotek ClassFile",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Razčlenjevalnik bajtkode",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Napaka",
  "NEW_JAVA_PLUGIN": "Novi vtičnik Java",
  "NEW_JAVASCRIPT_PLUGIN": "Nov vtičnik Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Predlagani popravek: Če ponovno ne uspe, poskusite z drugim razgrajevalnikom.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Predlagani popravek: Poskusite View>Pane>Krakatau>Bytecode in omogočite Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "OPOZORILO: Trenutno ni izbran noben dekompilator. Poskusite View>Pane in izberite dekompilator.",
  "COMPILER_TIP": "Upoštevajte, da večina dekompilatorjev ne more ustvariti sestavljivih razredov.",
  "FIRST_OPEN_A_RESOURCE": "Najprej odprite vir znotraj BCV (razred, jar, zip ali apk datoteko).",
  "FIRST_OPEN_A_CLASS": "Najprej odprite vir razredne datoteke znotraj BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Najprej si oglejte datoteko razreda v zavihku.",
  "DRAG_CLASS_JAR": "Razred vlečenja",

  "YES": "Da",
  "NO": "Ne",
  "ERROR2": "Napaka:",
  "PROCESS2": "Postopek:",
  "EXIT_VALUE_IS": "Vrednost izhoda je:",
  "JAVA_COMPILE_FAILED": "Java Compile ni uspel",
  "ERROR_COMPILING_CLASS": "Napaka pri sestavljanju razreda",
  "COMPILER": "Upoštevajte, da večina dekompilatorjev ne more ustvariti sestavljivih razredov.",
  "SELECT_LIBRARY_FOLDER": "Izberite mapo knjižnice",
  "SELECT_JAVA_RT": "Izberite JRE RT Jar",
  "SELECT_JAVA": "Izberite Izvedljivi program Java",
  "SELECT_JAVAC": "Izberite Izvršilni program Javac",
  "SELECT_JAVA_TOOLS": "Izberite Java Tools Jar",
  "SELECT_PYTHON_2": "Izberite program Python 2.7 Executable",
  "SELECT_PYTHON_3": "Izberite program Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (ali PyPy 2.7 za hitrost) Izvedljivo",
  "PYTHON_3_EXECUTABLE": "Python 3.x (ali PyPy 3.x za hitrost) Izvedljivo",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Nastaviti morate pot do izvajalnega programa Python 2.7 (ali PyPy 2.7 za hitrost).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Nastaviti morate pot do izvajalnega programa Python 3.x (ali PyPy 3.x za hitrost).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Nastaviti morate knjižnico JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Programske datoteke\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Izvedljivi program Java (znotraj JRE C:",
  "JAVAC_EXECUTABLE": "Izvedljiv program Javac (zahteva JDK C:",
  "JAVA_TOOLS_JAR": "Orodja Java Jar (znotraj JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (znotraj JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Izbirna mapa knjižnice (Compiler in Krakatau)",

  "HIDE_BRIDGE_METHODS": "Skrijte metode mostu",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Skrijte sintetične člane razreda",
  "DECOMPILE_INNER_CLASSES": "Dekompiliranje notranjih razredov",
  "COLLAPSE_14_CLASS_REFERENCES": "Zbijanje 1.4 reference razredov",
  "DECOMPILE_ASSERTIONS": "Dekompiliranje trditev",
  "HIDE_EMPTY_SUPER_INVOCATION": "Skrijte prazen poziv super",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Skrijte prazen privzeti konstruktor",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompiliranje generičnih podpisov",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Predpostavimo, da vrnitev ne vrže izjeme",
  "DECOMPILE_ENUMERATIONS": "Dekompiliranje naštevanj",
  "REMOVE_GETCLASS_INVOCATION": "Odstranitev klica getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretacija int 1 kot boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Dovolite, da ne nastavite sintetičnega atributa",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Brezimne tipe obravnavajte kot java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonstrukcija imen spremenljivk iz informacij o odpravljanju napak",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Odstranjevanje praznih območij izjem",
  "DEINLINE_FINALLY_STRUCTURES": "Končno odstranjevanje struktur",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "V nizih dovolite samo znake ASCII",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Preimenovanje dvoumnih razredov in elementov razredov",

  "DECODE_ENUM_SWITCH": "Stikalo za dekodiranje enumov",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Stikalo za dekodiranje nizov",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Zbirka",
  "INNER_CLASSES": "Notranji razredi",
  "REMOVE_BOILER_PLATE": "Odstranite ploščo kotla",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Odstranitev sintetike notranjega razreda",
  "DECODE_LAMBDAS": "Dekodiranje lambd",
  "LIFT__CONSTRUCTOR_INIT": "Konstruktor Lift Init",
  "REMOVE_DEAD_METHODS": "Odstranjevanje mrtvih metod",
  "REMOVE_BAD_GENERICS": "Odstranjevanje slabih generičnih imen",
  "SUGAR_ASSERTS": "Sladkor trdi",
  "SUGAR_BOXING": "Sladkorni boks",
  "SHOW_VERSION": "Prikaži različico",
  "DECODE_FINALLY": "Končno dekodiranje",
  "TIDY_MONITORS": "Urejeni monitorji",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Komentarji",
  "FORCE_TOP_SORT": "Siljenje zgornje razvrstitve",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Izkoristek izvzetja za sadeže",
  "STRING_BUFFER": "Vrstični medpomnilnik",
  "STRING_BUILDER": "Graditelj nizov",
  "SILENT": "Tihi",
  "RECOVER": "Obnovitev",
  "OVERRIDE": "Prevlada",
  "SHOW_INFERRABLE": "Prikaži nesprejemljivo",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Sila Cond Propagate",
  "HIDE_UTF": "Skrij UTF",
  "HIDE_LONG_STRINGS": "Skrijte dolge strune",
  "COMMENT_MONITORS": "Spremljevalci komentarjev",
  "ALLOW_CORRECTING": "Omogoči popravljanje",
  "LABELLED_BLOCKS": "Označeni bloki",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Skrij Lang Uvoz",
  "RECOVER_TYPE_CLASH": "Obnovitev spopada tipov",
  "RECOVER_TYPE__HINTS": "Namigi za obnovitev tipa",
  "FORCE_RETURNING_IFS": "Sila, ki vrača IF-je",
  "FOR_LOOP_AGG_CAPTURE": "Za zanko AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Vedno ustvarite spremenljivko za izjemo za bloke Catch",
  "EXCLUDE_NESTED_TYPES": "Izključitev vgnezdenih tipov",
  "SHOW_DEBUG_LINE_NUMBERS": "Prikaži številke vrstic za odpravljanje napak",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Vključevanje številk vrstic v bitno kodo",
  "INCLUDE_ERROR_DIAGNOSTICS": "Vključite diagnostiko napak",
  "SHOW_SYNTHETIC_MEMBERS": "Prikaži sintetične člane",
  "SIMPLIFY_MEMBER_REFERENCES": "Poenostavitev referenc članov",
  "MERGE_VARIABLES": "Združitev spremenljivk",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Prisilite eksplicitne argumente tipa",
  "FORCE_EXPLICIT_IMPORTS": "Prisilite eksplicitni uvoz",
  "FLATTEN_SWITCH_BLOCKS": "Sploščenje stikalnih blokov",
  "RETAIN_POINTLESS_SWITCHES": "Ohranjanje nepotrebnih stikal",
  "RETAIN_REDUNDANT_CASTS": "Ohranjanje odvečnih zasedb",
  "UNICODE_OUTPUT_ENABLED": "Omogočen izhod Unicode",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Ponovno naložite vire",
  "RELOAD_RESOURCES_CONFIRM": "Ali ste prepričani, da želite ponovno naložiti vire?",
  "SELECT_FILE_TITLE": "Izberite datoteko ali mapo, ki jo želite odpreti v {BCV}",
  "SELECT_FILE_DESCRIPTION": "Datoteke APK, DEX, datoteke razredov ali ZIP",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Izberite Zunanji vtičnik",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Zunanji vtičnik BCV v jeziku js, java, python, ruby ali groovy",
  "FOREIGN_LIBRARY_WARNING": "OPOZORILO: Če je ta možnost izklopljena, zastarele knjižnice NE bodo odstranjene.\n\rTo je tudi varnostno vprašanje.\n\rIZKLOPITE GA LE, ČE VESTE, KAJ POČNETE.",
  "RESET_TITLE": "{PRODUCT_NAME} - Ponastavitev delovnega prostora",
  "RESET_CONFIRM": "Ste prepričani, da želite ponastaviti delovni prostor?\n\rPonastavil se bo tudi navigator za datoteke in iskanje.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Izhod",
  "EXIT_CONFIRM": "Ste prepričani, da želite izstopiti?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Vizitka - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Konzorcij vtičnikov",
  "CLOSE_ALL_BUT_THIS": "Zapri vse razen tega",
  "CLOSE_TAB": "Zapri zavihek",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Ta dnevnik napak pošljite na naslov",
  "PLEASE_SEND_RESOURCES": "Če imate ustrezne zakonske pravice do zadevnega razreda.",
  "ONE_PLUGIN_AT_A_TIME": "Trenutno se izvaja drug vtičnik, zato počakajte, da se zaključi.",
  "ILLEGAL_ACCESS_ERROR": "Pri tem uporabljajte program Java 15 ali starejši.",


  "FILES": "Datoteke",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Hitro iskanje datotek (brez končnice)",
  "WORK_SPACE": "Delovni prostor",
  "EXACT": "Natančno",
  "SEARCH": "Iskanje",
  "SEARCH_FROM": "Iskanje od:",
  "SEARCH_STRING": "Iskalni niz:",
  "SEARCH_REGEX": "Iskanje Regex:",
  "OWNER": "Lastnik:",
  "NAME": "Ime in priimek:",
  "DESC": "Opis:",
  "SAVE": "Shrani...",
  "SAVE_AS": "Shrani kot...",
  "RESULTS": "Rezultati",
  "REFRESH": "Osvežitev",
  "ANNOTATION_NAME": "Ime anotacije",
  "MATCH_CASE": "Primer tekme",
  "EXACT_PATH": "Natančna pot",
  "MIN_SDK_VERSION": "Najmanjša različica SDK",
  "PRINT_LINE_NUMBERS": "Tiskanje številk vrstic"
}

```

`src/main/resources/translations/spanish.json`:

```json
{
  "FILE": "Archivo",
  "ADD": "Añadir...",
  "NEW_WORKSPACE": "Nuevo espacio de trabajo",
  "RELOAD_RESOURCES": "Recarga de recursos",
  "RUN": "Ejecutar",
  "OPEN": "Abrir...",
  "OPEN_UNSTYLED": "Abrir",
  "QUICK_OPEN": "Apertura rápida",
  "DELETE": "Borrar",
  "NEW": "Nuevo",
  "EXPAND": "Ampliar",
  "COLLAPSE": "Colapso",
  "COMPILE": "Compilar",
  "SAVE_AS_RUNNABLE_JAR": "Guardar como jarra ejecutable...",
  "SAVE_AS_ZIP": "Guardar como zip...",
  "SAVE_AS_DEX": "Guardar como DEX...",
  "SAVE_AS_APK": "Guardar como APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Descompilar y guardar las clases abiertas",
  "DECOMPILE_SAVE_ALL_CLASSES": "Descompilar y guardar todas las clases",
  "RECENT_FILES": "Archivos recientes",
  "ABOUT": "Acerca de",
  "EXIT": "Salir",

  "VIEW": "Ver",
  "VISUAL_SETTINGS": "Ajustes visuales",
  "PANE_1": "Panel 1",
  "PANE_2": "Panel 2",
  "PANE_3": "Panel 3",
  "NONE": "Ninguno",
  "EDITABLE": "Editable",

  "LANGUAGE": "Idioma",
  "FONT_SIZE": "Tamaño de la fuente",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Mostrar archivo en el título de la pestaña",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Simplificar el nombre en el título de la pestaña",
  "SYNCHRONIZED_VIEWING": "Visualización sincronizada",
  "SHOW_CLASS_METHODS": "Mostrar métodos de clase",

  "WINDOW_THEME": "Tema de la ventana",
  "SYSTEM_THEME": "Tema del sistema",
  "DARK_THEME": "Tema oscuro",
  "LIGHT_THEME": "Tema de la luz",
  "ONE_DARK_THEME": "Un tema oscuro",
  "SOLARIZED_DARK_THEME": "Tema oscuro solarizado",
  "SOLARIZED_LIGHT_THEME": "Tema de la luz solarizada",
  "HIGH_CONTRAST_DARK_THEME": "Tema oscuro de alto contraste",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema luminoso de alto contraste",
  "ONE_DARK": "Una oscuridad",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Luz solarizada",
  "HIGH_CONTRAST_DARK": "Alto Contraste Oscuro",
  "HIGH_CONTRAST_LIGHT": "Luz de alto contraste",
  "TEXT_AREA_THEME": "Tema del área de texto",
  "DEFAULT_RECOMMENDED_LIGHT": "Por defecto (luz recomendada)",
  "THEME_MATCH": "Partido temático (recomendado)",
  "DARK": "Oscuro (Oscuro recomendado)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Default-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Estudio visual",
  "DRUID_DARK": "Druida (Oscuro)",
  "MONOKAI_DARK": "Monokai (oscuro)",

  "SETTINGS": "Ajustes",
  "COMPILE_ON_SAVE": "Compilar al guardar",
  "COMPILE_ON_REFRESH": "Compilar al actualizar",
  "REFRESH_ON_VIEW_CHANGE": "Actualizar al cambiar de vista",
  "DECODE_APK_RESOURCES": "Descodificación de recursos APK",
  "APK_CONVERSION": "Conversión APK",
  "APK_CONVERSION_DECODING": "Conversión APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjaretar",
  "UPDATE_CHECK": "Comprobación de actualización",
  "DELETE_UNKNOWN_LIBS": "Borrar el extranjero",
  "FORCE_PURE_ASCII_AS_TEXT": "Forzar Ascii Puro Como Texto",
  "SET_PYTHON_27_EXECUTABLE": "Establecer el ejecutable de Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Establecer el ejecutable de Python 3.X",
  "SET_JRE_RT_LIBRARY": "Establecer la biblioteca JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Establecer carpeta de biblioteca opcional",
  "SET_JAVAC_EXECUTABLE": "Establecer el ejecutable de Javac",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Configuración de Procyon",
  "CFR_SETTINGS": "Ajustes del CFR",
  "FERNFLOWER_SETTINGS": "Configuración de FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Código hexadecimal",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Descompilador de Bytecode",
  "DEBUG_HELPERS": "Ayudantes de depuración",
  "APPEND_BRACKETS_TO_LABEL": "Añadir paréntesis a la etiqueta",

  "PLUGINS": "Plugins",
  "OPEN_PLUGIN": "Abrir Plugin...",
  "RECENT_PLUGINS": "Plugins recientes",
  "CODE_SEQUENCE_DIAGRAM": "Diagrama de la secuencia del código",
  "MALICIOUS_CODE_SCANNER": "Escáner de códigos maliciosos",
  "SHOW_MAIN_METHODS": "Mostrar métodos principales",
  "SHOW_ALL_STRINGS": "Mostrar todas las cadenas",
  "REPLACE_STRINGS": "Reemplazar cadenas",
  "STACK_FRAMES_REMOVER": "Eliminador de marcos de pila",
  "ZKM_STRING_DECRYPTER": "Desencriptador de cadenas ZKM",
  "ALLATORI_STRING_DECRYPTER": "Descifrador de cadenas Allatori",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Ver los permisos de Android",
  "VIEW_MANIFEST": "Ver Manifiesto",
  "CHANGE_CLASSFILE_VERSIONS": "Cambiar las versiones de los archivos de clase",



  "PROCYON_DECOMPILER": "Descompilador Procyon",
  "CFR_DECOMPILER": "Descompilador CFR",
  "FERNFLOWER_DECOMPILER": "Descompilador FernFlower",
  "JADX_DECOMPILER": "Descompilador JADX",
  "JD_DECOMPILER": "Descompilador JD-GUI",
  "BYTECODE_DISASSEMBLER": "Desensamblador de Bytecode",
  "DISASSEMBLER": "Desensamblador",

  "ERROR": "Error",
  "NEW_JAVA_PLUGIN": "Nuevo plugin de Java",
  "NEW_JAVASCRIPT_PLUGIN": "Nuevo plugin de Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Solución sugerida: Haga clic en refrescar la clase, si falla de nuevo intente otro descompilador.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Solución sugerida: Pruebe con Ver>Panel>Krakatau>Bytecode y active la opción Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ADVERTENCIA: No hay ningún descompilador seleccionado actualmente. Pruebe con Ver>Panel y elija un descompilador.",
  "COMPILER_TIP": "Tenga en cuenta que la mayoría de los descompiladores no pueden producir clases compilables",
  "FIRST_OPEN_A_RESOURCE": "Primero abre un recurso dentro de BCV (clase, jar, zip o archivo apk)",
  "FIRST_OPEN_A_CLASS": "Primero abra un recurso de archivo de clase dentro de BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Primero vea un archivo de clase dentro de una pestaña.",
  "DRAG_CLASS_JAR": "Clase de arrastre",

  "YES": "Sí",
  "NO": "No",
  "ERROR2": "Error:",
  "PROCESS2": "Proceso:",
  "EXIT_VALUE_IS": "El valor de salida es:",
  "JAVA_COMPILE_FAILED": "Error de compilación de Java",
  "ERROR_COMPILING_CLASS": "Error al compilar la clase",
  "COMPILER": "Tenga en cuenta que la mayoría de los descompiladores no pueden producir clases compilables",
  "SELECT_LIBRARY_FOLDER": "Seleccione la carpeta de la biblioteca",
  "SELECT_JAVA_RT": "Seleccione JRE RT Jar",
  "SELECT_JAVA": "Seleccione el ejecutable Java",
  "SELECT_JAVAC": "Seleccione el ejecutable Javac",
  "SELECT_JAVA_TOOLS": "Seleccione el tarro de herramientas Java",
  "SELECT_PYTHON_2": "Seleccione el ejecutable de Python 2.7",
  "SELECT_PYTHON_3": "Seleccione el ejecutable de Python 3.x",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (o PyPy 2.7 para la velocidad) Ejecutable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (O PyPy 3.x para la velocidad) Ejecutable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Necesitas establecer tu ruta de ejecución de Python 2.7 (o PyPy 2.7 para la velocidad).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Necesitas establecer la ruta del ejecutable de Python 3.x (o PyPy 3.x para la velocidad).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Es necesario configurar la biblioteca JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\NArchivos de Programa\\NJava\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Dentro de JRE C:",
  "JAVAC_EXECUTABLE": "Javac Executable (Requiere JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Dentro de JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (Dentro de JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Carpeta de biblioteca opcional (compilador y Krakatau)",

  "HIDE_BRIDGE_METHODS": "Ocultar los métodos de los puentes",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Ocultar los miembros de la clase sintética",
  "DECOMPILE_INNER_CLASSES": "Descompilar las clases internas",
  "COLLAPSE_14_CLASS_REFERENCES": "Colapso 1.4 referencias de clase",
  "DECOMPILE_ASSERTIONS": "Descompilar aserciones",
  "HIDE_EMPTY_SUPER_INVOCATION": "Ocultar la superinvocación vacía",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Ocultar el constructor vacío por defecto",
  "DECOMPILE_GENERIC_SIGNATURES": "Descompilar firmas genéricas",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Asumir que el retorno no lanza excepciones",
  "DECOMPILE_ENUMERATIONS": "Descompilar las enumeraciones",
  "REMOVE_GETCLASS_INVOCATION": "Eliminar la invocación a getClass()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpretar int 1 como booleano verdadero",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Permitir no establecer el atributo sintético",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Considere los tipos sin nombre como java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruir los nombres de las variables a partir de la información de depuración",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Eliminar rangos de excepción vacíos",
  "DEINLINE_FINALLY_STRUCTURES": "Desinstalar finalmente las estructuras",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Permitir sólo caracteres ASCII en las cadenas",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Renombrar clases y elementos de clase ambiguos",

  "DECODE_ENUM_SWITCH": "Decodificar el interruptor Enum",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Interruptor de cadena de decodificación",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Coleccionista",
  "INNER_CLASSES": "Clases internas",
  "REMOVE_BOILER_PLATE": "Retirar la placa de la caldera",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Quitar los sintéticos de la clase interior",
  "DECODE_LAMBDAS": "Descodificar lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Constructor de ascensores Init",
  "REMOVE_DEAD_METHODS": "Eliminar los métodos muertos",
  "REMOVE_BAD_GENERICS": "Eliminar los genéricos defectuosos",
  "SUGAR_ASSERTS": "Azúcar afirma",
  "SUGAR_BOXING": "Boxeo con azúcar",
  "SHOW_VERSION": "Mostrar versión",
  "DECODE_FINALLY": "Descifrar por fin",
  "TIDY_MONITORS": "Monitores ordenados",
  "LENIENT": "Leninaje",
  "DUMP_CLASSPATH": "Vertedero Classpath",
  "COMMENTS": "Comentarios",
  "FORCE_TOP_SORT": "Forzar la clasificación superior",
  "FORCE_TOP_SORT_AGGRESS": "Fuerza de la Ordenación Superior Agresión",
  "FORCE_EXCEPTION_PRUNE": "Poda de excepción forzada",
  "STRING_BUFFER": "Buffer de cadenas",
  "STRING_BUILDER": "Constructor de cadenas",
  "SILENT": "Silencio",
  "RECOVER": "Recuperar",
  "OVERRIDE": "Anular",
  "SHOW_INFERRABLE": "Mostrar Inferible",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Fuerza de Propagación de Cond.",
  "HIDE_UTF": "Ocultar UTF",
  "HIDE_LONG_STRINGS": "Ocultar cadenas largas",
  "COMMENT_MONITORS": "Monitores de comentarios",
  "ALLOW_CORRECTING": "Permitir la corrección",
  "LABELLED_BLOCKS": "Bloques etiquetados",
  "J14CLASSOBJ": "J14ClaseOBJ",
  "HIDE_LANG_IMPORTS": "Importaciones Hide Lang",
  "RECOVER_TYPE_CLASH": "Recuperar el tipo de choque",
  "RECOVER_TYPE__HINTS": "Consejos sobre el tipo de recuperación",
  "FORCE_RETURNING_IFS": "Forzar el retorno de los fondos de inversión",
  "FOR_LOOP_AGG_CAPTURE": "Bucle de captura AGG",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Generar siempre una variable de excepción para los bloques Catch",
  "EXCLUDE_NESTED_TYPES": "Excluir tipos anidados",
  "SHOW_DEBUG_LINE_NUMBERS": "Mostrar números de línea de depuración",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Incluir números de línea en el bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Incluir diagnóstico de errores",
  "SHOW_SYNTHETIC_MEMBERS": "Mostrar miembros sintéticos",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplificar las referencias de los miembros",
  "MERGE_VARIABLES": "Fusión de variables",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Forzar argumentos de tipo explícito",
  "FORCE_EXPLICIT_IMPORTS": "Forzar las importaciones explícitas",
  "FLATTEN_SWITCH_BLOCKS": "Aplanar los bloques de interruptores",
  "RETAIN_POINTLESS_SWITCHES": "Mantener los interruptores sin sentido",
  "RETAIN_REDUNDANT_CASTS": "Conservar los moldes redundantes",
  "UNICODE_OUTPUT_ENABLED": "Salida Unicode habilitada",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Recargar recursos",
  "RELOAD_RESOURCES_CONFIRM": "¿Está seguro de que desea recargar los recursos?",
  "SELECT_FILE_TITLE": "Seleccione Archivo o Carpeta para abrir en {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Archivos de Clase o Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Seleccione el plugin externo",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Plugin externo BCV en js, java, python, ruby o groovy",
  "FOREIGN_LIBRARY_WARNING": "ADVERTENCIA: Si se desactiva esta opción, las bibliotecas obsoletas NO se eliminarán.\n\rTambién es un problema de seguridad.\n\rSÓLO DESACTÍVELO SI SABE LO QUE ESTÁ HACIENDO.",
  "RESET_TITLE": "{PRODUCT_NAME} - Restablecer espacio de trabajo",
  "RESET_CONFIRM": "¿Estás seguro de que quieres restablecer el espacio de trabajo?\n\rTambién restablecerá el navegador de archivos y la búsqueda.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Salir",
  "EXIT_CONFIRM": "¿Estás seguro de que quieres salir?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Acerca de - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Consola de plugins",
  "CLOSE_ALL_BUT_THIS": "Cerrar todo menos esto",
  "CLOSE_TAB": "Cerrar pestaña",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Por favor, envíe este registro de errores a",
  "PLEASE_SEND_RESOURCES": "Si usted es titular de los derechos legales correspondientes a la clase en cuestión",
  "ONE_PLUGIN_AT_A_TIME": "En este momento hay otro plugin en ejecución, por favor espere a que termine de ejecutarse.",
  "ILLEGAL_ACCESS_ERROR": "Por favor, utilice Java 15 o superior para hacerlo.",


  "FILES": "Archivos",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Búsqueda rápida de archivos (sin extensión de archivo)",
  "WORK_SPACE": "Espacio de trabajo",
  "EXACT": "Exactamente",
  "SEARCH": "Buscar en",
  "SEARCH_FROM": "Buscar desde:",
  "SEARCH_STRING": "Cadena de búsqueda:",
  "SEARCH_REGEX": "Buscar Regex:",
  "OWNER": "El propietario:",
  "NAME": "Nombre:",
  "DESC": "Desc:",
  "SAVE": "Ahorra...",
  "SAVE_AS": "Guardar como...",
  "RESULTS": "Resultados",
  "REFRESH": "Actualizar",
  "ANNOTATION_NAME": "Nombre de la anotación",
  "MATCH_CASE": "Caso del partido",
  "EXACT_PATH": "Ruta exacta",
  "MIN_SDK_VERSION": "Versión mínima del SDK",
  "PRINT_LINE_NUMBERS": "Imprimir números de línea"
}

```

`src/main/resources/translations/swahili.json`:

```json
{
  "FILE": "Faili",
  "ADD": "Ongeza ...",
  "NEW_WORKSPACE": "Nafasi mpya ya kazi",
  "RELOAD_RESOURCES": "Pakia Rasilimali",
  "RUN": "Endesha",
  "OPEN": "Fungua ...",
  "OPEN_UNSTYLED": "Fungua",
  "QUICK_OPEN": "Fungua Haraka",
  "DELETE": "Futa",
  "NEW": "Mpya",
  "EXPAND": "Panua",
  "COLLAPSE": "Kunja",
  "COMPILE": "Kutunga",
  "SAVE_AS_RUNNABLE_JAR": "Hifadhi Kama Mtungi Unaoweza Kuendeshwa ...",
  "SAVE_AS_ZIP": "Hifadhi Kama Zip ...",
  "SAVE_AS_DEX": "Hifadhi kama DEX ...",
  "SAVE_AS_APK": "Hifadhi Kama APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Tenganisha na Hifadhi Hatari zilizofunguliwa",
  "DECOMPILE_SAVE_ALL_CLASSES": "Kuoza na Okoa Madarasa Yote",
  "RECENT_FILES": "Faili za Hivi Karibuni",
  "ABOUT": "Kuhusu",
  "EXIT": "Utgång",

  "VIEW": "Angalia",
  "VISUAL_SETTINGS": "Mipangilio ya Kuonekana",
  "PANE_1": "Pane 1",
  "PANE_2": "Pane 2",
  "PANE_3": "Pane 3",
  "NONE": "Hakuna",
  "EDITABLE": "Inayoweza kubadilika",

  "LANGUAGE": "Lugha",
  "FONT_SIZE": "Ukubwa wa herufi",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Onyesha Faili Katika Kichwa cha Kichupo",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Kurahisisha Jina Katika Kichwa cha Kichupo",
  "SYNCHRONIZED_VIEWING": "Utazamaji uliosawazishwa",
  "SHOW_CLASS_METHODS": "Onyesha Njia za Darasa",

  "WINDOW_THEME": "Mandhari ya Dirisha",
  "SYSTEM_THEME": "Mada ya Mfumo",
  "DARK_THEME": "Mandhari meusi",
  "LIGHT_THEME": "Mandhari mepesi",
  "ONE_DARK_THEME": "Mandhari Moja meusi",
  "SOLARIZED_DARK_THEME": "Mada ya Giza Iliyodhibitiwa",
  "SOLARIZED_LIGHT_THEME": "Mandhari ya Nuru ya Nuru",
  "HIGH_CONTRAST_DARK_THEME": "Mandhari ya Giza Tofauti ya Juu",
  "HIGH_CONTRAST_LIGHT_THEME": "Mandhari ya Nuru ya Tofauti",
  "ONE_DARK": "Giza Moja",
  "SOLARIZED_DARK": "Nuru ya jua",
  "SOLARIZED_LIGHT": "Mwanga wa jua",
  "HIGH_CONTRAST_DARK": "Tofauti ya Juu Giza",
  "HIGH_CONTRAST_LIGHT": "Mwanga wa Tofauti ya Juu",
  "TEXT_AREA_THEME": "Mandhari ya Eneo la Nakala",
  "DEFAULT_RECOMMENDED_LIGHT": "Chaguomsingi (Nuru inayopendekezwa)",
  "THEME_MATCH": "Mechi ya Mandhari (Imependekezwa)",
  "DARK": "Giza (Inapendekezwa Giza)",
  "DARK_ALT": "Giza-Nyeusi",
  "DEFAULT_ALT": "Mbadala-Alt",
  "ECLIPSE": "Kupatwa kwa jua",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Studio ya Visual",
  "DRUID_DARK": "Druid (Giza)",
  "MONOKAI_DARK": "Monokai (Giza)",

  "SETTINGS": "Mipangilio",
  "COMPILE_ON_SAVE": "Jumuisha kwenye Hifadhi",
  "COMPILE_ON_REFRESH": "Kusanya Juu ya Kuonyesha upya",
  "REFRESH_ON_VIEW_CHANGE": "Onyesha upya juu ya Mabadiliko ya Mtazamo",
  "DECODE_APK_RESOURCES": "Fafanua Rasilimali za APK",
  "APK_CONVERSION": "Ubadilishaji wa APK",
  "APK_CONVERSION_DECODING": "Ubadilishaji / Kusimba kwa APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Badilisha",
  "UPDATE_CHECK": "Sasisha Angalia",
  "DELETE_UNKNOWN_LIBS": "Futa Libs za Kigeni / za zamani",
  "FORCE_PURE_ASCII_AS_TEXT": "Lazimisha Ascii safi kama Nakala",
  "SET_PYTHON_27_EXECUTABLE": "Weka Python 2.7 inayoweza kutekelezwa",
  "SET_PYTHON_30_EXECUTABLE": "Weka Python 3.X Inayoweza Kutekelezwa",
  "SET_JRE_RT_LIBRARY": "Weka Maktaba ya JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Weka Folda ya Hiari ya Maktaba",
  "SET_JAVAC_EXECUTABLE": "Weka Javac Inayoweza Kutekelezwa",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Mipangilio ya Procyon",
  "CFR_SETTINGS": "Mipangilio ya CFR",
  "FERNFLOWER_SETTINGS": "Mipangilio ya FernFlower",
  "PROCYON": "Prokon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali / Dex",
  "HEXCODE": "Nambari ya nambari",
  "BYTECODE": "Nambari mbadala",
  "ASM_TEXTIFY": "Ujumbe wa ASM",

  "BYTECODE_DECOMPILER": "Mtenganishaji wa Bytecode",
  "DEBUG_HELPERS": "Wasaidizi wa Utatuzi",
  "APPEND_BRACKETS_TO_LABEL": "Tumia mabano kwa Lebo",

  "PLUGINS": "Programu-jalizi",
  "OPEN_PLUGIN": "Fungua Programu-jalizi ...",
  "RECENT_PLUGINS": "Programu-jalizi za Hivi Karibuni",
  "CODE_SEQUENCE_DIAGRAM": "Mchoro wa Utaratibu wa Kanuni",
  "MALICIOUS_CODE_SCANNER": "Skana Skana Mbaya",
  "SHOW_MAIN_METHODS": "Onyesha Njia kuu",
  "SHOW_ALL_STRINGS": "Onyesha Kamba Zote",
  "REPLACE_STRINGS": "Badilisha Nafasi",
  "STACK_FRAMES_REMOVER": "Remover ya fremu",
  "ZKM_STRING_DECRYPTER": "ZKM Kamba ya Kusimba",
  "ALLATORI_STRING_DECRYPTER": "Allatori ya Kamba ya Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Angalia Ruhusa za Android",
  "VIEW_MANIFEST": "Angalia Dhihirisho",
  "CHANGE_CLASSFILE_VERSIONS": "Badilisha Matoleo ya ClassFile",



  "PROCYON_DECOMPILER": "Mtenganishaji wa Procyon",
  "CFR_DECOMPILER": "Mchanganyiko wa CFR",
  "FERNFLOWER_DECOMPILER": "Mkusanyaji wa FernFlower",
  "JADX_DECOMPILER": "JADX Mtenganishaji",
  "JD_DECOMPILER": "JD-GUI Mtenganishaji",
  "BYTECODE_DISASSEMBLER": "Kutenganisha kwa Bytecode",
  "DISASSEMBLER": "Mtenganishaji",

  "ERROR": "Kosa",
  "NEW_JAVA_PLUGIN": "Programu-jalizi mpya ya Java",
  "NEW_JAVASCRIPT_PLUGIN": "Programu-jalizi mpya ya Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Kurekebisha Iliyopendekezwa: Bonyeza darasa la kuonyesha upya, ikiwa inashindwa tena jaribu mtengano mwingine.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Kurekebisha Iliyopendekezwa: Jaribu Angalia> Pane> Krakatau> Bytecode na uwezeshe kuhaririwa.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ONYO: Hakuna mtenganishaji aliyechaguliwa kwa sasa. Jaribu Tazama> Pane na uchague mtenganishaji.",
  "COMPILER_TIP": "Kumbuka watenganishaji wengi hawawezi kutoa madarasa yanayopatikana",
  "FIRST_OPEN_A_RESOURCE": "Kwanza fungua rasilimali ndani ya BCV (darasa, jar, zip au faili ya apk)",
  "FIRST_OPEN_A_CLASS": "Kwanza fungua rasilimali ya darasa ndani ya BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Kwanza angalia faili ya darasa ndani ya kichupo.",
  "DRAG_CLASS_JAR": "Buruta darasa / jar / zip / APK / DEX hapa",

  "YES": "Ndio",
  "NO": "Hapana",
  "ERROR2": "Kosa:",
  "PROCESS2": "Mchakato:",
  "EXIT_VALUE_IS": "Thamani ya Kutoka ni:",
  "JAVA_COMPILE_FAILED": "Mkusanyiko wa Java Umeshindwa",
  "ERROR_COMPILING_CLASS": "Hitilafu wakati wa kukusanya darasa",
  "COMPILER": "Kumbuka watenganishaji wengi hawawezi kutoa madarasa yanayopatikana",
  "SELECT_LIBRARY_FOLDER": "Chagua Folda ya Maktaba",
  "SELECT_JAVA_RT": "Chagua JRE RT Jar",
  "SELECT_JAVA": "Chagua Java inayoweza kutekelezwa",
  "SELECT_JAVAC": "Chagua Kutekelezwa kwa Javac",
  "SELECT_JAVA_TOOLS": "Chagua Mtungi wa Zana za Java",
  "SELECT_PYTHON_2": "Chagua Python 2.7 inayoweza kutekelezwa",
  "SELECT_PYTHON_3": "Chagua Python 3.x Inayoweza Kutekelezwa",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Au PyPy 2.7 kwa kasi) Inayoweza kutekelezwa",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Au PyPy 3.x kwa kasi) Inayoweza kutekelezwa",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Unahitaji kuweka Python 2.7 yako (au PyPy 2.7 kwa kasi) njia inayoweza kutekelezwa.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Unahitaji kuweka Python 3.x yako (au PyPy 3.x kwa kasi) njia inayoweza kutekelezwa.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Unahitaji kuweka JRE RT Library yako.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "Java Inayoweza Kutekelezwa (Ndani ya JRE C: / Faili za Programu / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Javac Inayoweza Kutekelezwa (Inahitaji JDK C: / Faili za Programu / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "Vyombo vya Java Jar (Ndani ya JDK C: / Faili za Programu / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Ndani ya JRE C: / Faili za Programu / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Folda ya Hiari ya Maktaba (Mkusanyaji na Krakatau)",

  "HIDE_BRIDGE_METHODS": "Ficha njia za daraja",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Ficha washiriki wa darasa bandia",
  "DECOMPILE_INNER_CLASSES": "Tenganisha madarasa ya ndani",
  "COLLAPSE_14_CLASS_REFERENCES": "Kunja marejeleo ya darasa la 1.4",
  "DECOMPILE_ASSERTIONS": "Tenganisha madai",
  "HIDE_EMPTY_SUPER_INVOCATION": "Ficha dua kubwa tupu",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Ficha mjenzi chaguomsingi mtupu",
  "DECOMPILE_GENERIC_SIGNATURES": "Tenganisha saini za generic",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Fikiria kurudi sio kutupa ubaguzi",
  "DECOMPILE_ENUMERATIONS": "Tenganisha hesabu",
  "REMOVE_GETCLASS_INVOCATION": "Ondoa maombi ya GetClass ()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Fasiri int 1 kama kweli ya boolean",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Ruhusu isiweke sifa ya sintetiki",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Fikiria aina zisizo na jina kama java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Tengeneza majina tofauti kutoka kwa maelezo ya utatuzi",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Ondoa safu tupu za ubaguzi",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline mwishowe miundo",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Ruhusu herufi za ASCII tu kwa masharti",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Badili jina la madarasa ya kutatanisha na vitu vya darasa",

  "DECODE_ENUM_SWITCH": "Futa Kubadilisha Enum",
  "SUGARENUMS": "Mchanganyiko wa Sukari",
  "DECODE_STRING_SWITCH": "Fafanua Kubadilisha Kamba",
  "ARRAYITER": "Mpangaji",
  "COLLECTIONITER": "Mkusanyaji",
  "INNER_CLASSES": "Madarasa ya ndani",
  "REMOVE_BOILER_PLATE": "Ondoa Sahani ya Boiler",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Ondoa Synthetics ya Darasa la Ndani",
  "DECODE_LAMBDAS": "Tambua Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Inua Ujenzi Init",
  "REMOVE_DEAD_METHODS": "Ondoa Mbinu Zilizokufa",
  "REMOVE_BAD_GENERICS": "Ondoa Generics Mbaya",
  "SUGAR_ASSERTS": "Kujiunga na Sukari",
  "SUGAR_BOXING": "Ndondi ya Sukari",
  "SHOW_VERSION": "Onyesha Toleo",
  "DECODE_FINALLY": "Tambua mwisho",
  "TIDY_MONITORS": "Wachunguzi Wadhifu",
  "LENIENT": "Mpole",
  "DUMP_CLASSPATH": "Tupa Njia ya Njia",
  "COMMENTS": "Maoni",
  "FORCE_TOP_SORT": "Lazimisha Aina ya Juu",
  "FORCE_TOP_SORT_AGGRESS": "Lazimisha Aina ya Juu ya Aina",
  "FORCE_EXCEPTION_PRUNE": "Lazimisha Prune ya Ubaguzi",
  "STRING_BUFFER": "Kamba bafa",
  "STRING_BUILDER": "Mjenzi wa Kamba",
  "SILENT": "Kimya",
  "RECOVER": "Rejesha",
  "OVERRIDE": "Batilisha",
  "SHOW_INFERRABLE": "Onyesha Isiyobadilika",
  "AEXAGG": "Mchanganyiko",
  "FORCE_COND_PROPAGATE": "Nguvu Cond Propagate",
  "HIDE_UTF": "Ficha UTF",
  "HIDE_LONG_STRINGS": "Ficha Kamba ndefu",
  "COMMENT_MONITORS": "Wachunguzi wa Maoni",
  "ALLOW_CORRECTING": "Ruhusu Kurekebisha",
  "LABELLED_BLOCKS": "Vitalu vilivyo na Lebo",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Ficha Uingizaji wa Lang",
  "RECOVER_TYPE_CLASH": "Rejesha Mgongano wa Aina",
  "RECOVER_TYPE__HINTS": "Pata Vidokezo vya Aina",
  "FORCE_RETURNING_IFS": "Lazimisha Kurudisha IFs",
  "FOR_LOOP_AGG_CAPTURE": "Kwa Kukamata Kitanzi cha AGG",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Daima Zalisha Mseto Mbadala kwa Vitalu Vya Kukamata",
  "EXCLUDE_NESTED_TYPES": "Tenga Aina Zilizowekwa Nchini",
  "SHOW_DEBUG_LINE_NUMBERS": "Onyesha Nambari za laini za Utatuzi",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Jumuisha Nambari za Mstari Katika Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Jumuisha Utambuzi wa Kosa",
  "SHOW_SYNTHETIC_MEMBERS": "Onyesha Wanachama wa Synthetic",
  "SIMPLIFY_MEMBER_REFERENCES": "Rahisi Marejeleo ya Mwanachama",
  "MERGE_VARIABLES": "Unganisha Vigezo",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Lazimisha Hoja za Aina Wazi",
  "FORCE_EXPLICIT_IMPORTS": "Lazimisha Uingizaji Dhahiri",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Kubadilisha Vitalu",
  "RETAIN_POINTLESS_SWITCHES": "Weka swichi zisizo na maana",
  "RETAIN_REDUNDANT_CASTS": "Kubadilisha Utupaji uliotengwa",
  "UNICODE_OUTPUT_ENABLED": "Pato la Unicode Limewezeshwa",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Pakia Rasilimali upya",
  "RELOAD_RESOURCES_CONFIRM": "Je! Una uhakika unataka kupakia tena rasilimali?",
  "SELECT_FILE_TITLE": "Chagua Faili au Folda ya kufungua kwenye {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, Faili za Darasa au Zip / Jar / Nyaraka za Vita",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Chagua Programu-jalizi ya nje",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Programu-jalizi ya nje ya BCV katika js, java, chatu, ruby ​​au groovy",
  "FOREIGN_LIBRARY_WARNING": "ONYO: Kwa kugeuzwa kwa maktaba zilizopitwa na wakati hakutaondolewa.\n\rPia ni suala la usalama.\n\rZIMA TU ikiwa unajua unachofanya.",
  "RESET_TITLE": "{PRODUCT_NAME} - Weka upya nafasi ya kazi",
  "RESET_CONFIRM": "Je! Una uhakika unataka kuweka upya nafasi ya kazi?\n\rPia itaweka upya navigator yako ya faili na utafute.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Toka",
  "EXIT_CONFIRM": "Je! Una uhakika unataka kutoka?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Kuhusu - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Dashibodi ya Programu-jalizi",
  "CLOSE_ALL_BUT_THIS": "Funga Yote Lakini Hii",
  "CLOSE_TAB": "Funga Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Tafadhali tuma kumbukumbu hii ya makosa kwa",
  "PLEASE_SEND_RESOURCES": "Ikiwa unashikilia haki sahihi za kisheria kwa faili ya darasa / jar / apk husika tafadhali ingiza hiyo pia.",
  "ONE_PLUGIN_AT_A_TIME": "Kwa sasa kuna programu-jalizi nyingine inayofanya kazi sasa hivi, tafadhali subiri hiyo ikamilishe kutekeleza.",
  "ILLEGAL_ACCESS_ERROR": "Tafadhali tumia Java 15 au zaidi kufanya hivi.",


  "FILES": "Mafaili",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Utafutaji wa faili haraka (hakuna kiendelezi cha faili)",
  "WORK_SPACE": "Nafasi ya Kazi",
  "EXACT": "Halisi",
  "SEARCH": "Tafuta",
  "SEARCH_FROM": "Tafuta Kutoka:",
  "SEARCH_STRING": "Kamba ya Utafutaji:",
  "SEARCH_REGEX": "Tafuta Regex:",
  "OWNER": "Mmiliki:",
  "NAME": "Jina:",
  "DESC": "Desc:",
  "SAVE": "Hifadhi ...",
  "SAVE_AS": "Hifadhi kama ...",
  "RESULTS": "Matokeo",
  "REFRESH": "Onyesha upya",
  "ANNOTATION_NAME": "Jina la Ufafanuzi",
  "MATCH_CASE": "Kesi ya Kulinganisha",
  "EXACT_PATH": "Njia Hasa",
  "MIN_SDK_VERSION": "Toleo la chini kabisa la SDK",
  "PRINT_LINE_NUMBERS": "Chapisha Nambari za Mstari"
}

```

`src/main/resources/translations/swedish.json`:

```json
{
  "FILE": "Fil",
  "ADD": "Lägg till...",
  "NEW_WORKSPACE": "Nytt arbetsområde",
  "RELOAD_RESOURCES": "Återladdning av resurser",
  "RUN": "Kör",
  "OPEN": "Öppna...",
  "OPEN_UNSTYLED": "Öppna",
  "QUICK_OPEN": "Snabböppning",
  "DELETE": "Ta bort",
  "NEW": "Ny",
  "EXPAND": "Expandera",
  "COLLAPSE": "Kollaps",
  "COMPILE": "Kompilera",
  "SAVE_AS_RUNNABLE_JAR": "Spara som körbar burk...",
  "SAVE_AS_ZIP": "Spara som zip...",
  "SAVE_AS_DEX": "Spara som DEX...",
  "SAVE_AS_APK": "Spara som APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Dekompilera och spara öppnade klasser",
  "DECOMPILE_SAVE_ALL_CLASSES": "Dekompilera och spara alla klasser",
  "RECENT_FILES": "Senaste filerna",
  "ABOUT": "Om",
  "EXIT": "Avsluta",

  "VIEW": "Visa",
  "VISUAL_SETTINGS": "Visuella inställningar",
  "PANE_1": "ruta 1",
  "PANE_2": "ruta 2",
  "PANE_3": "ruta 3",
  "NONE": "Ingen",
  "EDITABLE": "Redigerbar",

  "LANGUAGE": "Språk",
  "FONT_SIZE": "Teckensnittsstorlek",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Visa filen i flikens titel",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Förenkla namnet i flikens titel",
  "SYNCHRONIZED_VIEWING": "Synkroniserad visning",
  "SHOW_CLASS_METHODS": "Visa klassens metoder",

  "WINDOW_THEME": "Tema för fönstren",
  "SYSTEM_THEME": "Systemtema",
  "DARK_THEME": "Mörkt tema",
  "LIGHT_THEME": "Tema Ljus",
  "ONE_DARK_THEME": "Ett mörkt tema",
  "SOLARIZED_DARK_THEME": "Solarized mörkt tema",
  "SOLARIZED_LIGHT_THEME": "Tema Solarized Light",
  "HIGH_CONTRAST_DARK_THEME": "Mörkt tema med hög kontrast",
  "HIGH_CONTRAST_LIGHT_THEME": "Tema med hög kontrast och ljus",
  "ONE_DARK": "En mörk",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solarized Light",
  "HIGH_CONTRAST_DARK": "Hög kontrast mörk",
  "HIGH_CONTRAST_LIGHT": "Ljus med hög kontrast",
  "TEXT_AREA_THEME": "Tema för textområdet",
  "DEFAULT_RECOMMENDED_LIGHT": "Standard (rekommenderat ljus)",
  "THEME_MATCH": "Temamatch (rekommenderas)",
  "DARK": "Mörk (Rekommenderad mörk)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Standard-Alt",
  "ECLIPSE": "Eclipse",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (mörk)",
  "MONOKAI_DARK": "Monokai (mörk)",

  "SETTINGS": "Inställningar",
  "COMPILE_ON_SAVE": "Kompilera när du sparar",
  "COMPILE_ON_REFRESH": "Kompilera vid uppdatering",
  "REFRESH_ON_VIEW_CHANGE": "Uppdatera vid ändring av visning",
  "DECODE_APK_RESOURCES": "Avkoda APK-resurser",
  "APK_CONVERSION": "Konvertering av APK",
  "APK_CONVERSION_DECODING": "Konvertering av APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Uppdateringskontroll",
  "DELETE_UNKNOWN_LIBS": "Radera utländska",
  "FORCE_PURE_ASCII_AS_TEXT": "Force Pure Ascii som text",
  "SET_PYTHON_27_EXECUTABLE": "Ställ in Python 2.7 Exekverbar",
  "SET_PYTHON_30_EXECUTABLE": "Ställ in Python 3.X Exekverbar",
  "SET_JRE_RT_LIBRARY": "Ställ in JRE RT-biblioteket",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Ange valfri biblioteksmapp",
  "SET_JAVAC_EXECUTABLE": "Ställ in Javac Executable",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Inställningar för Procyon",
  "CFR_SETTINGS": "Inställningar för CFR",
  "FERNFLOWER_SETTINGS": "Inställningar för FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali",
  "HEXCODE": "Hexkod",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode-dekompilering",
  "DEBUG_HELPERS": "Hjälpmedel för felsökning",
  "APPEND_BRACKETS_TO_LABEL": "Lägga till parenteser till etiketten",

  "PLUGINS": "Insticksprogram",
  "OPEN_PLUGIN": "Öppna Plugin...",
  "RECENT_PLUGINS": "Senaste plugins",
  "CODE_SEQUENCE_DIAGRAM": "Kodsekvensdiagram",
  "MALICIOUS_CODE_SCANNER": "Skanner för skadlig kod",
  "SHOW_MAIN_METHODS": "Visa de viktigaste metoderna",
  "SHOW_ALL_STRINGS": "Visa alla strängar",
  "REPLACE_STRINGS": "Ersätt strängar",
  "STACK_FRAMES_REMOVER": "Stack Frames Remover",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Dekrypterare",
  "VIEW_ANDROID_PERMISSIONS": "Visa Android-behörigheter",
  "VIEW_MANIFEST": "Visa manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Ändra versioner av ClassFile",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR-dekompilering",
  "FERNFLOWER_DECOMPILER": "FernFlower-dekompilering",
  "JADX_DECOMPILER": "JADX-dekompilering",
  "JD_DECOMPILER": "JD-GUI-dekompilering",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Disassembler",

  "ERROR": "Fel",
  "NEW_JAVA_PLUGIN": "Ny Java-plugin",
  "NEW_JAVASCRIPT_PLUGIN": "Ny Javascript-plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Föreslagen lösning: Klicka på uppdatera klassen, om det misslyckas igen försök en annan dekompilator.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Förslag till lösning: Prova Visa>Fönster>Krakatau>Bytecode och aktivera Redigerbart.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "VARNING: Ingen dekompilator är för närvarande vald. Försök med Visa>Fönster och välj en dekompilator.",
  "COMPILER_TIP": "Tänk på att de flesta dekompilatorer inte kan producera kompilerbara klasser.",
  "FIRST_OPEN_A_RESOURCE": "Öppna först en resurs i BCV (klass, jar, zip eller apk-fil).",
  "FIRST_OPEN_A_CLASS": "Öppna först en klassfilresurs i BCV (jar, zip, apk, dex).",
  "FIRST_VIEW_A_CLASS": "Visa först en klassfil i en flik.",
  "DRAG_CLASS_JAR": "Dra klass",

  "YES": "Ja",
  "NO": "Ingen",
  "ERROR2": "Fel:",
  "PROCESS2": "Process:",
  "EXIT_VALUE_IS": "Exit Value är:",
  "JAVA_COMPILE_FAILED": "Java-kompilering misslyckades",
  "ERROR_COMPILING_CLASS": "Fel vid kompilering av klassen",
  "COMPILER": "Tänk på att de flesta dekompilatorer inte kan producera kompilerbara klasser.",
  "SELECT_LIBRARY_FOLDER": "Välj biblioteksmapp",
  "SELECT_JAVA_RT": "Välj JRE RT Jar",
  "SELECT_JAVA": "Välj Java Executable",
  "SELECT_JAVAC": "Välj Javac Executable",
  "SELECT_JAVA_TOOLS": "Välj Java Tools Jar",
  "SELECT_PYTHON_2": "Välj Python 2.7 Executable",
  "SELECT_PYTHON_3": "Välj Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (eller PyPy 2.7 för att få fart) Exekverbart",
  "PYTHON_3_EXECUTABLE": "Python 3.x (eller PyPy 3.x för att få fart) Exekverbart",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Du måste ange sökvägen för Python 2.7 (eller PyPy 2.7 för att få fart).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Du måste ange sökvägen för Python 3.x (eller PyPy 3.x för att få fart).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Du måste ställa in ditt JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (inuti JRE C:",
  "JAVAC_EXECUTABLE": "Javac Executable (kräver JDK C:",
  "JAVA_TOOLS_JAR": "Java Tools Jar (inuti JDK C:",
  "JAVA_RT_JAR": "Java RT Jar (inuti JRE C:",
  "OPTIONAL_LIBRARY_FOLDER": "Biblioteksmapp som är valbar (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Dölj brometoder",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Dölja syntetiska klassmedlemmar",
  "DECOMPILE_INNER_CLASSES": "Dekompilera inre klasser",
  "COLLAPSE_14_CLASS_REFERENCES": "Kollaps 1.4 klassreferenser",
  "DECOMPILE_ASSERTIONS": "Dekompilera påståenden",
  "HIDE_EMPTY_SUPER_INVOCATION": "Dölja tomma superinvationer",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Dölj tom standardkonstruktör",
  "DECOMPILE_GENERIC_SIGNATURES": "Dekompilera generiska signaturer",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Anta att returen inte ger upphov till undantag",
  "DECOMPILE_ENUMERATIONS": "Dekompilera uppräkningar",
  "REMOVE_GETCLASS_INVOCATION": "Ta bort getClass()-anropet",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Tolka int 1 som boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Tillåt att inte ställa in ett syntetiskt attribut",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Betrakta namnlösa typer som java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Rekonstruera variabelnamn från felsökningsinformation",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Ta bort tomma undantagsområden",
  "DEINLINE_FINALLY_STRUCTURES": "Ta bort slutligt strukturer.",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Endast ASCII-tecken tillåts i strängar",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Byt namn på tvetydiga klasser och klasselement",

  "DECODE_ENUM_SWITCH": "Avkodning Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Avkodning av strängbyte",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Samling",
  "INNER_CLASSES": "Inre klasser",
  "REMOVE_BOILER_PLATE": "Ta bort pannplattan",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Ta bort inner Class Synthetics",
  "DECODE_LAMBDAS": "Avkodning av lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Liftkonstruktör Init",
  "REMOVE_DEAD_METHODS": "Ta bort döda metoder",
  "REMOVE_BAD_GENERICS": "Ta bort dåliga generiska läkemedel",
  "SUGAR_ASSERTS": "Socker hävdar",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Visa version",
  "DECODE_FINALLY": "Avkodning Slutligen",
  "TIDY_MONITORS": "Ordentliga bildskärmar",
  "LENIENT": "Lättnader",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Kommentarer",
  "FORCE_TOP_SORT": "Tvinga till toppsortering",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Tvinga fram undantag Prune",
  "STRING_BUFFER": "Strängbuffert",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Tyst",
  "RECOVER": "Återskapa",
  "OVERRIDE": "Överprövning",
  "SHOW_INFERRABLE": "Visa Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Kraft Cond Propagera",
  "HIDE_UTF": "Dölj UTF",
  "HIDE_LONG_STRINGS": "Dölj långa strängar",
  "COMMENT_MONITORS": "Övervakning av kommentarer",
  "ALLOW_CORRECTING": "Tillåt korrigering",
  "LABELLED_BLOCKS": "Märkta block",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Återskapa typ av kollision",
  "RECOVER_TYPE__HINTS": "Tips för att återskapa typ",
  "FORCE_RETURNING_IFS": "Tvinga återvändande IF:er att återvända",
  "FOR_LOOP_AGG_CAPTURE": "För Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Generera alltid undantagsvariabeln för fångstblock",
  "EXCLUDE_NESTED_TYPES": "Exkludera inbäddade typer",
  "SHOW_DEBUG_LINE_NUMBERS": "Visa nummer på felsökningsrader",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Inkludera radnummer i bytekod",
  "INCLUDE_ERROR_DIAGNOSTICS": "Inkludera feldiagnostik",
  "SHOW_SYNTHETIC_MEMBERS": "Visa syntetiska medlemmar",
  "SIMPLIFY_MEMBER_REFERENCES": "Förenkla referenserna till medlemmarna",
  "MERGE_VARIABLES": "Slå samman variabler",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Tvinga fram explicita typargument",
  "FORCE_EXPLICIT_IMPORTS": "Tvinga fram explicita importer",
  "FLATTEN_SWITCH_BLOCKS": "Platta växelblock",
  "RETAIN_POINTLESS_SWITCHES": "Behåll meningslösa växlar",
  "RETAIN_REDUNDANT_CASTS": "Behåll överflödiga gjutningar",
  "UNICODE_OUTPUT_ENABLED": "Unicode-utgång aktiverad",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Ladda om resurser",
  "RELOAD_RESOURCES_CONFIRM": "Är du säker på att du vill ladda om resurserna?",
  "SELECT_FILE_TITLE": "Välj fil eller mapp att öppna i {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, klassfiler eller Zip",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Välj extern plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin i js, java, python, ruby eller groovy",
  "FOREIGN_LIBRARY_WARNING": "VARNING: Om denna funktion är avstängd kommer föråldrade bibliotek INTE att tas bort.\n\rDet är också en säkerhetsfråga.\n\rSLÅ BARA AV DEN OM DU VET VAD DU GÖR.",
  "RESET_TITLE": "{PRODUCT_NAME} - Återställ arbetsutrymme",
  "RESET_CONFIRM": "Är du säker på att du vill återställa arbetsområdet?\n\rDet återställer också din filnavigator och sökning.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Avsluta",
  "EXIT_CONFIRM": "Är du säker på att du vill avsluta?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Om - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin-konsol",
  "CLOSE_ALL_BUT_THIS": "Stäng allt utom detta",
  "CLOSE_TAB": "Stäng fliken",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Skicka denna fellogg till",
  "PLEASE_SEND_RESOURCES": "Om du har lämpliga lagliga rättigheter till den relevanta klassen.",
  "ONE_PLUGIN_AT_A_TIME": "Ett annat insticksprogram körs just nu, vänligen vänta tills det är klart.",
  "ILLEGAL_ACCESS_ERROR": "Använd Java 15 eller äldre för att göra detta.",


  "FILES": "Filer",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Snabb filsökning (ingen filändelse)",
  "WORK_SPACE": "Arbetsutrymme",
  "EXACT": "Exakt",
  "SEARCH": "Sök på",
  "SEARCH_FROM": "Sök från:",
  "SEARCH_STRING": "Söksträng:",
  "SEARCH_REGEX": "Sök Regex:",
  "OWNER": "Ägare:",
  "NAME": "Namn:",
  "DESC": "Desc:",
  "SAVE": "Spara...",
  "SAVE_AS": "Spara som...",
  "RESULTS": "Resultat",
  "REFRESH": "Uppdatera",
  "ANNOTATION_NAME": "Namn på anteckning",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Exakt väg",
  "MIN_SDK_VERSION": "Minsta version av SDK",
  "PRINT_LINE_NUMBERS": "Utskrift av linjenummer"
}

```

`src/main/resources/translations/thai.json`:

```json
{
  "FILE": "ไฟล์",
  "ADD": "เพิ่ม...",
  "NEW_WORKSPACE": "พื้นที่ทำงานใหม่",
  "RELOAD_RESOURCES": "รีโหลดทรัพยากร",
  "RUN": "วิ่ง",
  "OPEN": "Open...",
  "OPEN_UNSTYLED": "Open",
  "QUICK_OPEN": "Quick Open",
  "DELETE": "Delete",
  "NEW": "New",
  "EXPAND": "Expand",
  "COLLAPSE": "Collapse",
  "COMPILE": "รวบรวม",
  "SAVE_AS_RUNNABLE_JAR": "บันทึกเป็น Runnable Jar...",
  "SAVE_AS_ZIP": "บันทึกเป็นซิป...",
  "SAVE_AS_DEX": "บันทึกเป็น DEX...",
  "SAVE_AS_APK": "บันทึกเป็น APK...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "ถอดรหัสและบันทึกคลาสที่เปิดอยู่",
  "DECOMPILE_SAVE_ALL_CLASSES": "ถอดรหัสและบันทึกคลาสทั้งหมด",
  "RECENT_FILES": "ไฟล์ล่าสุด",
  "ABOUT": "เกี่ยวกับ",
  "EXIT": "ทางออก",

  "VIEW": "ดู",
  "VISUAL_SETTINGS": "การตั้งค่าภาพ",
  "PANE_1": "บานหน้าต่าง 1",
  "PANE_2": "บานหน้าต่าง2",
  "PANE_3": "บานหน้าต่าง 3",
  "NONE": "ไม่มี",
  "EDITABLE": "แก้ไขได้",

  "LANGUAGE": "ภาษา",
  "FONT_SIZE": "ขนาดตัวอักษร",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "แสดงไฟล์ในชื่อแท็บ",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "ลดความซับซ้อนของชื่อในชื่อแท็บ",
  "SYNCHRONIZED_VIEWING": "การดูแบบซิงโครไนซ์",
  "SHOW_CLASS_METHODS": "แสดงวิธีการเรียน",

  "WINDOW_THEME": "ธีมหน้าต่าง",
  "SYSTEM_THEME": "ธีมของระบบ",
  "DARK_THEME": "ธีมมืด",
  "LIGHT_THEME": "ธีมไฟ",
  "ONE_DARK_THEME": "One Dark Theme",
  "SOLARIZED_DARK_THEME": "Solarized Dark Theme",
  "SOLARIZED_LIGHT_THEME": "Solarized Light Theme",
  "HIGH_CONTRAST_DARK_THEME": "High Contrast Dark Theme",
  "HIGH_CONTRAST_LIGHT_THEME": "High Contrast Light Theme",
  "ONE_DARK": "One Dark",
  "SOLARIZED_DARK": "Solarized Dark",
  "SOLARIZED_LIGHT": "Solarized Light",
  "HIGH_CONTRAST_DARK": "High Contrast Dark",
  "HIGH_CONTRAST_LIGHT": "High Contrast Light",
  "TEXT_AREA_THEME": "ธีมพื้นที่ข้อความ",
  "DEFAULT_RECOMMENDED_LIGHT": "ค่าเริ่มต้น (ไฟที่แนะนำ)",
  "THEME_MATCH": "Theme Match (Recommended)",
  "DARK": "Dark (Recommended Dark)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "ค่าเริ่มต้น-Alt",
  "ECLIPSE": "คราส",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "ดรูอิด (มืด)",
  "MONOKAI_DARK": "โมโนไค (ความมืด)",

  "SETTINGS": "การตั้งค่า",
  "COMPILE_ON_SAVE": "รวบรวมในบันทึก",
  "COMPILE_ON_REFRESH": "คอมไพล์เมื่อรีเฟรช",
  "REFRESH_ON_VIEW_CHANGE": "รีเฟรชเมื่อดูการเปลี่ยนแปลง",
  "DECODE_APK_RESOURCES": "ถอดรหัสทรัพยากร APK",
  "APK_CONVERSION": "การแปลง APK",
  "APK_CONVERSION_DECODING": "APK Conversion/Decoding",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "อัปเดตตรวจสอบ",
  "DELETE_UNKNOWN_LIBS": "ลบ Libs ต่างประเทศ / ล้าสมัย",
  "FORCE_PURE_ASCII_AS_TEXT": "บังคับให้ Ascii บริสุทธิ์เป็นข้อความ",
  "SET_PYTHON_27_EXECUTABLE": "ตั้งค่า Python 2.7 ปฏิบัติการได้",
  "SET_PYTHON_30_EXECUTABLE": "ตั้งค่า Python 3.X ปฏิบัติการได้",
  "SET_JRE_RT_LIBRARY": "ตั้งค่าไลบรารี JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "ตั้งค่าโฟลเดอร์ไลบรารีเสริม",
  "SET_JAVAC_EXECUTABLE": "ตั้งค่า Javac ปฏิบัติการ",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon Settings",
  "CFR_SETTINGS": "CFR Settings",
  "FERNFLOWER_SETTINGS": "FernFlower Settings",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "เฟิร์นฟลาวเวอร์",
  "KRAKATAU": "กรากะตัว",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "สมาลี",
  "SMALI_DEX": "สมาลี/เด็กซ์",
  "HEXCODE": "รหัสเลขฐานสิบหก",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode Decompiler",
  "DEBUG_HELPERS": "ตัวช่วยดีบัก",
  "APPEND_BRACKETS_TO_LABEL": "ต่อท้ายวงเล็บเพื่อติดป้ายกำกับ",

  "PLUGINS": "ปลั๊กอิน",
  "OPEN_PLUGIN": "เปิดปลั๊กอิน...",
  "RECENT_PLUGINS": "ปลั๊กอินล่าสุด",
  "CODE_SEQUENCE_DIAGRAM": "รหัสลำดับไดอะแกรม Code",
  "MALICIOUS_CODE_SCANNER": "เครื่องสแกนรหัสที่เป็นอันตราย",
  "SHOW_MAIN_METHODS": "แสดงวิธีการหลัก",
  "SHOW_ALL_STRINGS": "แสดงสตริงทั้งหมด",
  "REPLACE_STRINGS": "แทนที่สตริง",
  "STACK_FRAMES_REMOVER": "ตัวล้างเฟรมสแต็ค",
  "ZKM_STRING_DECRYPTER": "ตัวถอดรหัสสตริง ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ตัวถอดรหัสลับ ZStringArray",
  "VIEW_ANDROID_PERMISSIONS": "View Android Permissions",
  "VIEW_MANIFEST": "View Manifest",
  "CHANGE_CLASSFILE_VERSIONS": "Change ClassFile Versions",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "ถอดประกอบ",

  "ERROR": "ผิดพลาด",
  "NEW_JAVA_PLUGIN": "New Java Plugin",
  "NEW_JAVASCRIPT_PLUGIN": "New Javascript Plugin",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "การแก้ไขที่แนะนำ: คลิกรีเฟรชคลาส หากล้มเหลวอีกครั้ง ให้ลองใช้ตัวถอดรหัสอื่น",
  "SUGGESTED_FIX_COMPILER_ERROR": "การแก้ไขที่แนะนำ: ลอง View>Pane>Krakatau>Bytecode และเปิดใช้งาน Editable",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "WARNING: No decompiler is currently selected. Try View>Pane and choose a decompiler.",
  "COMPILER_TIP": "Keep in mind most decompilers cannot produce compilable classes",
  "FIRST_OPEN_A_RESOURCE": "First open a resource inside of BCV (class, jar, zip or apk file)",
  "FIRST_OPEN_A_CLASS": "First open a classfile resource inside of BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "First view a class file inside of a tab.",
  "DRAG_CLASS_JAR": "ลาก class/jar/zip/APK/DEX ที่นี่",

  "YES": "Yes",
  "NO": "No",
  "ERROR2": "Error:",
  "PROCESS2": "Process:",
  "EXIT_VALUE_IS": "Exit Value is:",
  "JAVA_COMPILE_FAILED": "Java Compile Failed",
  "ERROR_COMPILING_CLASS": "Error compiling class",
  "COMPILER": "Keep in mind most decompilers cannot produce compilable classes",
  "SELECT_LIBRARY_FOLDER": "Select Library Folder",
  "SELECT_JAVA_RT": "Select JRE RT Jar",
  "SELECT_JAVA": "Select Java Executable",
  "SELECT_JAVAC": "Select Javac Executable",
  "SELECT_JAVA_TOOLS": "Select Java Tools Jar",
  "SELECT_PYTHON_2": "Select Python 2.7 Executable",
  "SELECT_PYTHON_3": "Select Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Or PyPy 2.7 for speed) Executable",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Or PyPy 3.x for speed) Executable",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "You need to set your Python 2.7 (or PyPy 2.7 for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "You need to set your Python 3.x (or PyPy 3.x for speed) executable path.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "You need to set your JRE RT Library.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Files\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C:/Program Files/Java/JRE_xx/bin/java.exe)",
  "JAVAC_EXECUTABLE": "Javac Executable (Requires JDK C:/Program Files/Java/JDK_xx/bin/javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C:/Program Files/Java/JDK_xx/lib/tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C:/Program Files/Java/JRE_xx/lib/rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Optional Library Folder (Compiler & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Hide bridge methods",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Hide synthetic class members",
  "DECOMPILE_INNER_CLASSES": "Decompile inner classes",
  "COLLAPSE_14_CLASS_REFERENCES": "Collapse 1.4 class references",
  "DECOMPILE_ASSERTIONS": "Decompile assertions",
  "HIDE_EMPTY_SUPER_INVOCATION": "Hide empty super invocation",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Hide empty default constructor",
  "DECOMPILE_GENERIC_SIGNATURES": "Decompile generic signatures",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Assume return not throwing exceptions",
  "DECOMPILE_ENUMERATIONS": "Decompile enumerations",
  "REMOVE_GETCLASS_INVOCATION": "Remove getClass() invocation",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Interpret int 1 as boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Allow for not set synthetic attribute",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Consider nameless types as java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Reconstruct variable names from debug info",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Remove empty exception ranges",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline finally structures",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Allow only ASCII characters in strings",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Rename ambiguous classes and class elements",

  "DECODE_ENUM_SWITCH": "Decode Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Decode String Switch",
  "ARRAYITER": "Arrayiter",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Inner Classes",
  "REMOVE_BOILER_PLATE": "Remove Boiler Plate",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Remove Inner Class Synthetics",
  "DECODE_LAMBDAS": "Decode Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift  Constructor Init",
  "REMOVE_DEAD_METHODS": "Remove Dead Methods",
  "REMOVE_BAD_GENERICS": "Remove Bad Generics",
  "SUGAR_ASSERTS": "Sugar Asserts",
  "SUGAR_BOXING": "Sugar Boxing",
  "SHOW_VERSION": "Show Version",
  "DECODE_FINALLY": "Decode Finally",
  "TIDY_MONITORS": "Tidy Monitors",
  "LENIENT": "Lenient",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Comments",
  "FORCE_TOP_SORT": "Force Top Sort",
  "FORCE_TOP_SORT_AGGRESS": "Force Top Sort Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "String Buffer",
  "STRING_BUILDER": "String Builder",
  "SILENT": "Silent",
  "RECOVER": "Recover",
  "OVERRIDE": "Override",
  "SHOW_INFERRABLE": "Show Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond Propagate",
  "HIDE_UTF": "Hide UTF",
  "HIDE_LONG_STRINGS": "Hide Long Strings",
  "COMMENT_MONITORS": "Comment Monitors",
  "ALLOW_CORRECTING": "Allow Correcting",
  "LABELLED_BLOCKS": "Labelled Blocks",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Hide Lang Imports",
  "RECOVER_TYPE_CLASH": "Recover Type Clash",
  "RECOVER_TYPE__HINTS": "Recover Type  Hints",
  "FORCE_RETURNING_IFS": "Force Returning IFs",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Always Generate Exception Variable For Catch Blocks",
  "EXCLUDE_NESTED_TYPES": "Exclude Nested Types",
  "SHOW_DEBUG_LINE_NUMBERS": "Show Debug Line Numbers",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Include Line Numbers In Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Include Error Diagnostics",
  "SHOW_SYNTHETIC_MEMBERS": "Show Synthetic Members",
  "SIMPLIFY_MEMBER_REFERENCES": "Simplify Member References",
  "MERGE_VARIABLES": "Merge Variables",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Force Explicit Type Arguments",
  "FORCE_EXPLICIT_IMPORTS": "Force Explicit Imports",
  "FLATTEN_SWITCH_BLOCKS": "Flatten Switch Blocks",
  "RETAIN_POINTLESS_SWITCHES": "Retain Pointless Switches",
  "RETAIN_REDUNDANT_CASTS": "Retain Redundant Casts",
  "UNICODE_OUTPUT_ENABLED": "Unicode Output Enabled",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Reload Resources",
  "RELOAD_RESOURCES_CONFIRM": "Are you sure you wish to reload the resources?",
  "SELECT_FILE_TITLE": "Select File or Folder to open in {BCV}",
  "SELECT_FILE_DESCRIPTION": "APKs, DEX, Class Files or Zip/Jar/War Archives",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Select External Plugin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin in js, java, python, ruby or groovy",
  "FOREIGN_LIBRARY_WARNING": "WARNING: With this being toggled off outdated libraries will NOT be removed.\n\rIt's also a security issue.\n\rONLY TURN IT OFF IF YOU KNOW WHAT YOU'RE DOING.",
  "RESET_TITLE": "{PRODUCT_NAME} - Reset Workspace",
  "RESET_CONFIRM": "Are you sure you want to reset the workspace?\n\rIt will also reset your file navigator and search.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Exit",
  "EXIT_CONFIRM": "Are you sure you want to exit?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - About - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Plugin Console",
  "CLOSE_ALL_BUT_THIS": "Close All But This",
  "CLOSE_TAB": "Close Tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Please send this error log to",
  "PLEASE_SEND_RESOURCES": "If you hold appropriate legal rights to the relevant class/jar/apk file please include that as well.",
  "ONE_PLUGIN_AT_A_TIME": "There is currently another plugin running right now, please wait for that to finish executing.",
  "ILLEGAL_ACCESS_ERROR": "Please use Java 15 or older to do this.",


  "FILES": "ไฟล์",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "ค้นหาไฟล์อย่างรวดเร็ว (ไม่มีนามสกุลไฟล์)",
  "WORK_SPACE": "พื้นที่ทำงาน",
  "EXACT": "ที่แน่นอน",
  "SEARCH": "ค้นหา",
  "SEARCH_FROM": "ค้นหาจาก:",
  "SEARCH_STRING": "สตริงการค้นหา:",
  "SEARCH_REGEX": "ค้นหา Regex:",
  "OWNER": "เจ้าของ:",
  "NAME": "ชื่อ:",
  "DESC": "เรียง:",
  "SAVE": "Save...",
  "SAVE_AS": "Save As...",
  "RESULTS": "Results",
  "REFRESH": "รีเฟรช",
  "ANNOTATION_NAME": "Annotation Name",
  "MATCH_CASE": "Match Case",
  "EXACT_PATH": "Exact Path",
  "MIN_SDK_VERSION": "Minimum SDK version",
  "PRINT_LINE_NUMBERS": "Print Line Numbers"
}

```

`src/main/resources/translations/turkish.json`:

```json
{
  "FILE": "Dosya",
  "ADD": "Ekle...",
  "NEW_WORKSPACE": "Yeni Çalışma Alanı",
  "RELOAD_RESOURCES": "Kaynakları Yeniden Yükle",
  "RUN": "Çalıştırmak",
  "OPEN": "Açık...",
  "OPEN_UNSTYLED": "Açık",
  "QUICK_OPEN": "Hızlı Aç",
  "DELETE": "Silmek",
  "NEW": "Yeni",
  "EXPAND": "Genişletmek",
  "COLLAPSE": "Çöküş",
  "COMPILE": "derlemek",
  "SAVE_AS_RUNNABLE_JAR": "Çalıştırılabilir Kavanoz Olarak Kaydet...",
  "SAVE_AS_ZIP": "Zip Olarak Kaydet...",
  "SAVE_AS_DEX": "DEX Olarak Kaydet...",
  "SAVE_AS_APK": "APK olarak kaydet...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Açılan Sınıfları Geri Derleme ve Kaydetme",
  "DECOMPILE_SAVE_ALL_CLASSES": "Tüm Sınıfları Geri Derleme ve Kaydetme",
  "RECENT_FILES": "Son Dosyalar",
  "ABOUT": "hakkında",
  "EXIT": "çıkış",

  "VIEW": "Görünüm",
  "VISUAL_SETTINGS": "Görsel ayarlar",
  "PANE_1": "Bölme 1",
  "PANE_2": "Bölme 2",
  "PANE_3": "Bölme 3",
  "NONE": "Yok",
  "EDITABLE": "Düzenlenebilir",

  "LANGUAGE": "Dil",
  "FONT_SIZE": "Yazı Boyutu",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Dosyayı Sekme Başlığında Göster",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Sekme Başlığında Adı Basitleştirin",
  "SYNCHRONIZED_VIEWING": "Senkronize Görüntüleme",
  "SHOW_CLASS_METHODS": "Sınıf Yöntemlerini Göster",

  "WINDOW_THEME": "Pencere Teması",
  "SYSTEM_THEME": "Sistem Teması",
  "DARK_THEME": "Karanlık Tema",
  "LIGHT_THEME": "Işık Tema",
  "ONE_DARK_THEME": "Bir Karanlık Tema",
  "SOLARIZED_DARK_THEME": "Solarize Karanlık Tema",
  "SOLARIZED_LIGHT_THEME": "Solarize Işık Teması",
  "HIGH_CONTRAST_DARK_THEME": "Yüksek Kontrastlı Koyu Tema",
  "HIGH_CONTRAST_LIGHT_THEME": "Yüksek Kontrastlı Işık Teması",
  "ONE_DARK": "Bir Karanlık",
  "SOLARIZED_DARK": "Solarize Karanlık",
  "SOLARIZED_LIGHT": "Solarize Işık",
  "HIGH_CONTRAST_DARK": "Yüksek Kontrastlı Koyu",
  "HIGH_CONTRAST_LIGHT": "Yüksek Kontrastlı Işık",
  "TEXT_AREA_THEME": "Metin Alanı Teması",
  "DEFAULT_RECOMMENDED_LIGHT": "Varsayılan (Önerilen Işık)",
  "THEME_MATCH": "Tema Eşleştirme (Önerilen)",
  "DARK": "Koyu (Önerilen Koyu)",
  "DARK_ALT": "Koyu-Alt",
  "DEFAULT_ALT": "Varsayılan-Alt",
  "ECLIPSE": "tutulma",
  "INTELLIJ": "akıllı",
  "VISUAL_STUDIO": "Görsel stüdyo",
  "DRUID_DARK": "Büyücü (Karanlık)",
  "MONOKAI_DARK": "Monokai (Karanlık)",

  "SETTINGS": "Ayarlar",
  "COMPILE_ON_SAVE": "Kaydettiğinizde Derleyin",
  "COMPILE_ON_REFRESH": "Yenilendiğinde Derle",
  "REFRESH_ON_VIEW_CHANGE": "Görünüm Değişikliğinde Yenile",
  "DECODE_APK_RESOURCES": "APK Kaynaklarının Kodunu Çöz",
  "APK_CONVERSION": "APK Dönüşümü",
  "APK_CONVERSION_DECODING": "APK Dönüştürme/Kod Çözme",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "canlandırmak",
  "UPDATE_CHECK": "Güncelleme kontrolü",
  "DELETE_UNKNOWN_LIBS": "Yabancı/Eski Lib'leri Sil",
  "FORCE_PURE_ASCII_AS_TEXT": "Pure Ascii'yi Metin Olarak Zorla",
  "SET_PYTHON_27_EXECUTABLE": "Python 2.7 Yürütülebilir Dosyasını Ayarla",
  "SET_PYTHON_30_EXECUTABLE": "Python 3.X Yürütülebilir Dosyasını Ayarla",
  "SET_JRE_RT_LIBRARY": "JRE RT Kitaplığını Ayarla",
  "SET_OPTIONAL_LIBRARY_FOLDER": "İsteğe Bağlı Kitaplık Klasörünü Ayarla",
  "SET_JAVAC_EXECUTABLE": "Javac Yürütülebilir Dosyasını Ayarla",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Procyon Ayarları",
  "CFR_SETTINGS": "CFR Ayarları",
  "FERNFLOWER_SETTINGS": "FernFlower Ayarları",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "EğreltiotuÇiçek",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "küçük",
  "SMALI_DEX": "Küçük/Dex",
  "HEXCODE": "altı kod",
  "BYTECODE": "bayt kodu",
  "ASM_TEXTIFY": "ASM Metinleştir",

  "BYTECODE_DECOMPILER": "Bayt Kodu Çözümleyici",
  "DEBUG_HELPERS": "Hata Ayıklama Yardımcıları",
  "APPEND_BRACKETS_TO_LABEL": "Etikete Parantez Ekle",

  "PLUGINS": "Eklentiler",
  "OPEN_PLUGIN": "Eklentiyi Aç...",
  "RECENT_PLUGINS": "Son Eklentiler",
  "CODE_SEQUENCE_DIAGRAM": "Kod Sırası Şeması",
  "MALICIOUS_CODE_SCANNER": "Kötü Amaçlı Kod Tarayıcı",
  "SHOW_MAIN_METHODS": "Ana Yöntemleri Göster",
  "SHOW_ALL_STRINGS": "Tüm Dizeleri Göster",
  "REPLACE_STRINGS": "Dizeleri Değiştir",
  "STACK_FRAMES_REMOVER": "Yığın Çerçeve Sökücü",
  "ZKM_STRING_DECRYPTER": "ZKM Dize Şifre Çözücü",
  "ALLATORI_STRING_DECRYPTER": "Allatori Dize Şifre Çözücü",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Şifre Çözücü",
  "VIEW_ANDROID_PERMISSIONS": "Android İzinlerini Görüntüle",
  "VIEW_MANIFEST": "Manifest'i Görüntüle",
  "CHANGE_CLASSFILE_VERSIONS": "ClassFile Sürümlerini Değiştirin",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "CFR Decompiler",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "JADX Decompiler",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Bayt Kodu Çözücü",
  "DISASSEMBLER": "sökücü",

  "ERROR": "Hata",
  "NEW_JAVA_PLUGIN": "Yeni Java Eklentisi",
  "NEW_JAVASCRIPT_PLUGIN": "Yeni Javascript Eklentisi",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Önerilen Düzeltme: Sınıfı yenile'ye tıklayın, tekrar başarısız olursa başka bir kod çözücü deneyin.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Önerilen Düzeltme: Görünüm>Bölme>Krakatau>Bytecode'u deneyin ve Düzenlenebilir'i etkinleştirin.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "UYARI: Şu anda hiçbir kod çözücü seçili değil. Görünüm> Bölmeyi deneyin ve bir kod çözücü seçin.",
  "COMPILER_TIP": "Çoğu kod çözücünün derlenebilir sınıflar üretemediğini unutmayın.",
  "FIRST_OPEN_A_RESOURCE": "Önce BCV içinde bir kaynak açın (sınıf, jar, zip veya apk dosyası)",
  "FIRST_OPEN_A_CLASS": "Önce BCV içinde bir sınıf dosyası kaynağı açın (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "İlk önce bir sekmenin içindeki bir sınıf dosyasını görüntüleyin.",
  "DRAG_CLASS_JAR": "Sınıfı/jar/zip/APK/DEX'i buraya sürükleyin",

  "YES": "Evet",
  "NO": "Hayır",
  "ERROR2": "Hata:",
  "PROCESS2": "süreç:",
  "EXIT_VALUE_IS": "Çıkış Değeri:",
  "JAVA_COMPILE_FAILED": "Java Derlemesi Başarısız",
  "ERROR_COMPILING_CLASS": "Sınıf derlenirken hata oluştu",
  "COMPILER": "Çoğu kod çözücünün derlenebilir sınıflar üretemediğini unutmayın.",
  "SELECT_LIBRARY_FOLDER": "Kitaplık Klasörünü Seçin",
  "SELECT_JAVA_RT": "JRE RT Kavanozunu Seçin",
  "SELECT_JAVA": "Java Yürütülebilir Dosyasını Seçin",
  "SELECT_JAVAC": "Javac Yürütülebilir Dosyasını Seçin",
  "SELECT_JAVA_TOOLS": "Java Araçları Kavanozunu Seçin",
  "SELECT_PYTHON_2": "Python 2.7 Yürütülebilir Dosyasını Seçin",
  "SELECT_PYTHON_3": "Python 3.x Yürütülebilir Dosyasını Seçin",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Veya hız için PyPy 2.7) Yürütülebilir",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Veya hız için PyPy 3.x) Yürütülebilir",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Python 2.7 (veya hız için PyPy 2.7) yürütülebilir yolunuzu ayarlamanız gerekir.",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Python 3.x (veya hız için PyPy 3.x) yürütülebilir yolunuzu ayarlamanız gerekir.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "JRE RT Kitaplığınızı ayarlamanız gerekir.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C:\\Program Dosyaları\\Java\\jre7\\lib\\rt.jar)",
  "JAVA_EXECUTABLE": "Yürütülebilir Java Dosyası (JRE C:/Program Files/Java/JRE_xx/bin/java.exe İçinde)",
  "JAVAC_EXECUTABLE": "Javac Yürütülebilir Dosyası (JDK C:/Program Files/Java/JDK_xx/bin/javac.exe gerektirir)",
  "JAVA_TOOLS_JAR": "Java Araçları Kavanozu (JDK C:/Program Files/Java/JDK_xx/lib/tools.jar İçinde)",
  "JAVA_RT_JAR": "Java RT Jar (JRE C:/Program Files/Java/JRE_xx/lib/rt.jar İçinde)",
  "OPTIONAL_LIBRARY_FOLDER": "İsteğe Bağlı Kitaplık Klasörü (Derleyici ve Krakatau)",

  "HIDE_BRIDGE_METHODS": "Köprü yöntemlerini gizle",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Sentetik sınıf üyelerini gizle",
  "DECOMPILE_INNER_CLASSES": "İç sınıfları geri derleme",
  "COLLAPSE_14_CLASS_REFERENCES": "1.4 sınıf referanslarını daralt",
  "DECOMPILE_ASSERTIONS": "iddiaları geri derleme",
  "HIDE_EMPTY_SUPER_INVOCATION": "Boş süper çağrıyı gizle",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Boş varsayılan kurucuyu gizle",
  "DECOMPILE_GENERIC_SIGNATURES": "Genel imzaları geri derleme",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "İstisnalar atmadan dönüşü varsayın",
  "DECOMPILE_ENUMERATIONS": "Numaralandırmaları geri derleme",
  "REMOVE_GETCLASS_INVOCATION": "getClass() çağrısını kaldır",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "int 1'i boolean true olarak yorumlayın",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Sentetik özniteliğin ayarlanmamasına izin ver",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "İsimsiz türleri Java.lang.Object olarak düşünün",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Hata ayıklama bilgisinden değişken adlarını yeniden oluşturun",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Boş istisna aralıklarını kaldırın",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline nihayet yapıları",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Dizelerde yalnızca ASCII karakterlerine izin ver",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Belirsiz sınıfları ve sınıf öğelerini yeniden adlandırın",

  "DECODE_ENUM_SWITCH": "Numaralandırma Anahtarını Çöz",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Dize Anahtarını Çöz",
  "ARRAYITER": "dizici",
  "COLLECTIONITER": "Koleksiyoncu",
  "INNER_CLASSES": "İç Sınıflar",
  "REMOVE_BOILER_PLATE": "Kazan Plakasını Çıkarın",
  "REMOVE_INNER_CLASS_SYNTHETICS": "İç Sınıf Sentetiklerini Kaldır",
  "DECODE_LAMBDAS": "Lambdaların kodunu çöz",
  "LIFT__CONSTRUCTOR_INIT": "Asansör Oluşturucu Başlatma",
  "REMOVE_DEAD_METHODS": "Ölü Yöntemleri Kaldır",
  "REMOVE_BAD_GENERICS": "Kötü Jenerikleri Kaldır",
  "SUGAR_ASSERTS": "Şeker İddiaları",
  "SUGAR_BOXING": "şeker boksu",
  "SHOW_VERSION": "Sürümü Göster",
  "DECODE_FINALLY": "Sonunda Kodu Çöz",
  "TIDY_MONITORS": "Düzenli Monitörler",
  "LENIENT": "Hoşgörülü",
  "DUMP_CLASSPATH": "Döküm Sınıf Yolu",
  "COMMENTS": "Yorumlar",
  "FORCE_TOP_SORT": "En Üst Sıralamayı Zorla",
  "FORCE_TOP_SORT_AGGRESS": "En İyi Sıralama Saldırısını Zorla",
  "FORCE_EXCEPTION_PRUNE": "İstisna Budayı Zorla",
  "STRING_BUFFER": "dize arabelleği",
  "STRING_BUILDER": "Dize Oluşturucu",
  "SILENT": "Sessiz",
  "RECOVER": "Kurtarmak",
  "OVERRIDE": "geçersiz kıl",
  "SHOW_INFERRABLE": "Çıkarılabilir Göster",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Kuvvet Koşulu Yayılımı",
  "HIDE_UTF": "UTF'yi gizle",
  "HIDE_LONG_STRINGS": "Uzun Dizeleri Gizle",
  "COMMENT_MONITORS": "Yorum Monitörleri",
  "ALLOW_CORRECTING": "Düzeltmeye İzin Ver",
  "LABELLED_BLOCKS": "Etiketli Bloklar",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Lang İthalatlarını Gizle",
  "RECOVER_TYPE_CLASH": "Tip Çatışmasını Kurtar",
  "RECOVER_TYPE__HINTS": "Kurtarma Türü İpuçları",
  "FORCE_RETURNING_IFS": "Geri Dönen IF'leri Zorla",
  "FOR_LOOP_AGG_CAPTURE": "Döngü AGG Yakalama için",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Yakalama Blokları İçin Daima İstisna Değişkeni Oluşturun",
  "EXCLUDE_NESTED_TYPES": "İç İçe Türleri Hariç Tut",
  "SHOW_DEBUG_LINE_NUMBERS": "Hata Ayıklama Satır Numaralarını Göster",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Bayt Koduna Satır Numaralarını Dahil Et",
  "INCLUDE_ERROR_DIAGNOSTICS": "Hata Teşhisini Dahil Et",
  "SHOW_SYNTHETIC_MEMBERS": "Sentetik Üyeleri Göster",
  "SIMPLIFY_MEMBER_REFERENCES": "Üye Referanslarını Basitleştirin",
  "MERGE_VARIABLES": "Değişkenleri Birleştir",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Açık Tür Bağımsız Değişkenlerini Zorla",
  "FORCE_EXPLICIT_IMPORTS": "Açık İthalatı Zorla",
  "FLATTEN_SWITCH_BLOCKS": "Düzleştirme Anahtar Blokları",
  "RETAIN_POINTLESS_SWITCHES": "Amaçsız Anahtarları Tut",
  "RETAIN_REDUNDANT_CASTS": "Gereksiz Yayınları Koru",
  "UNICODE_OUTPUT_ENABLED": "Unicode Çıkışı Etkin",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Kaynakları Yeniden Yükle",
  "RELOAD_RESOURCES_CONFIRM": "Kaynakları yeniden yüklemek istediğinizden emin misiniz?",
  "SELECT_FILE_TITLE": "{BCV} içinde açılacak Dosya veya Klasörü seçin",
  "SELECT_FILE_DESCRIPTION": "APK'lar, DEX, Sınıf Dosyaları veya Zip/Jar/War Arşivleri",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Harici Eklenti Seçin",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "js, java, python, ruby ​​veya groovy'de BCV Harici Eklentisi",
  "FOREIGN_LIBRARY_WARNING": "UYARI: Bu kapatıldığında, eski kitaplıklar KALDIRILMAYACAKTIR.\n\rAynı zamanda bir güvenlik sorunudur.\n\rYALNIZCA NE YAPTIĞINIZI BİLİYORSANIZ KAPATIN.",
  "RESET_TITLE": "{PRODUCT_NAME} - Çalışma Alanını Sıfırla",
  "RESET_CONFIRM": "Çalışma alanını sıfırlamak istediğinizden emin misiniz?\n\rAyrıca dosya gezgininizi ve aramanızı sıfırlar.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Çıkış",
  "EXIT_CONFIRM": "Çıkmak istediğine emin misin?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Hakkında - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Eklenti Konsolu",
  "CLOSE_ALL_BUT_THIS": "Bu hariç hepsini kapat",
  "CLOSE_TAB": "Sekmeyi Kapat",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Lütfen bu hata günlüğünü şu adrese gönderin:",
  "PLEASE_SEND_RESOURCES": "İlgili class/jar/apk dosyası için uygun yasal haklara sahipseniz lütfen bunu da ekleyin.",
  "ONE_PLUGIN_AT_A_TIME": "Şu anda çalışan başka bir eklenti var, lütfen yürütmenin bitmesini bekleyin.",
  "ILLEGAL_ACCESS_ERROR": "Bunu yapmak için lütfen Java 15 veya daha eskisini kullanın.",


  "FILES": "Dosyalar",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Hızlı dosya arama (dosya uzantısı yok)",
  "WORK_SPACE": "Çalışma Alanı",
  "EXACT": "tam",
  "SEARCH": "Arama",
  "SEARCH_FROM": "Ara:",
  "SEARCH_STRING": "Arama dizisi:",
  "SEARCH_REGEX": "Normal İfadede Ara:",
  "OWNER": "Sahip:",
  "NAME": "İsim:",
  "DESC": "Açıklama:",
  "SAVE": "Kayıt etmek...",
  "SAVE_AS": "Farklı kaydet...",
  "RESULTS": "Sonuçlar",
  "REFRESH": "Yenile",
  "ANNOTATION_NAME": "Ek Açıklama Adı",
  "MATCH_CASE": "Maç Kasası",
  "EXACT_PATH": "Tam Yol",
  "MIN_SDK_VERSION": "Minimum SDK sürümü",
  "PRINT_LINE_NUMBERS": "Satır Numaralarını Yazdır"
}

```

`src/main/resources/translations/ukrainian.json`:

```json
{
  "FILE": "Файл",
  "ADD": "Додати ...",
  "NEW_WORKSPACE": "Нова робоча область",
  "RELOAD_RESOURCES": "Перезавантажте ресурси",
  "RUN": "Біжи",
  "OPEN": "Відчинено...",
  "OPEN_UNSTYLED": "відчинено",
  "QUICK_OPEN": "Швидке відкриття",
  "DELETE": "Видалити",
  "NEW": "Новий",
  "EXPAND": "Розгорнути",
  "COLLAPSE": "Згорнути",
  "COMPILE": "Скласти",
  "SAVE_AS_RUNNABLE_JAR": "Зберегти як керовану банку ...",
  "SAVE_AS_ZIP": "Зберегти як Zip ...",
  "SAVE_AS_DEX": "Зберегти як DEX ...",
  "SAVE_AS_APK": "Зберегти як APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Декомпілювати та зберегти відкриті класи",
  "DECOMPILE_SAVE_ALL_CLASSES": "Декомпілювати та зберегти всі класи",
  "RECENT_FILES": "Останні файли",
  "ABOUT": "Про",
  "EXIT": "Вихід",

  "VIEW": "Переглянути",
  "VISUAL_SETTINGS": "Візуальні налаштування",
  "PANE_1": "Панель 1",
  "PANE_2": "Панель 2",
  "PANE_3": "Панель 3",
  "NONE": "Жоден",
  "EDITABLE": "Можна редагувати",

  "LANGUAGE": "Мову",
  "FONT_SIZE": "Розмір шрифту",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Показати файл у заголовку вкладки",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Спростіть назву в заголовку вкладки",
  "SYNCHRONIZED_VIEWING": "Синхронізоване перегляд",
  "SHOW_CLASS_METHODS": "Показати методи занять",

  "WINDOW_THEME": "Тема вікна",
  "SYSTEM_THEME": "Тема системи",
  "DARK_THEME": "Темна тема",
  "LIGHT_THEME": "Світла тема",
  "ONE_DARK_THEME": "Одна темна тема",
  "SOLARIZED_DARK_THEME": "Соляризована темна тема",
  "SOLARIZED_LIGHT_THEME": "Тема соляризованого світла",
  "HIGH_CONTRAST_DARK_THEME": "Темна тема з високим контрастом",
  "HIGH_CONTRAST_LIGHT_THEME": "Висока контрастність світлової теми",
  "ONE_DARK": "Один темний",
  "SOLARIZED_DARK": "Соляризований Темний",
  "SOLARIZED_LIGHT": "Соляризоване світло",
  "HIGH_CONTRAST_DARK": "Високий контраст Темний",
  "HIGH_CONTRAST_LIGHT": "Висококонтрастне світло",
  "TEXT_AREA_THEME": "Тема області тексту",
  "DEFAULT_RECOMMENDED_LIGHT": "За замовчуванням (рекомендоване світло)",
  "THEME_MATCH": "Відповідність теми (рекомендується)",
  "DARK": "Темний (рекомендований темний)",
  "DARK_ALT": "Темно-Альт",
  "DEFAULT_ALT": "За замовчуванням-Alt",
  "ECLIPSE": "Затьмарення",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Друїд (Темний)",
  "MONOKAI_DARK": "Монокай (темний)",

  "SETTINGS": "Налаштування",
  "COMPILE_ON_SAVE": "Складіть на Save",
  "COMPILE_ON_REFRESH": "Складіть на оновлення",
  "REFRESH_ON_VIEW_CHANGE": "Оновити при зміні подання",
  "DECODE_APK_RESOURCES": "Розшифрувати ресурси APK",
  "APK_CONVERSION": "Перетворення файлів .apk",
  "APK_CONVERSION_DECODING": "Перетворення / декодування APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Enjarify",
  "UPDATE_CHECK": "Перевірка оновлення",
  "DELETE_UNKNOWN_LIBS": "Видалити іноземні / застарілі бібліотеки",
  "FORCE_PURE_ASCII_AS_TEXT": "Форсируйте чистий Ascii як текст",
  "SET_PYTHON_27_EXECUTABLE": "Встановіть виконуваний Python 2.7",
  "SET_PYTHON_30_EXECUTABLE": "Встановіть виконуваний файл Python 3.X.",
  "SET_JRE_RT_LIBRARY": "Встановити бібліотеку JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Встановити додаткову папку бібліотеки",
  "SET_JAVAC_EXECUTABLE": "Встановити Javac Executable",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Налаштування Procyon",
  "CFR_SETTINGS": "Налаштування CFR",
  "FERNFLOWER_SETTINGS": "Налаштування FernFlower",
  "PROCYON": "Процій",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Кракатау",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Смалі",
  "SMALI_DEX": "Смалі / Декс",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Байт-код",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Декомпілятор байт-коду",
  "DEBUG_HELPERS": "Помічники з налагодження",
  "APPEND_BRACKETS_TO_LABEL": "Додайте дужки до ярлика",

  "PLUGINS": "Плагіни",
  "OPEN_PLUGIN": "Відкрити плагін ...",
  "RECENT_PLUGINS": "Останні плагіни",
  "CODE_SEQUENCE_DIAGRAM": "Діаграма послідовності коду",
  "MALICIOUS_CODE_SCANNER": "Сканер зловмисного коду",
  "SHOW_MAIN_METHODS": "Показати основні методи",
  "SHOW_ALL_STRINGS": "Показати всі рядки",
  "REPLACE_STRINGS": "Замінити рядки",
  "STACK_FRAMES_REMOVER": "Видалення кадрів стека",
  "ZKM_STRING_DECRYPTER": "ZKM String Decrypter",
  "ALLATORI_STRING_DECRYPTER": "Розшифрувач рядка Аллаторі",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Переглянути дозволи Android",
  "VIEW_MANIFEST": "Переглянути маніфест",
  "CHANGE_CLASSFILE_VERSIONS": "Змінити версії ClassFile",



  "PROCYON_DECOMPILER": "Декомпілятор проціонів",
  "CFR_DECOMPILER": "CFR-декомпілятор",
  "FERNFLOWER_DECOMPILER": "Декомпілятор FernFlower",
  "JADX_DECOMPILER": "Декомпілятор JADX",
  "JD_DECOMPILER": "Декомпілятор JD-GUI",
  "BYTECODE_DISASSEMBLER": "Розбірник байт-кодів",
  "DISASSEMBLER": "Демонтажник",

  "ERROR": "Помилка",
  "NEW_JAVA_PLUGIN": "Новий плагін Java",
  "NEW_JAVASCRIPT_PLUGIN": "Новий плагін Javascript",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Запропоноване виправлення: клацніть клас оновлення, якщо він знову не вдасться, спробуйте інший декомпілятор.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Запропоноване виправлення: Спробуйте Переглянути> Панель> Кракатау> Байт-код та увімкніть редагування.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "ПОПЕРЕДЖЕННЯ: На даний момент не обрано жодного декомпілятора. Спробуйте Переглянути> Панель та виберіть декомпілятор.",
  "COMPILER_TIP": "Майте на увазі, більшість декомпіляторів не можуть створювати компілюючі класи",
  "FIRST_OPEN_A_RESOURCE": "Спочатку відкрийте ресурс всередині BCV (клас, jar, zip або apk файл)",
  "FIRST_OPEN_A_CLASS": "Спочатку відкрийте ресурс файлу класу всередині BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Спочатку перегляньте файл класу всередині вкладки.",
  "DRAG_CLASS_JAR": "Перетягніть сюди клас / jar / zip / APK / DEX",

  "YES": "Так",
  "NO": "Немає",
  "ERROR2": "Помилка:",
  "PROCESS2": "Процес:",
  "EXIT_VALUE_IS": "Вихідне значення:",
  "JAVA_COMPILE_FAILED": "Помилка компіляції Java",
  "ERROR_COMPILING_CLASS": "Помилка компіляції класу",
  "COMPILER": "Майте на увазі, більшість декомпіляторів не можуть створювати компілюючі класи",
  "SELECT_LIBRARY_FOLDER": "Виберіть папку бібліотеки",
  "SELECT_JAVA_RT": "Виберіть JRE RT Jar",
  "SELECT_JAVA": "Виберіть Java Executable",
  "SELECT_JAVAC": "Виберіть Javac Executable",
  "SELECT_JAVA_TOOLS": "Виберіть Java Tools Jar",
  "SELECT_PYTHON_2": "Виберіть Python 2.7 Executable",
  "SELECT_PYTHON_3": "Виберіть Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (або PyPy 2.7 для швидкості) Виконуваний",
  "PYTHON_3_EXECUTABLE": "Python 3.x (або PyPy 3.x для швидкості) Виконуваний",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Вам потрібно встановити ваш виконуваний шлях до Python 2.7 (або PyPy 2.7 для швидкості).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Вам потрібно встановити ваш виконуваний шлях до Python 3.x (або PyPy 3.x для швидкості).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Вам потрібно встановити вашу бібліотеку JRE RT.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "Виконавча програма Java (усередині JRE C: / Програмні файли / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Виконуваний файл Javac (Потрібен JDK C: / Програмні файли / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "Пакет Java Tools (усередині JDK C: / Program Files / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C: / Program Files / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Додаткова папка бібліотеки (компілятор і Кракатау)",

  "HIDE_BRIDGE_METHODS": "Сховати мостові методи",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Приховати членів синтетичного класу",
  "DECOMPILE_INNER_CLASSES": "Декомпілювати внутрішні класи",
  "COLLAPSE_14_CLASS_REFERENCES": "Згорнути посилання на клас 1.4",
  "DECOMPILE_ASSERTIONS": "Декомпілювати твердження",
  "HIDE_EMPTY_SUPER_INVOCATION": "Приховати порожнє супервиклик",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Приховати порожній конструктор за замовчуванням",
  "DECOMPILE_GENERIC_SIGNATURES": "Декомпілювати загальні підписи",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Припустимо повернення, не кидаючи винятків",
  "DECOMPILE_ENUMERATIONS": "Декомпілювати перелічення",
  "REMOVE_GETCLASS_INVOCATION": "Видалити виклик getClass ()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Інтерпретуйте int 1 як логічну істину",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Дозволити не встановлений синтетичний атрибут",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Розгляньте безіменні типи як java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Відновити імена змінних з інформації про налагодження",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Видалити порожні діапазони винятків",
  "DEINLINE_FINALLY_STRUCTURES": "Deinline нарешті структури",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Дозволити лише символи ASCII у рядках",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Перейменуйте неоднозначні класи та елементи класу",

  "DECODE_ENUM_SWITCH": "Розшифрувати перемикач Enum",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Розшифрувати рядковий перемикач",
  "ARRAYITER": "Аррайтер",
  "COLLECTIONITER": "Колекціонер",
  "INNER_CLASSES": "Внутрішні класи",
  "REMOVE_BOILER_PLATE": "Зніміть пластину котла",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Видаліть синтетику внутрішнього класу",
  "DECODE_LAMBDAS": "Розшифрувати лямбди",
  "LIFT__CONSTRUCTOR_INIT": "Підніміть конструктор Init",
  "REMOVE_DEAD_METHODS": "Видаліть мертві методи",
  "REMOVE_BAD_GENERICS": "Видаліть погані дженерики",
  "SUGAR_ASSERTS": "Цукор Асерти",
  "SUGAR_BOXING": "Цукровий бокс",
  "SHOW_VERSION": "Показати версію",
  "DECODE_FINALLY": "Розшифруйте нарешті",
  "TIDY_MONITORS": "Охайні монітори",
  "LENIENT": "Поблажливий",
  "DUMP_CLASSPATH": "Скинути шлях до класу",
  "COMMENTS": "Коментарі",
  "FORCE_TOP_SORT": "Примусово сортувати за вершиною",
  "FORCE_TOP_SORT_AGGRESS": "Примусовий агресивний сорт",
  "FORCE_EXCEPTION_PRUNE": "Чорнослив для винятку сил",
  "STRING_BUFFER": "Рядковий буфер",
  "STRING_BUILDER": "Струнний конструктор",
  "SILENT": "Безмовний",
  "RECOVER": "Одужайте",
  "OVERRIDE": "Замінити",
  "SHOW_INFERRABLE": "Показувати Inferrable",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Примусове поширення",
  "HIDE_UTF": "Сховати UTF",
  "HIDE_LONG_STRINGS": "Сховати довгі струни",
  "COMMENT_MONITORS": "Монітори коментарів",
  "ALLOW_CORRECTING": "Дозволити виправлення",
  "LABELLED_BLOCKS": "Позначені блоки",
  "J14CLASSOBJ": "J14КласOBJ",
  "HIDE_LANG_IMPORTS": "Сховати імпорт язика",
  "RECOVER_TYPE_CLASH": "Відновлення типу Clash",
  "RECOVER_TYPE__HINTS": "Відновити підказки типу",
  "FORCE_RETURNING_IFS": "Примусово повернути ІФ",
  "FOR_LOOP_AGG_CAPTURE": "Для Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Завжди генеруйте змінну винятку для блоків вилову",
  "EXCLUDE_NESTED_TYPES": "Виключити вкладені типи",
  "SHOW_DEBUG_LINE_NUMBERS": "Показати номери налагоджувальних рядків",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Включіть номери рядків у байт-код",
  "INCLUDE_ERROR_DIAGNOSTICS": "Включити діагностику помилок",
  "SHOW_SYNTHETIC_MEMBERS": "Показати синтетичних членів",
  "SIMPLIFY_MEMBER_REFERENCES": "Спростіть посилання на членів",
  "MERGE_VARIABLES": "Об’єднати змінні",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Вимушувати явні аргументи типу",
  "FORCE_EXPLICIT_IMPORTS": "Примусове явне імпортування",
  "FLATTEN_SWITCH_BLOCKS": "Вирівняйте вимикачі",
  "RETAIN_POINTLESS_SWITCHES": "Зберігайте безглузді вимикачі",
  "RETAIN_REDUNDANT_CASTS": "Зберігати зайві зліпки",
  "UNICODE_OUTPUT_ENABLED": "Вихід Unicode увімкнено",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - перезавантажте ресурси",
  "RELOAD_RESOURCES_CONFIRM": "Ви впевнені, що хочете перезавантажити ресурси?",
  "SELECT_FILE_TITLE": "Виберіть файл або папку, яку потрібно відкрити в {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK-файли, файли DEX, файли класів або архіви Zip / Jar / War",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Виберіть Зовнішній плагін",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "Зовнішній плагін BCV у js, java, python, ruby ​​або groovy",
  "FOREIGN_LIBRARY_WARNING": "ПОПЕРЕДЖЕННЯ. При цьому вимикання застарілих бібліотек НЕ буде видалено.\n\rЦе також проблема безпеки.\n\rТІЛЬКИ ВИМКНУЙТЕ ЦЕ, ЯКЩО ЗНАЄТЕ, ЩО РОБИТЕ.",
  "RESET_TITLE": "{PRODUCT_NAME} - скинути робочу область",
  "RESET_CONFIRM": "Справді скинути робочу область?\n\rВін також скине ваш навігатор файлів та пошук.",
  "EXIT_TITLE": "{PRODUCT_NAME} - вихід",
  "EXIT_CONFIRM": "Ви впевнені що хочете вийти?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Про нас - {ВЕБ-САЙТ} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - консоль плагіна",
  "CLOSE_ALL_BUT_THIS": "Закрийте все, крім цього",
  "CLOSE_TAB": "Закрити вкладку",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Будь ласка, надішліть цей журнал помилок на",
  "PLEASE_SEND_RESOURCES": "Якщо ви маєте відповідні юридичні права на відповідний файл класу / jar / apk, будь ласка, включіть це також.",
  "ONE_PLUGIN_AT_A_TIME": "Зараз працює інший плагін, будь ласка, дочекайтеся його виконання.",
  "ILLEGAL_ACCESS_ERROR": "Для цього використовуйте Java 15 або старішу версію.",


  "FILES": "Файли",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Швидкий пошук файлів (без розширення файлу)",
  "WORK_SPACE": "Робочий простір",
  "EXACT": "Точно",
  "SEARCH": "Пошук",
  "SEARCH_FROM": "Шукати з:",
  "SEARCH_STRING": "Рядок пошуку:",
  "SEARCH_REGEX": "Пошук регулярних виразів:",
  "OWNER": "Власник:",
  "NAME": "Ім'я:",
  "DESC": "Desc:",
  "SAVE": "Зберегти ...",
  "SAVE_AS": "Зберегти як...",
  "RESULTS": "Результати",
  "REFRESH": "Оновити",
  "ANNOTATION_NAME": "Назва анотації",
  "MATCH_CASE": "Випадок матчів",
  "EXACT_PATH": "Точний шлях",
  "MIN_SDK_VERSION": "Мінімальна версія SDK",
  "PRINT_LINE_NUMBERS": "Друк номерів рядків"
}

```

`src/main/resources/translations/vietnamese.json`:

```json
{
  "FILE": "Tập tin",
  "ADD": "Thêm vào...",
  "NEW_WORKSPACE": "Không gian làm việc mới",
  "RELOAD_RESOURCES": "Tải lại tài nguyên",
  "RUN": "Chạy",
  "OPEN": "Mở...",
  "OPEN_UNSTYLED": "Mở",
  "QUICK_OPEN": "Mở nhanh",
  "DELETE": "Xóa bỏ",
  "NEW": "Mới mẻ",
  "EXPAND": "Mở rộng",
  "COLLAPSE": "Sự sụp đổ",
  "COMPILE": "Biên dịch",
  "SAVE_AS_RUNNABLE_JAR": "Save As Runnable Jar ...",
  "SAVE_AS_ZIP": "Lưu dưới dạng Zip ...",
  "SAVE_AS_DEX": "Lưu dưới dạng DEX ...",
  "SAVE_AS_APK": "Lưu dưới dạng APK ...",
  "DECOMPILE_SAVE_OPENED_CLASSES": "Giải mã và lưu các lớp đã mở",
  "DECOMPILE_SAVE_ALL_CLASSES": "Giải mã và lưu tất cả các lớp",
  "RECENT_FILES": "Tệp gần đây",
  "ABOUT": "Trong khoảng",
  "EXIT": "Lối ra",

  "VIEW": "Lượt xem",
  "VISUAL_SETTINGS": "Cài đặt hình ảnh",
  "PANE_1": "Ngăn 1",
  "PANE_2": "Ngăn 2",
  "PANE_3": "Ngăn 3",
  "NONE": "không ai",
  "EDITABLE": "Có thể chỉnh sửa",

  "LANGUAGE": "Ngôn ngữ",
  "FONT_SIZE": "Cỡ chữ",
  "SHOW_TAB_FILE_IN_TAB_TITLE": "Hiển thị tệp trong tiêu đề tab",
  "SIMPLIFY_NAME_IN_TAB_TITLE": "Đơn giản hóa tên trong tiêu đề tab",
  "SYNCHRONIZED_VIEWING": "Xem được đồng bộ hóa",
  "SHOW_CLASS_METHODS": "Hiển thị các phương pháp lớp học",

  "WINDOW_THEME": "Chủ đề cửa sổ",
  "SYSTEM_THEME": "Chủ đề hệ thống",
  "DARK_THEME": "Chủ đề tối",
  "LIGHT_THEME": "Chủ đề ánh sáng",
  "ONE_DARK_THEME": "Một chủ đề tối",
  "SOLARIZED_DARK_THEME": "Chủ đề tối phân cực",
  "SOLARIZED_LIGHT_THEME": "Chủ đề ánh sáng phân cực",
  "HIGH_CONTRAST_DARK_THEME": "Chủ đề tối tương phản cao",
  "HIGH_CONTRAST_LIGHT_THEME": "Chủ đề ánh sáng tương phản cao",
  "ONE_DARK": "Một bóng tối",
  "SOLARIZED_DARK": "Tối phân cực",
  "SOLARIZED_LIGHT": "Ánh sáng phân cực",
  "HIGH_CONTRAST_DARK": "Tối tương phản cao",
  "HIGH_CONTRAST_LIGHT": "Ánh sáng tương phản cao",
  "TEXT_AREA_THEME": "Chủ đề vùng văn bản",
  "DEFAULT_RECOMMENDED_LIGHT": "Mặc định (Ánh sáng được Đề xuất)",
  "THEME_MATCH": "Đối sánh chủ đề (Được đề xuất)",
  "DARK": "Tối (Đề xuất tối)",
  "DARK_ALT": "Dark-Alt",
  "DEFAULT_ALT": "Mặc định-Alt",
  "ECLIPSE": "Nhật thực",
  "INTELLIJ": "Intellij",
  "VISUAL_STUDIO": "Visual Studio",
  "DRUID_DARK": "Druid (Bóng tối)",
  "MONOKAI_DARK": "Monokai (Bóng tối)",

  "SETTINGS": "Cài đặt",
  "COMPILE_ON_SAVE": "Biên dịch khi lưu",
  "COMPILE_ON_REFRESH": "Biên dịch khi làm mới",
  "REFRESH_ON_VIEW_CHANGE": "Làm mới khi xem thay đổi",
  "DECODE_APK_RESOURCES": "Giải mã tài nguyên APK",
  "APK_CONVERSION": "Chuyển đổi APK",
  "APK_CONVERSION_DECODING": "Chuyển đổi / Giải mã APK",
  "DEX_TO_JAR": "Dex2Jar",
  "ENJARIFY": "Làm rõ",
  "UPDATE_CHECK": "Cập nhật kiểm tra",
  "DELETE_UNKNOWN_LIBS": "Xóa Lib nước ngoài / lỗi thời",
  "FORCE_PURE_ASCII_AS_TEXT": "Buộc Ascii thuần túy dưới dạng văn bản",
  "SET_PYTHON_27_EXECUTABLE": "Đặt Python 2.7 có thể thực thi",
  "SET_PYTHON_30_EXECUTABLE": "Đặt Python 3.X Executable",
  "SET_JRE_RT_LIBRARY": "Đặt Thư viện JRE RT",
  "SET_OPTIONAL_LIBRARY_FOLDER": "Đặt Thư mục Thư viện Tùy chọn",
  "SET_JAVAC_EXECUTABLE": "Đặt Javac Executable",

  "JAVA": "Java",
  "PROCYON_SETTINGS": "Cài đặt Procyon",
  "CFR_SETTINGS": "Cài đặt CFR",
  "FERNFLOWER_SETTINGS": "Cài đặt FernFlower",
  "PROCYON": "Procyon",
  "CFR": "CFR",
  "FERNFLOWER": "FernFlower",
  "KRAKATAU": "Krakatau",
  "JDGUI": "JD-GUI",
  "JADX": "JADX",
  "SMALI": "Smali",
  "SMALI_DEX": "Smali / Dex",
  "HEXCODE": "Hexcode",
  "BYTECODE": "Bytecode",
  "ASM_TEXTIFY": "ASM Textify",

  "BYTECODE_DECOMPILER": "Bytecode Decompiler",
  "DEBUG_HELPERS": "Trình trợ giúp gỡ lỗi",
  "APPEND_BRACKETS_TO_LABEL": "Nối dấu ngoặc vào nhãn",

  "PLUGINS": "bổ sung",
  "OPEN_PLUGIN": "Mở Plugin ...",
  "RECENT_PLUGINS": "Các plugin gần đây",
  "CODE_SEQUENCE_DIAGRAM": "Sơ đồ trình tự mã",
  "MALICIOUS_CODE_SCANNER": "Máy quét mã độc hại",
  "SHOW_MAIN_METHODS": "Hiển thị các phương pháp chính",
  "SHOW_ALL_STRINGS": "Hiển thị tất cả các chuỗi",
  "REPLACE_STRINGS": "Thay thế chuỗi",
  "STACK_FRAMES_REMOVER": "Stack Frames Remover",
  "ZKM_STRING_DECRYPTER": "Giải mã chuỗi ZKM",
  "ALLATORI_STRING_DECRYPTER": "Allatori String Decrypter",
  "ZSTRINGARRAY_DECRYPTER": "ZStringArray Decrypter",
  "VIEW_ANDROID_PERMISSIONS": "Xem các quyền của Android",
  "VIEW_MANIFEST": "Xem Tệp kê khai",
  "CHANGE_CLASSFILE_VERSIONS": "Thay đổi phiên bản ClassFile",



  "PROCYON_DECOMPILER": "Procyon Decompiler",
  "CFR_DECOMPILER": "Trình biên dịch CFR",
  "FERNFLOWER_DECOMPILER": "FernFlower Decompiler",
  "JADX_DECOMPILER": "Trình biên dịch JADX",
  "JD_DECOMPILER": "JD-GUI Decompiler",
  "BYTECODE_DISASSEMBLER": "Bytecode Disassembler",
  "DISASSEMBLER": "Bộ tháo rời",

  "ERROR": "lỗi",
  "NEW_JAVA_PLUGIN": "Plugin Java mới",
  "NEW_JAVASCRIPT_PLUGIN": "Plugin Javascript mới",
  "SUGGESTED_FIX_DECOMPILER_ERROR": "Cách khắc phục được đề xuất: Nhấp vào làm mới lớp, nếu nó không thành công nữa, hãy thử một trình dịch ngược khác.",
  "SUGGESTED_FIX_COMPILER_ERROR": "Cách khắc phục được đề xuất: Hãy thử View> Pane> Krakatau> Bytecode và bật Editable.",
  "SUGGESTED_FIX_NO_DECOMPILER_WARNING": "CẢNH BÁO: Hiện không có trình dịch ngược nào được chọn. Hãy thử View> Pane và chọn một trình dịch ngược.",
  "COMPILER_TIP": "Hãy nhớ rằng hầu hết các trình dịch ngược không thể tạo ra các lớp có thể biên dịch",
  "FIRST_OPEN_A_RESOURCE": "Trước tiên, hãy mở một tài nguyên bên trong BCV (tệp lớp, jar, zip hoặc apk)",
  "FIRST_OPEN_A_CLASS": "Đầu tiên, hãy mở tài nguyên classfile bên trong BCV (jar, zip, apk, dex)",
  "FIRST_VIEW_A_CLASS": "Trước tiên, hãy xem một tệp lớp bên trong một tab.",
  "DRAG_CLASS_JAR": "Kéo lớp / jar / zip / APK / DEX vào đây",

  "YES": "Đúng",
  "NO": "Không",
  "ERROR2": "Lỗi:",
  "PROCESS2": "Quá trình:",
  "EXIT_VALUE_IS": "Giá trị Thoát là:",
  "JAVA_COMPILE_FAILED": "Biên dịch Java không thành công",
  "ERROR_COMPILING_CLASS": "Lỗi biên dịch lớp",
  "COMPILER": "Hãy nhớ rằng hầu hết các trình dịch ngược không thể tạo ra các lớp có thể biên dịch",
  "SELECT_LIBRARY_FOLDER": "Chọn Thư mục Thư viện",
  "SELECT_JAVA_RT": "Chọn JRE RT Jar",
  "SELECT_JAVA": "Chọn Java Executable",
  "SELECT_JAVAC": "Chọn Javac Executable",
  "SELECT_JAVA_TOOLS": "Chọn Jar công cụ Java",
  "SELECT_PYTHON_2": "Chọn Python 2.7 Có thể thực thi",
  "SELECT_PYTHON_3": "Chọn Python 3.x Executable",
  "PYTHON_2_EXECUTABLE": "Python 2.7 (Hoặc PyPy 2.7 cho tốc độ)",
  "PYTHON_3_EXECUTABLE": "Python 3.x (Hoặc PyPy 3.x cho tốc độ)",
  "YOU_NEED_TO_SET_YOUR_PYTHON_2_PATH": "Bạn cần đặt đường dẫn thực thi Python 2.7 (hoặc PyPy 2.7 cho tốc độ).",
  "YOU_NEED_TO_SET_YOUR_PYTHON_3_PATH": "Bạn cần đặt đường dẫn thực thi Python 3.x (hoặc PyPy 3.x cho tốc độ).",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_A": "Bạn cần đặt Thư viện JRE RT của mình.",
  "YOU_NEED_TO_SET_YOUR_JAVA_RT_PATH_B": "(C: \\ Program Files \\ Java \\ jre7 \\ lib \\ rt.jar)",
  "JAVA_EXECUTABLE": "Java Executable (Inside Of JRE C: / Program Files / Java / JRE_xx / bin / java.exe)",
  "JAVAC_EXECUTABLE": "Javac Executable (Yêu cầu JDK C: / Program Files / Java / JDK_xx / bin / javac.exe)",
  "JAVA_TOOLS_JAR": "Java Tools Jar (Inside Of JDK C: / Program Files / Java / JDK_xx / lib / tools.jar)",
  "JAVA_RT_JAR": "Java RT Jar (Inside Of JRE C: / Program Files / Java / JRE_xx / lib / rt.jar)",
  "OPTIONAL_LIBRARY_FOLDER": "Thư mục Thư viện Tùy chọn (Trình biên dịch & Krakatau)",

  "HIDE_BRIDGE_METHODS": "Ẩn các phương pháp cầu nối",
  "HIDE_SYNTHETIC_CLASS_MEMBERS": "Ẩn các thành viên lớp tổng hợp",
  "DECOMPILE_INNER_CLASSES": "Giải mã các lớp bên trong",
  "COLLAPSE_14_CLASS_REFERENCES": "Thu gọn tham chiếu lớp 1.4",
  "DECOMPILE_ASSERTIONS": "Giải mã xác nhận",
  "HIDE_EMPTY_SUPER_INVOCATION": "Ẩn lời gọi siêu trống rỗng",
  "HIDE_EMPTY_DEFAULT_CONSTRUCTOR": "Ẩn hàm tạo mặc định trống",
  "DECOMPILE_GENERIC_SIGNATURES": "Giải mã chữ ký chung",
  "ASSUME_RETURN_NOT_THROWING_EXCEPTIONS": "Giả sử trả về không ném ra các ngoại lệ",
  "DECOMPILE_ENUMERATIONS": "Giải mã các bảng kê",
  "REMOVE_GETCLASS_INVOCATION": "Xóa lệnh gọi getClass ()",
  "INTERPRET_INT_1_AS_BOOLEAN_TRUE": "Giải thích int 1 dưới dạng boolean true",
  "ALLOW_FOR_NOT_SET_SYNTHETIC_ATTRIBUTE": "Cho phép không đặt thuộc tính tổng hợp",
  "CONSIDER_NAMELESS_TYPES_AS_JAVALANGOBJECT": "Hãy coi các kiểu không tên là java.lang.Object",
  "RECONSTRUCT_VARIABLE_NAMES_FROM_DEBUG_INFO": "Tạo lại tên biến từ thông tin gỡ lỗi",
  "REMOVE_EMPTY_EXCEPTION_RANGES": "Xóa các phạm vi ngoại lệ trống",
  "DEINLINE_FINALLY_STRUCTURES": "Cấu trúc cuối cùng Deinline",
  "ALLOW_ONLY_ASCII_CHARACTERS_IN_STRINGS": "Chỉ cho phép các ký tự ASCII trong chuỗi",
  "RENAME_AMBIGUOUS_CLASSES_AND_CLASS_ELEMENTS": "Đổi tên các lớp và phần tử lớp không rõ ràng",

  "DECODE_ENUM_SWITCH": "Giải mã Enum Switch",
  "SUGARENUMS": "SugarEnums",
  "DECODE_STRING_SWITCH": "Giải mã công tắc chuỗi",
  "ARRAYITER": "Dấu mảng",
  "COLLECTIONITER": "Collectioniter",
  "INNER_CLASSES": "Lớp bên trong",
  "REMOVE_BOILER_PLATE": "Loại bỏ tấm lò hơi",
  "REMOVE_INNER_CLASS_SYNTHETICS": "Xóa lớp tổng hợp bên trong",
  "DECODE_LAMBDAS": "Giải mã Lambdas",
  "LIFT__CONSTRUCTOR_INIT": "Lift Constructor Init",
  "REMOVE_DEAD_METHODS": "Loại bỏ các phương pháp chết",
  "REMOVE_BAD_GENERICS": "Loại bỏ các gen xấu",
  "SUGAR_ASSERTS": "Cảnh báo đường",
  "SUGAR_BOXING": "Đấm bốc đường",
  "SHOW_VERSION": "Hiển thị phiên bản",
  "DECODE_FINALLY": "Giải mã cuối cùng",
  "TIDY_MONITORS": "Màn hình ngăn nắp",
  "LENIENT": "Hòa nhã",
  "DUMP_CLASSPATH": "Dump Classpath",
  "COMMENTS": "Bình luận",
  "FORCE_TOP_SORT": "Buộc sắp xếp hàng đầu",
  "FORCE_TOP_SORT_AGGRESS": "Buộc sắp xếp hàng đầu Aggress",
  "FORCE_EXCEPTION_PRUNE": "Force Exception Prune",
  "STRING_BUFFER": "Bộ đệm chuỗi",
  "STRING_BUILDER": "Trình tạo chuỗi",
  "SILENT": "Im lặng",
  "RECOVER": "Bình phục",
  "OVERRIDE": "Ghi đè",
  "SHOW_INFERRABLE": "Hiển thị có thể suy luận",
  "AEXAGG": "Aexagg",
  "FORCE_COND_PROPAGATE": "Force Cond tuyên truyền",
  "HIDE_UTF": "Ẩn UTF",
  "HIDE_LONG_STRINGS": "Ẩn chuỗi dài",
  "COMMENT_MONITORS": "Nhận xét theo dõi",
  "ALLOW_CORRECTING": "Cho phép sửa chữa",
  "LABELLED_BLOCKS": "Các khối được gắn nhãn",
  "J14CLASSOBJ": "J14ClassOBJ",
  "HIDE_LANG_IMPORTS": "Ẩn nhập khẩu Lang",
  "RECOVER_TYPE_CLASH": "Khôi phục loại đụng độ",
  "RECOVER_TYPE__HINTS": "Gợi ý về loại khôi phục",
  "FORCE_RETURNING_IFS": "Buộc trả lại IF",
  "FOR_LOOP_AGG_CAPTURE": "For Loop AGG Capture",

  "ALWAYS_GENERATE_EXCEPTION_VARIABLE_FOR_CATCH_BLOCKS": "Luôn tạo biến ngoại lệ cho các khối bắt",
  "EXCLUDE_NESTED_TYPES": "Loại trừ các loại lồng nhau",
  "SHOW_DEBUG_LINE_NUMBERS": "Hiển thị số dòng gỡ lỗi",
  "INCLUDE_LINE_NUMBERS_IN_BYTECODE": "Bao gồm số dòng trong Bytecode",
  "INCLUDE_ERROR_DIAGNOSTICS": "Bao gồm chẩn đoán lỗi",
  "SHOW_SYNTHETIC_MEMBERS": "Hiển thị các thành viên tổng hợp",
  "SIMPLIFY_MEMBER_REFERENCES": "Đơn giản hóa việc tham khảo thành viên",
  "MERGE_VARIABLES": "Hợp nhất các biến",
  "FORCE_EXPLICIT_TYPE_ARGUMENTS": "Buộc các đối số loại rõ ràng",
  "FORCE_EXPLICIT_IMPORTS": "Buộc nhập khẩu rõ ràng",
  "FLATTEN_SWITCH_BLOCKS": "Làm phẳng các khối công tắc",
  "RETAIN_POINTLESS_SWITCHES": "Giữ lại các thiết bị chuyển mạch không điểm",
  "RETAIN_REDUNDANT_CASTS": "Giữ lại các Cast dự phòng",
  "UNICODE_OUTPUT_ENABLED": "Đã bật đầu ra Unicode",


  "RELOAD_RESOURCES_TITLE": "{PRODUCT_NAME} - Tải lại tài nguyên",
  "RELOAD_RESOURCES_CONFIRM": "Bạn có chắc chắn muốn tải lại các tài nguyên không?",
  "SELECT_FILE_TITLE": "Chọn Tệp hoặc Thư mục để mở trong {BCV}",
  "SELECT_FILE_DESCRIPTION": "APK, DEX, Tệp lớp hoặc Lưu trữ Zip / Jar / War",
  "SELECT_EXTERNAL_PLUGIN_TITLE": "Chọn Plugin bên ngoài",
  "SELECT_EXTERNAL_PLUGIN_DESCRIPTION": "BCV External Plugin trong js, java, python, ruby ​​hoặc groovy",
  "FOREIGN_LIBRARY_WARNING": "CẢNH BÁO: Với việc này, các thư viện lỗi thời sẽ KHÔNG bị xóa.\n\rĐây cũng là một vấn đề bảo mật.\n\rCHỈ TẮT NẾU BẠN BIẾT BẠN ĐANG LÀM GÌ.",
  "RESET_TITLE": "{PRODUCT_NAME} - Đặt lại Không gian làm việc",
  "RESET_CONFIRM": "Bạn có chắc chắn muốn đặt lại không gian làm việc không?\n\rNó cũng sẽ đặt lại trình điều hướng tệp và tìm kiếm của bạn.",
  "EXIT_TITLE": "{PRODUCT_NAME} - Thoát",
  "EXIT_CONFIRM": "Bạn có chắc bạn muốn thoát?",
  "ABOUT_TITLE": "{PRODUCT_NAME} - Giới thiệu - {WEBSITE} | {TBC}",
  "PLUGIN_CONSOLE_TITLE": "{PRODUCT_NAME} - Bảng điều khiển plugin",
  "CLOSE_ALL_BUT_THIS": "Đóng tất cả trừ cái này",
  "CLOSE_TAB": "Đóng tab",
  "PLEASE_SEND_THIS_ERROR_LOG_TO": "Vui lòng gửi nhật ký lỗi này tới",
  "PLEASE_SEND_RESOURCES": "Nếu bạn nắm giữ các quyền hợp pháp thích hợp đối với tệp class / jar / apk liên quan, vui lòng bao gồm cả quyền đó.",
  "ONE_PLUGIN_AT_A_TIME": "Hiện tại có một plugin khác đang chạy ngay bây giờ, vui lòng đợi plugin đó hoàn tất quá trình thực thi.",
  "ILLEGAL_ACCESS_ERROR": "Vui lòng sử dụng Java 15 trở lên để thực hiện việc này.",


  "FILES": "Các tập tin",
  "QUICK_FILE_SEARCH_NO_FILE_EXTENSION": "Tìm kiếm tệp nhanh (không có phần mở rộng tệp)",
  "WORK_SPACE": "Không gian làm việc",
  "EXACT": "Chính xác",
  "SEARCH": "Tìm kiếm",
  "SEARCH_FROM": "Tìm kiếm từ:",
  "SEARCH_STRING": "Chuỗi tìm kiếm:",
  "SEARCH_REGEX": "Tìm kiếm Regex:",
  "OWNER": "Chủ nhân:",
  "NAME": "Tên:",
  "DESC": "Mô tả:",
  "SAVE": "Tiết kiệm...",
  "SAVE_AS": "Lưu thành...",
  "RESULTS": "Các kết quả",
  "REFRESH": "Làm tươi",
  "ANNOTATION_NAME": "Tên chú thích",
  "MATCH_CASE": "Trường hợp phù hợp",
  "EXACT_PATH": "Đường dẫn chính xác",
  "MIN_SDK_VERSION": "Phiên bản SDK tối thiểu",
  "PRINT_LINE_NUMBERS": "In số dòng"
}

```