Project Path: arc_gmh5225_EAC_sn7m984k

Source Tree:

```txt
arc_gmh5225_EAC_sn7m984k
├── EAC-Reversal-main
│   ├── drivers.cpp
│   ├── gameprocess.cpp
│   ├── hwid.cpp
│   ├── injection.cpp
│   ├── integrity.cpp
│   ├── misc.cpp
│   ├── modules.cpp
│   └── processes.cpp
├── EAC_SDK
│   ├── SDK
│   │   ├── Bin
│   │   │   ├── EOSSDK-Win32-Shipping.dll
│   │   │   ├── EOSSDK-Win64-Shipping.dll
│   │   │   ├── x64
│   │   │   │   └── xaudio2_9redist.dll
│   │   │   └── x86
│   │   │       └── xaudio2_9redist.dll
│   │   ├── Lib
│   │   │   ├── EOSSDK-Win32-Shipping.lib
│   │   │   └── EOSSDK-Win64-Shipping.lib
│   │   ├── Tools
│   │   │   ├── EOSBootstrapper.exe
│   │   │   ├── EOSBootstrapperTool.exe
│   │   │   ├── EOS_AntiCheatTools-mac-x64-2.0.5.zip
│   │   │   ├── EOS_AntiCheatTools-win32-x64-2.0.5.zip
│   │   │   └── EOS_FileDecryptionTool.exe
│   │   └── include
│   │       ├── eos_achievements.h
│   │       ├── eos_achievements_types.h
│   │       ├── eos_achievements_types_deprecated.inl
│   │       ├── eos_anticheatclient.h
│   │       ├── eos_anticheatclient_types.h
│   │       ├── eos_anticheatclient_types_deprecated.inl
│   │       ├── eos_anticheatcommon_types.h
│   │       ├── eos_anticheatserver.h
│   │       ├── eos_anticheatserver_types.h
│   │       ├── eos_auth.h
│   │       ├── eos_auth_types.h
│   │       ├── eos_auth_types_deprecated.inl
│   │       ├── eos_base.h
│   │       ├── eos_common.h
│   │       ├── eos_connect.h
│   │       ├── eos_connect_types.h
│   │       ├── eos_custominvites.h
│   │       ├── eos_custominvites_types.h
│   │       ├── eos_ecom.h
│   │       ├── eos_ecom_types.h
│   │       ├── eos_friends.h
│   │       ├── eos_friends_types.h
│   │       ├── eos_init.h
│   │       ├── eos_integratedplatform.h
│   │       ├── eos_integratedplatform_types.h
│   │       ├── eos_kws.h
│   │       ├── eos_kws_types.h
│   │       ├── eos_leaderboards.h
│   │       ├── eos_leaderboards_types.h
│   │       ├── eos_leaderboards_types_deprecated.inl
│   │       ├── eos_lobby.h
│   │       ├── eos_lobby_types.h
│   │       ├── eos_logging.h
│   │       ├── eos_metrics.h
│   │       ├── eos_metrics_types.h
│   │       ├── eos_mods.h
│   │       ├── eos_mods_types.h
│   │       ├── eos_p2p.h
│   │       ├── eos_p2p_types.h
│   │       ├── eos_platform_prereqs.h
│   │       ├── eos_playerdatastorage.h
│   │       ├── eos_playerdatastorage_types.h
│   │       ├── eos_presence.h
│   │       ├── eos_presence_types.h
│   │       ├── eos_progressionsnapshot.h
│   │       ├── eos_progressionsnapshot_types.h
│   │       ├── eos_reports.h
│   │       ├── eos_reports_types.h
│   │       ├── eos_result.h
│   │       ├── eos_rtc.h
│   │       ├── eos_rtc_admin.h
│   │       ├── eos_rtc_admin_types.h
│   │       ├── eos_rtc_audio.h
│   │       ├── eos_rtc_audio_types.h
│   │       ├── eos_rtc_audio_types_deprecated.inl
│   │       ├── eos_rtc_data.h
│   │       ├── eos_rtc_data_types.h
│   │       ├── eos_rtc_types.h
│   │       ├── eos_sanctions.h
│   │       ├── eos_sanctions_types.h
│   │       ├── eos_sdk.h
│   │       ├── eos_sessions.h
│   │       ├── eos_sessions_types.h
│   │       ├── eos_stats.h
│   │       ├── eos_stats_types.h
│   │       ├── eos_titlestorage.h
│   │       ├── eos_titlestorage_types.h
│   │       ├── eos_types.h
│   │       ├── eos_ui.h
│   │       ├── eos_ui_buttons.h
│   │       ├── eos_ui_keys.h
│   │       ├── eos_ui_types.h
│   │       ├── eos_userinfo.h
│   │       ├── eos_userinfo_types.h
│   │       ├── eos_version.h
│   │       ├── linux
│   │       │   ├── eos_Linux.h
│   │       │   └── eos_Linux_base.h
│   │       ├── mac
│   │       │   ├── eos_Mac.h
│   │       │   └── eos_Mac_base.h
│   │       └── windows
│   │           ├── eos_Windows.h
│   │           └── eos_Windows_base.h
│   ├── Samples
│   │   ├── Achievements
│   │   │   ├── Achievements.vcxproj
│   │   │   ├── Achievements.vcxproj.filters
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── Source
│   │   │   │   ├── Achievements.cpp
│   │   │   │   ├── Achievements.h
│   │   │   │   ├── AchievementsDefinitionsDialog.cpp
│   │   │   │   ├── AchievementsDefinitionsDialog.h
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   └── settings.manifest
│   │   ├── AntiCheat
│   │   │   ├── Client
│   │   │   │   ├── AntiCheat.vcxproj
│   │   │   │   ├── AntiCheat.vcxproj.filters
│   │   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   │   ├── Source
│   │   │   │   │   ├── AntiCheatClient.cpp
│   │   │   │   │   ├── AntiCheatClient.h
│   │   │   │   │   ├── AntiCheatDialog.cpp
│   │   │   │   │   ├── AntiCheatDialog.h
│   │   │   │   │   ├── AntiCheatNetworkTransport.cpp
│   │   │   │   │   ├── AntiCheatNetworkTransport.h
│   │   │   │   │   ├── Game.cpp
│   │   │   │   │   ├── Game.h
│   │   │   │   │   ├── Game.icns
│   │   │   │   │   ├── Level.h
│   │   │   │   │   ├── Menu.cpp
│   │   │   │   │   ├── Menu.h
│   │   │   │   │   ├── SampleConstants.h
│   │   │   │   │   ├── TCPClient.cpp
│   │   │   │   │   ├── TCPClient.h
│   │   │   │   │   ├── game.ico
│   │   │   │   │   └── resource.rc
│   │   │   │   └── settings.manifest
│   │   │   └── Server
│   │   │       ├── AntiCheatServer.vcxproj
│   │   │       ├── AntiCheatServer.vcxproj.filters
│   │   │       ├── Source
│   │   │       │   ├── AntiCheatNetworkTransport.cpp
│   │   │       │   ├── AntiCheatNetworkTransport.h
│   │   │       │   ├── AntiCheatServer.cpp
│   │   │       │   ├── AntiCheatServer.h
│   │   │       │   ├── EosSdk.cpp
│   │   │       │   ├── EosSdk.h
│   │   │       │   ├── Game.icns
│   │   │       │   ├── Main
│   │   │       │   │   ├── MacMain.h
│   │   │       │   │   ├── MacMain.mm
│   │   │       │   │   ├── Main.cpp
│   │   │       │   │   ├── Main.h
│   │   │       │   │   └── ServerMain.cpp
│   │   │       │   ├── NonCopyable.h
│   │   │       │   ├── SampleConstants.h
│   │   │       │   ├── TCPClient.cpp
│   │   │       │   ├── TCPClient.h
│   │   │       │   ├── game.ico
│   │   │       │   ├── pch.cpp
│   │   │       │   └── pch.h
│   │   │       └── cmake
│   │   │           ├── FindSDL2.cmake
│   │   │           └── FindSDL2NET.cmake
│   │   ├── AuthAndFriends
│   │   │   ├── AuthAndFriends.vcxproj
│   │   │   ├── AuthAndFriends.vcxproj.filters
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── Source
│   │   │   │   ├── CustomInviteReceivedDialog.cpp
│   │   │   │   ├── CustomInviteReceivedDialog.h
│   │   │   │   ├── CustomInviteSendDialog.cpp
│   │   │   │   ├── CustomInviteSendDialog.h
│   │   │   │   ├── CustomInvites.cpp
│   │   │   │   ├── CustomInvites.h
│   │   │   │   ├── CustomInvitesDialog.cpp
│   │   │   │   ├── CustomInvitesDialog.h
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   └── settings.manifest
│   │   ├── Leaderboard
│   │   │   ├── Leaderboard.vcxproj
│   │   │   ├── Leaderboard.vcxproj.filters
│   │   │   ├── Source
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Leaderboard.cpp
│   │   │   │   ├── Leaderboard.h
│   │   │   │   ├── LeaderboardDialog.cpp
│   │   │   │   ├── LeaderboardDialog.h
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   └── settings.manifest
│   │   ├── Lobbies
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── Lobbies.vcxproj
│   │   │   ├── Lobbies.vcxproj.filters
│   │   │   ├── Source
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Lobbies.cpp
│   │   │   │   ├── Lobbies.h
│   │   │   │   ├── LobbiesDialog.cpp
│   │   │   │   ├── LobbiesDialog.h
│   │   │   │   ├── LobbyInviteReceivedDialog.cpp
│   │   │   │   ├── LobbyInviteReceivedDialog.h
│   │   │   │   ├── LobbyMemberTableRowView.cpp
│   │   │   │   ├── LobbyMemberTableRowView.h
│   │   │   │   ├── LobbySearchResultTableRowView.cpp
│   │   │   │   ├── LobbySearchResultTableRowView.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── NewLobbyDialog.cpp
│   │   │   │   ├── NewLobbyDialog.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   └── settings.manifest
│   │   ├── Mods
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── Mods.vcxproj
│   │   │   ├── Mods.vcxproj.filters
│   │   │   ├── Source
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── Mods.cpp
│   │   │   │   ├── Mods.h
│   │   │   │   ├── ModsDialog.cpp
│   │   │   │   ├── ModsDialog.h
│   │   │   │   ├── ModsTableDialog.cpp
│   │   │   │   ├── ModsTableDialog.h
│   │   │   │   ├── ModsTableRowView.cpp
│   │   │   │   ├── ModsTableRowView.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   └── settings.manifest
│   │   ├── P2PNAT
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── P2PNAT.vcxproj
│   │   │   ├── P2PNAT.vcxproj.filters
│   │   │   ├── Source
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── P2PNAT.cpp
│   │   │   │   ├── P2PNAT.h
│   │   │   │   ├── P2PNATDialog.cpp
│   │   │   │   ├── P2PNATDialog.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   └── settings.manifest
│   │   ├── PlayerDataStorage
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── PlayerDataStorage.vcxproj
│   │   │   ├── PlayerDataStorage.vcxproj.filters
│   │   │   ├── Source
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── NewFileDialog.cpp
│   │   │   │   ├── NewFileDialog.h
│   │   │   │   ├── PlayerDataStorage.cpp
│   │   │   │   ├── PlayerDataStorage.h
│   │   │   │   ├── PlayerDataStorageDialog.cpp
│   │   │   │   ├── PlayerDataStorageDialog.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   └── settings.manifest
│   │   ├── Samples.props
│   │   ├── Samples.sln
│   │   ├── SessionMatchmaking
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── SessionMatchmaking.vcxproj
│   │   │   ├── SessionMatchmaking.vcxproj.filters
│   │   │   ├── Source
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── NewSessionDialog.cpp
│   │   │   │   ├── NewSessionDialog.h
│   │   │   │   ├── RequestToJoinSessionReceivedDialog.cpp
│   │   │   │   ├── RequestToJoinSessionReceivedDialog.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── SessionInviteReceivedDialog.cpp
│   │   │   │   ├── SessionInviteReceivedDialog.h
│   │   │   │   ├── SessionMatchmaking.cpp
│   │   │   │   ├── SessionMatchmaking.h
│   │   │   │   ├── SessionMatchmakingDialog.cpp
│   │   │   │   ├── SessionMatchmakingDialog.h
│   │   │   │   ├── SessionsTableRowView.cpp
│   │   │   │   ├── SessionsTableRowView.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   └── settings.manifest
│   │   ├── Store
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── Source
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── OfferInfo.cpp
│   │   │   │   ├── OfferInfo.h
│   │   │   │   ├── OfferList.cpp
│   │   │   │   ├── OfferList.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── Store.cpp
│   │   │   │   ├── Store.h
│   │   │   │   ├── StoreDialog.cpp
│   │   │   │   ├── StoreDialog.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   ├── Store.vcxproj
│   │   │   ├── Store.vcxproj.filters
│   │   │   └── settings.manifest
│   │   ├── TitleStorage
│   │   │   ├── CopyAssetsToBuilds.bat
│   │   │   ├── CopyAssetsToBuilds.sh
│   │   │   ├── CopyAssetsToBuildsSDL.bat
│   │   │   ├── Source
│   │   │   │   ├── Game.cpp
│   │   │   │   ├── Game.h
│   │   │   │   ├── Game.icns
│   │   │   │   ├── Level.h
│   │   │   │   ├── Menu.cpp
│   │   │   │   ├── Menu.h
│   │   │   │   ├── SampleConstants.h
│   │   │   │   ├── TitleStorage.cpp
│   │   │   │   ├── TitleStorage.h
│   │   │   │   ├── TitleStorageDialog.cpp
│   │   │   │   ├── TitleStorageDialog.h
│   │   │   │   ├── game.ico
│   │   │   │   └── resource.rc
│   │   │   ├── TitleStorage.vcxproj
│   │   │   ├── TitleStorage.vcxproj.filters
│   │   │   └── settings.manifest
│   │   └── Voice
│   │       ├── Client
│   │       │   ├── CopyAssetsToBuilds.bat
│   │       │   ├── CopyAssetsToBuilds.sh
│   │       │   ├── CopyAssetsToBuildsSDL.bat
│   │       │   ├── Source
│   │       │   │   ├── Game.cpp
│   │       │   │   ├── Game.h
│   │       │   │   ├── Game.icns
│   │       │   │   ├── Level.h
│   │       │   │   ├── Menu.cpp
│   │       │   │   ├── Menu.h
│   │       │   │   ├── SampleConstants.h
│   │       │   │   ├── Voice.cpp
│   │       │   │   ├── Voice.h
│   │       │   │   ├── VoiceDialog.cpp
│   │       │   │   ├── VoiceDialog.h
│   │       │   │   ├── VoiceRoomMemberTableRowView.cpp
│   │       │   │   ├── VoiceRoomMemberTableRowView.h
│   │       │   │   ├── VoiceSetupDialog.cpp
│   │       │   │   ├── VoiceSetupDialog.h
│   │       │   │   ├── game.ico
│   │       │   │   └── resource.rc
│   │       │   ├── Voice.vcxproj
│   │       │   ├── Voice.vcxproj.filters
│   │       │   └── settings.manifest
│   │       └── Server
│   │           ├── Source
│   │           │   ├── ApiParams.cpp
│   │           │   ├── ApiParams.h
│   │           │   ├── Game.icns
│   │           │   ├── Main
│   │           │   │   ├── MacMain.h
│   │           │   │   ├── MacMain.mm
│   │           │   │   ├── Main.cpp
│   │           │   │   ├── Main.h
│   │           │   │   └── ServerMain.cpp
│   │           │   ├── NonCopyable.h
│   │           │   ├── SampleConstants.h
│   │           │   ├── VoiceApi.cpp
│   │           │   ├── VoiceApi.h
│   │           │   ├── VoiceHost.cpp
│   │           │   ├── VoiceHost.h
│   │           │   ├── VoiceRequest.cpp
│   │           │   ├── VoiceRequest.h
│   │           │   ├── VoiceRequestJoin.cpp
│   │           │   ├── VoiceRequestJoin.h
│   │           │   ├── VoiceRequestKickUser.cpp
│   │           │   ├── VoiceRequestKickUser.h
│   │           │   ├── VoiceRequestMuteUser.cpp
│   │           │   ├── VoiceRequestMuteUser.h
│   │           │   ├── VoiceSdk.cpp
│   │           │   ├── VoiceSdk.h
│   │           │   ├── VoiceSession.cpp
│   │           │   ├── VoiceSession.h
│   │           │   ├── VoiceUser.h
│   │           │   ├── game.ico
│   │           │   ├── pch.cpp
│   │           │   └── pch.h
│   │           ├── VoiceServer.vcxproj
│   │           └── VoiceServer.vcxproj.filters
│   └── ThirdPartyNotices
│       └── ThirdPartySoftwareNotice.txt
├── EasyAntiCheat.sys
│   ├── cheatpages.c
│   ├── disk.c
│   ├── dispatchhook.c
│   ├── dr.c
│   ├── driver.c
│   ├── handles.c
│   ├── hiddenprocess.c
│   ├── hwid.c
│   ├── kernelpatch.c
│   ├── mac.c
│   ├── physmem.c
│   ├── pooltags.c
│   ├── process.c
│   ├── servicetable.c
│   ├── suspiciousmodules.c
│   ├── systemthread.c
│   ├── tdl.c
│   └── vm.asm
└── README.md

```

`EAC-Reversal-main/drivers.cpp`:

```cpp
char EAC::Callbacks::SomeDriverChecks()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  pOutputResult = 0;
  v14 = -5772;
  pCheckDriverDispatch = 0;
  v13[0] = -683422989;
  v15[0] = 0i64;
  v1 = 0i64;
  LOWORD(v15[1]) = 0;
  v2 = -685061481;
  v13[1] = -2105495067;
  v21 = v13;
  v22 = v15;
  v3 = 8i64;
  do
  {
    *(v22 + v1 * 4) = v21[v1] ^ v2;
    ++v1;
    v2 = __ROL4__(((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13) ^ (32 * (((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13))), 1);
  }
  while ( v1 < 2 );
  v21 = v13;
  v22 = v15;
  do
  {
    v4 = v2;
    v2 >>= 8;
    *(v22 + v3) = *(v21 + v3) ^ v4;
    ++v3;
  }
  while ( v3 < 0xA );
  EAC::Memory::memset(&nDriverCTLMinusAddress, 0, 0x108ui64);
  EAC::Memory::InitializeUnicodeStringWithCString(v16, v15);
  pDriverObject = EAC::Memory::GetDriverObject(v16);
  pDriverObject_1 = pDriverObject;
  if ( pDriverObject )
  {
    pCheckDriverDispatch = EAC::Callbacks::CheckDriverDispatch(
                             pDriverObject,
                             v6,
                             &nDriverCTLMinusAddress,
                             &pOutputResult);
    ObfDereferenceObject(pDriverObject_1);
    nDetectionResult = pOutputResult;
  }
  else
  {
    nDetectionResult = 1;
  }
  for ( i = 0i64; i < 256; ++i )
  {
    if ( !a3_8[i] )
      break;
  }
  pAllocated = EAC::Memory::ExAllocatePoolWithRandomTag2(i + 0xA);
  pAllocated_1 = pAllocated;
  if ( pAllocated )                             // send driver information to server aswell?
  {
    EAC::Memory::memset(pAllocated, 0, i + 0xA);
    pAllocated_1->nDriverCTLMinusAddress = nDriverCTLMinusAddress;
    pAllocated_1->dword5 = a3_4;
    pAllocated_1->nDetectionResult = nDetectionResult;
    if ( i )
      EAC::Memory::memmove(&pAllocated_1->oword9, a3_8, i);
    if ( i != 0xFFFFFFFFFFFFFFF6ui64 )
    {
      EAC::Callbacks::ReportViolation(0x125F58F6i64, pAllocated_1, (i + 0xA));
FREE_POOL_LABEL:
      EAC::Memory::ExFreePool(pAllocated_1);
      goto END_RET_LABEL;
    }
  }
  EAC::Callbacks::ReportViolation(0x125F58F6i64, 0i64, 0i64);
  if ( pAllocated_1 )
    goto FREE_POOL_LABEL;
END_RET_LABEL:
  memset(v15, 0, 0xAui64);
  return pCheckDriverDispatch;
}

char __fastcall EAC::Callbacks::CheckDriverDispatch(_DRIVER_OBJECT *pDriverObject, __int64 a2, struct_a3 *a3, _DWORD *pOutDetectionResult)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  bIsOutsideDriverBounds = 0;
  if ( !pDriverObject )
  {
    if ( pOutDetectionResult )
      *pOutDetectionResult = 2;
    return 0;
  }
  pAddressOfDeviceCTLMJ = pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL];
  if ( !pAddressOfDeviceCTLMJ )
  {
    if ( pOutDetectionResult )
      *pOutDetectionResult = 4;
    return 0;
  }
  v8 = EAC::Memory::GetRunningModules();
  v9 = v8;
  if ( !v8 )
  {
    if ( pOutDetectionResult )
      *pOutDetectionResult = 5;
    return 0;
  }
  v11 = 0;
  if ( *v8 )
  {
    while ( 1 )
    {
      v12 = 0x128i64 * v11;
      nAddrOfModule = *(v12 + v8 + 24);
      if ( nAddrOfModule >= MmSystemRangeStart
        && pAddressOfDeviceCTLMJ >= nAddrOfModule
        && pAddressOfDeviceCTLMJ <= nAddrOfModule + *(v12 + v8 + 32) )
      {
        break;
      }
      if ( ++v11 >= *v8 )                       // driver majorfunction was in bounds, we can just leave now.
        goto GOTO_END_OF_FN;
    }
    bIsOutsideDriverBounds = 1;
    if ( a3 )
    {
      v14 = 0i64;
      a3->dword0 = pAddressOfDeviceCTLMJ - nAddrOfModule;
      v15 = &v9[v12 + 48];
      if ( !v15 )
        goto LABEL_34;
      do
      {
        if ( !*(v15 + v14) )
          break;
        ++v14;
      }
      while ( v14 < 0x100 );
      v16 = 0xFFi64;
      if ( v14 < 0xFF )
      {
LABEL_34:
        v16 = 0i64;
        if ( v15 )
        {
          do
          {
            if ( !*(v15 + v16) )
              break;
            ++v16;
          }
          while ( v16 < 0x100 );
        }
      }
      EAC::Memory::memmove(&a3->oword8, v15, v16);
      *(&a3->oword8 + v16) = 0;
      a3->dword4 = *&v9[v12 + 32];
    }
    if ( pOutDetectionResult )
      *pOutDetectionResult = 7;
  }
GOTO_END_OF_FN:
  EAC::Memory::ExFreePool(v9);
  if ( !bIsOutsideDriverBounds && pOutDetectionResult )
    *pOutDetectionResult = 6;
  return bIsOutsideDriverBounds;
}

__int64 __fastcall EAC::Callbacks::DetectProcessHackerDriver(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rsi
  unsigned __int8 *v4; // rdi
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rbp
  bool i; // cf
  ULONG nTimeStamp; // ecx
  unsigned int v10; // [rsp+40h] [rbp+8h] BYREF
  IMAGE_NT_HEADERS64 *pImage; // [rsp+48h] [rbp+10h] BYREF

  v10 = 0;
  v3 = a2 & 0xFFFFFFFFFFFFF000ui64;
  if ( a1 < MmSystemRangeStart
    || (a1 & 0xFFFFFFFFFFFFF000ui64) != a1
    || !v3
    || ((qword_140073200 ^ a1) & 0xFFFFFFFF00000000ui64) != 0 )
  {
    return 0i64;
  }
  v4 = EAC::Memory::ExAllocatePoolWithRandomTag2(4096i64);
  if ( v4 )
  {
    v5 = a1 + v3;
    v6 = a1;
    for ( i = a1 < v5; i && !v10; i = v6 < v5 )
    {
      if ( EAC::Imports::MmCopyMemory(v6, 0x1000ui64, v4) == 4096 )
      {
        sub_14000F6DC(v4, 4096i64, sub_14003F8D8, &v10);
        if ( v6 == a1 )
        {
          if ( EAC::Memory::GetPEHeader(v4, 0x1000ui64, 0i64, &pImage) )
          {
            if ( pImage->FileHeader.NumberOfSections == 7
              && pImage->OptionalHeader.AddressOfEntryPoint == 0x9064
              && pImage->OptionalHeader.SizeOfImage == 0xB000 )
            {
              nTimeStamp = pImage->FileHeader.TimeDateStamp;
              if ( nTimeStamp == 0x56F975FA || nTimeStamp == 0x57089DA8 )
              {
                v10 = 0;
                break;
              }
            }
          }
          if ( !v10 )
            v10 = sub_14003FBB4(v4);
        }
      }
      v6 += 4096i64;
    }
    EAC::Memory::ExFreePool(v4);
  }
  return v10;
}

__int64 __fastcall EAC::Callbacks::FindProcessHackerDriverFile(_FLT_CALLBACK_DATA *a1, __int64 a2)
{
  unsigned int v4; // ebx
  PFLT_IO_PARAMETER_BLOCK v5; // rdx
  SIZE_T v6; // rsi
  PVOID v7; // r14
  PFLT_IO_PARAMETER_BLOCK v8; // rdx
  __int128 FileInformation; // [rsp+50h] [rbp-38h] BYREF
  __int64 v11; // [rsp+60h] [rbp-28h]
  ULONG LengthReturned; // [rsp+90h] [rbp+8h] BYREF
  union _LARGE_INTEGER ByteOffset; // [rsp+A8h] [rbp+20h] BYREF

  v11 = 0i64;
  v4 = 1;
  FileInformation = 0i64;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a1->Iopb->MajorFunction == 255 && !KeGetCurrentIrql() && FltGetRequestorProcess(a1) == PsInitialSystemProcess )
      {
        v5 = a1->Iopb;
        if ( v5->Parameters.Read.Length == 1
          && (v5->Parameters.AcquireForSectionSynchronization.PageProtection & 0xF0) != 0
          && FltQueryInformationFile(
               *(a2 + 24),
               v5->TargetFileObject,
               &FileInformation,
               0x18u,
               FileStandardInformation,
               &LengthReturned) >= 0
          && LengthReturned == 24 )
        {
          v6 = *(&FileInformation + 1);
          if ( *(&FileInformation + 1) <= 0xFFFFFFFFi64 )
          {
            if ( *(&FileInformation + 1) > 0x800000 )
              v6 = 0x800000i64;
            v7 = FltAllocatePoolAlignedWithTag(*(a2 + 24), NonPagedPool, v6, 'godW');
            if ( v7 )
            {
              v8 = a1->Iopb;
              ByteOffset.QuadPart = 0i64;
              if ( FltReadFile(*(a2 + 24), v8->TargetFileObject, &ByteOffset, v6, v7, 4u, &LengthReturned, 0i64, 0i64) >= 0
                && EAC::Callbacks::IsFileProcessHackerDriver(v7, LengthReturned) )
              {
                a1->IoStatus.Status = 0xC0000022;
                v4 = 4;
              }
              FltFreePoolAlignedWithTag(*(a2 + 24), v7, 'godW');
            }
          }
        }
      }
    }
  }
  return v4;
}

__int64 __fastcall EAC::Callbacks::IsFileProcessHackerDriver(unsigned __int8 *a1, unsigned __int64 a2)
{
  __int64 v4; // rcx
  __int64 result; // rax
  ULONG v6; // ecx
  unsigned int v7; // [rsp+30h] [rbp+8h] BYREF
  IMAGE_NT_HEADERS64 *v8; // [rsp+40h] [rbp+18h] BYREF

  v7 = 0;
  if ( !a1 || !a2 )
    return 0i64;
  sub_14000F6DC(a1, a2, sub_14003F8D8, &v7);
  result = v7;
  if ( !v7 )
  {
    result = EAC::Memory::IncreaseImageSizeWeird(v4, a1, a2);
    v7 = result;
    if ( !result )
    {
      result = sub_14003FE78(a1, a2);
      v7 = result;
    }
  }
  if ( result == 9 )
  {
    if ( !EAC::Memory::GetPEHeader(a1, 0x1000ui64, 0i64, &v8) )
      return v7;
    if ( v8->FileHeader.NumberOfSections != 7 )
      return v7;
    if ( v8->OptionalHeader.AddressOfEntryPoint != 0x9064 )
      return v7;
    if ( v8->OptionalHeader.SizeOfImage != 0xB000 )
      return v7;
    v6 = v8->FileHeader.TimeDateStamp;
    if ( v6 != 0x56F975FA && v6 != 0x57089DA8 )
      return v7;
    return 0i64;
  }
  return result;
}

__int64 __fastcall EAC::Callbacks::MoreDriverChecks(_OWORD *a1)
{
  unsigned int v2; // ebx
  unsigned int *v3; // rax
  unsigned int *v4; // rsi
  unsigned int v5; // ebp
  __int64 v6; // rdi
  unsigned __int64 v7; // rax
  char *v8; // rdx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rcx
  __int64 v11; // r8
  char v12; // dl
  _BYTE *v13; // rax
  __int64 v14; // rcx

  v2 = 0;
  KeQueryTimeIncrement();
  v3 = EAC::Memory::GetRunningModules();
  v4 = v3;
  if ( !v3 )
    goto LABEL_35;
  v5 = 0;
  if ( *v3 )
  {
    do
    {
      if ( v2 )
        break;
      v6 = &v4[74 * v5 + 2];
      v2 = EAC::Callbacks::DetectProcessHackerDriver(*(v6 + 16), *(v6 + 24));
      if ( v2 || (v2 = EAC::Memory::GetSomeFilePEHeaderInfo(v6), v2 != 22) )
      {
        if ( v2 == 5 )
        {
          v10 = 0i64;
          v11 = v6 + *(v6 + 38);
          v12 = *(v11 + 40);
          v13 = (v11 + 40);
          if ( v12 )
          {
            do
            {
              ++v13;
              ++v10;
            }
            while ( *v13 );
            if ( v10 >= 16 && v12 == 'p' )
            {
              v14 = 1i64;
              while ( (*(v14 + v11 + 40) - 48) <= 9u )
              {
                if ( ++v14 >= 12 )
                {
                  v2 = 0;
                  break;
                }
              }
            }
          }
        }
      }
      else if ( v6 != 0xFFFFFFFFFFFFFFD8ui64 && a1 )
      {
        v7 = 0i64;
        v8 = (v6 + *(v6 + 38) + 40i64);
        if ( v8 )
        {
          while ( v8[v7] )
          {
            if ( ++v7 >= 256 )
            {
              if ( v7 < 0x104 )
                break;
              v9 = 260i64;
              goto LABEL_16;
            }
          }
        }
        v9 = 0i64;
        if ( v8 )
        {
          do
          {
            if ( !v8[v9] )
              break;
            ++v9;
          }
          while ( v9 < 0x100 );
        }
LABEL_16:
        EAC::Memory::memmove(a1, v8, v9);
      }
      ++v5;
    }
    while ( v5 < *v4 );
  }
  EAC::Memory::ExFreePool(v4);
  if ( !v2 )
  {
LABEL_35:
    if ( EAC::Callbacks::CheckForBlacklistedDriverNames() )
    {
      v2 = 18;
    }
    else if ( EAC::Callbacks::GetDriverAttributesFileList() )
    {
      v2 = 7;
    }
  }
  return v2;
}

__int64 __fastcall EAC::Callbacks::AddDriverHashToServerList(__int64 BaseAddress, unsigned __int64 ImageLength, __int64 DriverInstance, __int64 *ChangedPartList, _DWORD *a5)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v31 = ImageLength;
  v30 = BaseAddress;
  v7 = ImageLength;
  v8 = BaseAddress;
  v9 = -1073741271;
  if ( !KeGetCurrentIrql() )
  {
    if ( BaseAddress )
    {
      if ( ImageLength )
      {
        if ( DriverInstance )
        {
          v10 = *(DriverInstance + 16);
          if ( v10 )
          {
            if ( *(DriverInstance + 24)
              && v10 >= MmSystemRangeStart
              && ChangedPartList
              && a5
              && EAC::Memory::IsWithinMemoryConstraint(DriverInstance, v8)
              && EAC::Memory::IsWithinMemoryConstraint(v11, v8 + v7) )
            {
              *ChangedPartList = 0i64;
              *a5 = 0;
              v12 = EAC::Memory::ExAllocatePoolWithRandomTag2(8 * (v7 >> 12) + 8);
              *ChangedPartList = v12;
              if ( !v12 )
                return v9;
              if ( KeGetCurrentIrql() <= 1u )
              {
                ExAcquireFastMutex(&stru_1400732D0);
                if ( !EAC::Memory::HashDatabaseAllocated && !EAC::Globals::HasInitHash )
                {
                  v13 = EAC::Memory::ExAllocatePoolWithRandomTag2(24576i64);
                  EAC::Memory::HashDatabase = v13;
                  if ( v13 )
                  {
                    EAC::Memory::HashDatabaseAllocated = 1;
                    memset(v13, 0, 0x6000ui64);
                  }
                }
                ExReleaseFastMutex(&stru_1400732D0);
                if ( EAC::Memory::HashDatabaseAllocated )
                {
                  v14 = EAC::Memory::CRC32((DriverInstance + 40), 0x100u, 0);
                  driverHash = 0i64;
                  ExAcquireFastMutex(&stru_1400732D0);
                  if ( EAC::Memory::HashDatabaseAllocated )
                  {
                    v16 = 0i64;
                    if ( EAC::Memory::NumberOfBytes )
                    {
                      v17 = EAC::Memory::HashDatabase + 4;
                      while ( *v17 != v14 )
                      {
                        ++v16;
                        v17 += 6;
                        if ( v16 >= EAC::Memory::NumberOfBytes )
                          goto LABEL_32;
                      }
                      driverHash = EAC::Memory::ExAllocatePoolWithRandomTag2(24i64);
                      if ( driverHash )
                      {
                        v18 = EAC::Memory::HashDatabase;
                        v19 = 3 * v16;
                        *driverHash = *(EAC::Memory::HashDatabase + 8 * v19);
                        *(driverHash + 16) = v18[v19 + 2];
                        v20 = EAC::Memory::ExAllocatePoolWithRandomTag2(4i64 * HIDWORD(v18[v19 + 1]));
                        *(driverHash + 16) = v20;
                        if ( v20 )
                        {
                          EAC::Memory::memmove(
                            v20,
                            *(EAC::Memory::HashDatabase + v19 + 2),
                            4i64 * *(EAC::Memory::HashDatabase + 2 * v19 + 3));
                          if ( *(driverHash + 12) )
                          {
                            v21 = 0i64;
                            do
                            {
                              *(*(driverHash + 16) + 4 * v21) ^= *driverHash;
                              v21 = (v21 + 1);
                            }
                            while ( v21 < *(driverHash + 12) );
                          }
                        }
                        else
                        {
                          EAC::Memory::ExFreePool(driverHash);
                          driverHash = 0i64;
                        }
                      }
                    }
                  }
LABEL_32:
                  ExReleaseFastMutex(&stru_1400732D0);
                  if ( driverHash )
                  {
LABEL_43:
                    v27 = EAC::Memory::GetDriverHash(driverHash, v8, v7, *(DriverInstance + 16), ChangedPartList, a5);
                    v28 = *(driverHash + 16);
                    v9 = v27 == 0 ? 0xC0000005 : 0;
                    if ( v28 )
                      EAC::Memory::ExFreePool(v28);
                    EAC::Memory::ExFreePool(driverHash);
                    if ( (v9 & 0x80000000) == 0 && *a5 )
                      return v9;
                    goto LABEL_47;
                  }
                  driverHash = EAC::Memory::HashDriver(v14, DriverInstance);
                  if ( driverHash )
                  {
                    ExAcquireFastMutex(&stru_1400732D0);
                    if ( EAC::Memory::HashDatabaseAllocated && EAC::Memory::NumberOfBytes < 1024 )
                    {
                      v22 = EAC::Memory::HashDatabase;
                      v23 = 3i64 * EAC::Memory::NumberOfBytes;
                      *(EAC::Memory::HashDatabase + 8 * v23) = *driverHash;
                      v22[v23 + 2] = *(driverHash + 16);
                      v24 = EAC::Memory::ExAllocatePoolWithRandomTag2(4i64 * *(driverHash + 12));
                      v25 = EAC::Memory::NumberOfBytes;
                      *(EAC::Memory::HashDatabase + 3 * EAC::Memory::NumberOfBytes + 2) = v24;
                      if ( v24 )
                      {
                        EAC::Memory::memmove(v24, *(driverHash + 16), 4i64 * *(driverHash + 12));
                        if ( HIDWORD(v22[v23 + 1]) )
                        {
                          v26 = 0i64;
                          do
                          {
                            *(v22[v23 + 2] + 4 * v26) ^= LODWORD(v22[v23]);
                            v26 = (v26 + 1);
                          }
                          while ( v26 < HIDWORD(v22[v23 + 1]) );
                        }
                        EAC::Memory::NumberOfBytes = v25 + 1;
                      }
                      v8 = v30;
                      v7 = v31;
                    }
                    ExReleaseFastMutex(&stru_1400732D0);
                    goto LABEL_43;
                  }
                  v9 = 0xC0000123;
                }
              }
LABEL_47:
              EAC::Memory::ExFreePool(*ChangedPartList);
              return v9;
            }
          }
        }
      }
    }
  }
  return 0xC000000Di64;
}

_QWORD *__fastcall EAC::Memory::HashDriver(int a1, __int64 a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = *(a2 + 40);
  v37 = 0;
  v3 = *(a2 + 56);
  v4 = 0i64;
  v32[0] = v2;
  v7 = *(a2 + 72);
  v32[1] = v3;
  v8 = *(a2 + 88);
  v32[2] = v7;
  v9 = *(a2 + 104);
  v32[3] = v8;
  v10 = *(a2 + 120);
  v32[4] = v9;
  v11 = *(a2 + 136);
  v32[5] = v10;
  v32[6] = v11;
  v32[7] = *(a2 + 152);
  v12 = *(a2 + 280);
  v13 = *(a2 + 184);
  v32[8] = *(a2 + 168);
  v14 = *(a2 + 200);
  v32[9] = v13;
  v15 = *(a2 + 216);
  v32[10] = v14;
  v16 = *(a2 + 232);
  v32[11] = v15;
  v17 = *(a2 + 248);
  v32[12] = v16;
  v18 = *(a2 + 264);
  v32[13] = v17;
  v32[14] = v18;
  v33 = v12;
  v34 = *(a2 + 288);
  v35 = *(a2 + 292);
  v36 = *(a2 + 294);
  v30[1] = v32;
  v19 = -1i64;
  do
    ++v19;
  while ( *(v32 + v19) );
  LOWORD(v30[0]) = v19;
  WORD1(v30[0]) = v19 + 1;
  if ( EAC::Memory::CreateUnicodeString(v31, v30) >= 0 )
  {
    v20 = EAC::Memory::IsFileValidPEImage(v31, *(a2 + 16), &v38, 1);
    v21 = v20;
    if ( v20 )
    {
      v22 = 0i64;
      v23 = EAC::Memory::GetSectionSize(v20);
      v24 = v38 % v23;
      v25 = v38 / v23;
      if ( v38 / v23 )
      {
        v22 = EAC::Memory::ExAllocatePoolWithRandomTag2(24i64);
        if ( v22 )
        {
          v26 = EAC::Memory::ExAllocatePoolWithRandomTag2(4i64 * v25);
          v22[2] = v26;
          if ( v26 )
          {
            *(v22 + 1) = a1;
            *v22 = EAC::Memory::GenerateSeed(0, -1);
            *(v22 + 2) = v23;
            *(v22 + 3) = v25;
            do
            {
              v27 = EAC::Memory::CRC32(&v21[v23 * v4], v23, 0);
              LODWORD(v4) = v4 + 1;
              *(v28 + v22[2]) = v27;
            }
            while ( v4 < v25 );
          }
          else
          {
            EAC::Memory::ExFreePool(v22);
            v22 = 0i64;
          }
        }
      }
      v4 = v22;
      sub_14003CCAC(v21, v24);
    }
    EAC::Memory::FreeUnicdeString(v31);
  }
  return v4;
}

LONG_PTR __fastcall EAC::Callbacks::ScanForKernelPatches(__int64 a1, __int64 a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v4 = 0;
  m_bHasNTOSKrnlBeenPatched = EAC::Callbacks::CheckForNTOSKRNLPatches() - 1;
  if ( !m_bHasNTOSKrnlBeenPatched )
  {
    v4 = 0xC0020007;
    goto LABEL_35;
  }
  if ( m_bHasNTOSKrnlBeenPatched == 1 )
  {
    v4 = 0xC0020008;
    goto LABEL_35;
  }
  if ( MEMORY[0xFFFFF7800000026C] <= 6u && (MEMORY[0xFFFFF7800000026C] != 6 || (MEMORY[0xFFFFF78000000270] - 2) > 1) )
    goto LABEL_28;
  if ( !EAC::Memory::GetBootGUID(v38, v41) )
  {
    EAC::Callbacks::ReportViolation_1(a2, 0x5AADB103i64, 0i64, 0i64, 0i64);
LABEL_28:
    sub_14002F998(a2, 0x40010006i64);
    v4 = sub_14004D884(a1, a2);
    goto LABEL_29;
  }
  if ( v39 )
  {
    strcpy(v23, "5Ê\\\x1Bê8L");
    *&v44[48] = 0i64;
    *&v44[56] = 0;
    v6 = -1286774945;
    v24 = 80942024;
    v7 = 0i64;
    v25 = 594688901;
    v26 = -299880827;
    v27 = -1561828364;
    v28 = -1767145028;
    v29 = -1192192300;
    v30 = -526128710;
    v31 = 1008280262;
    v32 = -1032869015;
    v33 = 1233558148;
    v34 = -2057461693;
    v35 = 1825154181;
    v36 = -2016214440;
    *v44 = 0i64;
    *&v44[16] = 0i64;
    *&v44[32] = 0i64;
    do
    {
      v6 = __ROL4__(214013 * v6 + 2531011, 4);
      *&v44[v7] = *&v23[v7] ^ v6;
      v7 += 4i64;
    }
    while ( v7 < 0x3C );
    v8 = 1;
    if ( !EAC::Memory::CompareUnicodeStr(v38, v44) )
      goto LABEL_15;
    v37[0] = 1666580416;
    *&v43[48] = 0i64;
    *&v43[56] = 0;
    v9 = -1709524677;
    v37[1] = -1558651321;
    v37[2] = 629101256;
    v10 = 0i64;
    v37[3] = 467525598;
    v37[4] = -1984057362;
    v37[5] = 736416474;
    v37[6] = -1549857426;
    v37[7] = -1801439344;
    v37[8] = 431986060;
    v37[9] = -1755171940;
    v37[10] = -958271565;
    v37[11] = 1854764083;
    v37[12] = -693829820;
    v37[13] = -1894837076;
    v37[14] = 529568623;
    *v43 = 0i64;
    *&v43[16] = 0i64;
    *&v43[32] = 0i64;
    do
    {
      v9 = __ROL4__(((v9 ^ (v9 >> 7)) << 9) ^ v9 ^ (v9 >> 7) ^ ((((v9 ^ (v9 >> 7)) << 9) ^ v9 ^ (v9 >> 7)) >> 13), 4);
      *&v43[v10 * 4] = v37[v10] ^ v9;
      ++v10;
    }
    while ( v10 < 15 );
    v8 = 3;
    if ( EAC::Memory::CompareUnicodeStr(v38, v43) )
    {
      LOBYTE(v4) = 1;
    }
    else
    {
LABEL_15:
      if ( (v8 & 2) == 0 )
      {
LABEL_17:
        memset(v44, 0, sizeof(v44));
        EAC::Memory::FreeUnicdeString(v38);
        v4 = v4 != 0 ? 0xC0020010 : 0;
        goto LABEL_18;
      }
    }
    memset(v43, 0, sizeof(v43));
    goto LABEL_17;
  }
LABEL_18:
  if ( v42 )
  {
    v21[0] = -437452254;
    v22 = 25715;
    v21[1] = 991072209;
    *&v40[1] = 0i64;
    v11 = 0i64;
    WORD4(v40[1]) = 0;
    v12 = -442957236;
    v21[2] = 55889785;
    v21[3] = 1113584501;
    v21[4] = -1296637238;
    v13 = 24i64;
    v21[5] = 799280214;
    v40[0] = 0i64;
    do
    {
      v14 = v21[v11] ^ v12;
      v12 = __ROL4__(1140671485 * v12 + 12820163, 1);
      *(v40 + v11 * 4) = v14;
      ++v11;
    }
    while ( v11 < 6 );
    do
    {
      v15 = v12;
      v12 >>= 8;
      *(v40 + v13) = *(v21 + v13) ^ v15;
      ++v13;
    }
    while ( v13 < 0x1A );
    v16 = EAC::Memory::CompareUnicodeStr(v41, v40);
    memset(v40, 0, 0x1Aui64);
    if ( v16 )
      v4 = 0xC0020011;
    EAC::Memory::FreeUnicdeString(v41);
  }
  if ( !v4 )
    goto LABEL_28;
LABEL_29:
  if ( v4 != 0x40031000 )
  {
LABEL_35:
    v19 = v4;
    v18 = a2;
    goto LABEL_36;
  }
  sub_140025304(a2);
  v17 = sub_140009F70(a2);
  v18 = a2;
  if ( !v17 )
  {
    v19 = 3221356569i64;
LABEL_36:
    EAC::Callbacks::ReportViolation_0(v18, v19);
    return sub_140027958();
  }
  sub_14002F6A8(a2, 0x40031000);
  return sub_140027958();
}

__int64 EAC::Callbacks::CheckForNTOSKRNLPatches()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v0 = 0i64;
  LODWORD(FileSize) = 0;
  v1 = 2;
  ntoskrnlBase = EAC::Memory::GetNTOSKRNLBaseAddress();
  if ( ntoskrnlBase && EAC::Memory::GetNTOSKRNLPath(ModulePath, 1) )
  {
    if ( MEMORY[0xFFFFF7800000026C] <= 6u && (MEMORY[0xFFFFF7800000026C] != 6 || (MEMORY[0xFFFFF78000000270] - 2) > 1) )
      goto LABEL_10;
    v7[0] = 1035157922;
    v7[1] = -1211973253;
    v7[2] = 890527115;
    v7[3] = -1604919530;
    v7[4] = 335976341;
    v7[5] = 768738782;
    v7[6] = 1965411501;
    v7[7] = 387677515;
    v7[8] = -584117672;
    v7[9] = 323241621;
    v7[10] = -1563280376;
    v7[11] = 2025074343;
    v7[12] = 2050208706;
    v7[13] = 239808795;
    v7[14] = 1411383000;
    v7[15] = -198881325;
    v7[16] = 331163443;
    EAC::Memory::memset(Dst, 0, 0x44ui64);
    v3 = 276658416;
    v13 = v7;
    v14 = Dst;
    do
    {
      v3 = ~(((v3 ^ (v3 << 13)) >> 7) ^ v3 ^ (v3 << 13) ^ ((((v3 ^ (v3 << 13)) >> 7) ^ v3 ^ (v3 << 13)) << 17));
      *(v14->m128_i32 + v0) = *(v13 + v0) ^ v3;
      v0 += 4i64;
    }
    while ( v0 < 0x44 );
    LOBYTE(v0) = 1;
    if ( EAC::Memory::CompareUnicodeStr(ModulePath, Dst) )// ntoskrnl.exe
    {
      v4 = 1;
    }
    else
    {
LABEL_10:
      v4 = 0;
      if ( (v0 & 1) == 0 )
        goto LABEL_13;
    }
    memset(Dst, 0, 0x44ui64);
    if ( v4 )
    {
      v1 = 1;
LABEL_26:
      EAC::Memory::FreeUnicdeString(ModulePath);
      return v1;
    }
LABEL_13:
    if ( EAC::Memory::ForceReadFile(ModulePath, &pAllocatedHeap, &FileSize) )
    {
      pAllocatedHeapAddr = pAllocatedHeap;
      if ( FileSize >= 0x1000 )
        v1 = !EAC::Memory::GetPEHeader(ntoskrnlBase, 0x1000ui64, &FileSize, &MemoryHeader)
          || !EAC::Memory::GetPEHeader(pAllocatedHeapAddr, 0x1000ui64, &FileSize, &DiskHeader)
          || MemoryHeader->FileHeader.NumberOfSections != DiskHeader->FileHeader.NumberOfSections
          || MemoryHeader->FileHeader.TimeDateStamp != DiskHeader->FileHeader.TimeDateStamp
          || MemoryHeader->OptionalHeader.AddressOfEntryPoint != DiskHeader->OptionalHeader.AddressOfEntryPoint
          || MemoryHeader->OptionalHeader.CheckSum != DiskHeader->OptionalHeader.CheckSum
          || MemoryHeader->OptionalHeader.SizeOfImage != DiskHeader->OptionalHeader.SizeOfImage;
      if ( pAllocatedHeapAddr )
        EAC::Memory::ExFreePool(pAllocatedHeapAddr);
    }
    goto LABEL_26;
  }
  return v1;
}


```

`EAC-Reversal-main/gameprocess.cpp`:

```cpp
void __fastcall EAC::Callbacks::ScanGameProcess(ULONG64 *a1, char a2, __int64 a3, int a4, int a5, int a6, int a7)
{
  int v7; // er8
  ULONG64 v8; // rdx

  if ( (a2 & 1) != 0 )
  {
    EAC::Callbacks::CheckForManualMappedModule(a1);
  }
  else
  {
    if ( (a2 & 4) != 0 )
    {
      v7 = *(*a1 + 26) >> 14;
      LOBYTE(v7) = (*(*a1 + 26) & 0x4000) != 0;
      LODWORD(v8) = 0;
    }
    else
    {
      v8 = a1[1];
      v7 = 0;
    }
    (sub_14001A790)(a1, v8, v7, a4, a5, a6, a7);
  }
}

void __fastcall EAC::Callbacks::ProtectGameProcess(unsigned int *a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = 0;
  v68 = 0;
  v3 = 0i64;
  v4 = 0i64;
  v58[0] = 0;
  KeQueryTimeIncrement();
  if ( !a1 || *a1 == 197 )
    return;
  v5 = EAC::Memory::ExAllocatePoolWithRandomTag2(0x4000i64);
  v62 = v5;
  if ( !v5 )
    goto LABEL_85;
  v3 = EAC::Memory::ExAllocatePoolWithRandomTag2(1024i64);
  v63 = v3;
  if ( !v3 )
    goto LABEL_85;
  v6 = EAC::Memory::ExAllocatePoolWithRandomTag2(0x8000i64);
  v4 = v6;
  v64 = v6;
  if ( !v6 )
    goto LABEL_85;
  v59 = v6 + 2;
  v61 = v6 + 0x8000;
  if ( !EAC::Callbacks::KeStackAttachProcess(*(a1 + 1), v67) )
    goto LABEL_83;
  for ( i = 0i64; !*(a1 + 544) && EAC::Imports::NtQueryVirtualMemory(-1i64, i, 0i64, &i, 48i64); i += v54 )
  {
    v7 = (v54 + 4095) & 0xFFFFFFFFFFFFF000ui64;
    if ( !v7 )
      v7 = 4096i64;
    v54 = v7;
    v8 = v53;
    if ( v53 != i )
      goto LABEL_19;
    if ( v57 == 0x1000000 )
    {
      if ( !v53 || !EAC::Memory::PebImageByBaseWin64(v53) && !EAC::Memory::PebImageByBaseWow64(v8) )
      {
        v9 = EAC::Imports::GetProcessBaseAddress(*(a1 + 1));
        if ( v53 != v9 )
        {
          sub_140031F70(a1, &i);
          goto LABEL_35;
        }
      }
LABEL_19:
      if ( v57 == 0x1000000 && (v56 & 0x100) != 0 )
      {
        EAC::Callbacks::DetectLoadedModulesInGame(a1, 0x342B6272u, v53, 0i64);
        v34 = -1969993559;
        v35 = -1144243536;
        v36 = 242064136;
        v37 = 187676638;
        v38 = -1991878171;
        v39 = 96452294;
        v40 = -149557856;
        v41 = -694104463;
        v42 = -1557300779;
        v43 = -566847724;
        v44 = 510674766;
        v45 = 839459207;
        v46 = -379320832;
        v47 = 1465384362;
        v48 = 969356546;
        v49 = 1556836777;
        v50 = 307426473;
        v10 = v2 | 1;
        v12 = 0;
        if ( EAC::Memory::DecryptStr16(&v34, v66) )
        {
          v11 = *(a1 + 67);
          if ( v11 )
          {
            if ( !*(v11 + 32) )
              v12 = 1;
          }
        }
        v68 = v10 & 0xFFFFFFFE;
        memset(v66, 0, 0x44ui64);
        if ( v12 )
        {
          v34 = -1969993559;
          v35 = -1144243536;
          v36 = 242064136;
          v37 = 187676638;
          v38 = -1991878171;
          v39 = 96452294;
          v40 = -149557856;
          v41 = -694104463;
          v42 = -1557300779;
          v43 = -566847724;
          v44 = 510674766;
          v45 = 839459207;
          v46 = -379320832;
          v47 = 1465384362;
          v48 = 969356546;
          v49 = 1556836777;
          v50 = 307426473;
          v13 = EAC::Memory::DecryptStr16(&v34, v66);
          LODWORD(v33) = v55;
          LODWORD(v32) = v57;
          sub_14002B218(*(a1 + 67), v13, v54, v56, v32, v33);
          memset(v66, 0, 0x44ui64);
        }
        goto LABEL_35;
      }
    }
    if ( EAC::Imports::MmGetPhysicalForVirtual(i) )
    {
      v14 = *(a1 + 23);
      if ( v14 >= i && v14 < v54 + i )
        continue;
    }
    else if ( v54 <= 0x1000 || !EAC::Imports::MmGetPhysicalForVirtual(i - 4096 + v54) )
    {
      continue;
    }
LABEL_35:
    v15 = v54;
    v60 = v54;
    v65 = v54;
    v16 = v54;
    if ( v54 > 0x100000 )
      v16 = 0x100000i64;
    v54 = v16;
    EAC::Callbacks::IsInUsermodeAddressSpace(i, v16, 1);
    v17 = sub_14000F73C(&i, v5, 1024);
    v20 = v17;
    v69 = v17;
    if ( v17 )
    {
      nHASH = EAC::Memory::GetSomeHash(v18, 2, v5, v17);
      v22 = nHASH;
      if ( (nHASH != 0x1523ABE1 || v57 == 0x20000)// whitelisted module hashes? lol
        && (nHASH != 0x3EF9544D || v56 == 64)
        && (nHASH != 0x7D73439 || v57 == 0x20000) )
      {
        if ( nHASH == 0x1D73F827 )
        {
          if ( v57 == 0x1000000
            || (v23 = *a1, v23 <= 0x3E) && (v24 = 0x4002000800121000i64, _bittest64(&v24, v23))
            || v23 == 81
            || v23 == 89 )
          {
            v22 = 0;
          }
        }
        if ( v22 )
          goto SKIP_LOOP_LABEL;
      }
      v22 = 0;
      for ( j = 0; ; ++j )
      {
        v58[2] = j;
        if ( j >= v20 )
          break;
        v26 = 0;
        v27 = 0;
        v51 = 0i64;
        v28 = 0;
        for ( k = 0i64; ; k = (k + 1) )
        {
          v58[1] = k;
          LODWORD(v51) = v5[4 * j + 2];
          v29 = k == v51;
          if ( k >= v51 )
            break;
          v30 = *(k + *&v5[4 * j]);
          if ( v30 == 120 )
          {
            v26 |= 1u;
            v28 = 0;
            v51 = ++v27;
            if ( v27 == 3 )
              v26 |= 4u;
          }
          else
          {
            if ( v30 != 63 )
            {
              v29 = k == v51;
              break;
            }
            v26 |= 2u;
            v27 = 0;
            LODWORD(v51) = 0;
            HIDWORD(v51) = ++v28;
            if ( v28 == 2 )
              v26 |= 8u;
          }
        }
        if ( v29 && v26 == 15 )
        {
          v22 = 693986245;
          v20 = v69;
          break;
        }
        v20 = v69;
      }
      if ( v22 )
SKIP_LOOP_LABEL:
        sub_140031DC8(v22, &i, v5, v20, a1);
      v15 = v60;
    }
    if ( v54 > 0x1000 )
      v59 = EAC::Callbacks::SomeDisassemblerShitWrapper(&i, v3, k, v59, v61, v58);
    v2 = v68;
    v54 = v15;
  }
  EAC::Callbacks::KeUnstackDetachProcess(*(a1 + 1), v67);
  v31 = a1[10];
  if ( (v31 == 64 && i < 0x7FFFFFF0000i64 || v31 == 32 && i < 0x7FFE0000)
    && EAC::Imports::PsGetProcessExitProcessCalled(*(a1 + 1))
    && !*(a1 + 544) )
  {
    EAC::Callbacks::ReportViolation_1(a1, 0x49C7C002i64, &i, 8i64, 0i64);
  }
LABEL_83:
  if ( v58[0] )
  {
    *v4 = v58[0];
    EAC::Callbacks::ReportViolation_1(a1, 0x7A8B5AF5i64, v4, (v59 - v4), 0i64);
  }
LABEL_85:
  if ( v4 )
    EAC::Memory::ExFreePool(v4);
  if ( v3 )
    EAC::Memory::ExFreePool(v3);
  if ( v5 )
    EAC::Memory::ExFreePool(v5);
}

void __fastcall EAC::Callbacks::DetectLoadedModulesInGame(__int64 a1, unsigned int a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int16 *v4; // rsi
  __int64 v7; // rax
  __int16 v8; // bx
  __int64 v9; // rax
  int v10; // eax
  unsigned int v11; // er12
  _OWORD *v12; // rax
  __int64 v13; // r14
  char *i; // rax
  __int64 v15; // rdx
  unsigned int v16; // ebx
  __int64 v17[2]; // [rsp+50h] [rbp-88h] BYREF
  char v18[16]; // [rsp+60h] [rbp-78h] BYREF
  char *v19; // [rsp+70h] [rbp-68h] BYREF
  char *v20; // [rsp+78h] [rbp-60h]
  unsigned __int64 v21; // [rsp+88h] [rbp-50h]
  int v22; // [rsp+98h] [rbp-40h]

  if ( a1 )
  {
    v4 = a4;
    if ( a3 )
    {
      if ( !a4 || !*(a4 + 8) || !*a4 || !*(a4 + 2) )
        v4 = (v18 & -(EAC::Memory::GetMappedFilename(-1i64, a3, v18) != 0));
      v7 = EAC::Imports::PsGetCurrentProcess();
      v8 = EAC::Imports::PsGetCurrentProcessID(v7);
      v9 = EAC::Imports::PsGetCurrentProcess();
      v10 = EAC::Imports::PsGetProcessWow64(v9);
      v11 = 0x8000;
      v12 = EAC::Memory::CopyProcessInformation(a3, 0x1000ui64, 0x8000ui64, 0, v10, v4, v8, v17);
      v13 = v12;
      v17[1] = v12;
      if ( v12 )
      {
        *(v12 + 22) = 0;
        for ( i = a3; ; i = &v19[v21] )
        {
          v19 = i;
          if ( !v11 )
            break;
          if ( !EAC::Imports::NtQueryVirtualMemory(-1i64, i, 0i64, &v19, 48i64) )
            break;
          if ( v20 != a3 )
            break;
          v15 = (v21 + 4095) & 0xFFFFFFFFFFFFF000ui64;
          v21 = v15;
          if ( !v15 )
            break;
          EAC::Callbacks::IsInUsermodeAddressSpace(v19, v15, 1);
          if ( v22 == 0x1000000 && v19 == v20 )
          {
            *(v13 + 26) |= 2u;
            if ( !EAC::Memory::GetImageBase(v19, v21) )
              *(v13 + 26) |= 0x80u;
          }
          v16 = v11;
          if ( v11 > v21 )
            v16 = v21;
          EAC::Memory::memmove((v17[0] + *(v13 + 22)), v19, v16);
          *(v13 + 22) += v16;
          v11 -= v16;
        }
        EAC::Callbacks::ReportViolation_1(a1, a2, v13, (*(v13 + 10) + *(v13 + 22)), 0i64);
        EAC::Memory::ExFreePool(v13);
      }
      if ( v4 == v18 )
        EAC::Memory::FreeUnicdeString(v18);
    }
  }
}

void __fastcall EAC::Callbacks::DetectLoadedModulesInGame2(__int64 pStr, __int64 a2, unsigned int a3)
{
  __int64 v4; // r14
  unsigned __int64 v6; // r12
  _OWORD *v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rsi
  unsigned int v10; // er13
  __int64 v11; // rdi
  unsigned __int64 v12; // r15
  __int64 v13; // [rsp+80h] [rbp+8h]
  __int64 v14; // [rsp+98h] [rbp+20h] BYREF

  if ( pStr )
  {
    v13 = pStr;
    v4 = a2;
    if ( *(pStr + 32) )
    {
      if ( a2 )
      {
        if ( a3 )
        {
          v6 = 0x8000i64;
          v7 = EAC::Memory::CopyProcessInformation(*(pStr + 16), *(pStr + 24), 0x8000ui64, 4, 64, pStr, 0, &v14);
          v8 = v7;
          if ( v7 )
          {
            if ( *(pStr + 28) )
              *(v7 + 26) |= 0x400u;
            v9 = 0i64;
            v10 = 0;
            if ( a3 )
            {
              v11 = v14;
              do
              {
                v12 = (*(v4 + 8) + 1);
                if ( v12 > v6 )
                  break;
                EAC::Memory::memmove((v9 + v11), *v4, v12);
                v9 += v12;
                v6 -= v12;
                ++v10;
                v4 += 16i64;
              }
              while ( v10 < a3 );
              if ( v9 )
              {
                EAC::Callbacks::ReportViolation(*(v13 + 32), v8, (v9 + *(v8 + 10)));
                memset(v8, 0, (v9 + *(v8 + 10)));
              }
            }
            EAC::Memory::ExFreePool(v8);
          }
        }
      }
    }
  }
}

void EAC::Callbacks::CloseGameProcess()
{
  if ( EAC::Globals::GameProcessID )
  {
    EAC::Callbacks::TerminateUsermodeProcess(EAC::Globals::GameProcessID, 0);
    EAC::Globals::GameProcessID = 0i64;
  }
  if ( Event )
  {
    ObfDereferenceObject(Event);
    Event = 0i64;
  }
  EAC::Globals::ProcessID = 0i64;
}

char __fastcall EAC::Callbacks::ResetGameProcessID(__int64 a1)
{
  char result; // al

  if ( !a1 || a1 != EAC::Globals::GameProcessID )
    return 0;
  EAC::Globals::ProcessID = 0i64;
  result = 1;
  EAC::Globals::GameProcessID = 0i64;
  return result;
}

```

`EAC-Reversal-main/hwid.cpp`:

```cpp
char __fastcall EAC::HWID::GetMACAddress(__int64 a1, void *a2)
{
  char v2; // bl
  int v4; // [rsp+20h] [rbp-28h] BYREF
  void *v5; // [rsp+28h] [rbp-20h]
  char v6; // [rsp+30h] [rbp-18h]

  v2 = 0;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  if ( !a2 || a1 != 6 )
    return 0;
  if ( EAC::HWID::GetFirstNetworkDeviceMacAddress(a1, a2, &v4) )
  {
    if ( v6 )
      v2 = 1;
  }
  return v2;
}

char __fastcall EAC::HWID::GetFirstNetworkDeviceMacAddress(__int64 a1, void *a2, __int64 a3)
{
  __int64 v4; // r14
  char v5; // si
  int (__fastcall *v6)(void *, _QWORD, __int64, PVOID *); // rax
  __int64 v7; // r8
  char *v8; // rcx
  char *v9; // rbx
  __int64 v10; // r8
  unsigned __int32 v11; // edx
  unsigned __int64 v12; // rdi
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rax
  __int64 i; // r14
  char *v17; // rbx
  __int64 v18; // r8
  unsigned int v19; // edx
  unsigned __int64 v20; // rdi
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  __int64 v24; // rdi
  char *v25; // rdx
  __int64 v26; // r9
  char v27; // al
  __int64 v28; // rdx
  int v30[4]; // [rsp+20h] [rbp-50h]
  int v31[4]; // [rsp+30h] [rbp-40h]
  char v32[16]; // [rsp+40h] [rbp-30h] BYREF
  __int128 v33; // [rsp+50h] [rbp-20h] BYREF
  __int128 v34; // [rsp+60h] [rbp-10h] BYREF
  PVOID P; // [rsp+B8h] [rbp+48h] BYREF
  __int128 *v36; // [rsp+C8h] [rbp+58h]

  P = a2;
  v4 = 0i64;
  v5 = 1;
  if ( KeGetCurrentIrql() )
    return 0;
  v6 = EAC::Memory::ResolveImportWrapper(*IoGetDeviceInterfaces, IoGetDeviceInterfaces, 0i64);
  if ( !v6 || v6(&unk_14006E450, 0i64, v7, &P) < 0 )
    return 0;
  v8 = P;
  do
  {
    v9 = &v8[2 * v4];
    if ( !*v9 )
      break;
    v10 = -1i64;
    do
      ++v10;
    while ( *&v9[2 * v10] );
    v30[0] = -1172472817;
    v30[1] = -1869928664;
    v33 = 0i64;
    v30[2] = 2023745324;
    v11 = 861309531;
    v30[3] = 858689899;
    v12 = 0i64;
    v36 = &v33;
    do
    {
      v11 = _byteswap_ulong(((v11 ^ (v11 >> 7)) << 9) ^ v11 ^ (v11 >> 7) ^ ((((v11 ^ (v11 >> 7)) << 9) ^ v11 ^ (v11 >> 7)) >> 13));
      *(v36 + v12 * 4) = v30[v12] ^ v11;
      ++v12;
    }
    while ( v12 < 4 );
    v13 = sub_140007C9C(v9, &v33);
    memset(&v33, 0, sizeof(v33));
    if ( v13 == v9 )
    {
      EAC::Memory::InitializeUnicodeStringWithCString(v32, v9);
      v5 = EAC::HWID::GetMacAddressSecondary(0i64, v32, a3, v14);
    }
    v8 = P;
    v15 = -1i64;
    do
      ++v15;
    while ( *(P + v4 + v15) );
    v4 += v15 + 1;
  }
  while ( v5 );
  for ( i = 0i64; v5; i += v23 + 1 )
  {
    v17 = &v8[2 * i];
    if ( !*v17 )
      break;
    v18 = -1i64;
    do
      ++v18;
    while ( *&v17[2 * v18] );
    v31[0] = -893088486;
    v31[1] = 781382351;
    v34 = 0i64;
    v31[2] = 489497106;
    v19 = 1526199263;
    v31[3] = 1870561;
    v20 = 0i64;
    v36 = &v34;
    do
    {
      v19 = ~(((v19 ^ (v19 << 13)) >> 17) ^ v19 ^ (v19 << 13) ^ (32 * (((v19 ^ (v19 << 13)) >> 17) ^ v19 ^ (v19 << 13))));
      *(v36 + v20 * 4) = v31[v20] ^ v19;
      ++v20;
    }
    while ( v20 < 4 );
    v21 = sub_140007C9C(v17, &v34);
    memset(&v34, 0, sizeof(v34));
    if ( v21 == v17 )
    {
      EAC::Memory::InitializeUnicodeStringWithCString(v32, v17);
      v5 = EAC::HWID::GetMacAddressSecondary(1i64, v32, a3, v22);
    }
    v8 = P;
    v23 = -1i64;
    do
      ++v23;
    while ( *(P + i + v23) );
  }
  v24 = 0i64;
  if ( v5 )
  {
    do
    {
      v25 = &v8[2 * v24];
      if ( !*v25 )
        break;
      EAC::Memory::InitializeUnicodeStringWithCString(v32, v25);
      v27 = EAC::HWID::GetMacAddressSecondary(2i64, v32, a3, v26);
      v8 = P;
      v28 = -1i64;
      do
        ++v28;
      while ( *(P + v24 + v28) );
      v24 += v28 + 1;
    }
    while ( v27 );
  }
  ExFreePoolWithTag(v8, 0);
  return 1;
}

char __fastcall EAC::HWID::CollectProcessorFeatures(__int64 a1)
{
  unsigned int v2; // ebx
  __int128 *v4; // r8
  __int16 *v5; // rdx
  __int64 v6; // rax
  wchar_t *v7; // rcx
  __int128 v8; // [rsp+20h] [rbp-A8h] BYREF
  int v9; // [rsp+30h] [rbp-98h]
  __m128 v10[8]; // [rsp+40h] [rbp-88h] BYREF

  v9 = 0;
  v8 = 0i64;
  EAC::Memory::memset(v10, 0, 0x80ui64);
  v2 = 0;
  if ( !a1 )
    return 0;
  EAC::HWID::HashVar(0xFFFFF78000000274ui64, 0x40u, &v8);// ProcessorFeatures
  v4 = &v8;
  v5 = &v10[0].m128_i16[1];
  do
  {
    v6 = *v4;
    ++v2;
    v4 = (v4 + 1);
    v7 = off_1400534C0[v6];
    *(v5 - 1) = *v7;
    *v5 = v7[1];
    v5 += 2;
  }
  while ( v2 < 0x14 );
  return CreateUnicodeStringFromPWSTR(a1, v10);
}

char __fastcall EAC::HWID::HashFileInfromation(__int64 CurrentProcess, struct_pHWIDStruct *pHWIDStruct)
{
  __int64 bGetFileOnDisk; // rcx
  struct_pScanned_1 *pScanned; // rax
  struct_pScanned_1 *_pScanned; // rdi
  char v8[56]; // [rsp+20h] [rbp-38h] BYREF

  // Not sure if this is even a HWID related function.. It's probably them just sending process info to their servers.
  if ( !CurrentProcess || !pHWIDStruct || !EAC::Imports::PsGetProcessExitProcessCalled(CurrentProcess) )
    return 0;
  memset(pHWIDStruct, 0, 0x338ui64);
  if ( EAC::Callbacks::KeStackAttachProcess(CurrentProcess, v8) )
  {
    LOBYTE(bGetFileOnDisk) = 1;
    pScanned = EAC::Calbacks::ScanProcess(bGetFileOnDisk);
    _pScanned = pScanned;
    if ( pScanned )
    {
      pHWIDStruct->byte100 = *(pScanned->pInfoStruct + 30i64);
      EAC::Memory::CopyUnicodeStringToAnsiBuffer(pHWIDStruct, 256i64, &pScanned->unsigned___int1618);
      pHWIDStruct->dword104 = *(_pScanned->pInfoStruct + 0x250i64);
      pHWIDStruct->dword10C = *(_pScanned->pInfoStruct + 0x240i64);
      pHWIDStruct->dword108 = *(_pScanned->pInfoStruct + 0x234i64);
      pHWIDStruct->dword130 = *(_pScanned->pInfoStruct + 0x24Ci64);
      pHWIDStruct->dword134 = *(_pScanned->pInfoStruct + 0x248i64);
      EAC::Memory::CopyRawDataFromDebugDirectory(*(_pScanned->pInfoStruct + 14i64), &pHWIDStruct[1], 256);
      pHWIDStruct->nMicrosoftFileHash = EAC::HWID::HashMicrosoftFilesWrapper(*(_pScanned->pInfoStruct + 0xEi64));
      pHWIDStruct->qword120 = EAC::HWID::HashMoreFileShitNotSureWhatWrapper(*(_pScanned->pInfoStruct + 0xEi64));
      pHWIDStruct->qword128 = EAC::HWID::HashDosHeadersWrapper(*(_pScanned->pInfoStruct + 0xEi64));
      EAC::Memory::FreePoolAndUnicodeString(_pScanned);
    }
    EAC::Callbacks::KeUnstackDetachProcess(CurrentProcess, v8);
  }
  return 1;
}

char __fastcall EAC::HWID::SetNTOSKRNLOptionalHeaderHash(unsigned __int64 pCurrentFileBeingReadInMemory, unsigned int a2, _OWORD *pOutput)
{
  char bGrabbedHWID; // di
  __int64 v6; // rsi
  _IMAGE_NT_HEADERS64 *v7; // rax
  IMAGE_DATA_DIRECTORY *v8; // r8
  unsigned __int64 v9; // rax
  __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rcx
  unsigned int v13; // er14
  _IMAGE_NT_HEADERS64 *v14; // rdx
  char *v15; // rax
  unsigned int v16; // ecx
  __int64 v17; // rbx

  bGrabbedHWID = 0;
  if ( pOutput )
  {
    if ( pCurrentFileBeingReadInMemory )
    {
      v6 = a2;
      v7 = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, a2);
      if ( v7 )
      {
        v8 = &v7->OptionalHeader.DataDirectory[4];
        if ( v7->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
          v8 = &v7->OptionalHeader.DataDirectory[6];
        if ( v8->VirtualAddress )
        {
          if ( v8->Size )
          {
            v9 = sub_14004EC8C(v8->VirtualAddress, v7, pCurrentFileBeingReadInMemory);
            if ( v9 >= pCurrentFileBeingReadInMemory && v9 + 28 > v9 )
            {
              v11 = pCurrentFileBeingReadInMemory + v6;
              if ( v9 + 28 <= v11 )
              {
                v12 = *(v9 + 20);
                if ( v12 )
                {
                  v13 = *(v9 + 16);
                  if ( v13 )
                  {
                    if ( *(v9 + 12) == 2 )
                    {
                      v14 = sub_14004EC8C(v12, v10, pCurrentFileBeingReadInMemory);
                      if ( v14 >= pCurrentFileBeingReadInMemory )
                      {
                        v15 = v14 + v13;
                        if ( v15 > v14 && v15 <= v11 && v14->Signature == 'SDSR' )
                        {
                          v16 = 255;
                          if ( v13 - 25 < 0xFF )
                            v16 = v13 - 25;
                          v17 = v16;
                          EAC::Memory::memmove(pOutput, &v14->OptionalHeader, v16);
                          *(pOutput + v17) = 0;
                          bGrabbedHWID = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return bGrabbedHWID;
}

unsigned __int64 __fastcall EAC::HWID::HashMicrosoftFiles(unsigned __int64 a1, unsigned int CONSTANT_4096)
{
  __m128 *v4; // rsi
  _IMAGE_NT_HEADERS64 *pOptionalHeaders; // rcx
  __int64 nSizeOfCode; // rbx
  _IMAGE_NT_HEADERS64 *v7; // rdx
  ULONG *nNumberOfSymbols; // rcx
  __int128 pHashed; // [rsp+28h] [rbp-E0h] BYREF
  unsigned int nLiterallyZero; // [rsp+38h] [rbp-D0h]
  __m128 pOriginalStruct_MaybeIdk[32]; // [rsp+48h] [rbp-C0h] BYREF

  EAC::Memory::memset(pOriginalStruct_MaybeIdk, 0, 0x200ui64);
  v4 = pOriginalStruct_MaybeIdk;
  nLiterallyZero = 0;
  pHashed = 0i64;
  if ( a1 )
  {
    if ( CONSTANT_4096 >= 512 )
    {
      pOptionalHeaders = EAC::Memory::GetImageBase(a1, CONSTANT_4096);
      if ( pOptionalHeaders )
      {
        while ( pOptionalHeaders > a1 )
        {
          pOptionalHeaders = (pOptionalHeaders - 4);
          if ( pOptionalHeaders->Signature == 'hciR' )// (END MARKER)
          {
            if ( pOptionalHeaders > a1 )
            {
              nSizeOfCode = *&pOptionalHeaders->FileHeader.Machine;
              v7 = pOptionalHeaders;
              while ( pOptionalHeaders > a1 )
              {
                pOptionalHeaders = (pOptionalHeaders - 4);
                if ( (pOptionalHeaders->Signature ^ nSizeOfCode) == 'SnaD' )// (START MARKER)
                {
                  if ( pOptionalHeaders <= a1 )
                    return 0i64;
                  if ( *&pOptionalHeaders->FileHeader.Machine != nSizeOfCode )
                    return 0i64;
                  if ( pOptionalHeaders->FileHeader.TimeDateStamp != nSizeOfCode )
                    return 0i64;
                  if ( pOptionalHeaders->FileHeader.PointerToSymbolTable != nSizeOfCode )
                    return 0i64;
                  nNumberOfSymbols = &pOptionalHeaders->FileHeader.NumberOfSymbols;
                  if ( (((v7 - nNumberOfSymbols) >> 2) - 2) > 126 )
                    return 0i64;
                  while ( nNumberOfSymbols < v7 )
                  {
                    v4->m128_i32[0] = *nNumberOfSymbols ^ nSizeOfCode;
                    v4 = (v4 + 4);
                    ++nNumberOfSymbols;
                  }
                  EAC::HWID::HashVar(pOriginalStruct_MaybeIdk, v4 - pOriginalStruct_MaybeIdk, &pHashed);
                  return nLiterallyZero ^ DWORD2(pHashed) ^ pHashed | ((nSizeOfCode ^ HIDWORD(pHashed) ^ DWORD1(pHashed)) << 32);
                }
              }
            }
            return 0i64;
          }
        }
      }
    }
  }
  return 0i64;
}

unsigned __int64 __fastcall EAC::HWID::HashDosHeaders(__int64 a1, unsigned int CONSTANT_4096)
{
  _IMAGE_NT_HEADERS64 *pNtHeaders; // rax
  __int64 ntype; // rcx
  __int128 v5; // [rsp+20h] [rbp-28h] BYREF
  unsigned int v6; // [rsp+30h] [rbp-18h]

  v6 = 0;
  v5 = 0i64;
  if ( !a1 )
    return 0i64;
  if ( CONSTANT_4096 < 512 )
    return 0i64;
  pNtHeaders = EAC::Memory::GetImageBase(a1, CONSTANT_4096);
  if ( !pNtHeaders )
    return 0i64;
  ntype = 120i64;
  if ( pNtHeaders->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
    ntype = 136i64;
  EAC::HWID::HashVar(pNtHeaders + ntype, 0x80u, &v5);
  return ((HIDWORD(v5) ^ DWORD1(v5)) << 32) | v6 ^ DWORD2(v5) ^ v5;
}

char __fastcall EAC::HWID::HashNTOSKRNLInformation(__int64 pInputStruct, struct_a2 *pOutputStruct)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = 0i64;
  P = 0i64;
  FileLength = 0;
  bHasPassedAlotOfChecksWtf = 0;
  UNICODESTR = 0i64;
  if ( !pOutputStruct || !pInputStruct || !*(pInputStruct + 8) || !*pInputStruct || !*(pInputStruct + 2) )
    return 0;
  memset(pOutputStruct, 0, 0x338ui64);
  EAC::Memory::CopyUnicodeStringToAnsiBuffer(pOutputStruct, 256i64, pInputStruct);
  if ( EAC::Memory::CopyOverUnicodeString(v5, &UNICODESTR) )// \SystemRoot\system32\ntoskrnl.exe
  {
    if ( EAC::Memory::ForceReadFile(&UNICODESTR, &P, &FileLength) )// calls ZwReadFile and sets parameters with info
    {
      Size = FileLength;
      pCurrentFileBeingReadInMemory = P;
      v41 = FileLength;
      if ( P && FileLength )
      {
        bHasCompletedScan = 0;
        v9 = P + FileLength;
        P = v9;
        if ( FileLength )                       // all this block of code does is set bHasPassedAlotOfChecksWtf after checking if file is valid enough
        {
          v10 = 0i64;
          pNTHeaders_1 = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, FileLength);
          if ( pNTHeaders_1 )
          {
            v12 = 152i64;
            if ( pNTHeaders_1->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
              v12 = 168i64;
            pDOSHeaders_1 = (pNTHeaders_1 + v12);
            if ( pDOSHeaders_1 )
            {
              if ( pDOSHeaders_1 >= pCurrentFileBeingReadInMemory
                && pDOSHeaders_1 + 2 > pDOSHeaders_1
                && pDOSHeaders_1 + 2 <= v9 )
              {
                v14 = pDOSHeaders_1[1];
                if ( v14 )
                {
                  e_magic = *pDOSHeaders_1;
                  if ( *pDOSHeaders_1 )
                  {
                    for ( i = 0; i < v14; i += *&nCurrentSectionSignatureMaybe->e_magic )
                    {
                      nCurrentSectionSignatureMaybe = (pCurrentFileBeingReadInMemory + e_magic + i);
                      if ( nCurrentSectionSignatureMaybe < pCurrentFileBeingReadInMemory
                        || &nCurrentSectionSignatureMaybe->e_maxalloc <= nCurrentSectionSignatureMaybe
                        || &nCurrentSectionSignatureMaybe->e_maxalloc > P
                        || !*&nCurrentSectionSignatureMaybe->e_magic )
                      {
                        break;
                      }
                      if ( nCurrentSectionSignatureMaybe->e_crlc == 2 )
                      {
                        v10 = pCurrentFileBeingReadInMemory + e_magic + i;
                        bHasCompletedScan = 1;
                        break;
                      }
                    }
                    if ( bHasCompletedScan )
                    {
                      v18 = *v10;
                      v19 = (v10 + 8);
                      v20 = v18 - 8;
                      if ( v19 >= pCurrentFileBeingReadInMemory )
                      {
                        v21 = &v19[v20];
                        if ( v21 > v19 && v21 <= &v41[pCurrentFileBeingReadInMemory] )
                        {
                          v22 = EAC::Memory::ExAllocatePoolWithRandomTag2(72i64);
                          v2 = v22;
                          if ( v22 )
                          {
                            v44 = 0i64;
                            v41 = v19;
                            LODWORD(P) = v20;
                            memset(v22, 0, 0x48ui64);
                            v42 = 0i64;
                            v43 = 0i64;
                            if ( v19
                              && v20
                              && (memset(v22, 0, 0x48ui64), sub_140049E28(1, &v41, &P, &v42))
                              && v42 == 16
                              && sub_140049E28(1, &v41, &P, &v42)
                              && v42 == 6
                              && v43 == 9
                              && **(&v42 + 1) == 0x7010DF78648862Ai64
                              && *(*(&v42 + 1) + 8i64) == 2
                              && sub_140049E28(1, &v41, &P, &v42)
                              && !v42
                              && sub_140049E28(1, &v41, &P, &v42)
                              && v42 == 16
                              && v43
                              && sub_140035494(*(&v42 + 1), v43, v2) )
                            {
                              bHasPassedAlotOfChecksWtf = 1;
                            }
                            else
                            {
                              EAC::Memory::ExFreePool(v2);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          Size = FileLength;
        }
        if ( bHasPassedAlotOfChecksWtf )
        {
          EAC::Memory::CopyUnicodeStringToAnsiBuffer(&pOutputStruct[1].gap1[239], 256i64, &v2[1].Length);
          if ( !RtlCompareUnicodeString(v2 + 1, v2, 0) )
            pOutputStruct->byte101 = 1;
          if ( v2 )
          {
            v23 = v2->Buffer;
            if ( v23 )
            {
              EAC::Memory::ExFreePool(v23);
              *v2 = 0i64;
            }
            EAC::Memory::FreeUnicdeString(&v2[1]);
            EAC::Memory::ExFreePool(v2);
          }
        }
      }
      Size2 = Size;
      v25 = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, Size);
      v26 = v25;
      if ( v25 )
      {
        Magic = v25->OptionalHeader.Magic;
        bHasPassedAlotOfChecksWtf = 1;
        if ( Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC )
          nImageArchitectureType = 32;
        else
          nImageArchitectureType = Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC ? 0 : 64;
        pOutputStruct->nImageArchitectureType = nImageArchitectureType;
        EAC::Memory::memset(v46, 0, 0x200ui64);
        v29 = v46;
        LODWORD(v43) = 0;
        v42 = 0i64;
        if ( pCurrentFileBeingReadInMemory )
        {
          if ( Size >= 0x200 )
          {
            pDOSHeaders = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, Size);
            if ( pDOSHeaders )
            {
              while ( pDOSHeaders > pCurrentFileBeingReadInMemory )
              {
                pDOSHeaders = (pDOSHeaders - 4);
                if ( *&pDOSHeaders->e_magic == 'hciR' )
                {
                  if ( pDOSHeaders <= pCurrentFileBeingReadInMemory )
                    break;
                  v31 = *&pDOSHeaders->e_cp;
                  v32 = pDOSHeaders;
                  do
                  {
                    if ( pDOSHeaders <= pCurrentFileBeingReadInMemory )
                      goto BREAK_LABEL_MEME;
                    pDOSHeaders = (pDOSHeaders - 4);
                  }
                  while ( (*&pDOSHeaders->e_magic ^ v31) != 'SnaD' );
                  if ( pDOSHeaders <= pCurrentFileBeingReadInMemory
                    || *&pDOSHeaders->e_cp != v31
                    || *&pDOSHeaders->e_cparhdr != v31
                    || *&pDOSHeaders->e_maxalloc != v31
                    || (v33 = &pDOSHeaders->e_sp, (((v32 - v33) >> 2) - 2) > 0x7E) )
                  {
BREAK_LABEL_MEME:
                    Size2 = Size;
                    break;
                  }
                  while ( v33 < v32 )
                  {
                    v29->m128_i32[0] = *v33 ^ v31;
                    v29 = (v29 + 4);
                    v33 += 2;
                  }
                  EAC::HWID::HashVar(v46, v29 - v46, &v42);
                  nEndOfHash = (v31 ^ HIDWORD(v42) ^ DWORD1(v42)) << 32;
                  Size2 = Size;
                  nRichHeadersHash = v43 ^ DWORD2(v42) ^ v42 | nEndOfHash;
                  goto DONT_NULL_OUT_RICHHEADERS_VAR;
                }
              }
            }
          }
        }
        nRichHeadersHash = 0i64;
DONT_NULL_OUT_RICHHEADERS_VAR:
        bIs64Bit = pOutputStruct->nImageArchitectureType == 64;
        pOutputStruct->nRichHeadersHash = nRichHeadersHash;
        if ( bIs64Bit )
          pOutputStruct->nHashOfSomeWeirdShit = EAC::HWID::HashMoreFileShitNotSureWhat(
                                                  pCurrentFileBeingReadInMemory,
                                                  Size,
                                                  0);
        pOutputStruct->nImageAddressOfEntryPoint = v26->OptionalHeader.AddressOfEntryPoint;
        pOutputStruct->nImageSizeofCode = v26->OptionalHeader.SizeOfCode;
        LODWORD(v43) = 0;
        v42 = 0i64;
        if ( pCurrentFileBeingReadInMemory
          && Size >= 0x200
          && (pNTHeaders = EAC::Memory::GetImageBase(pCurrentFileBeingReadInMemory, Size2)) != 0i64 )
        {
          v37 = 0x78i64;
          if ( pNTHeaders->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
            v37 = 0x88i64;
          EAC::HWID::HashVar(pNTHeaders + v37, 0x80u, &v42);
          nHash = ((HIDWORD(v42) ^ DWORD1(v42)) << 32) | v43 ^ DWORD2(v42) ^ v42;
        }
        else
        {
          nHash = 0i64;
        }
        pOutputStruct->nNTHeadersHash = nHash;
        EAC::HWID::SetNTOSKRNLOptionalHeaderHash(
          pCurrentFileBeingReadInMemory,
          Size,
          &pOutputStruct->nNTOSKRNLOptionalHash);
        pOutputStruct->nImageChecksum = v26->OptionalHeader.CheckSum;
        pOutputStruct->nImageSizeOf = v26->OptionalHeader.SizeOfImage;
        pOutputStruct->nImageTimeDateStamp = v26->FileHeader.TimeDateStamp;
      }
      else
      {
        bHasPassedAlotOfChecksWtf = 0;
      }
      pOutputStruct->ImageSize = Size;
      if ( pCurrentFileBeingReadInMemory )
        EAC::Memory::ExFreePool(pCurrentFileBeingReadInMemory);
    }
    EAC::Memory::FreeUnicdeString(&UNICODESTR);
  }
  return bHasPassedAlotOfChecksWtf;
}

unsigned __int64 __fastcall EAC::HWID::HashMoreFileShitNotSureWhat(unsigned __int64 a1, unsigned int a2, char a3)
{
  unsigned __int64 v5; // rbx
  unsigned __int64 result; // rax
  __int64 v7; // r15
  __int64 v8; // rax
  __int64 v9; // rdx
  unsigned int *v10; // rsi
  __int64 v11; // rax
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // r9
  unsigned int *v14; // rcx
  unsigned int v15; // edx
  __int128 v16; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v17; // [rsp+40h] [rbp-28h]

  v5 = 0i64;
  result = 0i64;
  v16 = 0i64;
  v17 = 0;
  if ( a1 && a2 )
  {
    v7 = a2;
    v8 = EAC::Memory::GetImageBase(a1, a2);
    if ( v8 && EAC::Memory::GetProcessArchitectureType(v8) == 64 )
    {
      v10 = (v9 + 144);
      if ( *(v9 + 24) != 267 )
        v10 = (v9 + 160);
      v11 = *v10;
      if ( v11 )
      {
        v12 = v10[1];
        if ( v12 )
        {
          v13 = a3 ? v11 + a1 : sub_14004EC8C(v11, v9, a1);
          if ( v13 >= a1 && v12 + v13 > v13 && v12 + v13 <= v7 + a1 && v12 == 12 * (v12 / 12) )
          {
            v14 = v13;
            v15 = 0;
            while ( v14 < v13 + 12 * (v12 / 12) )
            {
              if ( v15 > *v14 )
                goto LABEL_21;
              v15 = *v14;
              v14 += 3;
            }
            EAC::HWID::HashVar(v13, v12, &v16);
            v5 = v17 ^ DWORD2(v16) ^ v16 | ((HIDWORD(v16) ^ DWORD1(v16) ^ v10[1]) << 32);
          }
        }
      }
    }
LABEL_21:
    result = v5;
  }
  return result;
}

```

`EAC-Reversal-main/injection.cpp`:

```cpp
bool __fastcall EAC::Callbacks::BeginWindowsInjection(__int64 a1)
{
  _UNICODE_STRING *v1; // r14
  bool v3; // bl
  char v4; // di
  unsigned int v5; // edx
  unsigned __int64 v6; // rdi
  unsigned __int64 i; // r8
  char v8; // cl
  int v9; // eax
  char v10; // dl
  __m128 *pBuffer; // rax
  __int64 v13; // rdx
  __m128 *v14; // rdi
  bool v15; // al
  int v16[21]; // [rsp+20h] [rbp-79h]
  __int16 v17; // [rsp+74h] [rbp-25h]
  char v18[122]; // [rsp+76h] [rbp-23h] BYREF

  v1 = (a1 + 16);
  v3 = 0;
  v4 = 0;
  if ( !EAC::Memory::ExAllocatePoolWithRandomTag2Wrapper(a1 + 16, 0x1000u) )
    goto LABEL_6;
  v16[0] = -1161486776;
  v17 = -7342;
  v16[1] = 2131784440;
  v16[2] = -1779023309;
  v16[3] = 1647530064;
  v16[4] = 883744188;
  v16[5] = 724101881;
  v16[6] = 2011759064;
  v16[7] = 496383216;
  v16[8] = -1184496954;
  v16[9] = 36685397;
  v16[10] = 930039539;
  v16[11] = -836592059;
  v16[12] = 1150566866;
  v16[13] = -919534435;
  v16[14] = 2032694796;
  v16[15] = 8270150;
  v16[16] = -1979060004;
  v16[17] = 771305898;
  v16[18] = -1362328921;
  v16[19] = -1669975869;
  v16[20] = 1112865952;
  EAC::Memory::memset(v18, 0, 0x56ui64);
  v5 = -1164567020;
  v6 = 84i64;
  for ( i = 0i64; i < 21; ++i )
  {
    *&v18[i * 4] = v16[i] ^ v5;
    v5 = __ROL4__(((v5 ^ (v5 << 13)) >> 7) ^ v5 ^ (v5 << 13) ^ ((((v5 ^ (v5 << 13)) >> 7) ^ v5 ^ (v5 << 13)) << 17), 4);
  }
  do
  {
    v8 = v5;
    v5 >>= 8;
    v18[v6] = *(v16 + v6) ^ v8;
    ++v6;
  }
  while ( v6 < 0x56 );
  v4 = 1;
  v9 = EAC::Memory::RtlUnicodeStringPrintf(v1, v18, __rdtsc());
  v10 = 0;
  if ( v9 < 0 )
LABEL_6:
    v10 = 1;
  if ( (v4 & 1) != 0 )
    memset(v18, 0, 0x56ui64);
  if ( v10 )
    return 0;
  pBuffer = EAC::Memory::GetImageBuffer(&unk_140066E90, 21992i64);
  v14 = pBuffer;
  if ( pBuffer )
  {
    if ( EAC::Memory::ForceWriteFile(v1, v13, pBuffer) )
    {
      *(a1 + 8) = 1;
      v15 = EAC::Callbacks::LoadLibraryInjection(a1, 1) >= 0;
      *(a1 + 9) = v15;
      v3 = v15;
    }
    EAC::Memory::memset(v14, 0, 0x55E8ui64);
    EAC::Memory::ExFreePool(v14);
  }
  return v3;
}

char __fastcall EAC::Callbacks::BeginWindowsInjectionWrapper(PVOID Object)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v1 = 0;
  v2 = 0;
  if ( !Object || !EAC::Globals::UnknownInjectionBoolean )
    goto LABEL_20;
  ExAcquireFastMutex(&stru_140073E70);
  v4 = 0i64;
  v5 = &EAC::Globals::LoadLibraryInjectionStruct;
  while ( *v5 != Object )
  {
    ++v4;
    v5 += 4;
    if ( v4 >= 0x10 )
    {
      v6 = 0i64;
      goto LABEL_7;
    }
  }
  v6 = &EAC::Globals::LoadLibraryInjectionStruct + 32 * v4;
  if ( v6 )
  {
    v1 = v6[9];
    v9 = v6;
    goto LABEL_15;
  }
LABEL_7:
  v7 = 0i64;
  v8 = &EAC::Globals::LoadLibraryInjectionStruct;
  while ( *v8 )
  {
    ++v7;
    v8 += 4;
    if ( v7 >= 0x10 )
    {
      v9 = 0i64;
      goto LABEL_14;
    }
  }
  v10 = 32 * v7;
  *(&EAC::Globals::LoadLibraryInjectionStruct + v10 + 8) = 0i64;
  v9 = &EAC::Globals::LoadLibraryInjectionStruct + v10;
  *(&EAC::Globals::LoadLibraryInjectionStruct + v10 + 16) = 0i64;
  *(&EAC::Globals::LoadLibraryInjectionStruct + v10 + 24) = 0i64;
  *(&EAC::Globals::LoadLibraryInjectionStruct + v10) = Object;
  if ( (&EAC::Globals::LoadLibraryInjectionStruct + v10) )
    goto LABEL_15;
LABEL_14:
  v2 = 1;
LABEL_15:
  ExReleaseFastMutex(&stru_140073E70);
  if ( v6 )
    return v1;
  if ( !v2 && (ObfReferenceObject(Object), EAC::Callbacks::BeginWindowsInjection(v9)) )
    result = 1;
  else
LABEL_20:
    result = 0;
  return result;
}

__int64 __fastcall EAC::Callbacks::LoadLibraryInjection(struct_a1_1 *pInputStruct, char a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v34 = a2;
  v4 = 0xC0000001;
  LODWORD(v18) = 0xC0000001;
  v25 = 0i64;
  if ( !sub_140021608(&pInputStruct->unsigned___int1610, &v26) )
    return 0xC000000Di64;
  if ( EAC::Callbacks::KeStackAttachProcess(pInputStruct->HANDLE, v32) )
  {
    v8 = EAC::Imports::NtAllocateVirtualMemoryWrapper(v6, 4096i64, v7, 64);
    v9 = v8;
    v25 = v8;
    if ( !v8 )
      goto FREE_MEMORY_AND_UNSTACK_LABEL;
    EAC::Memory::CheckAddressBounds(v8, 4096i64);
    *v9 = xmmword_14006C490;
    *(v9 + 16) = xmmword_14006C4A0;
    *(v9 + 32) = xmmword_14006C4B0;
    *(v9 + 48) = xmmword_14006C4C0;
    v23[0] = 183270618;
    v23[1] = -1577622027;
    v23[2] = 851333393;
    v23[3] = 212456202;
    v23[4] = 1264994537;
    v23[5] = -444005607;
    v24 = 17185;
    v10 = EAC::Memory::DecryptStr5(v23, v30);
    v11 = EAC::Callbacks::GetUsermodeModuleWrapper(v10);
    memset(v30, 0, 0x1Aui64);
    if ( !v11 )
      goto FREE_MEMORY_AND_UNSTACK_LABEL;
    if ( a2 )
    {
      v21[0] = 0x984BB8DA;
      v21[1] = -1983652296;
      v21[2] = -1640782585;
      v22 = 43;
      v12 = 1;
      str = EAC::Memory::DecryptStr3(v21, v29);
    }
    else
    {
      HIDWORD(v18) = 974224348;
      v19 = 1879373332;
      v20 = -573867558;
      v12 = 2;
      str = EAC::Memory::DecryptStr4(&v18 + 4, v28);
    }
    *(v9 + 64) = sub_14004F1A4(v14, str);
    if ( (v12 & 2) != 0 )
    {
      v12 &= 0xFDu;
      memset(v28, 0, sizeof(v28));
    }
    if ( (v12 & 1) != 0 )
      memset(v29, 0, 0xDui64);
    if ( !*(v9 + 64) )
      goto FREE_MEMORY_AND_UNSTACK_LABEL;
    if ( v34 )
    {
      *(v9 + 72) = v9 + 80;
      EAC::Memory::memmove((v9 + 80), v27, v26);
    }
    else if ( !sub_140007B70(v33, 64i64, &v26)
           || (v15 = EAC::Callbacks::GetUsermodeModuleWrapper(v33), (*(v9 + 72) = v15) == 0i64) )
    {
FREE_MEMORY_AND_UNSTACK_LABEL:
      if ( v9 )
        EAC::Imports::NtFreeVirtualMemoryWrapper(v9);
      EAC::Callbacks::KeUnstackDetachProcess(pInputStruct->HANDLE, v32);
      return v4;
    }
    if ( EAC::Globals::RtlCreateUserThread )
    {
      v16 = EAC::Globals::RtlCreateUserThread(-1i64, 0i64, 0i64, 0i64, 0i64, 0i64, v9, v9 + 64, &Handle, 0i64);
    }
    else
    {
      if ( !EAC::Globals::RtlCreateUserThreadAlternative )
      {
        v4 = 0xC0000002;
        LODWORD(v18) = 0xC0000002;
LABEL_24:
        if ( v4 >= 0 )
        {
          ZwWaitForSingleObject(Handle, 0, 0i64);
          v4 = EAC::Imports::NtQueryInformationThread(Handle, 0, v31, 0x30u);
          LODWORD(v18) = v4;
          if ( v4 >= 0 )
          {
            v17 = LOWORD(v31[0]) | 0xC0070000;
            if ( v31[0] <= 0 )
              v17 = v31[0];
            v4 = v31[0] != 0 ? v17 : 0;
            LODWORD(v18) = v4;
          }
          EAC::Imports::NtClose(Handle);
        }
        goto FREE_MEMORY_AND_UNSTACK_LABEL;
      }
      v16 = EAC::Globals::RtlCreateUserThreadAlternative(
              -1i64,
              0i64,
              0i64,
              0i64,
              0i64,
              0i64,
              0i64,
              v9,
              v9 + 64,
              &Handle,
              0i64,
              0i64,
              v18);
    }
    v4 = v16;
    LODWORD(v18) = v16;
    goto LABEL_24;
  }
  return v4;
}

__int64 EAC::Callbacks::WindowsInjectionNumber2()
{
  struct_a1_1 *pInputStruct; // rbx
  __int64 v1; // rdi
  __int64 result; // rax

  if ( EAC::Globals::UnknownInjectionBoolean )
  {
    pInputStruct = &EAC::Globals::LoadLibraryInjectionStruct;
    v1 = 16i64;
    do
    {
      if ( pInputStruct->HANDLE )
      {
        if ( pInputStruct->gap8[1] )
          EAC::Callbacks::LoadLibraryInjection(pInputStruct, 0);
        result = EAC::Callbacks::DeleteFileByString(pInputStruct);
      }
      pInputStruct = (pInputStruct + 32);
      --v1;
    }
    while ( v1 );
  }
  return result;
}

// Most credits to mm injection reversal goes to @Sinclairq.
__int64 __fastcall EAC::Callbacks::GatherShellcodeToMap(struct_a1 *pInputStruct, __int64 a2, __int64 a3)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  pOutputStruct = 0i64;
  if ( pInputStruct )
  {
    BaseAddress = EAC::Imports::NtAllocateVirtualMemoryWrapper(pInputStruct, 4096i64, a3, 64);
    pOutputStruct = BaseAddress;
    if ( BaseAddress )
    {
      EAC::Memory::CheckAddressBounds(BaseAddress, 4096i64);
      if ( pInputStruct->ImageType == 64 )
      {                                         // Thanks to @Sinclairq for convieniently writing the shellcode all neatly like this
        *v7 = EAC::Globals::ShellcodeBuffer64Bit;//                      0x48, 0x83, 0xEC, 0x28,        // SUB RSP, 0x28
                                                //                         0x4D, 0x31, 0xC0, // XOR R8, R8
                                                //                         0x48, 0x31, 0xD2, // XOR RDX, RDX
                                                //                         0x48, 0xFF, 0xC2, // INC RDX
                                                //                         0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 0
                                                //                         0xFF, 0xD0,        // CALL RAX
                                                //                         0x48, 0x83, 0xC4, 0x28, // ADD RSP, 0x28
                                                //                         0xC3 // RETN
        v7[23] = -1;
        *&v7[15] = pInputStruct->DllEntryPoint;
        *pOutputStruct = *v7;
        *(pOutputStruct + 16) = *&v7[16];
        *(pOutputStruct + 24) = 0xC48348D0;
        *(pOutputStruct + 28) = 0xC328;
      }
      else
      {
        v8 = EAC::Globals::ShellcodeBuffer32Bit;//                         0x6A, 0x00,        // PUSH 0
                                                //                         0x6A, 0x01,        // PUSH 1
                                                //                         0xFF, 0x74, 0xE4, 0x0C, // PUSH [RSP+0xC]
                                                //                         0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0
                                                //                         0xFF, 0xD0,        // CALL EAX
                                                //                         0xC2, 0x04, 0x00 // RETN 4
        *(&v8 + 9) = pInputStruct->DllEntryPoint;
        *pOutputStruct = v8;
        *(pOutputStruct + 16) = 4;
      }
    }
  }
  return pOutputStruct;
}

char __fastcall EAC::Callbacks::StartManualMap(ULONG64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax

  v2 = EAC::Imports::PsGetCurrentProcess();
  v3 = EAC::Imports::PsGetCurrentProcessID(v2);
  if ( !EAC::Globals::GameProcessID || v3 != EAC::Globals::GameProcessID )
    return 0;
  v4 = EAC::Imports::PsGetCurrentProcess();
  if ( a1 == EAC::Imports::GetProcessBaseAddress(v4) && !_InterlockedCompareExchange(&dword_140073D94, 1, 0) )
  {
    EAC::Callbacks::ManualMapImage();
    EAC::Callbacks::StoreImageDataForLaterValidation(a1);
    if ( Event )
      KeSetEvent(Event, 0, 0);
  }
  return 1;
}

void EAC::Callbacks::ManualMapImage()
{
  __m128 *pBuffer; // rdi
  bool v1; // bl
  ULONG_PTR RegionSize; // [rsp+50h] [rbp+8h] BYREF
  __int64 v3; // [rsp+58h] [rbp+10h] BYREF

  stru_140073DE8.Count = 1;
  stru_140073DE8.Owner = 0i64;
  stru_140073DE8.Contention = 0;
  KeInitializeEvent(&stru_140073DE8.Event, SynchronizationEvent, 0);
  EAC::Globals_BaseAddress = 0i64;
  RegionSize = 208128i64;
  if ( ZwAllocateVirtualMemory(0xFFFFFFFFFFFFFFFFi64, &EAC::Globals_BaseAddress, 0i64, &RegionSize, 0x3000u, 4u) >= 0 )
  {
    EAC::Callbacks::IsInUsermodeAddressSpace(EAC::Globals_BaseAddress, RegionSize, 1);
    EAC::Memory::memset(EAC::Globals_BaseAddress, 0, RegionSize);
    pBuffer = EAC::Memory::GetImageBuffer(&unk_140060E70, 24576i64);
    if ( pBuffer )
    {
      v1 = EAC::Callbacks::MapImage(
             pBuffer,
             0x6000ui64,
             &EAC::Globals_BaseAddressOfMappedModule,
             &v3,
             &EAC::Globals::EntryPointOfMappedModule,
             0i64,
             0i64);
      EAC::Memory::memset(pBuffer, 0, 0x6000ui64);
      EAC::Memory::ExFreePool(pBuffer);
      if ( v1 )
      {
        EAC::Memory::memset(EAC::Globals_BaseAddressOfMappedModule, 0, 0x1000ui64);
        EAC::Globals::StoredBaseAddressOfMappedModule = EAC::Globals_BaseAddressOfMappedModule;
      }
    }
  }
}

bool __fastcall EAC::Callbacks::MapImage(char *ImageBase, unsigned __int64 ImageSize, __int64 *MappedBase, _QWORD *MappedSize, _QWORD *MappedEntryPoint, _DWORD *ExceptionDirectory, _DWORD *ExceptionDirectorySize)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v7 = 0i64;
  v25 = 0i64;
  if ( !ImageBase || !ImageSize || !MappedBase || !MappedSize || !MappedEntryPoint )
    return 0;
  *MappedBase = 0i64;
  *MappedSize = 0i64;
  *MappedEntryPoint = 0i64;
  if ( ExceptionDirectory )
    *ExceptionDirectory = 0;
  if ( ExceptionDirectorySize )
    *ExceptionDirectorySize = 0;
  if ( EAC::Memory::GetPEHeader(ImageBase, ImageSize, &a3a, &v24) )
  {
    v8 = v24;
    v9 = v24->FileHeader.Machine;
    if ( v9 == 332 )
    {
      v10 = 32;
      v11 = v24->OptionalHeader.SizeOfImage;
      v22 = v11;
LABEL_18:
      v30 = v11;
      Buffer = EAC::Memory::ExAllocatePoolWithRandomTag2(v11);
      v7 = Buffer;
      v25 = Buffer;
      if ( Buffer )
      {
        EAC::Memory::memmove(Buffer, ImageBase, ImageSize);
        v13 = EAC::Memory::GenerateSeed(4, 16) << 12;
        LODWORD(v24) = v13;
        v26 = v13;
        Size = EAC::Memory::GenerateSeed(4, 16) << 12;
        v27 = Size;
        v14 = v11 + Size + v13;
        v16 = EAC::Imports::NtAllocateVirtualMemoryWrapper(v14, v14, v15, 4);
        v17 = v16;
        v28 = v16;
        if ( v16 )
        {
          if ( EAC::Imports::NtProtectVirtualMemoryWrapper(v16, v14, 64, v23) )
          {
            EAC::Callbacks::IsInUsermodeAddressSpace(v17, v13, 1);
            EAC::Callbacks::RandomizeRegion(v17, v13);
            if ( EAC::Imports::NtProtectVirtualMemoryWrapper(v17, v13, 32, v23) )
            {
              v18 = &v17[v22 + v13];
              EAC::Callbacks::IsInUsermodeAddressSpace(v18, Size, 1);
              EAC::Callbacks::RandomizeRegion(v18, Size);
              if ( EAC::Imports::NtProtectVirtualMemoryWrapper(v18, Size, 2, v23) )
              {
                v19 = &v17[v24];
                v28 = v19;
                v20 = &v7[*(a3a + 60)];
                v24 = v20;
                EAC::Callbacks::ResolveRelocations(v19, v7, v10, v20);
                if ( v10 == 64 )
                  *(v20 + 48) = v19;
                else
                  *(v20 + 52) = v19;
                if ( EAC::Callbacks::MapSections(v19, v7, v20) )
                {
                  EAC::Memory::CorrectSectionProtection(v19, v20);
                  *MappedBase = v19;
                  *MappedSize = v30;
                  *MappedEntryPoint = v19 + *(v20 + 40);
                }
              }
            }
          }
        }
      }
      goto END;
    }
    if ( v9 == 0x8664 )
    {
      v10 = 64;
      v11 = v24->OptionalHeader.SizeOfImage;
      v22 = v11;
      if ( ExceptionDirectory )
        *ExceptionDirectory = v24->OptionalHeader.DataDirectory[3].VirtualAddress;
      if ( ExceptionDirectorySize )
        *ExceptionDirectorySize = v8->OptionalHeader.DataDirectory[3].Size;
      goto LABEL_18;
    }
  }
END:
  if ( v7 )
    EAC::Memory::ExFreePool(v7);
  return *MappedEntryPoint != 0i64;
}

char __fastcall EAC::Callbacks::StoreImageDataForLaterValidation(ULONG64 a1)
{
  struct_v2 *pEntryPoint; // rax
  struct_v2 *v2; // rbx
  int v4; // [rsp+58h] [rbp+10h] BYREF
  __int64 v5; // [rsp+60h] [rbp+18h] BYREF
  struct_v2 *v6; // [rsp+68h] [rbp+20h] BYREF

  pEntryPoint = EAC::Memory::GetUsermodeProcessEntryPoint(a1);
  v2 = pEntryPoint;
  if ( pEntryPoint )
  {
    v6 = pEntryPoint;
    v5 = 23i64;
    LODWORD(pEntryPoint) = EAC::Imports::NtProtectVirtualMemory(-1i64, &v6, &v5, 0x40u, &v4);
    if ( pEntryPoint >= 0 )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(v2, 23i64, 1);
      v2->oword0 = xmmword_140060E58;
      v2->dword10 = 0;
      v2->word14 = 0xD0FF;
      v2->byte16 = 0xC3;
      *(&v2->oword0 + 1) = EAC::Globals::StoredBaseAddressOfMappedModule;
      *(&v2->oword0 + 6) = EAC::Globals_BaseAddress;
      *(&v2->oword0 + 11) = EAC::Globals_BaseAddressOfMappedModule;
      v2->dword10 = EAC::Globals::EntryPointOfMappedModule;
      byte_140073BE7 = 1;
      LOBYTE(pEntryPoint) = EAC::Imports::NtProtectVirtualMemoryWrapper(v2, 23i64, v4, &v4);
    }
  }
  return pEntryPoint;
}

void __fastcall EAC::Callbacks::MapAnotherImage(_QWORD *a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( a1 )
  {
    if ( EAC::Imports::PsGetCurrentProcess() == a1[1] )
    {
      v2 = EAC::Imports::PsGetCurrentProcess();
      v3 = sub_14000D244(v2);
      if ( v3 )
      {
        if ( !*(v3 + 2) )
        {
          *&v13 = 0x173C5BB8ECB50821i64;
          *(&v13 + 1) = 0xE19624F85FCC66AFui64;
          v14 = -434358038;
          v15 = 1143605379;
          v16 = -20;
          v4 = EAC::Memory::DecryptStr22(&v13, v17);
          v5 = EAC::Callbacks::GetUsermodeModuleWrapper(v4);
          memset(v17, 0, 0x1Aui64);
          if ( v5 )
          {
            v17[0] = -144606394;
            v17[1] = 1841444895;
            v17[2] = 1227386293;
            LOBYTE(v17[3]) = 96;
            v6 = EAC::Memory::DecryptStr13(v17, &v13);
            v7 = v6;
            v8 = a1[23];
            v9 = a1[22];
            if ( v9 && v8 && v6 )
            {
              if ( EAC::Memory::GetProcessArchitectureTypeWrapper(a1[23]) == 64 )
                EAC::Callbacks::MapAnotherImage64Bit(v9, v8, v7);
              else
                EAC::Callbacks::MapAnotherImage32Bit(v9, v8, v7);
            }
            memset(&v13, 0, 0xDui64);
            EAC::Callbacks::IsInUsermodeAddressSpace(a1[44], 60i64, 1);
            v10 = a1[44];
            v18 = *v10;
            v19 = *(v10 + 16);
            v13 = *(v10 + 32);
            v20 = *(v10 + 48);
            v11 = *(v10 + 56);
            *&v19 = 0i64;
            DWORD2(v19) = 0;
            EAC::Callbacks::IsInUsermodeAddressSpace(a1[23], 4096i64, 1);
            EAC::Callbacks::RandomizeRegion(a1[23], 4096i64);
            v12 = a1[44];
            *v12 = 0i64;
            *(v12 + 16) = v19;
            *(v12 + 32) = v13;
            *(v12 + 48) = v20;
            *(v12 + 56) = v11;
          }
        }
      }
    }
  }
}


```

`EAC-Reversal-main/integrity.cpp`:

```cpp
// Thanks to https://github.com/ch4ncellor/EAC-Reversal/issues/1
char EAC::Callbacks::ValidateExports()
{
  char v0; // bl
  __int64 PsProcessType; // rbp
  __int64 MmGetSystemRoutineAddress; // rdi
  __int64 ZwDeleteKey; // rsi
  __int64 PsProcessTypeHMAP; // r14
  __int64 ZwDeleteKeyHMAP; // r15
  __int64 MmGetSystemRoutineAddressHMAP; // rax

  v0 = 0;
  PsProcessType = EAC::Memory::FindExport(&PsProcessTypeHash);
  MmGetSystemRoutineAddress = EAC::Memory::FindExport(&MmGetSystemRoutineAddressHash);
  ZwDeleteKey = EAC::Memory::FindExport(&ZwDeleteKeyHash);
  PsProcessTypeHMAP = EAC::Memory::LookupImportHMAP(1i64);
  ZwDeleteKeyHMAP = EAC::Memory::LookupImportHMAP(2i64);
  MmGetSystemRoutineAddressHMAP = EAC::Memory::LookupImportHMAP(0i64);
  if ( PsProcessType
    && MmGetSystemRoutineAddress
    && ZwDeleteKey
    && ZwDeleteKey == ZwDeleteKeyHMAP
    && PsProcessType == PsProcessTypeHMAP
    && MmGetSystemRoutineAddress == MmGetSystemRoutineAddressHMAP )
  {
    return 1;
  }
  EAC::Callbacks::ReportViolation(0xE7F46F3i64, 0i64, 0i64);
  return v0;
}

LONG_PTR __fastcall EAC::Callbacks::ValidatePreviouslyMappedImage(char **a1, int a2, void *a3, __int64 a4)
{
  LONG_PTR result; // rax
  char *v8; // r14
  void *v9; // rcx
  unsigned __int64 v10; // r8
  void *v11; // rdx
  unsigned __int64 i; // r8
  bool v13; // [rsp+30h] [rbp-88h]
  PVOID v14; // [rsp+38h] [rbp-80h] BYREF
  PVOID Object[3]; // [rsp+40h] [rbp-78h] BYREF
  _LARGE_INTEGER Timeout; // [rsp+58h] [rbp-60h] BYREF
  _OWORD *v17; // [rsp+60h] [rbp-58h]
  char v18[56]; // [rsp+68h] [rbp-50h] BYREF
  void *retaddr; // [rsp+B8h] [rbp+0h] BYREF
  PVOID v20; // [rsp+D0h] [rbp+18h] BYREF
  __int64 v21; // [rsp+D8h] [rbp+20h]

  result = &retaddr;
  v21 = a4;
  v20 = a3;
  v17 = a4;
  v13 = 0;
  Object[0] = 0i64;
  v14 = 0i64;
  if ( a4 )
  {
    result = EAC::Memory::memset((a4 + 8), 0, 0xA98ui64);
    *a4 = 1;
    *(a4 + 4) = 6;
    if ( a1 && a1[1] && *a1 && *(a1 + 1) && a2 )
    {
      result = MEMORY[0xFFFFF7800000026C];
      if ( MEMORY[0xFFFFF7800000026C] < 6u
        || MEMORY[0xFFFFF7800000026C] == 6 && (result = 0xFFFFF78000000270ui64, !MEMORY[0xFFFFF78000000270]) )
      {
        *(a4 + 4) = 0;
      }
      else
      {
        result = EAC::Globals::GameProcessID;
        if ( EAC::Globals::GameProcessID && byte_140073BE7 )
        {
          result = EAC::Imports::PsLookupProcessByProcessID(EAC::Globals::GameProcessID, &v20);
          if ( result >= 0 )
          {
            v8 = sub_14003E130();
            Object[2] = v8;
            if ( v8 && EAC::Callbacks::KeStackAttachProcess(v20, v18) )
            {
              if ( EAC::Globals::StoredBaseAddressOfMappedModule )
              {
                EAC::Callbacks::IsInUsermodeAddressSpace(EAC::Globals::StoredBaseAddressOfMappedModule, 4i64, 1);
                v9 = *EAC::Globals::StoredBaseAddressOfMappedModule;
                if ( v9 )
                {
                  if ( ObReferenceObjectByHandle(v9, 2u, ExEventObjectType, 1, Object, 0i64) >= 0 )
                  {
                    EAC::Callbacks::IsInUsermodeAddressSpace(v8, 0xCB4i64, 1);
                    if ( ObReferenceObjectByHandle(*(v8 + 1), 0x100000u, ExEventObjectType, 1, &v14, 0i64) >= 0 )
                    {
                      *(v8 + 2) = a2;
                      v10 = 518i64;
                      if ( *a1 < 0x206ui64 )
                        v10 = *a1;
                      EAC::Memory::memmove(v8 + 12, a1[1], v10);
                      *(v8 + 265) = 0;
                      v11 = 0i64;
                      for ( i = 0i64; ; ++i )
                      {
                        Object[1] = v11;
                        if ( i >= 0x208 )
                          break;
                        v8[v11 + 12] += 64 - 96 * v11;
                        v11 = (i + 1);
                      }
                      EAC::Memory::memset((v8 + 532), 0, 0xAA0ui64);
                      *(v8 + 133) = 1;
                      *(v8 + 134) = 7;
                      *v8 = 1;
                      v13 = 1;
                    }
                    else
                    {
                      v14 = 0i64;
                    }
                  }
                  else
                  {
                    Object[0] = 0i64;
                  }
                }
              }
              EAC::Callbacks::KeUnstackDetachProcess(v20, v18);
              *(a4 + 4) = 7;
              if ( v13 )
              {
                KeSetEvent(Object[0], 0, 1u);
                Timeout.QuadPart = -300000000i64;
                v13 = KeWaitForSingleObject(v14, UserRequest, 0, 0, &Timeout) == 0;
              }
              if ( v14 )
                ObfDereferenceObject(v14);
              if ( Object[0] )
                ObfDereferenceObject(Object[0]);
            }
            if ( v13 )
            {
              if ( EAC::Callbacks::KeStackAttachProcess(v20, v18) )
              {
                EAC::Callbacks::IsInUsermodeAddressSpace(v8, 3252i64, 1);
                EAC::Memory::memmove(v17, v8 + 532, 0xAA0ui64);
                EAC::Memory::memset((v8 + 532), 0, 0xAA0ui64);
                EAC::Callbacks::KeUnstackDetachProcess(v20, v18);
              }
            }
            result = ObfDereferenceObject(v20);
          }
        }
        else
        {
          *(a4 + 4) = 6;
        }
      }
    }
    else
    {
      *(a4 + 4) = 4;
    }
  }
  return result;
}

void __fastcall EAC::Callbacks::DetectAPCLevelIRQL(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v3; // rbx
  void *v4; // rbp
  struct _FAST_MUTEX *v5; // rcx
  __int64 v6; // rbx

  if ( !a1 )
    return;
  v1 = *(a1 + 536);
  v3 = v1;
  if ( !v1 )
    goto LABEL_5;
  if ( KeGetCurrentIrql() <= APC_LEVEL )
  {
    *(v1 + 32) = 1;
    v3 = *(a1 + 536);
LABEL_5:
    if ( !v3 )
      return;
  }
  if ( KeGetCurrentIrql() <= APC_LEVEL )
  {
    ExAcquireFastMutex((v3 + 40));
    v4 = *v3;
    v5 = (v3 + 40);
    v6 = *(v3 + 8);
    ExReleaseFastMutex(v5);
    if ( v6 )
    {
      EAC::Callbacks::ReportViolation_1(a1, 0x50FB7A72i64, v4, (2 * v6 + 2), 0i64);
      memset(v4, 0, 2i64 * (v6 + 1));
    }
  }
}

```

`EAC-Reversal-main/misc.cpp`:

```cpp
bool EAC::Callbacks::EnableTSX()
{
  unsigned __int64 v0; // r9
  unsigned __int64 newtsx; // rax

  v0 = __readmsr(0x122u);
  _disable();
  __writemsr(0x122u, v0 & 0xFFFFFFFFFFFFFFFEui64);//  MSR_IA32_TSX_CTRL
  newtsx = __readmsr(0x122u);
  __writemsr(0x122u, v0);                       //  MSR_IA32_TSX_CTRL
  _enable();
  return (newtsx & 1) == 0;
}

char __fastcall EAC::Memory::VMRead_Wrapper(__int64 _RCX, __int64 _RDX)
{
  char v2; // cf
  char v3; // zf

  __asm { vmread  qword ptr [rdx], rcx }
  return v2 + v2 + v3;
}

char EAC::Callbacks::DetectHyperVisor()
{
  char v1; // [rsp+50h] [rbp+8h] BYREF

  EAC::Memory::VMRead_Wrapper(0i64, &v1);
  return 1;
}

unsigned __int64 EAC::Callbacks::GetstHyperIface()
{
  return __readmsr(0x40000001u);                // Hypervisor interface
}

bool EAC::Callbacks::DSEFixDetection()
{
  int nFlags; // ebx
  _DWORD *pooltagInformation; // rax
  void *v2; // rdx
  unsigned int v3; // er9
  unsigned int v4; // er8
  _DWORD *entry; // rcx
  int v6; // eax

  nFlags = 0;
  pooltagInformation = EAC::Callbacks::QuerySystemInformation(0x16u, 0x10000u, 0x100000u, 0i64);
  v2 = pooltagInformation;
  if ( pooltagInformation )
  {
    v3 = *pooltagInformation;
    v4 = 0;
    if ( *pooltagInformation )
    {
      entry = pooltagInformation + 3;
      do
      {
        if ( nFlags == 3 )
          break;
        v6 = *(entry - 1);
        if ( v6 == 'rcIC' )
        {
          if ( *entry > entry[1] )
            nFlags |= 1u;
        }
        else if ( v6 == 'csIC' && *entry > entry[1] )// called by CiValidateImageHeader
        {
          nFlags |= 2u;
        }
        ++v4;
        entry += 10;
      }
      while ( v4 < v3 );
    }
    EAC::Memory::ExFreePool(v2);
  }
  else
  {
    nFlags = 3;
  }
  return nFlags == 3;
}

char __fastcall EAC::Callbacks::WriteGameCrashInfoToRegistry(PVOID ValueData)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  LOBYTE(v2) = 0;
  HIDWORD(v30) = 0;
  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  if ( ValueData )
  {
    v2 = EAC::Imports::PsGetCurrentProcess();
    if ( v2 == *(ValueData + 1) )
    {
      v3 = EAC::Imports::PsGetCurrentProcess();
      v4 = EAC::Memory::ResolveImportWrapper(qword_140074158, &qword_140074158, 0i64);
      LODWORD(v2) = v4 ? v4(v3) : 0xC0000002;
      v28 = v2;
      if ( v2 || *(ValueData + 137) )
      {
        v30 = MEMORY[0xFFFFF78000000014];
        v5 = IoGetCurrentProcess();
        v26[0] = PsGetProcessCreateTimeQuadPart(v5);
        v29 = EAC::Memory::GetCurrentTime(*(ValueData + 6));
        v27 = *(ValueData + 4);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameState",
          4u,
          ValueData + 548,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashGameID",
          4u,
          ValueData,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashPID",
          4u,
          &v27,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashCreateTime",
          0xBu,
          v26,
          8u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashExitTime",
          0xBu,
          &v30,
          8u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashExitStatus",
          4u,
          &v28,
          4u);
        LOBYTE(v2) = RtlWriteRegistryValue(
                       0,
                       L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                       L"ErrRpt_GameCrashInfo01",
                       4u,
                       &v29,
                       4u);
        v6 = *(ValueData + 23);
        v7 = v6 + *(ValueData + 24);
        v8 = *(ValueData + 44);
        if ( v8 )
        {
          LOBYTE(v2) = EAC::Callbacks::IsInUsermodeAddressSpace(v8, 60i64, 1);
          v9 = *(ValueData + 44);
          v10 = 0i64;
          v18 = 0i64;
          if ( v9 )
          {
            for ( i = 0i64; ; ++i )
            {
              v26[1] = i;
              if ( i >= 8 )
                break;
              LOBYTE(v2) = *(v9 + 4 * i + 28) ^ 0x90;
              *(&v18 + i) = v2;
              v10 = v18;
            }
          }
          if ( v10 )
          {
            LOBYTE(v2) = EAC::Callbacks::IsInUsermodeAddressSpace(v10, 40i64, 1);
            v12 = *(v10 + 24);
            v13 = *(v10 + 32);
            if ( v12 )
            {
              LOBYTE(v2) = EAC::Callbacks::IsInUsermodeAddressSpace(*(v10 + 24), 64i64, 1);
              if ( *v12 )
              {
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo02",
                  4u,
                  (v12 + 12),
                  4u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo03",
                  0xBu,
                  (v12 + 16),
                  8u);
                v14 = *(v12 + 16);
                if ( v14 <= v6 || v14 > v7 )
                  v15 = 0i64;
                else
                  v15 = v14 - v6;
                v19 = v15;
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo04",
                  0xBu,
                  &v19,
                  8u);
                if ( *(v12 + 28) )
                  v20 = *(v12 + 32);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo05",
                  0xBu,
                  &v20,
                  8u);
                if ( *(v12 + 28) >= 2u )
                  v21 = *(v12 + 40);
                LOBYTE(v2) = RtlWriteRegistryValue(
                               0,
                               L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                               L"ErrRpt_GameCrashInfo06",
                               0xBu,
                               &v21,
                               8u);
              }
            }
            if ( v13 )
            {
              LOBYTE(v2) = EAC::Callbacks::IsInUsermodeAddressSpace(v13, 52i64, 1);
              if ( *v13 )
              {
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo07",
                  4u,
                  (v13 + 12),
                  4u);
                v16 = *(v13 + 16);
                if ( v16 )
                {
                  v22 = *(v13 + 20);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 2 )
                {
                  v23 = *(v13 + 28);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 3 )
                {
                  v24 = *(v13 + 36);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 4 )
                  v25 = *(v13 + 44);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo08",
                  0xBu,
                  &v22,
                  8u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo09",
                  0xBu,
                  &v23,
                  8u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo10",
                  0xBu,
                  &v24,
                  8u);
                LOBYTE(v2) = RtlWriteRegistryValue(
                               0,
                               L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                               L"ErrRpt_GameCrashInfo11",
                               0xBu,
                               &v25,
                               8u);
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

__int64 __fastcall EAC::Callbacks::TimingCheck()
{
  __int64 v0; // r12
  __int64 v1; // r13
  __int64 v2; // r14
  __int64 v3; // r15
  __int64 v4; // r10
  __int64 v5; // r11
  __int64 v6; // r9
  __int64 v7; // rdi
  unsigned __int64 v8; // r8
  unsigned __int64 v14; // rax
  __int64 v15; // rbx
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // kr00_8
  _QWORD v20[17]; // [rsp-A8h] [rbp-F8h] BYREF
  _QWORD v21[8]; // [rsp-20h] [rbp-70h] BYREF
  __int128 v22; // [rsp+20h] [rbp-30h]
  __int128 v23; // [rsp+30h] [rbp-20h]
  __int64 v24; // [rsp+40h] [rbp-10h]
  __int64 vars0; // [rsp+50h] [rbp+0h] BYREF

  v22 = 0i64;
  v24 = 0i64;
  v23 = 0i64;
  v4 = KeGetCurrentIrql();
  __writecr8(0xFui64);
  v5 = *(&v23 + 1);
  v6 = v24 + 100;
  v7 = v6;
  do
  {
    v8 = __rdtsc();
    _RAX = 1i64;
    __asm { cpuid }
    *&v22 = __PAIR64__(_RBX, _RAX);
    *(&v22 + 1) = __PAIR64__(_RDX, _RCX);
    v14 = __rdtsc();
    v5 += ((HIDWORD(v14) << 32) | v14) - v8;
    --v7;
  }
  while ( v7 );
  v15 = v24;
  *(&v23 + 1) = v5;
  do
  {
    v16 = __rdtsc();
    v17 = __rdtsc();
    v15 += ((HIDWORD(v17) << 32) | v17) - v16;
    --v6;
  }
  while ( v6 );
  v24 = v15;
  __writecr8(v4);
  v21[3] = -1074443376i64;
  v21[2] = -2003135156i64;
  v18 = __readeflags();
  v21[1] = v18;
  v21[0] = 15i64;
  v20[16] = v21;
  v20[15] = HIDWORD(v17) << 32;
  v20[14] = v5;
  v20[13] = v4;
  v20[12] = 0i64;
  v20[11] = v1;
  v20[10] = qword_140052A70;
  v20[9] = v4;
  v20[8] = v15;
  v20[7] = &vars0;
  v20[6] = v0;
  v20[5] = 0i64;
  v20[4] = v8;
  v20[3] = v2;
  v20[2] = v3;
  v20[1] = 0i64;
  v20[0] = 0i64;
  return sub_1418A2D0C(v20);
}

void __fastcall EAC::Callbacks::HandleUsermodeOperation(__int64 a1, __int64 a2, _DWORD *a3)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  pProcess = 0i64;
  nCallbackType = 0i64;
  v5 = *(a2 + 32);
  if ( !v5 )
    goto LABEL_49;
  v6 = *(a2 + 16);
  if ( v6 <= 8 )
    goto LABEL_49;
  if ( *(a1 + 112) != v5 )
    goto LABEL_49;
  if ( *(a2 + 8) != v6 )
    goto LABEL_49;
  EAC::Callbacks::IsInUsermodeAddressSpace(v5, v6, 1);
  v7 = EAC::Memory::ExAllocatePoolWithRandomTag2(v6);
  nCallbackType = v7;
  if ( !v7 )
    goto LABEL_49;
  EAC::Memory::memmove(v7, v5, v6);
  pProcess = EAC::Memory::GetPEPROCESS(*(nCallbackType + 4));
  if ( !pProcess )
    goto LABEL_49;
  EAC::Imports::PsGetCurrentProcess();
  if ( !sub_140012D18() )
    goto LABEL_49;
  if ( *nCallbackType == 1 )
  {
    if ( v6 != 40 )
      goto LABEL_49;
    v12 = EAC::Memory::AllocateMemoryInProcess(pProcess[1], nCallbackType);
  }
  else if ( *nCallbackType == 2 )
  {
    if ( v6 != 40 )
      goto LABEL_49;
    v12 = sub_140045628(pProcess[1], nCallbackType);
  }
  else if ( *nCallbackType == 3 )
  {
    if ( v6 != 40 )
      goto LABEL_49;
    v12 = sub_14004573C(pProcess[1], nCallbackType);
  }
  else if ( *nCallbackType == 4 )
  {
    if ( v6 != 32 )
      goto LABEL_49;
    v12 = EAC::Memory::ProtectMemoryInProcess(pProcess[1], nCallbackType);
  }
  else if ( *nCallbackType == 5 )
  {
    if ( v6 != 28 )
      goto LABEL_49;
    v12 = EAC::Memory::FreeMemoryInProcess(pProcess[1], nCallbackType);
  }
  else
  {
    if ( *nCallbackType != 6 )
    {
      if ( *nCallbackType == 7 )
      {
        if ( v6 != 36 )
          goto LABEL_49;
        v8 = pProcess[1];
        v9 = 0;
        v15 = 0i64;
        if ( !v8 )
          goto LABEL_25;
        if ( !*(nCallbackType + 8) || !*(nCallbackType + 20) || !*(nCallbackType + 28) )
          goto LABEL_49;
        if ( !EAC::Callbacks::KeStackAttachProcess(v8, v13) )
          goto LABEL_25;
        if ( EAC::Imports::ZwQueryVirtualMemory(
               -1i64,
               *(nCallbackType + 8),
               *(nCallbackType + 16),
               *(nCallbackType + 20),
               *(nCallbackType + 28),
               &v15) >= 0 )
        {
          *(nCallbackType + 32) = v15;
          v9 = 1;
        }
      }
      else
      {
        if ( *nCallbackType != 8 || v6 != 36 )
          goto LABEL_49;
        v8 = pProcess[1];
        v9 = 0;
        if ( !v8 )
          goto LABEL_25;
        if ( !*(nCallbackType + 12) || !*(nCallbackType + 20) || !*(nCallbackType + 24) || *(nCallbackType + 32) )
          goto LABEL_49;
        if ( !EAC::Callbacks::KeStackAttachProcess(v8, v13) )
          goto LABEL_25;
        v9 = EAC::Imports::NtSetInformationVirtualMemory(
               v10,
               *(nCallbackType + 8),
               *(nCallbackType + 20),
               *(nCallbackType + 12),
               *(nCallbackType + 24),
               *(nCallbackType + 32)) >= 0;
      }
      EAC::Callbacks::KeUnstackDetachProcess(v8, v13);
LABEL_25:
      v11 = !v9;
      goto LABEL_47;
    }
    if ( v6 != 36 )
      goto LABEL_49;
    v12 = EAC::Memory::ZwFlushVirtualMemoryWrapper(pProcess[1], nCallbackType);
  }
  v11 = v12 == 0;
LABEL_47:
  if ( !v11 )
  {
    EAC::Memory::memmove(v5, nCallbackType, v6);
    *a3 = v6;
  }
LABEL_49:
  if ( nCallbackType )
    EAC::Memory::ExFreePool(nCallbackType);
  if ( pProcess )
    EAC::Memory::ReleasePEPROCESS(pProcess);
}

bool __fastcall EAC::Callbacks::CheckForPhysicalHandle(__int64 a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( !a1 )
    return 0;
  v2 = qword_140073320 == 0;
  *a1 = 0i64;
  *(a1 + 16) = 0i64;
  if ( v2 || _InterlockedCompareExchange(&dword_140074238, 1, 0) )
    return 0;
  v3 = EAC::Callbacks::QuerySystemInformation(0x10u, 0x80000u, 0x1000000u, 0i64);
  if ( !v3 )
    goto LABEL_41;
  v21[0] = 1916479917;
  v22 = 7074;
  v4 = 44i64;
  v21[1] = -1077771171;
  *&physMemDecrypted[2] = 0i64;
  DWORD2(physMemDecrypted[2]) = 0;
  v5 = 1920936433;
  WORD6(physMemDecrypted[2]) = 0;
  v6 = 0i64;
  v21[2] = -456920151;
  v21[3] = 1354280435;
  v21[4] = -1213991906;
  v21[5] = -252238082;
  v21[6] = -16337681;
  v21[7] = 1002680223;
  v21[8] = 38635846;
  v21[9] = -1183450918;
  v21[10] = -1816555846;
  physMemDecrypted[0] = 0i64;
  physMemDecrypted[1] = 0i64;
  v29 = v21;
  v30 = physMemDecrypted;
  do
  {
    *(v30 + v6 * 4) = v29[v6] ^ v5;
    ++v6;
    v5 = __ROR4__(((v5 ^ (v5 << 13)) >> 17) ^ v5 ^ (v5 << 13) ^ (32 * (((v5 ^ (v5 << 13)) >> 17) ^ v5 ^ (v5 << 13))), 1);
  }
  while ( v6 < 11 );
  v29 = v21;
  v30 = physMemDecrypted;
  do
  {
    v7 = v5;
    v5 >>= 8;
    *(v30 + v4) = *(v29 + v4) ^ v7;
    ++v4;
  }
  while ( v4 < 0x2E );
  EAC::Memory::InitializeUnicodeStringWithCString(szPhysMem, physMemDecrypted);// \Device\PhysicalMemory
  ObjectAttributes.Length = 48;
  ObjectAttributes.ObjectName = szPhysMem;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  *&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( ZwOpenSection(&SectionHandle, 1u, &ObjectAttributes) >= 0 )
  {
    v8 = EAC::Imports::ObReferenceObjectByHandle(SectionHandle, 1u, 0i64, 0, &EAC::Globals::Object, 0i64);
    v9 = EAC::Globals::Object;
    if ( v8 < 0 )
      v9 = 0i64;
    EAC::Globals::Object = v9;
    ZwClose(SectionHandle);
  }
  v10 = 0i64;
  memset(physMemDecrypted, 0, 0x2Eui64);
  if ( !*v3 )
    goto LABEL_37;
  sectionObjectType = EAC::Globals::Object;
  v12 = (v3 + 2);
  v13 = 0;
  while ( 1 )
  {
    if ( v12[1] != sectionObjectType || !sectionObjectType || *v12 == 4 )
      goto LABEL_21;
    v14 = *(v12 + 3);
    v15 = EAC::Memory::ResolveImportWrapper(qword_140073D58, &qword_140073D58, 0i64);
    if ( !v15 || !v15(v14) )
      break;
    sectionObjectType = EAC::Globals::Object;
LABEL_21:
    ++v10;
    v12 += 3;
    if ( v10 >= *v3 )
      goto LABEL_38;
  }
  v16 = EAC::Memory::GetProcessImageFilename(*v12, v24);
  if ( v16 )
    v13 = sub_140021608(v24, v26);
  v17 = -v13;
  v18 = (v26 & -(v17 != 0));
  if ( !*(a1 + 4) )
  {
    *a1 = 1;
    *(a1 + 4) = 13;
    if ( v18 )
    {
      if ( *((v26 & -(v17 != 0)) + 8) && *v18 && *((v26 & -(v17 != 0)) + 2) && !*(a1 + 8) )
      {
        if ( a1 == 0xFFFFFFFFFFFFFFF0ui64 )
          v19 = 0;
        else
          v19 = EAC::Memory::AllocateCopyUnicodeString(a1 + 0x10, v18, *v18);
        *(a1 + 8) = v19;
      }
    }
  }
  if ( v16 )
    EAC::Memory::FreeUnicdeString(v24);
LABEL_37:
  sectionObjectType = EAC::Globals::Object;
LABEL_38:
  if ( sectionObjectType )
  {
    ObfDereferenceObject(sectionObjectType);
    EAC::Globals::Object = 0i64;
  }
  EAC::Memory::ExFreePool(v3);
LABEL_41:
  _InterlockedExchange(&dword_140074238, 0);
  return *(a1 + 4) != 0;
}

```

`EAC-Reversal-main/modules.cpp`:

```cpp
void __fastcall EAC::Callbacks::CheckForManualMappedModule(ULONG64 *pAnomalyHashStruct)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  if ( pAnomalyHashStruct )
  {
    v11 = 0i64;
    v2 = pAnomalyHashStruct[1];
    if ( v2 )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(pAnomalyHashStruct[1], 4096i64, 1);
      if ( EAC::Memory::GetPEHeader(v2, 0x1000ui64, 0i64, &v12) )
      {
        v3 = v12;
        v4 = &v12->OptionalHeader + v12->FileHeader.SizeOfOptionalHeader;
        for ( i = 0; i < v3->FileHeader.NumberOfSections && *(pAnomalyHashStruct + 10) != 32; ++i )
        {
          EAC::Callbacks::IsInUsermodeAddressSpace(v4, 40i64, 1);
          v6 = *(v4 + 3);
          if ( v6 )
          {
            v7 = *(v4 + 2);
            if ( v7 )
            {
              if ( (*(v4 + 9) & 0x2000000) == 0 )
              {
                v8 = *v4;
                if ( (*v4 != 'ler.' || *(v4 + 2) != 'co') && v8 != 'slt.' )
                {
                  if ( v8 != 'rsr.' || (v9 = 1, v4[4] != 'c') )
                    v9 = 0;
                  BYTE12(v11) = v9;
                  v10 = v9;
                  if ( (*(*pAnomalyHashStruct + 26) & 0x60) != 0 )
                    v10 = 1;
                  BYTE12(v11) = v10;
                  *&v11 = v2 + v6;
                  DWORD2(v11) = v7;
                  EAC::Callbacks::IsInUsermodeAddressSpace(v2 + v6, v7, 1);
                  EAC::Callbacks::SetHashOfAnomaly(&v11, pAnomalyHashStruct);
                }
              }
            }
          }
          v4 += 40;
        }
      }
    }
  }
}

char __fastcall EAC::Callbacks::CheckForBlacklistedModuleNamesWrapper(__int64 a1)
{
  char v2; // si
  __int64 v3; // rax
  PVOID *v4; // rbx
  unsigned int v5; // edi
  __int64 *v6; // r14
  __int64 v7; // rdi

  v2 = 0;
  v3 = EAC::Memory::ExAllocatePoolWithRandomTag2(4096i64);
  v4 = v3;
  if ( v3 )
  {
    v5 = sub_14000D368(v3);
    if ( v5 )
    {
      ObfDereferenceObject(*v4);
      if ( v5 > 1 )
      {
        v6 = (v4 + 1);
        v7 = v5 - 1;
        do
        {
          if ( !v2 && !sub_140006810(a1) )
            v2 = EAC::Callbacks::CheckForBlacklistedModuleNames(*v6);
          ObfDereferenceObject(*v6++);
          --v7;
        }
        while ( v7 );
      }
    }
    EAC::Memory::ExFreePool(v4);
  }
  return v2;
}

char __fastcall EAC::Callbacks::CheckForBlacklistedModuleNames(__int64 a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  bDidFindBlacklistedModule = 0;
  if ( !EAC::Callbacks::KeStackAttachProcess(a1, v64) )
    return bDidFindBlacklistedModule;
  v42[0] = 404169542;
  v43 = 24194;
  v3 = 20i64;
  v42[1] = 1671252913;
  *&v55[16] = 0;
  *&v55[20] = 0;
  v4 = 409084674;
  v42[2] = 1997423613;
  v42[3] = -2365392;
  v5 = 0i64;
  v42[4] = 1080899897;
  *v55 = 0i64;
  do
  {
    *&v55[v5 * 4] = v42[v5] ^ v4;
    ++v5;
    v4 = _byteswap_ulong(((v4 ^ (v4 << 13)) >> 17) ^ v4 ^ (v4 << 13) ^ (32
                                                                      * (((v4 ^ (v4 << 13)) >> 17) ^ v4 ^ (v4 << 13))));
  }
  while ( v5 < 5 );
  do
  {
    v6 = v4;
    v4 >>= 8;
    v55[v3] = *(v42 + v3) ^ v6;
    ++v3;
  }
  while ( v3 < 0x16 );
  v7 = 1;
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v55) )// Dumper.dll
  {
    v40[0] = 570211008;
    v41 = -31209;
    v40[1] = -1022839618;
    *&v54[16] = 0;
    v8 = 563133063;
    v40[2] = -738526335;
    v40[3] = 1285740581;
    v9 = 0i64;
    *v54 = 0i64;
    do
    {
      *&v54[v9 * 4] = v40[v9] ^ v8;
      ++v9;
      v8 = -2531012 - 214013 * v8;
    }
    while ( v9 < 4 );
    for ( i = 16i64; i < 0x12; ++i )
    {
      v11 = v8;
      v8 >>= 8;
      v54[i] = *(v40 + i) ^ v11;
    }
    v7 = 3;
    if ( EAC::Callbacks::GetUsermodeModuleWrapper(v54) )// Glob.dll
    {
      v48[0] = 316787955;
      *&v59[16] = 0i64;
      v48[1] = 679437834;
      v48[2] = -1174755841;
      v12 = 392827509;
      v48[3] = -496974842;
      v13 = 0i64;
      v48[4] = 692469395;
      v48[5] = -508318795;
      *v59 = 0i64;
      do
      {
        v12 = _byteswap_ulong(((v12 ^ (v12 >> 7)) << 9) ^ v12 ^ (v12 >> 7) ^ ((((v12 ^ (v12 >> 7)) << 9) ^ v12 ^ (v12 >> 7)) >> 13));
        *&v59[v13 * 4] = v48[v13] ^ v12;
        ++v13;
      }
      while ( v13 < 6 );
      v7 = 7;
      if ( EAC::Callbacks::GetUsermodeModuleWrapper(v59) )// mswsock.dll
      {
        v49[0] = 1462885684;
        *&v58[16] = 0i64;
        v49[1] = -402286035;
        v49[2] = -1169349665;
        v14 = 2101152273;
        v49[3] = -538151392;
        v15 = 0i64;
        v49[4] = -274603261;
        v49[5] = 488391802;
        *v58 = 0i64;
        do
        {
          v14 = __ROR4__(
                  ((v14 ^ (v14 << 13)) >> 7) ^ v14 ^ (v14 << 13) ^ ((((v14 ^ (v14 << 13)) >> 7) ^ v14 ^ (v14 << 13)) << 17),
                  4);
          *&v58[v15 * 4] = v49[v15] ^ v14;
          ++v15;
        }
        while ( v15 < 6 );
        v7 = 15;
        if ( EAC::Callbacks::GetUsermodeModuleWrapper(v58) )//  perl512.dll
        {
          v16 = 1;
LABEL_19:
          v7 &= 0xFFFFFFF7;
          memset(v58, 0, sizeof(v58));
          goto LABEL_20;
        }
      }
    }
  }
  v16 = 0;
  if ( (v7 & 8) != 0 )
    goto LABEL_19;
LABEL_20:
  if ( (v7 & 4) != 0 )
  {
    v7 &= 0xFFFFFFFB;
    memset(v59, 0, sizeof(v59));
  }
  if ( (v7 & 2) != 0 )
  {
    v7 &= 0xFFFFFFFD;
    memset(v54, 0, sizeof(v54));
  }
  v17 = v7 & 0xFFFFFFFE;
  memset(v55, 0, sizeof(v55));
  if ( v16 )
    goto LABEL_54;
  v46[0] = -1918767450;
  v47 = 30032;
  v46[1] = 1716648254;
  v18 = v17 | 0x10;
  v46[2] = -2001414969;
  *&v61[32] = 0;
  v19 = -1915949360;
  v46[3] = -682439642;
  v46[4] = 1479981800;
  v20 = 0i64;
  v46[5] = 747063356;
  v46[6] = -796488994;
  v46[7] = 1471440201;
  *v61 = 0i64;
  *&v61[16] = 0i64;
  do
  {
    v21 = v46[v20] ^ v19;
    v19 = __ROR4__(23449 * v19 + 10042149, 2);
    *&v61[v20 * 4] = v21;
    ++v20;
  }
  while ( v20 < 8 );
  for ( j = 32i64; j < 0x22; ++j )
  {
    v23 = v19;
    v19 >>= 8;
    v61[j] = *(v46 + j) ^ v23;
  }
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v61) )// vmclientcore.dll
    goto LABEL_44;
  *&v57[16] = 0i64;
  *&v57[24] = 0;
  v18 |= 0x20u;
  v51[0] = 1064449107;
  *v57 = 0i64;
  v51[1] = 1638685829;
  v24 = -1269883487;
  v51[2] = 1103840582;
  v25 = 0i64;
  v51[3] = -554947786;
  v51[4] = -679930175;
  v51[5] = -277811938;
  v51[6] = 434714035;
  do
  {
    v24 = ~(((v24 ^ (v24 << 13)) >> 7) ^ v24 ^ (v24 << 13) ^ ((((v24 ^ (v24 << 13)) >> 7) ^ v24 ^ (v24 << 13)) << 17));
    *&v57[v25 * 4] = v51[v25] ^ v24;
    ++v25;
  }
  while ( v25 < 7 );
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v57) )// vmwarewui.dll
    goto LABEL_44;
  v44[0] = -1427003179;
  v45 = 16042;
  v18 |= 0x40u;
  v44[1] = -1341968668;
  *&v56[16] = 0i64;
  *&v56[24] = 0;
  v26 = -1432835933;
  *&v56[28] = 0;
  v27 = 0i64;
  v44[2] = 421141858;
  v44[3] = 670852926;
  v44[4] = -1407531516;
  v44[5] = 386858880;
  v44[6] = -1587770893;
  *v56 = 0i64;
  do
  {
    *&v56[v27 * 4] = v44[v27] ^ v26;
    ++v27;
    v26 = -4486779 - 60741 * v26;
  }
  while ( v27 < 7 );
  for ( k = 28i64; k < 0x1E; ++k )
  {
    v29 = v26;
    v26 >>= 8;
    v56[k] = *(v44 + k) ^ v29;
  }
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v56) )// virtualbox.dll
    goto LABEL_44;
  v52[0] = 1246573564;
  v52[1] = -1435646966;
  v62[0] = 0i64;
  v52[2] = -1583470474;
  v18 |= 0x80u;
  v62[1] = 0i64;
  v52[3] = 1413339661;
  v30 = -678343082;
  v52[4] = 266555639;
  v31 = 0i64;
  v52[5] = 963523025;
  v52[6] = -972779894;
  v52[7] = 1931803890;
  do
  {
    v30 = _byteswap_ulong(((v30 ^ (v30 << 13)) >> 7) ^ v30 ^ (v30 << 13) ^ ((((v30 ^ (v30 << 13)) >> 7) ^ v30 ^ (v30 << 13)) << 17));
    *(v62 + v31 * 4) = v52[v31] ^ v30;
    ++v31;
  }
  while ( v31 < 8 );
  if ( EAC::Callbacks::GetUsermodeModuleWrapper(v62) )//  qtcorevbox4.dll
    goto LABEL_44;
  *&v60[16] = 0i64;
  v50[0] = 1622598650;
  *v60 = 0i64;
  v50[1] = -434380297;
  v18 |= 0x100u;
  v50[2] = 450310602;
  v32 = 967813938;
  v50[3] = -1230501162;
  v33 = 0i64;
  v50[4] = 130594042;
  v50[5] = 877756042;
  do
  {
    v32 = _byteswap_ulong(14767 * v32 + 11512626);
    *&v60[v33 * 4] = v50[v33] ^ v32;
    ++v33;
  }
  while ( v33 < 6 );
  v34 = EAC::Callbacks::GetUsermodeModuleWrapper(v60);// vboxvmm.dll
  v35 = 0;
  if ( v34 )
LABEL_44:
    v35 = 1;
  if ( _bittest(&v18, 8u) )
    memset(v60, 0, sizeof(v60));
  if ( (v18 & 0x80u) != 0 )
  {
    LOBYTE(v18) = v18 & 0x7F;
    memset(v62, 0, sizeof(v62));
  }
  if ( (v18 & 0x40) != 0 )
    memset(v56, 0, sizeof(v56));
  if ( (v18 & 0x20) != 0 )
    memset(v57, 0, sizeof(v57));
  memset(v61, 0, sizeof(v61));
  if ( v35 )
  {
LABEL_54:
    bDidFindBlacklistedModule = 1;
  }
  else
  {
    v53[0] = 1037675329;
    v53[1] = -1518926285;
    v63[0] = 0i64;
    v53[2] = 21725712;
    v36 = 476297892;
    v63[1] = 0i64;
    v53[3] = -814997594;
    v37 = 0i64;
    v53[4] = -1828532299;
    v53[5] = -1535047739;
    v53[6] = -1866569114;
    v53[7] = 1065021894;
    do
    {
      v36 = -(((v36 ^ (v36 << 13)) >> 7) ^ v36 ^ (v36 << 13) ^ ((((v36 ^ (v36 << 13)) >> 7) ^ v36 ^ (v36 << 13)) << 17));
      *(v63 + v37 * 4) = v53[v37] ^ v36;
      ++v37;
    }
    while ( v37 < 8 );
    v38 = EAC::Callbacks::GetUsermodeModuleWrapper(v63);//  netredirect.dll
    bDidFindBlacklistedModule = 0;
    memset(v63, 0, sizeof(v63));
    if ( v38 )
      bDidFindBlacklistedModule = 1;
  }
  EAC::Callbacks::KeUnstackDetachProcess(a1, v64);
  return bDidFindBlacklistedModule;
}

char EAC::Callbacks::CheckModuleExtension(unsigned __int64 a1, char a2, unsigned int *a3, __int64 a4, ...)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  va_start(va1, a4);
  va_start(Pa, a4);
  Pa = va_arg(va1, PVOID);
  v47 = va_arg(va1, _WORD *);
  v45 = a4;
  v44 = a2;
  v36 = 0;
  EAC::Memory::memset(&v40, 0, 0x98ui64);
  Pa = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  if ( !a1 || !a3 || !a4 )
    return 0;
  if ( a2 == 32 )
  {
    v11 = a3[32];
    v12 = a3[33];
  }
  else
  {
    if ( a2 != 64 )
      return 0;
    v11 = a3[36];
    v12 = a3[37];
  }
  v13 = a3[20];
  v39 = v13;
  v14 = (a1 + v11);
  v15 = v13 + a1;
  v38 = v13 + a1;
  if ( !v13 || v12 < 0x14ui64 || v14 <= a1 || v14 + v12 > v15 )
    return 0;
  v40.m128_i32[3] = 0xEFCDAB89;
  v41 = -1732584194;
  v42 = 271733878;
  v40.m128_i32[0] = 0;
  *(v40.m128_u64 + 4) = 0x6745230100000000i64;
  while ( 1 )
  {
    v16 = v14[3];
    if ( !v16 )
      break;
    if ( v16 <= v13 )
    {
      if ( sub_140018490(a1 + v16, Pa) )
      {
        v18 = Pa;
        v19 = -1i64;
        do
          ++v19;
        while ( *(Pa + v19) );
        if ( v19 > 4 )
        {
          nModuleExtension = *(Pa + v19 - 4);
          if ( nModuleExtension == 'xco.' || nModuleExtension == 'sys.' || nModuleExtension == 'lld.' )
            *(Pa + v19 - 4) = 0;
        }
        v21 = *v14;
        if ( v21 || (v21 = v14[4], v21) )
          v9 = (a1 + v21);
        if ( v9 && v9 < v15 )
        {
          if ( v44 == 32 )
          {
            v22 = v9;
            while ( 1 )
            {
              v23 = v22;
              v24 = *v22;
              if ( !*v22 )
                break;
              ++v22;
              v25 = !*v22 && !v14[8];
              v26 = *v23;
              if ( v24 >= 0 )
                v27 = sub_1400186B4(v18, (a1 + v26 + 2), v43);
              else
                v27 = sub_1400185A0(v18, v26, v43, v17, v25);
              if ( v27 )
              {
                v28 = -1i64;
                do
                  ++v28;
                while ( v43[v28] );
                sub_14002930C(&v40, v43, v28);
                ++v8;
              }
            }
          }
          else if ( v44 == 64 )
          {
            for ( i = v9; ; i = v31 )
            {
              v30 = *i;
              if ( !*i )
                break;
              v31 = i + 1;
              v32 = !i[1] && !v14[8];
              if ( v30 >= 0 )
                v33 = sub_1400186B4(v18, (a1 + v30 + 2), v43);
              else
                v33 = sub_1400185A0(v18, v30, v43, v17, v32);
              if ( v33 )
              {
                v34 = -1i64;
                do
                  ++v34;
                while ( v43[v34] );
                sub_14002930C(&v40, v43, v34);
                ++v8;
              }
            }
          }
        }
        EAC::Memory::ExFreePool(v18);
        v15 = v38;
      }
      v13 = v39;
    }
    v14 += 5;
  }
  if ( v8 )
  {
    sub_1400293C8(&v40, v45);
    if ( v47 )
      *v47 = v8;
    v36 = 1;
  }
  return v36;
}


```

`EAC-Reversal-main/processes.cpp`:

```cpp
char __fastcall EAC::Callbacks::ProcessEnumerationScan(unsigned int *a1)
{
  __int64 v2; // rdi
  __int64 v4; // rcx
  unsigned int v5; // ecx
  char v6; // [rsp+20h] [rbp-48h]
  char v7[56]; // [rsp+30h] [rbp-38h] BYREF
  PVOID Object; // [rsp+78h] [rbp+10h] BYREF

  v6 = 0;
  v2 = 0i64;
  if ( !a1 )
    return 0;
  EAC::Callbacks::IsInUsermodeAddressSpace(a1, 16i64, 1);
  if ( !*a1 || !*(a1 + 1) || !a1[3] )
    return 0;
  if ( EAC::Imports::PsLookupProcessByProcessID(*a1, &Object) >= 0 )
  {
    if ( EAC::Callbacks::KeStackAttachProcess(Object, v7) )
    {
      LOBYTE(v4) = 1;
      v2 = EAC::Callbacks::ScanProcess(v4);
      EAC::Callbacks::KeUnstackDetachProcess(Object, v7);
    }
    ObfDereferenceObject(Object);
  }
  if ( v2 )
  {
    EAC::Callbacks::IsInUsermodeAddressSpace(*(a1 + 1), a1[3], 1);
    v5 = *(*v2 + 10i64);
    if ( v5 >= a1[3] )
      v5 = a1[3];
    EAC::Memory::memmove(*(a1 + 1), *v2, v5);
    v6 = 1;
    EAC::Memory::FreePoolAndUnicodeString(v2);
  }
  return v6;
}

struct_v6 *__fastcall EAC::Callbacks::ScanProcess(__int64 a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  bGetFileOnDisk = a1;
  bHasSetNeededData = 0;
  Process = EAC::Imports::PsGetCurrentProcess();
  pID = EAC::Imports::PsGetCurrentProcessID(Process);
  v5 = EAC::Memory::ExAllocatePoolWithRandomTag2(816i64);
  pStruct = v5;
  if ( v5 )
  {
    EAC::Memory::memset(v5, 0, 0x330ui64);
    v7 = EAC::Imports::GetProcessBaseAddress(Process);
    pStruct->qword8 = v7;
    if ( v7 || (v8 = EAC::Callbacks::GetUsermodeModuleWrapper(0i64), (pStruct->qword8 = v8) != 0i64) )
    {
      if ( EAC::Imports::IsWin32ConsoleSubsystem(Process) )
      {
        processFlags2 = 0x8001;
      }
      else if ( EAC::Imports::HasCOMDescriptor(pStruct->qword8) )
      {
        processFlags2 = 9;
      }
      else
      {
        v21[0] = 0x17B95E6A;
        v21[1] = 0xB5A7A4BD;
        v21[2] = 0x62CDCB21;
        v21[3] = 0xA77AB98D;
        v21[4] = 0xDE91C109;
        v21[5] = 0xE534B047;
        v22 = -19593;
        v11 = EAC::Memory::DecryptStringBuffer(v21, v20);
        v12 = EAC::Callbacks::GetUsermodeModuleWrapper(v11);
        memset(v20, 0, 0x1Aui64);
        v9 = 0i64;
        if ( v12 )
        {
          processFlags2 = 17;                   // msvbvm60.dll
        }
        else
        {
          v20[0] = 0x12D3327D;
          v20[1] = 0xCBBDD298;
          v20[2] = -1184356958;
          v20[3] = 0x10D2A830;
          v20[4] = 1441356086;
          v20[5] = -160030657;
          v13 = EAC::Memory::DecryptStringBuffer2(v20, v21);
          v14 = EAC::Callbacks::GetUsermodeModuleWrapper(v13);
          memset(v21, 0, sizeof(v21));
          v9 = 0i64;
          processFlags2 = 1;
          if ( v14 )
            processFlags2 = 0x1001;             // perl512.dll
        }
      }
      processFlags = processFlags2;
      v15 = pStruct->qword8;
      if ( EAC::Memory::IsDbgUiRemoteBreakinPatchedToCallLdrShutdownProcess(v9)
        || EAC::Memory::DoesProcessHaveAntiDebug(v15) )
      {
        processFlags2 |= 0x20u;
        processFlags = processFlags2;
      }
      if ( EAC::Callbacks::IsProcessVMProtected(pStruct->qword8) )
      {
        processFlags2 |= 0x40u;
        processFlags = processFlags2;
      }
      if ( EAC::Callbacks::HasDetectedPacker(pStruct->qword8, &nOutResult) )
        processFlags = (nOutResult != 0 ? 0x20000 : 0x10000) | processFlags2;
      EAC::Callbacks::SomeMaliciousIdentifierChecks(&processFlags);
      if ( bGetFileOnDisk
        && (EAC::Imports::GetDeviceName(Process, &pStruct[1].qword0 + 7)
         || EAC::Memory::GetMappedFilename(-1i64, pStruct->qword8, &pStruct[1].qword0 + 7)
         || EAC::Memory::GetProcessImageFilename(pID, &pStruct[1].qword0 + 7))
        || EAC::Memory::GetProcessPathOrCommandline(Process, 1, &pStruct[1].qword0 + 7) )
      {
        pStruct->bIsProgramOnDisk = 1;
        if ( EAC::Callbacks::IsMaliciousProgram(&pStruct[1].qword0 + 7) )
        {
          processFlags |= 0x40000u;
        }
        else if ( EAC::Callbacks::IsFileInSystemDirectory(&pStruct[1].qword0 + 7) )
        {
          processFlags |= 0x200u;
        }
      }
      EAC::Callbacks::IsInUsermodeAddressSpace(pStruct->qword8, 4096i64, 1);
      v16 = ((&pStruct[1].qword0 + 7) & -(pStruct->bIsProgramOnDisk != 0));
      v17 = EAC::Imports::PsGetProcessWow64(Process);
      pInfo = EAC::Memory::CopyProcessInformation(pStruct->qword8, 0x1000ui64, 0i64, processFlags, v17, v16, pID, 0i64);
      pStruct->qword0 = pInfo;
      if ( pInfo )
      {
        if ( !pStruct->bIsProgramOnDisk && EAC::Imports::GetProcessFileName(Process, v20) )
          EAC::Memory::CopyString(pStruct->qword0 + 0x20i64, 256i64, v20);
        bHasSetNeededData = 1;
      }
    }
  }
  if ( !bHasSetNeededData && pStruct )
  {
    EAC::Memory::FreePoolAndUnicodeString(pStruct);
    pStruct = 0i64;
  }
  return pStruct;
}

char __fastcall EAC::Memory::DoesProcessHaveAntiDebug(ULONG64 a1)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = 0;
  v3 = 0;
  if ( !a1 )
    return 0;
  EAC::Callbacks::IsInUsermodeAddressSpace(a1, 4096i64, 1);
  if ( EAC::Memory::GetPEHeader(a1, 0x1000ui64, 0i64, &v12) )
  {
    v5 = v12;
    if ( *(v12 + 40) )
    {
      v6 = (*(v12 + 20) + v12 + 24);
      for ( i = 0; ; ++i )
      {
        if ( i >= *(v5 + 6) )
          return v2;
        EAC::Callbacks::IsInUsermodeAddressSpace(v6, 40i64, 1);
        v8 = v6->OptionalHeader.SizeOfUninitializedData;
        if ( v8 == 0x60000020 )                 // unpacked file
          break;
        if ( v8 == 0xE0000040 )                 // UPX packed exe? https://i.imgur.com/85R5QvD.png
        {
          if ( v6->Signature == '    ' && *&v6->FileHeader.Machine == '    ' )// cleared shit
            goto LABEL_11;
          for ( j = 0; ; ++j )
          {
            v11 = j == 8;
            if ( j >= 8 )
              break;
            if ( (*(&v6->Signature + j) - 97) > 25u )
            {
              v11 = j == 8;
              break;
            }
          }
          if ( v11 )
          {
            v9 = ++v3 == 2;
LABEL_10:
            if ( v9 )
              goto LABEL_11;
            goto LABEL_22;
          }
        }
LABEL_22:
        v6 = (v6 + 40);
      }
      if ( v6->Signature != '   ' )
        goto LABEL_22;
      v9 = *&v6->FileHeader.Machine == '    ';  // cleared shit
      goto LABEL_10;
    }
LABEL_11:
    v2 = 1;
  }
  return v2;
}

char __fastcall EAC::Callbacks::IsProcessVMProtected(ULONG64 BaseAddress)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v2 = 0;
  if ( !BaseAddress )
    return 0;
  EAC::Callbacks::IsInUsermodeAddressSpace(BaseAddress, 4096i64, 1);
  if ( EAC::Memory::GetPEHeader(BaseAddress, 0x1000ui64, 0i64, &v7) )
  {
    v4 = v7;
    v5 = (&v7->OptionalHeader + v7->FileHeader.SizeOfOptionalHeader);
    for ( i = 0; i < v4->FileHeader.NumberOfSections; ++i )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(v5, 40i64, 1);
      if ( *(&v5->e_magic + 1) == '0pmv' )
        return 1;
      v5 = (v5 + 40);
    }
  }
  return v2;
}

char __fastcall EAC::Callbacks::HasDetectedPacker(ULONG64 a1, _BYTE *a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v4 = 0;
  if ( a1 && a2 )
  {
    *a2 = 0;
    EAC::Callbacks::IsInUsermodeAddressSpace(a1, 4096i64, 1);
    if ( !EAC::Memory::GetPEHeader(a1, 0x1000ui64, 0i64, &v27) )
      return v4;
    v5 = v27;
    sectionName = (&v27->OptionalHeader.Magic + v27->FileHeader.SizeOfOptionalHeader);
    for ( i = 0; i < v5->FileHeader.NumberOfSections; ++i )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(sectionName, 40i64, 1);
      if ( *sectionName == '0XPU' )             // upx lol
        return 1;
      sectionName += 10;
    }
    v8 = EAC::Callbacks::IsEntrypointInUsermodeAddressSpace(a1, v5);
    if ( !v8 )
      return v4;
    nMachine = v5->FileHeader.Machine;
    if ( nMachine == 332 )
    {
      v10 = 32;
    }
    else
    {
      if ( nMachine == 0x8664 || nMachine == 0xAA64 )
      {
        if ( *v8 != 'UWVS' )
          return v4;
        v11 = &v8[sub_140020E6C(v8 + 4, v21) + 4];
        if ( (v26 & 0x1000) != 0 )
          return v4;
        if ( (v26 & 0x40000000) == 0 )
          return v4;
        if ( v22 != -115 )
          return v4;
        if ( v23 != 53 )
          return v4;
        sub_140020E6C(v11, v21);
        if ( (v26 & 0x1000) != 0 || (v26 & 0x40000000) == 0 || v22 != -115 || v24 != 7 )
          return v4;
        v12 = v25 == 6;
        goto LABEL_34;
      }
      v10 = 0;
    }
    if ( v10 != 32 )
      return v4;
    v13 = &v8[sub_14004CDFC(v8, v16)];
    if ( (v20 & 0x1000) != 0 )
      return v4;
    if ( v17 != 96 )
      return v4;
    v14 = &v13[sub_14004CDFC(v13, v16)];
    if ( (v20 & 0x1000) != 0 )
      return v4;
    if ( v17 != -66 )
      return v4;
    sub_14004CDFC(v14, v16);
    if ( (v20 & 0x1000) != 0 || v17 != -115 || v18 != 7 )
      return v4;
    v12 = v19 == 6;
LABEL_34:
    if ( v12 )
    {
      v4 = 1;
      *a2 = 1;
    }
    return v4;
  }
  return 0;
}

_OWORD *__fastcall EAC::Memory::CopyProcessInformation(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, int a4, int a5, unsigned __int16 *a6, __int16 pID, _QWORD *a8)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v42 = a1;
  v9 = a2;
  v11 = 0i64;
  if ( a3 > 0x8000 )
    return 0i64;
  v12 = EAC::Memory::ExAllocatePoolWithRandomTag2(4704i64);
  v13 = v12;
  v40 = v12;
  if ( !v12 )
    return 0i64;
  EAC::Memory::memset(v12, 0, 0x260ui64);
  *&v13->char0 = 10;
  v13->dword4 = 1346718061;
  v13->word8 = 2;
  v13->qwordE = a1;
  v13->dword16 = v9;
  v13->dword1A = a4;
  v14 = 64;
  if ( a5 )
    v14 = a5;
  v13->byte1E = v14;
  v13->word220 = pID;
  if ( a6 )
  {
    v15 = *(a6 + 1);
    if ( v15 )
    {
      v16 = *a6;
      if ( v16 )
      {
        v17 = a6[1];
        if ( v17 )
        {
          v18 = &v13->word20;
          v19 = 0;
          if ( (v16 & 1) != 0 || (v17 & 1) != 0 || v16 > v17 || v17 == 0xFFFF )
            v19 = 0xC000000D;
          if ( v19 < 0 )
          {
            *v18 = 0;
          }
          else
          {
            v20 = v16 >> 1;
            v21 = 256i64;
            v22 = v15 - v18;
            do
            {
              if ( !(v20 + v21 - 256) )
                break;
              *v18 = *(v18 + v22);
              ++v18;
              --v21;
            }
            while ( v21 );
            v23 = v18 - 1;
            if ( v21 )
              v23 = v18;
            *v23 = 0;
          }
          if ( sub_140021608(a6, v37) )
            v13->byte1F = (*a6 - v37[0]) >> 1;
        }
      }
    }
  }
  v24 = &v13->oword260;
  if ( a1 && a2 >= 0x1000 && EAC::Memory::IsAddressLoadedInUsermodeMemory(a1, a2, &v13->gap222[18]) )
  {
    v25 = v13->word238;
    if ( v25 == 332 )
    {
      v26 = 32;
    }
    else if ( v25 == 0x8664 || v25 == 0xAA64 )
    {
      v26 = 64;
    }
    else
    {
      v26 = 0;
    }
    v13->byte1E = v26;
    if ( a1 < MmHighestUserAddress )
    {
      EAC::Callbacks::IsInUsermodeAddressSpace(a1, a2, 1);
      if ( EAC::Memory::GetPEHeader(a1, a2, 0i64, &v36) )
      {
        v27 = v36;
        EAC::Callbacks::CheckModuleExtension(v42, v13->byte1E, v36, v13->gap222);
        v39 = &v13->oword260;
        v28 = (v27 + *(v27 + 10) + 24);
        v38 = v28;
        v29 = 0;
        while ( v29 < *(v27 + 3) )
        {
          EAC::Callbacks::IsInUsermodeAddressSpace(v28, 40i64, 1);
          *v24 = *v28;
          ++v13->word254;
          ++v29;
          v28 += 5;
          v38 = v28;
          v24 = (v24 + 8);
          v39 = v24;
        }
        if ( EAC::Memory::CopyRawDataFromDebugDirectory(v42, v41, 128) )
        {
          v37[1] = v41;
          v30 = -1i64;
          do
            ++v30;
          while ( v41[v30] );
          v36 = v30;
          LOWORD(v37[0]) = v30;
          WORD1(v37[0]) = v30 + 1;
          EAC::Memory::memmove(v24, v41, v30);
          LODWORD(v24) = v30 + v24;
          v13->word25A = v30;
        }
      }
      else
      {
        v13->dword1A |= 0x80u;
      }
    }
    v31 = a3;
  }
  else
  {
    v13->dword1A |= 0x80u;
    v31 = a3;
  }
  v32 = v24 - v13;
  v13->unsigned_intA = v32;
  if ( v32 + v31 >= v32 )
  {
    v33 = EAC::Memory::ExAllocatePoolWithRandomTag2(v32 + v31);
    v11 = v33;
    if ( v33 )
    {
      EAC::Memory::memmove(v33, &v13->char0, v13->unsigned_intA);
      if ( v31 )
      {
        if ( a8 )
          *a8 = v11 + *(v11 + 10);
      }
    }
  }
  EAC::Memory::ExFreePool(v13);
  return v11;
}

char __fastcall EAC::Memory::IsImageOnDisk(__int64 a1, __int64 a2)
{
  char v2; // bl

  v2 = 0;
  if ( a1
    && a2
    && (EAC::Imports::GetDeviceName(a1, a2)
     || EAC::Callbacks::GetProcessName(a1, a2)
     || EAC::Memory::GetProcessPathOrCommandline(a1, 0, a2)) )
  {
    v2 = 1;
  }
  return v2;
}

char EAC::Callbacks::CheckRunningPrograms()
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v0 = 0;
  v1 = 0;
  v2 = 0;
  v3 = EAC::Memory::ExAllocatePoolWithRandomTag2(2048i64);
  v4 = v3;
  if ( !v3 )
    goto LABEL_23;
  v5 = EAC::Memory::GetRunningProcesses(v3, 0x100u);
  if ( v5 )
  {
    v6 = v4;
    while ( 1 )
    {
      if ( *v6 )
      {
        if ( EAC::Imports::PsLookupProcessByProcessID(*v6, &Object) >= 0 )
        {
          v7 = EAC::Imports::GetProcessFileName(Object, v55);
          ObfDereferenceObject(Object);
          if ( v7 )
          {
            v60 = 1551606071;
            v52 = 0i64;
            v8 = v1 | 1;
            v61 = 1300367728;
            v9 = -1293282290;
            for ( i = 0i64; i < 8; i += 4i64 )
            {
              v9 = __ROR4__(214013 * v9 + 2531011, 3);
              *(&v52 + i) = *(&v60 + i) ^ v9;
            }
            if ( EAC::Memory::CompareStrings(v55, &v52, 7ui64) )
              goto LABEL_15;
            v62 = 1587912774;
            v51 = 0i64;
            v8 |= 2u;
            v63 = 0x8CB32030;
            v11 = 0x97070F92;
            for ( j = 0i64; j < 8; j += 4i64 )
            {
              v11 = ~(((v11 ^ (v11 >> 7)) << 9) ^ v11 ^ (v11 >> 7) ^ ((((v11 ^ (v11 >> 7)) << 9) ^ v11 ^ (v11 >> 7)) >> 13));
              *(&v51 + j) = *(&v62 + j) ^ v11;
            }
            if ( EAC::Memory::CompareStrings(v55, &v51, 7ui64)// dbgview
                                                // devenv
                                                // tv_
              || (v8 |= 4u, strcpy(v59, "tv_"), EAC::Memory::CompareStrings(v55, v59, 3ui64)) )
            {
LABEL_15:
              v13 = 1;
            }
            else
            {
              v13 = 0;
            }
            if ( (v8 & 4) != 0 )
            {
              v8 &= 0xFFFFFFFB;
              memset(v59, 0, 4ui64);
            }
            if ( (v8 & 2) != 0 )
            {
              v8 &= 0xFFFFFFFD;
              memset(&v51, 0, sizeof(v51));
            }
            v1 = v8 & 0xFFFFFFFE;
            memset(&v52, 0, sizeof(v52));
            if ( v13 )
              break;
          }
        }
      }
      ++v0;
      ++v6;
      if ( v0 >= v5 )
        goto LABEL_22;
    }
    v2 = 1;
  }
LABEL_22:
  EAC::Memory::ExFreePool(v4);
  if ( !v2 )
  {
LABEL_23:
    v14 = EAC::Memory::GetRunningModules();
    v15 = v14;
    if ( v14 )
    {
      v16 = 0;
      if ( *v14 )
      {
        while ( 1 )
        {
          v17 = 74i64 * v16;
          if ( *&v15[v17 + 6] >= MmSystemRangeStart )
          {
            v18 = HIWORD(v15[v17 + 11]);
            v19 = &v15[v17 + 12];
            v20 = (v19 + v18) == 0i64;
            v21 = v19 + v18;
            String1.Buffer = v21;
            if ( v20 )
            {
              *&String1.Length = 0;
            }
            else
            {
              v22 = -1i64;
              do
                ++v22;
              while ( v21[v22] );
              String1.Length = v22;
              String1.MaximumLength = v22 + 1;
            }
            v42[0] = -1641674219;
            v23 = v1 | 8;
            v42[1] = -1284726641;
            *v48 = 0i64;
            v24 = -398366639;
            v48[8] = 0;
            v25 = 0i64;
            v43 = -64;
            do
            {
              v26 = v42[v25] ^ v24;
              v24 = __ROL4__(214013 * v24 + 2531011, 1);
              *&v48[v25 * 4] = v26;
              ++v25;
            }
            while ( v25 < 2 );
            v48[8] = v43 ^ v24;
            String2.Buffer = v48;
            v27 = -1i64;
            do
              ++v27;
            while ( v48[v27] );
            String2.Length = v27;
            String2.MaximumLength = v27 + 1;
            if ( !RtlCompareString(&String1, &String2, 1u) )// Dbgv.sys
              goto LABEL_51;
            v46[0] = -1717625671;
            v23 |= 0x10u;
            v46[1] = 1890075069;
            *v50 = 0i64;
            v28 = -623882519;
            *&v50[8] = 0;
            v29 = 0i64;
            *&v50[12] = 0;
            v46[2] = 1862005061;
            v47 = 31770;
            do
            {
              *&v50[v29 * 4] = v46[v29] ^ v28;
              ++v29;
              v28 = __ROL4__(
                      ((v28 ^ (v28 >> 7)) << 9) ^ v28 ^ (v28 >> 7) ^ ((((v28 ^ (v28 >> 7)) << 9) ^ v28 ^ (v28 >> 7)) >> 13),
                      2);
            }
            while ( v29 < 3 );
            for ( k = 12i64; k < 0xE; ++k )
            {
              v31 = v28;
              v28 >>= 8;
              v50[k] = *(v46 + k) ^ v31;
            }
            v57.Buffer = v50;
            v32 = -1i64;
            do
              ++v32;
            while ( v50[v32] );
            v57.Length = v32;
            v57.MaximumLength = v32 + 1;
            if ( !RtlCompareString(&String1, &v57, 1u) )// PROCMON23.sys
              goto LABEL_51;
            v44[0] = -448893557;
            v23 |= 0x20u;
            v44[1] = -928826563;
            *v49 = 0i64;
            v33 = -749400081;
            *&v49[8] = 0;
            v34 = 0i64;
            v45 = 15396;
            do
            {
              v35 = v44[v34] ^ v33;
              v33 = ~(214013 * v33 + 2531011);
              *&v49[v34 * 4] = v35;
              ++v34;
            }
            while ( v34 < 2 );
            for ( l = 8i64; l < 0xA; ++l )
            {
              v37 = v33;
              v33 >>= 8;
              v49[l] = *(v44 + l) ^ v37;
            }
            v58.Buffer = v49;
            v38 = -1i64;
            do
              ++v38;
            while ( v49[v38] );
            v58.Length = v38;
            v58.MaximumLength = v38 + 1;
            v39 = RtlCompareString(&String1, &v58, 1u);//  dbk64.sys
            v40 = 0;
            if ( !v39 )
LABEL_51:
              v40 = 1;
            if ( (v23 & 0x20) != 0 )
            {
              v23 &= 0xFFFFFFDF;
              memset(v49, 0, sizeof(v49));
            }
            if ( (v23 & 0x10) != 0 )
            {
              v23 &= 0xFFFFFFEF;
              memset(v50, 0, sizeof(v50));
            }
            v1 = v23 & 0xFFFFFFF7;
            memset(v48, 0, sizeof(v48));
            if ( v40 )
              break;
          }
          if ( ++v16 >= *v15 )
            goto LABEL_60;
        }
        v2 = 1;
      }
LABEL_60:
      EAC::Memory::ExFreePool(v15);
    }
  }
  return v2;
}

char *__fastcall EAC::Callbacks::DetectUsermodeAnomalies(unsigned int a1, __int64 a2, _OWORD *a3, __int64 a4, char *a5, unsigned int a6)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v20 = a3;
  v7 = EAC::Imports::PsGetCurrentProcess();
  result = EAC::Imports::GetProcessBaseAddress(v7);
  v9 = result;
  if ( result < MmHighestUserAddress )
  {
    v10 = (v19 & -(EAC::Callbacks::GetProcessName(v7, v19) != 0));
    v11 = EAC::Imports::PsGetCurrentProcessID(v7);
    v12 = EAC::Imports::PsGetCurrentProcess();
    v13 = EAC::Imports::PsGetProcessWow64(v12);
    v14 = a5;
    if ( a5 && a6 )
      v15 = a6 + 4096;
    else
      v15 = 4096;
    v16 = EAC::Memory::CopyProcessInformation(v9, 0x1000ui64, v15, 1, v13, v10, v11, &v20);
    v17 = v16;
    if ( v16 )
    {
      *(v16 + 22) = 0;
      if ( v9 )
      {
        EAC::Callbacks::IsInUsermodeAddressSpace((v9 + 4096), 4096i64, 1);
        EAC::Memory::memmove(v20, v9 + 4096, 0x1000ui64);
      }
      if ( !v14 )
        goto LABEL_14;
      if ( a6 && v20 )
        EAC::Memory::memmove(v20 + 256, v14, a6);
      v18 = a6;
      if ( !a6 )
LABEL_14:
        v18 = 0;
      EAC::Callbacks::ReportViolation(a1, v17, v18 + *(v17 + 10) + 4096);
      memset(v17, 0, (*(v17 + 10) + 4096));
      EAC::Memory::ExFreePool(v17);
    }
    result = v19;
    if ( v10 == v19 )
      result = EAC::Memory::FreeUnicdeString(v19);
  }
  return result;
}

__int64 __fastcall EAC::Callbacks::CheckForBlacklistedProcessNames(__int64 a1, _DWORD *a2, int a3, unsigned int a4)
{
  char v5; // bl
  char v8; // r14
  int v9; // edx
  unsigned __int64 v10; // rdi
  char v11; // dl
  unsigned int v12; // ecx
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  unsigned int v16; // ecx
  bool v17; // zf
  unsigned int v18; // edx
  unsigned __int64 v19; // rdi
  unsigned __int64 i; // rdi
  char v21; // cl
  char v22; // dl
  unsigned int v23; // edx
  unsigned __int64 v24; // rdi
  int v25; // ecx
  unsigned __int64 j; // rdi
  char v27; // cl
  char v28; // dl
  unsigned int v29; // ecx
  int v30; // edx
  int v31; // edi
  int v32; // ecx
  int v33; // edx
  unsigned int v34; // edx
  unsigned __int64 v35; // rdi
  int v37[2]; // [rsp+38h] [rbp-49h]
  __int16 v38; // [rsp+40h] [rbp-41h]
  char v39; // [rsp+42h] [rbp-3Fh]
  int v40[3]; // [rsp+43h] [rbp-3Eh]
  char v41; // [rsp+4Fh] [rbp-32h]
  int v42[3]; // [rsp+50h] [rbp-31h]
  __int16 v43; // [rsp+5Ch] [rbp-25h]
  char v44; // [rsp+5Eh] [rbp-23h]
  int v45[3]; // [rsp+5Fh] [rbp-22h]
  _BYTE v46[11]; // [rsp+6Bh] [rbp-16h] BYREF
  _BYTE v47[13]; // [rsp+76h] [rbp-Bh] BYREF
  _BYTE v48[15]; // [rsp+83h] [rbp+2h] BYREF
  _BYTE v49[12]; // [rsp+92h] [rbp+11h] BYREF
  char v50[24]; // [rsp+A0h] [rbp+1Fh] BYREF

  v5 = 0;
  if ( !EAC::Imports::GetProcessFileName(a1, v50) )
    return a4;
  v8 = 1;
  if ( !a2 || *a2 != 0x52 && *a2 != 0x118 && *a2 != 0x119 && *a2 != 0x11B && *a2 != 0x17F && *a2 != 0x1EA )
    goto LABEL_13;
  v45[0] = -1709991619;
  *v49 = 0i64;
  v9 = 1210365784;
  *&v49[8] = 0;
  v10 = 0i64;
  v45[1] = 1457018111;
  v45[2] = 18902803;
  do
  {
    v9 = ~(1103515245 * v9 + 12345);
    *&v49[v10 * 4] = v45[v10] ^ v9;
    ++v10;
  }
  while ( v10 < 3 );
  v5 = 1;
  if ( EAC::Memory::CompareStrings(v50, v49, 0xBui64) )
  {
    v11 = 1;
  }
  else
  {
LABEL_13:
    v11 = 0;
    if ( (v5 & 1) == 0 )
      goto LABEL_26;
  }
  v5 &= 0xFEu;
  memset(v49, 0, sizeof(v49));
  if ( v11 )
  {
    v12 = a4 | 2;
    if ( (a3 & 2) == 0 )
      v12 = a4;
    v13 = v12 | 8;
    if ( (a3 & 8) == 0 )
      v13 = v12;
    v14 = v13 | 0x10;
    if ( (a3 & 0x10) == 0 )
      v14 = v13;
    v15 = v14 | 0x20;
    if ( (a3 & 0x20) == 0 )
      v15 = v14;
    v16 = v15 | 0x200;
    if ( (a3 & 0x200) == 0 )
      v16 = v15;
    a4 = v16 | 0x400;
    v17 = (a3 & 0x400) == 0;
LABEL_64:
    if ( v17 )
      a4 = v16;
    return a4;
  }
  if ( *a2 != 20 )
    goto LABEL_33;
LABEL_26:
  v37[0] = -1987792738;
  *v46 = 0i64;
  v5 |= 2u;
  *&v46[8] = 0;
  v18 = -640686133;
  v46[10] = 0;
  v19 = 0i64;
  v37[1] = 392935476;
  v38 = 14253;
  v39 = -74;
  do
  {
    *&v46[v19 * 4] = v37[v19] ^ v18;
    ++v19;
    v18 = __ROR4__(
            ((v18 ^ (v18 >> 7)) << 9) ^ v18 ^ (v18 >> 7) ^ ((((v18 ^ (v18 >> 7)) << 9) ^ v18 ^ (v18 >> 7)) >> 13),
            4);
  }
  while ( v19 < 2 );
  for ( i = 8i64; i < 0xB; ++i )
  {
    v21 = v18;
    v18 >>= 8;
    v46[i] = *(v37 + i) ^ v21;
  }
  if ( EAC::Memory::CompareStrings(v50, v46, 0xAui64) )
    v22 = 1;
  else
LABEL_33:
    v22 = 0;
  if ( (v5 & 2) != 0 )
  {
    v5 &= 0xFDu;
    memset(v46, 0, sizeof(v46));
  }
  if ( v22 )
  {
    v16 = a4 | 0x400;
    if ( (a3 & 0x400) == 0 )
      v16 = a4;
    a4 = v16 | 0x10;
    v17 = (a3 & 0x10) == 0;
    goto LABEL_64;
  }
  if ( *a2 != 330 )
    goto LABEL_47;
  v42[0] = 827781030;
  *v48 = 0i64;
  v5 |= 4u;
  *&v48[8] = 0;
  v23 = 1445236465;
  *&v48[12] = 0;
  v24 = 0i64;
  v48[14] = 0;
  v42[1] = -1132862917;
  v42[2] = 347640278;
  v43 = 26589;
  v44 = 98;
  do
  {
    v25 = v42[v24] ^ v23;
    v23 = __ROR4__(1103515245 * v23 + 12345, 3);
    *&v48[v24 * 4] = v25;
    ++v24;
  }
  while ( v24 < 3 );
  for ( j = 12i64; j < 0xF; ++j )
  {
    v27 = v23;
    v23 >>= 8;
    v48[j] = *(v42 + j) ^ v27;
  }
  if ( EAC::Memory::CompareStrings(v50, v48, 0xEui64) )
    v28 = 1;
  else
LABEL_47:
    v28 = 0;
  if ( (v5 & 4) != 0 )
  {
    v5 &= 0xFBu;
    memset(v48, 0, sizeof(v48));
  }
  if ( v28 )
  {
    v29 = a4 | 0x40;
    if ( (a3 & 0x40) == 0 )
      v29 = a4;
    v30 = v29 | 0x400;
    if ( (a3 & 0x400) == 0 )
      v30 = v29;
    v31 = v30 | 0x1000;
    if ( (a3 & 0x1000) == 0 )
      v31 = v30;
    v32 = v31 | 0x800;
    if ( (a3 & 0x800) == 0 )
      v32 = v31;
    v33 = v32 | 1;
    if ( (a3 & 1) == 0 )
      v33 = v32;
    v16 = v33 | 0x10;
    if ( (a3 & 0x10) == 0 )
      v16 = v33;
    a4 = v16 | 0x100000;
    v17 = (a3 & 0x100000) == 0;
    goto LABEL_64;
  }
  if ( MEMORY[0xFFFFF7800000026C] != 10 && EAC::Memory::GetBuildNumber() < 10240 )// if not windows 10
    goto LABEL_73;
  if ( (a3 & 0x400) == 0 )
    goto LABEL_73;
  v40[0] = -756454645;
  *v47 = 0i64;
  v5 |= 8u;
  *&v47[8] = 0;
  v34 = -1584920471;
  v47[12] = 0;
  v35 = 0i64;
  v40[1] = 1749006771;
  v40[2] = 72172906;
  v41 = -4;
  do
  {
    *&v47[v35 * 4] = v40[v35] ^ v34;
    ++v35;
    v34 = -(((v34 ^ (v34 << 13)) >> 7) ^ v34 ^ (v34 << 13) ^ ((((v34 ^ (v34 << 13)) >> 7) ^ v34 ^ (v34 << 13)) << 17));
  }
  while ( v35 < 3 );
  v47[12] = v41 ^ v34;
  if ( !EAC::Memory::CompareStrings(v50, v47, 0xCui64) )
LABEL_73:
    v8 = 0;
  if ( (v5 & 8) != 0 )
    memset(v47, 0, sizeof(v47));
  if ( v8 )
    a4 |= 0x400u;
  return a4;
}

char __fastcall EAC::Callbacks::CheckForFrapsEXE(ULONG64 a1)
{
  char v2; // bl
  ULONG v3; // eax
  IMAGE_NT_HEADERS64 *v5; // [rsp+48h] [rbp+10h] BYREF

  v2 = 0;
  if ( a1 )
  {
    EAC::Callbacks::IsInUsermodeAddressSpace(a1, 4096i64, 1);
    if ( EAC::Memory::GetPEHeader(a1, 0x1000ui64, 0i64, &v5) )
    {
      if ( v5->FileHeader.Characteristics == 271 && v5->FileHeader.NumberOfSections == 5 )
      {
        v3 = v5->FileHeader.TimeDateStamp;
        if ( v3 == 0x4EA2A728 || v3 == 0x503F67EC || v3 == 0x512C56A2 || v3 == 0x55EAA341 )
          v2 = 1;
      }
    }
  }
  return v2;
}

```

`EAC_SDK/SDK/include/eos_achievements.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_achievements_types.h"

/**
 * The following EOS_Achievements_* functions allow you to query existing achievement definitions that have been defined for your application.
 * You can also query achievement progress data for users.
 * In addition, you can also unlock one or more achievements directly.
 * You can also receive notifications when achievements are unlocked.
 */

/**
 * Query for a list of definitions for all existing achievements, including localized text, icon IDs and whether an achievement is hidden.
 *
 * @note When the Social Overlay is enabled then this will be called automatically.  The Social Overlay is enabled by default (see EOS_PF_DISABLE_SOCIAL_OVERLAY).
 *
 * @param Options Structure containing information about the application whose achievement definitions we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the query definitions operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_QueryDefinitions(EOS_HAchievements Handle, const EOS_Achievements_QueryDefinitionsOptions* Options, void* ClientData, const EOS_Achievements_OnQueryDefinitionsCompleteCallback CompletionDelegate);

/**
 * Fetch the number of achievement definitions that are cached locally.
 *
 * @param Options The Options associated with retrieving the achievement definition count
 *
 * @see EOS_Achievements_CopyAchievementDefinitionByIndex
 *
 * @return Number of achievement definitions or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Achievements_GetAchievementDefinitionCount(EOS_HAchievements Handle, const EOS_Achievements_GetAchievementDefinitionCountOptions* Options);

/**
 * Fetches an achievement definition from a given index.
 *
 * @param Options Structure containing the index being accessed
 * @param OutDefinition The achievement definition for the given index, if it exists and is valid, use EOS_Achievements_Definition_Release when finished
 *
 * @see EOS_Achievements_DefinitionV2_Release
 *
 * @return EOS_Success if the information is available and passed out in OutDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the achievement definition is not found
 *         EOS_Invalid_ProductUserID if any of the userid options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyAchievementDefinitionV2ByIndex(EOS_HAchievements Handle, const EOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions* Options, EOS_Achievements_DefinitionV2 ** OutDefinition);

/**
 * Fetches an achievement definition from a given achievement ID.
 *
 * @param Options Structure containing the achievement ID being accessed
 * @param OutDefinition The achievement definition for the given achievement ID, if it exists and is valid, use EOS_Achievements_Definition_Release when finished
 *
 * @see EOS_Achievements_DefinitionV2_Release
 *
 * @return EOS_Success if the information is available and passed out in OutDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the achievement definition is not found
 *         EOS_Invalid_ProductUserID if any of the userid options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId(EOS_HAchievements Handle, const EOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions* Options, EOS_Achievements_DefinitionV2 ** OutDefinition);

/**
 * Query for a list of achievements for a specific player, including progress towards completion for each achievement.
 *
 * @note When the Social Overlay is enabled then this will be called automatically.  The Social Overlay is enabled by default (see EOS_PF_DISABLE_SOCIAL_OVERLAY).
 *
 * @param Options Structure containing information about the player whose achievements we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the query player achievements operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_Invalid_ProductUserID if any of the userid options are incorrect
 *         EOS_InvalidParameters if any of the other options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_QueryPlayerAchievements(EOS_HAchievements Handle, const EOS_Achievements_QueryPlayerAchievementsOptions* Options, void* ClientData, const EOS_Achievements_OnQueryPlayerAchievementsCompleteCallback CompletionDelegate);

/**
 * Fetch the number of player achievements that are cached locally.
 *
 * @param Options The Options associated with retrieving the player achievement count
 *
 * @see EOS_Achievements_CopyPlayerAchievementByIndex
 *
 * @return Number of player achievements or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Achievements_GetPlayerAchievementCount(EOS_HAchievements Handle, const EOS_Achievements_GetPlayerAchievementCountOptions* Options);

/**
 * Fetches a player achievement from a given index.
 *
 * @param Options Structure containing the Product User ID and index being accessed
 * @param OutAchievement The player achievement data for the given index, if it exists and is valid, use EOS_Achievements_PlayerAchievement_Release when finished
 *
 * @see EOS_Achievements_PlayerAchievement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutAchievement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the player achievement is not found
 *         EOS_Invalid_ProductUserID if you pass an invalid user ID
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyPlayerAchievementByIndex(EOS_HAchievements Handle, const EOS_Achievements_CopyPlayerAchievementByIndexOptions* Options, EOS_Achievements_PlayerAchievement ** OutAchievement);

/**
 * Fetches a player achievement from a given achievement ID.
 *
 * @param Options Structure containing the Product User ID and achievement ID being accessed
 * @param OutAchievement The player achievement data for the given achievement ID, if it exists and is valid, use EOS_Achievements_PlayerAchievement_Release when finished
 *
 * @see EOS_Achievements_PlayerAchievement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutAchievement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the player achievement is not found
 *         EOS_Invalid_ProductUserID if you pass an invalid user ID
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyPlayerAchievementByAchievementId(EOS_HAchievements Handle, const EOS_Achievements_CopyPlayerAchievementByAchievementIdOptions* Options, EOS_Achievements_PlayerAchievement ** OutAchievement);

/**
 * Unlocks a number of achievements for a specific player.
 *
 * @param Options Structure containing information about the achievements and the player whose achievements we're unlocking.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the unlock achievements operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_UnlockAchievements(EOS_HAchievements Handle, const EOS_Achievements_UnlockAchievementsOptions* Options, void* ClientData, const EOS_Achievements_OnUnlockAchievementsCompleteCallback CompletionDelegate);

/**
 * Register to receive achievement unlocked notifications.
 * @note If the returned NotificationId is valid, you must call EOS_Achievements_RemoveNotifyAchievementsUnlocked when you no longer wish to have your NotificationHandler called.
 *
 * @see EOS_Achievements_RemoveNotifyAchievementsUnlocked
 *
 * @param Options Structure containing information about the achievement unlocked notification
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param NotificationFn A callback that is fired when an achievement unlocked notification for a user has been received
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Achievements_AddNotifyAchievementsUnlockedV2(EOS_HAchievements Handle, const EOS_Achievements_AddNotifyAchievementsUnlockedV2Options* Options, void* ClientData, const EOS_Achievements_OnAchievementsUnlockedCallbackV2 NotificationFn);

/**
 * Unregister from receiving achievement unlocked notifications.
 *
 * @see EOS_Achievements_AddNotifyAchievementsUnlocked
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_RemoveNotifyAchievementsUnlocked(EOS_HAchievements Handle, EOS_NotificationId InId);

/**
 * DEPRECATED! Use EOS_Achievements_CopyAchievementDefinitionV2ByIndex instead.
 *
 * Fetches an achievement definition from a given index.
 *
 * @param Options Structure containing the index being accessed
 * @param OutDefinition The achievement definition for the given index, if it exists and is valid, use EOS_Achievements_Definition_Release when finished
 *
 * @see EOS_Achievements_CopyAchievementDefinitionV2ByIndex
 * @see EOS_Achievements_Definition_Release
 *
 * @return EOS_Success if the information is available and passed out in OutDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the achievement definition is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyAchievementDefinitionByIndex(EOS_HAchievements Handle, const EOS_Achievements_CopyAchievementDefinitionByIndexOptions* Options, EOS_Achievements_Definition ** OutDefinition);

/**
 * DEPRECATED! Use EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId instead.
 *
 * Fetches an achievement definition from a given achievement ID.
 *
 * @param Options Structure containing the achievement ID being accessed
 * @param OutDefinition The achievement definition for the given achievement ID, if it exists and is valid, use EOS_Achievements_Definition_Release when finished
 *
 * @see EOS_Achievements_Definition_Release
 * @see EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId
 *
 * @return EOS_Success if the information is available and passed out in OutDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the achievement definition is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyAchievementDefinitionByAchievementId(EOS_HAchievements Handle, const EOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions* Options, EOS_Achievements_Definition ** OutDefinition);

/**
 * DEPRECATED! Use EOS_Achievements_GetPlayerAchievementCount, EOS_Achievements_CopyPlayerAchievementByIndex and filter for unlocked instead.
 *
 * Fetch the number of unlocked achievements that are cached locally.
 *
 * @param Options The Options associated with retrieving the unlocked achievement count
 *
 * @see EOS_Achievements_CopyUnlockedAchievementByIndex
 *
 * @return Number of unlocked achievements or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Achievements_GetUnlockedAchievementCount(EOS_HAchievements Handle, const EOS_Achievements_GetUnlockedAchievementCountOptions* Options);

/**
 * DEPRECATED! Use EOS_Achievements_CopyPlayerAchievementByAchievementId instead.
 *
 * Fetches an unlocked achievement from a given index.
 *
 * @param Options Structure containing the Product User ID and index being accessed
 * @param OutAchievement The unlocked achievement data for the given index, if it exists and is valid, use EOS_Achievements_UnlockedAchievement_Release when finished
 *
 * @see EOS_Achievements_UnlockedAchievement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutAchievement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the unlocked achievement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyUnlockedAchievementByIndex(EOS_HAchievements Handle, const EOS_Achievements_CopyUnlockedAchievementByIndexOptions* Options, EOS_Achievements_UnlockedAchievement ** OutAchievement);

/**
 * DEPRECATED! Use EOS_Achievements_CopyPlayerAchievementByAchievementId instead.
 *
 * Fetches an unlocked achievement from a given achievement ID.
 *
 * @param Options Structure containing the Product User ID and achievement ID being accessed
 * @param OutAchievement The unlocked achievement data for the given achievement ID, if it exists and is valid, use EOS_Achievements_UnlockedAchievement_Release when finished
 *
 * @see EOS_Achievements_UnlockedAchievement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutAchievement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the unlocked achievement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Achievements_CopyUnlockedAchievementByAchievementId(EOS_HAchievements Handle, const EOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions* Options, EOS_Achievements_UnlockedAchievement ** OutAchievement);

/**
 * DEPRECATED! Use EOS_Achievements_AddNotifyAchievementsUnlockedV2 instead.
 *
 * Register to receive achievement unlocked notifications.
 * @note If the returned NotificationId is valid, you must call EOS_Achievements_RemoveNotifyAchievementsUnlocked when you no longer wish to have your NotificationHandler called.
 *
 * @see EOS_Achievements_RemoveNotifyAchievementsUnlocked
 *
 * @param Options Structure containing information about the achievement unlocked notification
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param NotificationFn A callback that is fired when an achievement unlocked notification for a user has been received
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Achievements_AddNotifyAchievementsUnlocked(EOS_HAchievements Handle, const EOS_Achievements_AddNotifyAchievementsUnlockedOptions* Options, void* ClientData, const EOS_Achievements_OnAchievementsUnlockedCallback NotificationFn);

```

`EAC_SDK/SDK/include/eos_achievements_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_AchievementsHandle* EOS_HAchievements;

/** The most recent version of the EOS_Achievements_QueryDefinitions struct. */
#define EOS_ACHIEVEMENTS_QUERYDEFINITIONS_API_LATEST 3

/**
 * Input parameters for the EOS_Achievements_QueryDefinitions function.
 */
EOS_STRUCT(EOS_Achievements_QueryDefinitionsOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_QUERYDEFINITIONS_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Product User ID for user who is querying definitions.
	 * The localized text returned will be based on the locale code of the given user if they have a linked Epic Account ID.
	 * The localized text returned can also be overridden using EOS_Platform_SetOverrideLocaleCode to override the locale.
	 * If the locale code is not overridden and LocalUserId is not valid, default text will be returned.
	 */
	EOS_ProductUserId LocalUserId;
	/** Deprecated */
	EOS_EpicAccountId EpicUserId_DEPRECATED;
	/** Deprecated */
	const char** HiddenAchievementIds_DEPRECATED;
	/** Deprecated */
	uint32_t HiddenAchievementsCount_DEPRECATED;
));

/** The most recent version of the EOS_Achievements_StatThresholds struct. */
#define EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST 1

/** DEPRECATED! Use EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST instead. */
#define EOS_ACHIEVEMENTS_STATTHRESHOLD_API_LATEST EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST

/**
 * Contains information about a collection of stat threshold data.
 *
 * The threshold will depend on the stat aggregate type:
 *   LATEST (Tracks the latest value)
 *   MAX (Tracks the maximum value)
 *   MIN (Tracks the minimum value)
 *   SUM (Generates a rolling sum of the value)
 *
 * @see EOS_Achievements_Definition
 */
EOS_STRUCT(EOS_Achievements_StatThresholds, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_STATTHRESHOLDS_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the stat. */
	const char* Name;
	/** The value that the stat must surpass to satisfy the requirement for unlocking an achievement. */
	int32_t Threshold;
));

#define EOS_ACHIEVEMENTS_PLAYERSTATINFO_API_LATEST 1
/**
 * Contains information about a collection of stat info data.
 *
 * @see EOS_Achievements_PlayerAchievement
 */
EOS_STRUCT(EOS_Achievements_PlayerStatInfo, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_PLAYERSTATINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the stat. */
	const char* Name;
	/** The current value of the stat. */
	int32_t CurrentValue;
	/** The threshold value of the stat, used in determining when to unlock an achievement. */
	int32_t ThresholdValue;
));

/** The most recent version of the EOS_Achievements_DefinitionV2 struct. */
#define EOS_ACHIEVEMENTS_DEFINITIONV2_API_LATEST 2

/**
 * Contains information about a single achievement definition with localized text.
 */
EOS_STRUCT(EOS_Achievements_DefinitionV2, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_DEFINITIONV2_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID that can be used to uniquely identify the achievement. */
	const char* AchievementId;
	/** Localized display name for the achievement when it has been unlocked. */
	const char* UnlockedDisplayName;
	/** Localized description for the achievement when it has been unlocked. */
	const char* UnlockedDescription;
	/** Localized display name for the achievement when it is locked or hidden. */
	const char* LockedDisplayName;
	/** Localized description for the achievement when it is locked or hidden. */
	const char* LockedDescription;
	/** Localized flavor text that can be used by the game in an arbitrary manner. This may be null if there is no data configured in the dev portal. */
	const char* FlavorText;
	/** URL of an icon to display for the achievement when it is unlocked. This may be null if there is no data configured in the dev portal. */
	const char* UnlockedIconURL;
	/** URL of an icon to display for the achievement when it is locked or hidden. This may be null if there is no data configured in the dev portal. */
	const char* LockedIconURL;
	/** EOS_TRUE if the achievement is hidden; EOS_FALSE otherwise. */
	EOS_Bool bIsHidden;
	/** The number of stat thresholds used to monitor progress towards this achievement. */
	uint32_t StatThresholdsCount;
	/** Array of `EOS_Achievements_StatThresholds` that need to be satisfied to unlock this achievement. Consists of Name and Threshold Value. */
	const EOS_Achievements_StatThresholds* StatThresholds;
));

/**
 * Release the memory associated with EOS_Achievements_DefinitionV2. This must be called on data retrieved from
 * EOS_Achievements_CopyAchievementDefinitionV2ByIndex or EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId.
 *
 * @param AchievementDefinition - The achievement definition to release.
 *
 * @see EOS_Achievements_DefinitionV2
 * @see EOS_Achievements_CopyAchievementDefinitionV2ByIndex
 * @see EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_DefinitionV2_Release(EOS_Achievements_DefinitionV2* AchievementDefinition);


/** The most recent version of the EOS_Achievements_GetAchievementDefinitionCount API. */
#define EOS_ACHIEVEMENTS_GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_GetAchievementDefinitionCount function.
 */
EOS_STRUCT(EOS_Achievements_GetAchievementDefinitionCountOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Achievements_CopyAchievementDefinitionByIndexOptions struct. */
#define EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST 2

/** DEPRECATED! Use EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST instead. */
#define EOS_ACHIEVEMENTS_COPYDEFINITIONV2BYINDEX_API_LATEST EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST

/**
 * Input parameters for the EOS_Achievements_CopyAchievementDefinitionByIndex function.
 */
EOS_STRUCT(EOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the achievement definition to retrieve from the cache. */
	uint32_t AchievementIndex;
));

/** The most recent version of the EOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions struct. */
#define EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST 2

/** DEPRECATED! Use EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST instead. */
#define EOS_ACHIEVEMENTS_COPYDEFINITIONV2BYACHIEVEMENTID_API_LATEST EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST

/**
 * Input parameters for the EOS_Achievements_CopyAchievementDefinitionV2ByAchievementId function.
 */
EOS_STRUCT(EOS_Achievements_CopyAchievementDefinitionV2ByAchievementIdOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYACHIEVEMENTDEFINITIONV2BYACHIEVEMENTID_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID to look for when copying the definition from the cache. */
	const char* AchievementId;
));

/**
 * Data containing the result information for a query definitions request.
 */
EOS_STRUCT(EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** User-defined context that was passed into EOS_Achievements_QueryDefinitions. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Achievements_QueryDefinitions
 * @param Data An EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnQueryDefinitionsCompleteCallback, const EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo* Data);


/** The most recent version of the EOS_Achievements_QueryPlayerAchievements struct. */
#define EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_QueryPlayerAchievements function.
 */
EOS_STRUCT(EOS_Achievements_QueryPlayerAchievementsOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievements are to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID for the user who is querying for player achievements. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));

/** Timestamp value representing an undefined UnlockTime for EOS_Achievements_PlayerAchievement and EOS_Achievements_UnlockedAchievement */
#define EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED -1

/** The most recent version of the EOS_Achievements_PlayerAchievement struct. */
#define EOS_ACHIEVEMENTS_PLAYERACHIEVEMENT_API_LATEST 2

/**
 * Contains information about a single player achievement.
 */
EOS_STRUCT(EOS_Achievements_PlayerAchievement, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_PLAYERACHIEVEMENT_API_LATEST. */
	int32_t ApiVersion;
	/** This achievement's unique identifier. */
	const char* AchievementId;
	/** Progress towards completing this achievement (as a percentage). */
	double Progress;
	/** The POSIX timestamp when the achievement was unlocked. If the achievement has not been unlocked, this value will be EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED. */
	int64_t UnlockTime;
	/** The number of player stat info entries associated with this achievement. */
	int32_t StatInfoCount;
	/** Array of EOS_Achievements_PlayerStatInfo structures containing information about stat thresholds used to unlock the achievement and the player's current values for those stats. */
	const EOS_Achievements_PlayerStatInfo* StatInfo;
	/**
	 * Localized display name for the achievement based on this specific player's current progress on the achievement.
	 * @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked.
	 */
	const char* DisplayName;
	/**
	 * Localized description for the achievement based on this specific player's current progress on the achievement.
	 * @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked.
	 */
	const char* Description;
	/**
	 * URL of an icon to display for the achievement based on this specific player's current progress on the achievement. This may be null if there is no data configured in the dev portal.
	 * @note The current progress is updated when EOS_Achievements_QueryPlayerAchievements succeeds and when an achievement is unlocked.
	 */
	const char* IconURL;
	/** Localized flavor text that can be used by the game in an arbitrary manner. This may be null if there is no data configured in the dev portal. */
	const char* FlavorText;
));

/** The most recent version of the EOS_Achievements_GetPlayerAchievementCount API. */
#define EOS_ACHIEVEMENTS_GETPLAYERACHIEVEMENTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_GetPlayerAchievementCount function.
 */
EOS_STRUCT(EOS_Achievements_GetPlayerAchievementCountOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_GETPLAYERACHIEVEMENTCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievement count is being retrieved. */
	EOS_ProductUserId UserId;
));

/** The most recent version of the EOS_Achievements_CopyPlayerAchievementByIndexOptions struct. */
#define EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_CopyPlayerAchievementByIndex function.
 */
EOS_STRUCT(EOS_Achievements_CopyPlayerAchievementByIndexOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievement is to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The index of the player achievement data to retrieve from the cache. */
	uint32_t AchievementIndex;
	/** The Product User ID for the user who is querying for a player achievement. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Achievements_CopyPlayerAchievementByAchievementIdOptions struct. */
#define EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYACHIEVEMENTID_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_CopyPlayerAchievementByAchievementId function.
 */
EOS_STRUCT(EOS_Achievements_CopyPlayerAchievementByAchievementIdOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYACHIEVEMENTID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievement is to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** Achievement ID to search for when retrieving player achievement data from the cache. */
	const char* AchievementId;
	/** The Product User ID for the user who is querying for a player achievement. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Release the memory associated with a player achievement. This must be called on data retrieved from
 * EOS_Achievements_CopyPlayerAchievementByIndex or EOS_Achievements_CopyPlayerAchievementByAchievementId.
 *
 * @param Achievement - The achievement data to release.
 *
 * @see EOS_Achievements_PlayerAchievement
 * @see EOS_Achievements_CopyPlayerAchievementByIndex
 * @see EOS_Achievements_CopyPlayerAchievementByAchievementId
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_PlayerAchievement_Release(EOS_Achievements_PlayerAchievement* Achievement);

/**
 * Data containing the result information for querying a player's achievements request.
 */
EOS_STRUCT(EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Achievements_QueryPlayerAchievements. */
	void* ClientData;
	/** The Product User ID whose achievements were retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID of the user who initiated this request. For a Dedicated Server this should be null. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Achievements_QueryPlayerAchievements
 *
 * @param Data An EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo containing the output information and result
 *
 * @see EOS_Achievements_PlayerAchievement_Release
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnQueryPlayerAchievementsCompleteCallback, const EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo* Data);


/** The most recent version of the EOS_Achievements_UnlockAchievements struct. */
#define EOS_ACHIEVEMENTS_UNLOCKACHIEVEMENTS_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_UnlockAchievements function.
 */
EOS_STRUCT(EOS_Achievements_UnlockAchievementsOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_UNLOCKACHIEVEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose achievements we want to unlock. */
	EOS_ProductUserId UserId;
	/** An array of Achievement IDs to unlock. */
	const char** AchievementIds;
	/** The number of achievements to unlock. */
	uint32_t AchievementsCount;
));

/**
 * Data containing the result information for unlocking achievements request.
 */
EOS_STRUCT(EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Achievements_UnlockAchievements. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId UserId;
	/** The number of achievements that the operation unlocked. */
	uint32_t AchievementsCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_Achievements_UnlockAchievements
 * @param Data An EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnUnlockAchievementsCompleteCallback, const EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo* Data);

/** The most recent version of the EOS_Achievements_AddNotifyAchievementsUnlockedV2 API. */
#define EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKEDV2_API_LATEST 2

/**
 * Input parameters for the EOS_Achievements_AddNotifyAchievementsUnlocked function.
 */
EOS_STRUCT(EOS_Achievements_AddNotifyAchievementsUnlockedV2Options, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKEDV2_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Achievements_OnAchievementsUnlockedCallbackV2 Function.
 */
EOS_STRUCT(EOS_Achievements_OnAchievementsUnlockedCallbackV2Info, (
	/** Context that was passed into EOS_Achievements_AddNotifyAchievementsUnlocked */
	void* ClientData;
	/** The Product User ID for the user who received the unlocked achievements notification */
	EOS_ProductUserId UserId;
	/** The Achievement ID for the achievement that was unlocked. Pass this to EOS_Achievements_CopyPlayerAchievementByAchievementId to get the full achievement information. */
	const char* AchievementId;
	/** POSIX timestamp when the achievement was unlocked. */
	int64_t UnlockTime;
));

/**
 * Function prototype definition for notifications that come from EOS_Achievements_AddNotifyAchievementsUnlockedV2
 *
 * @param Data An EOS_Achievements_OnAchievementsUnlockedCallbackV2Info containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnAchievementsUnlockedCallbackV2, const EOS_Achievements_OnAchievementsUnlockedCallbackV2Info* Data);


#pragma pack(pop)

#include "eos_achievements_types_deprecated.inl"

```

`EAC_SDK/SDK/include/eos_achievements_types_deprecated.inl`:

```inl
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

/**
 * This file contains the deprecated types for EOS Achievements. In a future version, these types will be removed.
 */

#pragma pack(push, 8)

/** The most recent version of the EOS_Achievements_Definition struct. */
#define EOS_ACHIEVEMENTS_DEFINITION_API_LATEST 1

/**
 * Contains information about a single achievement definition with localized text.
 */
EOS_STRUCT(EOS_Achievements_Definition, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_DEFINITION_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID that can be used to uniquely identify the achievement. */
	const char* AchievementId;
	/** Text representing the Name to display in-game when achievement has been unlocked. */
	const char* DisplayName;
	/** Text representing the description to display in-game when achievement has been unlocked. */
	const char* Description;
	/** Text representing the name to display in-game when achievement is locked. */
	const char* LockedDisplayName;
	/** Text representing the description of what needs to be done to trigger the unlock of this achievement. */
	const char* LockedDescription;
	/** Text representing the description to display in-game when achievement is hidden. */
	const char* HiddenDescription;
	/** Text representing the description of what happens when the achievement is unlocked. */
	const char* CompletionDescription;
	/** Text representing the icon to display in-game when achievement is unlocked. */
	const char* UnlockedIconId;
	/** Text representing the icon to display in-game when achievement is locked. */
	const char* LockedIconId;
	/** True if achievement is hidden, false otherwise. */
	EOS_Bool bIsHidden;
	/** The number of stat thresholds. */
	int32_t StatThresholdsCount;
	/** Array of stat thresholds that need to be satisfied to unlock the achievement. */
	const EOS_Achievements_StatThresholds* StatThresholds;
));

/**
 * Release the memory associated with achievement definitions. This must be called on data retrieved from
 * EOS_Achievements_CopyAchievementDefinitionByIndex or EOS_Achievements_CopyAchievementDefinitionByAchievementId.
 *
 * @param AchievementDefinition - The achievement definition to release.
 *
 * @see EOS_Achievements_Definition
 * @see EOS_Achievements_CopyAchievementDefinitionByIndex
 * @see EOS_Achievements_CopyAchievementDefinitionByAchievementId
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_Definition_Release(EOS_Achievements_Definition* AchievementDefinition);

/** The most recent version of the EOS_Achievements_CopyAchievementDefinitionByIndexOptions struct. */
#define EOS_ACHIEVEMENTS_COPYDEFINITIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_CopyAchievementDefinitionByIndex function.
 */
EOS_STRUCT(EOS_Achievements_CopyAchievementDefinitionByIndexOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYDEFINITIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the achievement definition to retrieve from the cache */
	uint32_t AchievementIndex;
));

/** The most recent version of the EOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions struct. */
#define EOS_ACHIEVEMENTS_COPYDEFINITIONBYACHIEVEMENTID_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_CopyAchievementDefinitionByAchievementId function.
 */
EOS_STRUCT(EOS_Achievements_CopyAchievementDefinitionByAchievementIdOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYDEFINITIONBYACHIEVEMENTID_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID to look for when copying definition from the cache */
	const char* AchievementId;
));

/** The most recent version of the EOS_Achievements_UnlockedAchievement struct. */
#define EOS_ACHIEVEMENTS_UNLOCKEDACHIEVEMENT_API_LATEST 1

/**
 * Contains information about a single unlocked achievement.
 */
EOS_STRUCT(EOS_Achievements_UnlockedAchievement, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_UNLOCKEDACHIEVEMENT_API_LATEST. */
	int32_t ApiVersion;
	/** Achievement ID that can be used to uniquely identify the unlocked achievement. */
	const char* AchievementId;
	/** If not EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED then this is the POSIX timestamp that the achievement was unlocked. */
	int64_t UnlockTime;
));

/** The most recent version of the EOS_Achievements_GetUnlockedAchievementCount API. */
#define EOS_ACHIEVEMENTS_GETUNLOCKEDACHIEVEMENTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_GetUnlockedAchievementCount function.
 */
EOS_STRUCT(EOS_Achievements_GetUnlockedAchievementCountOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_GETUNLOCKEDACHIEVEMENTCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID for which to retrieve the unlocked achievement count */
	EOS_ProductUserId UserId;
));

/** The most recent version of the EOS_Achievements_CopyUnlockedAchievementByIndexOptions struct. */
#define EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_CopyUnlockedAchievementByIndex function.
 */
EOS_STRUCT(EOS_Achievements_CopyUnlockedAchievementByIndexOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user who is copying the unlocked achievement */
	EOS_ProductUserId UserId;
	/** Index of the unlocked achievement to retrieve from the cache */
	uint32_t AchievementIndex;
));

/** The most recent version of the EOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions struct. */
#define EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYACHIEVEMENTID_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_CopyUnlockedAchievementByAchievementId function.
 */
EOS_STRUCT(EOS_Achievements_CopyUnlockedAchievementByAchievementIdOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_COPYUNLOCKEDACHIEVEMENTBYACHIEVEMENTID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user who is copying the unlocked achievement */
	EOS_ProductUserId UserId;
	/** AchievementId of the unlocked achievement to retrieve from the cache */
	const char* AchievementId;
));


/** The most recent version of the EOS_Achievements_AddNotifyAchievementsUnlocked API. */
#define EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKED_API_LATEST 1

/**
 * Input parameters for the EOS_Achievements_AddNotifyAchievementsUnlocked function.
 */
EOS_STRUCT(EOS_Achievements_AddNotifyAchievementsUnlockedOptions, (
	/** API Version: Set this to EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Achievements_OnAchievementsUnlockedCallback Function.
 */
EOS_STRUCT(EOS_Achievements_OnAchievementsUnlockedCallbackInfo, (
	/** Context that was passed into EOS_Achievements_AddNotifyAchievementsUnlocked */
	void* ClientData;
	/** The Product User ID for the user who received the unlocked achievements notification */
	EOS_ProductUserId UserId;
	/** The number of achievements. */
	uint32_t AchievementsCount;
	/** This member is not used and will always be set to NULL. */
	const char** AchievementIds;
));

/**
 * Function prototype definition for notifications that come from EOS_Achievements_AddNotifyAchievementsUnlocked
 *
 * @param Data A EOS_Achievements_OnAchievementsUnlockedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Achievements_OnAchievementsUnlockedCallback, const EOS_Achievements_OnAchievementsUnlockedCallbackInfo* Data);

/**
 * Release the memory associated with an unlocked achievement. This must be called on data retrieved from
 * EOS_Achievements_CopyUnlockedAchievementByIndex or EOS_Achievements_CopyUnlockedAchievementByAchievementId.
 *
 * @param Achievement - The unlocked achievement data to release.
 *
 * @see EOS_Achievements_UnlockedAchievement
 * @see EOS_Achievements_CopyUnlockedAchievementByIndex
 * @see EOS_Achievements_CopyUnlockedAchievementByAchievementId
 */
EOS_DECLARE_FUNC(void) EOS_Achievements_UnlockedAchievement_Release(EOS_Achievements_UnlockedAchievement* Achievement);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_anticheatclient.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_anticheatclient_types.h"

/**
 * Add a callback issued when a new message must be dispatched to the game server. The bound function will only be called
 * between a successful call to EOS_AntiCheatClient_BeginSession and the matching EOS_AntiCheatClient_EndSession call in mode EOS_ACCM_ClientServer.
 * Mode: EOS_ACCM_ClientServer.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyMessageToServer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyMessageToServerOptions* Options, void* ClientData, EOS_AntiCheatClient_OnMessageToServerCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyMessageToServer handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyMessageToServer(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Add a callback issued when a new message must be dispatched to a connected peer. The bound function will only be called
 * between a successful call to EOS_AntiCheatClient_BeginSession and the matching EOS_AntiCheatClient_EndSession call in mode EOS_ACCM_PeerToPeer.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyMessageToPeer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyMessageToPeerOptions* Options, void* ClientData, EOS_AntiCheatClient_OnMessageToPeerCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyMessageToPeer handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyMessageToPeer(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Add a callback issued when an action must be applied to a connected client. The bound function will only be called
 * between a successful call to EOS_AntiCheatClient_BeginSession and the matching EOS_AntiCheatClient_EndSession call in mode EOS_ACCM_PeerToPeer.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyPeerActionRequired(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions* Options, void* ClientData, EOS_AntiCheatClient_OnPeerActionRequiredCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyPeerActionRequired handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyPeerActionRequired(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Add an optional callback issued when a connected peer's authentication status changes. The bound function will only be called
 * between a successful call to EOS_AntiCheatClient_BeginSession and the matching EOS_AntiCheatClient_EndSession call in mode EOS_ACCM_PeerToPeer.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyPeerAuthStatusChanged(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions* Options, void* ClientData, EOS_AntiCheatClient_OnPeerAuthStatusChangedCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyPeerAuthStatusChanged handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyPeerAuthStatusChanged(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Add a callback when a message must be displayed to the local client informing them on a local integrity violation,
 * which will prevent further online play.
 * Mode: Any.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatClient_AddNotifyClientIntegrityViolated(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions* Options, void* ClientData, EOS_AntiCheatClient_OnClientIntegrityViolatedCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatClient_AddNotifyClientIntegrityViolated handler.
 * Mode: Any.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatClient_RemoveNotifyClientIntegrityViolated(EOS_HAntiCheatClient Handle, EOS_NotificationId NotificationId);

/**
 * Begins a multiplayer game session. After this call returns successfully, the client is ready to exchange
 * anti-cheat messages with a game server or peer(s). When leaving one game session and connecting to a
 * different one, a new anti-cheat session must be created by calling EOS_AntiCheatClient_EndSession and EOS_AntiCheatClient_BeginSession again.
 * Mode: All
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the session was started successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_BeginSession(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_BeginSessionOptions* Options);

/**
 * Ends a multiplayer game session, either by leaving an ongoing session or shutting it down entirely.
 * Mode: All
 *
 * Must be called when the multiplayer session ends, or when the local user leaves a session in progress.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the session was ended normally
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_EndSession(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_EndSessionOptions* Options);

/**
 * Polls for changes in client integrity status.
 * Mode: All
 *
 * The purpose of this function is to allow the game to display information
 * about anti-cheat integrity problems to the user. These are often the result of a
 * corrupt game installation rather than cheating attempts. This function does not
 * check for violations, it only provides information about violations which have
 * automatically been discovered by the anti-cheat client. Such a violation may occur
 * at any time and afterwards the user will be unable to join any protected multiplayer
 * session until after restarting the game. Note that this function returns EOS_NotFound
 * when everything is normal and there is no violation to display.
 *
 * NOTE: This API is deprecated. In order to get client status updates,
 * use AddNotifyClientIntegrityViolated to register a callback that will
 * be called when violations are triggered.
 *
 * @param Options Structure containing input data.
 * @param OutViolationType On success, receives a code describing the violation that occurred.
 * @param OutMessage On success, receives a string describing the violation which should be displayed to the user.
 *
 * @return EOS_Success - If violation information was returned successfully
 *		   EOS_LimitExceeded - If OutMessage is too small to receive the message string. Call again with a larger OutMessage.
 *         EOS_NotFound - If no violation has occurred since the last call
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_PollStatus(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_PollStatusOptions* Options, EOS_EAntiCheatClientViolationType* OutViolationType, char* OutMessage);

/**
 * Optional. Adds an integrity catalog and certificate pair from outside the game directory,
 * for example to support mods that load from elsewhere.
 * Mode: All
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the integrity catalog was added successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_AddExternalIntegrityCatalog(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_AddExternalIntegrityCatalogOptions* Options);

/**
 * Call when an anti-cheat message is received from the game server.
 * Mode: EOS_ACCM_ClientServer.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the message was processed successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_InvalidRequest - If message contents were corrupt and could not be processed
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_ReceiveMessageFromServer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_ReceiveMessageFromServerOptions* Options);

/**
 * Optional NetProtect feature for game message encryption.
 * Calculates the required decrypted buffer size for a given input data length.
 * This will not change for a given SDK version, and allows one time allocation of reusable buffers.
 * Mode: EOS_ACCM_ClientServer.
 *
 * @param Options Structure containing input data.
 * @param OutBufferLengthBytes On success, the OutBuffer length in bytes that is required to call ProtectMessage on the given input size.
 *
 * @return EOS_Success - If the output length was calculated successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_GetProtectMessageOutputLength(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_GetProtectMessageOutputLengthOptions* Options, uint32_t* OutBufferSizeBytes);

/**
 * Optional NetProtect feature for game message encryption.
 * Encrypts an arbitrary message that will be sent to the game server and decrypted on the other side.
 * Mode: EOS_ACCM_ClientServer.
 *
 * Options.Data and OutBuffer may refer to the same buffer to encrypt in place.
 *
 * @param Options Structure containing input data.
 * @param OutBuffer On success, buffer where encrypted message data will be written.
 * @param OutBytesWritten On success, the number of bytes that were written to OutBuffer.
 *
 * @return EOS_Success - If the message was protected successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_ProtectMessage(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_ProtectMessageOptions* Options, void* OutBuffer, uint32_t* OutBytesWritten);

/**
 * Optional NetProtect feature for game message encryption.
 * Decrypts an encrypted message received from the game server.
 * Mode: EOS_ACCM_ClientServer.
 *
 * Options.Data and OutBuffer may refer to the same buffer to decrypt in place.
 *
 * @param Options Structure containing input data.
 * @param OutBuffer On success, buffer where encrypted message data will be written.
 * @param OutBytesWritten On success, the number of bytes that were written to OutBuffer.
 *
 * @return EOS_Success - If the message was unprotected successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_UnprotectMessage(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_UnprotectMessageOptions* Options, void* OutBuffer, uint32_t* OutBytesWritten);

/**
 * Registers a connected peer-to-peer client.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * Must be paired with a call to EOS_AntiCheatClient_UnregisterPeer if this user leaves the session
 * in progress, or EOS_AntiCheatClient_EndSession if the entire session is ending.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the player was registered successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_RegisterPeer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_RegisterPeerOptions* Options);

/**
 * Unregisters a disconnected peer-to-peer client.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * Must be called when a user leaves a session in progress.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the player was unregistered successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_UnregisterPeer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_UnregisterPeerOptions* Options);

/**
 * Call when an anti-cheat message is received from a peer.
 * Mode: EOS_ACCM_PeerToPeer.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the message was processed successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_AntiCheat_InvalidMode - If the current mode does not support this function
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatClient_ReceiveMessageFromPeer(EOS_HAntiCheatClient Handle, const EOS_AntiCheatClient_ReceiveMessageFromPeerOptions* Options);

```

`EAC_SDK/SDK/include/eos_anticheatclient_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"
#include "eos_anticheatcommon_types.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_AntiCheatClientHandle* EOS_HAntiCheatClient;

/** Operating modes */
EOS_ENUM(EOS_EAntiCheatClientMode,
	/** Not used */
	EOS_ACCM_Invalid = 0,
	/** Dedicated or listen server mode */
	EOS_ACCM_ClientServer = 1,
	/** Full mesh peer-to-peer mode */
	EOS_ACCM_PeerToPeer = 2
);

/** Anti-cheat integrity violation types */
EOS_ENUM(EOS_EAntiCheatClientViolationType,
	/** Not used */
	EOS_ACCVT_Invalid = 0,
	/** An anti-cheat asset integrity catalog file could not be found */
	EOS_ACCVT_IntegrityCatalogNotFound = 1,
	/** An anti-cheat asset integrity catalog file is corrupt or invalid */
	EOS_ACCVT_IntegrityCatalogError = 2,
	/** An anti-cheat asset integrity catalog file's certificate has been revoked. */
	EOS_ACCVT_IntegrityCatalogCertificateRevoked = 3,
	/**
	 * The primary anti-cheat asset integrity catalog does not include an entry for the game's
	 * main executable, which is required.
	 */
	EOS_ACCVT_IntegrityCatalogMissingMainExecutable = 4,
	/** A disallowed game file modification was detected */
	EOS_ACCVT_GameFileMismatch = 5,
	/** A disallowed game file removal was detected */
	EOS_ACCVT_RequiredGameFileNotFound = 6,
	/** A disallowed game file addition was detected */
	EOS_ACCVT_UnknownGameFileForbidden = 7,
	/** A system file failed an integrity check */
	EOS_ACCVT_SystemFileUntrusted = 8,
	/** A disallowed code module was loaded into the game process */
	EOS_ACCVT_ForbiddenModuleLoaded = 9,
	/** A disallowed game process memory modification was detected */
	EOS_ACCVT_CorruptedMemory = 10,
	/** A disallowed tool was detected running in the system */
	EOS_ACCVT_ForbiddenToolDetected = 11,
	/** An internal anti-cheat integrity check failed */
	EOS_ACCVT_InternalAntiCheatViolation = 12,
	/** Integrity checks on messages between the game client and game server failed */
	EOS_ACCVT_CorruptedNetworkMessageFlow = 13,
	/** The game is running inside a disallowed virtual machine */
	EOS_ACCVT_VirtualMachineNotAllowed = 14,
	/** A forbidden operating system configuration was detected */
	EOS_ACCVT_ForbiddenSystemConfiguration = 15
);

/**
 * Structure containing details about a new message that must be dispatched to the game server.
 */
EOS_STRUCT(EOS_AntiCheatClient_OnMessageToServerCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** The message data that must be sent to the server */
	const void* MessageData;
	/** The size in bytes of MessageData */
	uint32_t MessageDataSizeBytes;
));

/** Structure containing details about integrity violation related to the local client */
EOS_STRUCT(EOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** Code describing the violation that occurred */
	EOS_EAntiCheatClientViolationType ViolationType;
	/** String describing the violation which should be displayed to the user */
	const char* ViolationMessage;
));

/**
 * Maximum size of an individual message provided through EOS_AntiCheatClient_OnMessageToServerCallback.
 */
#define EOS_ANTICHEATCLIENT_ONMESSAGETOSERVERCALLBACK_MAX_MESSAGE_SIZE 512

/**
 * Callback issued when a new message must be dispatched to the game server.
 *
 * Messages contain opaque binary data and must be transmitted
 * to the game server using the game's own networking layer, then delivered
 * to the server anti-cheat instance using the EOS_AntiCheatServer_ReceiveMessageFromClient function.
 * The upper limit of the message size is EOS_ANTICHEATCLIENT_ONMESSAGETOSERVERCALLBACK_MAX_MESSAGE_SIZE.
 *
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnMessageToServerCallback, const EOS_AntiCheatClient_OnMessageToServerCallbackInfo* Data);

/**
 * Callback issued when the local client triggers an integrity violation.
 *
 * The message contains descriptive string of up to 256 characters and must be displayed to the player.
 *
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnClientIntegrityViolatedCallback, const EOS_AntiCheatClient_OnClientIntegrityViolatedCallbackInfo* Data);

/**
 * Maximum size of an individual message provided through EOS_AntiCheatClient_OnMessageToPeerCallback.
 */
#define EOS_ANTICHEATCLIENT_ONMESSAGETOPEERCALLBACK_MAX_MESSAGE_SIZE 512

/**
 * Callback issued when a new message must be dispatched to a connected peer.
 *
 * Messages contain opaque binary data and must be transmitted
 * to the correct peer using the game's own networking layer, then delivered
 * to the client anti-cheat instance using the EOS_AntiCheatClient_ReceiveMessageFromPeer function.
 * The upper limit of the message size is EOS_ANTICHEATCLIENT_ONMESSAGETOPEERCALLBACK_MAX_MESSAGE_SIZE.
 *
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnMessageToPeerCallback, const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Data);

/**
 * Callback issued when an action must be applied to a connected peer.
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnPeerActionRequiredCallback, const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Data);

/**
 * Optional callback issued when a connected peer's authentication status has changed.
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatClient_OnPeerAuthStatusChangedCallback, const EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo* Data);

#define EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOSERVER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyMessageToServerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOSERVER_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOPEER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyMessageToPeerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOPEER_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_ADDNOTIFYPEERACTIONREQUIRED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyPeerActionRequiredOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYPEERACTIONREQUIRED_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_ADDNOTIFYPEERAUTHSTATUSCHANGED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyPeerAuthStatusChangedOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYPEERAUTHSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_ADDNOTIFYCLIENTINTEGRITYVIOLATED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddNotifyClientIntegrityViolatedOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDNOTIFYPEERAUTHSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_BEGINSESSION_API_LATEST 3
EOS_STRUCT(EOS_AntiCheatClient_BeginSessionOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_BEGINSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Logged in user identifier from earlier call to EOS_Connect_Login family of functions */
	EOS_ProductUserId LocalUserId;
	/** Operating mode */
	EOS_EAntiCheatClientMode Mode;
));

#define EOS_ANTICHEATCLIENT_ENDSESSION_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_EndSessionOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ENDSESSION_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATCLIENT_ADDEXTERNALINTEGRITYCATALOG_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_AddExternalIntegrityCatalogOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_ADDEXTERNALINTEGRITYCATALOG_API_LATEST. */
	int32_t ApiVersion;
	/** UTF-8 path to the .bin catalog file to add */
	const char* PathToBinFile;
));

#define EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMSERVER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_ReceiveMessageFromServerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMSERVER_API_LATEST. */
	int32_t ApiVersion;
	/** The size of the data received */
	uint32_t DataLengthBytes;
	/** The data received */
	const void* Data;
));

#define EOS_ANTICHEATCLIENT_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_GetProtectMessageOutputLengthOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST. */
	int32_t ApiVersion;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
));

#define EOS_ANTICHEATCLIENT_PROTECTMESSAGE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_ProtectMessageOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_PROTECTMESSAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
	/** The data to encrypt */
	const void* Data;
	/** The size in bytes of OutBuffer */
	uint32_t OutBufferSizeBytes;
));

#define EOS_ANTICHEATCLIENT_UNPROTECTMESSAGE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_UnprotectMessageOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_UNPROTECTMESSAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
	/** The data to decrypt */
	const void* Data;
	/** The size in bytes of OutBuffer */
	uint32_t OutBufferSizeBytes;
));

/**
 * A special peer handle that represents the client itself.
 * It does not need to be registered or unregistered and is
 * used in OnPeerActionRequiredCallback to quickly signal to the user
 * that they will not be able to join online play.
 */
#define EOS_ANTICHEATCLIENT_PEER_SELF (EOS_AntiCheatCommon_ClientHandle)(-1)

/** Limits on RegisterTimeoutSeconds parameter */
#define EOS_ANTICHEATCLIENT_REGISTERPEER_MIN_AUTHENTICATIONTIMEOUT 40
#define EOS_ANTICHEATCLIENT_REGISTERPEER_MAX_AUTHENTICATIONTIMEOUT 120
#define EOS_ANTICHEATCLIENT_REGISTERPEER_API_LATEST 3
EOS_STRUCT(EOS_AntiCheatClient_RegisterPeerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_REGISTERPEER_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user (e.g. a player object pointer) */
	EOS_AntiCheatCommon_ClientHandle PeerHandle;
	/** Type of remote user being registered */
	EOS_EAntiCheatCommonClientType ClientType;
	/** Remote user's platform, if known */
	EOS_EAntiCheatCommonClientPlatform ClientPlatform;
	/**
	 * Time in seconds to allow newly registered peers to send the initial message containing their token.
	 */
	uint32_t AuthenticationTimeout;
	/** Deprecated - use PeerProductUserId instead */
	const char* AccountId_DEPRECATED;
	/**
	 * Optional IP address for the remote user. May be null if not available.
	 * IPv4 format: "0.0.0.0"
	 * IPv6 format: "0:0:0:0:0:0:0:0"
	 */
	const char* IpAddress;
	/** EOS_ProductUserId Identifier for the remote user */
	EOS_ProductUserId PeerProductUserId;
));

#define EOS_ANTICHEATCLIENT_UNREGISTERPEER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_UnregisterPeerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_UNREGISTERPEER_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user, as previously passed to EOS_AntiCheatClient_RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle PeerHandle;
));

#define EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMPEER_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_ReceiveMessageFromPeerOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMPEER_API_LATEST. */
	int32_t ApiVersion;
	/** The handle describing the sender of this message */
	EOS_AntiCheatCommon_ClientHandle PeerHandle;
	/** The size of the data received */
	uint32_t DataLengthBytes;
	/** The data received */
	const void* Data;
));

#pragma pack(pop)

#include "eos_anticheatclient_types_deprecated.inl"

```

`EAC_SDK/SDK/include/eos_anticheatclient_types_deprecated.inl`:

```inl
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

/**
 * This file contains the deprecated types for EOS AntiCheat Client. In a future version, these types will be removed.
 */

#pragma pack(push, 8)

#define EOS_ANTICHEATCLIENT_POLLSTATUS_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatClient_PollStatusOptions, (
	/** API Version: Set this to EOS_ANTICHEATCLIENT_POLLSTATUS_API_LATEST. */
	int32_t ApiVersion;
	/** The size of OutMessage in bytes. Recommended size is 256 bytes. */
	uint32_t OutMessageLength;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_anticheatcommon_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/**
 * Arbitrary data that is a unique local identifier for
 * a single remote client or peer.
 *
 * Typically this is a pointer to an object describing the
 * player, but it can be anything that is locally unique.
 */
EXTERN_C typedef void* EOS_AntiCheatCommon_ClientHandle;

/** Flags describing the type of a remote client */
EOS_ENUM(EOS_EAntiCheatCommonClientType,
	/** An ordinary player that requires anti-cheat client protection to play */
	EOS_ACCCT_ProtectedClient = 0,
	/** The player does not need the anti-cheat client to play because of their platform or other factors */
	EOS_ACCCT_UnprotectedClient = 1,
	/** The client is an AI bot, not an actual human */
	EOS_ACCCT_AIBot = 2
);

/** Flags describing the platform of a remote client, if known */
EOS_ENUM(EOS_EAntiCheatCommonClientPlatform,
	/** Unknown platform */
	EOS_ACCCP_Unknown = 0,
	/** The client is playing on Windows */
	EOS_ACCCP_Windows = 1,
	/** The client is playing on Mac */
	EOS_ACCCP_Mac = 2,
	/** The client is playing on Linux */
	EOS_ACCCP_Linux = 3,
	/** The client is playing on an Xbox device */
	EOS_ACCCP_Xbox = 4,
	/** The client is playing on a PlayStation device */
	EOS_ACCCP_PlayStation = 5,
	/** The client is playing on a Nintendo device */
	EOS_ACCCP_Nintendo = 6,
	/** The client is playing on iOS */
	EOS_ACCCP_iOS = 7,
	/** The client is playing on Android */
	EOS_ACCCP_Android = 8
);

/** Anti-cheat action values. Applicable to both clients and remote peers. */
EOS_ENUM(EOS_EAntiCheatCommonClientAction,
	/** Not used */
	EOS_ACCCA_Invalid = 0,
	/** The client/peer must be removed from the current game session */
	EOS_ACCCA_RemovePlayer = 1
);

/** Anti-cheat action reasons. Applicable to both clients and remote peers. */
EOS_ENUM(EOS_EAntiCheatCommonClientActionReason,
	/** Not used */
	EOS_ACCCAR_Invalid = 0,
	/** An internal error occurred */
	EOS_ACCCAR_InternalError = 1,
	/** An anti-cheat message received from the client/peer was corrupt or invalid */
	EOS_ACCCAR_InvalidMessage = 2,
	/** The client/peer's anti-cheat authentication failed */
	EOS_ACCCAR_AuthenticationFailed = 3,
	/** The client/peer failed to load the anti-cheat module at startup */
	EOS_ACCCAR_NullClient = 4,
	/** The client/peer's anti-cheat heartbeat was not received */
	EOS_ACCCAR_HeartbeatTimeout = 5,
	/** The client/peer failed an anti-cheat client runtime check */
	EOS_ACCCAR_ClientViolation = 6,
	/** The client/peer failed an anti-cheat backend runtime check */
	EOS_ACCCAR_BackendViolation = 7,
	/** The client/peer is temporarily blocked from playing on this game server */
	EOS_ACCCAR_TemporaryCooldown = 8,
	/** The client/peer is temporarily banned */
	EOS_ACCCAR_TemporaryBanned = 9,
	/** The client/peer is permanently banned */
	EOS_ACCCAR_PermanentBanned = 10
);

/** The client/peer's anti-cheat authentication status */
EOS_ENUM(EOS_EAntiCheatCommonClientAuthStatus,
	/** Not used */
	EOS_ACCCAS_Invalid = 0,
	/** The client/peer's anti-cheat functionality has been validated by this game server */
	EOS_ACCCAS_LocalAuthComplete = 1,
	/** The client/peer's anti-cheat functionality has been validated by the anti-cheat backend service */
	EOS_ACCCAS_RemoteAuthComplete = 2
);

/** Flags describing a remote client. These can be updated during a play session */
EOS_ENUM(EOS_EAntiCheatCommonClientFlags,
	/** No particular flags relevant for this client */
	EOS_ACCCF_None = 0,
	/** The client has admin privileges on the game server */
	EOS_ACCCF_Admin = (1 << 0)
);
EOS_ENUM_BOOLEAN_OPERATORS(EOS_EAntiCheatCommonClientFlags);

/** Flags describing the input device used by a remote client, if known. These can be updated during a play session. */
EOS_ENUM(EOS_EAntiCheatCommonClientInput,
	/** Unknown input device */
	EOS_ACCCI_Unknown = 0,
	/** The client is using mouse and keyboard */
	EOS_ACCCI_MouseKeyboard = 1,
	/** The client is using a gamepad or game controller */
	EOS_ACCCI_Gamepad = 2,
	/** The client is using a touch input device (e.g. phone/tablet screen) */
	EOS_ACCCI_TouchInput = 3
);

/**
 * Types supported for custom gameplay behavior events.
 * These have a considerable impact on performance
 */
EOS_ENUM(EOS_EAntiCheatCommonEventType,
	/** Not used */
	EOS_ACCET_Invalid = 0,
	/**
	 * A general game event that is not specific to any individual player.
	 * Low memory use which is constant with respect to the number of players.
	 */
	EOS_ACCET_GameEvent = 1,
	/**
	 * An event that is logically associated with a specific player. Events logged in
	 * this category require a specific ClientHandle to which they will be attached.
	 * Higher memory use which scales according to the number of players.
	 */
	EOS_ACCET_PlayerEvent = 2
);

/** Types supported for custom gameplay behavior event parameters */
EOS_ENUM(EOS_EAntiCheatCommonEventParamType,
	/** Not used */
	EOS_ACCEPT_Invalid = 0,
	/** EOS_AntiCheatCommon_ClientHandle */
	EOS_ACCEPT_ClientHandle = 1,
	/** const char* */
	EOS_ACCEPT_String = 2,
	/** uint32_t */
	EOS_ACCEPT_UInt32 = 3,
	/** int32_t */
	EOS_ACCEPT_Int32 = 4,
	/** uint64_t */
	EOS_ACCEPT_UInt64 = 5,
	/** int64_t */
	EOS_ACCEPT_Int64 = 6,
	/** EOS_AntiCheatCommon_Vec3f */
	EOS_ACCEPT_Vector3f = 7,
	/** EOS_AntiCheatCommon_Quat */
	EOS_ACCEPT_Quat = 8,
	/** float */
	EOS_ACCEPT_Float = 9
);

/** Details of a player's movement state */
EOS_ENUM(EOS_EAntiCheatCommonPlayerMovementState,
	/** No particular state applies */
	EOS_ACCPMS_None = 0,
	/** Player is crouching */
	EOS_ACCPMS_Crouching = 1,
	/** Player is prone */
	EOS_ACCPMS_Prone = 2,
	/** Player is mounted in a vehicle or similar */
	EOS_ACCPMS_Mounted = 3,
	/** Player is swimming in a fluid volume */
	EOS_ACCPMS_Swimming = 4,
	/** Player is falling under the effects of gravity, such as when jumping or walking off the edge of a surface */
	EOS_ACCPMS_Falling = 5,
	/** Player is flying, ignoring the effects of gravity */
	EOS_ACCPMS_Flying = 6,
	/** Player is on a ladder */
	EOS_ACCPMS_OnLadder = 7
);

/** The source of a damage event */
EOS_ENUM(EOS_EAntiCheatCommonPlayerTakeDamageSource,
	/** No particular source relevant */
	EOS_ACCPTDS_None = 0,
	/** Damage caused by a player controlled character */
	EOS_ACCPTDS_Player = 1,
	/** Damage caused by a non-player character such as an AI enemy */
	EOS_ACCPTDS_NonPlayerCharacter = 2,
	/** Damage caused by the world (falling off level, into lava, etc) */
	EOS_ACCPTDS_World = 3
);

/** Type of damage applied in a damage event */
EOS_ENUM(EOS_EAntiCheatCommonPlayerTakeDamageType,
	/** No particular type relevant */
	EOS_ACCPTDT_None = 0,
	/** Damage caused by a point source such as a bullet or melee attack */
	EOS_ACCPTDT_PointDamage = 1,
	/** Damage caused by a radial source such as an explosion */
	EOS_ACCPTDT_RadialDamage = 2,
	/** Damage over time such as bleeding, poison, etc */
	EOS_ACCPTDT_DamageOverTime = 3
);

/** The result of a damage event, if any */
EOS_ENUM(EOS_EAntiCheatCommonPlayerTakeDamageResult,
	/** No direct state change consequence for the victim */
	EOS_ACCPTDR_None = 0,
	/** Player character is temporarily incapacitated and requires assistance to recover */
	EOS_ACCPTDR_Downed = 1,
	/** Player character is permanently incapacitated and cannot recover (e.g. dead) */
	EOS_ACCPTDR_Eliminated = 2
);

/** Vector using left-handed coordinate system (as in Unreal Engine) */
EOS_STRUCT(EOS_AntiCheatCommon_Vec3f, (
	/** X axis coordinate - forward direction */
	float x;
	/** Y axis coordinate - right direction */
	float y;
	/** Z axis coordinate - up direction */
	float z;
));

/** Quaternion using left-handed coordinate system (as in Unreal Engine) */
EOS_STRUCT(EOS_AntiCheatCommon_Quat, (
	/** W component - scalar part */
	float w;
	/** X component - forward direction */
	float x;
	/** Y component - right direction */
	float y;
	/** Z component - up direction */
	float z;
));

/**
 * Structure containing details about a new message that must be dispatched to a connected client/peer.
 */
EOS_STRUCT(EOS_AntiCheatCommon_OnMessageToClientCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** The identifier of the client/peer that this message must be delivered to. See the RegisterClient and RegisterPeer functions. */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** The message data that must be sent to the client */
	const void* MessageData;
	/** The size in bytes of MessageData */
	uint32_t MessageDataSizeBytes;
));

/** Structure containing details about a required client/peer action */
EOS_STRUCT(EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** The identifier of the client/peer that this action applies to. See the RegisterClient and RegisterPeer functions. */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** The action that must be applied to the specified client/peer */
	EOS_EAntiCheatCommonClientAction ClientAction;
	/** Code indicating the reason for the action. This can be displayed to the affected player. */
	EOS_EAntiCheatCommonClientActionReason ActionReasonCode;
	/** String containing details about the action reason. This can be displayed to the affected player. */
	const char* ActionReasonDetailsString;
));

/** Structure containing details about a client/peer authentication status change */
EOS_STRUCT(EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo, (
	/** Caller-specified context data */
	void* ClientData;
	/** The identifier of the client/peer that this status change applies to. See the RegisterClient and RegisterPeer functions. */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** The client/peer's new authentication status */
	EOS_EAntiCheatCommonClientAuthStatus ClientAuthStatus;
));

#define EOS_ANTICHEATCOMMON_SETCLIENTDETAILS_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_SetClientDetailsOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_SETCLIENTDETAILS_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** General flags associated with this client, if any */
	EOS_EAntiCheatCommonClientFlags ClientFlags;
	/** Input device being used by this client, if known */
	EOS_EAntiCheatCommonClientInput ClientInputMethod;
));

#define EOS_ANTICHEATCOMMON_SETGAMESESSIONID_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_SetGameSessionIdOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_SETGAMESESSIONID_API_LATEST. */
	int32_t ApiVersion;
	/** Game session identifier */
	const char* GameSessionId;
));

#define EOS_ANTICHEATCOMMON_REGISTEREVENT_API_LATEST 1
#define EOS_ANTICHEATCOMMON_REGISTEREVENT_CUSTOMEVENTBASE 0x10000000
#define EOS_ANTICHEATCOMMON_REGISTEREVENT_MAX_PARAMDEFSCOUNT 12
EOS_STRUCT(EOS_AntiCheatCommon_RegisterEventParamDef, (
	/** Parameter name. Allowed characters are 0-9, A-Z, a-z, '_', '-' */
	const char* ParamName;
	/** Parameter type */
	EOS_EAntiCheatCommonEventParamType ParamType;
));
EOS_STRUCT(EOS_AntiCheatCommon_RegisterEventOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_REGISTEREVENT_API_LATEST. */
	int32_t ApiVersion;
	/** Unique event identifier. Must be >= EOS_ANTICHEATCOMMON_REGISTEREVENT_CUSTOMEVENTBASE. */
	uint32_t EventId;
	/** Name of the custom event. Allowed characters are 0-9, A-Z, a-z, '_', '-' */
	const char* EventName;
	/** Type of the custom event */
	EOS_EAntiCheatCommonEventType EventType;
	/** Number of parameters described in ParamDefs. Must be <= EOS_ANTICHEATCOMMON_REGISTEREVENT_MAX_PARAMDEFSCOUNT. */
	uint32_t ParamDefsCount;
	/** Pointer to an array of EOS_AntiCheatCommon_RegisterEventParamDef with ParamDefsCount elements */
	const EOS_AntiCheatCommon_RegisterEventParamDef* ParamDefs;
));

#define EOS_ANTICHEATCOMMON_LOGEVENT_API_LATEST 1
#define EOS_ANTICHEATCOMMON_LOGEVENT_STRING_MAX_LENGTH 39
EOS_STRUCT(EOS_AntiCheatCommon_LogEventParamPair, (
	/** Parameter type */
	EOS_EAntiCheatCommonEventParamType ParamValueType;
	/** Parameter value */
	union
	{
		EOS_AntiCheatCommon_ClientHandle ClientHandle;
		const char* String; // Will be truncated if longer than EOS_ANTICHEATCOMMON_LOGEVENT_STRING_MAX_LENGTH bytes.
		uint32_t UInt32;
		int32_t Int32;
		uint64_t UInt64;
		int64_t Int64;
		EOS_AntiCheatCommon_Vec3f Vec3f;
		EOS_AntiCheatCommon_Quat Quat;
		float Float;
	} ParamValue;
));
EOS_STRUCT(EOS_AntiCheatCommon_LogEventOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGEVENT_API_LATEST. */
	int32_t ApiVersion;
	/** Optional client who this event is primarily associated with. If not applicable, use 0. */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** Unique event identifier previously configured in RegisterEvent */
	uint32_t EventId;
	/** Number of parameters described in Params */
	uint32_t ParamsCount;
	/** Set of parameter types previously configured in RegisterEvent, and their values */
	const EOS_AntiCheatCommon_LogEventParamPair* Params;
));

#define EOS_ANTICHEATCOMMON_LOGGAMEROUNDSTART_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogGameRoundStartOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGGAMEROUNDSTART_API_LATEST. */
	int32_t ApiVersion;
	/** Optional game session or match identifier useful for some backend API integrations */
	const char* SessionIdentifier;
	/** Optional name of the map being played */
	const char* LevelName;
	/** Optional name of the game mode being played */
	const char* ModeName;
	/** Optional length of the game round to be played, in seconds. If none, use 0. */
	uint32_t RoundTimeSeconds;
));

#define EOS_ANTICHEATCOMMON_LOGGAMEROUNDEND_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogGameRoundEndOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGGAMEROUNDEND_API_LATEST. */
	int32_t ApiVersion;
	/** Optional identifier for the winning team */
	uint32_t WinningTeamId;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERSPAWN_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerSpawnOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERSPAWN_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle SpawnedPlayerHandle;
	/** Optional identifier for the player's team. If none, use 0. */
	uint32_t TeamId;
	/** Optional identifier for the player's character. If none, use 0. */
	uint32_t CharacterId;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERDESPAWN_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerDespawnOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERDESPAWN_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle DespawnedPlayerHandle;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERREVIVE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerReviveOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERREVIVE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle RevivedPlayerHandle;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle ReviverPlayerHandle;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERTICK_API_LATEST 3
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerTickOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERTICK_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle PlayerHandle;
	/** Player character's current world position as a 3D vector. This should be the center of the character. */
	EOS_AntiCheatCommon_Vec3f* PlayerPosition;
	/** Player camera's current world rotation as a quaternion. */
	EOS_AntiCheatCommon_Quat* PlayerViewRotation;
	/** True if the player's view is zoomed (e.g. using a sniper rifle), otherwise false */
	EOS_Bool bIsPlayerViewZoomed;
	/** Player's current health value */
	float PlayerHealth;
	/** Any movement state applicable */
	EOS_EAntiCheatCommonPlayerMovementState PlayerMovementState;
	/** Player camera's current world position as a 3D vector. */
	EOS_AntiCheatCommon_Vec3f* PlayerViewPosition;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_API_LATEST 2
#define EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_WEAPONNAME_MAX_LENGTH 16
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerUseWeaponData, (
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle PlayerHandle;
	/** Attack origin world position as a 3D vector */
	EOS_AntiCheatCommon_Vec3f* PlayerPosition;
	/** Attack direction as a quaternion */
	EOS_AntiCheatCommon_Quat* PlayerViewRotation;
	/** True if the player's view is zoomed (e.g. using a sniper rifle), otherwise false */
	EOS_Bool bIsPlayerViewZoomed;
	/** Set to true if the player is using a melee attack, otherwise false */
	EOS_Bool bIsMeleeAttack;
	/** Name of the weapon used. Will be truncated to EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_WEAPONNAME_MAX_LENGTH bytes if longer. */
	const char* WeaponName;
));
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerUseWeaponOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERUSEWEAPON_API_LATEST. */
	int32_t ApiVersion;
	/** Struct containing detailed information about a weapon use event */
	EOS_AntiCheatCommon_LogPlayerUseWeaponData* UseWeaponData;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERUSEABILITY_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerUseAbilityOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERUSEABILITY_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle PlayerHandle;
	/** Game defined unique identifier for the ability being used */
	uint32_t AbilityId;
	/** Duration of the ability effect in milliseconds. If not applicable, use 0. */
	uint32_t AbilityDurationMs;
	/** Cooldown until the ability can be used again in milliseconds. If not applicable, use 0. */
	uint32_t AbilityCooldownMs;
));

#define EOS_ANTICHEATCOMMON_LOGPLAYERTAKEDAMAGE_API_LATEST 4
EOS_STRUCT(EOS_AntiCheatCommon_LogPlayerTakeDamageOptions, (
	/** API Version: Set this to EOS_ANTICHEATCOMMON_LOGPLAYERTAKEDAMAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value used in RegisterClient/RegisterPeer */
	EOS_AntiCheatCommon_ClientHandle VictimPlayerHandle;
	/** Victim player character's world position as a 3D vector. This should be the center of the character. */
	EOS_AntiCheatCommon_Vec3f* VictimPlayerPosition;
	/** Victim player camera's world rotation as a quaternion. */
	EOS_AntiCheatCommon_Quat* VictimPlayerViewRotation;
	/** Locally unique value used in RegisterClient/RegisterPeer if applicable, otherwise 0. */
	EOS_AntiCheatCommon_ClientHandle AttackerPlayerHandle;
	/** Attacker player character's world position as a 3D vector if applicable, otherwise NULL. */
	EOS_AntiCheatCommon_Vec3f* AttackerPlayerPosition;
	/** Attacker player camera's world rotation as a quaternion if applicable, otherwise NULL. */
	EOS_AntiCheatCommon_Quat* AttackerPlayerViewRotation;
	/**
	 * True if the damage was applied instantly at the time of attack from the game
	 * simulation's perspective, otherwise false (simulated ballistics, arrow, etc).
	 */
	EOS_Bool bIsHitscanAttack;
	/**
	 * True if there is a visible line of sight between the attacker and the victim at the time
	 * that damage is being applied, false if there is an obstacle like a wall or terrain in
	 * the way. For some situations like melee or hitscan weapons this is trivially
	 * true, for others like projectiles with simulated physics it may not be e.g. a player
	 * could fire a slow moving projectile and then move behind cover before it strikes.
	 *
	 * This can be an estimate, or can simply be always set to true if it is not feasible
	 * to compute in your game.
	 */
	EOS_Bool bHasLineOfSight;
	/** True if this was a critical hit that causes extra damage (e.g. headshot) */
	EOS_Bool bIsCriticalHit;
	/** Deprecated - use DamagePosition instead */
	uint32_t HitBoneId_DEPRECATED;
	/** Number of health points that the victim lost due to this damage event */
	float DamageTaken;
	/** Number of health points that the victim has remaining after this damage event */
	float HealthRemaining;
	/** Source of the damage event */
	EOS_EAntiCheatCommonPlayerTakeDamageSource DamageSource;
	/** Type of the damage being applied */
	EOS_EAntiCheatCommonPlayerTakeDamageType DamageType;
	/** Result of the damage for the victim, if any */
	EOS_EAntiCheatCommonPlayerTakeDamageResult DamageResult;
	/** PlayerUseWeaponData associated with this damage event if available, otherwise NULL */
	EOS_AntiCheatCommon_LogPlayerUseWeaponData* PlayerUseWeaponData;
	/** Time in milliseconds since the associated PlayerUseWeaponData event occurred if available, otherwise 0 */
	uint32_t TimeSincePlayerUseWeaponMs;
	/** World position where damage hit the victim as a 3D vector if available, otherwise NULL */
	EOS_AntiCheatCommon_Vec3f* DamagePosition;
	/** Attacker player camera's world position as a 3D vector if applicable, otherwise NULL */
	EOS_AntiCheatCommon_Vec3f* AttackerPlayerViewPosition;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_anticheatserver.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_anticheatserver_types.h"

/**
 * Add a callback issued when a new message must be dispatched to a connected client. The bound function
 * will only be called between a successful call to EOS_AntiCheatServer_BeginSession and the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatServer_AddNotifyMessageToClient(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_AddNotifyMessageToClientOptions* Options, void* ClientData, EOS_AntiCheatServer_OnMessageToClientCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatServer_AddNotifyMessageToClient handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatServer_RemoveNotifyMessageToClient(EOS_HAntiCheatServer Handle, EOS_NotificationId NotificationId);

/**
 * Add a callback issued when an action must be applied to a connected client. The bound function
 * will only be called between a successful call to EOS_AntiCheatServer_BeginSession and the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatServer_AddNotifyClientActionRequired(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_AddNotifyClientActionRequiredOptions* Options, void* ClientData, EOS_AntiCheatServer_OnClientActionRequiredCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatServer_AddNotifyClientActionRequired handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatServer_RemoveNotifyClientActionRequired(EOS_HAntiCheatServer Handle, EOS_NotificationId NotificationId);

/**
 * Add an optional callback issued when a connected client's authentication status changes. The bound function
 * will only be called between a successful call to EOS_AntiCheatServer_BeginSession and the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data
 * @param ClientData This value is returned to the caller when NotificationFn is invoked
 * @param NotificationFn The callback to be fired
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_AntiCheatServer_AddNotifyClientAuthStatusChanged(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions* Options, void* ClientData, EOS_AntiCheatServer_OnClientAuthStatusChangedCallback NotificationFn);

/**
 * Remove a previously bound EOS_AntiCheatServer_AddNotifyClientAuthStatusChanged handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_AntiCheatServer_RemoveNotifyClientAuthStatusChanged(EOS_HAntiCheatServer Handle, EOS_NotificationId NotificationId);

/**
 * Begin the gameplay session. Event callbacks must be configured with EOS_AntiCheatServer_AddNotifyMessageToClient
 * and EOS_AntiCheatServer_AddNotifyClientActionRequired before calling this function.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the initialization succeeded
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_BeginSession(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_BeginSessionOptions* Options);

/**
 * End the gameplay session. Should be called when the server is shutting down or entering an idle state.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the initialization succeeded
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_EndSession(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_EndSessionOptions* Options);

/**
 * Register a connected client. Must be paired with a call to UnregisterClient.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the player was registered successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_RegisterClient(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_RegisterClientOptions* Options);

/**
 * Unregister a disconnected client.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the player was unregistered successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_UnregisterClient(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_UnregisterClientOptions* Options);

/**
 * Call when an anti-cheat message is received from a client.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the message was processed successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_InvalidRequest - If message contents were corrupt and could not be processed
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_ReceiveMessageFromClient(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_ReceiveMessageFromClientOptions* Options);

/**
 * Optional. Sets or updates client details including input device and admin status.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the flags were updated successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_SetClientDetails(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_SetClientDetailsOptions* Options);

/**
 * Optional. Sets or updates a game session identifier which can be attached to other data for reference.
 * The identifier can be updated at any time for currently and subsequently registered clients.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the game session identifier was set successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_SetGameSessionId(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_SetGameSessionIdOptions* Options);

/**
 * Optional. Can be used to indicate that a client is legitimately known to be
 * temporarily unable to communicate, for example as a result of loading a new level.
 *
 * The bIsNetworkActive flag must be set back to true when users enter normal
 * gameplay, otherwise anti-cheat enforcement will not work correctly.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the network state was updated successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_SetClientNetworkState(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_SetClientNetworkStateOptions* Options);

/**
 * Optional NetProtect feature for game message encryption.
 * Calculates the required decrypted buffer size for a given input data length.
 * This will not change for a given SDK version, and allows one time allocation of reusable buffers.
 *
 * @param Options Structure containing input data.
 * @param OutBufferLengthBytes On success, the OutBuffer length in bytes that is required to call ProtectMessage on the given input size.
 *
 * @return EOS_Success - If the output length was calculated successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_GetProtectMessageOutputLength(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_GetProtectMessageOutputLengthOptions* Options, uint32_t* OutBufferSizeBytes);

/**
 * Optional NetProtect feature for game message encryption.
 * Encrypts an arbitrary message that will be sent to a game client and decrypted on the other side.
 *
 * Options.Data and OutBuffer may refer to the same buffer to encrypt in place.
 *
 * @param Options Structure containing input data.
 * @param OutBuffer On success, buffer where encrypted message data will be written.
 * @param OutBytesWritten On success, the number of bytes that were written to OutBuffer.
 *
 * @return EOS_Success - If the message was protected successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_InvalidUser - If the specified ClientHandle was invalid or not currently registered. See RegisterClient.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_ProtectMessage(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_ProtectMessageOptions* Options, void* OutBuffer, uint32_t* OutBytesWritten);

/**
 * Optional NetProtect feature for game message encryption.
 * Decrypts an encrypted message received from a game client.
 *
 * Options.Data and OutBuffer may refer to the same buffer to decrypt in place.
 *
 * @param Options Structure containing input data.
 * @param OutBuffer On success, buffer where encrypted message data will be written.
 * @param OutBytesWritten On success, the number of bytes that were written to OutBuffer.
 *
 * @return EOS_Success - If the message was unprotected successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_UnprotectMessage(EOS_HAntiCheatServer Handle, const EOS_AntiCheatServer_UnprotectMessageOptions* Options, void* OutBuffer, uint32_t* OutBytesWritten);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Registers a custom gameplay event.
 *
 * All custom game events must be registered before EOS_AntiCheatServer_BeginSession is called for the first time.
 * After the first call to EOS_AntiCheatServer_BeginSession, this function cannot be called any longer.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was registered successfully
 *         EOS_InvalidParameters - If input data was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_RegisterEvent(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_RegisterEventOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a custom gameplay event.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogEvent(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogEventOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a new game round start.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogGameRoundStart(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogGameRoundStartOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a game round's end and outcome.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogGameRoundEnd(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogGameRoundEndOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a player spawning into the game.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerSpawn(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerSpawnOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a player despawning in the game, for example as a result of the character's death,
 * switching to spectator mode, etc.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerDespawn(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerDespawnOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a player being revived after being downed (see EOS_AntiCheatServer_LogPlayerTakeDamage options).
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerRevive(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerReviveOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs a player's general state including position and view direction.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerTick(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerTickOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs that a player has used a weapon, for example firing one bullet or making one melee attack.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerUseWeapon(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerUseWeaponOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs that a player has used a special ability or item which affects their character's capabilities,
 * for example temporarily increasing their speed or allowing them to see nearby players behind walls.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerUseAbility(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerUseAbilityOptions* Options);

/**
 * Optional Cerberus feature for gameplay data collection.
 * Logs that a player has taken damage.
 *
 * This function may only be called between a successful call to EOS_AntiCheatServer_BeginSession and
 * the matching EOS_AntiCheatServer_EndSession call.
 *
 * @param Options Structure containing input data.
 *
 * @return EOS_Success - If the event was logged successfully
 *         EOS_InvalidParameters - If input data was invalid
 *         EOS_NotConfigured - If called outside of BeginSession/EndSession boundaries
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_AntiCheatServer_LogPlayerTakeDamage(EOS_HAntiCheatServer Handle, const EOS_AntiCheatCommon_LogPlayerTakeDamageOptions* Options);

```

`EAC_SDK/SDK/include/eos_anticheatserver_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"
#include "eos_anticheatcommon_types.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_AntiCheatServerHandle* EOS_HAntiCheatServer;

/**
 * Maximum size of an individual message provided through EOS_AntiCheatServer_OnMessageToClientCallback.
 */
#define EOS_ANTICHEATSERVER_ONMESSAGETOCLIENTCALLBACK_MAX_MESSAGE_SIZE 512

/**
 * Callback issued when a new message must be dispatched to a connected client.
 *
 * Messages contain opaque binary data and must be transmitted to the correct client
 * using the game's own networking layer, then delivered to the client anti-cheat instance
 * using the EOS_AntiCheatClient_ReceiveMessageFromServer function.
 * The upper limit of the message size is EOS_ANTICHEATSERVER_ONMESSAGETOCLIENTCALLBACK_MAX_MESSAGE_SIZE.
 *
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatServer_OnMessageToClientCallback, const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Data);

/**
 * Callback issued when an action must be applied to a connected client.
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatServer_OnClientActionRequiredCallback, const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Data);

/**
 * Optional callback issued when a connected client's authentication status has changed.
 * This callback is always issued from within EOS_Platform_Tick on its calling thread.
 */
EOS_DECLARE_CALLBACK(EOS_AntiCheatServer_OnClientAuthStatusChangedCallback, const EOS_AntiCheatCommon_OnClientAuthStatusChangedCallbackInfo* Data);

#define EOS_ANTICHEATSERVER_ADDNOTIFYMESSAGETOCLIENT_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_AddNotifyMessageToClientOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYMESSAGETOCLIENT_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTACTIONREQUIRED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_AddNotifyClientActionRequiredOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTACTIONREQUIRED_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTAUTHSTATUSCHANGED_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_AddNotifyClientAuthStatusChangedOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTAUTHSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/** Limits on RegisterTimeoutSeconds parameter */
#define EOS_ANTICHEATSERVER_BEGINSESSION_MIN_REGISTERTIMEOUT 10
#define EOS_ANTICHEATSERVER_BEGINSESSION_MAX_REGISTERTIMEOUT 120
#define EOS_ANTICHEATSERVER_BEGINSESSION_API_LATEST 3
EOS_STRUCT(EOS_AntiCheatServer_BeginSessionOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_BEGINSESSION_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Time in seconds to allow newly registered clients to complete anti-cheat authentication.
	 * Recommended value: 60
	 */
	uint32_t RegisterTimeoutSeconds;
	/** Optional name of this game server */
	const char* ServerName;
	/**
	 * Gameplay data collection APIs such as LogPlayerTick will be enabled if set to true.
	 * If you do not use these APIs you should set this value to false to reduce memory use.
	 */
	EOS_Bool bEnableGameplayData;
	/** The Product User ID of the local user who is associated with this session. Dedicated servers should set this to null. */
	EOS_ProductUserId LocalUserId;
));

#define EOS_ANTICHEATSERVER_ENDSESSION_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_EndSessionOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_ENDSESSION_API_LATEST. */
	int32_t ApiVersion;
));

#define EOS_ANTICHEATSERVER_REGISTERCLIENT_API_LATEST 2
EOS_STRUCT(EOS_AntiCheatServer_RegisterClientOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_REGISTERCLIENT_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user (e.g. a player object pointer) */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** Type of remote user being registered */
	EOS_EAntiCheatCommonClientType ClientType;
	/** Remote user's platform, if known */
	EOS_EAntiCheatCommonClientPlatform ClientPlatform;
	/**
	 * DEPRECATED - New code should set this to null and specify UserId instead.
	 *
	 * Identifier for the remote user. This is typically a string representation of an
	 * account ID, but it can be any string which is both unique (two different users will never
	 * have the same string) and consistent (if the same user connects to this game session
	 * twice, the same string will be used) in the scope of a single protected game session.
	 */
	const char* AccountId_DEPRECATED;
	/**
	 * Optional IP address for the remote user. May be null if not available.
	 * IPv4 format: "0.0.0.0"
	 * IPv6 format: "0:0:0:0:0:0:0:0"
	 */
	const char* IpAddress;
	/** The Product User ID for the remote user who is being registered. */
	EOS_ProductUserId UserId;
));

#define EOS_ANTICHEATSERVER_UNREGISTERCLIENT_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_UnregisterClientOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_UNREGISTERCLIENT_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user, as previously passed to RegisterClient */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
));

#define EOS_ANTICHEATSERVER_RECEIVEMESSAGEFROMCLIENT_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_ReceiveMessageFromClientOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_RECEIVEMESSAGEFROMCLIENT_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the corresponding remote user, as previously passed to RegisterClient */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** The size of the data received */
	uint32_t DataLengthBytes;
	/** The data received */
	const void* Data;
));

#define EOS_ANTICHEATSERVER_SETCLIENTNETWORKSTATE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_SetClientNetworkStateOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_SETCLIENTNETWORKSTATE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user (e.g. a player object pointer) */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** True if the network is functioning normally, false if temporarily interrupted */
	EOS_Bool bIsNetworkActive;
));

#define EOS_ANTICHEATSERVER_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_GetProtectMessageOutputLengthOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST. */
	int32_t ApiVersion;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
));

#define EOS_ANTICHEATSERVER_PROTECTMESSAGE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_ProtectMessageOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_PROTECTMESSAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user to whom the message will be sent */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
	/** The data to encrypt */
	const void* Data;
	/** The size in bytes of OutBuffer */
	uint32_t OutBufferSizeBytes;
));

#define EOS_ANTICHEATSERVER_UNPROTECTMESSAGE_API_LATEST 1
EOS_STRUCT(EOS_AntiCheatServer_UnprotectMessageOptions, (
	/** API Version: Set this to EOS_ANTICHEATSERVER_UNPROTECTMESSAGE_API_LATEST. */
	int32_t ApiVersion;
	/** Locally unique value describing the remote user from whom the message was received */
	EOS_AntiCheatCommon_ClientHandle ClientHandle;
	/** Length in bytes of input */
	uint32_t DataLengthBytes;
	/** The data to decrypt */
	const void* Data;
	/** The size in bytes of OutBuffer */
	uint32_t OutBufferSizeBytes;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_auth.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_auth_types.h"

/**
 * The Auth Interface is used to manage local user permissions and access to backend services through the verification of various forms of credentials.
 * All Auth Interface calls take a handle of type EOS_HAuth as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetAuthInterface function.
 *
 * @see EOS_Platform_GetAuthInterface
 */

/**
 * Login/Authenticate with user credentials.
 *
 * @param Options structure containing the account credentials to use during the login operation
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the login operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Auth_Login(EOS_HAuth Handle, const EOS_Auth_LoginOptions* Options, void* ClientData, const EOS_Auth_OnLoginCallback CompletionDelegate);

/**
 * Signs the player out of the online service.
 *
 * @param Options structure containing information about which account to log out.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the logout operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Auth_Logout(EOS_HAuth Handle, const EOS_Auth_LogoutOptions* Options, void* ClientData, const EOS_Auth_OnLogoutCallback CompletionDelegate);

/**
 * Link external account by continuing previous login attempt with a continuance token.
 *
 * The user will be presented with Epic Accounts onboarding flow managed by the SDK.
 *
 * On success, the user will be logged in at the completion of this action.
 * This will commit this external account to the Epic Account and cannot be undone in the SDK.
 *
 * @param Options structure containing the account credentials to use during the link account operation
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the link account operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Auth_LinkAccount(EOS_HAuth Handle, const EOS_Auth_LinkAccountOptions* Options, void* ClientData, const EOS_Auth_OnLinkAccountCallback CompletionDelegate);

/**
 * Deletes a previously received and locally stored persistent auth access token for the currently logged in user of the local device.
 *
 * On Desktop and Mobile platforms, the access token is deleted from the keychain of the local user and a backend request is made to revoke the token on the authentication server.
 * On Console platforms, even though the caller is responsible for storing and deleting the access token on the local device,
 * this function should still be called with the access token before its deletion to make the best effort in attempting to also revoke it on the authentication server.
 * If the function would fail on Console, the caller should still proceed as normal to delete the access token locally as intended.
 *
 * @param Options structure containing operation input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the deletion operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Auth_DeletePersistentAuth(EOS_HAuth Handle, const EOS_Auth_DeletePersistentAuthOptions* Options, void* ClientData, const EOS_Auth_OnDeletePersistentAuthCallback CompletionDelegate);

/**
 * Contact the backend service to verify validity of an existing user auth token.
 * This function is intended for server-side use only.
 *
 * @param Options structure containing information about the auth token being verified
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the logout operation completes, either successfully or in error
 *
 * @see EOS_Auth_CopyUserAuthToken
 */
EOS_DECLARE_FUNC(void) EOS_Auth_VerifyUserAuth(EOS_HAuth Handle, const EOS_Auth_VerifyUserAuthOptions* Options, void* ClientData, const EOS_Auth_OnVerifyUserAuthCallback CompletionDelegate);

/**
 * Fetch the number of accounts that are logged in.
 *
 * @return the number of accounts logged in.
 */
EOS_DECLARE_FUNC(int32_t) EOS_Auth_GetLoggedInAccountsCount(EOS_HAuth Handle);

/**
 * Fetch an Epic Account ID that is logged in.
 *
 * @param Index An index into the list of logged in accounts. If the index is out of bounds, the returned Epic Account ID will be invalid.
 *
 * @return The Epic Account ID associated with the index passed
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_Auth_GetLoggedInAccountByIndex(EOS_HAuth Handle, int32_t Index);

/**
 * Fetches the login status for an Epic Account ID.
 *
 * @param LocalUserId The Epic Account ID of the user being queried
 *
 * @return The enum value of a user's login status
 */
EOS_DECLARE_FUNC(EOS_ELoginStatus) EOS_Auth_GetLoginStatus(EOS_HAuth Handle, EOS_EpicAccountId LocalUserId);

/**
 * Fetch a user auth token for an Epic Account ID.
 *
 * A user authentication token allows any code with possession (backend/client) to perform certain actions on behalf of the user.
 * Because of this, for the purposes of user identity verification, the EOS_Auth_CopyIdToken API should be used instead.
 *
 * @param Options Structure containing the api version of CopyUserAuthToken to use
 * @param LocalUserId The Epic Account ID of the user being queried
 * @param OutUserAuthToken The auth token for the given user, if it exists and is valid; use EOS_Auth_Token_Release when finished
 *
 * @see EOS_Auth_Token_Release
 *
 * @return EOS_Success if the information is available and passed out in OutUserAuthToken
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the auth token is not found or expired.
 *
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Auth_CopyUserAuthToken(EOS_HAuth Handle, const EOS_Auth_CopyUserAuthTokenOptions* Options, EOS_EpicAccountId LocalUserId, EOS_Auth_Token ** OutUserAuthToken);

/**
 * Fetch an ID token for an Epic Account ID.
 *
 * ID tokens are used to securely verify user identities with online services.
 * The most common use case is using an ID token to authenticate the local user by their selected account ID,
 * which is the account ID that should be used to access any game-scoped data for the current application.
 *
 * An ID token for the selected account ID of a locally authenticated user will always be readily available.
 * To retrieve it for the selected account ID, you can use EOS_Auth_CopyIdToken directly after a successful user login.
 *
 * @param Options Structure containing the account ID for which to copy an ID token.
 * @param OutIdToken An ID token for the given user, if it exists and is valid; use EOS_Auth_IdToken_Release when finished.
 *
 * @see EOS_Auth_IdToken_Release
 *
 * @return EOS_Success if the information is available and passed out in OutUserIdToken
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the Id token is not found or expired.
 *
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Auth_CopyIdToken(EOS_HAuth Handle, const EOS_Auth_CopyIdTokenOptions* Options, EOS_Auth_IdToken ** OutIdToken);

/**
 * Query the backend for an ID token that describes one of the merged account IDs of a local authenticated user.
 *
 * The ID token can be used to impersonate a merged account ID when communicating with online services.
 *
 * An ID token for the selected account ID of a locally authenticated user will always be readily available and does not need to be queried explicitly.
 *
 * @param Options Structure containing the merged account ID for which to query an ID token.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Auth_QueryIdToken(EOS_HAuth Handle, const EOS_Auth_QueryIdTokenOptions* Options, void* ClientData, const EOS_Auth_OnQueryIdTokenCallback CompletionDelegate);

/**
 * Verify a given ID token for authenticity and validity.
 *
 * @param Options Structure containing information about the ID token to verify.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Auth_VerifyIdToken(EOS_HAuth Handle, const EOS_Auth_VerifyIdTokenOptions* Options, void* ClientData, const EOS_Auth_OnVerifyIdTokenCallback CompletionDelegate);

/**
 * Fetch the selected account ID to the current application for a local authenticated user.
 *
 * @param LocalUserId The account ID of a currently logged in account.
 * @param OutSelectedAccountId The selected account ID corresponding to the given account ID.
 *
 * @return EOS_Success if the user is logged in and the information is available.
 *         EOS_InvalidParameters if the output parameter is NULL.
 *         EOS_InvalidUser if the input account ID is not locally known.
 *         EOS_InvalidAuth if the input account ID is not locally logged in.
 *         EOS_NotFound otherwise.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Auth_GetSelectedAccountId(EOS_HAuth Handle, const EOS_EpicAccountId LocalUserId, EOS_EpicAccountId* OutSelectedAccountId);

/**
 * Fetch the number of merged accounts for a given logged in account.
 *
 * @param LocalUserId The account ID of a currently logged in account.
 *
 * @return the number of merged accounts for the logged in account.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Auth_GetMergedAccountsCount(EOS_HAuth Handle, const EOS_EpicAccountId LocalUserId);

/**
 * Fetch one of the merged account IDs for a given logged in account.
 *
 * @param LocalUserId The account ID of a currently logged in account.
 * @param Index An index into the list of merged accounts. If the index is out of bounds, the returned Epic Account ID will be invalid.
 *
 * @return The Epic Account ID associated with the index passed.
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_Auth_GetMergedAccountByIndex(EOS_HAuth Handle, const EOS_EpicAccountId LocalUserId, const uint32_t Index);

/**
 * Register to receive login status updates.
 * @note If the returned NotificationId is valid, you must call EOS_Auth_RemoveNotifyLoginStatusChanged when you no longer wish to have your NotificationHandler called.
 *
 * @param Options structure containing the api version of AddNotifyLoginStatusChanged to use
 * @param ClientData arbitrary data that is passed back to you in the callback
 * @param Notification a callback that is fired when the login status for a user changes
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Auth_AddNotifyLoginStatusChanged(EOS_HAuth Handle, const EOS_Auth_AddNotifyLoginStatusChangedOptions* Options, void* ClientData, const EOS_Auth_OnLoginStatusChangedCallback Notification);

/**
 * Unregister from receiving login status updates.
 *
 * @param InId handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Auth_RemoveNotifyLoginStatusChanged(EOS_HAuth Handle, EOS_NotificationId InId);

```

`EAC_SDK/SDK/include/eos_auth_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_auth_types_deprecated.inl"
#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_AuthHandle* EOS_HAuth;

/**
 * All possible types of login methods, availability depends on permissions granted to the client.
 *
 * @see EOS_Auth_Login
 * @see EOS_Auth_Credentials
 */
EOS_ENUM(EOS_ELoginCredentialType,
	/**
	 * Login using account email address and password.
	 *
	 * @note Use of this login method is restricted and cannot be used in general.
	 */
	EOS_LCT_Password = 0,
	/**
	 * A short-lived one-time use exchange code to login the local user.
	 *
	 * @details Typically retrieved via command-line parameters provided by a launcher that generated the exchange code for this application.
	 * When started, the application is expected to consume the exchange code by using the EOS_Auth_Login API as soon as possible.
	 * This is needed in order to authenticate the local user before the exchange code would expire.
	 * Attempting to consume an already expired exchange code will return EOS_EResult::EOS_Auth_ExchangeCodeNotFound error by the EOS_Auth_Login API.
	 */
	EOS_LCT_ExchangeCode = 1,
	/**
	 * Used by standalone applications distributed outside the supported game platforms such as Epic Games Store or Steam, and on Nintendo Switch.
	 *
	 * Persistent Auth is used in conjunction with the EOS_LCT_AccountPortal login method for automatic login of the local user across multiple runs of the application.
	 *
	 * Standalone applications implement the login sequence as follows:
	 * 1. Application calls EOS_Auth_Login with EOS_LCT_PersistentAuth, using a previously stored Epic refresh token for an automatic user login.
	 * 2. If automatic login fails, the application discards the Epic refresh token used as defunct, and proceeds to call EOS_Auth_Login with EOS_LCT_AccountPortal to prompt the user for manual login.
	 *
	 * @note On Desktop and Mobile platforms, the persistent refresh token is automatically managed by the SDK that stores it in the keychain of the currently logged in user of the local device.
	 * On Nintendo Switch, after a successful login the refresh token must be retrieved using the EOS_Auth_CopyUserAuthToken API and stored by the application specifically for the active Nintendo Switch user.
	 *
	 * @see EOS_LCT_AccountPortal
	 */
	EOS_LCT_PersistentAuth = 2,
	/**
	 * Not supported. Superseded by EOS_LCT_ExternalAuth login method.
	 *
	 * @see EOS_LCT_ExternalAuth
	 */
	EOS_LCT_DeviceCode = 3,
	/**
	 * Login with named credentials hosted by the EOS SDK Developer Authentication Tool.
	 *
	 * @note Used for development purposes only.
	 */
	EOS_LCT_Developer = 4,
	/**
	 * Refresh token that was retrieved from a previous call to EOS_Auth_Login API in another local process context.
	 * Mainly used in conjunction with custom desktop launcher applications.
	 *
	 * @details Can be used for example when launching the game from Epic Games Launcher and having an intermediate process
	 * in-between that requires authenticating the user before eventually starting the actual game client application.
	 * In such scenario, an intermediate launcher will log in the user by consuming the exchange code it received from the
	 * Epic Games Launcher. To allow the game client to also authenticate the user, it can copy the refresh token using the
	 * EOS_Auth_CopyUserAuthToken API and pass it via launch parameters to the started game client. The game client can then
	 * use the refresh token to log in the user.
	 */
	EOS_LCT_RefreshToken = 5,
	/**
	 * Used by standalone applications distributed outside the supported game platforms such as Epic Games Store or Steam, and on Nintendo Switch.
	 *
	 * Login using the built-in user onboarding experience provided by the SDK, which will automatically store a persistent
	 * refresh token to enable automatic user login for consecutive application runs on the local device. Applications are
	 * expected to attempt automatic login using the EOS_LCT_PersistentAuth login method, and fall back to EOS_LCT_AccountPortal
	 * to prompt users for manual login.
	 *
	 * @note On Windows, using this login method requires applications to be started through the EOS Bootstrapper application
	 * and to have the local Epic Online Services redistributable installed on the local system. See EOS_Platform_GetDesktopCrossplayStatus
	 * for adding a readiness check prior to calling EOS_Auth_Login.
	 *
	 * @see EOS_LCT_PersistentAuth
	 */
	EOS_LCT_AccountPortal = 6,
	/**
	 * Login using external account provider credentials, such as PlayStation(TM)Network, Steam, and Xbox Live.
	 *
	 * This is the intended login method on PlayStation® and Xbox console devices.
	 * On Desktop and Mobile, used when launched through any of the commonly supported platform clients.
	 *
	 * @details The user is seamlessly logged in to their Epic account using an external account access token.
	 * If the local platform account is already linked with the user's Epic account, the login will succeed and EOS_EResult::EOS_Success is returned.
	 * When the local platform account has not been linked with an Epic account yet,
	 * EOS_EResult::EOS_InvalidUser is returned and the EOS_ContinuanceToken will be set in the EOS_Auth_LoginCallbackInfo data.
	 * If EOS_EResult::EOS_InvalidUser is returned,
	 * the application should proceed to call the EOS_Auth_LinkAccount API with the EOS_ContinuanceToken to continue with the external account login
	 * and to link the external account at the end of the login flow.
	 *
	 * @details Login flow when the platform user account has not been linked with an Epic account yet:
	 * 1. Game calls EOS_Auth_Login with the EOS_LCT_ExternalAuth credential type.
	 * 2. EOS_Auth_Login returns EOS_EResult::EOS_InvalidUser with a non-null EOS_ContinuanceToken in the EOS_Auth_LoginCallbackInfo data.
	 * 3. Game calls EOS_Auth_LinkAccount with the EOS_ContinuanceToken to initiate the login flow for linking the platform account with the user's Epic account.
	 * 4. The user is taken automatically to the Epic accounts user onboarding flow managed by the SDK.
	 * 5. Once the user completes the login, cancels it or if the login flow times out, EOS_Auth_LinkAccount invokes the completion callback to the caller.
	 *    - If the user was logged in successfully, EOS_EResult::EOS_Success is returned in the EOS_Auth_LoginCallbackInfo. Otherwise, an error result code is returned accordingly.
	 *
	 * @note On Windows, using this login method requires applications to be started through the EOS Bootstrapper application
	 * and to have the local Epic Online Services redistributable installed on the local system. See EOS_Platform_GetDesktopCrossplayStatus
	 * for adding a readiness check prior to calling EOS_Auth_Login.
	 */
	EOS_LCT_ExternalAuth = 7
);

/** The most recent version of the EOS_Auth_Token struct. */
#define EOS_AUTH_TOKEN_API_LATEST 2

/**
 * Types of auth tokens
 *
 * @see EOS_Auth_CopyUserAuthToken
 * @see EOS_Auth_Token
 */
EOS_ENUM(EOS_EAuthTokenType,
	/** Auth token is for a validated client */
	EOS_ATT_Client = 0,
	/** Auth token is for a validated user */
	EOS_ATT_User = 1
);

/**
 * A structure that contains an auth token.
 * These structures are created by EOS_Auth_CopyUserAuthToken and must be passed to EOS_Auth_Token_Release.
 */
EOS_STRUCT(EOS_Auth_Token, (
	/** API Version: Set this to EOS_AUTH_TOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the app related to the client ID involved with this token */
	const char* App;
	/** Client ID that requested this token */
	const char* ClientId;
	/** The Epic Account ID associated with this auth token */
	EOS_EpicAccountId AccountId;
	/** Access token for the current user login session */
	const char* AccessToken;
	/** Time before the access token expires, in seconds, relative to the call to EOS_Auth_CopyUserAuthToken */
	double ExpiresIn;
	/** Absolute time in UTC before the access token expires, in ISO 8601 format */
	const char* ExpiresAt;
	/** Type of auth token */
	EOS_EAuthTokenType AuthType;
	/**
	 * Refresh token.
	 *
	 * @see EOS_ELoginCredentialType::EOS_LCT_RefreshToken
	 */
	const char* RefreshToken;
	/** Time before the access token expires, in seconds, relative to the call to EOS_Auth_CopyUserAuthToken */
	double RefreshExpiresIn;
	/** Absolute time in UTC before the refresh token expires, in ISO 8601 format */
	const char* RefreshExpiresAt;
));

/**
 * Release the memory associated with an EOS_Auth_Token structure. This must be called on data retrieved from EOS_Auth_CopyUserAuthToken.
 *
 * @param AuthToken The auth token structure to be released.
 *
 * @see EOS_Auth_Token
 * @see EOS_Auth_CopyUserAuthToken
 */
EOS_DECLARE_FUNC(void) EOS_Auth_Token_Release(EOS_Auth_Token* AuthToken);

/** The most recent version of the EOS_Auth_Credentials struct. */
#define EOS_AUTH_CREDENTIALS_API_LATEST 4

/**
 * Login credentials filled as part of the EOS_Auth_LoginOptions struct for EOS_Auth_Login API.
 *
 * Required input parameters to be set depend on the login credential type.
 * Any parameters not being used must be set to NULL. Otherwise, EOS_InvalidParameters error is returned.
 *
 * EOS_LCT_Password			| ID is the email address, and Token is the password.
 * EOS_LCT_ExchangeCode		| Set ID to NULL. Token is the exchange code.
 * EOS_LCT_PersistentAuth	| Set ID to NULL. On console platforms, Token is the long-lived refresh token. Otherwise, set to NULL.
 * EOS_LCT_Developer		| Set ID as the host (e.g. localhost:6547). Token is the credential name registered in the EOS Developer Authentication Tool.
 * EOS_LCT_RefreshToken		| Set ID to NULL. Token is the refresh token.
 * EOS_LCT_AccountPortal	| Set ID and Token to NULL. SystemAuthCredentialsOptions may be required on mobile platforms.
 * EOS_LCT_ExternalAuth		| Set ID to NULL or the External Account ID that belongs to the external auth token. Token is the external auth token specified by ExternalType. External Account IDs set to the ID are expected as either base-10 numeric strings for integer-based external Account IDs, or the actual string for everything else. If ID is provided, login will automatically be cancelled if the EOS SDK is able to and does detect the external account signing-out. If ID is provided, it must match the external account ID belonging to the auth-token, or login will fail.
 *
 * @see EOS_ELoginCredentialType
 * @see EOS_Auth_Login
 * @see EOS_Auth_DeletePersistentAuthOptions
 */
EOS_STRUCT(EOS_Auth_Credentials, (
	/** API Version: Set this to EOS_AUTH_CREDENTIALS_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Authentication ID value based on the used EOS_ELoginCredentialType.
	 * If not used, must be set to NULL.
	 */
	const char* Id;
	/**
	 * Authentication Token value based on the used EOS_ELoginCredentialType.
	 * If not used, must be set to NULL.
	 */
	const char* Token;
	/** Login credentials type based on the authentication method used. */
	EOS_ELoginCredentialType Type;
	/**
	 * This field is for system specific options, if any.
	 *
	 * If provided, the structure will be located in (System)/eos_(system).h.
	 * The structure will be named EOS_(System)_Auth_CredentialsOptions.
	 */
	void* SystemAuthCredentialsOptions;
	/**
	 * Type of external login. Needed to identify the external auth method to use.
	 * Used when login type is set to EOS_LCT_ExternalAuth, ignored for other EOS_ELoginCredentialType methods.
	 */
	EOS_EExternalCredentialType ExternalType;
));

/** The most recent version of the EOS_Auth_PinGrantInfo struct. */
#define EOS_AUTH_PINGRANTINFO_API_LATEST 2

/**
 * Intermediate data for completing Epic account login, when neither the in-game overlay or a platform browser is used.
 * The EOS_Auth_PinGrantInfo struct is returned as part of the EOS_Auth_LoginCallbackInfo and EOS_Auth_LinkAccountCallbackInfo structs.
 * The data inside should be exposed to the user for entry on a secondary device.
 * All data must be copied out before the completion of this callback.
 */
EOS_STRUCT(EOS_Auth_PinGrantInfo, (
	/** API Version: Set this to EOS_AUTH_PINGRANTINFO_API_LATEST. */
	int32_t ApiVersion;
	/** Code the user must input on an external device to activate the login. */
	const char* UserCode;
	/** The end-user verification URI. Users can be asked to manually type this into their browser. */
	const char* VerificationURI;
	/** Time the user has, in seconds, to complete the process or else timeout. */
	int32_t ExpiresIn;
	/** A verification URI that includes the user code. Useful for non-textual transmission. */
	const char* VerificationURIComplete;
));

/** Flags that describe user permissions */
EOS_ENUM(EOS_EAuthScopeFlags,
	EOS_AS_NoFlags = 0x0,
	/** Permissions to see your account ID, display name, and language */
	EOS_AS_BasicProfile = 0x1,
	/** Permissions to see a list of your friends who use this application */
	EOS_AS_FriendsList = 0x2,
	/** Permissions to set your online presence and see presence of your friends */
	EOS_AS_Presence = 0x4,
	/** Permissions to manage the Epic friends list. This scope is restricted to Epic first party products, and attempting to use it will result in authentication failures. */
	EOS_AS_FriendsManagement = 0x8,
	/** Permissions to see email in the response when fetching information for a user. This scope is restricted to Epic first party products, and attempting to use it will result in authentication failures. */
	EOS_AS_Email = 0x10,
	/** Permissions to see your country */
	EOS_AS_Country = 0x20
);

EOS_ENUM_BOOLEAN_OPERATORS(EOS_EAuthScopeFlags)

/** Optional login flags used in EOS_Auth_Login. */

/**
 * Specify login to be performed without SDK provided user interface.
 *
 * By default, and without this flag, the SDK uses the overlay or a system browser to show user interfaces during login
 * when the user needs to perform some action. With this flag, an error such as EOS_Auth_UserInterfaceRequired is returned
 * to the login callback, and no user interface is shown in those cases.
 */
#define EOS_LF_NO_USER_INTERFACE 0x00001

/** The most recent version of the EOS_Auth_Login API. */
#define EOS_AUTH_LOGIN_API_LATEST 3

/**
 * Input parameters for the EOS_Auth_Login function.
 */
EOS_STRUCT(EOS_Auth_LoginOptions, (
	/** API Version: Set this to EOS_AUTH_LOGIN_API_LATEST. */
	int32_t ApiVersion;
	/** Credentials specified for a given login method. */
	const EOS_Auth_Credentials* Credentials;
	/** Auth scope flags are permissions to request from the user while they are logging in. This is a bitwise-or union of EOS_EAuthScopeFlags flags defined above. */
	EOS_EAuthScopeFlags ScopeFlags;
	/** Optional flags for the desired login behavior, e.g. EOS_LF_NO_USER_INTERFACE. This is a bitwise-or union of the defined flags. */
	uint64_t LoginFlags;
));

/**
 * Output parameters for the EOS_Auth_Login Function.
 */
EOS_STRUCT(EOS_Auth_LoginCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_Login. */
	void* ClientData;
	/** The Epic Account ID of the local user who has logged in. */
	EOS_EpicAccountId LocalUserId;
	/**
	 * Optional data that may be returned in the middle of the login flow, when neither the in-game overlay or a platform browser is used.
	 * This data is present when the ResultCode is EOS_Auth_PinGrantCode.
	 */
	const EOS_Auth_PinGrantInfo* PinGrantInfo;
	/** If the user was not found with external auth credentials passed into EOS_Auth_Login, this continuance token can be passed to EOS_Auth_LinkAccount to continue the flow. */
	EOS_ContinuanceToken ContinuanceToken;
	/** Deprecated field that is no longer used. */
	const EOS_Auth_AccountFeatureRestrictedInfo* AccountFeatureRestrictedInfo_DEPRECATED;
	/**
	 * The Epic Account ID that has been previously selected to be used for the current application.
	 * Applications should use this ID to authenticate with online backend services that store game-scoped data for users.
	 *
	 * Note: This ID may be different from LocalUserId if the user has previously merged Epic accounts into the account
	 * represented by LocalUserId, and one of the accounts that got merged had game data associated with it for the application.
	 */
	EOS_EpicAccountId SelectedAccountId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_Login
 * @param Data A EOS_Auth_LoginCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnLoginCallback, const EOS_Auth_LoginCallbackInfo* Data);

/** The most recent version of the EOS_Auth_Logout API. */
#define EOS_AUTH_LOGOUT_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_Logout function.
 */
EOS_STRUCT(EOS_Auth_LogoutOptions, (
	/** API Version: Set this to EOS_AUTH_LOGOUT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who is being logged out */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_Auth_Logout Function.
 */
EOS_STRUCT(EOS_Auth_LogoutCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_Login */
	void* ClientData;
	/** The Epic Account ID of the local user requesting the information */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_Logout
 * @param Data A EOS_Auth_LogoutCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnLogoutCallback, const EOS_Auth_LogoutCallbackInfo* Data);

/**
 * Flags used to describe how the account linking operation is to be performed.
 *
 * @see EOS_Auth_LinkAccount
 */
EOS_ENUM(EOS_ELinkAccountFlags,
	/**
	 * Default flag used for a standard account linking operation.
	 *
	 * This flag is set when using a continuance token received from a previous call to the EOS_Auth_Login API,
	 * when the local user has not yet been successfully logged in to an Epic Account yet.
	 */
	EOS_LA_NoFlags = 0x0,
	/**
	 * Specified when the EOS_ContinuanceToken describes a Nintendo NSA ID account type.
	 *
	 * This flag is used only with, and must be set, when the continuance token was received from a previous call
	 * to the EOS_Auth_Login API using the EOS_EExternalCredentialType::EOS_ECT_NINTENDO_NSA_ID_TOKEN login type.
	 */
	EOS_LA_NintendoNsaId = 0x1
);

/** The most recent version of the EOS_Auth_LinkAccount API. */
#define EOS_AUTH_LINKACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_LinkAccount function.
 */
EOS_STRUCT(EOS_Auth_LinkAccountOptions, (
	/** API Version: Set this to EOS_AUTH_LINKACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Combination of the enumeration flags to specify how the account linking operation will be performed.
	 */
	EOS_ELinkAccountFlags LinkAccountFlags;
	/**
	 * Continuance token received from a previous call to the EOS_Auth_Login API.
	 *
	 * A continuance token is received in the case when the external account used for login was not found to be linked
	 * against any existing Epic Account. In such case, the application needs to proceed with an account linking operation in which case
	 * the user is first asked to create a new account or login into their existing Epic Account, and then link their external account to it.
	 * Alternatively, the application may suggest the user to login using another external account that they have already linked to their existing Epic Account.
	 * In this flow, the external account is typically the currently logged in local platform user account.
	 * It can also be another external user account that the user is offered to login with.
	 */
	EOS_ContinuanceToken ContinuanceToken;
	/**
	 * The Epic Account ID of the logged in local user whose Epic Account will be linked with the local Nintendo NSA ID Account. By default set to NULL.
	 *
	 * This parameter is only used and required to be set when EOS_ELinkAccountFlags::EOS_LA_NintendoNsaId is specified.
	 * Otherwise, set to NULL, as the standard account linking and login flow using continuance token will handle logging in the user to their Epic Account.
	 */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_Auth_LinkAccount Function.
 */
EOS_STRUCT(EOS_Auth_LinkAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_LinkAccount. */
	void* ClientData;
	/** The Epic Account ID of the local user whose account has been linked during login. */
	EOS_EpicAccountId LocalUserId;
	/**
	 * Optional data that may be returned in the middle of the login flow, when neither the in-game overlay or a platform browser is used.
	 * This data is present when the ResultCode is EOS_Auth_PinGrantCode.
	 */
	const EOS_Auth_PinGrantInfo* PinGrantInfo;
	/**
	 * The Epic Account ID that has been previously selected to be used for the current application.
	 * Applications should use this ID to authenticate with online backend services that store game-scoped data for users.
	 *
	 * Note: This ID may be different from LocalUserId if the user has previously merged Epic accounts into the account
	 * represented by LocalUserId, and one of the accounts that got merged had game data associated with it for the application.
	 */
	EOS_EpicAccountId SelectedAccountId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_LinkAccount
 * @param Data A EOS_Auth_LinkAccountCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnLinkAccountCallback, const EOS_Auth_LinkAccountCallbackInfo* Data);

/** The most recent version of the EOS_Auth_VerifyUserAuth API. */
#define EOS_AUTH_VERIFYUSERAUTH_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_VerifyUserAuth function.
 * This operation is destructive, the pointer will remain the same but the data pointers inside will update
 */
EOS_STRUCT(EOS_Auth_VerifyUserAuthOptions, (
	/** API Version: Set this to EOS_AUTH_VERIFYUSERAUTH_API_LATEST. */
	int32_t ApiVersion;
	/** Auth token to verify against the backend service */
	const EOS_Auth_Token* AuthToken;
));

/**
 * Output parameters for the EOS_Auth_VerifyUserAuth Function.
 */
EOS_STRUCT(EOS_Auth_VerifyUserAuthCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_Login */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_VerifyUserAuth
 * @param Data A EOS_Auth_VerifyUserAuthCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnVerifyUserAuthCallback, const EOS_Auth_VerifyUserAuthCallbackInfo* Data);

/** The most recent version of the EOS_Auth_CopyUserAuthToken API. */
#define EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_CopyUserAuthToken function.
 */
EOS_STRUCT(EOS_Auth_CopyUserAuthTokenOptions, (
	/** API Version: Set this to EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Auth_CopyIdToken API. */
#define EOS_AUTH_COPYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_CopyIdToken function.
 */
EOS_STRUCT(EOS_Auth_CopyIdTokenOptions, (
	/** API Version: Set this to EOS_AUTH_COPYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user being queried. */
	EOS_EpicAccountId AccountId;
));

/** The most recent version of the EOS_Auth_IdToken struct. */
#define EOS_AUTH_IDTOKEN_API_LATEST 1

/**
 * A structure that contains an ID token.
 * These structures are created by EOS_Auth_CopyIdToken and must be passed to EOS_Auth_IdToken_Release when finished.
 */
EOS_STRUCT(EOS_Auth_IdToken, (
	/** API Version: Set this to EOS_AUTH_IDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The Epic Account ID described by the ID token.
	 * Use EOS_EpicAccountId_FromString to populate this field when validating a received ID token.
	 */
	EOS_EpicAccountId AccountId;
	/** The ID token as a Json Web Token (JWT) string. */
	const char* JsonWebToken;
));

/**
 * Release the memory associated with an EOS_Auth_IdToken structure. This must be called on data retrieved from EOS_Auth_CopyIdToken.
 *
 * @param IdToken The ID token structure to be released.
 *
 * @see EOS_Auth_IdToken
 * @see EOS_Auth_CopyIdToken
 */
EOS_DECLARE_FUNC(void) EOS_Auth_IdToken_Release(EOS_Auth_IdToken* IdToken);

/** The most recent version of the EOS_Auth_QueryIdToken API. */
#define EOS_AUTH_QUERYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_QueryIdToken function.
 */
EOS_STRUCT(EOS_Auth_QueryIdTokenOptions, (
	/** API Version: Set this to EOS_AUTH_QUERYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local authenticated user. */
	EOS_EpicAccountId LocalUserId;
	/**
	 * The target Epic Account ID for which to query an ID token.
	 * This account id may be the same as the input LocalUserId or another merged account id associated with the local user's Epic account.
	 *
	 * An ID token for the selected account id of a locally authenticated user will always be readily available.
	 * To retrieve it for the selected account ID, you can use EOS_Auth_CopyIdToken directly after a successful user login.
	 */
	EOS_EpicAccountId TargetAccountId;
));

/**
 * Output parameters for the EOS_Auth_QueryIdToken Function.
 */
EOS_STRUCT(EOS_Auth_QueryIdTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_QueryIdToken */
	void* ClientData;
	/** The Epic Account ID of the local authenticated user. */
	EOS_EpicAccountId LocalUserId;
	/** The target Epic Account ID for which the ID token was retrieved. */
	EOS_EpicAccountId TargetAccountId;
));

EOS_DECLARE_CALLBACK(EOS_Auth_OnQueryIdTokenCallback, const EOS_Auth_QueryIdTokenCallbackInfo* Data);

/** The most recent version of the EOS_Auth_VerifyIdToken API. */
#define EOS_AUTH_VERIFYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_VerifyIdToken function.
 */
EOS_STRUCT(EOS_Auth_VerifyIdTokenOptions, (
	/** API Version: Set this to EOS_AUTH_VERIFYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The ID token to verify.
	 * Use EOS_EpicAccountId_FromString to populate the AccountId field of this struct.
	 */
	const EOS_Auth_IdToken* IdToken;
));

/**
 * Output parameters for the EOS_Auth_VerifyIdToken Function.
 */
EOS_STRUCT(EOS_Auth_VerifyIdTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_VerifyIdToken */
	void* ClientData;
	/**
	 * Epic Account Services Application ID.
	 */
	const char* ApplicationId;
	/**
	 * Client ID of the authorized client.
	 */
	const char* ClientId;
	/**
	 * Product ID.
	 */
	const char* ProductId;
	/**
	 * Sandbox ID.
	 */
	const char* SandboxId;
	/**
	 * Deployment ID.
	 */
	const char* DeploymentId;
	/**
	 * Epic Account display name.
	 *
	 * This value may be set to an empty string.
	 */
	const char* DisplayName;
	/**
	 * Flag set to indicate whether external account information is present.
	 * Applications must always first check this value to be set before attempting
	 * to read the ExternalAccountIdType, ExternalAccountId, ExternalAccountDisplayName and Platform fields.
	 *
	 * This flag is set when the user has logged in to their Epic Account using external account credentials, e.g. through local platform authentication.
	 */
	EOS_Bool bIsExternalAccountInfoPresent;
	/**
	 * The identity provider that the user logged in with to their Epic Account.
	 *
	 * If bIsExternalAccountInfoPresent is set, this field describes the external account type.
	 */
	EOS_EExternalAccountType ExternalAccountIdType;
	/**
	 * The external account ID of the logged in user.
	 *
	 * This value may be set to an empty string.
	 */
	const char* ExternalAccountId;
	/**
	 * The external account display name.
	 *
	 * This value may be set to an empty string.
	 */
	const char* ExternalAccountDisplayName;
	/**
	 * Platform that the user is connected from.
	 *
	 * This value may be set to an empty string.
	 */
	const char* Platform;
));

/**
 * Function prototype definition for callbacks passed into EOS_Auth_VerifyIdToken.
 *
 * @param Data A EOS_Auth_VerifyIdTokenCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnVerifyIdTokenCallback, const EOS_Auth_VerifyIdTokenCallbackInfo* Data);

/** The most recent version of the EOS_Auth_AddNotifyLoginStatusChanged API. */
#define EOS_AUTH_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST 1

/**
 * Input parameters for the EOS_Auth_AddNotifyLoginStatusChanged Function.
 */
EOS_STRUCT(EOS_Auth_AddNotifyLoginStatusChangedOptions, (
	/** API Version: Set this to EOS_AUTH_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Auth_DeletePersistentAuth API. */
#define EOS_AUTH_DELETEPERSISTENTAUTH_API_LATEST 2

/**
 * Input parameters for the EOS_Auth_DeletePersistentAuth function.
 */
EOS_STRUCT(EOS_Auth_DeletePersistentAuthOptions, (
	/** API Version: Set this to EOS_AUTH_DELETEPERSISTENTAUTH_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * A long-lived refresh token that is used with the EOS_LCT_PersistentAuth login type and is to be revoked from the authentication server. Only used on Console platforms.
	 * On Desktop and Mobile platforms, set this parameter to NULL.
	 */
	const char* RefreshToken;
));

/**
 * Output parameters for the EOS_Auth_DeletePersistentAuth Function.
 */
EOS_STRUCT(EOS_Auth_DeletePersistentAuthCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Auth_DeletePersistentAuth */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Auth_DeletePersistentAuth
 * @param Data A EOS_Auth_DeletePersistentAuthCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnDeletePersistentAuthCallback, const EOS_Auth_DeletePersistentAuthCallbackInfo* Data);

/**
 * Output parameters for the EOS_Auth_OnLoginStatusChangedCallback Function.
 */
EOS_STRUCT(EOS_Auth_LoginStatusChangedCallbackInfo, (
	/** Context that was passed into EOS_Auth_AddNotifyLoginStatusChanged */
	void* ClientData;
	/** The Epic Account ID of the local user whose status has changed */
	EOS_EpicAccountId LocalUserId;
	/** The status prior to the change */
	EOS_ELoginStatus PrevStatus;
	/** The status at the time of the notification */
	EOS_ELoginStatus CurrentStatus;
));

/**
 * Function prototype definition for notifications that come from EOS_Auth_AddNotifyLoginStatusChanged
 *
 * @param Data A EOS_Auth_LoginStatusChangedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Auth_OnLoginStatusChangedCallback, const EOS_Auth_LoginStatusChangedCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_auth_types_deprecated.inl`:

```inl
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** The most recent version of the EOS_Auth_AccountFeatureRestrictedInfo struct. */
#define EOS_AUTH_ACCOUNTFEATURERESTRICTEDINFO_API_LATEST 1

/**
 * Intermediate data needed to complete account restriction verification during login flow, returned by EOS_Auth_LoginCallbackInfo when the ResultCode is EOS_Auth_AccountFeatureRestricted.
 * The URI inside should be exposed to the user for entry in a web browser. The URI must be copied out of this struct before completion of the callback.
 */
EOS_STRUCT(EOS_Auth_AccountFeatureRestrictedInfo, (
	/** API Version: Set this to EOS_AUTH_ACCOUNTFEATURERESTRICTEDINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The end-user verification URI. Users must be asked to open the page in a browser to address the restrictions. */
	const char* VerificationURI;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_base.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once


#if !defined(EOS_MEMORY_CALL) || !defined(EOS_CALL) || !defined(EOS_USE_DLLEXPORT)
#if !defined(_WIN32) && !defined(_WIN64) && !defined(__ANDROID__) && !defined(__linux__) && !defined(__APPLE__)
#error \
This platform expected a `eos_<platform>_base.h` include before this header. \
Please refer to https://dev.epicgames.com/docs/services or `eos_platform_prereqs.h` for details.
#endif
#endif

#ifndef EOS_USE_DLLEXPORT
#if defined(_WIN32) || defined(__CYGWIN__)
#define EOS_USE_DLLEXPORT 1
#else
#define EOS_USE_DLLEXPORT 0
#endif
#endif

#ifndef EOS_CALL
#if defined(_WIN32) && (defined(__i386) || defined(_M_IX86))
#define EOS_CALL __stdcall
#define EOS_MEMORY_CALL __stdcall
#else
#define EOS_CALL
#define EOS_MEMORY_CALL
#endif
#endif

#if !defined(EOS_MEMORY_CALL) || !defined(EOS_CALL) || !defined(EOS_USE_DLLEXPORT)
#error \
The expected macros EOS_MEMORY_CALL, EOS_CALL, and EOS_USE_DLLEXPORT where not all defined. \
Please refer to https://dev.epicgames.com/docs/services or `eos_platform_prereqs.h` for details.
#endif


#if defined(__cplusplus)
	#if defined(_MSC_VER) && _MSC_VER >= 1800
		/* Visual Studio 2013 or later */
		#include <cstdint>
	#else
		#include <stdint.h>
		#include <stddef.h>
	#endif

	#if __cplusplus >= 201103L
		#define EOS_HAS_ENUM_CLASS
	#elif defined(_MSC_VER) && defined(_MSVC_LANG) && _MSVC_LANG >= 201103L
		#define EOS_HAS_ENUM_CLASS
	#endif
#else
	/* C Compiler */
	#include <stdint.h>
	#include <stddef.h>
#endif


typedef int32_t EOS_Bool;
#define EOS_TRUE 1
#define EOS_FALSE 0


#if defined(EOS_BUILDING_SDK) && EOS_BUILDING_SDK > 0
	#if EOS_USE_DLLEXPORT
		#ifdef __GNUC__
			#define EOS_API __attribute__ ((dllexport))
		#else
			#define EOS_API __declspec(dllexport)
		#endif
	#else
		#if __GNUC__ >= 4
			#define EOS_API __attribute__ ((visibility ("default")))
		#else
			#define EOS_API
		#endif
	#endif

#else

	#if EOS_USE_DLLEXPORT
		#if defined(EOS_MONOLITHIC) && EOS_MONOLITHIC > 0
			#define EOS_API
		#elif defined(EOS_BUILD_DLL) && EOS_BUILD_DLL > 0
			#ifdef __GNUC__
				#define EOS_API __attribute__ ((dllexport))
			#else
				#define EOS_API __declspec(dllexport)
			#endif
		#else
			#ifdef __GNUC__
				#define EOS_API __attribute__ ((dllimport))
			#else
				#define EOS_API __declspec(dllimport)
			#endif
		#endif
	#else
		#if __GNUC__ >= 4
			#define EOS_API __attribute__ ((visibility ("default")))
		#else
			#define EOS_API
		#endif
	#endif
#endif

#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif

#define EOS_DECLARE_FUNC(return_type) EXTERN_C EOS_API return_type EOS_CALL
#define EOS_DECLARE_CALLBACK(CallbackName, ...) EXTERN_C typedef void (EOS_CALL * CallbackName)(__VA_ARGS__)
#define EOS_DECLARE_CALLBACK_RETVALUE(ReturnType, CallbackName, ...) EXTERN_C typedef ReturnType (EOS_CALL * CallbackName)(__VA_ARGS__)
#define EOS_PASTE(...) __VA_ARGS__
#define EOS_STRUCT(struct_name, struct_def)           \
	EXTERN_C typedef struct _tag ## struct_name {     \
		EOS_PASTE struct_def                          \
	} struct_name


#ifdef EOS_HAS_ENUM_CLASS
#define EOS_ENUM_START(name) enum class name : int32_t {
#define EOS_ENUM_END(name) }
#else
#define EOS_ENUM_START(name) typedef enum name {
#define EOS_ENUM_END(name) , __##name##_PAD_INT32__ = 0x7FFFFFFF } name
#endif
#define EOS_ENUM(name, ...) EOS_ENUM_START(name) __VA_ARGS__ EOS_ENUM_END(name)


#ifdef EOS_HAS_ENUM_CLASS
#define EOS_ENUM_BOOLEAN_OPERATORS(name) \
/** A set of bitwise operators provided when the enum is provided as an `enum class`. */ \
inline constexpr name operator|(name Left, name Right) { return static_cast<name>((__underlying_type(name))Left | (__underlying_type(name))Right); } \
inline constexpr name operator&(name Left, name Right) { return static_cast<name>((__underlying_type(name))Left & (__underlying_type(name))Right); } \
inline constexpr name operator^(name Left, name Right) { return static_cast<name>((__underlying_type(name))Left ^ (__underlying_type(name))Right); } \
inline constexpr name operator~(name Left) { return static_cast<name>(~(__underlying_type(name))Left); } \
inline name& operator|=(name& Left, name Right) { return Left = Left | Right; } \
inline name& operator&=(name& Left, name Right) { return Left = Left & Right; } \
inline name& operator^=(name& Left, name Right) { return Left = Left ^ Right; } \
/**/
#else
#define EOS_ENUM_BOOLEAN_OPERATORS(name)
#endif


#undef EOS_HAS_ENUM_CLASS

```

`EAC_SDK/SDK/include/eos_common.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_base.h"

#pragma pack(push, 8)

#undef EOS_RESULT_VALUE
#undef EOS_RESULT_VALUE_LAST
#define EOS_RESULT_VALUE(Name, Value) Name = Value,
#define EOS_RESULT_VALUE_LAST(Name, Value) Name = Value

EOS_ENUM_START(EOS_EResult)
#include "eos_result.h"
EOS_ENUM_END(EOS_EResult);

#undef EOS_RESULT_VALUE
#undef EOS_RESULT_VALUE_LAST

/**
 * Returns a string representation of an EOS_EResult.
 * The return value is never null.
 * The return value must not be freed.
 *
 * Example: EOS_EResult_ToString(EOS_Success) returns "EOS_Success"
 */
EOS_DECLARE_FUNC(const char*) EOS_EResult_ToString(EOS_EResult Result);

/**
 * Returns whether a result is to be considered the final result, or false if the callback that returned this result
 * will be called again either after some time or from another action.
 *
 * @param Result The result to check against being a final result for an operation
 * @return True if this result means the operation is complete, false otherwise
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_EResult_IsOperationComplete(EOS_EResult Result);

/**
 * Encode a byte array into hex encoded string
 *
 * @return An EOS_EResult that indicates whether the byte array was converted and copied into the OutBuffer.
 *         EOS_Success if the encoding was successful and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer on invalid length for any of the parameters
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the encoding. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ByteArray_ToString(const uint8_t* ByteArray, const uint32_t Length, char* OutBuffer, uint32_t* InOutBufferLength);

/**
 * A handle to a user's Epic Account ID
 * This ID is associated with a specific login associated with Epic Account Services
 *
 * @see EOS_Auth_Login
 */
typedef struct EOS_EpicAccountIdDetails* EOS_EpicAccountId;

/**
 * Check whether or not the given Epic Account ID is considered valid
 * NOTE: This will return true for any EOS_EpicAccountId created with EOS_EpicAccountId_FromString as there is no validation
 *
 * @param AccountId The Epic Account ID to check for validity
 * @return EOS_TRUE if the EOS_EpicAccountId is valid, otherwise EOS_FALSE
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_EpicAccountId_IsValid(EOS_EpicAccountId AccountId);

/**
 * Retrieve a null-terminated stringified Epic Account ID from an EOS_EpicAccountId. This is useful for replication of Epic Account IDs in multiplayer games.
 * This string will be no larger than EOS_EPICACCOUNTID_MAX_LENGTH + 1 and will only contain UTF8-encoded printable characters as well as a null-terminator.
 *
 * @param AccountId The Epic Account ID for which to retrieve the stringified version.
 * @param OutBuffer The buffer into which the character data should be written
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null-termination character.
 *
 * @return An EOS_EResult that indicates whether the Epic Account ID string was copied into the OutBuffer.
 *         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null-terminator.
 *         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.
 *         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the Epic Account ID string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_EpicAccountId_ToString(EOS_EpicAccountId AccountId, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Retrieve an EOS_EpicAccountId from a raw string representing an Epic Account ID. The input string must be null-terminated.
 * NOTE: There is no validation on the string format, this should only be used with values serialized from legitimate sources such as EOS_EpicAccountId_ToString
 *
 * @param AccountIdString The stringified account ID for which to retrieve the Epic Account ID
 * @return The EOS_EpicAccountId that corresponds to the AccountIdString
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_EpicAccountId_FromString(const char* AccountIdString);

/**
 * A character buffer of this size is large enough to fit a successful output of EOS_EpicAccountId_ToString. This length does not include the null-terminator.
 * The EpicAccountId data structure is opaque in nature and no assumptions of its structure should be inferred
 */
#define EOS_EPICACCOUNTID_MAX_LENGTH 32

/**
 * A handle to a user's Product User ID (game services related ecosystem)
 * This ID is associated with any of the external account providers (of which Epic Account Services is one)
 *
 * @see EOS_Connect_Login
 * @see EOS_EExternalCredentialType
 */
typedef struct EOS_ProductUserIdDetails* EOS_ProductUserId;

/**
 * Check whether or not the given account unique ID is considered valid
 * NOTE: This will return true for any EOS_ProductUserId created with EOS_ProductUserId_FromString as there is no validation
 *
 * @param AccountId The Product User ID to check for validity
 * @return EOS_TRUE if the EOS_ProductUserId is valid, otherwise EOS_FALSE
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_ProductUserId_IsValid(EOS_ProductUserId AccountId);

/**
 * Retrieve a null-terminated stringified Product User ID from an EOS_ProductUserId. This is useful for replication of Product User IDs in multiplayer games.
 * This string will be no larger than EOS_PRODUCTUSERID_MAX_LENGTH + 1 and will only contain UTF8-encoded printable characters as well as the null-terminator.
 *
 * @param AccountId The Product User ID for which to retrieve the stringified version.
 * @param OutBuffer The buffer into which the character data should be written
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null-termination character.
 *
 * @return An EOS_EResult that indicates whether the Product User ID string was copied into the OutBuffer.
 *         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null-terminator.
 *         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.
 *         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the Product User ID string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ProductUserId_ToString(EOS_ProductUserId AccountId, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Retrieve an EOS_ProductUserId from a raw string representing an Epic Online Services Product User ID. The input string must be null-terminated.
 * NOTE: There is no validation on the string format, this should only be used with values serialized from legitimate sources such as EOS_ProductUserId_ToString
 *
 * @param ProductUserIdString The stringified product user ID for which to retrieve the Epic Online Services Product User ID
 * @return The EOS_ProductUserId that corresponds to the ProductUserIdString
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_ProductUserId_FromString(const char* ProductUserIdString);

/** A character buffer of this size is large enough to fit a successful output of EOS_ProductUserId_ToString. This length does not include the null-terminator. */
#define EOS_PRODUCTUSERID_MAX_LENGTH 32

/** Handle to an existing registered notification (0 is an invalid handle) */
EXTERN_C typedef uint64_t EOS_NotificationId;

/** An invalid notification ID */
#define EOS_INVALID_NOTIFICATIONID ((EOS_NotificationId)0)

/** A handle to a continuance token @see eos_connect.h */
typedef struct EOS_ContinuanceTokenDetails* EOS_ContinuanceToken;

/**
 * Retrieve a null-terminated stringified continuance token from an EOS_ContinuanceToken.
 *
 * To get the required buffer size, call once with OutBuffer set to NULL, InOutBufferLength will contain the buffer size needed.
 * Call again with valid params to get the stringified continuance token which will only contain UTF8-encoded printable characters as well as the null-terminator.
 *
 * @param ContinuanceToken The continuance token for which to retrieve the stringified version.
 * @param OutBuffer The buffer into which the character data should be written
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer including the null-termination character.
 *
 * @return An EOS_EResult that indicates whether the continuance token string was copied into the OutBuffer.
 *         EOS_Success - The OutBuffer was filled, and InOutBufferLength contains the number of characters copied into OutBuffer including the null-terminator.
 *         EOS_InvalidParameters - Either OutBuffer or InOutBufferLength were passed as NULL parameters.
 *         EOS_InvalidUser - The AccountId is invalid and cannot be stringified.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the continuance token string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ContinuanceToken_ToString(EOS_ContinuanceToken ContinuanceToken, char* OutBuffer, int32_t* InOutBufferLength);

/** The most recent version of the EOS_PageQuery structs. */
#define EOS_PAGEQUERY_API_LATEST 1

/** DEPRECATED! Use EOS_PAGEQUERY_API_LATEST instead. */
#define EOS_PAGINATION_API_LATEST EOS_PAGEQUERY_API_LATEST

/** The default MaxCount used for a EOS_PageQuery when the API allows the EOS_PageQuery to be omitted. */
#define EOS_PAGEQUERY_MAXCOUNT_DEFAULT 10

/** The maximum MaxCount used for a EOS_PageQuery. */
#define EOS_PAGEQUERY_MAXCOUNT_MAXIMUM 100

/**
 * A page query is part of query options. It is used to allow pagination of query results.
 */
EOS_STRUCT(EOS_PageQuery, (
	/** API Version: Set this to EOS_PAGEQUERY_API_LATEST. */
	int32_t ApiVersion;
	/** The index into the ordered query results to start the page at. */
	int32_t StartIndex;
	/** The maximum number of results to have in the page. */
	int32_t MaxCount;
));

/**
 * A page result is part of query callback info. It is used to provide pagination details of query results.
 */
EOS_STRUCT(EOS_PageResult, (
	/** The index into the ordered query results to start the page at. */
	int32_t StartIndex;
	/** The number of results in the current page. */
	int32_t Count;
	/** The number of results associated with they original query options. */
	int32_t TotalCount;
));

/**
 * All possible states of a local user
 *
 * @see EOS_Auth_AddNotifyLoginStatusChanged
 * @see EOS_Auth_GetLoginStatus
 * @see EOS_Auth_Login
 * @see EOS_Connect_AddNotifyLoginStatusChanged
 * @see EOS_Connect_GetLoginStatus
 * @see EOS_Connect_Login
 */
EOS_ENUM(EOS_ELoginStatus,
	/** Player has not logged in or chosen a local profile */
	EOS_LS_NotLoggedIn = 0,
	/** Player is using a local profile but is not logged in */
	EOS_LS_UsingLocalProfile = 1,
	/** Player has been validated by the platform specific authentication service */
	EOS_LS_LoggedIn = 2
);

/**
 * Supported types of data that can be stored with inside an attribute (used by sessions/lobbies/etc)
 *
 * @see EOS_LobbySearch_SetParameter
 * @see EOS_SessionSearch_SetParameter
 */
EOS_ENUM(EOS_EAttributeType,
	/** Boolean value (true/false) */
	EOS_AT_BOOLEAN = 0,
	/** 64 bit integers */
	EOS_AT_INT64 = 1,
	/** Double/floating point precision */
	EOS_AT_DOUBLE = 2,
	/** UTF8 Strings */
	EOS_AT_STRING = 3
);

typedef EOS_EAttributeType EOS_ESessionAttributeType;
typedef EOS_EAttributeType EOS_ELobbyAttributeType;

/**
 * All comparison operators associated with parameters in a search query
 *
 * @see EOS_LobbySearch_SetParameter
 * @see EOS_SessionSearch_SetParameter
 */
EOS_ENUM(EOS_EComparisonOp,
	/** Value must equal the one stored on the lobby/session */
	EOS_CO_EQUAL = 0,
	/** Value must not equal the one stored on the lobby/session */
	EOS_CO_NOTEQUAL = 1,
	/** Value must be strictly greater than the one stored on the lobby/session */
	EOS_CO_GREATERTHAN = 2,
	/** Value must be greater than or equal to the one stored on the lobby/session */
	EOS_CO_GREATERTHANOREQUAL = 3,
	/** Value must be strictly less than the one stored on the lobby/session */
	EOS_CO_LESSTHAN = 4,
	/** Value must be less than or equal to the one stored on the lobby/session */
	EOS_CO_LESSTHANOREQUAL = 5,
	/** Prefer values nearest the one specified ie. abs(SearchValue-SessionValue) closest to 0 */
	EOS_CO_DISTANCE = 6,
	/** Value stored on the lobby/session may be any from a specified list */
	EOS_CO_ANYOF = 7,
	/** Value stored on the lobby/session may NOT be any from a specified list */
	EOS_CO_NOTANYOF = 8,
	/** This one value is a part of a collection */
	EOS_CO_ONEOF = 9,
	/** This one value is NOT part of a collection */
	EOS_CO_NOTONEOF = 10,
	/** This value is a CASE SENSITIVE substring of an attribute stored on the lobby/session */
	EOS_CO_CONTAINS = 11
);

typedef EOS_EComparisonOp EOS_EOnlineComparisonOp;

/**
 * All supported external account providers
 *
 * @see EOS_Connect_QueryExternalAccountMappings
 */
EOS_ENUM(EOS_EExternalAccountType,
	/** External account is associated with Epic Games */
	EOS_EAT_EPIC = 0,
	/** External account is associated with Steam */
	EOS_EAT_STEAM = 1,
	/** External account is associated with PlayStation(TM)Network */
	EOS_EAT_PSN = 2,
	/** External account is associated with Xbox Live */
	EOS_EAT_XBL = 3,
	/** External account is associated with Discord */
	EOS_EAT_DISCORD = 4,
	/** External account is associated with GOG */
	EOS_EAT_GOG = 5,
	/**
	 * External account is associated with Nintendo
	 *
	 * With both EOS Connect and EOS UserInfo APIs, the associated account type is Nintendo Service Account ID.
	 * Local user authentication is possible using Nintendo Account ID, while the account type does not get exposed to the SDK in queries related to linked accounts information.
	 */
	EOS_EAT_NINTENDO = 6,
	/** External account is associated with Uplay */
	EOS_EAT_UPLAY = 7,
	/** External account is associated with an OpenID Provider */
	EOS_EAT_OPENID = 8,
	/** External account is associated with Apple */
	EOS_EAT_APPLE = 9,
	/** External account is associated with Google */
	EOS_EAT_GOOGLE = 10,
	/** External account is associated with Oculus */
	EOS_EAT_OCULUS = 11,
	/** External account is associated with itch.io */
	EOS_EAT_ITCHIO = 12,
	/** External account is associated with Amazon */
	EOS_EAT_AMAZON = 13,
	/** External account is associated with Viveport */
	EOS_EAT_VIVEPORT = 14
);

/**
 * List of the supported identity providers to authenticate a user.
 *
 * The type of authentication token is specific to each provider.
 * Tokens in string format should be passed as-is to the function.
 * Tokens retrieved as raw byte arrays should be converted into a hex-encoded UTF-8 string (e.g. "FA87097A..") before being passed to the function.
 * EOS_ByteArray_ToString can be used for this conversion.
 *
 * @see EOS_Auth_Login
 * @see EOS_Connect_Login
 */
EOS_ENUM(EOS_EExternalCredentialType,
	/**
	 * Epic Account Services Token
	 *
	 * Using ID Token is preferred, retrieved with EOS_Auth_CopyIdToken that returns EOS_Auth_IdToken::JsonWebToken.
	 * Using Auth Token is supported for backwards compatibility, retrieved with EOS_Auth_CopyUserAuthToken that returns EOS_Auth_Token::AccessToken.
	 *
	 * Supported with EOS_Connect_Login.
	 *
	 * @see EOS_Auth_CopyIdToken
	 * @see EOS_Auth_CopyUserAuthToken
	 */
	EOS_ECT_EPIC = 0,
	/**
	 * Steam Encrypted App Ticket
	 * Note that EOS_ECT_STEAM_APP_TICKET is deprecated for use with EOS_Auth_Login. Use EOS_ECT_STEAM_SESSION_TICKET instead.
	 *
	 * Generated using the ISteamUser::RequestEncryptedAppTicket API of Steamworks SDK.
	 * For ticket generation parameters, use pDataToInclude(NULL) and cbDataToInclude(0).
	 *
	 * The retrieved App Ticket byte buffer needs to be converted into a hex-encoded UTF-8 string (e.g. "FA87097A..") before passing it to the EOS_Connect_Login API.
	 * EOS_ByteArray_ToString can be used for this conversion.
	 *
	 * Supported with EOS_Connect_Login.
	 *
	 * @see EOS_ECT_STEAM_SESSION_TICKET
	 */
	EOS_ECT_STEAM_APP_TICKET = 1,
	/**
	 * PlayStation(TM)Network ID Token
	 *
	 * Retrieved from the PlayStation(R) SDK. Please see first-party documentation for additional information.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_PSN_ID_TOKEN = 2,
	/**
	 * Xbox Live XSTS Token
	 *
	 * Retrieved from the GDK and XDK. Please see first-party documentation for additional information.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_XBL_XSTS_TOKEN = 3,
	/**
	 * Discord Access Token
	 *
	 * Retrieved using the ApplicationManager::GetOAuth2Token API of Discord SDK.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_DISCORD_ACCESS_TOKEN = 4,
	/**
	 * GOG Galaxy Encrypted App Ticket
	 *
	 * Generated using the IUser::RequestEncryptedAppTicket API of GOG Galaxy SDK.
	 * For ticket generation parameters, use data(NULL) and dataSize(0).
	 *
	 * The retrieved App Ticket byte buffer needs to be converted into a hex-encoded UTF-8 string (e.g. "FA87097A..") before passing it to the EOS_Connect_Login API.
	 * For C/C++ API integration, use the EOS_ByteArray_ToString API for the conversion.
	 * For C# integration, you can use <see cref="Helper.ToHexString" /> for the conversion.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_GOG_SESSION_TICKET = 5,
	/**
	 * Nintendo Account ID Token
	 *
	 * Identifies a Nintendo user account and is acquired through web flow authentication where the local user logs in using their email address/sign-in ID and password.
	 * This is the common Nintendo account that users login with outside the Nintendo Switch device.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_NINTENDO_ID_TOKEN = 6,
	/**
	 * Nintendo Service Account ID Token (NSA ID)
	 *
	 * The NSA ID identifies uniquely the local Nintendo Switch device. The authentication token is acquired locally without explicit user credentials.
	 * As such, it is the primary authentication method for seamless login on Nintendo Switch.
	 *
	 * The NSA ID is not exposed directly to the user and does not provide any means for login outside the local device.
	 * Because of this, Nintendo Switch users will need to link their Nintendo Account or another external user account
	 * to their Product User ID in order to share their game progression across other platforms. Otherwise, the user will
	 * not be able to login to their existing Product User ID on another platform due to missing login credentials to use.
	 * It is recommended that the game explicitly communicates this restriction to the user so that they will know to add
	 * the first linked external account on the Nintendo Switch device and then proceed with login on another platform.
	 *
	 * In addition to sharing cross-platform game progression, linking the Nintendo Account or another external account
	 * will allow preserving the game progression permanently. Otherwise, the game progression will be tied only to the
	 * local device. In case the user loses access to their local device, they will not be able to recover the game
	 * progression if it is only associated with this account type.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 */
	EOS_ECT_NINTENDO_NSA_ID_TOKEN = 7,
	/**
	 * Uplay Access Token
	 */
	EOS_ECT_UPLAY_ACCESS_TOKEN = 8,
	/**
	 * OpenID Provider Access Token
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_OPENID_ACCESS_TOKEN = 9,
	/**
	 * Device ID access token that identifies the current locally logged in user profile on the local device.
	 * The local user profile here refers to the operating system user login, for example the user's Windows Account
	 * or on a mobile device the default active user profile.
	 *
	 * This credential type is used to automatically login the local user using the EOS Connect Device ID feature.
	 *
	 * The intended use of the Device ID feature is to allow automatically logging in the user on a mobile device
	 * and to allow playing the game without requiring the user to necessarily login using a real user account at all.
	 * This makes a seamless first-time experience possible and allows linking the local device with a real external
	 * user account at a later time, sharing the same EOS_ProductUserId that is being used with the Device ID feature.
	 *
	 * Supported with EOS_Connect_Login.
	 *
	 * @see EOS_Connect_CreateDeviceId
	 */
	EOS_ECT_DEVICEID_ACCESS_TOKEN = 10,
	/**
	 * Apple ID Token
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_APPLE_ID_TOKEN = 11,
	/**
	 * Google ID Token
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_GOOGLE_ID_TOKEN = 12,
	/**
	 * Oculus User ID and Nonce
	 *
	 * Call ovr_User_GetUserProof(), or Platform.User.GetUserProof() if you are using Unity, to retrieve the nonce.
	 * Then pass the local User ID and the Nonce as a "{UserID}|{Nonce}" formatted string for the EOS_Connect_Login Token parameter.
	 *
	 * Note that in order to successfully retrieve a valid non-zero id for the local user using ovr_User_GetUser(),
	 * your Oculus App needs to be configured in the Oculus Developer Dashboard to have the User ID feature enabled.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_OCULUS_USERID_NONCE = 13,
	/**
	 * itch.io JWT Access Token
	 *
	 * Use the itch.io app manifest to receive a JWT access token for the local user via the ITCHIO_API_KEY process environment variable.
	 * The itch.io access token is valid for 7 days after which the game needs to be restarted by the user as otherwise EOS Connect
	 * authentication session can no longer be refreshed.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_ITCHIO_JWT = 14,
	/**
	 * itch.io Key Access Token
	 *
	 * This access token type is retrieved through the OAuth 2.0 authentication flow for the itch.io application.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_ITCHIO_KEY = 15,
	/**
	 * Epic Games ID Token
	 *
	 * Acquired using EOS_Auth_CopyIdToken that returns EOS_Auth_IdToken::JsonWebToken.
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_EPIC_ID_TOKEN = 16,
	/**
	 * Amazon Access Token
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_AMAZON_ACCESS_TOKEN = 17,
	/**
	 * Steam Auth Session Ticket
	 *
	 * Generated using the ISteamUser::GetAuthTicketForWebApi API of Steamworks SDK.
	 *
	 * @attention
	 * The pchIdentity input parameter of GetAuthTicketForWebApi API must be set to a valid non-empty string value.
	 * The string value used by the game client must match identically to the backend-configured value in EOS Dev Portal.
	 * The recommended value to use is "epiconlineservices" in lowercase, matching the default value for new Steam identity provider credentials in EOS Dev Portal.
	 * This identifier is important for security reasons to prevent session hijacking. Applications must use a dedicated unique identity identifier for Session Tickets passed to the EOS SDK APIs.
	 * Session Tickets using the EOS-assigned identifier must not be used with anything else than the EOS SDK APIs. You must use a different identifier when generating Session Tickets to authenticate with other parties.
	 *
	 * @warning
	 * To update an already live game to use the new GetAuthTicketForWebApi API instead of the deprecated GetAuthSessionTicket API, follow these steps in this order to prevent breaking the live game for players:
	 * 1. Update your game client code to use the new ISteamUser::GetAuthTicketForWebApi API.
	 * 2. Publish the new game client update to end-users.
	 * 3. Update the existing Steam identity provider credentials entry in EOS Dev Portal to use the same identity string identifier as the game client.
	 *
	 * @example
	 * SteamUser()->GetAuthTicketForWebApi("epiconlineservices");
	 *
	 * The retrieved Auth Session Ticket byte buffer needs to be converted into a hex-encoded UTF-8 string (e.g. "FA87097A..") before passing it to the EOS_Auth_Login or EOS_Connect_Login APIs.
	 * EOS_ByteArray_ToString can be used for this conversion.
	 *
	 * Supported with EOS_Auth_Login, EOS_Connect_Login.
	 *
	 * @version 1.15.1+
	 */
	EOS_ECT_STEAM_SESSION_TICKET = 18,
	/**
	 * VIVEPORT User Session Token
	 *
	 * Supported with EOS_Connect_Login.
	 */
	EOS_ECT_VIVEPORT_USER_TOKEN = 19
);

/**
 * This type is used to distinguish between different supported integrated platforms.
 * Integrated platforms which are common across multiple host platforms will be defined here.
 */
EXTERN_C typedef const char* EOS_IntegratedPlatformType;
/** A macro to identify an unknown integrated platform. */
#define EOS_IPT_Unknown (const char*)NULL

/** This type is used to distinguish between different online platforms. */
EXTERN_C typedef uint32_t EOS_OnlinePlatformType;

#define EOS_OPT_Unknown 0
#define EOS_OPT_Epic 100
#define EOS_OPT_Steam 4000

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_connect.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_connect_types.h"

/**
 * The Connect Interface is used to manage local user permissions and access to backend services through the verification of various forms of credentials.
 * It creates an association between third party providers and an internal mapping that allows Epic Online Services to represent a user agnostically.
 * All Connect Interface calls take a handle of type EOS_HConnect as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetConnectInterface function.
 *
 * @see EOS_Platform_GetConnectInterface
 */

/**
 * Login/Authenticate given a valid set of external auth credentials.
 *
 * @param Options structure containing the external account credentials and type to use during the login operation.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the login operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_Login(EOS_HConnect Handle, const EOS_Connect_LoginOptions* Options, void* ClientData, const EOS_Connect_OnLoginCallback CompletionDelegate);

/**
 * Logout a currently logged in user.
 * NOTE: Access tokens for Product User IDs cannot be revoked. This operation really just cleans up state for the Product User ID and locally discards any associated access token.
 *
 * @param Options Structure containing the input parameters for the operation
 * @param ClientData Arbitrary data that is passed back to the caller in the CompletionDelegate.
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_Logout(EOS_HConnect Handle, const EOS_Connect_LogoutOptions* Options, void* ClientData, const EOS_Connect_OnLogoutCallback CompletionDelegate);

/**
 * Create an account association with the Epic Online Service as a product user given their external auth credentials.
 *
 * @param Options structure containing a continuance token from a "user not found" response during Login (always try login first).
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the create operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_CreateUser(EOS_HConnect Handle, const EOS_Connect_CreateUserOptions* Options, void* ClientData, const EOS_Connect_OnCreateUserCallback CompletionDelegate);

/**
 * Link a set of external auth credentials with an existing product user on the Epic Online Service.
 *
 * @param Options structure containing a continuance token from a "user not found" response during Login (always try login first) and a currently logged in user not already associated with this external auth provider.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the link operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_LinkAccount(EOS_HConnect Handle, const EOS_Connect_LinkAccountOptions* Options, void* ClientData, const EOS_Connect_OnLinkAccountCallback CompletionDelegate);

/**
 * Unlink external auth credentials from the owning keychain of a logged in product user.
 *
 * This function allows recovering the user from scenarios where they have accidentally proceeded to creating
 * a new product user for the local native user account, instead of linking it with an existing keychain that
 * they have previously created by playing the game (or another game owned by the organization) on another platform.
 *
 * In such scenario, after the initial platform login and a new product user creation, the user wishes to re-login
 * using other set of external auth credentials to connect with their existing game progression data. In order to
 * allow automatic login also on the current platform, they will need to unlink the accidentally created new keychain
 * and product user and then use the EOS_Connect_Login and EOS_Connect_LinkAccount APIs to link the local native platform
 * account with that previously created existing product user and its owning keychain.
 *
 * In another scenario, the user may simply want to disassociate the account that they have logged in with from the current
 * keychain that it is linked with, perhaps to link it against another keychain or to separate the game progressions again.
 *
 * In order to protect against account theft, it is only possible to unlink user accounts that have been authenticated
 * and logged in to the product user in the current session. This prevents a malicious actor from gaining access to one
 * of the linked accounts and using it to remove all other accounts linked with the keychain. This also prevents a malicious
 * actor from replacing the unlinked account with their own corresponding account on the same platform, as the unlinking
 * operation will ensure that any existing authentication session cannot be used to re-link and overwrite the entry without
 * authenticating with one of the other linked accounts in the keychain. These restrictions limit the potential attack surface
 * related to account theft scenarios.
 *
 * @param Options structure containing operation input parameters.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the unlink operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_UnlinkAccount(EOS_HConnect Handle, const EOS_Connect_UnlinkAccountOptions* Options, void* ClientData, const EOS_Connect_OnUnlinkAccountCallback CompletionDelegate);

/**
 * Create a new unique pseudo-account that can be used to identify the current user profile on the local device.
 *
 * This function is intended to be used by mobile games and PC games that wish to allow
 * a new user to start playing without requiring to login to the game using any user identity.
 * In addition to this, the Device ID feature is used to automatically login the local user
 * also when they have linked at least one external user account(s) with the local Device ID.
 *
 * It is possible to link many devices with the same user's account keyring using the Device ID feature.
 *
 * Linking a device later or immediately with a real user account will ensure that the player
 * will not lose their progress if they switch devices or lose the device at some point,
 * as they will be always able to login with one of their linked real accounts and also link
 * another new device with the user account associations keychain. Otherwise, without having
 * at least one permanent user account linked to the Device ID, the player would lose all of their
 * game data and progression permanently should something happen to their device or the local
 * user profile on the device.
 *
 * After a successful one-time CreateDeviceId operation, the game can login the local user
 * automatically on subsequent game starts with EOS_Connect_Login using the EOS_ECT_DEVICEID_ACCESS_TOKEN
 * credentials type. If a Device ID already exists for the local user on the device then EOS_DuplicateNotAllowed
 * error result is returned and the caller should proceed to calling EOS_Connect_Login directly.
 *
 * @param Options structure containing operation input parameters.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the create operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_CreateDeviceId(EOS_HConnect Handle, const EOS_Connect_CreateDeviceIdOptions* Options, void* ClientData, const EOS_Connect_OnCreateDeviceIdCallback CompletionDelegate);

/**
 * Delete any existing Device ID access credentials for the current user profile on the local device.
 *
 * The deletion is permanent and it is not possible to recover lost game data and progression
 * if the Device ID had not been linked with at least one real external user account.
 *
 * On Android and iOS devices, uninstalling the application will automatically delete any local
 * Device ID credentials created by the application.
 *
 * On Desktop platforms (Linux, macOS, Windows), Device ID credentials are not automatically deleted.
 * Applications may re-use existing Device ID credentials for the local OS user when the application is
 * re-installed, or call the DeleteDeviceId API on the first run to ensure a fresh start for the user.
 *
 * @param Options structure containing operation input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the delete operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Connect_DeleteDeviceId(EOS_HConnect Handle, const EOS_Connect_DeleteDeviceIdOptions* Options, void* ClientData, const EOS_Connect_OnDeleteDeviceIdCallback CompletionDelegate);

/**
 * Transfer a Device ID pseudo-account and the product user associated with it into another
 * keychain linked with real user accounts (such as Epic Games, PlayStation(TM)Network, Xbox Live, and other).
 *
 * This function allows transferring a product user, i.e. the local user's game progression
 * backend data from a Device ID owned keychain into a keychain with real user accounts
 * linked to it. The transfer of Device ID owned product user into a keychain of real user
 * accounts allows persisting the user's game data on the backend in the event that they
 * would lose access to the local device or otherwise switch to another device or platform.
 *
 * This function is only applicable in the situation of where the local user first plays
 * the game using the anonymous Device ID login, then later logs in using a real user
 * account that they have also already used to play the same game or another game under the
 * same organization within Epic Online Services. In such situation, while normally the login
 * attempt with a real user account would return EOS_InvalidUser and an EOS_ContinuanceToken
 * and allow calling the EOS_Connect_LinkAccount API to link it with the Device ID's keychain,
 * instead the login operation succeeds and finds an existing user because the association
 * already exists. Because the user cannot have two product users simultaneously to play with,
 * the game should prompt the user to choose which profile to keep and which one to discard
 * permanently. Based on the user choice, the game may then proceed to transfer the Device ID
 * login into the keychain that is persistent and backed by real user accounts, and if the user
 * chooses so, move the product user as well into the destination keychain and overwrite the
 * existing previous product user with it. To clarify, moving the product user with the Device ID
 * login in this way into a persisted keychain allows to preserve the so far only locally persisted
 * game progression and thus protect the user against a case where they lose access to the device.
 *
 * On success, the completion callback will return the preserved EOS_ProductUserId that remains
 * logged in while the discarded EOS_ProductUserId has been invalidated and deleted permanently.
 * Consecutive logins using the existing Device ID login type or the external account will
 * connect the user to the same backend data belonging to the preserved EOS_ProductUserId.
 *
 * Example walkthrough: Cross-platform mobile game using the anonymous Device ID login.
 *
 * For onboarding new users, the game will attempt to always automatically login the local user
 * by calling EOS_Connect_Login using the EOS_ECT_DEVICEID_ACCESS_TOKEN login type. If the local
 * Device ID credentials are not found, and the game wants a frictionless entry for the first time
 * user experience, the game will automatically call EOS_Connect_CreateDeviceId to create new
 * Device ID pseudo-account and then login the local user into it. Consecutive game starts will
 * thus automatically login the user to their locally persisted Device ID account.
 *
 * The user starts playing anonymously using the Device ID login type and makes significant game progress.
 * Later, they login using an external account that they have already used previously for the
 * same game perhaps on another platform, or another game owned by the same organization.
 * In such case, EOS_Connect_Login will automatically login the user to their existing account
 * linking keychain and create automatically a new empty product user for this product.
 *
 * In order for the user to use their existing previously created keychain and have the locally
 * created Device ID login reference to that keychain instead, the user's current product user
 * needs to be moved to be under that keychain so that their existing game progression will be
 * preserved. To do so, the game can call EOS_Connect_TransferDeviceIdAccount to transfer the
 * Device ID login and the product user associated with it into the other keychain that has real
 * external user account(s) linked to it. Note that it is important that the game either automatically
 * checks that the other product user does not have any meaningful progression data, or otherwise
 * will prompt the user to make the choice on which game progression to preserve and which can
 * be discarded permanently. The other product user will be discarded permanently and cannot be
 * recovered, so it is very important that the user is guided to make the right choice to avoid
 * accidental loss of all game progression.
 *
 * @see EOS_Connect_Login
 * @see EOS_Connect_CreateDeviceId
 *
 * @param Options structure containing the logged in product users and specifying which one will be preserved.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the transfer operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_TransferDeviceIdAccount(EOS_HConnect Handle, const EOS_Connect_TransferDeviceIdAccountOptions* Options, void* ClientData, const EOS_Connect_OnTransferDeviceIdAccountCallback CompletionDelegate);

/**
 * Retrieve the equivalent Product User IDs from a list of external account IDs from supported account providers.
 * The values will be cached and retrievable through EOS_Connect_GetExternalAccountMapping.
 *
 * @note A common use case is to query other users who are connected through the same account system as the local user.
 * Queries using external account IDs of another account system may not be available, depending on the account system specifics.
 *
 * @param Options structure containing a list of external account IDs, in string form, to query for the Product User ID representation.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the query operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_QueryExternalAccountMappings(EOS_HConnect Handle, const EOS_Connect_QueryExternalAccountMappingsOptions* Options, void* ClientData, const EOS_Connect_OnQueryExternalAccountMappingsCallback CompletionDelegate);

/**
 * Retrieve the equivalent external account mappings from a list of Product User IDs.
 *
 * The values will be cached and retrievable via EOS_Connect_GetProductUserIdMapping, EOS_Connect_CopyProductUserExternalAccountByIndex,
 * EOS_Connect_CopyProductUserExternalAccountByAccountType or EOS_Connect_CopyProductUserExternalAccountByAccountId.
 *
 * @see EOS_Connect_ExternalAccountInfo
 * @see EOS_Connect_GetProductUserExternalAccountCount
 * @see EOS_Connect_GetProductUserIdMapping
 * @see EOS_Connect_CopyProductUserExternalAccountByIndex
 * @see EOS_Connect_CopyProductUserExternalAccountByAccountType
 * @see EOS_Connect_CopyProductUserExternalAccountByAccountId
 * @see EOS_Connect_CopyProductUserInfo
 *
 * @param Options structure containing a list of Product User IDs to query for the external account representation.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the query operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_QueryProductUserIdMappings(EOS_HConnect Handle, const EOS_Connect_QueryProductUserIdMappingsOptions* Options, void* ClientData, const EOS_Connect_OnQueryProductUserIdMappingsCallback CompletionDelegate);

/**
 * Fetch a Product User ID that maps to an external account ID cached from a previous query.
 *
 * @param Options structure containing the local user and target external account ID.
 *
 * @return The Product User ID, previously retrieved from the backend service, for the given target external account.
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_Connect_GetExternalAccountMapping(EOS_HConnect Handle, const EOS_Connect_GetExternalAccountMappingsOptions* Options);

/**
 * Fetch an external account ID, in string form, that maps to a given Product User ID.
 *
 * @param Options structure containing the local user and target Product User ID.
 * @param OutBuffer The buffer into which the external account ID data should be written. The buffer must be long enough to hold a string of EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates the external account ID was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutUserInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the mapping doesn't exist or hasn't been queried yet.
 *         EOS_LimitExceeded if the OutBuffer is not large enough to receive the external account ID. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_GetProductUserIdMapping(EOS_HConnect Handle, const EOS_Connect_GetProductUserIdMappingOptions* Options, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Fetch the number of linked external accounts for a Product User ID.
 *
 * @param Options The Options associated with retrieving the external account info count.
 *
 * @see EOS_Connect_CopyProductUserExternalAccountByIndex
 *
 * @return Number of external accounts or 0 otherwise.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Connect_GetProductUserExternalAccountCount(EOS_HConnect Handle, const EOS_Connect_GetProductUserExternalAccountCountOptions* Options);

/**
 * Fetch information about an external account linked to a Product User ID.
 * On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.
 *
 * @param Options Structure containing the target index.
 * @param OutExternalAccountInfo The external account info data for the user with given index.
 *
 * @see EOS_Connect_ExternalAccountInfo_Release
 *
 * @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.
 *         EOS_Success if the information is available and passed out in OutExternalAccountInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the account data doesn't exist or hasn't been queried yet.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyProductUserExternalAccountByIndex(EOS_HConnect Handle, const EOS_Connect_CopyProductUserExternalAccountByIndexOptions* Options, EOS_Connect_ExternalAccountInfo ** OutExternalAccountInfo);

/**
 * Fetch information about an external account of a specific type linked to a Product User ID.
 * On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.
 *
 * @param Options Structure containing the target external account type.
 * @param OutExternalAccountInfo The external account info data for the user with given external account type.
 *
 * @see EOS_Connect_ExternalAccountInfo_Release
 *
 * @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.
 *         EOS_Success if the information is available and passed out in OutExternalAccountInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the account data doesn't exist or hasn't been queried yet.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyProductUserExternalAccountByAccountType(EOS_HConnect Handle, const EOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions* Options, EOS_Connect_ExternalAccountInfo ** OutExternalAccountInfo);

/**
 * Fetch information about an external account linked to a Product User ID.
 * On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.
 *
 * @param Options Structure containing the target external account ID.
 * @param OutExternalAccountInfo The external account info data for the user with given external account ID.
 *
 * @see EOS_Connect_ExternalAccountInfo_Release
 *
 * @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.
 *         EOS_Success if the information is available and passed out in OutExternalAccountInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the account data doesn't exist or hasn't been queried yet.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyProductUserExternalAccountByAccountId(EOS_HConnect Handle, const EOS_Connect_CopyProductUserExternalAccountByAccountIdOptions* Options, EOS_Connect_ExternalAccountInfo ** OutExternalAccountInfo);

/**
 * Fetch information about a Product User, using the external account that they most recently logged in with as the reference.
 * On a successful call, the caller must release the returned structure using the EOS_Connect_ExternalAccountInfo_Release API.
 *
 * @param Options Structure containing the target external account ID.
 * @param OutExternalAccountInfo The external account info data last logged in for the user.
 *
 * @see EOS_Connect_ExternalAccountInfo_Release
 *
 * @return An EOS_EResult that indicates the external account data was copied into the OutExternalAccountInfo.
 *         EOS_Success if the information is available and passed out in OutExternalAccountInfo.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the account data doesn't exist or hasn't been queried yet.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyProductUserInfo(EOS_HConnect Handle, const EOS_Connect_CopyProductUserInfoOptions* Options, EOS_Connect_ExternalAccountInfo ** OutExternalAccountInfo);

/**
 * Fetch the number of product users that are logged in.
 *
 * @return the number of product users logged in.
 */
EOS_DECLARE_FUNC(int32_t) EOS_Connect_GetLoggedInUsersCount(EOS_HConnect Handle);

/**
 * Fetch a Product User ID that is logged in. This Product User ID is in the Epic Online Services namespace.
 *
 * @param Index an index into the list of logged in users. If the index is out of bounds, the returned Product User ID will be invalid.
 *
 * @return the Product User ID associated with the index passed.
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_Connect_GetLoggedInUserByIndex(EOS_HConnect Handle, int32_t Index);

/**
 * Fetches the login status for an Product User ID.  This Product User ID is considered logged in as long as the underlying access token has not expired.
 *
 * @param LocalUserId the Product User ID of the user being queried.
 *
 * @return the enum value of a user's login status.
 */
EOS_DECLARE_FUNC(EOS_ELoginStatus) EOS_Connect_GetLoginStatus(EOS_HConnect Handle, EOS_ProductUserId LocalUserId);

/**
 * Register to receive upcoming authentication expiration notifications.
 * Notification is approximately 10 minutes prior to expiration.
 * Call EOS_Connect_Login again with valid third party credentials to refresh access.
 *
 * @note If the returned NotificationId is valid, you must call EOS_Connect_RemoveNotifyAuthExpiration when you no longer wish to have your NotificationHandler called.
 *
 * @param Options structure containing the API version of the callback to use.
 * @param ClientData arbitrary data that is passed back to you in the callback.
 * @param Notification a callback that is fired when the authentication is about to expire.
 *
 * @return handle representing the registered callback.
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Connect_AddNotifyAuthExpiration(EOS_HConnect Handle, const EOS_Connect_AddNotifyAuthExpirationOptions* Options, void* ClientData, const EOS_Connect_OnAuthExpirationCallback Notification);

/**
 * Unregister from receiving expiration notifications.
 *
 * @param InId handle representing the registered callback.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_RemoveNotifyAuthExpiration(EOS_HConnect Handle, EOS_NotificationId InId);

/**
 * Register to receive user login status updates.
 * @note If the returned NotificationId is valid, you must call EOS_Connect_RemoveNotifyLoginStatusChanged when you no longer wish to have your NotificationHandler called.
 *
 * @param Options structure containing the API version of the callback to use.
 * @param ClientData arbitrary data that is passed back to you in the callback.
 * @param Notification a callback that is fired when the login status for a user changes.
 *
 * @return handle representing the registered callback.
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Connect_AddNotifyLoginStatusChanged(EOS_HConnect Handle, const EOS_Connect_AddNotifyLoginStatusChangedOptions* Options, void* ClientData, const EOS_Connect_OnLoginStatusChangedCallback Notification);

/**
 * Unregister from receiving user login status updates.
 *
 * @param InId handle representing the registered callback.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_RemoveNotifyLoginStatusChanged(EOS_HConnect Handle, EOS_NotificationId InId);

/**
 * Fetches an ID token for a Product User ID.
 *
 * @param Options Structure containing information about the ID token to copy.
 * @param OutIdToken The ID token for the given user, if it exists and is valid; use EOS_Connect_IdToken_Release when finished.
 *
 * @see EOS_Connect_IdToken_Release
 *
 * @return EOS_Success if the information is available and passed out in OutIdToken.
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter.
 *         EOS_NotFound if the ID token is not found or expired.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Connect_CopyIdToken(EOS_HConnect Handle, const EOS_Connect_CopyIdTokenOptions* Options, EOS_Connect_IdToken ** OutIdToken);

/**
 * Verify a given ID token for authenticity and validity.
 *
 * @param Options structure containing information about the ID token to verify.
 * @param ClientData arbitrary data that is passed back to you in the callback.
 * @param CompletionDelegate a callback that is fired when the operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Connect_VerifyIdToken(EOS_HConnect Handle, const EOS_Connect_VerifyIdTokenOptions* Options, void* ClientData, const EOS_Connect_OnVerifyIdTokenCallback CompletionDelegate);

```

`EAC_SDK/SDK/include/eos_connect_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_ConnectHandle* EOS_HConnect;

/** Max length of an external account ID in string form */
#define EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH 256

/** The most recent version of the EOS_Connect_Credentials struct. */
#define EOS_CONNECT_CREDENTIALS_API_LATEST 1

/**
 * A structure that contains external login credentials.
 *
 * This is part of the input structure EOS_Connect_LoginOptions.
 *
 * @see EOS_EExternalCredentialType
 * @see EOS_Connect_Login
 */
EOS_STRUCT(EOS_Connect_Credentials, (
	/** API Version: Set this to EOS_CONNECT_CREDENTIALS_API_LATEST. */
	int32_t ApiVersion;
	/** External token associated with the user logging in. */
	const char* Token;
	/** Type of external login; identifies the auth method to use. */
	EOS_EExternalCredentialType Type;
));

/** Max length of a display name, not including the terminating null. */
#define EOS_CONNECT_USERLOGININFO_DISPLAYNAME_MAX_LENGTH 32

/** The most recent version of the EOS_Connect_UserLoginInfo struct. */
#define EOS_CONNECT_USERLOGININFO_API_LATEST 2

/**
 * Additional information about the local user.
 */
EOS_STRUCT(EOS_Connect_UserLoginInfo, (
	/** API Version: Set this to EOS_CONNECT_USERLOGININFO_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The user's display name on the identity provider systems as UTF-8 encoded null-terminated string.
	 * The length of the name can be at maximum up to EOS_CONNECT_USERLOGININFO_DISPLAYNAME_MAX_LENGTH bytes.
	 *
	 * As the display name passed here is client-controlled and not part of user authentication tokens,
	 * it is only treated as non-authoritative informational data to be used by some of the feature services.
	 * For example displaying player names in Leaderboards rankings.
	 */
	const char* DisplayName;
	/**
	 * Nintendo Service Account ID Token (NSA ID).
	 * 
	 * This field is required to be set and only used when running on the Nintendo Switch device,
	 * and the user is being authenticated using any other credential type than EOS_ECT_NINTENDO_NSA_ID_TOKEN.
	 *
	 * In order to use the Lobbies and Sessions interfaces, a valid NSA ID Token is required to be provided
	 * for the active local Nintendo Switch user. Otherwise, attempting to use either of the Lobbies or
	 * Sessions interfaces will return the EOS_Permission_OnlinePlayRestricted error result.
	 */
	const char* NsaIdToken;
));

/** The most recent version of the EOS_Connect_Login API. */
#define EOS_CONNECT_LOGIN_API_LATEST 2

/**
 * Input parameters for the EOS_Connect_Login function.
 */
EOS_STRUCT(EOS_Connect_LoginOptions, (
	/** API Version: Set this to EOS_CONNECT_LOGIN_API_LATEST. */
	int32_t ApiVersion;
	/** Credentials specified for a given login method */
	const EOS_Connect_Credentials* Credentials;
	/**
	 * Additional information about the local user.
	 *
	 * This field is required to be set and used when authenticating the user using Amazon, Apple, Google, Nintendo Account, Nintendo Service Account, Oculus or the Device ID feature login.
	 * It is also required for using the Lobbies and Sessions interfaces when running on the Nintendo Switch device, and using any other credential type than EOS_ECT_NINTENDO_NSA_ID_TOKEN.
	 * In all other cases, set this field to NULL.
	 */
	const EOS_Connect_UserLoginInfo* UserLoginInfo;
));

/**
 * Output parameters for the EOS_Connect_Login function.
 */
EOS_STRUCT(EOS_Connect_LoginCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_Login. */
	void* ClientData;
	/** If login was successful, this is the Product User ID of the local player that logged in. */
	EOS_ProductUserId LocalUserId;
	/**
	 * If the user was not found with credentials passed into EOS_Connect_Login,
	 * this continuance token can be passed to either EOS_Connect_CreateUser
	 * or EOS_Connect_LinkAccount to continue the flow.
	 */
	EOS_ContinuanceToken ContinuanceToken;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_Login.
 *
 * @param Data A EOS_Connect_LoginCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnLoginCallback, const EOS_Connect_LoginCallbackInfo* Data);

/** The most recent version of the EOS_Connect_Logout API. */
#define EOS_CONNECT_LOGOUT_API_LATEST 1

/** Input parameters for the EOS_Connect_Logout API */
EOS_STRUCT(EOS_Connect_LogoutOptions, (
	/** API Version: Set this to EOS_CONNECT_LOGOUT_API_LATEST. */
	int32_t ApiVersion;

	/** The Product User ID of the player to logout */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Connect_Logout function.
 */
EOS_STRUCT(EOS_Connect_LogoutCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;

	/** Context that was passed into EOS_Connect_Logout. */
	void* ClientData;

	/** The Product User ID of the player that is being logged out. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_Logout
 * 
 * @param Data A EOS_Connect_LogoutCallbackInfo containing the result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnLogoutCallback, const EOS_Connect_LogoutCallbackInfo* Data);

/** The most recent version of the EOS_Connect_CreateUser API. */
#define EOS_CONNECT_CREATEUSER_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CreateUser function.
 */
EOS_STRUCT(EOS_Connect_CreateUserOptions, (
	/** API Version: Set this to EOS_CONNECT_CREATEUSER_API_LATEST. */
	int32_t ApiVersion;
	/** Continuance token from previous call to EOS_Connect_Login */
	EOS_ContinuanceToken ContinuanceToken;
));

/**
 * Output parameters for the EOS_Connect_CreateUser function.
 */
EOS_STRUCT(EOS_Connect_CreateUserCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_CreateUser. */
	void* ClientData;
	/** If the operation succeeded, this is the Product User ID of the local user who was created. */
	EOS_ProductUserId LocalUserId;
));

EOS_DECLARE_CALLBACK(EOS_Connect_OnCreateUserCallback, const EOS_Connect_CreateUserCallbackInfo* Data);

/** The most recent version of the EOS_Connect_LinkAccount API. */
#define EOS_CONNECT_LINKACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_LinkAccount function.
 */
EOS_STRUCT(EOS_Connect_LinkAccountOptions, (
	/** API Version: Set this to EOS_CONNECT_LINKACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The existing logged in product user for which to link the external account described by the continuance token. */
	EOS_ProductUserId LocalUserId;
	/** Continuance token from previous call to EOS_Connect_Login. */
	EOS_ContinuanceToken ContinuanceToken;
));

/**
 * Output parameters for the EOS_Connect_LinkAccount function.
 */
EOS_STRUCT(EOS_Connect_LinkAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_LinkAccount. */
	void* ClientData;
	/** The Product User ID of the existing, logged-in user whose account was linked (on success). */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_LinkAccount.
 *
 * @param Data A EOS_Connect_LinkAccountCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnLinkAccountCallback, const EOS_Connect_LinkAccountCallbackInfo* Data);

/** The most recent version of the EOS_Connect_UnlinkAccount API. */
#define EOS_CONNECT_UNLINKACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_UnlinkAccount Function.
 */
EOS_STRUCT(EOS_Connect_UnlinkAccountOptions, (
	/** API Version: Set this to EOS_CONNECT_UNLINKACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Existing logged in product user that is subject for the unlinking operation.
	 * The external account that was used to login to the product user will be unlinked from the owning keychain.
	 *
	 * On a successful operation, the product user will be logged out as the external account used to authenticate the user was unlinked from the owning keychain.
	 */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Connect_UnlinkAccount Function.
 */
EOS_STRUCT(EOS_Connect_UnlinkAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_UnlinkAccount. */
	void* ClientData;
	/**
	 * The product user that was subject for the unlinking operation.
	 *
	 * On a successful operation, the local authentication session for the product user will have been invalidated.
	 * As such, the LocalUserId value will no longer be valid in any context unless the user is logged into it again.
	 */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_UnlinkAccount.
 *
 * @param Data A EOS_Connect_UnlinkAccountCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnUnlinkAccountCallback, const EOS_Connect_UnlinkAccountCallbackInfo* Data);

/** The most recent version of the EOS_Connect_CreateDeviceId API. */
#define EOS_CONNECT_CREATEDEVICEID_API_LATEST 1

/** Max length of a device model name, not including the terminating null */
#define EOS_CONNECT_CREATEDEVICEID_DEVICEMODEL_MAX_LENGTH 64

/**
 * Input parameters for the EOS_Connect_CreateDeviceId function.
 */
EOS_STRUCT(EOS_Connect_CreateDeviceIdOptions, (
	/** API Version: Set this to EOS_CONNECT_CREATEDEVICEID_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * A freeform text description identifying the device type and model,
	 * which can be used in account linking management to allow the player
	 * and customer support to identify different devices linked to an EOS
	 * user keychain. For example 'iPhone 6S' or 'PC Windows'.
	 *
	 * The input string must be in UTF-8 character format, with a maximum
	 * length of 64 characters. Longer string will be silently truncated.
	 *
	 * This field is required to be present.
	 */
	const char* DeviceModel;
));

/**
 * Output parameters for the EOS_Connect_CreateDeviceId function.
 */
EOS_STRUCT(EOS_Connect_CreateDeviceIdCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_CreateDeviceId. */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_Connect_OnCreateDeviceIdCallback, const EOS_Connect_CreateDeviceIdCallbackInfo* Data);

/** The most recent version of the EOS_Connect_DeleteDeviceId API. */
#define EOS_CONNECT_DELETEDEVICEID_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_DeleteDeviceId function.
 */
EOS_STRUCT(EOS_Connect_DeleteDeviceIdOptions, (
	/** API Version: Set this to EOS_CONNECT_DELETEDEVICEID_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Connect_DeleteDeviceId function.
 */
EOS_STRUCT(EOS_Connect_DeleteDeviceIdCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_DeleteDeviceId */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_Connect_OnDeleteDeviceIdCallback, const EOS_Connect_DeleteDeviceIdCallbackInfo* Data);

/** The most recent version of the EOS_Connect_TransferDeviceIdAccount API. */
#define EOS_CONNECT_TRANSFERDEVICEIDACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_TransferDeviceIdAccount Function.
 */
EOS_STRUCT(EOS_Connect_TransferDeviceIdAccountOptions, (
	/** API Version: Set this to EOS_CONNECT_TRANSFERDEVICEIDACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The primary product user id, currently logged in, that is already associated with a real external user account (such as Epic Games, PlayStation(TM)Network, Xbox Live and other).
	 *
	 * The account linking keychain that owns this product user will be preserved and receive
	 * the Device ID login credentials under it.
	 */
	EOS_ProductUserId PrimaryLocalUserId;
	/**
	 * The product user id, currently logged in, that has been originally created using the anonymous local Device ID login type,
	 * and whose Device ID login will be transferred to the keychain of the PrimaryLocalUserId.
	 */
	EOS_ProductUserId LocalDeviceUserId;
	/**
	 * Specifies which EOS_ProductUserId (i.e. game progression) will be preserved in the operation.
	 *
	 * After a successful transfer operation, subsequent logins using the same external account or
	 * the same local Device ID login will return user session for the ProductUserIdToPreserve.
	 *
	 * Set to either PrimaryLocalUserId or LocalDeviceUserId.
	 */
	EOS_ProductUserId ProductUserIdToPreserve;
));

/**
 * Output parameters for the EOS_Connect_TransferDeviceIdAccount Function.
 */
EOS_STRUCT(EOS_Connect_TransferDeviceIdAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_TransferDeviceIdAccount. */
	void* ClientData;
	/**
	 * The ProductUserIdToPreserve that was passed to the original EOS_Connect_TransferDeviceIdAccount call.
	 *
	 * On successful operation, this EOS_ProductUserId will have a valid authentication session
	 * and the other EOS_ProductUserId value has been discarded and lost forever.
	 *
	 * The application should remove any registered notification callbacks for the discarded EOS_ProductUserId as obsolete.
	 */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_TransferDeviceIdAccount.
 *
 * @param Data A EOS_Connect_TransferDeviceIdAccountCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnTransferDeviceIdAccountCallback, const EOS_Connect_TransferDeviceIdAccountCallbackInfo* Data);

/** The most recent version of the EOS_Connect_QueryExternalAccountMappings API. */
#define EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_API_LATEST 1

/** Maximum number of account IDs that can be queried at once */
#define EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_MAX_ACCOUNT_IDS 128

/**
 * Input parameters for the EOS_Connect_QueryExternalAccountMappings function.
 */
EOS_STRUCT(EOS_Connect_QueryExternalAccountMappingsOptions, (
	/** API Version: Set this to EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the existing, logged-in user who is querying account mappings. */
	EOS_ProductUserId LocalUserId;
	/** External auth service supplying the account IDs in string form. */
	EOS_EExternalAccountType AccountIdType;
	/** An array of external account IDs to map to the product user ID representation. */
	const char** ExternalAccountIds;
	/** Number of account IDs to query. */
	uint32_t ExternalAccountIdCount;
));

/**
 * Output parameters for the EOS_Connect_QueryExternalAccountMappings function.
 */
EOS_STRUCT(EOS_Connect_QueryExternalAccountMappingsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_QueryExternalAccountMappings. */
	void* ClientData;
	/** The Product User ID of the existing, logged-in user who made the request. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_QueryExternalAccountMappings.
 *
 * @param Data A EOS_Connect_QueryExternalAccountMappingsCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnQueryExternalAccountMappingsCallback, const EOS_Connect_QueryExternalAccountMappingsCallbackInfo* Data);

/** The most recent version of the EOS_Connect_GetExternalAccountMapping API. */
#define EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST 1

/** DEPRECATED! Use EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST instead. */
#define EOS_CONNECT_GETEXTERNALACCOUNTMAPPINGS_API_LATEST EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST

/**
 * Input parameters for the EOS_Connect_GetExternalAccountMapping function.
 */
EOS_STRUCT(EOS_Connect_GetExternalAccountMappingsOptions, (
	/** API Version: Set this to EOS_CONNECT_GETEXTERNALACCOUNTMAPPING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the existing, logged-in user who is querying account mappings. */
	EOS_ProductUserId LocalUserId;
	/** External auth service supplying the account IDs in string form. */
	EOS_EExternalAccountType AccountIdType;
	/** Target user to retrieve the mapping for, as an external account ID. */
	const char* TargetExternalUserId;
));

/** The most recent version of the EOS_Connect_QueryProductUserIdMappings API. */
#define EOS_CONNECT_QUERYPRODUCTUSERIDMAPPINGS_API_LATEST 2

/**
 * Input parameters for the EOS_Connect_QueryProductUserIdMappings function.
 */
EOS_STRUCT(EOS_Connect_QueryProductUserIdMappingsOptions, (
	/** API Version: Set this to EOS_CONNECT_QUERYPRODUCTUSERIDMAPPINGS_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Game Clients set this field to the Product User ID of the local authenticated user querying account mappings.
	 * Game Servers set this field to NULL. Usage is allowed given that the configured client policy for server credentials permit it.
	 */
	EOS_ProductUserId LocalUserId;
	/** Deprecated - all external mappings are included in this call, it is no longer necessary to specify this value. */
	EOS_EExternalAccountType AccountIdType_DEPRECATED;
	/** An array of Product User IDs to query for the given external account representation. */
	EOS_ProductUserId* ProductUserIds;
	/** Number of Product User IDs to query. */
	uint32_t ProductUserIdCount;
));

/**
 * Output parameters for the EOS_Connect_QueryProductUserIdMappings function.
 */
EOS_STRUCT(EOS_Connect_QueryProductUserIdMappingsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_QueryProductUserIdMappings. */
	void* ClientData;
	/** The local Product User ID that was passed with the input options. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Connect_QueryProductUserIdMappings.
 *
 * @param Data A EOS_Connect_QueryProductUserIdMappingsCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnQueryProductUserIdMappingsCallback, const EOS_Connect_QueryProductUserIdMappingsCallbackInfo* Data);

/** The most recent version of the EOS_Connect_GetProductUserIdMapping API. */
#define EOS_CONNECT_GETPRODUCTUSERIDMAPPING_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_GetProductUserIdMapping function.
 */
EOS_STRUCT(EOS_Connect_GetProductUserIdMappingOptions, (
	/** API Version: Set this to EOS_CONNECT_GETPRODUCTUSERIDMAPPING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the existing, logged-in user that is querying account mappings. */
	EOS_ProductUserId LocalUserId;
	/** External auth service mapping to retrieve. */
	EOS_EExternalAccountType AccountIdType;
	/** The Product User ID of the user whose information is being requested. */
	EOS_ProductUserId TargetProductUserId;
));

/** The most recent version of the EOS_Connect_GetProductUserExternalAccountCount API. */
#define EOS_CONNECT_GETPRODUCTUSEREXTERNALACCOUNTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_GetProductUserExternalAccountCount function.
 */
EOS_STRUCT(EOS_Connect_GetProductUserExternalAccountCountOptions, (
	/** API Version: Set this to EOS_CONNECT_GETPRODUCTUSEREXTERNALACCOUNTCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when getting external account info count from the cache. */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_Connect_CopyProductUserExternalAccountByIndex API. */
#define EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyProductUserExternalAccountByIndex function.
 */
EOS_STRUCT(EOS_Connect_CopyProductUserExternalAccountByIndexOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when copying external account info from the cache. */
	EOS_ProductUserId TargetUserId;
	/** Index of the external account info to retrieve from the cache. */
	uint32_t ExternalAccountInfoIndex;
));

/** The most recent version of the EOS_Connect_CopyProductUserExternalAccountByAccountType API. */
#define EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTTYPE_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyProductUserExternalAccountByAccountType function.
 */
EOS_STRUCT(EOS_Connect_CopyProductUserExternalAccountByAccountTypeOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTTYPE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when copying external account info from the cache. */
	EOS_ProductUserId TargetUserId;
	/** External auth service account type to look for when copying external account info from the cache. */
	EOS_EExternalAccountType AccountIdType;
));

/** The most recent version of the EOS_Connect_CopyProductUserExternalAccountByAccountId API. */
#define EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTID_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyProductUserExternalAccountByAccountId function.
 */
EOS_STRUCT(EOS_Connect_CopyProductUserExternalAccountByAccountIdOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when copying external account info from the cache. */
	EOS_ProductUserId TargetUserId;
	/** External auth service account ID to look for when copying external account info from the cache. */
	const char* AccountId;
));

/** The most recent version of the EOS_Connect_CopyProductUserInfo API. */
#define EOS_CONNECT_COPYPRODUCTUSERINFO_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyProductUserInfo function.
 */
EOS_STRUCT(EOS_Connect_CopyProductUserInfoOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYPRODUCTUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** Product user ID to look for when copying external account info from the cache. */
	EOS_ProductUserId TargetUserId;
));

/** Timestamp value representing an undefined time for last login time. */
#define EOS_CONNECT_TIME_UNDEFINED -1

/** The most recent version of the EOS_Connect_ExternalAccountInfo struct. */
#define EOS_CONNECT_EXTERNALACCOUNTINFO_API_LATEST 1

/**
 * Contains information about an external account linked with a Product User ID.
 */
EOS_STRUCT(EOS_Connect_ExternalAccountInfo, (
	/** API Version: Set this to EOS_CONNECT_EXTERNALACCOUNTINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the target user. */
	EOS_ProductUserId ProductUserId;
	/** Display name, can be null if not set. */
	const char* DisplayName;
	/**
	 * External account ID.
	 *
	 * May be set to an empty string if the AccountIdType of another user belongs
	 * to different account system than the local user's authenticated account.
	 * The availability of this field is dependent on account system specifics.
	 */
	const char* AccountId;
	/** The identity provider that owns the external account. */
	EOS_EExternalAccountType AccountIdType;
	/** The POSIX timestamp for the time the user last logged in, or EOS_CONNECT_TIME_UNDEFINED. */
	int64_t LastLoginTime;
));

/**
 * Release the memory associated with an external account info. This must be called on data retrieved from
 * EOS_Connect_CopyProductUserExternalAccountByIndex, EOS_Connect_CopyProductUserExternalAccountByAccountType,
 * EOS_Connect_CopyProductUserExternalAccountByAccountId or EOS_Connect_CopyProductUserInfo.
 *
 * @param ExternalAccountInfo The external account info data to release.
 *
 * @see EOS_Connect_CopyProductUserExternalAccountByIndex
 * @see EOS_Connect_CopyProductUserExternalAccountByAccountType
 * @see EOS_Connect_CopyProductUserExternalAccountByAccountId
 * @see EOS_Connect_CopyProductUserInfo
 */
EOS_DECLARE_FUNC(void) EOS_Connect_ExternalAccountInfo_Release(EOS_Connect_ExternalAccountInfo* ExternalAccountInfo);

/** The most recent version of the EOS_Connect_AddNotifyAuthExpiration API. */
#define EOS_CONNECT_ADDNOTIFYAUTHEXPIRATION_API_LATEST 1
/**
 * Structure containing information for the auth expiration notification callback.
 */
EOS_STRUCT(EOS_Connect_AddNotifyAuthExpirationOptions, (
	/** API Version: Set this to EOS_CONNECT_ADDNOTIFYAUTHEXPIRATION_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Connect_OnAuthExpirationCallback API. */
#define EOS_CONNECT_ONAUTHEXPIRATIONCALLBACK_API_LATEST 1

/**
 * Output parameters for the EOS_Connect_OnAuthExpirationCallback function.
 */
EOS_STRUCT(EOS_Connect_AuthExpirationCallbackInfo, (
	/** Context that was passed into EOS_Connect_AddNotifyAuthExpiration. */
	void* ClientData;
	/** The Product User ID of the local player whose status has changed. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for notifications that come from EOS_Connect_AddNotifyAuthExpiration.
 *
 * @param Data A EOS_Connect_AuthExpirationCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnAuthExpirationCallback, const EOS_Connect_AuthExpirationCallbackInfo* Data);


/** The most recent version of the EOS_Connect_AddNotifyLoginStatusChanged API. */
#define EOS_CONNECT_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST 1
/**
 * Structure containing information or the connect user login status change callback.
 */
EOS_STRUCT(EOS_Connect_AddNotifyLoginStatusChangedOptions, (
	/** API Version: Set this to EOS_CONNECT_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Connect_OnLoginStatusChangedCallback function.
 */
EOS_STRUCT(EOS_Connect_LoginStatusChangedCallbackInfo, (
	/** Context that was passed into EOS_Connect_AddNotifyLoginStatusChanged. */
	void* ClientData;
	/** The Product User ID of the local player whose status has changed. */
	EOS_ProductUserId LocalUserId;
	/** The status prior to the change. */
	EOS_ELoginStatus PreviousStatus;
	/** The status at the time of the notification. */
	EOS_ELoginStatus CurrentStatus;
));

/**
 * Function prototype definition for notifications that come from EOS_Connect_AddNotifyLoginStatusChanged.
 *
 * @param Data A EOS_Connect_LoginStatusChangedCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnLoginStatusChangedCallback, const EOS_Connect_LoginStatusChangedCallbackInfo* Data);

/** The most recent version of the EOS_Connect_IdToken struct. */
#define EOS_CONNECT_IDTOKEN_API_LATEST 1

/**
 * A structure that contains an ID token.
 * These structures are created by EOS_Connect_CopyIdToken and must be passed to EOS_Connect_IdToken_Release.
 */
EOS_STRUCT(EOS_Connect_IdToken, (
	/** API Version: Set this to EOS_CONNECT_IDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The Product User ID described by the ID token.
	 * Use EOS_ProductUserId_FromString to populate this field when validating a received ID token.
	 */
	EOS_ProductUserId ProductUserId;
	/** The ID token as a Json Web Token (JWT) string. */
	const char* JsonWebToken;
));

/**
 * Release the memory associated with an EOS_Connect_IdToken structure. This must be called on data retrieved from EOS_Connect_CopyIdToken.
 *
 * @param IdToken The ID token structure to be released.
 *
 * @see EOS_Connect_IdToken
 * @see EOS_Connect_CopyIdToken
 */
EOS_DECLARE_FUNC(void) EOS_Connect_IdToken_Release(EOS_Connect_IdToken* IdToken);

/** The most recent version of the EOS_Connect_CopyIdToken API. */
#define EOS_CONNECT_COPYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_CopyIdToken function.
 */
EOS_STRUCT(EOS_Connect_CopyIdTokenOptions, (
	/** API Version: Set this to EOS_CONNECT_COPYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The local Product User ID whose ID token should be copied. */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Connect_VerifyIdToken API. */
#define EOS_CONNECT_VERIFYIDTOKEN_API_LATEST 1

/**
 * Input parameters for the EOS_Connect_VerifyIdToken function.
 */
EOS_STRUCT(EOS_Connect_VerifyIdTokenOptions, (
	/** API Version: Set this to EOS_CONNECT_VERIFYIDTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The ID token to verify.
	 * Use EOS_ProductUserId_FromString to populate the ProductUserId field of this struct.
	 */
	const EOS_Connect_IdToken* IdToken;
));

/**
 * Output parameters for the EOS_Connect_VerifyIdToken Function.
 */
EOS_STRUCT(EOS_Connect_VerifyIdTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Connect_VerifyIdToken */
	void* ClientData;
	/** The Product User ID associated with the ID token. */
	EOS_ProductUserId ProductUserId;
	/**
	 * Flag set to indicate whether account information is available.
	 * Applications must always first check this value to be set before attempting
	 * to read the AccountType, AccountId, Platform and DeviceType fields.
	 *
	 * This flag is always false for users that authenticated using EOS Connect Device ID.
	 */
	EOS_Bool bIsAccountInfoPresent;
	/**
	 * The identity provider that the user authenticated with to EOS Connect.
	 *
	 * If bIsAccountInfoPresent is set, this field describes the external account type.
	 */
	EOS_EExternalAccountType AccountIdType;
	/**
	 * The external account ID of the authenticated user.
	 *
	 * This value may be set to an empty string.
	 */
	const char* AccountId;
	/**
	 * Platform that the user is connected from.
	 *
	 * This value may be set to an empty string.
	 */
	const char* Platform;
	/**
	 * Identifies the device type that the user is connected from.
	 * Can be used to securely verify that the user is connected through a real Console device.
	 *
	 * This value may be set to an empty string.
	 */
	const char* DeviceType;
	/**
	 * Client ID of the authorized client.
	 */
	const char* ClientId;
	/**
	 * Product ID.
	 */
	const char* ProductId;
	/**
	 * Sandbox ID.
	 */
	const char* SandboxId;
	/**
	 * Deployment ID.
	 */
	const char* DeploymentId;
));

/**
 * Function prototype definition for callbacks passed into EOS_Connect_VerifyIdToken.
 *
 * @param Data A EOS_Connect_VerifyIdTokenCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Connect_OnVerifyIdTokenCallback, const EOS_Connect_VerifyIdTokenCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_custominvites.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_custominvites_types.h"

/**
 * The Custom Invites Interface is designed to allow developers to have custom game Invite and Join operations driven by the Notification Service and supported by the Overlay (if desired).
 * All Custom Invites Interface calls take a handle of type EOS_HCustomInvites as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetCustomInvitesInterface function.
 *
 * @see EOS_Platform_GetCustomInvitesInterface
 */

/**
 * Initializes a Custom Invite with a specified payload in preparation for it to be sent to another user or users.
 *
 * @param Options Structure containing information about the request.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options values are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_CustomInvites_SetCustomInvite(EOS_HCustomInvites Handle, const EOS_CustomInvites_SetCustomInviteOptions* Options);

/**
 * Sends a Custom Invite that has previously been initialized via SetCustomInvite to a group of users.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if the query completes successfully
 *         EOS_InvalidParameters if any of the options values are incorrect
 *         EOS_TooManyRequests if the number of allowed queries is exceeded
 *         EOS_NotFound if SetCustomInvite has not been previously successfully called for this user
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_SendCustomInvite(EOS_HCustomInvites Handle, const EOS_CustomInvites_SendCustomInviteOptions* Options, void* ClientData, const EOS_CustomInvites_OnSendCustomInviteCallback CompletionDelegate);

/**
 * Register to receive notifications when a Custom Invite for any logged in local user is received
 * @note If the returned NotificationId is valid, you must call EOS_CustomInvites_RemoveNotifyCustomInviteReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a Custom Invite is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_CustomInvites_AddNotifyCustomInviteReceived(EOS_HCustomInvites Handle, const EOS_CustomInvites_AddNotifyCustomInviteReceivedOptions* Options, void* ClientData, const EOS_CustomInvites_OnCustomInviteReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a Custom Invite for any logged in local user is received
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RemoveNotifyCustomInviteReceived(EOS_HCustomInvites Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a Custom Invite for any logged in local user is accepted via the Social Overlay
 * Invites accepted in this way still need to have FinalizeInvite called on them after you have finished processing the invite accept (e.g. after joining the game)
 * @note If the returned NotificationId is valid, you must call EOS_CustomInvites_RemoveNotifyCustomInviteAccepted when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a Custom Invite is accepted via the Social Overlay.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_CustomInvites_AddNotifyCustomInviteAccepted(EOS_HCustomInvites Handle, const EOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions* Options, void* ClientData, const EOS_CustomInvites_OnCustomInviteAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a Custom Invite for any logged in local user is accepted via the Social Overlay
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RemoveNotifyCustomInviteAccepted(EOS_HCustomInvites Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a Custom Invite for any logged in local user is rejected via the Social Overlay
 * Invites rejected in this way do not need to have FinalizeInvite called on them, it is called automatically internally by the SDK.
 * @note If the returned NotificationId is valid, you must call EOS_CustomInvites_RemoveNotifyCustomInviteRejected when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a Custom Invite is rejected via the Social Overlay.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_CustomInvites_AddNotifyCustomInviteRejected(EOS_HCustomInvites Handle, const EOS_CustomInvites_AddNotifyCustomInviteRejectedOptions* Options, void* ClientData, const EOS_CustomInvites_OnCustomInviteRejectedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a Custom Invite for any logged in local user is rejected via the Social Overlay
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RemoveNotifyCustomInviteRejected(EOS_HCustomInvites Handle, EOS_NotificationId InId);

/**
 * Signal that the title has completed processing a received Custom Invite, and that it should be cleaned up internally and in the Overlay
 *
 * @param Options Structure containing information about the request.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the option values are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_CustomInvites_FinalizeInvite(EOS_HCustomInvites Handle, const EOS_CustomInvites_FinalizeInviteOptions* Options);

/**
 * Request that another user send an invitation.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if the query completes successfully
 *         EOS_InvalidParameters if any of the options values are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_SendRequestToJoin(EOS_HCustomInvites Handle, const EOS_CustomInvites_SendRequestToJoinOptions* Options, void* ClientData, const EOS_CustomInvites_OnSendRequestToJoinCallback CompletionDelegate);

/**
 * Register to receive notifications when a request to join is responded to by a target user. Note that there is no guarantee a response will be received for every request to join.
 * A player is free to ignore a Request to Join until it expires at which point it will be deleted without sending a response.
 * @note If the returned NotificationId is valid, you must call EOS_CustomInvites_RemoveNotifyRequestToJoinResponseReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a response is received for an invite request.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_CustomInvites_AddNotifyRequestToJoinResponseReceived(EOS_HCustomInvites Handle, const EOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions* Options, void* ClientData, const EOS_CustomInvites_OnRequestToJoinResponseReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a request to join for any logged in local user is received
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RemoveNotifyRequestToJoinResponseReceived(EOS_HCustomInvites Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a request to join is received for a local user
 * @note If the returned NotificationId is valid, you must call EOS_CustomInvites_RemoveNotifyRequestToJoinReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a response is received for an invite request.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_CustomInvites_AddNotifyRequestToJoinReceived(EOS_HCustomInvites Handle, const EOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions* Options, void* ClientData, const EOS_CustomInvites_OnRequestToJoinReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a request to join for any logged in local user is received
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RemoveNotifyRequestToJoinReceived(EOS_HCustomInvites Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about a custom invite "INVITE" performed by a local user via the overlay.
 * This is only needed when a configured integrated platform has EOS_IPMF_DisableSDKManagedSessions set.  The EOS SDK will
 * then use the state of EOS_IPMF_PreferEOSIdentity and EOS_IPMF_PreferIntegratedIdentity to determine when the NotificationFn is
 * called.
 *
 * @note If the returned NotificationId is valid, you must call EOS_CustomInvites_RemoveNotifySendCustomNativeInviteRequested when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 *
 * @see EOS_IPMF_DisableSDKManagedSessions
 * @see EOS_IPMF_PreferEOSIdentity
 * @see EOS_IPMF_PreferIntegratedIdentity
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_CustomInvites_AddNotifySendCustomNativeInviteRequested(EOS_HCustomInvites Handle, const EOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions* Options, void* ClientData, const EOS_CustomInvites_OnSendCustomNativeInviteRequestedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user requests a send invite via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RemoveNotifySendCustomNativeInviteRequested(EOS_HCustomInvites Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a Request to Join for any logged in local user is accepted via the Social Overlay
 * @note If the returned NotificationId is valid, you must call EOS_CustomInvites_RemoveNotifyRequestToJoinAccepted when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a Request to Join is accepted via the Social Overlay.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_CustomInvites_AddNotifyRequestToJoinAccepted(EOS_HCustomInvites Handle, const EOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions* Options, void* ClientData, const EOS_CustomInvites_OnRequestToJoinAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a Request to Join for any logged in local user is accepted via the Social Overlay
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RemoveNotifyRequestToJoinAccepted(EOS_HCustomInvites Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a Request to Join for any logged in local user is rejected via the Social Overlay
 * @note If the returned NotificationId is valid, you must call EOS_CustomInvites_RemoveNotifyRequestToJoinRejected when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a Request to Join is accepted via the Social Overlay.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_CustomInvites_AddNotifyRequestToJoinRejected(EOS_HCustomInvites Handle, const EOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions* Options, void* ClientData, const EOS_CustomInvites_OnRequestToJoinRejectedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a Request to Join for any logged in local user is rejected via the Social Overlay
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RemoveNotifyRequestToJoinRejected(EOS_HCustomInvites Handle, EOS_NotificationId InId);

/**
 * Accept a request to join from another user
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if the query completes successfully
 *         EOS_InvalidParameters if any of the options values are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_AcceptRequestToJoin(EOS_HCustomInvites Handle, const EOS_CustomInvites_AcceptRequestToJoinOptions* Options, void* ClientData, const EOS_CustomInvites_OnAcceptRequestToJoinCallback CompletionDelegate);

/**
 * Reject a request to join from another user
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if the query completes successfully
 *         EOS_InvalidParameters if any of the options values are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_CustomInvites_RejectRequestToJoin(EOS_HCustomInvites Handle, const EOS_CustomInvites_RejectRequestToJoinOptions* Options, void* ClientData, const EOS_CustomInvites_OnRejectRequestToJoinCallback CompletionDelegate);

```

`EAC_SDK/SDK/include/eos_custominvites_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"
#include "eos_ui_types.h"

#pragma pack(push, 8)

/** Handle to the custom invites interface */
EXTERN_C typedef struct EOS_CustomInvitesHandle* EOS_HCustomInvites;

/** Maximum size of the custom invite payload string */
#define EOS_CUSTOMINVITES_MAX_PAYLOAD_LENGTH 500

/** The most recent version of the EOS_CustomInvites_SetCustomInvite API. */
#define EOS_CUSTOMINVITES_SETCUSTOMINVITE_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_SetCustomInviteOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_SETCUSTOMINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** Local user creating / sending a Custom Invite */
	EOS_ProductUserId LocalUserId;
	/** String payload for the Custom Invite (must be less than EOS_CUSTOMINVITES_MAX_PAYLOAD_LENGTH) */
	const char* Payload;
));

/** The most recent version of the EOS_CustomInvites_SendCustomInvite API. */
#define EOS_CUSTOMINVITES_SENDCUSTOMINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_CustomInvites_SendCustomInvite function.
 */
EOS_STRUCT(EOS_CustomInvites_SendCustomInviteOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_SENDCUSTOMINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** Local user sending a CustomInvite */
	EOS_ProductUserId LocalUserId;
	/** Users to whom the invites should be sent */
	EOS_ProductUserId* TargetUserIds;
	/** The number of users we are sending to */
	uint32_t TargetUserIdsCount;
));

/**
 * Output parameters for the EOS_CustomInvites_SendCustomInvite Function. These parameters are received through the callback provided to EOS_CustomInvites_SendCustomInvite
 */
EOS_STRUCT(EOS_CustomInvites_SendCustomInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_CustomInvites_SendCustomInvite */
	void* ClientData;
	/** Local user sending a CustomInvite */
	EOS_ProductUserId LocalUserId;
	/** Users to whom the invites were successfully sent (can be different than original call if an invite for same Payload was previously sent) */
	EOS_ProductUserId* TargetUserIds;
	/** The number of users we are sending to */
	uint32_t TargetUserIdsCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_CustomInvites_SendCustomInvite
 * @param Data A EOS_CustomInvites_SendCustomInviteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnSendCustomInviteCallback, const EOS_CustomInvites_SendCustomInviteCallbackInfo* Data);


/** The most recent version of the EOS_CustomInvites_AddNotifyCustomInviteReceived API. */
#define EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AddNotifyCustomInviteReceivedOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_CustomInvites_OnCustomInviteReceivedCallback Function.
 */
EOS_STRUCT(EOS_CustomInvites_OnCustomInviteReceivedCallbackInfo, (
	/** Context that was passed into EOS_CustomInvites_AddNotifyCustomInviteReceived */
	void* ClientData;
	/** User that sent this custom invite */
	EOS_ProductUserId TargetUserId;
	/** Recipient Local user id */
	EOS_ProductUserId LocalUserId;
	/** Id of the received Custom Invite*/
	const char* CustomInviteId;
	/** Payload of the received Custom Invite */
	const char* Payload;
));

/**
 * Function prototype definition for notifications that comes from EOS_CustomInvites_AddNotifyCustomInviteReceived
 *
 * @param Data A EOS_CustomInvites_OnCustomInviteReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnCustomInviteReceivedCallback, const EOS_CustomInvites_OnCustomInviteReceivedCallbackInfo* Data);


/** The most recent version of the EOS_CustomInvites_AddNotifyCustomInviteAccepted API. */
#define EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEACCEPTED_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_CustomInvites_OnCustomInviteAcceptedCallback Function.
 */
EOS_STRUCT(EOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo, (
	/** Context that was passed into EOS_CustomInvites_AddNotifyCustomInviteAccepted */
	void* ClientData;
	/** User that sent the custom invite */
	EOS_ProductUserId TargetUserId;
	/** Recipient Local user id */
	EOS_ProductUserId LocalUserId;
	/** Id of the accepted Custom Invite */
	const char* CustomInviteId;
	/** Payload of the accepted Custom Invite */
	const char* Payload;
));

/**
 * Function prototype definition for notifications that comes from EOS_CustomInvites_AddNotifyCustomInviteAccepted
 *
 * @param Data A EOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnCustomInviteAcceptedCallback, const EOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo* Data);

/** The most recent version of the EOS_CustomInvites_AddNotifyCustomInviteRejected API. */
#define EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEREJECTED_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AddNotifyCustomInviteRejectedOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEREJECTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_CustomInvites_OnCustomInviteRejectedCallback Function.
 */
EOS_STRUCT(EOS_CustomInvites_CustomInviteRejectedCallbackInfo, (
	/** Context that was passed into EOS_CustomInvites_AddNotifyCustomInviteRejected */
	void* ClientData;
	/** User that sent the custom invite */
	EOS_ProductUserId TargetUserId;
	/** Recipient Local user id */
	EOS_ProductUserId LocalUserId;
	/** Id of the rejected Custom Invite */
	const char* CustomInviteId;
	/** Payload of the rejected Custom Invite */
	const char* Payload;
));

/**
 * Function prototype definition for notifications that comes from EOS_CustomInvites_AddNotifyCustomInviteRejected
 *
 * @param Data A EOS_CustomInvites_CustomInviteRejectedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnCustomInviteRejectedCallback, const EOS_CustomInvites_CustomInviteRejectedCallbackInfo* Data);

/** The most recent version of the EOS_CustomInvites_FinalizeInvite API. */
#define EOS_CUSTOMINVITES_FINALIZEINVITE_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_FinalizeInviteOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_FINALIZEINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** User that sent the custom invite */
	EOS_ProductUserId TargetUserId;
	/** Recipient Local user id */
	EOS_ProductUserId LocalUserId;
	/** Id of the Custom Invite accepted */
	const char* CustomInviteId;
	/** Result of the Processing operation, transmitted to Social Overlay if applicable */
	EOS_EResult ProcessingResult;
));

/** The most recent version of the EOS_CustomInvites_SendRequestToJoinOptions API. */
#define EOS_CUSTOMINVITES_SENDREQUESTTOJOIN_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_SendRequestToJoinOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_SENDREQUESTTOJOIN_API_LATEST. */
	int32_t ApiVersion;
	/** Local user Requesting an Invite */
	EOS_ProductUserId LocalUserId;
	/** Recipient of Request Invite*/
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_CustomInvites_SendRequestToJoin Function. These parameters are received through the callback provided to EOS_CustomInvites_SendRequestToJoin
 */
EOS_STRUCT(EOS_CustomInvites_SendRequestToJoinCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_CustomInvites_SendRequestToJoin */
	void* ClientData;
	/** Local user requesting an invite */
	EOS_ProductUserId LocalUserId;
	/** Recipient of Request Invite*/
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_CustomInvites_SendRequestToJoin
 * @param Data A EOS_CustomInvites_SendCustomInviteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnSendRequestToJoinCallback, const EOS_CustomInvites_SendRequestToJoinCallbackInfo* Data);

/** The most recent version of the EOS_CustomInvites_AddNotifyRequestToJoinResponseReceived API. */
#define EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRESPONSERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AddNotifyRequestToJoinResponseReceivedOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRESPONSERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/** Response to an invite request. */
EOS_ENUM(EOS_ERequestToJoinResponse,
	/** The target of the invite request has accepted. */
	EOS_RTJR_ACCEPTED = 0,
	/** The target of the invite request has rejected. */
	EOS_RTJR_REJECTED = 1
);

/**
 * Output parameters for the EOS_CustomInvites_OnRequestToJoinResponseReceivedCallback function.
 */
EOS_STRUCT(EOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo, (
	/** Context that was passed into EOS_CustomInvites_AddNotifyRequestToJoinResponseReceived */
	void* ClientData;
	/** User that sent this response */
	EOS_ProductUserId FromUserId;
	/** Recipient Local user id */
	EOS_ProductUserId ToUserId;
	/** The Intent associated with this response */
	EOS_ERequestToJoinResponse Response;
));

/**
 * Function prototype definition for notifications that come from EOS_CustomInvites_AddNotifyRequestToJoinResponseReceived
 *
 * @param Data A EOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnRequestToJoinResponseReceivedCallback, const EOS_CustomInvites_RequestToJoinResponseReceivedCallbackInfo* Data);

/** The most recent version of the AddNotifyRequestToJoinReceived API. */
#define EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRECEIVED_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_CustomInvites_AddNotifyRequestToJoinReceived function.
 */
EOS_STRUCT(EOS_CustomInvites_RequestToJoinReceivedCallbackInfo, (
	/** Context that was passed into EOS_CustomInvites_AddNotifyRequestToJoinReceived */
	void* ClientData;
	/** User that sent this response */
	EOS_ProductUserId FromUserId;
	/** Recipient Local user id */
	EOS_ProductUserId ToUserId;
));

/**
 * Function prototype definition for notifications that comes from EOS_CustomInvites_AddNotifyRequestToJoinReceived
 *
 * @param Data A EOS_CustomInvites_RequestToJoinReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnRequestToJoinReceivedCallback, const EOS_CustomInvites_RequestToJoinReceivedCallbackInfo* Data);

/** The most recent version of the EOS_CustomInvites_AcceptRequestToJoin API. */
#define EOS_CUSTOMINVITES_ACCEPTREQUESTTOJOIN_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AcceptRequestToJoinOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ACCEPTREQUESTTOJOIN_API_LATEST. */
	int32_t ApiVersion;
	/** Local user accepting a request to join */
	EOS_ProductUserId LocalUserId;
	/** Target user that sent original request to join */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_CustomInvites_AcceptRequestToJoin Function. These parameters are received through the callback provided to EOS_CustomInvites_AcceptRequestToJoin
 */
EOS_STRUCT(EOS_CustomInvites_AcceptRequestToJoinCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_CustomInvites_AcceptRequestToJoin */
	void* ClientData;
	/** Local user accepting an invite request */
	EOS_ProductUserId LocalUserId;
	/** Target user that sent original invite request */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_CustomInvites_AcceptRequestToJoin
 * @param Data A EOS_CustomInvites_AcceptRequestToJoinCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnAcceptRequestToJoinCallback, const EOS_CustomInvites_AcceptRequestToJoinCallbackInfo* Data);

/** The most recent version of the EOS_CustomInvites_RejectRequestToJoin API. */
#define EOS_CUSTOMINVITES_REJECTREQUESTTOJOIN_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_RejectRequestToJoinOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_REJECTREQUESTTOJOIN_API_LATEST. */
	int32_t ApiVersion;
	/** Local user declining an invite request */
	EOS_ProductUserId LocalUserId;
	/** Target user that sent original invite request */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_CustomInvites_RejectRequestToJoin Function. These parameters are received through the callback provided to EOS_CustomInvites_RejectRequestToJoin
 */
EOS_STRUCT(EOS_CustomInvites_RejectRequestToJoinCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_CustomInvites_RejectRequestToJoin */
	void* ClientData;
	/** Local user declining a request to join */
	EOS_ProductUserId LocalUserId;
	/** Target user that sent original request to join */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_CustomInvites_RejectRequestToJoin
 * @param Data A EOS_CustomInvites_OnRejectRequestToJoinCallback containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnRejectRequestToJoinCallback, const EOS_CustomInvites_RejectRequestToJoinCallbackInfo* Data);

/** The most recent version of the EOS_CustomInvites_AddNotifySendCustomNativeInviteRequested API. */
#define EOS_CUSTOMINVITES_ADDNOTIFYSENDCUSTOMNATIVEINVITEREQUESTED_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AddNotifySendCustomNativeInviteRequestedOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYSENDCUSTOMNATIVEINVITEREQUESTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_CustomInvites_OnSendCustomNativeInviteRequestedCallback Function.
 */
EOS_STRUCT(EOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo, (
	/** Context that was passed into EOS_CustomInvites_AddNotifySendCustomNativeInviteRequested */
	void* ClientData;
	/**
	 * Identifies this event which will need to be acknowledged with EOS_UI_AcknowledgeEventId().
	 * @see EOS_UI_AcknowledgeEventId
	 */
	EOS_UI_EventId UiEventId;
	/** The Product User ID of the local user who is inviting. */
	EOS_ProductUserId LocalUserId;
	/**
	 * The Native Platform Account Type. If only a single integrated platform is configured then
	 * this will always reference that platform.
	 */
	EOS_IntegratedPlatformType TargetNativeAccountType;
	/** The Native Platform Account ID of the target user being invited. */
	const char* TargetUserNativeAccountId;
	/** Invite ID that the user is being invited to */
	const char* InviteId;
));

/**
 * Function prototype definition for notifications that comes from EOS_CustomInvites_AddNotifySendCustomNativeInviteRequested
 *
 * @param Data A EOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo containing the output information and result
 *
 * @note After processing the callback EOS_UI_AcknowledgeEventId must be called.
 *
 * @see EOS_UI_AcknowledgeEventId
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnSendCustomNativeInviteRequestedCallback, const EOS_CustomInvites_SendCustomNativeInviteRequestedCallbackInfo* Data);

/** The most recent version of the EOS_CustomInvites_AddNotifyCustomInviteAccepted API. */
#define EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINACCEPTED_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AddNotifyRequestToJoinAcceptedOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_CustomInvites_OnRequestToJoinAcceptedCallback Function.
 */
EOS_STRUCT(EOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo, (
	/** Context that was passed into EOS_CustomInvites_AddNotifyRequestToJoinAccepted */
	void* ClientData;
	/** User that sent the request to join */
	EOS_ProductUserId TargetUserId;
	/** Local user ID of the Request to Join recipient */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for notifications that comes from EOS_CustomInvites_AddNotifyRequestToJoinAccepted
 *
 * @param Data A EOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnRequestToJoinAcceptedCallback, const EOS_CustomInvites_OnRequestToJoinAcceptedCallbackInfo* Data);

/** The most recent version of the EOS_CustomInvites_AddNotifyRequestToJoinRejected API. */
#define EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINREJECTED_API_LATEST 1

EOS_STRUCT(EOS_CustomInvites_AddNotifyRequestToJoinRejectedOptions, (
	/** API Version: Set this to EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINREJECTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_CustomInvites_OnRequestToJoinRejectedCallback Function.
 */
EOS_STRUCT(EOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo, (
	/** Context that was passed into EOS_CustomInvites_AddNotifyCustomInviteRejected */
	void* ClientData;
	/** User that sent the custom invite */
	EOS_ProductUserId TargetUserId;
	/** Recipient Local user id */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for notifications that comes from EOS_CustomInvites_AddNotifyRequestToJoinRejected
 *
 * @param Data A EOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_CustomInvites_OnRequestToJoinRejectedCallback, const EOS_CustomInvites_OnRequestToJoinRejectedCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_ecom.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_ecom_types.h"

/**
 * The Ecom Interface exposes all catalog, purchasing, and ownership entitlement features available with the Epic Games store
 * All Ecom Interface calls take a handle of type EOS_HEcom as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetEcomInterface function.
 *
 * @note At this time, this feature is only available for products that are part of the Epic Games store.
 *
 * @see EOS_Platform_GetEcomInterface
 */

/**
 * Query the ownership status for a given list of catalog item IDs defined with Epic Online Services.
 * This data will be cached for a limited time and retrieved again from the backend when necessary
 * Depending on the number of catalog item ids passed, the SDK splits the query into smaller batch requests to the backend and aggregates the result.
 * Note: If one of the request batches fails, no data is cached and the entire query is marked as failed.
 *
 * @param Options structure containing the account and catalog item IDs to retrieve
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryOwnership(EOS_HEcom Handle, const EOS_Ecom_QueryOwnershipOptions* Options, void* ClientData, const EOS_Ecom_OnQueryOwnershipCallback CompletionDelegate);

/**
 * Query the ownership status of all catalog item IDs under the given list of Sandbox IDs defined with Epic Online Services.
 * This data will be cached for a limited time and retrieved again from the backend when necessary.
 *
 * @param Options structure containing the account and Sandbox IDs to retrieve.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error.
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryOwnershipBySandboxIds(EOS_HEcom Handle, const EOS_Ecom_QueryOwnershipBySandboxIdsOptions* Options, void* ClientData, const EOS_Ecom_OnQueryOwnershipBySandboxIdsCallback CompletionDelegate);

/**
 * Query the ownership status for a given list of catalog item IDs defined with Epic Online Services.
 * The data is return via the callback in the form of a signed JWT that should be verified by an external backend server using a public key for authenticity.
 *
 * @param Options structure containing the account and catalog item IDs to retrieve in token form
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryOwnershipToken(EOS_HEcom Handle, const EOS_Ecom_QueryOwnershipTokenOptions* Options, void* ClientData, const EOS_Ecom_OnQueryOwnershipTokenCallback CompletionDelegate);

/**
 * Query the entitlement information defined with Epic Online Services.
 * A set of entitlement names can be provided to filter the set of entitlements associated with the account.
 * This data will be cached for a limited time and retrieved again from the backend when necessary.
 * Depending on the number of entitlements passed, the SDK splits the query into smaller batch requests to the backend and aggregates the result.
 * Note: If one of the request batches fails, no data is cached and the entire query is marked as failed.
 * Use EOS_Ecom_CopyEntitlementByIndex, EOS_Ecom_CopyEntitlementByNameAndIndex, and EOS_Ecom_CopyEntitlementById to get the entitlement details.
 * Use EOS_Ecom_GetEntitlementsByNameCount to retrieve the number of entitlements with a specific entitlement name.
 *
 * @param Options structure containing the account and entitlement names to retrieve
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryEntitlements(EOS_HEcom Handle, const EOS_Ecom_QueryEntitlementsOptions* Options, void* ClientData, const EOS_Ecom_OnQueryEntitlementsCallback CompletionDelegate);

/**
 * Query the entitlement verification status defined with Epic Online Services.
 * An optional set of entitlement names can be provided to filter the set of entitlements associated with the account.
 * The data is return via the callback in the form of a signed JWT that should be verified by an external backend server using a public key for authenticity.
 *
 * @param Options structure containing the account and catalog item IDs to retrieve in token form
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryEntitlementToken(EOS_HEcom Handle, const EOS_Ecom_QueryEntitlementTokenOptions* Options, void* ClientData, const EOS_Ecom_OnQueryEntitlementTokenCallback CompletionDelegate);

/**
 * Query for a list of catalog offers defined with Epic Online Services.
 * This data will be cached for a limited time and retrieved again from the backend when necessary.
 *
 * @param Options structure containing filter criteria
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_QueryOffers(EOS_HEcom Handle, const EOS_Ecom_QueryOffersOptions* Options, void* ClientData, const EOS_Ecom_OnQueryOffersCallback CompletionDelegate);

/**
 * Initiates the purchase flow for a set of offers.  The callback is triggered after the purchase flow.
 * On success, the set of entitlements that were unlocked will be cached.
 * On success, a Transaction ID will be returned. The Transaction ID can be used to obtain an
 * EOS_Ecom_HTransaction handle. The handle can then be used to retrieve the entitlements rewarded by the purchase.
 *
 * @see EOS_Ecom_Transaction_Release
 *
 * @param Options structure containing filter criteria
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_Checkout(EOS_HEcom Handle, const EOS_Ecom_CheckoutOptions* Options, void* ClientData, const EOS_Ecom_OnCheckoutCallback CompletionDelegate);

/**
 * Requests that the provided entitlement be marked redeemed.  This will cause that entitlement
 * to no longer be returned from QueryEntitlements unless the include redeemed request flag is set true.
 *
 * @param Options structure containing entitlement to redeem
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_RedeemEntitlements(EOS_HEcom Handle, const EOS_Ecom_RedeemEntitlementsOptions* Options, void* ClientData, const EOS_Ecom_OnRedeemEntitlementsCallback CompletionDelegate);

/**
 * Fetch the number of entitlements that were redeemed during the last EOS_Ecom_RedeemEntitlements call.
 *
 * @param Options structure containing the Epic Account ID
 *
 * @see EOS_Ecom_CopyLastRedeemedEntitlementByIndex
 *
 * @return the number of the redeemed entitlements.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetLastRedeemedEntitlementsCount(EOS_HEcom Handle, const EOS_Ecom_GetLastRedeemedEntitlementsCountOptions* Options);

/**
 * Fetches a redeemed entitlement id from a given index.
 * Only entitlements that were redeemed during the last EOS_Ecom_RedeemEntitlements call can be copied.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 * @param OutRedeemedEntitlementId The ID of the redeemed entitlement. Must be long enough to hold a string of EOS_ECOM_ENTITLEMENTID_MAX_LENGTH.
 * @param InOutRedeemedEntitlementIdLength The size of the OutRedeemedEntitlementId in characters.
 *										   The input buffer should include enough space to be null-terminated.
 *										   When the function returns, this parameter will be filled with the length of the string copied into OutRedeemedEntitlementId.
 *
 * @return EOS_Success if the information is available and passed out in OutRedeemedEntitlementId
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement id is not found
 *
 * @see EOS_ECOM_ENTITLEMENTID_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyLastRedeemedEntitlementByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions* Options, char* OutRedeemedEntitlementId, int32_t* InOutRedeemedEntitlementIdLength);

/**
 * Fetch the number of entitlements that are cached for a given local user.
 *
 * @param Options structure containing the Epic Account ID being accessed
 *
 * @see EOS_Ecom_CopyEntitlementByIndex
 *
 * @return the number of entitlements found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetEntitlementsCount(EOS_HEcom Handle, const EOS_Ecom_GetEntitlementsCountOptions* Options);

/**
 * Fetch the number of entitlements with the given Entitlement Name that are cached for a given local user.
 *
 * @param Options structure containing the Epic Account ID and name being accessed
 *
 * @see EOS_Ecom_CopyEntitlementByNameAndIndex
 *
 * @return the number of entitlements found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetEntitlementsByNameCount(EOS_HEcom Handle, const EOS_Ecom_GetEntitlementsByNameCountOptions* Options);

/**
 * Fetches an entitlement from a given index.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 * @param OutEntitlement the entitlement for the given index, if it exists and is valid, use EOS_Ecom_Entitlement_Release when finished
 *
 * @see EOS_Ecom_Entitlement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutEntitlement
 *         EOS_Ecom_EntitlementStale if the entitlement information is stale and passed out in OutEntitlement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyEntitlementByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyEntitlementByIndexOptions* Options, EOS_Ecom_Entitlement ** OutEntitlement);

/**
 * Fetches a single entitlement with a given Entitlement Name.  The Index is used to access individual
 * entitlements among those with the same Entitlement Name.  The Index can be a value from 0 to
 * one less than the result from EOS_Ecom_GetEntitlementsByNameCount.
 *
 * @param Options structure containing the Epic Account ID, entitlement name, and index being accessed
 * @param OutEntitlement the entitlement for the given name index pair, if it exists and is valid, use EOS_Ecom_Entitlement_Release when finished
 *
 * @see EOS_Ecom_Entitlement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutEntitlement
 *         EOS_Ecom_EntitlementStale if the entitlement information is stale and passed out in OutEntitlement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyEntitlementByNameAndIndex(EOS_HEcom Handle, const EOS_Ecom_CopyEntitlementByNameAndIndexOptions* Options, EOS_Ecom_Entitlement ** OutEntitlement);

/**
 * Fetches the entitlement with the given ID.
 *
 * @param Options structure containing the Epic Account ID and entitlement ID being accessed
 * @param OutEntitlement the entitlement for the given ID, if it exists and is valid, use EOS_Ecom_Entitlement_Release when finished
 *
 * @see EOS_Ecom_CopyEntitlementByNameAndIndex
 * @see EOS_Ecom_Entitlement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutEntitlement
 *         EOS_Ecom_EntitlementStale if the entitlement information is stale and passed out in OutEntitlement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyEntitlementById(EOS_HEcom Handle, const EOS_Ecom_CopyEntitlementByIdOptions* Options, EOS_Ecom_Entitlement ** OutEntitlement);

/**
 * Fetch the number of offers that are cached for a given local user.
 *
 * @param Options structure containing the Epic Account ID being accessed
 *
 * @see EOS_Ecom_CopyOfferByIndex
 *
 * @return the number of offers found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetOfferCount(EOS_HEcom Handle, const EOS_Ecom_GetOfferCountOptions* Options);

/**
 * Fetches an offer from a given index.  The pricing and text are localized to the provided account.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 * @param OutOffer the offer for the given index, if it exists and is valid, use EOS_Ecom_CatalogOffer_Release when finished
 *
 * @see EOS_Ecom_CatalogOffer_Release
 * @see EOS_Ecom_GetOfferItemCount
 *
 * @return EOS_Success if the information is available and passed out in OutOffer
 *         EOS_Ecom_CatalogOfferStale if the offer information is stale and passed out in OutOffer
 *         EOS_Ecom_CatalogOfferPriceInvalid if the offer information has an invalid price and passed out in OutOffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the offer is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyOfferByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyOfferByIndexOptions* Options, EOS_Ecom_CatalogOffer ** OutOffer);

/**
 * Fetches an offer with a given ID.  The pricing and text are localized to the provided account.
 *
 * @param Options structure containing the Epic Account ID and offer ID being accessed
 * @param OutOffer the offer for the given index, if it exists and is valid, use EOS_Ecom_CatalogOffer_Release when finished
 *
 * @see EOS_Ecom_CatalogOffer_Release
 * @see EOS_Ecom_GetOfferItemCount
 *
 * @return EOS_Success if the information is available and passed out in OutOffer
 *         EOS_Ecom_CatalogOfferStale if the offer information is stale and passed out in OutOffer
 *         EOS_Ecom_CatalogOfferPriceInvalid if the offer information has an invalid price and passed out in OutOffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the offer is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyOfferById(EOS_HEcom Handle, const EOS_Ecom_CopyOfferByIdOptions* Options, EOS_Ecom_CatalogOffer ** OutOffer);

/**
 * Fetch the number of items that are associated with a given cached offer for a local user.
 *
 * @return the number of items found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetOfferItemCount(EOS_HEcom Handle, const EOS_Ecom_GetOfferItemCountOptions* Options);

/**
 * Fetches an item from a given index.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 * @param OutItem the item for the given index, if it exists and is valid, use EOS_Ecom_CatalogItem_Release when finished
 *
 * @see EOS_Ecom_CatalogItem_Release
 * @see EOS_Ecom_GetItemImageInfoCount
 * @see EOS_Ecom_GetItemReleaseCount
 *
 * @return EOS_Success if the information is available and passed out in OutItem
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_Ecom_CatalogItemStale if the item information is stale
 *         EOS_NotFound if the item is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyOfferItemByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyOfferItemByIndexOptions* Options, EOS_Ecom_CatalogItem ** OutItem);

/**
 * Fetches an item with a given ID.
 *
 * @param Options structure containing the item ID being accessed
 * @param OutItem the item for the given index, if it exists and is valid, use EOS_Ecom_CatalogItem_Release when finished
 *
 * @see EOS_Ecom_CatalogItem_Release
 * @see EOS_Ecom_GetItemImageInfoCount
 * @see EOS_Ecom_GetItemReleaseCount
 *
 * @return EOS_Success if the information is available and passed out in OutItem
 *         EOS_Ecom_CatalogItemStale if the item information is stale and passed out in OutItem
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the offer is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyItemById(EOS_HEcom Handle, const EOS_Ecom_CopyItemByIdOptions* Options, EOS_Ecom_CatalogItem ** OutItem);

/**
 * Fetch the number of images that are associated with a given cached offer for a local user.
 *
 * @return the number of images found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetOfferImageInfoCount(EOS_HEcom Handle, const EOS_Ecom_GetOfferImageInfoCountOptions* Options);

/**
 * Fetches an image from a given index.
 *
 * @param Options structure containing the offer ID and index being accessed
 * @param OutImageInfo the image for the given index, if it exists and is valid, use EOS_Ecom_KeyImageInfo_Release when finished
 *
 * @see EOS_Ecom_KeyImageInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutImageInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_Ecom_CatalogOfferStale if the associated offer information is stale
 *         EOS_NotFound if the image is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyOfferImageInfoByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyOfferImageInfoByIndexOptions* Options, EOS_Ecom_KeyImageInfo ** OutImageInfo);

/**
 * Fetch the number of images that are associated with a given cached item for a local user.
 *
 * @return the number of images found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetItemImageInfoCount(EOS_HEcom Handle, const EOS_Ecom_GetItemImageInfoCountOptions* Options);

/**
 * Fetches an image from a given index.
 *
 * @param Options structure containing the item ID and index being accessed
 * @param OutImageInfo the image for the given index, if it exists and is valid, use EOS_Ecom_KeyImageInfo_Release when finished
 *
 * @see EOS_Ecom_KeyImageInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutImageInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_Ecom_CatalogItemStale if the associated item information is stale
 *         EOS_NotFound if the image is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyItemImageInfoByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyItemImageInfoByIndexOptions* Options, EOS_Ecom_KeyImageInfo ** OutImageInfo);

/**
 * Fetch the number of releases that are associated with a given cached item for a local user.
 *
 * @return the number of releases found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetItemReleaseCount(EOS_HEcom Handle, const EOS_Ecom_GetItemReleaseCountOptions* Options);

/**
 * Fetches a release from a given index.
 *
 * @param Options structure containing the item ID and index being accessed
 * @param OutRelease the release for the given index, if it exists and is valid, use EOS_Ecom_CatalogRelease_Release when finished
 *
 * @see EOS_Ecom_CatalogRelease_Release
 *
 * @return EOS_Success if the information is available and passed out in OutRelease
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_Ecom_CatalogItemStale if the associated item information is stale
 *         EOS_NotFound if the release is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyItemReleaseByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyItemReleaseByIndexOptions* Options, EOS_Ecom_CatalogRelease ** OutRelease);

/**
 * Fetch the number of transactions that are cached for a given local user.
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_CopyTransactionByIndex
 *
 * @return the number of transactions found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_GetTransactionCount(EOS_HEcom Handle, const EOS_Ecom_GetTransactionCountOptions* Options);

/**
 * Fetches the transaction handle at the given index.
 *
 * @param Options structure containing the Epic Account ID and index being accessed
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_Transaction_Release
 *
 * @return EOS_Success if the information is available and passed out in OutTransaction
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the transaction is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyTransactionByIndex(EOS_HEcom Handle, const EOS_Ecom_CopyTransactionByIndexOptions* Options, EOS_Ecom_HTransaction* OutTransaction);

/**
 * Fetches the transaction handle at the given index.
 *
 * @param Options structure containing the Epic Account ID and transaction ID being accessed
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_Transaction_Release
 *
 * @return EOS_Success if the information is available and passed out in OutTransaction
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the transaction is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_CopyTransactionById(EOS_HEcom Handle, const EOS_Ecom_CopyTransactionByIdOptions* Options, EOS_Ecom_HTransaction* OutTransaction);

/**
 * The Ecom Transaction Interface exposes getters for accessing information about a completed transaction.
 * All Ecom Transaction Interface calls take a handle of type EOS_Ecom_HTransaction as the first parameter.
 * An EOS_Ecom_HTransaction handle is originally returned as part of the EOS_Ecom_CheckoutCallbackInfo struct.
 * An EOS_Ecom_HTransaction handle can also be retrieved from an EOS_HEcom handle using EOS_Ecom_CopyTransactionByIndex.
 * It is expected that after a transaction that EOS_Ecom_Transaction_Release is called.
 * When EOS_Platform_Release is called any remaining transactions will also be released.
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_GetTransactionCount
 * @see EOS_Ecom_CopyTransactionByIndex
 */

EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_Transaction_GetTransactionId(EOS_Ecom_HTransaction Handle, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Fetch the number of entitlements that are part of this transaction.
 *
 * @param Options structure containing the Epic Account ID being accessed
 *
 * @see EOS_Ecom_Transaction_CopyEntitlementByIndex
 *
 * @return the number of entitlements found.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Ecom_Transaction_GetEntitlementsCount(EOS_Ecom_HTransaction Handle, const EOS_Ecom_Transaction_GetEntitlementsCountOptions* Options);

/**
 * Fetches an entitlement from a given index.
 *
 * @param Options structure containing the index being accessed
 * @param OutEntitlement the entitlement for the given index, if it exists and is valid, use EOS_Ecom_Entitlement_Release when finished
 *
 * @see EOS_Ecom_Entitlement_Release
 *
 * @return EOS_Success if the information is available and passed out in OutEntitlement
 *         EOS_Ecom_EntitlementStale if the entitlement information is stale and passed out in OutEntitlement
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the entitlement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Ecom_Transaction_CopyEntitlementByIndex(EOS_Ecom_HTransaction Handle, const EOS_Ecom_Transaction_CopyEntitlementByIndexOptions* Options, EOS_Ecom_Entitlement ** OutEntitlement);

```

`EAC_SDK/SDK/include/eos_ecom_types.h`:

```h
 // Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_EcomHandle* EOS_HEcom;

/**
 * This handle is copied when EOS_Ecom_CopyTransactionById or EOS_Ecom_CopyTransactionByIndex is called.
 * A EOS_Ecom_CheckoutCallbackInfo provides the ID for the copy.
 * After being copied, EOS_Ecom_Transaction_Release must be called.
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_CopyTransactionById
 * @see EOS_Ecom_CopyTransactionByIndex
 * @see EOS_Ecom_Transaction_Release
 */
EXTERN_C typedef struct EOS_Ecom_TransactionHandle* EOS_Ecom_HTransaction;

/**
 * A unique identifier for a catalog item defined and stored with the backend catalog service.
 * A catalog item represents a distinct object within the catalog.  When acquired by an account, an
 * entitlement is granted that references a specific catalog item.
 */
EXTERN_C typedef const char* EOS_Ecom_CatalogItemId;

/**
 * A unique identifier for a catalog offer defined and stored with the backend catalog service.
 * A catalog offer is a purchasable collection of 1 or more items, associated with a price (which
 * could be 0).  When an offer is purchased an entitlement is granted for each of the items
 * referenced by the offer.
 */
EXTERN_C typedef const char* EOS_Ecom_CatalogOfferId;

/**
 * An identifier which is defined on a catalog item and stored with the backend catalog service.
 * The entitlement name may not be unique.  A catalog may be configured with multiple items with the
 * same entitlement name in order to define a logical grouping of entitlements.  This is used to
 * retrieve all entitlements granted to an account grouped in this way.
 *
 * @see EOS_Ecom_QueryEntitlements
 */
EXTERN_C typedef const char* EOS_Ecom_EntitlementName;

/**
 * A unique identifier for an entitlement owned by an account.  An entitlement is always associated
 * with a single account.  The entitlement ID is provided to allow redeeming the entitlement as
 * well as identify individual entitlement grants.
 *
 * @see EOS_Ecom_QueryEntitlements
 * @see EOS_Ecom_RedeemEntitlements
 */
EXTERN_C typedef const char* EOS_Ecom_EntitlementId;

/**
 * A unique identifier for the Sandbox.
 * 
 * @see EOS_Ecom_QueryOwnershipBySandboxIds
 */
EXTERN_C typedef const char* EOS_Ecom_SandboxId;

/**
 * An enumeration of the different ownership statuses.
 */
EOS_ENUM(EOS_EOwnershipStatus,
	/** The catalog item is not owned by the local user */
	EOS_OS_NotOwned = 0,
	/** The catalog item is owned by the local user */
	EOS_OS_Owned = 1
);

/**
 * An enumeration defining the type of catalog item.  The primary use is to identify how the item is expended.
 */
EOS_ENUM(EOS_EEcomItemType,
	/** This entitlement is intended to persist. */
	EOS_EIT_Durable = 0,
	/**
	 * This entitlement is intended to be transient and redeemed.
	 *
	 * @see EOS_Ecom_RedeemEntitlements
	 */
	EOS_EIT_Consumable = 1,
	/** This entitlement has a type that is not currently intended for an in-game store. */
	EOS_EIT_Other = 2
);

/** The most recent version of the EOS_Ecom_Entitlement struct. */
#define EOS_ECOM_ENTITLEMENT_API_LATEST 2

/** Timestamp value representing an undefined EndTimestamp for EOS_Ecom_Entitlement */
#define EOS_ECOM_ENTITLEMENT_ENDTIMESTAMP_UNDEFINED -1

/**
 * Contains information about a single entitlement associated with an account. Instances of this structure are
 * created by EOS_Ecom_CopyEntitlementByIndex, EOS_Ecom_CopyEntitlementByNameAndIndex, or EOS_Ecom_CopyEntitlementById.
 * They must be passed to EOS_Ecom_Entitlement_Release.
 */
EOS_STRUCT(EOS_Ecom_Entitlement, (
	/** API Version: Set this to EOS_ECOM_ENTITLEMENT_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the entitlement */
	EOS_Ecom_EntitlementName EntitlementName;
	/** ID of the entitlement owned by an account */
	EOS_Ecom_EntitlementId EntitlementId;
	/** ID of the item associated with the offer which granted this entitlement */
	EOS_Ecom_CatalogItemId CatalogItemId;
	/**
	 * If queried using pagination then ServerIndex represents the index of the entitlement as it
	 * exists on the server.  If not queried using pagination then ServerIndex will be -1.
	 */
	int32_t ServerIndex;
	/** If true then the catalog has this entitlement marked as redeemed */
	EOS_Bool bRedeemed;
	/** If not -1 then this is a POSIX timestamp that this entitlement will end */
	int64_t EndTimestamp;
));

/**
 * Release the memory associated with an EOS_Ecom_Entitlement structure. This must be called on data
 * retrieved from EOS_Ecom_CopyEntitlementByIndex and EOS_Ecom_CopyEntitlementById.
 *
 * @param Entitlement - The entitlement structure to be released
 *
 * @see EOS_Ecom_Entitlement
 * @see EOS_Ecom_CopyEntitlementByIndex
 * @see EOS_Ecom_CopyEntitlementById
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_Entitlement_Release(EOS_Ecom_Entitlement* Entitlement);

/** The most recent version of the EOS_Ecom_ItemOwnership struct. */
#define EOS_ECOM_ITEMOWNERSHIP_API_LATEST 1

/**
 * Contains information about a single item ownership associated with an account. This structure is
 * returned as part of the EOS_Ecom_QueryOwnershipCallbackInfo structure.
 */
EOS_STRUCT(EOS_Ecom_ItemOwnership, (
	/** API Version: Set this to EOS_ECOM_ITEMOWNERSHIP_API_LATEST. */
	int32_t ApiVersion;
	/** ID of the catalog item */
	EOS_Ecom_CatalogItemId Id;
	/** Is this catalog item owned by the local user */
	EOS_EOwnershipStatus OwnershipStatus;
));

/** The most recent version of the EOS_Ecom_CatalogItem struct. */
#define EOS_ECOM_CATALOGITEM_API_LATEST 1

/** Timestamp value representing an undefined EntitlementEndTimestamp for EOS_Ecom_CatalogItem */
#define EOS_ECOM_CATALOGITEM_ENTITLEMENTENDTIMESTAMP_UNDEFINED -1

/**
 * Contains information about a single item within the catalog. Instances of this structure are created
 * by EOS_Ecom_CopyOfferItemByIndex. They must be passed to EOS_Ecom_CatalogItem_Release.
 */
EOS_STRUCT(EOS_Ecom_CatalogItem, (
	/** API Version: Set this to EOS_ECOM_CATALOGITEM_API_LATEST. */
	int32_t ApiVersion;
	/** Product namespace in which this item exists */
	const char* CatalogNamespace;
	/** The ID of this item */
	EOS_Ecom_CatalogItemId Id;
	/** The entitlement name associated with this item */
	EOS_Ecom_EntitlementName EntitlementName;
	/** Localized UTF-8 title of this item */
	const char* TitleText;
	/** Localized UTF-8 description of this item */
	const char* DescriptionText;
	/** Localized UTF-8 long description of this item */
	const char* LongDescriptionText;
	/** Localized UTF-8 technical details of this item */
	const char* TechnicalDetailsText;
	/** Localized UTF-8 developer of this item */
	const char* DeveloperText;
	/** The type of item as defined in the catalog */
	EOS_EEcomItemType ItemType;
	/** If not -1 then this is the POSIX timestamp that the entitlement will end */
	int64_t EntitlementEndTimestamp;
));

/**
 * Release the memory associated with an EOS_Ecom_CatalogItem structure. This must be called on data
 * retrieved from EOS_Ecom_CopyOfferItemByIndex.
 *
 * @param CatalogItem - The catalog item structure to be released
 *
 * @see EOS_Ecom_CatalogItem
 * @see EOS_Ecom_CopyOfferItemByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_CatalogItem_Release(EOS_Ecom_CatalogItem* CatalogItem);

/** The most recent version of the EOS_Ecom_CatalogOffer struct. */
#define EOS_ECOM_CATALOGOFFER_API_LATEST 5

/** Timestamp value representing an undefined ExpirationTimestamp for EOS_Ecom_CatalogOffer */
#define EOS_ECOM_CATALOGOFFER_EXPIRATIONTIMESTAMP_UNDEFINED -1
/** Timestamp value representing an undefined ReleaseDateTimestamp for EOS_Ecom_CatalogOffer */
#define EOS_ECOM_CATALOGOFFER_RELEASEDATETIMESTAMP_UNDEFINED -1
/** Timestamp value representing an undefined EffectiveDateTimestamp for EOS_Ecom_CatalogOffer */
#define EOS_ECOM_CATALOGOFFER_EFFECTIVEDATETIMESTAMP_UNDEFINED -1

/**
 * Contains information about a single offer within the catalog. Instances of this structure are
 * created by EOS_Ecom_CopyOfferByIndex. They must be passed to EOS_Ecom_CatalogOffer_Release.
 * Prices are stored in the lowest denomination for the associated currency.  If CurrencyCode is
 * "USD" then a price of 299 represents "$2.99".
 */
EOS_STRUCT(EOS_Ecom_CatalogOffer, (
	/** API Version: Set this to EOS_ECOM_CATALOGOFFER_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The index of this offer as it exists on the server.
	 * This is useful for understanding pagination data.
	 */
	int32_t ServerIndex;
	/** Product namespace in which this offer exists */
	const char* CatalogNamespace;
	/** The ID of this offer */
	EOS_Ecom_CatalogOfferId Id;
	/** Localized UTF-8 title of this offer */
	const char* TitleText;
	/** Localized UTF-8 description of this offer */
	const char* DescriptionText;
	/** Localized UTF-8 long description of this offer */
	const char* LongDescriptionText;
	/**
	 * Deprecated.
	 * EOS_Ecom_CatalogItem::TechnicalDetailsText is still valid.
	 */
	const char* TechnicalDetailsText_DEPRECATED;
	/** The Currency Code for this offer */
	const char* CurrencyCode;
	/**
	 * If this value is EOS_Success then OriginalPrice, CurrentPrice, and DiscountPercentage contain valid data.
	 * Otherwise this value represents the error that occurred on the price query.
	 */
	EOS_EResult PriceResult;
	/** The original price of this offer as a 32-bit number is deprecated. */
	uint32_t OriginalPrice_DEPRECATED;
	/** The current price including discounts of this offer as a 32-bit number is deprecated.. */
	uint32_t CurrentPrice_DEPRECATED;
	/** A value from 0 to 100 define the percentage of the OrignalPrice that the CurrentPrice represents */
	uint8_t DiscountPercentage;
	/** Contains the POSIX timestamp that the offer expires or -1 if it does not expire */
	int64_t ExpirationTimestamp;
	/**
	 * The number of times that the requesting account has purchased this offer.
	 * This value is deprecated and the backend no longer returns this value.
	 */
	uint32_t PurchasedCount_DEPRECATED;
	/**
	 * The maximum number of times that the offer can be purchased.
	 * A negative value implies there is no limit.
	 */
	int32_t PurchaseLimit;
	/** True if the user can purchase this offer. */
	EOS_Bool bAvailableForPurchase;
	/** The original price of this offer as a 64-bit number. */
	uint64_t OriginalPrice64;
	/** The current price including discounts of this offer as a 64-bit number. */
	uint64_t CurrentPrice64;
	/** The decimal point for the provided price.  For example, DecimalPoint '2' and CurrentPrice64 '12345' would be '123.45'. */
	uint32_t DecimalPoint;
	/** Timestamp indicating when the time when the offer was released. Can be ignored if set to -1. */
	int64_t ReleaseDateTimestamp;
	/** Timestamp indicating the effective date of the offer. Can be ignored if set to -1. */
	int64_t EffectiveDateTimestamp;
));

/**
 * Release the memory associated with an EOS_Ecom_CatalogOffer structure. This must be called on data
 * retrieved from EOS_Ecom_CopyOfferByIndex.
 *
 * @param CatalogOffer - The catalog offer structure to be released
 *
 * @see EOS_Ecom_CatalogOffer
 * @see EOS_Ecom_CopyOfferByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_CatalogOffer_Release(EOS_Ecom_CatalogOffer* CatalogOffer);

/** The most recent version of the EOS_Ecom_KeyImageInfo struct. */
#define EOS_ECOM_KEYIMAGEINFO_API_LATEST 1

/**
 * Contains information about a key image used by the catalog.  Instances of this structure are
 * created by EOS_Ecom_CopyItemImageInfoByIndex.  They must be passed to EOS_Ecom_KeyImageInfo_Release.
 * A Key Image is defined within Dev Portal and is associated with a Catalog Item.  A Key Image is
 * intended to be used to provide imagery for an in-game store.
 *
 * @see EOS_Ecom_CopyItemImageInfoByIndex
 * @see EOS_Ecom_KeyImageInfo_Release
 */
EOS_STRUCT(EOS_Ecom_KeyImageInfo, (
	/** API Version: Set this to EOS_ECOM_KEYIMAGEINFO_API_LATEST. */
	int32_t ApiVersion;
	/** Describes the usage of the image (ex: home_thumbnail) */
	const char* Type;
	/** The URL of the image */
	const char* Url;
	/** The expected width in pixels of the image */
	uint32_t Width;
	/** The expected height in pixels of the image */
	uint32_t Height;
));

/**
 * Release the memory associated with an EOS_Ecom_KeyImageInfo structure. This must be called on data
 * retrieved from EOS_Ecom_CopyItemImageInfoByIndex.
 *
 * @param KeyImageInfo - The key image info structure to be released
 *
 * @see EOS_Ecom_KeyImageInfo
 * @see EOS_Ecom_CopyItemImageInfoByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_KeyImageInfo_Release(EOS_Ecom_KeyImageInfo* KeyImageInfo);

/** The most recent version of the EOS_Ecom_CatalogRelease struct. */
#define EOS_ECOM_CATALOGRELEASE_API_LATEST 1

/**
 * Contains information about a single release within the catalog. Instances of this structure are
 * created by EOS_Ecom_CopyItemReleaseByIndex. They must be passed to EOS_Ecom_CatalogRelease_Release.
 */
EOS_STRUCT(EOS_Ecom_CatalogRelease, (
	/** API Version: Set this to EOS_ECOM_CATALOGRELEASE_API_LATEST. */
	int32_t ApiVersion;
	/** The number of APP IDs */
	uint32_t CompatibleAppIdCount;
	/** A list of compatible APP IDs */
	const char** CompatibleAppIds;
	/** The number of platforms */
	uint32_t CompatiblePlatformCount;
	/** A list of compatible Platforms */
	const char** CompatiblePlatforms;
	/** Release note for compatible versions */
	const char* ReleaseNote;
));

/**
 * Release the memory associated with an EOS_Ecom_CatalogRelease structure. This must be called on
 * data retrieved from EOS_Ecom_CopyItemReleaseByIndex.
 *
 * @param CatalogRelease - The catalog release structure to be released
 *
 * @see EOS_Ecom_CatalogRelease
 * @see EOS_Ecom_CopyItemReleaseByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_CatalogRelease_Release(EOS_Ecom_CatalogRelease* CatalogRelease);

/** The most recent version of the EOS_Ecom_CheckoutEntry struct. */
#define EOS_ECOM_CHECKOUTENTRY_API_LATEST 1

/**
 * Contains information about a request to purchase a single offer.  This structure is set as part
 * of the EOS_Ecom_CheckoutOptions structure.
 */
EOS_STRUCT(EOS_Ecom_CheckoutEntry, (
	/** API Version: Set this to EOS_ECOM_CHECKOUTENTRY_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the offer to purchase */
	EOS_Ecom_CatalogOfferId OfferId;
));

/** The most recent version of the EOS_Ecom_QueryOwnership API. */
#define EOS_ECOM_QUERYOWNERSHIP_API_LATEST 2

/**
 * The maximum number of catalog items that may be queried in a single pass
 */
#define EOS_ECOM_QUERYOWNERSHIP_MAX_CATALOG_IDS 400

/**
 * Input parameters for the EOS_Ecom_QueryOwnership function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYOWNERSHIP_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose ownership to query */
	EOS_EpicAccountId LocalUserId;
	/** The array of Catalog Item IDs to check for ownership */
	EOS_Ecom_CatalogItemId* CatalogItemIds;
	/** The number of Catalog Item IDs to in the array */
	uint32_t CatalogItemIdCount;
	/** Optional product namespace, if not the one specified during initialization */
	const char* CatalogNamespace;
));

/**
 * Output parameters for the EOS_Ecom_QueryOwnership Function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryOwnership */
	void* ClientData;
	/** The Epic Account ID of the local user whose ownership was queried */
	EOS_EpicAccountId LocalUserId;
	/** List of catalog items and their ownership status */
	const EOS_Ecom_ItemOwnership* ItemOwnership;
	/** Number of ownership results are included in this callback */
	uint32_t ItemOwnershipCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOwnership
 * @param Data A EOS_Ecom_QueryOwnershipCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryOwnershipCallback, const EOS_Ecom_QueryOwnershipCallbackInfo* Data);

/** The most recent version of the EOS_Ecom_QueryOwnershipBySandboxIds API. */
#define EOS_ECOM_QUERYOWNERSHIPBYSANDBOXIDSOPTIONS_API_LATEST 1

/**
 * The maximum number of Sandbox Ids that may be queried in a single pass.
 */
#define EOS_ECOM_QUERYOWNERSHIP_MAX_SANDBOX_IDS 10

 /**
  * Input parameters for the EOS_Ecom_QueryOwnershipBySandboxIds function.
  */
EOS_STRUCT(EOS_Ecom_QueryOwnershipBySandboxIdsOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYOWNERSHIPBYSANDBOXIDSOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose ownership to query. */
	EOS_EpicAccountId LocalUserId;
	/** The array of Sandbox IDs to check for ownership. */
	EOS_Ecom_SandboxId* SandboxIds;
	/** The number of Sandbox IDs in the query. */
	uint32_t SandboxIdsCount;
));

/**
 * Contains all owned catalog items for a sandbox ID. This structure is
 * returned as part of the EOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo structure.
 * Note: The SandboxID and CatalogItemId strings will not remain valid after EOS_Ecom_OnQueryOwnershipBySandboxIdsCallback, so a copy should be as needed.
 */
EOS_STRUCT(EOS_Ecom_SandboxIdItemOwnership, (
	/** SandboxId */
	EOS_Ecom_SandboxId SandboxId;
	/** List of all owned catalog items for this SandboxId */
	const EOS_Ecom_CatalogItemId* OwnedCatalogItemIds;
	/** Number of owned catalog items for this SandboxId */
	uint32_t OwnedCatalogItemIdsCount;
));

/**
 * Output parameters for the EOS_Ecom_QueryOwnershipBySandboxIds Function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryOwnership */
	void* ClientData;
	/** The Epic Account ID of the local user whose ownership was queried */
	EOS_EpicAccountId LocalUserId;
	/** List of SandboxIds and their corresponding owned catalog item Ids. If there are no ownership items, the OwnedCatalogItemIdsCount is 0 and OwnedCatalogItemIds is null. */
	const EOS_Ecom_SandboxIdItemOwnership* SandboxIdItemOwnerships;
	/** Number of ownership results are included in this callback */
	uint32_t SandboxIdItemOwnershipsCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOwnershipBySandboxIds
 * @param Data A EOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryOwnershipBySandboxIdsCallback, const EOS_Ecom_QueryOwnershipBySandboxIdsCallbackInfo* Data);

/** The most recent version of the EOS_Ecom_QueryOwnershipToken API. */
#define EOS_ECOM_QUERYOWNERSHIPTOKEN_API_LATEST 2

/**
 * The maximum number of catalog items that may be queried in a single pass
 */
#define EOS_ECOM_QUERYOWNERSHIPTOKEN_MAX_CATALOGITEM_IDS 32

/**
 * Input parameters for the EOS_Ecom_QueryOwnershipToken function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipTokenOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYOWNERSHIPTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose ownership token you want to query */
	EOS_EpicAccountId LocalUserId;
	/** The array of Catalog Item IDs to check for ownership, matching in number to the CatalogItemIdCount */
	EOS_Ecom_CatalogItemId* CatalogItemIds;
	/** The number of catalog item IDs to query */
	uint32_t CatalogItemIdCount;
	/** Optional product namespace, if not the one specified during initialization */
	const char* CatalogNamespace;
));

/**
 * Output parameters for the EOS_Ecom_QueryOwnershipToken Function.
 */
EOS_STRUCT(EOS_Ecom_QueryOwnershipTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryOwnershipToken */
	void* ClientData;
	/** The Epic Account ID of the local user whose ownership token was queried */
	EOS_EpicAccountId LocalUserId;
	/** Ownership token containing details about the catalog items queried */
	const char* OwnershipToken;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOwnershipToken
 * @param Data A EOS_Ecom_QueryOwnershipTokenCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryOwnershipTokenCallback, const EOS_Ecom_QueryOwnershipTokenCallbackInfo* Data);

/** The most recent version of the EOS_Ecom_QueryEntitlements API. */
#define EOS_ECOM_QUERYENTITLEMENTS_API_LATEST 2

/**
 * The maximum number of entitlements that may be queried in a single QueryEntitlements API call.
 */
#define EOS_ECOM_QUERYENTITLEMENTS_MAX_ENTITLEMENT_IDS 256

/**
 * Input parameters for the EOS_Ecom_QueryEntitlements function.
 */
EOS_STRUCT(EOS_Ecom_QueryEntitlementsOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYENTITLEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose Entitlements you want to retrieve */
	EOS_EpicAccountId LocalUserId;
	/** An array of Entitlement Names that you want to check */
	EOS_Ecom_EntitlementName* EntitlementNames;
	/** The number of Entitlement Names included in the array, up to EOS_ECOM_QUERYENTITLEMENTS_MAX_ENTITLEMENT_IDS; use zero to request all Entitlements associated with the user's Epic Online Services account. */
	uint32_t EntitlementNameCount;
	/** If true, Entitlements that have been redeemed will be included in the results. */
	EOS_Bool bIncludeRedeemed;
));

/**
 * Output parameters for the EOS_Ecom_QueryEntitlements Function.
 */
EOS_STRUCT(EOS_Ecom_QueryEntitlementsCallbackInfo, (
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryEntitlements */
	void* ClientData;
	/** The Epic Account ID of the local user whose entitlement was queried */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOwnershipToken
 * @param Data A EOS_Ecom_QueryEntitlementsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryEntitlementsCallback, const EOS_Ecom_QueryEntitlementsCallbackInfo* Data);

/** The most recent version of the EOS_Ecom_QueryEntitlementToken API. */
#define EOS_ECOM_QUERYENTITLEMENTTOKEN_API_LATEST 1

/** The maximum number of entitlements that may be queried in a single pass. */
#define EOS_ECOM_QUERYENTITLEMENTTOKEN_MAX_ENTITLEMENT_IDS 32

 /**
  * Input parameters for the EOS_Ecom_QueryEntitlementToken function.
  */
EOS_STRUCT(EOS_Ecom_QueryEntitlementTokenOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYENTITLEMENTTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose Entitlements you want to retrieve */
	EOS_EpicAccountId LocalUserId;
	/** An array of Entitlement Names that you want to check */
	EOS_Ecom_EntitlementName* EntitlementNames;
	/** The number of Entitlement Names included in the array, up to EOS_ECOM_QUERYENTITLEMENTTOKEN_MAX_ENTITLEMENT_IDS; use zero to request all Entitlements associated with the user's Epic Online Services account. */
	uint32_t EntitlementNameCount;
));

/**
 * Output parameters for the EOS_Ecom_QueryEntitlementToken Function.
 */
EOS_STRUCT(EOS_Ecom_QueryEntitlementTokenCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryEntitlementToken */
	void* ClientData;
	/** The Epic Account ID of the local user whose entitlement was queried */
	EOS_EpicAccountId LocalUserId;
	/** Entitlements token containing details about the catalog items queried */
	const char* EntitlementToken;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryEntitlementToken.
 * @param Data A EOS_Ecom_QueryEntitlementTokenCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryEntitlementTokenCallback, const EOS_Ecom_QueryEntitlementTokenCallbackInfo* Data);

/** The most recent version of the EOS_Ecom_QueryOffers API. */
#define EOS_ECOM_QUERYOFFERS_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_QueryOffers function.
 */
EOS_STRUCT(EOS_Ecom_QueryOffersOptions, (
	/** API Version: Set this to EOS_ECOM_QUERYOFFERS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer to query */
	EOS_EpicAccountId LocalUserId;
	/** If not provided then the SandboxId is used as the catalog namespace */
	const char* OverrideCatalogNamespace;
));

/**
 * Output parameters for the EOS_Ecom_QueryOffers Function.
 */
EOS_STRUCT(EOS_Ecom_QueryOffersCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_QueryOffers */
	void* ClientData;
	/** The Epic Account ID of the local user whose offer was queried; needed for localization of Catalog Item (Item) description text and pricing information */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_QueryOffers
 * @param Data A EOS_Ecom_QueryOffersCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnQueryOffersCallback, const EOS_Ecom_QueryOffersCallbackInfo* Data);


/** The most recent version of the EOS_Ecom_Checkout API. */
#define EOS_ECOM_CHECKOUT_API_LATEST 1

/** The maximum number of entries in a single checkout. */
#define EOS_ECOM_CHECKOUT_MAX_ENTRIES 10

/** The maximum length of a transaction ID. */
#define EOS_ECOM_TRANSACTIONID_MAXIMUM_LENGTH 64
/**
 * Input parameters for the EOS_Ecom_Checkout function.
 */
EOS_STRUCT(EOS_Ecom_CheckoutOptions, (
	/** API Version: Set this to EOS_ECOM_CHECKOUT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who is making the purchase */
	EOS_EpicAccountId LocalUserId;
	/** The catalog namespace will be the current Sandbox ID (in EOS_Platform_Options) unless overridden by this field */
	const char* OverrideCatalogNamespace;
	/** The number of EOS_Ecom_CheckoutEntry elements contained in Entries */
	uint32_t EntryCount;
	/** An array of EOS_Ecom_CheckoutEntry elements, each containing the details of a single offer */
	const EOS_Ecom_CheckoutEntry* Entries;
));

/**
 * Output parameters for the EOS_Ecom_Checkout Function.
 */
EOS_STRUCT(EOS_Ecom_CheckoutCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_Checkout */
	void* ClientData;
	/** The Epic Account ID of the user who initiated the purchase */
	EOS_EpicAccountId LocalUserId;
	/** The transaction ID which can be used to obtain an EOS_Ecom_HTransaction using EOS_Ecom_CopyTransactionById. */
	const char* TransactionId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_Checkout
 * @param Data A EOS_Ecom_CheckoutCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnCheckoutCallback, const EOS_Ecom_CheckoutCallbackInfo* Data);


/** The most recent version of the EOS_Ecom_RedeemEntitlements API. */
#define EOS_ECOM_REDEEMENTITLEMENTS_API_LATEST 2

/**
 * The maximum number of entitlement IDs that may be redeemed in a single pass
 */
#define EOS_ECOM_REDEEMENTITLEMENTS_MAX_IDS 32

/**
* The maximum length of an entitlement ID
*/
#define EOS_ECOM_ENTITLEMENTID_MAX_LENGTH 32

/**
 * Input parameters for the EOS_Ecom_RedeemEntitlements function.
 */
EOS_STRUCT(EOS_Ecom_RedeemEntitlementsOptions, (
	/** API Version: Set this to EOS_ECOM_REDEEMENTITLEMENTS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user who is redeeming Entitlements */
	EOS_EpicAccountId LocalUserId;
	/** The number of Entitlements to redeem */
	uint32_t EntitlementIdCount;
	/** The array of Entitlements to redeem */
	EOS_Ecom_EntitlementId* EntitlementIds;
));

/**
 * Output parameters for the EOS_Ecom_RedeemEntitlements Function.
 */
EOS_STRUCT(EOS_Ecom_RedeemEntitlementsCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Ecom_RedeemEntitlements */
	void* ClientData;
	/** The Epic Account ID of the user who has redeemed entitlements */
	EOS_EpicAccountId LocalUserId;
	/* The number of redeemed Entitlements */
	uint32_t RedeemedEntitlementIdsCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_Ecom_RedeemEntitlements
 * @param Data A EOS_Ecom_RedeemEntitlementsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Ecom_OnRedeemEntitlementsCallback, const EOS_Ecom_RedeemEntitlementsCallbackInfo* Data);

/** The most recent version of the EOS_Ecom_GetLastRedeemedEntitlementsCount API. */
#define EOS_ECOM_GETLASTREDEEMEDENTITLEMENTSCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetLastRedeemedEntitlementsCount function.
 */
EOS_STRUCT(EOS_Ecom_GetLastRedeemedEntitlementsCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETLASTREDEEMEDENTITLEMENTSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user for who to retrieve the last redeemed entitlements count */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_Ecom_CopyLastRedeemedEntitlementByIndex API. */
#define EOS_ECOM_COPYLASTREDEEMEDENTITLEMENTBYINDEX_API_LATEST 1

 /**
  * Input parameters for the EOS_Ecom_CopyLastRedeemedEntitlementByIndex function.
  */
EOS_STRUCT(EOS_Ecom_CopyLastRedeemedEntitlementByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYLASTREDEEMEDENTITLEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose last redeemed entitlement id is being copied */
	EOS_EpicAccountId LocalUserId;
	/** Index of the last redeemed entitlement id to retrieve from the cache */
	uint32_t RedeemedEntitlementIndex;
));

/** The most recent version of the EOS_Ecom_GetEntitlementsCount API. */
#define EOS_ECOM_GETENTITLEMENTSCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetEntitlementsCount function.
 */
EOS_STRUCT(EOS_Ecom_GetEntitlementsCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETENTITLEMENTSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user for which to retrieve the entitlement count */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_Ecom_GetEntitlementsByNameCount API. */
#define EOS_ECOM_GETENTITLEMENTSBYNAMECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetEntitlementsByNameCount function.
 */
EOS_STRUCT(EOS_Ecom_GetEntitlementsByNameCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETENTITLEMENTSBYNAMECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user for which to retrieve the entitlement count */
	EOS_EpicAccountId LocalUserId;
	/** Name of the entitlement to count in the cache */
	EOS_Ecom_EntitlementName EntitlementName;
));

/** The most recent version of the EOS_Ecom_CopyEntitlementByIndex API. */
#define EOS_ECOM_COPYENTITLEMENTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyEntitlementByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyEntitlementByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose entitlement is being copied */
	EOS_EpicAccountId LocalUserId;
	/** Index of the entitlement to retrieve from the cache */
	uint32_t EntitlementIndex;
));

/** The most recent version of the EOS_Ecom_CopyEntitlementByNameAndIndex API. */
#define EOS_ECOM_COPYENTITLEMENTBYNAMEANDINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyEntitlementByNameAndIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyEntitlementByNameAndIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYNAMEANDINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose entitlement is being copied */
	EOS_EpicAccountId LocalUserId;
	/** Name of the entitlement to retrieve from the cache */
	EOS_Ecom_EntitlementName EntitlementName;
	/** Index of the entitlement within the named set to retrieve from the cache. */
	uint32_t Index;
));

/** The most recent version of the EOS_Ecom_CopyEntitlementById API. */
#define EOS_ECOM_COPYENTITLEMENTBYID_API_LATEST 2

/**
 * Input parameters for the EOS_Ecom_CopyEntitlementById function.
 */
EOS_STRUCT(EOS_Ecom_CopyEntitlementByIdOptions, (
	/** API Version: Set this to EOS_ECOM_COPYENTITLEMENTBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose entitlement is being copied */
	EOS_EpicAccountId LocalUserId;
	/** ID of the entitlement to retrieve from the cache */
	EOS_Ecom_EntitlementId EntitlementId;
));

/** The most recent version of the EOS_Ecom_GetOfferCount API. */
#define EOS_ECOM_GETOFFERCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetOfferCount function.
 */
EOS_STRUCT(EOS_Ecom_GetOfferCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETOFFERCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offers are being accessed */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_Ecom_CopyOfferByIndex API. */
#define EOS_ECOM_COPYOFFERBYINDEX_API_LATEST 3

/**
 * Input parameters for the EOS_Ecom_CopyOfferByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyOfferByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYOFFERBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The index of the offer to get. */
	uint32_t OfferIndex;
));

/** The most recent version of the EOS_Ecom_CopyOfferById API. */
#define EOS_ECOM_COPYOFFERBYID_API_LATEST 3

/**
 * Input parameters for the EOS_Ecom_CopyOfferById function.
 */
EOS_STRUCT(EOS_Ecom_CopyOfferByIdOptions, (
	/** API Version: Set this to EOS_ECOM_COPYOFFERBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the offer to get. */
	EOS_Ecom_CatalogOfferId OfferId;
));

/** The most recent version of the EOS_Ecom_GetOfferItemCount API. */
#define EOS_ECOM_GETOFFERITEMCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetOfferItemCount function.
 */
EOS_STRUCT(EOS_Ecom_GetOfferItemCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETOFFERITEMCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who made the initial request for the Catalog Offer through EOS_Ecom_QueryOffers */
	EOS_EpicAccountId LocalUserId;
	/** An ID that corresponds to a cached Catalog Offer (retrieved by EOS_Ecom_CopyOfferByIndex) */
	EOS_Ecom_CatalogOfferId OfferId;
));

/** The most recent version of the EOS_Ecom_CopyOfferItemByIndex API. */
#define EOS_ECOM_COPYOFFERITEMBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyOfferItemByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyOfferItemByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYOFFERITEMBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the offer to get the items for. */
	EOS_Ecom_CatalogOfferId OfferId;
	/** The index of the item to get. */
	uint32_t ItemIndex;
));

/** The most recent version of the EOS_Ecom_CopyItemById API. */
#define EOS_ECOM_COPYITEMBYID_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyItemById function.
 */
EOS_STRUCT(EOS_Ecom_CopyItemByIdOptions, (
	/** API Version: Set this to EOS_ECOM_COPYITEMBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get. */
	EOS_Ecom_CatalogItemId ItemId;
));

/** The most recent version of the EOS_Ecom_GetOfferImageInfoCount API. */
#define EOS_ECOM_GETOFFERIMAGEINFOCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetOfferImageInfoCount function.
 */
EOS_STRUCT(EOS_Ecom_GetOfferImageInfoCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETOFFERIMAGEINFOCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer image is being accessed. */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the offer to get the images for. */
	EOS_Ecom_CatalogOfferId OfferId;
));

/** The most recent version of the EOS_Ecom_CopyOfferImageInfoByIndex API. */
#define EOS_ECOM_COPYOFFERIMAGEINFOBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyOfferImageInfoByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyOfferImageInfoByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYOFFERIMAGEINFOBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose offer image is being copied. */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the offer to get the images for. */
	EOS_Ecom_CatalogOfferId OfferId;
	/** The index of the image to get. */
	uint32_t ImageInfoIndex;
));

/** The most recent version of the EOS_Ecom_GetItemImageInfoCount API. */
#define EOS_ECOM_GETITEMIMAGEINFOCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetItemImageInfoCount function.
 */
EOS_STRUCT(EOS_Ecom_GetItemImageInfoCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETITEMIMAGEINFOCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item image is being accessed */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get the images for. */
	EOS_Ecom_CatalogItemId ItemId;
));

/** The most recent version of the EOS_Ecom_CopyItemImageInfoByIndex API. */
#define EOS_ECOM_COPYITEMIMAGEINFOBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyItemImageInfoByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyItemImageInfoByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYITEMIMAGEINFOBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item image is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get the images for. */
	EOS_Ecom_CatalogItemId ItemId;
	/** The index of the image to get. */
	uint32_t ImageInfoIndex;
));

/** The most recent version of the EOS_Ecom_GetItemReleaseCount API. */
#define EOS_ECOM_GETITEMRELEASECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetItemReleaseCount function.
 */
EOS_STRUCT(EOS_Ecom_GetItemReleaseCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETITEMRELEASECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item release is being accessed */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get the releases for. */
	EOS_Ecom_CatalogItemId ItemId;
));

/** The most recent version of the EOS_Ecom_CopyItemReleaseByIndex API. */
#define EOS_ECOM_COPYITEMRELEASEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyItemReleaseByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyItemReleaseByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYITEMRELEASEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose item release is being copied */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the item to get the releases for. */
	EOS_Ecom_CatalogItemId ItemId;
	/** The index of the release to get. */
	uint32_t ReleaseIndex;
));

/** The most recent version of the EOS_Ecom_GetTransactionCount Function. */
#define EOS_ECOM_GETTRANSACTIONCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_GetTransactionCount function.
 */
EOS_STRUCT(EOS_Ecom_GetTransactionCountOptions, (
	/** API Version: Set this to EOS_ECOM_GETTRANSACTIONCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user whose transaction count to get */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_Ecom_CopyTransactionByIndex Function. */
#define EOS_ECOM_COPYTRANSACTIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_CopyTransactionByIndex function.
 */
EOS_STRUCT(EOS_Ecom_CopyTransactionByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_COPYTRANSACTIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who is associated with the transaction */
	EOS_EpicAccountId LocalUserId;
	/** The index of the transaction to get */
	uint32_t TransactionIndex;
));

/** The most recent version of the EOS_Ecom_CopyTransactionById Function. */
#define EOS_ECOM_COPYTRANSACTIONBYID_API_LATEST 1
/**
 * Input parameters for the EOS_Ecom_CopyTransactionById function.
 */
EOS_STRUCT(EOS_Ecom_CopyTransactionByIdOptions, (
	/** API Version: Set this to EOS_ECOM_COPYTRANSACTIONBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local user who is associated with the transaction */
	EOS_EpicAccountId LocalUserId;
	/** The ID of the transaction to get */
	const char* TransactionId;
));

/** The most recent version of the EOS_Ecom_Transaction_GetEntitlementsCount Function. */
#define EOS_ECOM_TRANSACTION_GETENTITLEMENTSCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_Transaction_GetEntitlementsCount function.
 */
EOS_STRUCT(EOS_Ecom_Transaction_GetEntitlementsCountOptions, (
	/** API Version: Set this to EOS_ECOM_TRANSACTION_GETENTITLEMENTSCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Ecom_Transaction_CopyEntitlementByIndex Function. */
#define EOS_ECOM_TRANSACTION_COPYENTITLEMENTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Ecom_Transaction_CopyEntitlementByIndex function.
 */
EOS_STRUCT(EOS_Ecom_Transaction_CopyEntitlementByIndexOptions, (
	/** API Version: Set this to EOS_ECOM_TRANSACTION_COPYENTITLEMENTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The index of the entitlement to get */
	uint32_t EntitlementIndex;
));

/**
 * Release the memory associated with an EOS_Ecom_HTransaction.  Is expected to be called after
 * being received from a EOS_Ecom_CheckoutCallbackInfo.
 *
 * @param Transaction A handle to a transaction.
 *
 * @see EOS_Ecom_CheckoutCallbackInfo
 * @see EOS_Ecom_GetTransactionCount
 * @see EOS_Ecom_CopyTransactionByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Ecom_Transaction_Release(EOS_Ecom_HTransaction Transaction);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_friends.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_friends_types.h"

/**
 * The Friends Interface is used to manage a user's friends list, by interacting with the backend services, and to retrieve the cached list of friends, blocked users and pending invitations.
 * All Friends Interface calls take a handle of type EOS_HFriends as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetFriendsInterface function.
 *
 * @see EOS_Platform_GetFriendsInterface
 */

/**
 * Starts an asynchronous task that reads the user's friends list and blocklist from the backend service, caching it for future use.
 *
 * @note When the Social Overlay is enabled then this will be called automatically.  The Social Overlay is enabled by default (see EOS_PF_DISABLE_SOCIAL_OVERLAY).
 *
 * @param Options structure containing the account for which to retrieve the friends list
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Friends_QueryFriends(EOS_HFriends Handle, const EOS_Friends_QueryFriendsOptions* Options, void* ClientData, const EOS_Friends_OnQueryFriendsCallback CompletionDelegate);

/**
 * Starts an asynchronous task that sends a friend invitation to another user. The completion delegate is executed after the backend response has been received.
 * It does not indicate that the target user has responded to the friend invitation.
 *
 * @param Options structure containing the account to send the invite from and the account to send the invite to
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Friends_SendInvite(EOS_HFriends Handle, const EOS_Friends_SendInviteOptions* Options, void* ClientData, const EOS_Friends_OnSendInviteCallback CompletionDelegate);

/**
 * Starts an asynchronous task that accepts a friend invitation from another user. The completion delegate is executed after the backend response has been received.
 *
 * @param Options structure containing the logged in account and the inviting account
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Friends_AcceptInvite(EOS_HFriends Handle, const EOS_Friends_AcceptInviteOptions* Options, void* ClientData, const EOS_Friends_OnAcceptInviteCallback CompletionDelegate);

/**
 * Starts an asynchronous task that rejects a friend invitation from another user. The completion delegate is executed after the backend response has been received.
 *
 * @param Options structure containing the logged in account and the inviting account
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_Friends_RejectInvite(EOS_HFriends Handle, const EOS_Friends_RejectInviteOptions* Options, void* ClientData, const EOS_Friends_OnRejectInviteCallback CompletionDelegate);

/**
 * Retrieves the number of friends on the friends list that has already been retrieved by the EOS_Friends_QueryFriends API.
 *
 * @param Options structure containing the Epic Account ID of user who owns the friends list
 * @return the number of friends on the list
 *
 * @see EOS_Friends_GetFriendAtIndex
 */
EOS_DECLARE_FUNC(int32_t) EOS_Friends_GetFriendsCount(EOS_HFriends Handle, const EOS_Friends_GetFriendsCountOptions* Options);

/**
 * Retrieves the Epic Account ID of an entry from the friends list that has already been retrieved by the EOS_Friends_QueryFriends API.
 * The Epic Account ID returned by this function may belong to an account that has been invited to be a friend or that has invited the local user to be a friend.
 * To determine if the Epic Account ID returned by this function is a friend or a pending friend invitation, use the EOS_Friends_GetStatus function.
 *
 * @param Options structure containing the Epic Account ID of the owner of the friends list and the index into the list
 * @return the Epic Account ID of the friend. Note that if the index provided is out of bounds, the returned Epic Account ID will be a "null" account ID.
 *
 * @see EOS_Friends_GetFriendsCount
 * @see EOS_Friends_GetStatus
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_Friends_GetFriendAtIndex(EOS_HFriends Handle, const EOS_Friends_GetFriendAtIndexOptions* Options);

/**
 * Retrieve the friendship status between the local user and another user.
 *
 * @param Options structure containing the Epic Account ID of the friend list to check and the account of the user to test friendship status
 * @return A value indicating whether the two accounts have a friendship, pending invites in either direction, or no relationship
 *         EOS_FS_Friends is returned for two users that have confirmed friendship
 *         EOS_FS_InviteSent is returned when the local user has sent a friend invitation but the other user has not accepted or rejected it
 *         EOS_FS_InviteReceived is returned when the other user has sent a friend invitation to the local user
 *         EOS_FS_NotFriends is returned when there is no known relationship
 *
 * @see EOS_EFriendsStatus
 */
EOS_DECLARE_FUNC(EOS_EFriendsStatus) EOS_Friends_GetStatus(EOS_HFriends Handle, const EOS_Friends_GetStatusOptions* Options);

/**
 * Listen for changes to friends for a particular account.
 *
 * @param Options Information about who would like notifications.
 * @param ClientData This value is returned to the caller when FriendsUpdateHandler is invoked.
 * @param FriendsUpdateHandler The callback to be invoked when a change to any friend status changes.
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Friends_AddNotifyFriendsUpdate(EOS_HFriends Handle, const EOS_Friends_AddNotifyFriendsUpdateOptions* Options, void* ClientData, const EOS_Friends_OnFriendsUpdateCallback FriendsUpdateHandler);

/**
 * Stop listening for friends changes on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID.
 */
EOS_DECLARE_FUNC(void) EOS_Friends_RemoveNotifyFriendsUpdate(EOS_HFriends Handle, EOS_NotificationId NotificationId);

/**
 * Retrieves the number of blocked users on the blocklist that has already been retrieved by the EOS_Friends_QueryFriends API.
 *
 * @param Options structure containing the Epic Account ID of user who owns the blocklist.
 * @return the number of users on the blocklist.
 *
 * @see EOS_Friends_QueryFriends
 */
EOS_DECLARE_FUNC(int32_t) EOS_Friends_GetBlockedUsersCount(EOS_HFriends Handle, const EOS_Friends_GetBlockedUsersCountOptions* Options);

/**
 * Retrieves the Epic Account ID of an entry from the blocklist that has already been retrieved by the EOS_Friends_QueryFriends API.
 *
 * @param Options structure containing the Epic Account ID of the owner of the blocklist and the index into the list.
 * @return the Epic Account ID of the blocked user. Note that if the index provided is out of bounds, the returned Epic Account ID will be a "null" account ID.
 *
 * @see EOS_Friends_QueryFriends
 * @see EOS_Friends_GetBlockedUsersCount
 */
EOS_DECLARE_FUNC(EOS_EpicAccountId) EOS_Friends_GetBlockedUserAtIndex(EOS_HFriends Handle, const EOS_Friends_GetBlockedUserAtIndexOptions* Options);

/**
 * Listen for changes to blocklist for a particular account.
 *
 * @param Options Information about the API version which is being used.
 * @param ClientData This value is returned to the caller when BlockedUsersUpdateHandler is invoked.
 * @param BlockedUsersUpdateHandler The callback to be invoked when a blocklist changes.
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise.
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Friends_AddNotifyBlockedUsersUpdate(EOS_HFriends Handle, const EOS_Friends_AddNotifyBlockedUsersUpdateOptions* Options, void* ClientData, const EOS_Friends_OnBlockedUsersUpdateCallback BlockedUsersUpdateHandler);

/**
 * Stop listening for blocklist changes on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID.
 */
EOS_DECLARE_FUNC(void) EOS_Friends_RemoveNotifyBlockedUsersUpdate(EOS_HFriends Handle, EOS_NotificationId NotificationId);

```

`EAC_SDK/SDK/include/eos_friends_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_FriendsHandle* EOS_HFriends;

/**
 * EOS_Friends_QueryFriends is used to start an asynchronous query to retrieve friends, blocked users and pending outbound/inbound friends list invitations for a user account.
 * The following types are used to work with the API.
 */


/** The most recent version of the EOS_Friends_QueryFriends API. */
#define EOS_FRIENDS_QUERYFRIENDS_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_QueryFriends function.
 */
EOS_STRUCT(EOS_Friends_QueryFriendsOptions, (
	/** API Version: Set this to EOS_FRIENDS_QUERYFRIENDS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user whose friends list you want to retrieve */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_Friends_QueryFriends Function. These parameters are received through the callback provided to EOS_Friends_QueryFriends
 */
EOS_STRUCT(EOS_Friends_QueryFriendsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Friends_QueryFriends */
	void* ClientData;
	/** The Epic Account ID of the user whose friends were queried */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_QueryFriends
 * @param Data A EOS_Friends_QueryFriendsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnQueryFriendsCallback, const EOS_Friends_QueryFriendsCallbackInfo* Data);



/**
 * EOS_Friends_SendInvite is used to start an asynchronous operation to send a friends list invitation from a local user to a target user.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_SendInvite API. */
#define EOS_FRIENDS_SENDINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_SendInvite function.
 */
EOS_STRUCT(EOS_Friends_SendInviteOptions, (
	/** API Version: Set this to EOS_FRIENDS_SENDINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user who is sending the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who is receiving the friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_Friends_SendInvite API.
 */
EOS_STRUCT(EOS_Friends_SendInviteCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the invitation was sent, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Friends_SendInvite */
	void* ClientData;
	/** The Epic Account ID of the user who sent the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user to whom the friends list invitation was sent */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_SendInvite
 * @param Data A EOS_Friends_SendInviteCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnSendInviteCallback, const EOS_Friends_SendInviteCallbackInfo* Data);



/**
 * EOS_Friends_AcceptInvite is used to start an asynchronous operation to accept a friends list invitation from another user.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_AcceptInvite API. */
#define EOS_FRIENDS_ACCEPTINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_AcceptInvite function.
 */
EOS_STRUCT(EOS_Friends_AcceptInviteOptions, (
	/** API Version: Set this to EOS_FRIENDS_ACCEPTINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user who is accepting the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_Friends_AcceptInvite Function.
 */
EOS_STRUCT(EOS_Friends_AcceptInviteCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if an invite was accepted, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that is passed into EOS_Friends_AcceptInvite */
	void* ClientData;
	/** The Epic Account ID of the user who is accepting the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the local user a friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_AcceptInvite
 * @param Data A EOS_Friends_AcceptInviteCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnAcceptInviteCallback, const EOS_Friends_AcceptInviteCallbackInfo* Data);



/**
 * EOS_Friends_RejectInvite is used to start an asynchronous operation to reject a friends list invitation from another user.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_RejectInvite API. */
#define EOS_FRIENDS_REJECTINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_RejectInvite function.
 */
EOS_STRUCT(EOS_Friends_RejectInviteOptions, (
	/** API Version: Set this to EOS_FRIENDS_REJECTINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user who is rejecting a friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_Friends_RejectInvite Function.
 */
EOS_STRUCT(EOS_Friends_RejectInviteCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if an invite was accepted, otherwise one of the error codes is returned. See eos_common.h */
	EOS_EResult ResultCode;
	/** Context that is passed into EOS_Friends_RejectInvite */
	void* ClientData;
	/** The Epic Account ID of the user who is rejecting the friends list invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the friends list invitation */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Friends_RejectInvite
 * @param Data A EOS_Friends_RejectInviteCallbackInfo containing output information and the result.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnRejectInviteCallback, const EOS_Friends_RejectInviteCallbackInfo* Data);



/**
 * EOS_Friends_GetFriendsCount is used to immediately retrieve the number of cached friendships.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_GetFriendsCount API. */
#define EOS_FRIENDS_GETFRIENDSCOUNT_API_LATEST 1


/**
 * Input parameters for the EOS_Friends_GetFriendsCount function.
 */
EOS_STRUCT(EOS_Friends_GetFriendsCountOptions, (
	/** API Version: Set this to EOS_FRIENDS_GETFRIENDSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose friends should be counted */
	EOS_EpicAccountId LocalUserId;
));


/**
 * EOS_Friends_GetFriendAtIndex is used to immediately retrieve the account ID of another user who has a friendship (or pending friendship).
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_GetFriendAtIndex API. */
#define EOS_FRIENDS_GETFRIENDATINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_GetFriendAtIndex function.
 */
EOS_STRUCT(EOS_Friends_GetFriendAtIndexOptions, (
	/** API Version: Set this to EOS_FRIENDS_GETFRIENDATINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose friend list is being queried */
	EOS_EpicAccountId LocalUserId;
	/** Index into the friend list. This value must be between 0 and EOS_Friends_GetFriendsCount-1 inclusively. */
	int32_t Index;
));



/**
 * EOS_Friends_GetStatus is used to immediately retrieve the friendship status between two users.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_GetStatus API. */
#define EOS_FRIENDS_GETSTATUS_API_LATEST 1

/**
 * An enumeration of the different friendship statuses.
 */
EOS_ENUM(EOS_EFriendsStatus,
	/** The two accounts have no friendship status. */
	EOS_FS_NotFriends = 0,

	/** 
	 * The local account has sent a friend invite to the other account.
	 *
	 * NOTE: EOS_FS_InviteSent is not returned by EOS_Friends_GetStatus or in EOS_Friends_AddNotifyFriendsUpdate callbacks unless
	 *       the local account was logged in with the EOS_AS_FriendsManagement authentication scope. Friend invites are managed
	 *       automatically by the Social Overlay.
	 */
	EOS_FS_InviteSent = 1,

	/** 
	 * The other account has sent a friend invite to the local account.
	 *
	 * NOTE: EOS_FS_InviteReceived is not returned by EOS_Friends_GetStatus or in EOS_Friends_AddNotifyFriendsUpdate callbacks unless
	 *       the local account was logged in with the EOS_AS_FriendsManagement authentication scope. Friend invites are managed
	 *       automatically by the Social Overlay.
	 */
	EOS_FS_InviteReceived = 2,

	/** The accounts have accepted friendship. */
	EOS_FS_Friends = 3
);

/**
 * Input parameters for the EOS_Friends_GetStatus function.
 */
EOS_STRUCT(EOS_Friends_GetStatusOptions, (
	/** API Version: Set this to EOS_FRIENDS_GETSTATUS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged in user */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose friendship status with the local user is being queried */
	EOS_EpicAccountId TargetUserId;
));



/**
 * EOS_Friends_AddNotifyFriendsUpdate is used to setup notification to receive any friend status updates.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_AddNotifyFriendsUpdate API. */
#define EOS_FRIENDS_ADDNOTIFYFRIENDSUPDATE_API_LATEST 1

/** Input parameters for the EOS_Friends_AddNotifyFriendsUpdate function. */
EOS_STRUCT(EOS_Friends_AddNotifyFriendsUpdateOptions, (
	/** API Version: Set this to EOS_FRIENDS_ADDNOTIFYFRIENDSUPDATE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Structure containing information about a friend status update.
 */
EOS_STRUCT(EOS_Friends_OnFriendsUpdateInfo, (
	/** Client-specified data passed into EOS_Friends_AddNotifyFriendsUpdate */
	void* ClientData;
	/** The Epic Account ID of the local user who is receiving the update */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose status is being updated. */
	EOS_EpicAccountId TargetUserId;
	/** The previous status of the user. */
	EOS_EFriendsStatus PreviousStatus;
	/** The current status of the user. */
	EOS_EFriendsStatus CurrentStatus;
));

/**
 * Callback for information related to a friend status update.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnFriendsUpdateCallback, const EOS_Friends_OnFriendsUpdateInfo* Data);

/**
 * EOS_Friends_GetBlockedUsersCount is used to immediately retrieve the number of cached blocked users.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_GetBlockedUsersCount API. */
#define EOS_FRIENDS_GETBLOCKEDUSERSCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_GetBlockedUsersCount function.
 */
EOS_STRUCT(EOS_Friends_GetBlockedUsersCountOptions, (
	/** API Version: Set this to EOS_FRIENDS_GETBLOCKEDUSERSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose blocked users should be counted. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * EOS_Friends_GetBlockedUserAtIndex is used to immediately retrieve the account ID of user who is blocked.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_Friends_GetBlockedUserAtIndex API. */
#define EOS_FRIENDS_GETBLOCKEDUSERATINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Friends_GetBlockedUserAtIndex function.
 */
EOS_STRUCT(EOS_Friends_GetBlockedUserAtIndexOptions, (
	/** API Version: Set this to EOS_FRIENDS_GETBLOCKEDUSERATINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose blocked users list is being queried. */
	EOS_EpicAccountId LocalUserId;
	/** Index into the blocked users list. This value must be between 0 and EOS_Friends_GetBlockedUsersCount-1 inclusively. */
	int32_t Index;
));

/** The most recent version of the EOS_Friends_AddNotifyBlockedUsersUpdate API. */
#define EOS_FRIENDS_ADDNOTIFYBLOCKEDUSERSUPDATE_API_LATEST 1

/** Input parameters for the EOS_Friends_AddNotifyBlockedUsersUpdate function. */
EOS_STRUCT(EOS_Friends_AddNotifyBlockedUsersUpdateOptions, (
	/** API Version: Set this to EOS_FRIENDS_ADDNOTIFYBLOCKEDUSERSUPDATE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Structure containing information about a blocklist update.
 */
EOS_STRUCT(EOS_Friends_OnBlockedUsersUpdateInfo, (
	/** Client-specified data passed into EOS_Friends_AddNotifyBlockedUsersUpdate */
	void* ClientData;
	/** The Epic Account ID of the local user who is receiving the update */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose blocked status is being updated. */
	EOS_EpicAccountId TargetUserId;
	/** TargetUserId block status (blocked or not). */
	EOS_Bool bBlocked;
));

/**
 * Callback for information related to a blocklist update.
 */
EOS_DECLARE_CALLBACK(EOS_Friends_OnBlockedUsersUpdateCallback, const EOS_Friends_OnBlockedUsersUpdateInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_init.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_types.h"

#pragma pack(push, 8)

/**
 * Function prototype type definition for functions that allocate memory.
 *
 * Functions passed to EOS_Initialize to serve as memory allocators should return a pointer to the allocated memory.
 *
 * The returned pointer should have at least SizeInBytes available capacity and the memory address should be a multiple of Alignment.
 * The SDK will always call the provided function with an Alignment that is a power of 2.
 * Allocation failures should return a null pointer.
 */
EXTERN_C typedef void* (EOS_MEMORY_CALL * EOS_AllocateMemoryFunc)(size_t SizeInBytes, size_t Alignment);

/**
 * Function prototype type definition for functions that reallocate memory.
 *
 * Functions passed to EOS_Initialize to serve as memory reallocators should return a pointer to the reallocated memory.
 * The returned pointer should have at least SizeInBytes available capacity and the memory address should be a multiple of alignment.
 * The SDK will always call the provided function with an Alignment that is a power of 2.
 * Reallocation failures should return a null pointer.
 */
EXTERN_C typedef void* (EOS_MEMORY_CALL * EOS_ReallocateMemoryFunc)(void* Pointer, size_t SizeInBytes, size_t Alignment);

/**
 * Function prototype type definition for functions that release memory.
 *
 * When the SDK is done with memory that has been allocated by a custom allocator passed to EOS_Initialize, it will call the corresponding memory release function.
 */
EXTERN_C typedef void (EOS_MEMORY_CALL * EOS_ReleaseMemoryFunc)(void* Pointer);

/** The most recent version of the EOS_Initialize_ThreadAffinity API. */
#define EOS_INITIALIZE_THREADAFFINITY_API_LATEST 2

/**
 * Options for initializing defining thread affinity for use by Epic Online Services SDK.
 * Set the affinity to 0 to allow EOS SDK to use a platform specific default value.
 */
EOS_STRUCT(EOS_Initialize_ThreadAffinity, (
	/** API Version: Set this to EOS_INITIALIZE_THREADAFFINITY_API_LATEST. */
	int32_t ApiVersion;
	/** Any thread related to network management that is not IO. */
	uint64_t NetworkWork;
	/** Any thread that will interact with a storage device. */
	uint64_t StorageIo;
	/** Any thread that will generate web socket IO. */
	uint64_t WebSocketIo;
	/** Any thread that will generate IO related to P2P traffic and management. */
	uint64_t P2PIo;
	/** Any thread that will generate http request IO. */
	uint64_t HttpRequestIo;
	/** Any thread that will generate IO related to RTC traffic and management. */
	uint64_t RTCIo;
));

/** The most recent version of the EOS_Initialize API. */
#define EOS_INITIALIZE_API_LATEST 4

/** Max length of a product name, not including the terminating null. */
#define EOS_INITIALIZEOPTIONS_PRODUCTNAME_MAX_LENGTH 64

/** Max length of a product version, not including the terminating null. */
#define EOS_INITIALIZEOPTIONS_PRODUCTVERSION_MAX_LENGTH 64

/**
 * Options for initializing the Epic Online Services SDK.
 */
EOS_STRUCT(EOS_InitializeOptions, (
	/** API Version: Set this to EOS_INITIALIZE_API_LATEST. */
	int32_t ApiVersion;
	/** A custom memory allocator, if desired. */
	EOS_AllocateMemoryFunc AllocateMemoryFunction;
	/** A corresponding memory reallocator. If the AllocateMemoryFunction is nulled, then this field must also be nulled. */
	EOS_ReallocateMemoryFunc ReallocateMemoryFunction;
	/** A corresponding memory releaser. If the AllocateMemoryFunction is nulled, then this field must also be nulled. */
	EOS_ReleaseMemoryFunc ReleaseMemoryFunction;
	/**
	 * The name of the product using the Epic Online Services SDK.
	 *
	 * The name string is required to be non-empty and at maximum of EOS_INITIALIZEOPTIONS_PRODUCTNAME_MAX_LENGTH bytes long.
	 * The string buffer can consist of the following characters:
	 * A-Z, a-z, 0-9, dot, underscore, space, exclamation mark, question mark, and sign, hyphen, parenthesis, plus, minus, colon.
	 */
	const char* ProductName;
	/**
	 * Product version of the running application.
	 *
	 * The version string is required to be non-empty and at maximum of EOS_INITIALIZEOPTIONS_PRODUCTVERSION_MAX_LENGTH bytes long.
	 * The string buffer can consist of the following characters:
	 * A-Z, a-z, 0-9, dot, underscore, space, exclamation mark, question mark, and sign, hyphen, parenthesis, plus, minus, colon.
	 */
	const char* ProductVersion;
	/** A reserved field that should always be nulled. */
	void* Reserved;
	/**
	 * This field is for system specific initialization if any.
	 *
	 * If provided then the structure will be located in <System>/eos_<system>.h.
	 * The structure will be named EOS_<System>_InitializeOptions.
	 */
	void* SystemInitializeOptions;
	/** The thread affinity override values for each category of thread. */
	EOS_Initialize_ThreadAffinity* OverrideThreadAffinity;
));

/**
 * Initialize the Epic Online Services SDK.
 *
 * Before calling any other function in the SDK, clients must call this function.
 *
 * This function must only be called one time and must have a corresponding EOS_Shutdown call.
 *
 * @param Options - The initialization options to use for the SDK.
 * @return An EOS_EResult is returned to indicate success or an error.
 *
 * EOS_Success is returned if the SDK successfully initializes.
 * EOS_AlreadyConfigured is returned if the function has already been called.
 * EOS_InvalidParameters is returned if the provided options are invalid.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Initialize(const EOS_InitializeOptions* Options);

/**
 * Tear down the Epic Online Services SDK.
 *
 * Once this function has been called, no more SDK calls are permitted; calling anything after EOS_Shutdown will result in undefined behavior.
 * @return An EOS_EResult is returned to indicate success or an error.
 * EOS_Success is returned if the SDK is successfully torn down.
 * EOS_NotConfigured is returned if a successful call to EOS_Initialize has not been made.
 * EOS_UnexpectedError is returned if EOS_Shutdown has already been called.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Shutdown();

/**
 * Create a single Epic Online Services Platform Instance.
 *
 * The platform instance is used to gain access to the various Epic Online Services.
 *
 * This function returns an opaque handle to the platform instance, and that handle must be passed to EOS_Platform_Release to release the instance.
 *
 * @return An opaque handle to the platform instance.
 */
EOS_DECLARE_FUNC(EOS_HPlatform) EOS_Platform_Create(const EOS_Platform_Options* Options);

/**
 * Release an Epic Online Services platform instance previously returned from EOS_Platform_Create.
 *
 * This function should only be called once per instance returned by EOS_Platform_Create. Undefined behavior will result in calling it with a single instance more than once.
 * Typically only a single platform instance needs to be created during the lifetime of a game.
 * You should release each platform instance before calling the EOS_Shutdown function.
 */
EOS_DECLARE_FUNC(void) EOS_Platform_Release(EOS_HPlatform Handle);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_integratedplatform.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_integratedplatform_types.h"

/**
 * To add integrated platforms, you must call EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainer to create an integrated platform options container. To modify that handle, call
 * EOS_IntegratedPlatformOptionsContainer_* methods. Once you are finished, call EOS_Platform_Create with your handle. You must then release your integrated platform options container
 * handle by calling EOS_IntegratedPlatformOptionsContainer_Release.
 */

/**
 * Adds an integrated platform options to the container.
 *
 * @param Options Object containing properties related to setting a user's Status
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_IntegratedPlatformOptionsContainer_Add(EOS_HIntegratedPlatformOptionsContainer Handle, const EOS_IntegratedPlatformOptionsContainer_AddOptions* InOptions);

/**
 * Sets the current login status of a specific local platform user to a new value.
 *
 * This function may only be used with an Integrated Platform initialized with the EOS_IPMF_ApplicationManagedIdentityLogin flag, otherwise
 * calls will return EOS_InvalidState and a platform user's login status will be controlled by OS events.
 *
 * If the login status of a user changes, a Integrated Platform User Login Status Changed notification will fire, and depending on the state
 * of the user's login and the platform, the EOS SDK might start fetching data for the user, it may clear cached data, or it may do nothing.
 *
 * If the login status of a user is not different from a previous call to this function, the function will do nothing and return EOS_Success.
 * This will not trigger a call to the Integrated Platform User Login Status Changed.
 *
 * @param Options
 * @return EOS_Success if the call was successful
 *         EOS_NotConfigured if the Integrated Platform was not initialized on platform creation
 *         EOS_InvalidState if the Integrated Platform was not initialized with the EOS_IPMF_ApplicationManagedIdentityLogin flag
 *         EOS_InvalidUser if the LocalPlatformUserId is not a valid user id for the provided Integrated Platform
 *         EOS_InvalidParameters if any other input was invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_IntegratedPlatform_SetUserLoginStatus(EOS_HIntegratedPlatform Handle, const EOS_IntegratedPlatform_SetUserLoginStatusOptions* Options);

/**
 * Register to receive notifications when the login state of Integrated Platform users change.
 *
 * This notification will trigger any time the EOS SDK's internal login state changes for a user, including for manual login state
 * changes (when the EOS_IPMF_ApplicationManagedIdentityLogin flag is set), or automatically detected ones (when not disabled by the
 * EOS_IPMF_ApplicationManagedIdentityLogin flag).
 *
 * @param Options Data associated with what version of the notification to receive.
 * @param ClientData A context pointer that is returned in the callback function.
 * @param CallbackFunction The function that is called when Integrated Platform user logins happen
 * @return A valid notification that can be used to unregister for notifications, or EOS_INVALID_NOTIFICATIONID if input was invalid.
 *
 * @see EOS_IntegratedPlatform_RemoveNotifyUserLoginStatusChanged
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_IntegratedPlatform_AddNotifyUserLoginStatusChanged(EOS_HIntegratedPlatform Handle, const EOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions* Options, void* ClientData, const EOS_IntegratedPlatform_OnUserLoginStatusChangedCallback CallbackFunction);

/**
 * Unregister from Integrated Platform user login and logout notifications.
 *
 * @param NotificationId The NotificationId that was returned from registering for Integrated Platform user login and logout notifications.
 *
 * @see EOS_IntegratedPlatform_AddNotifyUserLoginStatusChanged
 */
EOS_DECLARE_FUNC(void) EOS_IntegratedPlatform_RemoveNotifyUserLoginStatusChanged(EOS_HIntegratedPlatform Handle, EOS_NotificationId NotificationId);

/**
 * Sets the integrated platform user logout handler for all integrated platforms.
 *
 * There can only be one handler set at once, attempting to set a handler when one is already set will result in a EOS_AlreadyConfigured error.
 *
 * This callback handler allows applications to decide if a user is logged-out immediately when the SDK receives a system user logout event,
 * or if the application would like to give the user a chance to correct themselves and log back in if they are in a state that might be
 * disruptive if an accidental logout happens (unsaved user data, in a multiplayer match, etc). This is not supported on all integrated
 * platforms, such as those where applications automatically close when a user logs out, or those where a user is always logged-in.
 *
 * If a logout is deferred, applications are expected to eventually call EOS_IntegratedPlatform_FinalizeDeferredUserLogout when they
 * have decided a user meant to logout, or if they have logged in again.
 *
 * @param Options Data that specifies the API version.
 * @param ClientData An optional context pointer that is returned in the callback data.
 * @param CallbackFunction The function that will handle the callback.
 * @return EOS_Success if the platform user logout handler was bound successfully.
 *		   EOS_AlreadyConfigured if there is already a platform user logout handler bound.
 *
 * @see EOS_IntegratedPlatform_ClearUserPreLogoutCallback
 * @see EOS_IntegratedPlatform_FinalizeDeferredUserLogout
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_IntegratedPlatform_SetUserPreLogoutCallback(EOS_HIntegratedPlatform Handle, const EOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions* Options, void* ClientData, EOS_IntegratedPlatform_OnUserPreLogoutCallback CallbackFunction);

/**
 * Clears a previously set integrated platform user logout handler for the specified integrated platform. If none is set for the specified platform, this does nothing.
 *
 * If there are any pending deferred user-logouts when a handler is cleared, those users will internally be logged-out and cached data about those users cleared before this function returns.
 * Any applicable callbacks about those users being logged-out will occur in a future call to EOS_Platform_Tick().
 *
 * @param Options Data for which integrated platform to no longer call a previously-registered callback for.
 *
 * @see EOS_IntegratedPlatform_SetUserPreLogoutCallback
 */
EOS_DECLARE_FUNC(void) EOS_IntegratedPlatform_ClearUserPreLogoutCallback(EOS_HIntegratedPlatform Handle, const EOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions* Options);

/**
 * Complete a Logout/Login for a previously deferred Integrated Platform User Logout.
 *
 * This function allows applications to control whether an integrated-platform user actually logs out when an integrated platform's system tells the SDK a user has been logged-out.
 * This allows applications to prevent accidental logouts from destroying application user state. If a user did not mean to logout, the application should prompt and confirm whether
 * the user meant to logout, and either wait for them to confirm they meant to, or wait for them to login again, before calling this function.
 *
 * If the sign-out is intended and your application believes the user is still logged-out, the UserExpectedLoginState in Options should be EOS_LS_NotLoggedIn.
 * If the sign-out was NOT intended and your application believes the user has logged-in again, the UserExpectedLoginState in Options should be EOS_LS_LoggedIn.
 *
 * @param Options Data for which integrated platform and user is now in the expected logged-in/logged-out state.
 * @return EOS_Success if the platform user state matches the UserExpectedLoginState internally.
 *         EOS_NotConfigured if the Integrated Platform was not initialized on platform creation
 *         EOS_InvalidUser if the LocalPlatformUserId is not a valid user id for the provided Integrated Platform, or if there is no deferred logout waiting to be completed for this specified user
 *         EOS_InvalidParameters if any other input was invalid
 *
 * @see EOS_IntegratedPlatform_SetUserPreLogoutCallback
 * @see EOS_IntegratedPlatform_ClearUserPreLogoutCallback
 * @see EOS_IntegratedPlatform_AddNotifyUserLoginStatusChanged
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_IntegratedPlatform_FinalizeDeferredUserLogout(EOS_HIntegratedPlatform Handle, const EOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions* Options);

```

`EAC_SDK/SDK/include/eos_integratedplatform_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

typedef struct EOS_IntegratedPlatformOptionsContainerHandle* EOS_HIntegratedPlatformOptionsContainer;
typedef struct EOS_IntegratedPlatformHandle* EOS_HIntegratedPlatform;

/** These flags are used to determine how a specific Integrated Platform will be managed. */
EOS_ENUM(EOS_EIntegratedPlatformManagementFlags,
	/** The integrated platform library should be disabled. This is equivalent to providing no flags. */
	EOS_IPMF_Disabled = 0x0001,
	/** The integrated platform library is managed by the calling application. EOS SDK should only hook into an existing instance of the integrated platform library. */
	EOS_IPMF_LibraryManagedByApplication = 0x0002,
	/** EOS SDK should fully manage the integrated platform library. It will do this by performing the load, initialize, tick and unload operations as necessary. */
	EOS_IPMF_LibraryManagedBySDK = 0x0004,
	/**
	 * The EOS SDK should not mirror the EOS rich presence with the Integrated Platform.
	 * The default behavior is for EOS SDK to share local presence with the Integrated Platform.
	 */
	EOS_IPMF_DisablePresenceMirroring = 0x0008,
	/**
	 * EOS SDK should not perform any sessions management through the Integrated Platform.
	 * The default behavior is for EOS SDK to perform sessions management through the Integrated Platform.
	 * Sessions management includes:
	 *    - sharing the lobby and session presence enabled games with the Integrated Platform.
	 *    - handling Social Overlay join button events which cannot be handled by normal processing of Epic Services.
	 *    - handling Social Overlay invite button events which cannot be handled by normal processing of Epic Services.
	 *    - handling startup requests from the Integrated Platform to immediately join a game due to in invite while offline.
	 *
	 * @see EOS_Lobby_AddNotifySendLobbyNativeInviteRequested
	 */
	EOS_IPMF_DisableSDKManagedSessions = 0x0010,
	/**
	 * Some features within the EOS SDK may wish to know a preference of Integrated Platform versus EOS.
	 * When determining an absolute platform preference those with this flag will be skipped.
	 * The IntegratedPlatforms list is provided via the EOS_Platform_Options during EOS_Platform_Create.
	 *
	 * The primary usage of the EOS_IPMF_PreferEOSIdentity and EOS_IPMF_PreferIntegratedIdentity flags is with game invites
	 * from the Social Overlay.
	 *
	 * For game invites from the Social Overlay the EOS SDK will follow these rules:
	 *     - If the only account ID we can determine for the target player is an EAS ID then the EOS system will be used.
	 *     - If the only account ID we can determine for the target player is an integrated platform ID then the integrated platform system will be used.
	 *     - If both are available then the EOS SDK will operate in 1 of 3 modes:
	 *         - no preference identified: use both the EOS and integrated platform systems.
	 *         - PreferEOS: Use EOS if the target is an EAS friend and is either online in EAS or not online for the integrated platform.
	 *         - PreferIntegrated: Use integrated platform if the target is an integrated platform friend and is either online in the integrated platform or not online for EAS.
	 *     - If the integrated platform fails to send then try EAS if was not already used.
	 */
	EOS_IPMF_PreferEOSIdentity = 0x0020,
	/**
	 * Some features within the EOS SDK may wish to know a preference of Integrated Platform versus EOS.
	 * For further explanation see EOS_IPMF_PreferEOSIdentity.
	 *
	 * @see EOS_IPMF_PreferEOSIdentity
	 */
	EOS_IPMF_PreferIntegratedIdentity = 0x0040,
	/**
	 * By default the EOS SDK will attempt to detect the login/logout events of local users and update local states accordingly. Setting this flag will disable this functionality,
	 * relying on the application to process login/logout events and notify EOS SDK. It is not possible for the EOS SDK to do this on all platforms, making this flag not always
	 * optional.
	 *
	 * This flag must be set to use the manual platform user login/logout functions, even on platforms where it is not possible for the EOS SDK to detect login/logout events,
	 * making this a required flag for correct Integrated Platform behavior on those platforms.
	 */
	EOS_IPMF_ApplicationManagedIdentityLogin = 0x0080
);
EOS_ENUM_BOOLEAN_OPERATORS(EOS_EIntegratedPlatformManagementFlags);

/** A macro to identify the Steam integrated platform. */
#define EOS_IPT_Steam "STEAM"

#define EOS_INTEGRATEDPLATFORM_OPTIONS_API_LATEST 1

/**
 */
EOS_STRUCT(EOS_IntegratedPlatform_Options, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORM_OPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The type to be initialized. */
	EOS_IntegratedPlatformType Type;
	/** Identifies how to initialize the IntegratedPlatform. */
	EOS_EIntegratedPlatformManagementFlags Flags;
	/**
	 * Options specific to this integrated platform type.
	 * This parameter is either required or set to NULL based on the platform type.
	 *
	 * @see EOS_IntegratedPlatform_Steam_Options
	 */
	const void* InitOptions;
));

#define EOS_INTEGRATEDPLATFORM_STEAM_OPTIONS_API_LATEST 3

#define EOS_INTEGRATEDPLATFORM_STEAM_MAX_STEAMAPIINTERFACEVERSIONSARRAY_SIZE 4096

/**
 * Required initialization options to use with EOS_IntegratedPlatform_Options for Steam.
 * Steamworks API needs to be at least v1.13
 * Steam Sanitization requires at least v1.45
 * Starting Steamworks v1.58a onwards, SteamApiInterfaceVersionsArray is required when EOS_IPMF_LibraryManagedBySDK is set.
 * 
 * @see EOS_IntegratedPlatform_Options
 */
EOS_STRUCT(EOS_IntegratedPlatform_Steam_Options, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORM_STEAM_OPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * Usage of this parameter is dependent on the specified EOS_EIntegratedPlatformManagementFlags.
	 *
	 * Optional with EOS_IPMF_LibraryManagedByApplication.
	 * Set to override the loaded library basename, or use NULL to assume the default basename by platform:
	 *
	 * - Linux: libsteam_api.so,
	 * - macOS: libsteam_api.dylib,
	 * - Windows 32-bit: steam_api.dll,
	 * - Windows 64-bit: steam_api64.dll.
	 *
	 * Required with EOS_IPMF_LibraryManagedBySDK.
	 * Set to a fully qualified file path to the Steamworks SDK runtime library on disk.
	 */
	const char* OverrideLibraryPath;
	/**
	 * Used to specify the major version of the Steam SDK your game is compiled against, e.g.:
	 *
	 * Options.SteamMajorVersion = 1;
	 */
	uint32_t SteamMajorVersion;
	/**
	 * Used to specify the minor version of the Steam SDK your game is compiled against, e.g.:
	 *
	 * Options.SteamMinorVersion = 58;
	 */
	uint32_t SteamMinorVersion;

	/**
	 * A pointer to a series of null terminated steam interface version names supported by the current steam dll. 
	 * 
	 * This field is only required when the Integrated Platform Management flags has EOS_IPMF_LibraryManagedBySDK set. Else must be set to NULL.
	 * 
	 * Starting v1.58 the Steam initialization API requires this new field during initialization for version check validations.
	 *
	 * Note: The pointer must be valid until after the execution of the EOS_IntegratedPlatformOptionsContainer_Add method.
	 *
	 * This value must be constructed from the corresponding steam_api.h header of the steam dll version that is shipped with the game.
	 * In the steam_api.h header, look for SteamAPI_InitEx() and copy the value of pszInternalCheckInterfaceVersions as it is.
	 * 
	 * For example in v1.58a its this:
	 * 	const char SteamInterfaceVersionsArray[] = 
	 *		STEAMUTILS_INTERFACE_VERSION "\0"
	 *		STEAMNETWORKINGUTILS_INTERFACE_VERSION "\0"
	 *		...
	 *		STEAMUSER_INTERFACE_VERSION "\0"
	 *		STEAMVIDEO_INTERFACE_VERSION "\0"
	 *      "\0";
	 */
	const char* SteamApiInterfaceVersionsArray;

	/**
	 * Size of the SteamApiInterfaceVersionsArray in bytes. Cannot exceed EOS_INTEGRATEDPLATFORM_STEAM_MAX_STEAMAPIINTERFACEVERSIONSARRAY_SIZE.
	 * 
	 * This field is only required when the Integrated Platform Management flags has EOS_IPMF_LibraryManagedBySDK set. Else must be set to 0.
	 *
	 * Note: Since SteamInterfaceVersionsArray contains a series of null terminated strings, please ensure that strlen() is NOT used to calculate this field.
	 * For instance, you can use the following to get the array length:
	 *  const char SteamInterfaceVersionsArray[] = 
	 *      STEAMUTILS_INTERFACE_VERSION "\0"
	 *		STEAMNETWORKINGUTILS_INTERFACE_VERSION "\0"
	 *      ...
	 *		STEAMVIDEO_INTERFACE_VERSION "\0"
	 *      "\0";
	 * 
	 *  uint32_t SteamApiInterfaceVersionsArrayBytes = sizeof(SteamApiInterfaceVersionsArray) // Note: sizeof() takes into account the last "\0" of the string literal;
	 */
	uint32_t SteamApiInterfaceVersionsArrayBytes;
));

#define EOS_INTEGRATEDPLATFORM_CREATEINTEGRATEDPLATFORMOPTIONSCONTAINER_API_LATEST 1

/**
 * Data for the EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainer function.
 */
EOS_STRUCT(EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORM_CREATEINTEGRATEDPLATFORMOPTIONSCONTAINER_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Creates an integrated platform options container handle. This handle can used to add multiple options to your container which will then be applied with EOS_Platform_Create.
 * The resulting handle must be released by calling EOS_IntegratedPlatformOptionsContainer_Release once it has been passed to EOS_Platform_Create.
 *
 * @param Options structure containing operation input parameters.
 * @param OutIntegratedPlatformOptionsContainerHandle Pointer to an integrated platform options container handle to be set if successful.
 * @return Success if we successfully created the integrated platform options container handle pointed at in OutIntegratedPlatformOptionsContainerHandle, or an error result if the input data was invalid.
 *
 * @see EOS_IntegratedPlatformOptionsContainer_Release
 * @see EOS_Platform_Create
 * @see EOS_IntegratedPlatformOptionsContainer_Add
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainer(const EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainerOptions* Options, EOS_HIntegratedPlatformOptionsContainer* OutIntegratedPlatformOptionsContainerHandle);

/**
 * Release the memory associated with an EOS_HIntegratedPlatformOptionsContainer handle. This must be called on Handles retrieved from EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainer.
 * This can be safely called on a NULL integrated platform options container handle.
 *
 * @param IntegratedPlatformOptionsContainerHandle The integrated platform options container handle to release.
 *
 * @see EOS_IntegratedPlatform_CreateIntegratedPlatformOptionsContainer
 */
EOS_DECLARE_FUNC(void) EOS_IntegratedPlatformOptionsContainer_Release(EOS_HIntegratedPlatformOptionsContainer IntegratedPlatformOptionsContainerHandle);


#define EOS_INTEGRATEDPLATFORMOPTIONSCONTAINER_ADD_API_LATEST 1

/**
 * Data for the EOS_IntegratedPlatformOptionsContainer_Add function.
 */
EOS_STRUCT(EOS_IntegratedPlatformOptionsContainer_AddOptions, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORMOPTIONSCONTAINER_ADD_API_LATEST. */
	int32_t ApiVersion;
	/** The integrated platform options to add. */
	const EOS_IntegratedPlatform_Options* Options;
));

/** The most recent version of the EOS_IntegratedPlatform_SetUserLoginStatus API. */
#define EOS_INTEGRATEDPLATFORM_SETUSERLOGINSTATUS_API_LATEST 1

/**
 * Input parameters for the EOS_IntegratedPlatform_SetUserLoginStatus function.
 */
EOS_STRUCT(EOS_IntegratedPlatform_SetUserLoginStatusOptions, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORM_SETUSERLOGINSTATUS_API_LATEST. */
	int32_t ApiVersion;

	/** The integrated platform this user belongs to. */
	EOS_IntegratedPlatformType PlatformType;
	
	/** String version of the integrated platform-dependent user id. */
	const char* LocalPlatformUserId;
	
	/** The login status of the provided user */
	EOS_ELoginStatus CurrentLoginStatus;
));


/** The most recent version of the EOS_IntegratedPlatform_AddNotifyUserLoginStatusChanged API. */
#define EOS_INTEGRATEDPLATFORM_ADDNOTIFYUSERLOGINSTATUSCHANGED_API_LATEST 1

/**
 * Input parameters for the EOS_IntegratedPlatform_AddNotifyUserLoginStatusChanged function.
 */
EOS_STRUCT(EOS_IntegratedPlatform_AddNotifyUserLoginStatusChangedOptions, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORM_ADDNOTIFYUSERLOGINSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Data about which integrated platform and which user that had a login status change and what the login status changed to.
 */
EOS_STRUCT(EOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo, (
	/** Context that was passed into EOS_IntegratedPlatform_AddNotifyUserLoginStatusChanged */
	void* ClientData;
	/** The integrated platform of the local platform user. */
	EOS_IntegratedPlatformType PlatformType;
	/** String version of platform's user id. */
	const char* LocalPlatformUserId;
	/** The Epic Games Account ID associated with this Integrated Platform's User (if there is one) */
	EOS_EpicAccountId AccountId;
	/** The EOS Product User ID associated with this Integrated Platform's User (if there is one) */
	EOS_ProductUserId ProductUserId;
	/** The login status prior to this change. */
	EOS_ELoginStatus PreviousLoginStatus;
	/** The login status at the time of this notification. */
	EOS_ELoginStatus CurrentLoginStatus;
));
/**
 * The callback function for when a local integrated platform user's login status has changed.
 */
EOS_DECLARE_CALLBACK(EOS_IntegratedPlatform_OnUserLoginStatusChangedCallback, const EOS_IntegratedPlatform_UserLoginStatusChangedCallbackInfo* Data);

/** The most recent version of the EOS_IntegratedPlatform_SetUserPreLogoutCallback API. */
#define EOS_INTEGRATEDPLATFORM_SETUSERPRELOGOUTCALLBACK_API_LATEST 1

/**
 * Input parameters for the EOS_IntegratedPlatform_SetUserPreLogoutCallback function.
 */
EOS_STRUCT(EOS_IntegratedPlatform_SetUserPreLogoutCallbackOptions, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORM_SETUSERPRELOGOUTCALLBACK_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * The return value for the EOS_IntegratedPlatform_OnUserPreLogoutCallback callback function. This signifies what the application wants to do for
 * the provided user of the integrated platform.
 */
EOS_ENUM(EOS_EIntegratedPlatformPreLogoutAction,
	/**
	 * The application accepts the user being logged-out. all cached data for the user will be cleared immediately and any pending
	 * actions canceled.
	 */
	EOS_IPLA_ProcessLogoutImmediately = 0,
	/**
	 * Instead of the user being logged-out, the SDK will wait for a call to EOS_IntegratedPlatform_FinalizeDeferredUserLogout with the
	 * expected login state of the user. If the expected state matches the current state, the user will continue to be logged-in or they
	 * will be logged-out, depending on the value of the expected state. This lets the application choose to ask the user if they meant
	 * to logout if it wishes, possibly preventing losing any unsaved changes, such as game progress, leaving a multiplayer match, or
	 * similar.
	 *
	 * @see EOS_IntegratedPlatform_FinalizeDeferredUserLogout
	 */
	EOS_IPLA_DeferLogout = 1
);

/**
 * Data passed to the application in the EOS_IntegratedPlatform_OnUserPreLogoutCallback function. This contains which user and associated
 * Integrated Platform that was detected as logged-out.
 */
EOS_STRUCT(EOS_IntegratedPlatform_UserPreLogoutCallbackInfo, (
	/** Context that was passed into EOS_IntegratedPlatform_SetUserPreLogoutCallback  */
	void* ClientData;
	/** The integrated platform the local user logged-out of. */
	EOS_IntegratedPlatformType PlatformType;
	/** String version of platform-dependent user id. */
	const char* LocalPlatformUserId;
	/** The Epic Games Account ID associated with this Integrated Platform's User (if there is one) */
	EOS_EpicAccountId AccountId;
	/** The EOS Product User ID associated with this Integrated Platform's User (if there is one) */
	EOS_ProductUserId ProductUserId;
));
/**
 * The callback function for when an integrated platform user is detected to have logged-out.
 */
EOS_DECLARE_CALLBACK_RETVALUE(EOS_EIntegratedPlatformPreLogoutAction, EOS_IntegratedPlatform_OnUserPreLogoutCallback, const EOS_IntegratedPlatform_UserPreLogoutCallbackInfo* Data);

/** The most recent version of the EOS_IntegratedPlatform_ClearUserPreLogoutCallback API. */
#define EOS_INTEGRATEDPLATFORM_CLEARUSERPRELOGOUTCALLBACK_API_LATEST 1

/**
 * Input parameters for the EOS_IntegratedPlatform_ClearUserPreLogoutCallback function.
 */
EOS_STRUCT(EOS_IntegratedPlatform_ClearUserPreLogoutCallbackOptions, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORM_CLEARUSERPRELOGOUTCALLBACK_API_LATEST. */
	int32_t ApiVersion;
));


/** The most recent version of the EOS_IntegratedPlatform_FinalizeDeferredUserLogout API. */
#define EOS_INTEGRATEDPLATFORM_FINALIZEDEFERREDUSERLOGOUT_API_LATEST 1

/**
 * Input parameters for the EOS_IntegratedPlatform_FinalizeDeferredUserLogout function.
 */
EOS_STRUCT(EOS_IntegratedPlatform_FinalizeDeferredUserLogoutOptions, (
	/** API Version: Set this to EOS_INTEGRATEDPLATFORM_FINALIZEDEFERREDUSERLOGOUT_API_LATEST. */
	int32_t ApiVersion;

	/** The integrated platform this user belongs to. */
	EOS_IntegratedPlatformType PlatformType;

	/** String version of the integrated platform-dependent user id. */
	const char* LocalPlatformUserId;

	/**
	 * The logged-in state the user is expected to be (EOS_LS_LoggedIn or EOS_LS_NotLoggedIn). If the provided
	 * state does not match internal EOS state, this function will return in failure. If the state is incorrect,
	 * the application should wait and attempt to call the function again next tick, after both updating its own
	 * state from the system and calling EOS_Platform_Tick, allowing the SDK to update its state from the system
	 * as well.
	 */
	EOS_ELoginStatus ExpectedLoginStatus;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_kws.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_kws_types.h"

/**
 * This interface is not available for general access at this time.
 *
 * The KWS Interface exists as an integration for age gating functionality provided by Kids Web Services from SuperAwesome, using the EOS Connect interface.
 *
 * All KWS Interface calls take a handle of type EOS_HKWS as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetKWSInterface function.
 *
 * @see EOS_Platform_GetKWSInterface
 */

/**
 * This interface is not available for general access at this time.
 *
 * Query the client's country and age permissions for client side reasoning about the possible need enforce age based restrictions
 *
 * @param Options options required for interacting with the age gate system
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if the query completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed queries is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_KWS_QueryAgeGate(EOS_HKWS Handle, const EOS_KWS_QueryAgeGateOptions* Options, void* ClientData, const EOS_KWS_OnQueryAgeGateCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Create an account with Kids Web Services and associate it with the local Product User ID
 *
 * @param Options options required for creating an account such as the local users Product User ID, their data of birth, and parental contact information
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if account creation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed requests is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_KWS_CreateUser(EOS_HKWS Handle, const EOS_KWS_CreateUserOptions* Options, void* ClientData, const EOS_KWS_OnCreateUserCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Query the current state of permissions for a given local Product User ID
 *
 * @param Options options required for querying permissions such as the local users Product User ID
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if the account query completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed requests is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_KWS_QueryPermissions(EOS_HKWS Handle, const EOS_KWS_QueryPermissionsOptions* Options, void* ClientData, const EOS_KWS_OnQueryPermissionsCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Update the parent contact information for a given local Product User ID
 *
 * @param Options options required for updating the contact information such as the new email address
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if contact information update completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed requests is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_KWS_UpdateParentEmail(EOS_HKWS Handle, const EOS_KWS_UpdateParentEmailOptions* Options, void* ClientData, const EOS_KWS_OnUpdateParentEmailCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Request new permissions for a given local Product User ID
 *
 * @param Options options required for updating permissions such as the new list of permissions
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the operation completes, either successfully or in error
 *
 * @return EOS_Success if contact information update completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_TooManyRequests if the number of allowed requests is exceeded
 *         EOS_KWS_ParentEmailMissing if the account requesting permissions has no parent email associated with it
 *         EOS_LimitExceeded if the number of permissions exceeds EOS_KWS_MAX_PERMISSIONS, or if any permission name exceeds EOS_KWS_MAX_PERMISSION_LENGTH
 */
EOS_DECLARE_FUNC(void) EOS_KWS_RequestPermissions(EOS_HKWS Handle, const EOS_KWS_RequestPermissionsOptions* Options, void* ClientData, const EOS_KWS_OnRequestPermissionsCallback CompletionDelegate);

/**
 * This interface is not available for general access at this time.
 *
 * Fetch the number of permissions found for a given local user
 *
 * @param Options Structure containing the input parameters
 *
 * @return the number of permissions associated with the given user
 */
EOS_DECLARE_FUNC(int32_t) EOS_KWS_GetPermissionsCount(EOS_HKWS Handle, const EOS_KWS_GetPermissionsCountOptions* Options);

/**
 * This interface is not available for general access at this time.
 *
 * Fetch a permission for a given by index for a given local user
 *
 * @param Options Structure containing the input parameters
 * @param OutPermission the permission for the given index, if it exists and is valid, use EOS_KWS_PermissionStatus_Release when finished
 *
 * @see EOS_KWS_CreateUser
 * @see EOS_KWS_QueryPermissions
 * @see EOS_KWS_RequestPermissions
 * @see EOS_KWS_PermissionStatus_Release
 *
 * @return EOS_Success if the permission state is known for the given user and index
 *         EOS_NotFound if the user is not found or the index is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_KWS_CopyPermissionByIndex(EOS_HKWS Handle, const EOS_KWS_CopyPermissionByIndexOptions* Options, EOS_KWS_PermissionStatus ** OutPermission);

/**
 * This interface is not available for general access at this time.
 *
 * Fetch the state of a given permission that are cached for a given local user.
 *
 * @param Options Structure containing the input parameters
 * @param OutPermission the permission for the given key, if it exists and is valid
 *
 * @see EOS_KWS_CreateUser
 * @see EOS_KWS_QueryPermissions
 * @see EOS_KWS_RequestPermissions
 *
 * @return EOS_Success if the permission state is known for the given user and key
 *         EOS_NotFound if the user or the permission is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_KWS_GetPermissionByKey(EOS_HKWS Handle, const EOS_KWS_GetPermissionByKeyOptions* Options, EOS_EKWSPermissionStatus* OutPermission);

/**
 * This interface is not available for general access at this time.
 *
 * Register to receive notifications about KWS permissions changes for any logged in local users
 * @note If the returned NotificationId is valid, you must call EOS_KWS_RemoveNotifyPermissionsUpdateReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_KWS_AddNotifyPermissionsUpdateReceived(EOS_HKWS Handle, const EOS_KWS_AddNotifyPermissionsUpdateReceivedOptions* Options, void* ClientData, const EOS_KWS_OnPermissionsUpdateReceivedCallback NotificationFn);

/**
 * This interface is not available for general access at this time.
 *
 * Unregister from receiving notifications about KWS permissions related to logged in users
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_KWS_RemoveNotifyPermissionsUpdateReceived(EOS_HKWS Handle, EOS_NotificationId InId);

```

`EAC_SDK/SDK/include/eos_kws_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_KWSHandle* EOS_HKWS;

/** Maximum number of permissions that may be requested */
#define EOS_KWS_MAX_PERMISSIONS 16

/** Maximum size of the name for the permission */
#define EOS_KWS_MAX_PERMISSION_LENGTH 32

/**
 * An enumeration of the different permission statuses.
 */
EOS_ENUM(EOS_EKWSPermissionStatus,
	/** Permission has been granted */
	EOS_KPS_GRANTED = 0,
	/** Permission has been rejected */
	EOS_KPS_REJECTED = 1,
	/** Permission is still pending approval */
	EOS_KPS_PENDING = 2
);

/** The most recent version of the EOS_KWS_PermissionStatus API. */
#define EOS_KWS_PERMISSIONSTATUS_API_LATEST 1

EOS_STRUCT(EOS_KWS_PermissionStatus, (
	/** API Version: Set this to EOS_KWS_PERMISSIONSTATUS_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the permission */
	const char* Name;
	/** Status of the permission */
	EOS_EKWSPermissionStatus Status;
));

EOS_DECLARE_FUNC(void) EOS_KWS_PermissionStatus_Release(EOS_KWS_PermissionStatus* PermissionStatus);

/** The most recent version of the EOS_KWS_QueryAgeGate API. */
#define EOS_KWS_QUERYAGEGATE_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_QueryAgeGate function.
 */
EOS_STRUCT(EOS_KWS_QueryAgeGateOptions, (
	/** API Version: Set this to EOS_KWS_QUERYAGEGATE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_KWS_QueryAgeGate Function. These parameters are received through the callback provided to EOS_KWS_QueryAgeGate
 */
EOS_STRUCT(EOS_KWS_QueryAgeGateCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_QueryAgeGate */
	void* ClientData;
	/** Country code determined for this request based on the local client's ip address that the backend resolves */
	const char* CountryCode;
	/** Age of consent in the given country */
	uint32_t AgeOfConsent;
));

/**
 * Function prototype definition for callbacks passed to EOS_KWS_QueryAgeGate
 * @param Data A EOS_KWS_QueryAgeGateCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnQueryAgeGateCallback, const EOS_KWS_QueryAgeGateCallbackInfo* Data);

/** The most recent version of the EOS_KWS_CreateUser API. */
#define EOS_KWS_CREATEUSER_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_CreateUser function.
 */
EOS_STRUCT(EOS_KWS_CreateUserOptions, (
	/** API Version: Set this to EOS_KWS_CREATEUSER_API_LATEST. */
	int32_t ApiVersion;
	/** Local user creating a KWS entry */
	EOS_ProductUserId LocalUserId;
	/** Date of birth in ISO8601 form (YYYY-MM-DD) */
	const char* DateOfBirth;
	/** Parent email */
	const char* ParentEmail;
));

/**
 * Output parameters for the EOS_KWS_CreateUserOptions Function. These parameters are received through the callback provided to EOS_KWS_CreateUser
 */
EOS_STRUCT(EOS_KWS_CreateUserCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_CreateUser */
	void* ClientData;
	/** Local user that created a KWS entry */
	EOS_ProductUserId LocalUserId;
	/** KWS UserId created */
	const char* KWSUserId;
	/** Is this user a minor */
	EOS_Bool bIsMinor;
));


/**
 * Function prototype definition for callbacks passed to EOS_KWS_CreateUser
 * @param Data A EOS_KWS_CreateUserCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnCreateUserCallback, const EOS_KWS_CreateUserCallbackInfo* Data);

/** The most recent version of the EOS_KWS_QueryPermissions API. */
#define EOS_KWS_QUERYPERMISSIONS_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_QueryPermissions function.
 */
EOS_STRUCT(EOS_KWS_QueryPermissionsOptions, (
	/** API Version: Set this to EOS_KWS_QUERYPERMISSIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Local user querying their permissions */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_KWS_QueryPermissionsOptions Function. These parameters are received through the callback provided to EOS_KWS_QueryPermissions
 */
EOS_STRUCT(EOS_KWS_QueryPermissionsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_QueryPermissions */
	void* ClientData;
	/** Local user querying their permissions */
	EOS_ProductUserId LocalUserId;
	/** KWS UserId created */
	const char* KWSUserId;
	/** Date of birth in ISO8601 form (YYYY-MM-DD) */
	const char* DateOfBirth;
	/** Is this user a minor */
	EOS_Bool bIsMinor;
	/** Parent email. This value may be set to an empty string if the originally registered email recipient declined to be the right person to give consent. */
	const char* ParentEmail;
));

/**
 * Function prototype definition for callbacks passed to EOS_KWS_QueryPermissions
 * @param Data A EOS_KWS_QueryPermissionsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnQueryPermissionsCallback, const EOS_KWS_QueryPermissionsCallbackInfo* Data);

/** The most recent version of the EOS_KWS_UpdateParentEmail API. */
#define EOS_KWS_UPDATEPARENTEMAIL_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_UpdateParentEmail function.
 */
EOS_STRUCT(EOS_KWS_UpdateParentEmailOptions, (
	/** API Version: Set this to EOS_KWS_UPDATEPARENTEMAIL_API_LATEST. */
	int32_t ApiVersion;
	/** Local user updating parental information */
	EOS_ProductUserId LocalUserId;
	/** New parent email */
	const char* ParentEmail;
));

/**
 * Output parameters for the EOS_KWS_UpdateParentEmailOptions Function. These parameters are received through the callback provided to EOS_KWS_UpdateParentEmail
 */
EOS_STRUCT(EOS_KWS_UpdateParentEmailCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_UpdateParentEmail */
	void* ClientData;
	/** Local user updating their parental email */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_KWS_UpdateParentEmail
 * @param Data A EOS_KWS_UpdateParentEmailCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnUpdateParentEmailCallback, const EOS_KWS_UpdateParentEmailCallbackInfo* Data);

/** The most recent version of the EOS_KWS_RequestPermissions API. */
#define EOS_KWS_REQUESTPERMISSIONS_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_RequestPermissions function.
 */
EOS_STRUCT(EOS_KWS_RequestPermissionsOptions, (
	/** API Version: Set this to EOS_KWS_REQUESTPERMISSIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Local user requesting new permissions */
	EOS_ProductUserId LocalUserId;
	/** The number of permissions to request, may not exceed EOS_KWS_MAX_PERMISSIONS. Only new permissions need be included. */
	uint32_t PermissionKeyCount;
	/** Names of the permissions to request (Setup with KWS) */
	const char** PermissionKeys;
));

/**
 * Output parameters for the EOS_KWS_RequestPermissionsOptions Function. These parameters are received through the callback provided to EOS_KWS_RequestPermissions
 */
EOS_STRUCT(EOS_KWS_RequestPermissionsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_KWS_RequestPermissions */
	void* ClientData;
	/** Local user requesting new permissions */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_KWS_RequestPermissions
 * @param Data A EOS_KWS_RequestPermissionsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnRequestPermissionsCallback, const EOS_KWS_RequestPermissionsCallbackInfo* Data);


#define EOS_KWS_GETPERMISSIONSCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_GetPermissionsCount function.
 */
EOS_STRUCT(EOS_KWS_GetPermissionsCountOptions, (
	/** API Version: Set this to EOS_KWS_GETPERMISSIONSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user whose permissions are being accessed */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_KWS_CopyPermissionByIndex API. */
#define EOS_KWS_COPYPERMISSIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_CopyPermissionByIndex function.
 */
EOS_STRUCT(EOS_KWS_CopyPermissionByIndexOptions, (
	/** API Version: Set this to EOS_KWS_COPYPERMISSIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user whose permissions are being accessed */
	EOS_ProductUserId LocalUserId;
	/** The index of the permission to get. */
	uint32_t Index;
));

/** The most recent version of the EOS_KWS_CreateUser API. */
#define EOS_KWS_GETPERMISSIONBYKEY_API_LATEST 1

/**
 * Input parameters for the EOS_KWS_GetPermissionByKey function.
 */
EOS_STRUCT(EOS_KWS_GetPermissionByKeyOptions, (
	/** API Version: Set this to EOS_KWS_GETPERMISSIONBYKEY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user getting permissions */
	EOS_ProductUserId LocalUserId;
	/** Permission name to query */
	const char* Key;
));

/** The most recent version of the EOS_KWS_AddNotifyPermissionsUpdateReceived API. */
#define EOS_KWS_ADDNOTIFYPERMISSIONSUPDATERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_KWS_AddNotifyPermissionsUpdateReceivedOptions, (
	/** API Version: Set this to EOS_KWS_ADDNOTIFYPERMISSIONSUPDATERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_KWS_OnPermissionsUpdateReceivedCallback Function.
 */
EOS_STRUCT(EOS_KWS_PermissionsUpdateReceivedCallbackInfo, (
	/** Context that was passed into EOS_KWS_AddNotifyPermissionsUpdateReceived */
	void* ClientData;
	/** Recipient Local user id */
	EOS_ProductUserId LocalUserId;
	/** Recipient's associated KWS UserId */
	const char* KWSUserId;
	/** Date of birth in ISO8601 form (YYYY-MM-DD) */
	const char* DateOfBirth;
	/** Is this user a minor */
	EOS_Bool bIsMinor;
	/** Parent email. This value may be set to an empty string if the originally registered email recipient declined to be the right person to give consent. */
	const char* ParentEmail;
));

/**
 * Function prototype definition for notifications that comes from EOS_KWS_AddNotifyPermissionsUpdateReceived
 *
 * @param Data A EOS_KWS_PermissionsUpdateReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_KWS_OnPermissionsUpdateReceivedCallback, const EOS_KWS_PermissionsUpdateReceivedCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_leaderboards.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_leaderboards_types.h"

/**
 * The following EOS_Leaderboards_* functions allow you to query existing leaderboard definitions that have been defined for your application.
 * You can retrieve a list of scores for the top users for each Leaderboard.
 * You can also query scores for one or more users.
 */

/**
 * Query for a list of existing leaderboards definitions including their attributes.
 *
 * @param Options Structure containing information about the application whose leaderboard definitions we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate This function is called when the query operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_QueryLeaderboardDefinitions(EOS_HLeaderboards Handle, const EOS_Leaderboards_QueryLeaderboardDefinitionsOptions* Options, void* ClientData, const EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallback CompletionDelegate);

/**
 * Fetch the number of leaderboards definitions that are cached locally.
 *
 * @param Options The Options associated with retrieving the leaderboard count.
 *
 * @see EOS_Leaderboards_CopyLeaderboardDefinitionByIndex
 * @see EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId
 *
 * @return Number of leaderboards or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Leaderboards_GetLeaderboardDefinitionCount(EOS_HLeaderboards Handle, const EOS_Leaderboards_GetLeaderboardDefinitionCountOptions* Options);

/**
 * Fetches a leaderboard definition from the cache using an index.
 *
 * @param Options Structure containing the index being accessed.
 * @param OutLeaderboardDefinition The leaderboard data for the given index, if it exists and is valid, use EOS_Leaderboards_Definition_Release when finished.
 *
 * @see EOS_Leaderboards_Definition_Release
 *
 * @return EOS_Success if the information is available and passed out in OutLeaderboardDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardDefinitionByIndex(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions* Options, EOS_Leaderboards_Definition ** OutLeaderboardDefinition);

/**
 * Fetches a leaderboard definition from the cache using a leaderboard ID.
 *
 * @param Options Structure containing the leaderboard ID being accessed.
 * @param OutLeaderboardDefinition The leaderboard definition for the given leaderboard ID, if it exists and is valid, use EOS_Leaderboards_Definition_Release when finished.
 *
 * @see EOS_Leaderboards_Definition_Release
 *
 * @return EOS_Success if the information is available and passed out in OutLeaderboardDefinition
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard data is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions* Options, EOS_Leaderboards_Definition ** OutLeaderboardDefinition);

/**
 * Retrieves top leaderboard records by rank in the leaderboard matching the given leaderboard ID.
 *
 * @param Options Structure containing information about the leaderboard records we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate This function is called when the query operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_QueryLeaderboardRanks(EOS_HLeaderboards Handle, const EOS_Leaderboards_QueryLeaderboardRanksOptions* Options, void* ClientData, const EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallback CompletionDelegate);

/**
 * Fetch the number of leaderboard records that are cached locally.
 *
 * @param Options The Options associated with retrieving the leaderboard record count.
 *
 * @see EOS_Leaderboards_CopyLeaderboardRecordByIndex
 * @see EOS_Leaderboards_CopyLeaderboardRecordByUserId
 *
 * @return Number of leaderboard records or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Leaderboards_GetLeaderboardRecordCount(EOS_HLeaderboards Handle, const EOS_Leaderboards_GetLeaderboardRecordCountOptions* Options);

/**
 * Fetches a leaderboard record from a given index.
 *
 * @param Options Structure containing the index being accessed.
 * @param OutLeaderboardRecord The leaderboard record for the given index, if it exists and is valid, use EOS_Leaderboards_LeaderboardRecord_Release when finished.
 *
 * @see EOS_Leaderboards_LeaderboardRecord_Release
 *
 * @return EOS_Success if the leaderboard record is available and passed out in OutLeaderboardRecord
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardRecordByIndex(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions* Options, EOS_Leaderboards_LeaderboardRecord ** OutLeaderboardRecord);

/**
 * Fetches a leaderboard record from a given user ID.
 *
 * @param Options Structure containing the user ID being accessed.
 * @param OutLeaderboardRecord The leaderboard record for the given user ID, if it exists and is valid, use EOS_Leaderboards_LeaderboardRecord_Release when finished.
 *
 * @see EOS_Leaderboards_LeaderboardRecord_Release
 *
 * @return EOS_Success if the leaderboard record is available and passed out in OutLeaderboardRecord
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard data is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardRecordByUserId(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions* Options, EOS_Leaderboards_LeaderboardRecord ** OutLeaderboardRecord);

/**
 * Query for a list of scores for a given list of users.
 *
 * @param Options Structure containing information about the users whose scores we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate This function is called when the query operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_QueryLeaderboardUserScores(EOS_HLeaderboards Handle, const EOS_Leaderboards_QueryLeaderboardUserScoresOptions* Options, void* ClientData, const EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallback CompletionDelegate);

/**
 * Fetch the number of leaderboard user scores that are cached locally.
 *
 * @param Options The Options associated with retrieving the leaderboard user scores count.
 *
 * @see EOS_Leaderboards_CopyLeaderboardUserScoreByIndex
 * @see EOS_Leaderboards_CopyLeaderboardUserScoreByUserId
 *
 * @return Number of leaderboard records or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Leaderboards_GetLeaderboardUserScoreCount(EOS_HLeaderboards Handle, const EOS_Leaderboards_GetLeaderboardUserScoreCountOptions* Options);

/**
 * Fetches leaderboard user score from a given index.
 *
 * @param Options Structure containing the index being accessed.
 * @param OutLeaderboardUserScore The leaderboard user score for the given index, if it exists and is valid, use EOS_Leaderboards_LeaderboardUserScore_Release when finished.
 *
 * @see EOS_Leaderboards_LeaderboardUserScore_Release
 *
 * @return EOS_Success if the leaderboard scores are available and passed out in OutLeaderboardUserScore
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard user scores are not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardUserScoreByIndex(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions* Options, EOS_Leaderboards_LeaderboardUserScore ** OutLeaderboardUserScore);

/**
 * Fetches leaderboard user score from a given user ID.
 *
 * @param Options Structure containing the user ID being accessed.
 * @param OutLeaderboardUserScore The leaderboard user score for the given user ID, if it exists and is valid, use EOS_Leaderboards_LeaderboardUserScore_Release when finished.
 *
 * @see EOS_Leaderboards_LeaderboardUserScore_Release
 *
 * @return EOS_Success if the leaderboard scores are available and passed out in OutLeaderboardUserScore
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the leaderboard user scores are not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Leaderboards_CopyLeaderboardUserScoreByUserId(EOS_HLeaderboards Handle, const EOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions* Options, EOS_Leaderboards_LeaderboardUserScore ** OutLeaderboardUserScore);

```

`EAC_SDK/SDK/include/eos_leaderboards_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_LeaderboardsHandle* EOS_HLeaderboards;

/** Timestamp value representing an undefined time for EOS_HLeaderboards. */
#define EOS_LEADERBOARDS_TIME_UNDEFINED -1

/** The most recent version of the EOS_Leaderboards_QueryLeaderboardDefinitions struct. */
#define EOS_LEADERBOARDS_QUERYLEADERBOARDDEFINITIONS_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_QueryLeaderboardDefinitions function.
 * StartTime and EndTime are optional parameters, they can be used to limit the list of definitions
 * to overlap the time window specified.
 */
EOS_STRUCT(EOS_Leaderboards_QueryLeaderboardDefinitionsOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDDEFINITIONS_API_LATEST. */
	int32_t ApiVersion;
	/** An optional POSIX timestamp for the leaderboard's start time, or EOS_LEADERBOARDS_TIME_UNDEFINED */
	int64_t StartTime;
	/** An optional POSIX timestamp for the leaderboard's end time, or EOS_LEADERBOARDS_TIME_UNDEFINED */
	int64_t EndTime;
	/**
	 * Product User ID for user who is querying definitions.
	 * Must be set when using a client policy that requires a valid logged in user.
	 * Not used for Dedicated Server where no user is available.
	 */
	EOS_ProductUserId LocalUserId;
));

/**
 * An enumeration of the different leaderboard aggregation types.
 */
EOS_ENUM(EOS_ELeaderboardAggregation,
	/** Minimum */
	EOS_LA_Min = 0,
	/** Maximum */
	EOS_LA_Max = 1,
	/** Sum */
	EOS_LA_Sum = 2,
	/** Latest */
	EOS_LA_Latest = 3
);

/** The most recent version of the EOS_Leaderboards_Definition struct. */
#define EOS_LEADERBOARDS_DEFINITION_API_LATEST 1

/**
 * Contains information about a single leaderboard definition
 */
EOS_STRUCT(EOS_Leaderboards_Definition, (
	/** API Version: Set this to EOS_LEADERBOARDS_DEFINITION_API_LATEST. */
	int32_t ApiVersion;
	/** Unique ID to identify leaderboard. */
	const char* LeaderboardId;
	/** Name of stat used to rank leaderboard. */
	const char* StatName;
	/** Aggregation used to sort leaderboard. */
	EOS_ELeaderboardAggregation Aggregation;
	/** The POSIX timestamp for the start time, or EOS_LEADERBOARDS_TIME_UNDEFINED. */
	int64_t StartTime;
	/** The POSIX timestamp for the end time, or EOS_LEADERBOARDS_TIME_UNDEFINED. */
	int64_t EndTime;
));

/** The most recent version of the EOS_Leaderboards_GetLeaderboardDefinitionCount API. */
#define EOS_LEADERBOARDS_GETLEADERBOARDDEFINITIONCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_GetLeaderboardDefinitionCount function.
 */
EOS_STRUCT(EOS_Leaderboards_GetLeaderboardDefinitionCountOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDDEFINITIONCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardDefinitionByIndex function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the leaderboard definition to retrieve from the cache */
	uint32_t LeaderboardIndex;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYLEADERBOARDID_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardIdOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYLEADERBOARDID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the leaderboard whose definition you want to copy from the cache */
	const char* LeaderboardId;
));

/**
 * Release the memory associated with a leaderboard definition. This must be called on data retrieved from
 * EOS_Leaderboards_CopyLeaderboardDefinitionByIndex or EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId.
 *
 * @param LeaderboardDefinition - The Leaderboard definition to release.
 *
 * @see EOS_Leaderboards_Definition
 * @see EOS_Leaderboards_CopyLeaderboardDefinitionByIndex
 * @see EOS_Leaderboards_CopyLeaderboardDefinitionByLeaderboardId
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_Definition_Release(EOS_Leaderboards_Definition* LeaderboardDefinition);

/**
 * Data containing the result information for a query leaderboard definitions request.
 */
EOS_STRUCT(EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Leaderboards_QueryLeaderboardDefinitions. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Leaderboards_QueryLeaderboardDefinitions
 * @param Data A EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallback, const EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo* Data);


/** The most recent version of the EOS_Leaderboards_UserScoresQueryStatInfo struct. */
#define EOS_LEADERBOARDS_USERSCORESQUERYSTATINFO_API_LATEST 1

/**
 * Contains information about a single stat to query with user scores.
 */
EOS_STRUCT(EOS_Leaderboards_UserScoresQueryStatInfo, (
	/** API Version: Set this to EOS_LEADERBOARDS_USERSCORESQUERYSTATINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the stat to query. */
	const char* StatName;
	/** Aggregation used to sort the cached user scores. */
	EOS_ELeaderboardAggregation Aggregation;
));

/** The most recent version of the EOS_Leaderboards_QueryLeaderboardUserScores struct. */
#define EOS_LEADERBOARDS_QUERYLEADERBOARDUSERSCORES_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_QueryLeaderboardUserScores function.
 */
EOS_STRUCT(EOS_Leaderboards_QueryLeaderboardUserScoresOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDUSERSCORES_API_LATEST. */
	int32_t ApiVersion;
	/** An array of Product User IDs indicating the users whose scores you want to retrieve */
	const EOS_ProductUserId* UserIds;
	/** The number of users included in query */
	uint32_t UserIdsCount;
	/** The stats to be collected, along with the sorting method to use when determining rank order for each stat */
	const EOS_Leaderboards_UserScoresQueryStatInfo* StatInfo;
	/** The number of stats to query */
	uint32_t StatInfoCount;
	/** An optional POSIX timestamp, or EOS_LEADERBOARDS_TIME_UNDEFINED; results will only include scores made after this time */
	int64_t StartTime;
	/** An optional POSIX timestamp, or EOS_LEADERBOARDS_TIME_UNDEFINED; results will only include scores made before this time */
	int64_t EndTime;
	/**
	 * Product User ID for user who is querying user scores.
	 * Must be set when using a client policy that requires a valid logged in user.
	 * Not used for Dedicated Server where no user is available.
	 */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Leaderboards_LeaderboardUserScore struct. */
#define EOS_LEADERBOARDS_LEADERBOARDUSERSCORE_API_LATEST 1

/**
 * Contains information about a single leaderboard user score
 */
EOS_STRUCT(EOS_Leaderboards_LeaderboardUserScore, (
	/** API Version: Set this to EOS_LEADERBOARDS_LEADERBOARDUSERSCORE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who got this score */
	EOS_ProductUserId UserId;
	/** Leaderboard score */
	int32_t Score;
));

/** The most recent version of the EOS_Leaderboards_GetLeaderboardUserScoreCount API. */
#define EOS_LEADERBOARDS_GETLEADERBOARDUSERSCORECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_GetLeaderboardUserScoreCount function.
 */
EOS_STRUCT(EOS_Leaderboards_GetLeaderboardUserScoreCountOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDUSERSCORECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** Name of stat used to rank leaderboard. */
	const char* StatName;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardUserScoreByIndex function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the sorted leaderboard user score to retrieve from the cache. */
	uint32_t LeaderboardUserScoreIndex;
	/** Name of the stat used to rank the leaderboard. */
	const char* StatName;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYUSERID_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardUserScoreByUserId function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to look for when copying leaderboard score data from the cache */
	EOS_ProductUserId UserId;
	/** The name of the stat that is used to rank this leaderboard */
	const char* StatName;
));

/**
 * Release the memory associated with leaderboard user score. This must be called on data retrieved from
 * EOS_Leaderboards_CopyLeaderboardUserScoreByIndex or EOS_Leaderboards_CopyLeaderboardUserScoreByUserId.
 *
 * @param LeaderboardUserScore - The Leaderboard user score to release.
 *
 * @see EOS_Leaderboards_LeaderboardUserScore
 * @see EOS_Leaderboards_CopyLeaderboardUserScoreByIndex
 * @see EOS_Leaderboards_CopyLeaderboardUserScoreByUserId
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_LeaderboardUserScore_Release(EOS_Leaderboards_LeaderboardUserScore* LeaderboardUserScore);

/**
 * Data containing the result information for a query leaderboard user scores request.
 */
EOS_STRUCT(EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Leaderboards_QueryLeaderboardUserScores. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Leaderboards_QueryLeaderboardUserScores
 * @param Data A EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallback, const EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo* Data);


/** The most recent version of the EOS_Leaderboards_QueryLeaderboardRanks struct. */
#define EOS_LEADERBOARDS_QUERYLEADERBOARDRANKS_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_QueryLeaderboardRanks function.
 *
 * @see EOS_Leaderboards_Definition
 */
EOS_STRUCT(EOS_Leaderboards_QueryLeaderboardRanksOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_QUERYLEADERBOARDRANKS_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the leaderboard whose information you want to retrieve. */
	const char* LeaderboardId;
	/**
	 * Product User ID for user who is querying ranks.
	 * Must be set when using a client policy that requires a valid logged in user.
	 * Not used for Dedicated Server where no user is available.
	 */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Leaderboards_LeaderboardRecord struct. */
#define EOS_LEADERBOARDS_LEADERBOARDRECORD_API_LATEST 2

/**
 * Contains information about a single leaderboard record
 */
EOS_STRUCT(EOS_Leaderboards_LeaderboardRecord, (
	/** API Version: Set this to EOS_LEADERBOARDS_LEADERBOARDRECORD_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID associated with this record */
	EOS_ProductUserId UserId;
	/** Sorted position on leaderboard */
	uint32_t Rank;
	/** Leaderboard score */
	int32_t Score;
	/** The latest display name seen for the user since they last time logged in. This is empty if the user does not have a display name set. */
	const char* UserDisplayName;
));

/** The most recent version of the EOS_Leaderboards_GetLeaderboardRecordCount API. */
#define EOS_LEADERBOARDS_GETLEADERBOARDRECORDCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Leaderboards_GetLeaderboardRecordCount function.
 */
EOS_STRUCT(EOS_Leaderboards_GetLeaderboardRecordCountOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_GETLEADERBOARDRECORDCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYINDEX_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardRecordByIndex function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the leaderboard record to retrieve from the cache */
	uint32_t LeaderboardRecordIndex;
));

/** The most recent version of the EOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions struct. */
#define EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYUSERID_API_LATEST 2

/**
 * Input parameters for the EOS_Leaderboards_CopyLeaderboardRecordByUserId function.
 */
EOS_STRUCT(EOS_Leaderboards_CopyLeaderboardRecordByUserIdOptions, (
	/** API Version: Set this to EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** Leaderboard data will be copied from the cache if it relates to the user matching this Product User ID */
	EOS_ProductUserId UserId;
));

/**
 * Release the memory associated with leaderboard record. This must be called on data retrieved from
 * EOS_Leaderboards_CopyLeaderboardRecordByIndex or EOS_Leaderboards_CopyLeaderboardRecordByUserId.
 *
 * @param LeaderboardRecord - The Leaderboard record to release.
 *
 * @see EOS_Leaderboards_LeaderboardRecord
 * @see EOS_Leaderboards_CopyLeaderboardRecordByIndex
 * @see EOS_Leaderboards_CopyLeaderboardRecordByUserId
 */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_LeaderboardRecord_Release(EOS_Leaderboards_LeaderboardRecord* LeaderboardRecord);

/**
 * Data containing the result information for a query leaderboard ranks request.
 */
EOS_STRUCT(EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Leaderboards_QueryLeaderboardRanks. */
	void* ClientData;
	/** The Leaderboard ID for the leaderboard that was queried. */
	const char* LeaderboardId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Leaderboards_QueryLeaderboardRanks
 * @param Data A EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallback, const EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo* Data);

#pragma pack(pop)

#include "eos_leaderboards_types_deprecated.inl"
```

`EAC_SDK/SDK/include/eos_leaderboards_types_deprecated.inl`:

```inl
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

/**
 * This file contains the deprecated types for EOS Leaderboards. In a future version, these types will be removed.
 */

#pragma pack(push, 8)

/** Do not use. Alias to the previous API name for backwards compatibility in compilation. */
EOS_DECLARE_FUNC(void) EOS_Leaderboards_LeaderboardDefinition_Release(EOS_Leaderboards_Definition* LeaderboardDefinition);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_lobby.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_lobby_types.h"

/**
 * The Lobby Interface is used to manage lobbies that provide a persistent connection between users and
 * notifications of data sharing/updates.  Lobbies may also be found by advertising and searching with the backend service.
 * All Lobby Interface calls take a handle of type EOS_HLobby as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetLobbyInterface function.
 *
 * @see EOS_Platform_GetLobbyInterface
 */

/**
 * Creates a lobby and adds the user to the lobby membership.  There is no data associated with the lobby at the start and can be added vis EOS_Lobby_UpdateLobbyModification
 *
 * If the lobby is successfully created with an RTC Room enabled, the lobby system will automatically join and maintain the connection to the RTC room as long as the
 * local user remains in the lobby. Applications can use the EOS_Lobby_GetRTCRoomName to get the name of the RTC Room associated with a lobby, which may be used with
 * many of the EOS_RTC_* suite of functions. This can be useful to: register for notifications for talking status; to mute or unmute the local user's audio output;
 * to block or unblock room participants; to set local audio device settings; and more.
 *
 * @param Options Required fields for the creation of a lobby such as a user count and its starting advertised state
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the create operation completes, either successfully or in error
 *
 * @return EOS_Success if the creation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_LimitExceeded if the number of allowed lobbies is exceeded
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_CreateLobby(EOS_HLobby Handle, const EOS_Lobby_CreateLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnCreateLobbyCallback CompletionDelegate);

/**
 * Destroy a lobby given a lobby ID
 *
 * @param Options Structure containing information about the lobby to be destroyed
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the destroy operation completes, either successfully or in error
 *
 * @return EOS_Success if the destroy completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_AlreadyPending if the lobby is already marked for destroy
 *         EOS_NotFound if the lobby to be destroyed does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_DestroyLobby(EOS_HLobby Handle, const EOS_Lobby_DestroyLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnDestroyLobbyCallback CompletionDelegate);

/**
 * Join a lobby, creating a local instance under a given lobby ID.  Backend will validate various conditions to make sure it is possible to join the lobby.
 *
 * If the lobby is successfully join has an RTC Room enabled, the lobby system will automatically join and maintain the connection to the RTC room as long as the
 * local user remains in the lobby. Applications can use the EOS_Lobby_GetRTCRoomName to get the name of the RTC Room associated with a lobby, which may be used with
 * many of the EOS_RTC_* suite of functions. This can be useful to: register for notifications for talking status; to mute or unmute the local user's audio output;
 * to block or unblock room participants; to set local audio device settings; and more.
 *
 * @param Options Structure containing information about the lobby to be joined
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the join operation completes, either successfully or in error
 *
 * @return EOS_Success if the destroy completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_JoinLobby(EOS_HLobby Handle, const EOS_Lobby_JoinLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnJoinLobbyCallback CompletionDelegate);

/**
 * This is a special case of EOS_Lobby_JoinLobby.  It should only be used if the lobby has had Join-by-ID enabled.
 * Additionally, Join-by-ID should only be enabled to support native invites on an integrated platform.
 *
 * @param Options Structure containing information about the lobby to be joined
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the join operation completes, either successfully or in error
 *
 * @return EOS_Success if the destroy completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *
 * @see EOS_Lobby_JoinLobby
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_JoinLobbyById(EOS_HLobby Handle, const EOS_Lobby_JoinLobbyByIdOptions* Options, void* ClientData, const EOS_Lobby_OnJoinLobbyByIdCallback CompletionDelegate);

/**
 * Leave a lobby given a lobby ID
 *
 * If the lobby you are leaving had an RTC Room enabled, leaving the lobby will also automatically leave the RTC room.
 *
 * @param Options Structure containing information about the lobby to be left
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the leave operation completes, either successfully or in error
 *
 * @return EOS_Success if the leave completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_AlreadyPending if the lobby is already marked for leave
 *         EOS_NotFound if a lobby to be left does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_LeaveLobby(EOS_HLobby Handle, const EOS_Lobby_LeaveLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnLeaveLobbyCallback CompletionDelegate);

/**
 * Creates a lobby modification handle (EOS_HLobbyModification). The lobby modification handle is used to modify an existing lobby and can be applied with EOS_Lobby_UpdateLobby.
 * The EOS_HLobbyModification must be released by calling EOS_LobbyModification_Release once it is no longer needed.
 *
 * @param Options Required fields such as lobby ID
 * @param OutLobbyModificationHandle Pointer to a Lobby Modification Handle only set if successful
 * @return EOS_Success if we successfully created the Lobby Modification Handle pointed at in OutLobbyModificationHandle, or an error result if the input data was invalid
 *		   EOS_InvalidParameters if any of the options are incorrect
 *
 * @see EOS_LobbyModification_Release
 * @see EOS_Lobby_UpdateLobby
 * @see EOS_HLobbyModification
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_UpdateLobbyModification(EOS_HLobby Handle, const EOS_Lobby_UpdateLobbyModificationOptions* Options, EOS_HLobbyModification* OutLobbyModificationHandle);

/**
 * Update a lobby given a lobby modification handle created by EOS_Lobby_UpdateLobbyModification
 *
 * @param Options Structure containing information about the lobby to be updated
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the update operation completes, either successfully or in error
 *
 * @return EOS_Success if the update completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Lobby_NotOwner if the lobby modification contains modifications that are only allowed by the owner
 *         EOS_NotFound if the lobby to update does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_UpdateLobby(EOS_HLobby Handle, const EOS_Lobby_UpdateLobbyOptions* Options, void* ClientData, const EOS_Lobby_OnUpdateLobbyCallback CompletionDelegate);

/**
 * Promote an existing member of the lobby to owner, allowing them to make lobby data modifications
 *
 * @param Options Structure containing information about the lobby and member to be promoted
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the promotion operation completes, either successfully or in error
 *
 * @return EOS_Success if the promote completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Lobby_NotOwner if the calling user is not the owner of the lobby
 *         EOS_NotFound if the lobby of interest does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_PromoteMember(EOS_HLobby Handle, const EOS_Lobby_PromoteMemberOptions* Options, void* ClientData, const EOS_Lobby_OnPromoteMemberCallback CompletionDelegate);

/**
 * Kick an existing member from the lobby
 *
 * @param Options Structure containing information about the lobby and member to be kicked
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the kick operation completes, either successfully or in error
 *
 * @return EOS_Success if the kick completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Lobby_NotOwner if the calling user is not the owner of the lobby
 *         EOS_NotFound if a lobby of interest does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_KickMember(EOS_HLobby Handle, const EOS_Lobby_KickMemberOptions* Options, void* ClientData, const EOS_Lobby_OnKickMemberCallback CompletionDelegate);

/**
 * Hard mute an existing member in the lobby, can't speak but can hear other members of the lobby
 *
 * @param Options Structure containing information about the lobby and member to be hard muted
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the hard mute operation completes, either successfully or in error
 *
 * @return EOS_Success if the hard mute completes successfully
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Invalid_ProductUserID if a target user is incorrect
 *         EOS_NotFound if lobby or target user cannot be found
 *         EOS_Lobby_VoiceNotEnabled if lobby has no voice enabled
 *         EOS_Lobby_NotOwner if the calling user is not the owner of the lobby
 *         EOS_NotFound if a lobby of interest does not exist
 *         EOS_AlreadyPending if the user is already marked for hard mute
 *         EOS_TooManyRequests if there are too many requests
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_HardMuteMember(EOS_HLobby Handle, const EOS_Lobby_HardMuteMemberOptions* Options, void* ClientData, const EOS_Lobby_OnHardMuteMemberCallback CompletionDelegate);

/**
 * Register to receive notifications when a lobby owner updates the attributes associated with the lobby.
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifyLobbyUpdateReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyUpdateReceived(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyUpdateReceivedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyUpdateReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a lobby changes its data.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyUpdateReceived(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a lobby member updates the attributes associated with themselves inside the lobby.
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifyLobbyMemberUpdateReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyMemberUpdateReceived(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyMemberUpdateReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when lobby members change their data.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyMemberUpdateReceived(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about the changing status of lobby members.
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifyLobbyMemberStatusReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyMemberStatusReceived(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyMemberStatusReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when lobby members status change.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyMemberStatusReceived(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Send an invite to another user.  User must be a member of the lobby or else the call will fail
 *
 * @param Options Structure containing information about the lobby and user to invite
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the send invite operation completes, either successfully or in error
 *
 * @return EOS_Success if the send invite completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the lobby to send the invite from does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_SendInvite(EOS_HLobby Handle, const EOS_Lobby_SendInviteOptions* Options, void* ClientData, const EOS_Lobby_OnSendInviteCallback CompletionDelegate);

/**
 * Reject an invite from another user.
 *
 * @param Options Structure containing information about the invite to reject
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the reject invite operation completes, either successfully or in error
 *
 * @return EOS_Success if the invite rejection completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the invite does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RejectInvite(EOS_HLobby Handle, const EOS_Lobby_RejectInviteOptions* Options, void* ClientData, const EOS_Lobby_OnRejectInviteCallback CompletionDelegate);

/**
 * Retrieve all existing invites for a single user
 *
 * @param Options Structure containing information about the invites to query
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the query invites operation completes, either successfully or in error
 *
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_QueryInvites(EOS_HLobby Handle, const EOS_Lobby_QueryInvitesOptions* Options, void* ClientData, const EOS_Lobby_OnQueryInvitesCallback CompletionDelegate);

/**
 * Get the number of known invites for a given user
 *
 * @param Options the Options associated with retrieving the current invite count
 *
 * @return number of known invites for a given user or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Lobby_GetInviteCount(EOS_HLobby Handle, const EOS_Lobby_GetInviteCountOptions* Options);

/**
 * Retrieve an invite ID from a list of active invites for a given user
 *
 * @param Options Structure containing the input parameters
 *
 * @return EOS_Success if the input is valid and an invite ID was returned
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the invite doesn't exist
 *
 * @see EOS_Lobby_GetInviteCount
 * @see EOS_Lobby_CopyLobbyDetailsHandleByInviteId
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_GetInviteIdByIndex(EOS_HLobby Handle, const EOS_Lobby_GetInviteIdByIndexOptions* Options, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Create a lobby search handle.  This handle may be modified to include various search parameters.
 * Searching is possible in three methods, all mutually exclusive
 * - set the lobby ID to find a specific lobby
 * - set the target user ID to find a specific user
 * - set lobby parameters to find an array of lobbies that match the search criteria
 *
 * @param Options Structure containing required parameters such as the maximum number of search results
 * @param OutLobbySearchHandle The new search handle or null if there was an error creating the search handle
 *
 * @return EOS_Success if the search creation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_CreateLobbySearch(EOS_HLobby Handle, const EOS_Lobby_CreateLobbySearchOptions* Options, EOS_HLobbySearch* OutLobbySearchHandle);

/**
 * Register to receive notifications about lobby invites sent to local users.
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifyLobbyInviteReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyInviteReceived(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyInviteReceivedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyInviteReceivedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user receives a lobby invitation.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyInviteReceived(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about lobby invites accepted by local user via the overlay.
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifyLobbyInviteAccepted when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyInviteAccepted(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyInviteAcceptedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyInviteAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a lobby invitation via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyInviteAccepted(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about lobby invites rejected by local user.
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifyLobbyInviteRejected when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLobbyInviteRejected(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLobbyInviteRejectedOptions* Options, void* ClientData, const EOS_Lobby_OnLobbyInviteRejectedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user rejects a lobby invitation via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLobbyInviteRejected(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about lobby "JOIN" performed by local user (when no invite) via the overlay.
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifyJoinLobbyAccepted when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyJoinLobbyAccepted(EOS_HLobby Handle, const EOS_Lobby_AddNotifyJoinLobbyAcceptedOptions* Options, void* ClientData, const EOS_Lobby_OnJoinLobbyAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a lobby invitation via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyJoinLobbyAccepted(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about a lobby "INVITE" performed by a local user via the overlay.
 * This is only needed when a configured integrated platform has EOS_IPMF_DisableSDKManagedSessions set.  The EOS SDK will
 * then use the state of EOS_IPMF_PreferEOSIdentity and EOS_IPMF_PreferIntegratedIdentity to determine when the NotificationFn is
 * called.
 *
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifySendLobbyNativeInviteRequested when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 *
 * @see EOS_IPMF_DisableSDKManagedSessions
 * @see EOS_IPMF_PreferEOSIdentity
 * @see EOS_IPMF_PreferIntegratedIdentity
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifySendLobbyNativeInviteRequested(EOS_HLobby Handle, const EOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions* Options, void* ClientData, const EOS_Lobby_OnSendLobbyNativeInviteRequestedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user requests a send invite via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifySendLobbyNativeInviteRequested(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * EOS_Lobby_CopyLobbyDetailsHandleByInviteId is used to immediately retrieve a handle to the lobby information from after notification of an invite
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsHandle, must be passed to EOS_LobbyDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsHandle out parameter used to receive the lobby handle
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyDetailsHandle
 *         EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound If the invite ID cannot be found
 *
 * @see EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions
 * @see EOS_LobbyDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_CopyLobbyDetailsHandleByInviteId(EOS_HLobby Handle, const EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions* Options, EOS_HLobbyDetails* OutLobbyDetailsHandle);

/**
 * EOS_Lobby_CopyLobbyDetailsHandleByUiEventId is used to immediately retrieve a handle to the lobby information from after notification of an join game
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsHandle, must be passed to EOS_LobbyDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsHandle out parameter used to receive the lobby handle
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyDetailsHandle
 *         EOS_InvalidParameters if you pass an invalid ui event ID
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound If the invite ID cannot be found
 *
 * @see EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions
 * @see EOS_LobbyDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_CopyLobbyDetailsHandleByUiEventId(EOS_HLobby Handle, const EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions* Options, EOS_HLobbyDetails* OutLobbyDetailsHandle);

/**
 * Create a handle to an existing lobby.
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsHandle, must be passed to EOS_LobbyDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing information about the lobby to retrieve
 * @param OutLobbyDetailsHandle The new active lobby handle or null if there was an error
 *
 * @return EOS_Success if the lobby handle was created successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the lobby doesn't exist
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_CopyLobbyDetailsHandle(EOS_HLobby Handle, const EOS_Lobby_CopyLobbyDetailsHandleOptions* Options, EOS_HLobbyDetails* OutLobbyDetailsHandle);

/**
 * Get the name of the RTC room associated with a specific lobby a local user belongs to.
 *
 * This value can be used whenever you need a RoomName value in the RTC_* suite of functions. RTC Room Names must not be used with
 * EOS_RTC_JoinRoom, EOS_RTC_LeaveRoom, or EOS_RTC_AddNotifyDisconnected. Doing so will return EOS_AccessDenied or
 * EOS_INVALID_NOTIFICATIONID if used with those functions.
 *
 * This function will only succeed when called on a lobby the local user is currently a member of.
 *
 * @param Options Structure containing information about the RTC room name to retrieve
 * @param OutBuffer The buffer to store the null-terminated room name string within
 * @param InOutBufferLength In: The maximum amount of writable chars in OutBuffer, Out: The minimum amount of chars needed in OutBuffer to store the RTC room name (including the null-terminator)
 *
 * @return EOS_Success if a room exists for the specified lobby, there was enough space in OutBuffer, and the name was written successfully
 *         EOS_NotFound if the lobby does not exist
 *         EOS_Disabled if the lobby exists, but did not have the RTC Room feature enabled when created
 *         EOS_InvalidParameters if you pass a null pointer on invalid length for any of the parameters
 *         EOS_LimitExceeded The OutBuffer is not large enough to receive the room name. InOutBufferLength contains the required minimum length to perform the operation successfully.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_GetRTCRoomName(EOS_HLobby Handle, const EOS_Lobby_GetRTCRoomNameOptions* Options, char* OutBuffer, uint32_t* InOutBufferLength);

/**
 * Get the current connection status of the RTC Room for a lobby.
 *
 * The RTC Room connection status is independent of the lobby connection status, however the lobby system will attempt to keep
 * them consistent, automatically connecting to the RTC room after joining a lobby which has an associated RTC room and disconnecting
 * from the RTC room when a lobby is left or disconnected.
 *
 * This function will only succeed when called on a lobby the local user is currently a member of.
 *
 * @param Options Structure containing information about the lobby to query the RTC Room connection status for
 * @param bOutIsConnected If the result is EOS_Success, this will be set to EOS_TRUE if we are connected, or EOS_FALSE if we are not yet connected.
 *
 * @return EOS_Success if we are connected to the specified lobby, the input options and parameters were valid and we were able to write to bOutIsConnected successfully.
 *         EOS_NotFound if the lobby doesn't exist
 *         EOS_Disabled if the lobby exists, but did not have the RTC Room feature enabled when created
 *         EOS_InvalidParameters if bOutIsConnected is NULL, or any other parameters are NULL or invalid
 *
 * @see EOS_Lobby_AddNotifyRTCRoomConnectionChanged
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_IsRTCRoomConnected(EOS_HLobby Handle, const EOS_Lobby_IsRTCRoomConnectedOptions* Options, EOS_Bool* bOutIsConnected);

/**
 * Register to receive notifications of when the RTC Room for a particular lobby has a connection status change.
 *
 * The RTC Room connection status is independent of the lobby connection status, however the lobby system will attempt to keep
 * them consistent, automatically connecting to the RTC room after joining a lobby which has an associated RTC room and disconnecting
 * from the RTC room when a lobby is left or disconnected.
 *
 * This notification is entirely informational and requires no action in response by the application. If the connected status is offline
 * (bIsConnected is EOS_FALSE), the connection will automatically attempt to reconnect. The purpose of this notification is to allow
 * applications to show the current connection status of the RTC room when the connection is not established.
 *
 * Unlike EOS_RTC_AddNotifyDisconnected, EOS_RTC_LeaveRoom should not be called when the RTC room is disconnected.
 *
 * This function will only succeed when called on a lobby the local user is currently a member of.
 *
 * @param Options Structure containing information about the lobby to receive updates about
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn The function to call if the RTC Room's connection status changes
 *
 * @return A valid notification ID if the NotificationFn was successfully registered, or EOS_INVALID_NOTIFICATIONID if the input was invalid, the lobby did not exist, or the lobby did not have an RTC room.
 *
 * @see EOS_Lobby_RemoveNotifyRTCRoomConnectionChanged
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyRTCRoomConnectionChanged(EOS_HLobby Handle, const EOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions* Options, void* ClientData, const EOS_Lobby_OnRTCRoomConnectionChangedCallback NotificationFn);

/**
 * Unregister from receiving notifications when an RTC Room's connection status changes.
 *
 * This should be called when the local user is leaving a lobby.
 *
 * @param InId Handle representing the registered callback
 *
 * @see EOS_Lobby_AddNotifyRTCRoomConnectionChanged
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyRTCRoomConnectionChanged(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * Get the Connection string for an EOS lobby. The connection string describes the presence of a player in terms of game state.
 * Xbox platforms expect titles to embed this into their MultiplayerActivity at creation.
 * When present, the SDK will use this value to populate session presence in the social overlay and facilitate platform invitations.
 *
 * @param Options Structure containing the input parameters. API version, the LobbyID of the lobby to generate the string from and the PUID of the requesting user.
 * @param OutBuffer The buffer to store the null-terminated ConnectString within
 * @param InOutBufferLength In: The maximum amount of writable chars in OutBuffer see EOS_LOBBY_GETCONNECTSTRING_BUFFER_SIZE, Out: The minimum amount of chars needed in OutBuffer to store the ConnectString (including the null-terminator). May be set to zero depending on the error result.
 *
 * @return EOS_Success if retrieving the string was successful.
 *         EOS_InvalidParameters if the OutBuffer or InOutBufferLength are null.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_NotFound if no lobby is found matching the LobbyID and PUID provided.
 *         EOS_LimitExceeded if the provided InOutBufferLength is too small to contain the resulting string.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_GetConnectString(EOS_HLobby Handle, const EOS_Lobby_GetConnectStringOptions* Options, char* OutBuffer, uint32_t* InOutBufferLength);

/**
 * Parse the ConnectString for an EOS lobby invitation to extract just the lobby ID.
 * Used for joining a lobby from a connection string (as generated by GetConnectString) found in a platform invitation or presence.
 *
 * @param Options Structure containing the input parameters. API version and ConnectString.
 * @param OutBuffer The buffer to store the null-terminated lobby ID within
 * @param InOutBufferLength In: The maximum amount of writable chars in OutBuffer see EOS_LOBBY_PARSECONNECTSTRING_BUFFER_SIZE, Out: The minimum amount of chars needed in OutBuffer to store the LobbyID (including the null-terminator). May be set to zero depending on the error result.
 *
 * @return EOS_Success if retrieving the string was successful.
 *         EOS_InvalidParameters if the OutBuffer or InOutBufferLength are null.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_LimitExceeded if the provided InOutBufferLength is too small to contain the resulting string.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Lobby_ParseConnectString(EOS_HLobby Handle, const EOS_Lobby_ParseConnectStringOptions* Options, char* OutBuffer, uint32_t* InOutBufferLength);

/**
 * Register to receive notifications about leave lobby requests performed by the local user via the overlay.
 * When user requests to leave the lobby in the social overlay, the SDK does not automatically leave the lobby, it is up to the game to perform any necessary cleanup and call the EOS_Lobby_LeaveLobby method using the lobbyId sent in the notification function.
 * @note If the returned NotificationId is valid, you must call EOS_Lobby_RemoveNotifyLeaveLobbyRequested when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Lobby_AddNotifyLeaveLobbyRequested(EOS_HLobby Handle, const EOS_Lobby_AddNotifyLeaveLobbyRequestedOptions* Options, void* ClientData, const EOS_Lobby_OnLeaveLobbyRequestedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user performs a leave lobby action via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Lobby_RemoveNotifyLeaveLobbyRequested(EOS_HLobby Handle, EOS_NotificationId InId);

/**
 * To modify lobbies or the lobby member data, you must call EOS_Lobby_UpdateLobbyModification to create a Lobby Modification handle. To modify that handle, call
 * EOS_HLobbyModification methods. Once you are finished, call EOS_Lobby_UpdateLobby with your handle. You must then release your Lobby Modification
 * handle by calling EOS_LobbyModification_Release.
 */

/**
 * Set the bucket ID associated with this lobby.
 * Values such as region, game mode, etc can be combined here depending on game need.
 * Setting this is strongly recommended to improve search performance.
 *
 * @param Options Options associated with the bucket ID of the lobby
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_InvalidParameters if the bucket ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetBucketId(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetBucketIdOptions* Options);

/**
 * Set the permissions associated with this lobby.
 * The permissions range from "public" to "invite only" and are described by EOS_ELobbyPermissionLevel
 *
 * @param Options Options associated with the permission level of the lobby
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetPermissionLevel(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetPermissionLevelOptions* Options);

/**
 * Set the maximum number of members allowed in this lobby.
 * When updating the lobby, it is not possible to reduce this number below the current number of existing members
 *
 * @param Options Options associated with max number of members in this lobby
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetMaxMembers(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetMaxMembersOptions* Options);

/**
 * Allows enabling or disabling invites for this lobby.
 * The lobby will also need to have `bPresenceEnabled` true.
 *
 * @param Options Options associated with invites allowed flag for this lobby.
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetInvitesAllowed(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetInvitesAllowedOptions* Options);

/**
 * Associate an attribute with this lobby
 * An attribute is something may be public or private with the lobby.
 * If public, it can be queried for in a search, otherwise the data remains known only to lobby members
 *
 * @param Options Options to set the attribute and its visibility state
 *
 * @return EOS_Success if setting this parameter was successful
 *		   EOS_InvalidParameters if the attribute is missing information or otherwise invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_AddAttribute(EOS_HLobbyModification Handle, const EOS_LobbyModification_AddAttributeOptions* Options);

/**
 * Remove an attribute associated with the lobby
 *
 * @param Options Specify the key of the attribute to remove
 *
 * @return EOS_Success if removing this parameter was successful
 *		   EOS_InvalidParameters if the key is null or empty
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_RemoveAttribute(EOS_HLobbyModification Handle, const EOS_LobbyModification_RemoveAttributeOptions* Options);

/**
 * Associate an attribute with a member of the lobby
 * Lobby member data is always private to the lobby
 *
 * @param Options Options to set the attribute and its visibility state
 *
 * @return EOS_Success if setting this parameter was successful
 *		   EOS_InvalidParameters if the attribute is missing information or otherwise invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_AddMemberAttribute(EOS_HLobbyModification Handle, const EOS_LobbyModification_AddMemberAttributeOptions* Options);

/**
 * Remove an attribute associated with of member of the lobby
 *
 * @param Options Specify the key of the member attribute to remove
 *
 * @return EOS_Success if removing this parameter was successful
 *		   EOS_InvalidParameters if the key is null or empty
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_RemoveMemberAttribute(EOS_HLobbyModification Handle, const EOS_LobbyModification_RemoveMemberAttributeOptions* Options);

/**
 * Set the Allowed Platform IDs for the lobby
 *
 * @param Options Options associated with allowed Platform IDs for this lobby
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_InvalidParameters if the AllowedPlatformIds array is null but the count is 0 or if the count is greater than 0 and the array is null.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyModification_SetAllowedPlatformIds(EOS_HLobbyModification Handle, const EOS_LobbyModification_SetAllowedPlatformIdsOptions* Options);

#include "eos_lobby_types.h"

/**
 * A "read only" representation of an existing lobby that games interact with externally.
 * Both the lobby and lobby search interfaces interface use this common class for lobby management and search results
 */

/**
 * Get the product user ID of the current owner for a given lobby
 *
 * @param Options Structure containing the input parameters
 *
 * @return the product user ID for the lobby owner or null if the input parameters are invalid
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_LobbyDetails_GetLobbyOwner(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetLobbyOwnerOptions* Options);

/**
 * EOS_LobbyDetails_CopyInfo is used to immediately retrieve a copy of lobby information from a given source such as a existing lobby or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsInfo, must be passed to EOS_LobbyDetails_Info_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsInfo Out parameter used to receive the EOS_LobbyDetails_Info structure.
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyDetailsInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_LobbyDetails_Info
 * @see EOS_LobbyDetails_CopyInfoOptions
 * @see EOS_LobbyDetails_Info_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyInfo(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyInfoOptions* Options, EOS_LobbyDetails_Info ** OutLobbyDetailsInfo);

/**
 * EOS_LobbyDetails_CopyMemberInfo is used to immediately retrieve a copy of lobby member information from an existing lobby.
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsMemberInfo, must be passed to EOS_LobbyDetails_MemberInfo_Release to release the memory associated with it.
 * Note: this information is only available if you are actively in the lobby.  It is not available for search results.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsMemberInfo Out parameter used to receive the EOS_LobbyDetails_Info structure.
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyMemberDetailsInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if searching for a target user ID returns no results
 *
 * @see EOS_LobbyDetails_MemberInfo
 * @see EOS_LobbyDetails_CopyMemberInfoOptions
 * @see EOS_LobbyDetails_MemberInfo_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyMemberInfo(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyMemberInfoOptions* Options, EOS_LobbyDetails_MemberInfo ** OutLobbyDetailsMemberInfo);

/**
 * Get the number of attributes associated with this lobby
 *
 * @param Options the Options associated with retrieving the attribute count
 *
 * @return number of attributes on the lobby or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_LobbyDetails_GetAttributeCount(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetAttributeCountOptions* Options);

/**
 * EOS_LobbyDetails_CopyAttributeByIndex is used to immediately retrieve a copy of a lobby attribute from a given source such as a existing lobby or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutAttribute, must be passed to EOS_Lobby_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutAttribute Out parameter used to receive the EOS_Lobby_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_Attribute
 * @see EOS_LobbyDetails_CopyAttributeByIndexOptions
 * @see EOS_Lobby_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyAttributeByIndex(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyAttributeByIndexOptions* Options, EOS_Lobby_Attribute ** OutAttribute);

/**
 * EOS_LobbyDetails_CopyAttributeByKey is used to immediately retrieve a copy of a lobby attribute from a given source such as a existing lobby or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutAttribute, must be passed to EOS_Lobby_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutAttribute Out parameter used to receive the EOS_Lobby_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_Attribute
 * @see EOS_LobbyDetails_CopyAttributeByKeyOptions
 * @see EOS_Lobby_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyAttributeByKey(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyAttributeByKeyOptions* Options, EOS_Lobby_Attribute ** OutAttribute);

/**
 * Get the number of members associated with this lobby
 *
 * @param Options the Options associated with retrieving the member count
 *
 * @return number of members in the existing lobby or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_LobbyDetails_GetMemberCount(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetMemberCountOptions* Options);

/**
 * EOS_LobbyDetails_GetMemberByIndex is used to immediately retrieve individual members registered with a lobby.
 * Note: this information is only available if you are actively in the lobby.  It is not available for search results.
 *
 * @param Options Structure containing the input parameters
 *
 * @return the product user ID for the registered member at a given index or null if that index is invalid
 *
 * @see EOS_LobbyDetails_GetMemberCount
 * @see EOS_LobbyDetails_GetMemberByIndexOptions
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_LobbyDetails_GetMemberByIndex(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetMemberByIndexOptions* Options);

/**
 * EOS_LobbyDetails_GetMemberAttributeCount is used to immediately retrieve the attribute count for members in a lobby.
 * Note: this information is only available if you are actively in the lobby.  It is not available for search results.
 *
 * @param Options Structure containing the input parameters
 *
 * @return the number of attributes associated with a given lobby member or 0 if that member is invalid
 *
 * @see EOS_LobbyDetails_GetMemberCount
 * @see EOS_LobbyDetails_GetMemberAttributeCountOptions
 */
EOS_DECLARE_FUNC(uint32_t) EOS_LobbyDetails_GetMemberAttributeCount(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_GetMemberAttributeCountOptions* Options);

/**
 * EOS_LobbyDetails_CopyMemberAttributeByIndex is used to immediately retrieve a copy of a lobby member attribute from an existing lobby.
 * If the call returns an EOS_Success result, the out parameter, OutAttribute, must be passed to EOS_Lobby_Attribute_Release to release the memory associated with it.
 * Note: this information is only available if you are actively in the lobby.  It is not available for search results.
 *
 * @param Options Structure containing the input parameters
 * @param OutAttribute Out parameter used to receive the EOS_Lobby_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_Attribute
 * @see EOS_LobbyDetails_CopyMemberAttributeByIndexOptions
 * @see EOS_Lobby_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyMemberAttributeByIndex(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyMemberAttributeByIndexOptions* Options, EOS_Lobby_Attribute ** OutAttribute);

/**
 * EOS_LobbyDetails_CopyMemberAttributeByKey is used to immediately retrieve a copy of a lobby member attribute from an existing lobby.
 * If the call returns an EOS_Success result, the out parameter, OutAttribute, must be passed to EOS_Lobby_Attribute_Release to release the memory associated with it.
 * Note: this information is only available if you are actively in the lobby.  It is not available for search results.
 *
 * @param Options Structure containing the input parameters
 * @param OutAttribute Out parameter used to receive the EOS_Lobby_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_Attribute
 * @see EOS_LobbyDetails_CopyMemberAttributeByKeyOptions
 * @see EOS_Lobby_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbyDetails_CopyMemberAttributeByKey(EOS_HLobbyDetails Handle, const EOS_LobbyDetails_CopyMemberAttributeByKeyOptions* Options, EOS_Lobby_Attribute ** OutAttribute);

#include "eos_lobby_types.h"

/**
 * Class responsible for the creation, setup, and execution of a search query.
 * Search parameters are defined, the query is executed and the search results are returned within this object
 */

/**
 * Find lobbies matching the search criteria setup via this lobby search handle.
 * When the operation completes, this handle will have the search results that can be parsed
 *
 * @param Options Structure containing information about the search criteria to use
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the search operation completes, either successfully or in error
 *
 * @return EOS_Success if the find operation completes successfully
 *         EOS_NotFound if searching for an individual lobby by lobby ID or target user ID returns no results
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_LobbySearch_Find(EOS_HLobbySearch Handle, const EOS_LobbySearch_FindOptions* Options, void* ClientData, const EOS_LobbySearch_OnFindCallback CompletionDelegate);

/**
 * Set a lobby ID to find and will return at most one search result.  Setting TargetUserId or SearchParameters will result in EOS_LobbySearch_Find failing
 *
 * @param Options A specific lobby ID for which to search
 *
 * @return EOS_Success if setting this lobby ID was successful
 *         EOS_InvalidParameters if the lobby ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_SetLobbyId(EOS_HLobbySearch Handle, const EOS_LobbySearch_SetLobbyIdOptions* Options);

/**
 * Set a target user ID to find.  Setting LobbyId or SearchParameters will result in EOS_LobbySearch_Find failing
 * @note a search result will only be found if this user is in a public lobby
 *
 * @param Options a specific target user ID to find
 *
 * @return EOS_Success if setting this target user ID was successful
 *         EOS_InvalidParameters if the target user ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_SetTargetUserId(EOS_HLobbySearch Handle, const EOS_LobbySearch_SetTargetUserIdOptions* Options);

/**
 * Add a parameter to an array of search criteria combined via an implicit AND operator.  Setting LobbyId or TargetUserId will result in EOS_LobbySearch_Find failing
 *
 * @param Options a search parameter and its comparison op
 *
 * @return EOS_Success if setting this search parameter was successful
 *         EOS_InvalidParameters if the search criteria is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Lobby_AttributeData
 * @see EOS_EComparisonOp
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_SetParameter(EOS_HLobbySearch Handle, const EOS_LobbySearch_SetParameterOptions* Options);

/**
 * Remove a parameter from the array of search criteria.
 *
 * @params Options a search parameter key name to remove
 *
 * @return EOS_Success if removing this search parameter was successful
 *         EOS_InvalidParameters if the search key is invalid or null
 *		   EOS_NotFound if the parameter was not a part of the search criteria
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_RemoveParameter(EOS_HLobbySearch Handle, const EOS_LobbySearch_RemoveParameterOptions* Options);

/**
 * Set the maximum number of search results to return in the query, can't be more than EOS_LOBBY_MAX_SEARCH_RESULTS
 *
 * @param Options maximum number of search results to return in the query
 *
 * @return EOS_Success if setting the max results was successful
 *         EOS_InvalidParameters if the number of results requested is invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_SetMaxResults(EOS_HLobbySearch Handle, const EOS_LobbySearch_SetMaxResultsOptions* Options);

/**
 * Get the number of search results found by the search parameters in this search
 *
 * @param Options Options associated with the search count
 *
 * @return return the number of search results found by the query or 0 if search is not complete
 */
EOS_DECLARE_FUNC(uint32_t) EOS_LobbySearch_GetSearchResultCount(EOS_HLobbySearch Handle, const EOS_LobbySearch_GetSearchResultCountOptions* Options);

/**
 * EOS_LobbySearch_CopySearchResultByIndex is used to immediately retrieve a handle to the lobby information from a given search result.
 * If the call returns an EOS_Success result, the out parameter, OutLobbyDetailsHandle, must be passed to EOS_LobbyDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutLobbyDetailsHandle out parameter used to receive the lobby details handle
 *
 * @return EOS_Success if the information is available and passed out in OutLobbyDetailsHandle
 *         EOS_InvalidParameters if you pass an invalid index or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_LobbySearch_CopySearchResultByIndexOptions
 * @see EOS_LobbyDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_LobbySearch_CopySearchResultByIndex(EOS_HLobbySearch Handle, const EOS_LobbySearch_CopySearchResultByIndexOptions* Options, EOS_HLobbyDetails* OutLobbyDetailsHandle);

```

`EAC_SDK/SDK/include/eos_lobby_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"
#include "eos_ui_types.h"

#pragma pack(push, 8)

/** Handle to the lobby interface */
EXTERN_C typedef struct EOS_LobbyHandle* EOS_HLobby;
/** Handle to a lobby modification object */
EXTERN_C typedef struct EOS_LobbyModificationHandle* EOS_HLobbyModification;
/** Handle to a single lobby */
EXTERN_C typedef struct EOS_LobbyDetailsHandle* EOS_HLobbyDetails;
/** Handle to the calls responsible for creating a search object */
EXTERN_C typedef struct EOS_LobbySearchHandle* EOS_HLobbySearch;

EOS_DECLARE_FUNC(void) EOS_LobbyModification_Release(EOS_HLobbyModification LobbyModificationHandle);

/**
 * Release the memory associated with a single lobby. This must be called on data retrieved from EOS_LobbySearch_CopySearchResultByIndex.
 *
 * @param LobbyHandle - The lobby handle to release
 *
 * @see EOS_LobbySearch_CopySearchResultByIndex
 */
EOS_DECLARE_FUNC(void) EOS_LobbyDetails_Release(EOS_HLobbyDetails LobbyHandle);

/**
 * Release the memory associated with a lobby search. This must be called on data retrieved from EOS_Lobby_CreateLobbySearch.
 *
 * @param LobbySearchHandle - The lobby search handle to release
 *
 * @see EOS_Lobby_CreateLobbySearch
 */
EOS_DECLARE_FUNC(void) EOS_LobbySearch_Release(EOS_HLobbySearch LobbySearchHandle);

/** All lobbies are referenced by a unique lobby ID */
EXTERN_C typedef const char* EOS_LobbyId;

#define EOS_LOBBY_MAX_LOBBIES 16
#define EOS_LOBBY_MAX_LOBBY_MEMBERS 64
#define EOS_LOBBY_MAX_SEARCH_RESULTS 200

/** Minimum number of characters allowed in the lobby id override */
#define EOS_LOBBY_MIN_LOBBYIDOVERRIDE_LENGTH 4
/** Maximum number of characters allowed in the lobby id override */
#define EOS_LOBBY_MAX_LOBBYIDOVERRIDE_LENGTH 60

/** Maximum number of attributes allowed on the lobby */
#define EOS_LOBBYMODIFICATION_MAX_ATTRIBUTES 64
/** Maximum length of the name of the attribute associated with the lobby */
#define EOS_LOBBYMODIFICATION_MAX_ATTRIBUTE_LENGTH 64

/** Permission level gets more restrictive further down */
EOS_ENUM(EOS_ELobbyPermissionLevel,
	/** Anyone can find this lobby as long as it isn't full */
	EOS_LPL_PUBLICADVERTISED = 0,
	/** Players who have access to presence can see this lobby */
	EOS_LPL_JOINVIAPRESENCE = 1,
	/** Only players with invites registered can see this lobby */
	EOS_LPL_INVITEONLY = 2
);

/** Advertisement properties for a single attribute associated with a lobby */
EOS_ENUM(EOS_ELobbyAttributeVisibility,
	/** Data is visible to lobby members, searchable and visible in search results. */
	EOS_LAT_PUBLIC = 0,
	/** Data is only visible to the user setting the data. Data is not visible to lobby members, not searchable, and not visible in search results. */
	EOS_LAT_PRIVATE = 1
);

/** Various types of lobby member updates */
EOS_ENUM(EOS_ELobbyMemberStatus,
	/** The user has joined the lobby */
	EOS_LMS_JOINED = 0,
	/** The user has explicitly left the lobby */
	EOS_LMS_LEFT = 1,
	/** The user has unexpectedly left the lobby */
	EOS_LMS_DISCONNECTED = 2,
	/** The user has been kicked from the lobby */
	EOS_LMS_KICKED = 3,
	/** The user has been promoted to lobby owner */
	EOS_LMS_PROMOTED = 4,
	/** The lobby has been closed and user has been removed */
	EOS_LMS_CLOSED = 5
);

#define EOS_LOBBYDETAILS_INFO_API_LATEST 3

EOS_STRUCT(EOS_LobbyDetails_Info, (
	/** API Version: Set this to EOS_LOBBYDETAILS_INFO_API_LATEST. */
	int32_t ApiVersion;
	/** Lobby ID */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the current owner of the lobby */
	EOS_ProductUserId LobbyOwnerUserId;
	/** Permission level of the lobby */
	EOS_ELobbyPermissionLevel PermissionLevel;
	/** Current available space */
	uint32_t AvailableSlots;
	/** Max allowed members in the lobby */
	uint32_t MaxMembers;
	/** If true, users can invite others to this lobby */
	EOS_Bool bAllowInvites;
	/** The main indexed parameter for this lobby, can be any string (i.e. "Region:GameMode") */
	const char* BucketId;
	/** Is host migration allowed */
	EOS_Bool bAllowHostMigration;
	/** Was a Real-Time Communication (RTC) room enabled at lobby creation? */
	EOS_Bool bRTCRoomEnabled;
	/** Is EOS_Lobby_JoinLobbyById allowed */
	EOS_Bool bAllowJoinById;
	/** Does rejoining after being kicked require an invite */
	EOS_Bool bRejoinAfterKickRequiresInvite;
	/** If true, this lobby will be associated with the local user's presence information. */
	EOS_Bool bPresenceEnabled;
	/** 
	 * Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are
	 * found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific
	 * header file. If null, the lobby will be unrestricted.
	 */
	const uint32_t* AllowedPlatformIds;
	/** Number of platform IDs in the array */
	uint32_t AllowedPlatformIdsCount;
));

EOS_DECLARE_FUNC(void) EOS_LobbyDetails_Info_Release(EOS_LobbyDetails_Info* LobbyDetailsInfo);

/** The most recent version of the EOS_Lobby_LocalRTCOptions structure. */
#define EOS_LOBBY_LOCALRTCOPTIONS_API_LATEST 1

/**
 * Input parameters to use with Lobby RTC Rooms.
 */
EOS_STRUCT(EOS_Lobby_LocalRTCOptions, (
	/** API Version: Set this to EOS_LOBBY_LOCALRTCOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Flags for the local user in this room. The default is 0 if this struct is not specified. @see EOS_RTC_JoinRoomOptions::Flags */
	uint32_t Flags;
	/**
	 * Set to EOS_TRUE to enable Manual Audio Input. If manual audio input is enabled, audio recording is not started and the audio buffers
	 * must be passed manually using EOS_RTCAudio_SendAudio. The default is EOS_FALSE if this struct is not specified.
	 */
	EOS_Bool bUseManualAudioInput;
	/**
	 * Set to EOS_TRUE to enable Manual Audio Output. If manual audio output is enabled, audio rendering is not started and the audio buffers
	 * must be received with EOS_RTCAudio_AddNotifyAudioBeforeRender and rendered manually. The default is EOS_FALSE if this struct is not
	 * specified.
	 */
	EOS_Bool bUseManualAudioOutput;
	/**
	 * Set to EOS_TRUE to start the audio input device's stream as muted when first connecting to the RTC room.
	 *
	 * It must be manually unmuted with a call to EOS_RTCAudio_UpdateSending. If manual audio output is enabled, this value is ignored.
	 * The default value is EOS_FALSE if this struct is not specified.
	 */
	EOS_Bool bLocalAudioDeviceInputStartsMuted;
));

/** The most recent version of the EOS_Lobby_CreateLobby API. */
#define EOS_LOBBY_CREATELOBBY_API_LATEST 9

/**
 * Input parameters for the EOS_Lobby_CreateLobby function.
 */
EOS_STRUCT(EOS_Lobby_CreateLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_CREATELOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user creating the lobby; this user will automatically join the lobby as its owner */
	EOS_ProductUserId LocalUserId;
	/** The maximum number of users who can be in the lobby at a time */
	uint32_t MaxLobbyMembers;
	/** The initial permission level of the lobby */
	EOS_ELobbyPermissionLevel PermissionLevel;
	/**
	 * If true, this lobby will be associated with the local user's presence information. A user's presence can only be associated with one lobby at a time.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Lobby_JoinLobbyByIdOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	EOS_Bool bPresenceEnabled;
	/** Are members of the lobby allowed to invite others */
	EOS_Bool bAllowInvites;
	/** Bucket ID associated with the lobby */
	const char* BucketId;
	/**
	 * Is host migration allowed (will the lobby stay open if the original host leaves?)
	 * NOTE: EOS_Lobby_PromoteMember is still allowed regardless of this setting
	 */
	EOS_Bool bDisableHostMigration;
	/**
	 * Creates a real-time communication (RTC) room for all members of this lobby. All members of the lobby will automatically join the RTC
	 * room when they connect to the lobby and they will automatically leave the RTC room when they leave or are removed from the lobby.
	 * While the joining and leaving of the RTC room is automatic, applications will still need to use the EOS RTC interfaces to handle all
	 * other functionality for the room.
	 *
	 * @see EOS_Lobby_GetRTCRoomName
	 * @see EOS_Lobby_AddNotifyRTCRoomConnectionChanged
	 */
	EOS_Bool bEnableRTCRoom;
	/**
	 * (Optional) Allows the local application to set local audio options for the RTC Room if it is enabled. Set this to NULL if the RTC
	 * RTC room is disabled or you would like to use the defaults.
	 */
	const EOS_Lobby_LocalRTCOptions* LocalRTCOptions;
	/**
	 * (Optional) Set to a globally unique value to override the backend assignment
	 * If not specified the backend service will assign one to the lobby.  Do not mix and match override and non override settings.
	 * This value can be of size [EOS_LOBBY_MIN_LOBBYIDOVERRIDE_LENGTH, EOS_LOBBY_MAX_LOBBYIDOVERRIDE_LENGTH]
	 */
	EOS_LobbyId LobbyId;
	/**
	 * Is EOS_Lobby_JoinLobbyById allowed.
	 * This is provided to support cases where an integrated platform's invite system is used.
	 * In these cases the game should provide the lobby ID securely to the invited player.  Such as by attaching the
	 * lobby ID to the integrated platform's session data or sending the lobby ID within the invite data.
	 */
	EOS_Bool bEnableJoinById;
	/**
	 * Does rejoining after being kicked require an invite?
	 * When this is set, a kicked player cannot return to the session even if the session was set with
	 * EOS_LPL_PUBLICADVERTISED.  When this is set, a player with invite privileges must use EOS_Lobby_SendInvite to
	 * allow the kicked player to return to the session.
	 */
	EOS_Bool bRejoinAfterKickRequiresInvite;
	/** 
	 * Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are
	 * found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific
	 * header file. If null, the lobby will be unrestricted.
	 */
	const uint32_t* AllowedPlatformIds;
	/** Number of platform IDs in the array */
	uint32_t AllowedPlatformIdsCount;
	/** 
	* This value indicates whether or not the lobby owner allows crossplay interactions. If false, the lobby owner
	* will be treated as allowing crossplay. If it is set to true, AllowedPlatformIds must have a single entry that matches 
	* the platform of the lobby owner.
	*/
	EOS_Bool bCrossplayOptOut;
));

/**
 * Output parameters for the EOS_Lobby_CreateLobby function.
 */
EOS_STRUCT(EOS_Lobby_CreateLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_CreateLobby */
	void* ClientData;
	/** The new lobby's ID */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_CreateLobby
 * @param Data A EOS_Lobby_CreateLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnCreateLobbyCallback, const EOS_Lobby_CreateLobbyCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_DestroyLobby API. */
#define EOS_LOBBY_DESTROYLOBBY_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_DestroyLobby function.
 */
EOS_STRUCT(EOS_Lobby_DestroyLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_DESTROYLOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting destruction of the lobby; this user must currently own the lobby */
	EOS_ProductUserId LocalUserId;
	/** The ID of the lobby to destroy */
	EOS_LobbyId LobbyId;
));

/**
 * Output parameters for the EOS_Lobby_DestroyLobby function.
 */
EOS_STRUCT(EOS_Lobby_DestroyLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_DestroyLobby */
	void* ClientData;
	/** The destroyed lobby's ID */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_DestroyLobby
 * @param Data A EOS_Lobby_DestroyLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnDestroyLobbyCallback, const EOS_Lobby_DestroyLobbyCallbackInfo* Data);


/** The most recent version of the EOS_Lobby_JoinLobby API. */
#define EOS_LOBBY_JOINLOBBY_API_LATEST 4

/**
 * Input parameters for the EOS_Lobby_JoinLobby function.
 */
EOS_STRUCT(EOS_Lobby_JoinLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_JOINLOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** The handle of the lobby to join */
	EOS_HLobbyDetails LobbyDetailsHandle;
	/** The Product User ID of the local user joining the lobby */
	EOS_ProductUserId LocalUserId;
	/** 
	 * If true, this lobby will be associated with the local user's presence information. A user can only associate one lobby at a time with their presence information.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	EOS_Bool bPresenceEnabled;
	/**
	 * (Optional) Set this value to override the default local options for the RTC Room, if it is enabled for this lobby. Set this to NULL if
	 * your application does not use the Lobby RTC Rooms feature, or if you would like to use the default settings. This option is ignored if
	 * the specified lobby does not have an RTC Room enabled and will not cause errors.
	 */
	const EOS_Lobby_LocalRTCOptions* LocalRTCOptions;
	/** 
	* This value indicates whether or not the local user allows crossplay interactions. If it is false, the local user 
	* will be treated as allowing crossplay.
	*/
	EOS_Bool bCrossplayOptOut;
));

/**
 * Output parameters for the EOS_Lobby_JoinLobby function.
 */
EOS_STRUCT(EOS_Lobby_JoinLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_JoinLobby */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_JoinLobby
 * @param Data A EOS_Lobby_JoinLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnJoinLobbyCallback, const EOS_Lobby_JoinLobbyCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_JoinLobbyById API. */
#define EOS_LOBBY_JOINLOBBYBYID_API_LATEST 2

/**
 * Input parameters for the EOS_Lobby_JoinLobbyById function.
 */
EOS_STRUCT(EOS_Lobby_JoinLobbyByIdOptions, (
	/** API Version: Set this to EOS_LOBBY_JOINLOBBYBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user joining the lobby */
	EOS_ProductUserId LocalUserId;
	/** If true, this lobby will be associated with the user's presence information. A user can only associate one lobby at a time with their presence information.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Lobby_JoinLobbyByIdOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	EOS_Bool bPresenceEnabled;
	/**
	 * (Optional) Set this value to override the default local options for the RTC Room, if it is enabled for this lobby. Set this to NULL if
	 * your application does not use the Lobby RTC Rooms feature, or if you would like to use the default settings. This option is ignored if
	 * the specified lobby does not have an RTC Room enabled and will not cause errors.
	 */
	const EOS_Lobby_LocalRTCOptions* LocalRTCOptions;
	/** 
	* This value indicates whether or not the local user allows crossplay interactions. If it is false, the local user
	* will be treated as allowing crossplay.
	*/
	EOS_Bool bCrossplayOptOut;
));

/**
 * Output parameters for the EOS_Lobby_JoinLobbyById function.
 */
EOS_STRUCT(EOS_Lobby_JoinLobbyByIdCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_JoinLobbyById */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_JoinLobbyById
 * @param Data A EOS_Lobby_JoinLobbyById CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnJoinLobbyByIdCallback, const EOS_Lobby_JoinLobbyByIdCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_LeaveLobby API. */
#define EOS_LOBBY_LEAVELOBBY_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_LeaveLobby function.
 */
EOS_STRUCT(EOS_Lobby_LeaveLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_LEAVELOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user leaving the lobby */
	EOS_ProductUserId LocalUserId;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Output parameters for the EOS_Lobby_LeaveLobby function.
 */
EOS_STRUCT(EOS_Lobby_LeaveLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_LeaveLobby */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_LeaveLobby
 * @param Data A EOS_Lobby_LeaveLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLeaveLobbyCallback, const EOS_Lobby_LeaveLobbyCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_UpdateLobbyModification API. */
#define EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_UpdateLobbyModification function.
 */
EOS_STRUCT(EOS_Lobby_UpdateLobbyModificationOptions, (
	/** API Version: Set this to EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the local user making modifications. Must be the owner to modify lobby data, but any lobby member can modify their own attributes. */
	EOS_ProductUserId LocalUserId;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/** The most recent version of the EOS_Lobby_UpdateLobby API. */
#define EOS_LOBBY_UPDATELOBBY_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_UpdateLobby function.
 */
EOS_STRUCT(EOS_Lobby_UpdateLobbyOptions, (
	/** API Version: Set this to EOS_LOBBY_UPDATELOBBY_API_LATEST. */
	int32_t ApiVersion;
	/** Builder handle */
	EOS_HLobbyModification LobbyModificationHandle;
));

/**
 * Output parameters for the EOS_Lobby_UpdateLobby function.
 */
EOS_STRUCT(EOS_Lobby_UpdateLobbyCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_UpdateLobby */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_UpdateLobby
 * @param Data A EOS_Lobby_UpdateLobby CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnUpdateLobbyCallback, const EOS_Lobby_UpdateLobbyCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_PromoteMember API. */
#define EOS_LOBBY_PROMOTEMEMBER_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_PromoteMember function.
 */
EOS_STRUCT(EOS_Lobby_PromoteMemberOptions, (
	/** API Version: Set this to EOS_LOBBY_PROMOTEMEMBER_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user making the request */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the member to promote to owner of the lobby */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_Lobby_PromoteMember function.
 */
EOS_STRUCT(EOS_Lobby_PromoteMemberCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_PromoteMember */
	void* ClientData;
	/** The ID of the lobby where the user was promoted */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_PromoteMember
 * @param Data A EOS_Lobby_PromoteMember CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnPromoteMemberCallback, const EOS_Lobby_PromoteMemberCallbackInfo* Data);


/** The most recent version of the EOS_Lobby_KickMember API. */
#define EOS_LOBBY_KICKMEMBER_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_KickMember function.
 */
EOS_STRUCT(EOS_Lobby_KickMemberOptions, (
	/** API Version: Set this to EOS_LOBBY_KICKMEMBER_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user requesting the removal; this user must be the lobby owner */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the lobby member to remove */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_Lobby_KickMember function.
 */
EOS_STRUCT(EOS_Lobby_KickMemberCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_KickMember */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_KickMember
 * @param Data A EOS_Lobby_KickMember CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnKickMemberCallback, const EOS_Lobby_KickMemberCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_HardMuteMember API. */
#define EOS_LOBBY_HARDMUTEMEMBER_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_HardMuteMember function.
 */
EOS_STRUCT(EOS_Lobby_HardMuteMemberOptions, (
	/** API Version: Set this to EOS_LOBBY_HARDMUTEMEMBER_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user requesting the hard mute; this user must be the lobby owner */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the lobby member to hard mute */
	EOS_ProductUserId TargetUserId;
	/** TargetUserId hard mute status (mute on or off) */
	EOS_Bool bHardMute;
));

/**
 * Output parameters for the EOS_Lobby_HardMuteMember function.
 */
EOS_STRUCT(EOS_Lobby_HardMuteMemberCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_HardMuteMember */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the lobby member whose mute status has been updated */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_HardMuteMember
 * @param Data A EOS_Lobby_HardMuteMember CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnHardMuteMemberCallback, const EOS_Lobby_HardMuteMemberCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyLobbyUpdateReceived API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYUPDATERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyUpdateReceivedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYUPDATERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyUpdateReceivedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyUpdateReceivedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyUpdateReceived */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyUpdateReceived
 *
 * @param Data A EOS_Lobby_LobbyUpdateReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyUpdateReceivedCallback, const EOS_Lobby_LobbyUpdateReceivedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyLobbyMemberUpdateReceived API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYMEMBERUPDATERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYMEMBERUPDATERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyMemberUpdateReceivedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyMemberUpdateReceived */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyMemberUpdateReceived
 *
 * @param Data A EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyMemberUpdateReceivedCallback, const EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyLobbyMemberStatusReceived API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYMEMBERSTATUSRECEIVED_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_AddNotifyLobbyMemberStatusReceived function.
 */
EOS_STRUCT(EOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYMEMBERSTATUSRECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_AddNotifyLobbyMemberStatusReceived function.
 */
EOS_STRUCT(EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyMemberStatusReceived */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
	/** Latest status of the user */
	EOS_ELobbyMemberStatus CurrentStatus;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_AddNotifyLobbyMemberStatusReceived
 * @param Data A EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyMemberStatusReceivedCallback, const EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo* Data);

/** Max length of an invite ID */
#define EOS_LOBBY_INVITEID_MAX_LENGTH 64

/** The most recent version of the EOS_Lobby_AddNotifyLobbyInviteReceived API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYINVITERECEIVED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyInviteReceivedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYINVITERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyInviteReceivedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyInviteReceivedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyInviteReceived */
	void* ClientData;
	/** The ID of the invitation */
	const char* InviteId;
	/** The Product User ID of the local user who received the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyInviteReceived
 *
 * @param Data A EOS_Lobby_LobbyInviteReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyInviteReceivedCallback, const EOS_Lobby_LobbyInviteReceivedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyLobbyInviteAccepted API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYINVITEACCEPTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyInviteAcceptedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYINVITEACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyInviteAcceptedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyInviteAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyInviteAccepted */
	void* ClientData;
	/** The invite ID */
	const char* InviteId;
	/** The Product User ID of the local user who received the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
	/** Lobby ID that the user has been invited to */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyInviteAccepted
 *
 * @param Data A EOS_Lobby_LobbyInviteAcceptedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyInviteAcceptedCallback, const EOS_Lobby_LobbyInviteAcceptedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifyJoinLobbyAccepted API. */
#define EOS_LOBBY_ADDNOTIFYJOINLOBBYACCEPTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyJoinLobbyAcceptedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYJOINLOBBYACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_Lobby_AddNotifyLobbyInviteRejected API. */
#define EOS_LOBBY_ADDNOTIFYLOBBYINVITEREJECTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLobbyInviteRejectedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLOBBYINVITEREJECTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLobbyInviteRejectedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LobbyInviteRejectedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyLobbyInviteRejected */
	void* ClientData;
	/** The invite ID */
	const char* InviteId;
	/** The Product User ID of the local user who received the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
	/** Lobby ID that the user has been invited to */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLobbyInviteRejected
 *
 * @param Data A EOS_Lobby_LobbyInviteRejectedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLobbyInviteRejectedCallback, const EOS_Lobby_LobbyInviteRejectedCallbackInfo* Data);

/**
 * Output parameters for the EOS_Lobby_OnJoinLobbyAcceptedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_JoinLobbyAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyJoinLobbyAccepted */
	void* ClientData;
	/** The Product User ID of the local user who is joining */
	EOS_ProductUserId LocalUserId;
	/**
	 * The UI Event associated with this Join Game event.
	 * This should be used with EOS_Lobby_CopyLobbyDetailsHandleByUiEventId to get a handle to be used
	 * when calling EOS_Lobby_JoinLobby.
	 */
	EOS_UI_EventId UiEventId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyJoinLobbyAccepted
 *
 * @param Data A EOS_Lobby_JoinLobbyAcceptedCallbackInfo containing the output information and result
 *
 * @note The lobby for the join game must be joined.
 *
 * @see EOS_Lobby_CopyLobbyDetailsHandleByUiEventId
 * @see EOS_Lobby_JoinLobby
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnJoinLobbyAcceptedCallback, const EOS_Lobby_JoinLobbyAcceptedCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_AddNotifySendLobbyNativeInviteRequested API. */
#define EOS_LOBBY_ADDNOTIFYSENDLOBBYNATIVEINVITEREQUESTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifySendLobbyNativeInviteRequestedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYSENDLOBBYNATIVEINVITEREQUESTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnSendLobbyNativeInviteRequestedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifySendLobbyNativeInviteRequested */
	void* ClientData;
	/**
	 * Identifies this event which will need to be acknowledged with EOS_UI_AcknowledgeEventId().
	 * @see EOS_UI_AcknowledgeEventId
	 */
	EOS_UI_EventId UiEventId;
	/** The Product User ID of the local user who is inviting. */
	EOS_ProductUserId LocalUserId;
	/**
	 * The Native Platform Account Type. If only a single integrated platform is configured then
	 * this will always reference that platform.
	 */
	EOS_IntegratedPlatformType TargetNativeAccountType;
	/** The Native Platform Account ID of the target user being invited. */
	const char* TargetUserNativeAccountId;
	/** Lobby ID that the user is being invited to */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifySendLobbyNativeInviteRequested
 *
 * @param Data A EOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo containing the output information and result
 *
 * @note After processing the callback EOS_UI_AcknowledgeEventId must be called.
 *
 * @see EOS_UI_AcknowledgeEventId
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnSendLobbyNativeInviteRequestedCallback, const EOS_Lobby_SendLobbyNativeInviteRequestedCallbackInfo* Data);


/** The most recent version of the EOS_Lobby_CopyLobbyDetailsHandleByInviteId API. */
#define EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_CopyLobbyDetailsHandleByInviteId function.
 */
EOS_STRUCT(EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions, (
	/** API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of an invitation to join the lobby */
	const char* InviteId;
));

/** The most recent version of the EOS_Lobby_CopyLobbyDetailsHandleByUiEventId API. */
#define EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYUIEVENTID_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_CopyLobbyDetailsHandleByUiEventId function.
 */
EOS_STRUCT(EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions, (
	/** API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYUIEVENTID_API_LATEST. */
	int32_t ApiVersion;
	/** UI Event associated with the lobby */
	EOS_UI_EventId UiEventId;
));

/** The most recent version of the EOS_Lobby_CreateLobbySearch API. */
#define EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_CreateLobbySearch function.
 */
EOS_STRUCT(EOS_Lobby_CreateLobbySearchOptions, (
	/** API Version: Set this to EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST. */
	int32_t ApiVersion;
	/** Maximum number of results allowed from the search */
	uint32_t MaxResults;
));

/** The most recent version of the EOS_Lobby_SendInvite API. */
#define EOS_LOBBY_SENDINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_SendInvite function.
 */
EOS_STRUCT(EOS_Lobby_SendInviteOptions, (
	/** API Version: Set this to EOS_LOBBY_SENDINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby associated with the invitation */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user sending the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user receiving the invitation */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_Lobby_SendInvite function.
 */
EOS_STRUCT(EOS_Lobby_SendInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_SendInvite */
	void* ClientData;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_SendInvite
 * @param Data A EOS_Lobby_SendInvite CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnSendInviteCallback, const EOS_Lobby_SendInviteCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_RejectInvite API. */
#define EOS_LOBBY_REJECTINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_RejectInvite function.
 */
EOS_STRUCT(EOS_Lobby_RejectInviteOptions, (
	/** API Version: Set this to EOS_LOBBY_REJECTINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby associated with the invitation */
	const char* InviteId;
	/** The Product User ID of the local user who is rejecting the invitation */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Lobby_RejectInvite function.
 */
EOS_STRUCT(EOS_Lobby_RejectInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_RejectInvite */
	void* ClientData;
	/** The ID of the invitation being rejected */
	const char* InviteId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_RejectInvite
 * @param Data A EOS_Lobby_RejectInvite CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnRejectInviteCallback, const EOS_Lobby_RejectInviteCallbackInfo* Data);

/** The most recent version of the EOS_Lobby_QueryInvites API. */
#define EOS_LOBBY_QUERYINVITES_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_QueryInvites function.
 */
EOS_STRUCT(EOS_Lobby_QueryInvitesOptions, (
	/** API Version: Set this to EOS_LOBBY_QUERYINVITES_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user whose invitations you want to retrieve */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Lobby_QueryInvites function.
 */
EOS_STRUCT(EOS_Lobby_QueryInvitesCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Lobby_QueryInvites */
	void* ClientData;
	/** The Product User ID of the local user that made the request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Lobby_QueryInvites
 * @param Data A EOS_Lobby_QueryInvites CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnQueryInvitesCallback, const EOS_Lobby_QueryInvitesCallbackInfo* Data);


/** The most recent version of the EOS_Lobby_GetInviteCount API. */
#define EOS_LOBBY_GETINVITECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_GetInviteCount function.
 */
EOS_STRUCT(EOS_Lobby_GetInviteCountOptions, (
	/** API Version: Set this to EOS_LOBBY_GETINVITECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user whose cached lobby invitations you want to count */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Lobby_GetInviteIdByIndex API. */
#define EOS_LOBBY_GETINVITEIDBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_GetInviteIdByIndex function.
 */
EOS_STRUCT(EOS_Lobby_GetInviteIdByIndexOptions, (
	/** API Version: Set this to EOS_LOBBY_GETINVITEIDBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who received the cached invitation */
	EOS_ProductUserId LocalUserId;
	/** The index of the invitation ID to retrieve */
	uint32_t Index;
));

/** The most recent version of the EOS_Lobby_CopyLobbyDetailsHandle API. */
#define EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_CopyLobbyDetailsHandle function.
 */
EOS_STRUCT(EOS_Lobby_CopyLobbyDetailsHandleOptions, (
	/** API Version: Set this to EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user making the request */
	EOS_ProductUserId LocalUserId;
));


/** The most recent version of the EOS_Lobby_GetRTCRoomName API. */
#define EOS_LOBBY_GETRTCROOMNAME_API_LATEST 1

/**
 * Input parameters for the EOS_Lobby_GetRTCRoomName function.
 */
EOS_STRUCT(EOS_Lobby_GetRTCRoomNameOptions, (
	/** API Version: Set this to EOS_LOBBY_GETRTCROOMNAME_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby to get the RTC Room name for */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user in the lobby */
	EOS_ProductUserId LocalUserId;
));


/** The most recent version of the EOS_Lobby_IsRTCRoomConnected API. */
#define EOS_LOBBY_ISRTCROOMCONNECTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_IsRTCRoomConnectedOptions, (
	/** API Version: Set this to EOS_LOBBY_ISRTCROOMCONNECTED_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby to get the RTC Room name for */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user in the lobby */
	EOS_ProductUserId LocalUserId;
));


/** The most recent version of the EOS_Lobby_AddNotifyRTCRoomConnectionChanged API. */
#define EOS_LOBBY_ADDNOTIFYRTCROOMCONNECTIONCHANGED_API_LATEST 2

/**
 * Input parameters for the EOS_Lobby_AddNotifyRTCRoomConnectionChanged function.
 */
EOS_STRUCT(EOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYRTCROOMCONNECTIONCHANGED_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby to receive RTC Room connection change notifications for
	 * This is deprecated and no longer needed. The notification is raised for any LobbyId or LocalUserId. If any filtering is required, the callback struct (EOS_Lobby_RTCRoomConnectionChangedCallbackInfo) has both a LobbyId and LocalUserId field.
	 */
	EOS_LobbyId LobbyId_DEPRECATED;
	/** The Product User ID of the local user in the lobby
	 * This is deprecated and no longer needed. The notification is raised for any LobbyId or LocalUserId. If any filtering is required, the callback struct (EOS_Lobby_RTCRoomConnectionChangedCallbackInfo) has both a LobbyId and LocalUserId field.
	 */
	EOS_ProductUserId LocalUserId_DEPRECATED;
));

EOS_STRUCT(EOS_Lobby_RTCRoomConnectionChangedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_AddNotifyRTCRoomConnectionChanged */
	void* ClientData;
	/** The ID of the lobby which had a RTC Room connection state change */
	EOS_LobbyId LobbyId;
	/** The Product User ID of the local user who is in the lobby and registered for notifications */
	EOS_ProductUserId LocalUserId;
	/** The new connection state of the room */
	EOS_Bool bIsConnected;
	/**
	 If bIsConnected is EOS_FALSE, this result will be the reason we were disconnected.
	 * EOS_Success: The room was left locally. This may be because: the associated lobby was Left or Destroyed, the connection to the lobby was interrupted, or because the SDK is being shutdown. If the lobby connection returns (lobby did not permanently go away), we will reconnect.
	 * EOS_NoConnection: There was a network issue connecting to the server. We will attempt to reconnect soon.
	 * EOS_RTC_UserKicked: The user has been kicked by the server. We will not reconnect.
	 * EOS_RTC_UserBanned: The user has been banned by the server. We will not reconnect.
	 * EOS_ServiceFailure: A known error occurred during interaction with the server. We will attempt to reconnect soon.
	 * EOS_UnexpectedError: Unexpected error. We will attempt to reconnect soon.
	 */
	EOS_EResult DisconnectReason;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyRTCRoomConnectionChanged
 *
 * @param Data containing the connection state of the RTC Room for a lobby
 *
 * @see EOS_Lobby_IsRTCRoomConnected
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnRTCRoomConnectionChangedCallback, const EOS_Lobby_RTCRoomConnectionChangedCallbackInfo* Data);


/** Search for a matching bucket ID (value is string) */
#define EOS_LOBBY_SEARCH_BUCKET_ID "bucket"
/** Search for lobbies that contain at least this number of members (value is int) */
#define EOS_LOBBY_SEARCH_MINCURRENTMEMBERS "mincurrentmembers"
/** Search for a match with min free space (value is int) */
#define EOS_LOBBY_SEARCH_MINSLOTSAVAILABLE "minslotsavailable"

/** The most recent version of the EOS_Lobby_AttributeData struct. */
#define EOS_LOBBY_ATTRIBUTEDATA_API_LATEST 1

/**
 * Contains information about lobby and lobby member data
 */
EOS_STRUCT(EOS_Lobby_AttributeData, (
	/** API Version: Set this to EOS_LOBBY_ATTRIBUTEDATA_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the lobby attribute */
	const char* Key;
	union
	{
		/** Stored as an 8 byte integer */
		int64_t AsInt64;
		/** Stored as a double precision floating point */
		double AsDouble;
		/** Stored as a boolean */
		EOS_Bool AsBool;
		/** Stored as a null terminated UTF8 string. Should not be nullptr */
		const char* AsUtf8;
	} Value;

	/** Type of value stored in the union */
	EOS_ELobbyAttributeType ValueType;
));

/** The most recent version of the EOS_Lobby_Attribute struct. */
#define EOS_LOBBY_ATTRIBUTE_API_LATEST 1

/**
 *  An attribute and its visibility setting stored with a lobby.
 *  Used to store both lobby and lobby member data
 */
EOS_STRUCT(EOS_Lobby_Attribute, (
	/** API Version: Set this to EOS_LOBBY_ATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute */
	EOS_Lobby_AttributeData* Data;
	/** Is this attribute public or private to the lobby and its members */
	EOS_ELobbyAttributeVisibility Visibility;
));

EOS_DECLARE_FUNC(void) EOS_Lobby_Attribute_Release(EOS_Lobby_Attribute* LobbyAttribute);

/** The most recent version of the EOS_Lobby_GetConnectString API. */
#define EOS_LOBBY_GETCONNECTSTRING_API_LATEST 1

/** The buffer size to provide to the  EOS_Lobby_GetConnectString API. */
#define EOS_LOBBY_GETCONNECTSTRING_BUFFER_SIZE 256

/**
 * Input parameters for the EOS_Lobby_GetConnectString function.
 */
EOS_STRUCT(EOS_Lobby_GetConnectStringOptions, (
	/** API Version: Set this to EOS_LOBBY_GETCONNECTSTRING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting the connection string generated from the lobby; this user must currently own the lobby */
	EOS_ProductUserId LocalUserId;
	/** The ID of the lobby to generate a connection string for */
	EOS_LobbyId LobbyId;
));

/** The most recent version of the EOS_Lobby_ParseConnectString API. */
#define EOS_LOBBY_PARSECONNECTSTRING_API_LATEST 1

/** The buffer size to provide to the EOS_Lobby_ParseConnectString API. */
#define EOS_LOBBY_PARSECONNECTSTRING_BUFFER_SIZE 256

/**
 * Input parameters for the EOS_Lobby_GetConnectString function.
 */
EOS_STRUCT(EOS_Lobby_ParseConnectStringOptions, (
	/** API Version: Set this to EOS_LOBBY_PARSECONNECTSTRING_API_LATEST. */
	int32_t ApiVersion;
	/** The connection string to parse */
	const char* ConnectString;
));

/** The most recent version of the EOS_LobbyModification_SetBucketId API. */
#define EOS_LOBBYMODIFICATION_SETBUCKETID_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetBucketId function.
 */
EOS_STRUCT(EOS_LobbyModification_SetBucketIdOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETBUCKETID_API_LATEST. */
	int32_t ApiVersion;
	/** The new bucket id associated with the lobby */
	const char* BucketId;
));

/** The most recent version of the EOS_LobbyModification_SetPermissionLevel API. */
#define EOS_LOBBYMODIFICATION_SETPERMISSIONLEVEL_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetPermissionLevel function.
 */
EOS_STRUCT(EOS_LobbyModification_SetPermissionLevelOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETPERMISSIONLEVEL_API_LATEST. */
	int32_t ApiVersion;
	/** Permission level of the lobby */
	EOS_ELobbyPermissionLevel PermissionLevel;
));

/** The most recent version of the EOS_LobbyModification_SetMaxMembers API. */
#define EOS_LOBBYMODIFICATION_SETMAXMEMBERS_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetMaxMembers function.
 */
EOS_STRUCT(EOS_LobbyModification_SetMaxMembersOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETMAXMEMBERS_API_LATEST. */
	int32_t ApiVersion;
	/** New maximum number of lobby members */
	uint32_t MaxMembers;
));

/** The most recent version of the EOS_LobbyModification_SetInvitesAllowed API. */
#define EOS_LOBBYMODIFICATION_SETINVITESALLOWED_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetInvitesAllowed Function.
 */
EOS_STRUCT(EOS_LobbyModification_SetInvitesAllowedOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETINVITESALLOWED_API_LATEST. */
	int32_t ApiVersion;
	/** If true then invites can currently be sent for the associated lobby */
	EOS_Bool bInvitesAllowed;
));

/** The most recent version of the EOS_LobbyModification_AddAttribute API. */
#define EOS_LOBBYMODIFICATION_ADDATTRIBUTE_API_LATEST 2

/**
 * Input parameters for the EOS_LobbyModification_AddAttribute function.
 */
EOS_STRUCT(EOS_LobbyModification_AddAttributeOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_ADDATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute to add to the lobby */
	const EOS_Lobby_AttributeData* Attribute;
	/** Is this attribute public or private to the lobby and its members */
	EOS_ELobbyAttributeVisibility Visibility;
));


/** The most recent version of the EOS_LobbyModification_RemoveAttribute API. */
#define EOS_LOBBYMODIFICATION_REMOVEATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_RemoveAttribute function.
 */
EOS_STRUCT(EOS_LobbyModification_RemoveAttributeOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_REMOVEATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the key */
	const char* Key;
));

/** The most recent version of the EOS_LobbyModification_AddMemberAttribute API. */
#define EOS_LOBBYMODIFICATION_ADDMEMBERATTRIBUTE_API_LATEST 2

/**
 * Input parameters for the EOS_LobbyModification_AddMemberAttribute function.
 */
EOS_STRUCT(EOS_LobbyModification_AddMemberAttributeOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_ADDMEMBERATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute to add to the lobby member */
	const EOS_Lobby_AttributeData* Attribute;
	/** Is this attribute public or private to the rest of the lobby members */
	EOS_ELobbyAttributeVisibility Visibility;
));

/** The most recent version of the EOS_LobbyModification_RemoveMemberAttribute API. */
#define EOS_LOBBYMODIFICATION_REMOVEMEMBERATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_RemoveMemberAttribute function.
 */
EOS_STRUCT(EOS_LobbyModification_RemoveMemberAttributeOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_REMOVEMEMBERATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the key */
	const char* Key;
));

/** The most recent version of the EOS_LobbyModification_SetAllowedPlatformIds API. */
#define EOS_LOBBYMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyModification_SetAllowedPlatformIdsOptions function.
 */
EOS_STRUCT(EOS_LobbyModification_SetAllowedPlatformIdsOptions, (
	/** API Version: Set this to EOS_LOBBYMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST. */
	int32_t ApiVersion;
	/** 
	 * Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are 
	 * found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific
	 * header file. If null, the lobby will be unrestricted.
	 */
	const uint32_t* AllowedPlatformIds;
	/** Number of platform IDs in the array */
	uint32_t AllowedPlatformIdsCount;
));

/** The most recent version of the EOS_LobbyDetails_GetLobbyOwner API. */
#define EOS_LOBBYDETAILS_GETLOBBYOWNER_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetLobbyOwner function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetLobbyOwnerOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETLOBBYOWNER_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_LobbyDetails_CopyInfo API. */
#define EOS_LOBBYDETAILS_COPYINFO_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyInfo function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyInfoOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYINFO_API_LATEST. */
	int32_t ApiVersion;
));


/** The most recent version of the EOS_LobbyDetails_GetAttributeCount API. */
#define EOS_LOBBYDETAILS_GETATTRIBUTECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetAttributeCount function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetAttributeCountOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETATTRIBUTECOUNT_API_LATEST. */
	int32_t ApiVersion;
));


/** The most recent version of the EOS_LobbyDetails_CopyAttributeByIndex API. */
#define EOS_LOBBYDETAILS_COPYATTRIBUTEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyAttributeByIndex function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyAttributeByIndexOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYATTRIBUTEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The index of the attribute to retrieve
	 * @see EOS_LobbyDetails_GetAttributeCount
	 */
	uint32_t AttrIndex;
));


/** The most recent version of the EOS_LobbyDetails_CopyAttributeByKey API. */
#define EOS_LOBBYDETAILS_COPYATTRIBUTEBYKEY_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyAttributeByKey function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyAttributeByKeyOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYATTRIBUTEBYKEY_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the attribute */
	const char* AttrKey;
));

/** The most recent version of the EOS_LobbyDetails_GetMemberAttributeCount API. */
#define EOS_LOBBYDETAILS_GETMEMBERATTRIBUTECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetMemberAttributeCount function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetMemberAttributeCountOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERATTRIBUTECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_LobbyDetails_CopyMemberAttributeByIndex API. */
#define EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyMemberAttributeByIndex function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyMemberAttributeByIndexOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
	/** The index of the attribute to copy */
	uint32_t AttrIndex;
));

/** The most recent version of the EOS_LobbyDetails_CopyMemberAttributeByKey API. */
#define EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYKEY_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyMemberAttributeByKey function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyMemberAttributeByKeyOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYKEY_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the lobby member */
	EOS_ProductUserId TargetUserId;
	/** Name of the attribute to copy */
	const char* AttrKey;
));

/** The most recent version of the EOS_LobbyDetails_GetMemberCount API. */
#define EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetMemberCount function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetMemberCountOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_LobbyDetails_GetMemberByIndex API. */
#define EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_GetMemberByIndex function.
 */
EOS_STRUCT(EOS_LobbyDetails_GetMemberByIndexOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the member to retrieve */
	uint32_t MemberIndex;
));

/** The most recent version of the EOS_LobbySearch_Find API. */
#define EOS_LOBBYSEARCH_FIND_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_Find function.
 */
EOS_STRUCT(EOS_LobbySearch_FindOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_FIND_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user making the search request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_LobbySearch_Find function.
 */
EOS_STRUCT(EOS_LobbySearch_FindCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_LobbySearch_Find */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_LobbySearch_Find
 * @param Data A EOS_LobbySearch_Find CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_LobbySearch_OnFindCallback, const EOS_LobbySearch_FindCallbackInfo* Data);

/** The most recent version of the EOS_LobbySearch_SetLobbyId API. */
#define EOS_LOBBYSEARCH_SETLOBBYID_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_SetLobbyId function.
 */
EOS_STRUCT(EOS_LobbySearch_SetLobbyIdOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_SETLOBBYID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID of the lobby to find */
	EOS_LobbyId LobbyId;
));

/** The most recent version of the EOS_LobbySearch_SetTargetUserId API. */
#define EOS_LOBBYSEARCH_SETTARGETUSERID_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_SetTargetUserId function.
 */
EOS_STRUCT(EOS_LobbySearch_SetTargetUserIdOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_SETTARGETUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** Search lobbies for given user by Product User ID, returning any lobbies where this user is currently registered */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_LobbySearch_SetParameter API. */
#define EOS_LOBBYSEARCH_SETPARAMETER_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_SetParameter function.
 */
EOS_STRUCT(EOS_LobbySearch_SetParameterOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_SETPARAMETER_API_LATEST. */
	int32_t ApiVersion;
	/** Search parameter describing a key and a value to compare */
	const EOS_Lobby_AttributeData* Parameter;
	/** The type of comparison to make against the search parameter */
	EOS_EComparisonOp ComparisonOp;
));

/** The most recent version of the EOS_LobbySearch_RemoveParameter API. */
#define EOS_LOBBYSEARCH_REMOVEPARAMETER_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_RemoveParameter function.
 */
EOS_STRUCT(EOS_LobbySearch_RemoveParameterOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_REMOVEPARAMETER_API_LATEST. */
	int32_t ApiVersion;
	/** Search parameter key to remove from the search */
	const char* Key;
	/** Search comparison operation associated with the key to remove */
	EOS_EComparisonOp ComparisonOp;
));

/** The most recent version of the EOS_LobbySearch_SetMaxResults API. */
#define EOS_LOBBYSEARCH_SETMAXRESULTS_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_SetMaxResults function.
 */
EOS_STRUCT(EOS_LobbySearch_SetMaxResultsOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_SETMAXRESULTS_API_LATEST. */
	int32_t ApiVersion;
	/** Maximum number of search results to return from the query */
	uint32_t MaxResults;
));

/** The most recent version of the EOS_LobbySearch_GetSearchResultCount API. */
#define EOS_LOBBYSEARCH_GETSEARCHRESULTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_GetSearchResultCount function.
 */
EOS_STRUCT(EOS_LobbySearch_GetSearchResultCountOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_GETSEARCHRESULTCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_LobbySearch_CopySearchResultByIndex API. */
#define EOS_LOBBYSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_LobbySearch_CopySearchResultByIndex function.
 */
EOS_STRUCT(EOS_LobbySearch_CopySearchResultByIndexOptions, (
	/** API Version: Set this to EOS_LOBBYSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The index of the lobby to retrieve within the completed search query
	 * @see EOS_LobbySearch_GetSearchResultCount
	 */
	uint32_t LobbyIndex;
));

/** The most recent version of the EOS_LobbyDetails_CopyMemberInfo API. */
#define EOS_LOBBYDETAILS_COPYMEMBERINFO_API_LATEST 1

/**
 * Input parameters for the EOS_LobbyDetails_CopyMemberInfo function.
 */
EOS_STRUCT(EOS_LobbyDetails_CopyMemberInfoOptions, (
	/** API Version: Set this to EOS_LOBBYDETAILS_COPYMEMBERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the lobby member to copy. */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_LobbyDetails_MemberInfo API. */
#define EOS_LOBBYDETAILS_MEMBERINFO_API_LATEST 1

EOS_STRUCT(EOS_LobbyDetails_MemberInfo, (
	/** API Version: Set this to EOS_LOBBYDETAILS_MEMBERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the lobby member. */
	EOS_ProductUserId UserId;
	/** The platform of the lobby member. */
	EOS_OnlinePlatformType Platform;
	/** Does this member allow crossplay */
	EOS_Bool bAllowsCrossplay;
));

EOS_DECLARE_FUNC(void) EOS_LobbyDetails_MemberInfo_Release(EOS_LobbyDetails_MemberInfo* LobbyDetailsMemberInfo);

/** The most recent version of the EOS_Lobby_AddNotifyLeaveLobbyRequested API. */
#define EOS_LOBBY_ADDNOTIFYLEAVELOBBYREQUESTED_API_LATEST 1

EOS_STRUCT(EOS_Lobby_AddNotifyLeaveLobbyRequestedOptions, (
	/** API Version: Set this to EOS_LOBBY_ADDNOTIFYLEAVELOBBYREQUESTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Lobby_OnLeaveLobbyRequestedCallback Function.
 */
EOS_STRUCT(EOS_Lobby_LeaveLobbyRequestedCallbackInfo, (
	/** Context that was passed into EOS_Lobby_OnLeaveLobbyRequestedCallback */
	void* ClientData;
	/** The Product User ID of the local user who received the leave lobby notification. */
	EOS_ProductUserId LocalUserId;
	/** Lobby ID associated with the leave lobby request. */
	EOS_LobbyId LobbyId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Lobby_AddNotifyLeaveLobbyRequested.
 *
 * @param Data A pointer to EOS_Lobby_LeaveLobbyRequestedCallbackInfo containing the output information.
 */
EOS_DECLARE_CALLBACK(EOS_Lobby_OnLeaveLobbyRequestedCallback, const EOS_Lobby_LeaveLobbyRequestedCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_logging.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

/**
 * The Logging Interface grants access to log output coming from the SDK at various levels of detail.
 * Unlike other interfaces, the Logging Interface does not require a handle from the Platform Interface,
 * as it functions entirely on the local system.
 */

#pragma pack(push, 8)

/**
 * Logging levels. When a log message is output, it has an associated log level.
 * Messages will only be sent to the callback function if the message's associated log level is less than or equal to the configured log level for that category.
 *
 * @see EOS_Logging_SetCallback
 * @see EOS_Logging_SetLogLevel
 */
EOS_ENUM(EOS_ELogLevel,
	EOS_LOG_Off = 0,
	EOS_LOG_Fatal = 100,
	EOS_LOG_Error = 200,
	EOS_LOG_Warning = 300,
	EOS_LOG_Info = 400,
	EOS_LOG_Verbose = 500,
	EOS_LOG_VeryVerbose = 600
);

/**
 * Logging Categories
 */
EOS_ENUM(EOS_ELogCategory,
	/** Low level logs unrelated to specific services */
	EOS_LC_Core = 0,
	/** Logs related to the Auth service */
	EOS_LC_Auth = 1,
	/** Logs related to the Friends service */
	EOS_LC_Friends = 2,
	/** Logs related to the Presence service */
	EOS_LC_Presence = 3,
	/** Logs related to the UserInfo service */
	EOS_LC_UserInfo = 4,
	/** Logs related to HTTP serialization */
	EOS_LC_HttpSerialization = 5,
	/** Logs related to the Ecommerce service */
	EOS_LC_Ecom = 6,
	/** Logs related to the P2P service */
	EOS_LC_P2P = 7,
	/** Logs related to the Sessions service */
	EOS_LC_Sessions = 8,
	/** Logs related to rate limiting */
	EOS_LC_RateLimiter = 9,
	/** Logs related to the PlayerDataStorage service */
	EOS_LC_PlayerDataStorage = 10,
	/** Logs related to sdk analytics */
	EOS_LC_Analytics = 11,
	/** Logs related to the messaging service */
	EOS_LC_Messaging = 12,
	/** Logs related to the Connect service */
	EOS_LC_Connect = 13,
	/** Logs related to the Overlay */
	EOS_LC_Overlay = 14,
	/** Logs related to the Achievements service */
	EOS_LC_Achievements = 15,
	/** Logs related to the Stats service */
	EOS_LC_Stats = 16,
	/** Logs related to the UI service */
	EOS_LC_UI = 17,
	/** Logs related to the lobby service */
	EOS_LC_Lobby = 18,
	/** Logs related to the Leaderboards service */
	EOS_LC_Leaderboards = 19,
	/** Logs related to an internal Keychain feature that the authentication interfaces use */
	EOS_LC_Keychain = 20,
	/** Logs related to integrated platforms */
	EOS_LC_IntegratedPlatform = 21,
	/** Logs related to Title Storage */
	EOS_LC_TitleStorage = 22,
	/** Logs related to the Mods service */
	EOS_LC_Mods = 23,
	/** Logs related to the Anti-Cheat service */
	EOS_LC_AntiCheat = 24,
	/** Logs related to reports client. */
	EOS_LC_Reports = 25,
	/** Logs related to the Sanctions service */
	EOS_LC_Sanctions = 26,
	/** Logs related to the Progression Snapshot service */
	EOS_LC_ProgressionSnapshots = 27,
	/** Logs related to the Kids Web Services integration */
	EOS_LC_KWS = 28,
	/** Logs related to the RTC API */
	EOS_LC_RTC = 29,
	/** Logs related to the RTC Admin API */
	EOS_LC_RTCAdmin = 30,
	/** Logs related to the Custom Invites API */
	EOS_LC_CustomInvites = 31,

	/** Not a real log category. Used by EOS_Logging_SetLogLevel to set the log level for all categories at the same time */
	EOS_LC_ALL_CATEGORIES = 0x7fffffff
);

/** A structure representing a log message */
EOS_STRUCT(EOS_LogMessage, (
	/** A string representation of the log message category, encoded in UTF-8. Only valid during the life of the callback, so copy the string if you need it later. */
	const char* Category;
	/** The log message, encoded in UTF-8. Only valid during the life of the callback, so copy the string if you need it later. */
	const char* Message;
	/** The log level associated with the message */
	EOS_ELogLevel Level;
));

/**
 * Function prototype definition for functions that receive log messages.
 *
 * @param Message A EOS_LogMessage containing the log category, log level, and message.
 * @see EOS_LogMessage
 */
EXTERN_C typedef void (EOS_CALL * EOS_LogMessageFunc)(const EOS_LogMessage* Message);

/**
 * Set the callback function to use for SDK log messages. Any previously set callback will no longer be called.
 *
 * @param Callback the function to call when the SDK logs messages
 * @return EOS_Success is returned if the callback will be used for future log messages.
 *         EOS_NotConfigured is returned if the SDK has not yet been initialized, or if it has been shut down
 *
 * @see EOS_Initialize
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Logging_SetCallback(EOS_LogMessageFunc Callback);

/**
 * Set the logging level for the specified logging category. By default all log categories will callback for Warnings, Errors, and Fatals.
 *
 * @param LogCategory the specific log category to configure. Use EOS_LC_ALL_CATEGORIES to configure all categories simultaneously to the same log level.
 * @param LogLevel the log level to use for the log category
 *
 * @return EOS_Success is returned if the log levels are now in use.
 *         EOS_NotConfigured is returned if the SDK has not yet been initialized, or if it has been shut down.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Logging_SetLogLevel(EOS_ELogCategory LogCategory, EOS_ELogLevel LogLevel);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_metrics.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_metrics_types.h"

/**
 * The Metrics Interface tracks your application's usage and populates the Game Analytics dashboard in the Developer Portal.
 * This data includes active, online instances of the game's client and server, and past sessions played by local players.
 * All Metrics Interface calls take a handle of type EOS_HMetrics as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetMetricsInterface function.
 *
 * @see EOS_Platform_GetMetricsInterface
 */

/**
 * Logs the start of a new game session for a local player.
 *
 * The game client should call this function whenever it joins into a new multiplayer, peer-to-peer or single player game session.
 * Each call to BeginPlayerSession must be matched with a corresponding call to EndPlayerSession.
 *
 * @param Options Structure containing the local player's game account and the game session information.
 *
 * @return Returns EOS_Success on success, or an error code if the input parameters are invalid or an active session for the player already exists.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Metrics_BeginPlayerSession(EOS_HMetrics Handle, const EOS_Metrics_BeginPlayerSessionOptions* Options);

/**
 * Logs the end of a game session for a local player.
 *
 * Call once when the game client leaves the active game session.
 * Each call to BeginPlayerSession must be matched with a corresponding call to EndPlayerSession.
 *
 * @param Options Structure containing the account id of the player whose session to end.
 *
 * @return Returns EOS_Success on success, or an error code if the input parameters are invalid or there was no active session for the player.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Metrics_EndPlayerSession(EOS_HMetrics Handle, const EOS_Metrics_EndPlayerSessionOptions* Options);

```

`EAC_SDK/SDK/include/eos_metrics_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_MetricsHandle* EOS_HMetrics;

/** User game controller types. */
EOS_ENUM(EOS_EUserControllerType,
	/** The game controller type is unknown. */
	EOS_UCT_Unknown = 0,
	/** Mouse and keyboard controller. */
	EOS_UCT_MouseKeyboard = 1,
	/** Gamepad controller. */
	EOS_UCT_GamepadControl = 2,
	/** Touch controller. */
	EOS_UCT_TouchControl = 3
);

/** Account ID type for EOS_Metrics_BeginPlayerSession and EOS_Metrics_EndPlayerSession. */
EOS_ENUM(EOS_EMetricsAccountIdType,
	/** An Epic Account ID. */
	EOS_MAIT_Epic = 0,
	/** An external service Account ID. */
	EOS_MAIT_External = 1
);

/** The most recent version of the EOS_Metrics_BeginPlayerSessionOptions struct. */
#define EOS_METRICS_BEGINPLAYERSESSION_API_LATEST 1

/** BeginPlayerSession. */
EOS_STRUCT(EOS_Metrics_BeginPlayerSessionOptions, (
	/** API Version: Set this to EOS_METRICS_BEGINPLAYERSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Account ID type that is set in the union. */
	EOS_EMetricsAccountIdType AccountIdType;
	/** The Account ID for the player whose session is beginning. */
	union
	{
		/** An Epic Account ID. Set this field when AccountIdType is set to EOS_MAIT_Epic. */
		EOS_EpicAccountId Epic;
		/** An Account ID for another service. Set this field when AccountIdType is set to EOS_MAIT_External. */
		const char* External;
	} AccountId;
	/** The in-game display name for the user as UTF-8 string. */
	const char* DisplayName;
	/** The user's game controller type. */
	EOS_EUserControllerType ControllerType;
	/**
	 * IP address of the game server hosting the game session. For a localhost session, set to NULL.
	 *
	 * @details Must be in either one of the following IPv4 or IPv6 string formats:
	 * * "127.0.0.1".
	 * * "1200:0000:AB00:1234:0000:2552:7777:1313".
	 * If both IPv4 and IPv6 addresses are available, use the IPv6 address.
	 */
	const char* ServerIp;
	/**
	 * Optional, application-defined custom match session identifier. If the identifier is not used, set to NULL.
	 *
	 * @details The game can tag each game session with a custom session match identifier,
	 * which will be shown in the Played Sessions listing at the user profile dashboard.
	 */
	const char* GameSessionId;
));

/** The most recent version of the EOS_Metrics_EndPlayerSessionOptions struct. */
#define EOS_METRICS_ENDPLAYERSESSION_API_LATEST 1

/** EndPlayerSession. */
EOS_STRUCT(EOS_Metrics_EndPlayerSessionOptions, (
	/** API Version: Set this to EOS_METRICS_ENDPLAYERSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** The Account ID type that is set in the union. */
	EOS_EMetricsAccountIdType AccountIdType;
	/** The Account ID for the player whose session is ending. */
	union
	{
		/** An Epic Account ID. Set this field when AccountIdType is set to EOS_MAIT_Epic. */
		EOS_EpicAccountId Epic;
		/** An Account ID for another service. Set this field when AccountIdType is set to EOS_MAIT_External. */
		const char* External;
	} AccountId;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_mods.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_mods_types.h"

/**
 * The Mods Interface is used to manage a user's mods. Allowing a user to install/uninstall/enumerate mods.
 * All Mods Interface calls take a handle of type EOS_HMods as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetModsInterface function.
 *
 * NOTE: At this time, this feature is only available for desktop platforms and for products that are part of the Epic Games store.
 *
 * @see EOS_Platform_GetModsInterface
 */

/**
 * Starts an asynchronous task that makes a request to install the specified mod.
 *
 * @param Options structure containing the game and mod identifiers
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see the section related to mods in eos_result.h for more details.
 */
EOS_DECLARE_FUNC(void) EOS_Mods_InstallMod(EOS_HMods Handle, const EOS_Mods_InstallModOptions* Options, void* ClientData, const EOS_Mods_OnInstallModCallback CompletionDelegate);

/**
 * Starts an asynchronous task that makes a request to uninstall the specified mod.
 *
 * @param Options structure containing the game and mod identifiers
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see the section related to mods in eos_result.h for more details.
 */
EOS_DECLARE_FUNC(void) EOS_Mods_UninstallMod(EOS_HMods Handle, const EOS_Mods_UninstallModOptions* Options, void* ClientData, const EOS_Mods_OnUninstallModCallback CompletionDelegate);

/**
 * Starts an asynchronous task that makes a request to enumerate mods for the specified game.
 * Types of the mods to enumerate can be specified through EOS_Mods_EnumerateModsOptions
 *
 * @param Options structure containing the game identifiers
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see the section related to mods in eos_result.h for more details.
 */
EOS_DECLARE_FUNC(void) EOS_Mods_EnumerateMods(EOS_HMods Handle, const EOS_Mods_EnumerateModsOptions* Options, void* ClientData, const EOS_Mods_OnEnumerateModsCallback CompletionDelegate);

/**
 * Get cached enumerated mods object. If successful, this data must be released by calling EOS_Mods_ModInfo_Release
 * Types of the cached enumerated mods can be specified through EOS_Mods_CopyModInfoOptions
 *
 * @param Options structure containing the game identifier for which requesting enumerated mods
 * @param OutEnumeratedMods Enumerated mods Info. If the returned result is success, this will be set to data that must be later released, otherwise this will be set to NULL
 * @return Success if we have cached data, or an error result if the request was invalid or we do not have cached data.
 *
 * @see EOS_Mods_ModInfo_Release
 *
 * This request may fail with an EOS_NotFound code if an enumeration of a certain type was not performed before this call.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Mods_CopyModInfo(EOS_HMods Handle, const EOS_Mods_CopyModInfoOptions* Options, EOS_Mods_ModInfo ** OutEnumeratedMods);

/**
 * Starts an asynchronous task that makes a request to update the specified mod to the latest version.
 *
 * @param Options structure containing the game and mod identifiers
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error. If the mod is up to date then the operation will complete with success.
 *
 * @see the section related to mods in eos_result.h for more details.
 */
EOS_DECLARE_FUNC(void) EOS_Mods_UpdateMod(EOS_HMods Handle, const EOS_Mods_UpdateModOptions* Options, void* ClientData, const EOS_Mods_OnUpdateModCallback CompletionDelegate);

```

`EAC_SDK/SDK/include/eos_mods_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_ModsHandle* EOS_HMods;

/** The most recent version of the EOS_Mod_Identifier struct. */
#define EOS_MOD_IDENTIFIER_API_LATEST 1

/**
 * EOS_Mod_Identifier is used to identify a mod.
 */
EOS_STRUCT(EOS_Mod_Identifier, (
	/** API Version: Set this to EOS_MOD_IDENTIFIER_API_LATEST. */
	int32_t ApiVersion;
	/** Product namespace id in which this mod item exists */
	const char* NamespaceId;
	/** Item id of the Mod */
	const char* ItemId;
	/** Artifact id of the Mod */
	const char* ArtifactId;
	/** Represent mod item title. */
	const char* Title;
	/** Represent mod item version. */
	const char* Version;
));


/**
 * EOS_Mods_InstallMod is used to start an asynchronous request to make a mod install request for a game.
 * The following types are used to work with the API.
 */


/** The most recent version of the EOS_Mods_InstallMod API. */
#define EOS_MODS_INSTALLMOD_API_LATEST 1

/**
 * Input parameters for the EOS_Mods_InstallMod Function.
 */
EOS_STRUCT(EOS_Mods_InstallModOptions, (
	/** API Version: Set this to EOS_MODS_INSTALLMOD_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which the mod should be installed */
	EOS_EpicAccountId LocalUserId;
	/** The mod to install */
	const EOS_Mod_Identifier* Mod;
	/** Indicates whether the mod should be uninstalled after exiting the game or not. */
	EOS_Bool bRemoveAfterExit;
));

/**
 * Output parameters for the EOS_Mods_InstallMod Function. These parameters are received through the callback provided to EOS_Mods_InstallMod
 */
EOS_STRUCT(EOS_Mods_InstallModCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the installation was successful, otherwise one of the error codes is returned. */
	EOS_EResult ResultCode;
	/** The Epic Account ID of the user for which mod installation was requested */
	EOS_EpicAccountId LocalUserId;
	/** Context that is passed into EOS_Mods_InstallMod */
	void* ClientData;
	/** Mod for which installation was requested */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Function prototype definition for callbacks passed to EOS_Mods_InstallMod
 * @param Data A EOS_Mods_InstallModCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Mods_OnInstallModCallback, const EOS_Mods_InstallModCallbackInfo* Data);


/**
 * EOS_Mods_UninstallMod is used to start an asynchronous request to make a mod uninstall request for a game.
 * The following types are used to work with the API.
 */


/** The most recent version of the EOS_Mods_UninstallModOptions API. */
#define EOS_MODS_UNINSTALLMOD_API_LATEST 1

/**
 * Input parameters for the EOS_Mods_UninstallMod Function.
 */
EOS_STRUCT(EOS_Mods_UninstallModOptions, (
	/** API Version: Set this to EOS_MODS_UNINSTALLMOD_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which the mod should be uninstalled */
	EOS_EpicAccountId LocalUserId;
	/** The mod to uninstall */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Output parameters for the EOS_Mods_UninstallMod Function. These parameters are received through the callback provided to EOS_Mods_UninstallMod
 */
EOS_STRUCT(EOS_Mods_UninstallModCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the uninstallation was successful, otherwise one of the error codes is returned. */
	EOS_EResult ResultCode;
	/** The Epic Account ID of the user for which mod uninstallation was requested */
	EOS_EpicAccountId LocalUserId;
	/** Context that is passed into EOS_Mods_UninstallMod */
	void* ClientData;
	/** Mod for which uninstallation was requested */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Function prototype definition for callbacks passed to EOS_Mods_UninstallMod
 * @param Data A EOS_Mods_UninstallModCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Mods_OnUninstallModCallback, const EOS_Mods_UninstallModCallbackInfo* Data);


/**
 * EOS_Mods_EnumerateMods is used to start an asynchronous request to enumerate mods for a game.
 * The following types are used to work with the API.
 */


/** The type of mod enumeration. */
EOS_ENUM(EOS_EModEnumerationType,
	/** Installed mods */
	EOS_MET_INSTALLED = 0,
	/** All available mods*/
	EOS_MET_ALL_AVAILABLE
);

/** The most recent version of the EOS_Mods_EnumerateModsOptions API. */
#define EOS_MODS_ENUMERATEMODS_API_LATEST 1

/**
 * Input parameters for the EOS_Mods_EnumerateMods Function.
 */
EOS_STRUCT(EOS_Mods_EnumerateModsOptions, (
	/** API Version: Set this to EOS_MODS_ENUMERATEMODS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which the mod should be enumerated */
	EOS_EpicAccountId LocalUserId;
	/** Type of the mods to enumerate */
	EOS_EModEnumerationType Type;
));

/**
 * Output parameters for the EOS_Mods_EnumerateMods Function. These parameters are received through the callback provided to EOS_Mods_EnumerateMods
 */
EOS_STRUCT(EOS_Mods_EnumerateModsCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the enumeration was successful, otherwise one of the error codes is returned. */
	EOS_EResult ResultCode;
	/** The Epic Account ID of the user for which mod enumeration was requested */
	EOS_EpicAccountId LocalUserId;
	/** Context that is passed into EOS_Mods_EnumerateMods */
	void* ClientData;
	/** Type of the enumerated mods */
	EOS_EModEnumerationType Type;
));

/**
 * Function prototype definition for callbacks passed to EOS_Mods_EnumerateMods
 * @param Data A EOS_Mods_EnumerateModsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Mods_OnEnumerateModsCallback, const EOS_Mods_EnumerateModsCallbackInfo* Data);

/** The most recent version of the EOS_Mods_CopyModInfoOptions API. */
#define EOS_MODS_COPYMODINFO_API_LATEST 1

/**
 * Data for the EOS_Mods_CopyModInfo function.
 */
EOS_STRUCT(EOS_Mods_CopyModInfoOptions, (
	/** API Version: Set this to EOS_MODS_COPYMODINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which mods should be copied */
	EOS_EpicAccountId LocalUserId;
	/** Type of the enumerated mod to copy */
	EOS_EModEnumerationType Type;
));

/** The most recent version of the EOS_Mods_ModInfo struct. */
#define EOS_MODS_MODINFO_API_LATEST 1

/**
 * Data for the EOS_Mods_CopyModInfo function.
 *
 * @see EOS_Mods_CopyModInfo
 * @see EOS_Mods_ModInfo_Release
 */
EOS_STRUCT(EOS_Mods_ModInfo, (
	/** API Version: Set this to EOS_MODS_MODINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The count of enumerated mods */
	int32_t ModsCount;
	/** The array of enumerated mods or NULL if no such type of mods were enumerated */
	EOS_Mod_Identifier* Mods;
	/** Type of the mods */
	EOS_EModEnumerationType Type;
));

/**
 * Release the memory associated with an EOS_Mods_ModInfo structure and its sub-objects. This must be called on data retrieved from EOS_Mods_CopyModInfo.
 *
 * @param ModInfo the info structure to be release
 *
 * @see EOS_Mods_ModInfo
 * @see EOS_Mods_CopyModInfo
 */
EOS_DECLARE_FUNC(void) EOS_Mods_ModInfo_Release(EOS_Mods_ModInfo* ModInfo);

/** The most recent version of the EOS_Mods_UpdateModOptions API. */
#define EOS_MODS_UPDATEMOD_API_LATEST 1

/**
 * Input parameters for the EOS_Mods_UpdateMod Function.
 */
EOS_STRUCT(EOS_Mods_UpdateModOptions, (
	/** API Version: Set this to EOS_MODS_UPDATEMOD_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user for which the mod should be updated */
	EOS_EpicAccountId LocalUserId;
	/** The mod to update */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Output parameters for the EOS_Mods_UpdateMod Function. These parameters are received through the callback provided to EOS_Mods_UpdateMod
 */
EOS_STRUCT(EOS_Mods_UpdateModCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if the request to update was successful, otherwise one of the error codes is returned. */
	EOS_EResult ResultCode;
	/** The Epic Account ID of the user for which mod update was requested */
	EOS_EpicAccountId LocalUserId;
	/** Context that is passed into EOS_Mods_UpdateMod */
	void* ClientData;
	/** Mod for which update was requested */
	const EOS_Mod_Identifier* Mod;
));

/**
 * Function prototype definition for callbacks passed to EOS_Mods_UpdateMod
 * @param Data A EOS_Mods_UpdateModCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Mods_OnUpdateModCallback, const EOS_Mods_UpdateModCallbackInfo* Data);

#pragma pack(pop)
```

`EAC_SDK/SDK/include/eos_p2p.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_p2p_types.h"

/**
 * P2P functions to help manage sending and receiving of messages to peers.
 *
 * These functions will attempt to punch through NATs, but will fallback to using Epic relay servers if a direct connection cannot be established.
 */

/**
 * Send a packet to a peer at the specified address. If there is already an open connection to this peer, it will be
 * sent immediately. If there is no open connection, an attempt to connect to the peer will be made. An EOS_Success
 * result only means the data was accepted to be sent, not that it has been successfully delivered to the peer.
 *
 * @param Options Information about the data being sent, by who, to who
 * @return EOS_EResult::EOS_Success           - If packet was queued to be sent successfully
 *         EOS_EResult::EOS_InvalidParameters - If input was invalid
 *         EOS_EResult::EOS_LimitExceeded     - If amount of data being sent is too large, or the outgoing packet queue was full
 *         EOS_EResult::EOS_NoConnection      - If bDisableAutoAcceptConnection was set to EOS_TRUE and the connection was not currently accepted (call EOS_P2P_AcceptConnection first, or set bDisableAutoAcceptConnection to EOS_FALSE)
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_SendPacket(EOS_HP2P Handle, const EOS_P2P_SendPacketOptions* Options);

/**
 * Gets the size of the packet that will be returned by ReceivePacket for a particular user, if there is any available
 * packets to be retrieved.
 *
 * @param Options Information about who is requesting the size of their next packet
 * @param OutPacketSizeBytes The amount of bytes required to store the data of the next packet for the requested user
 * @return EOS_EResult::EOS_Success - If OutPacketSizeBytes was successfully set and there is data to be received
 *         EOS_EResult::EOS_InvalidParameters - If input was invalid
 *         EOS_EResult::EOS_NotFound  - If there are no packets available for the requesting user
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetNextReceivedPacketSize(EOS_HP2P Handle, const EOS_P2P_GetNextReceivedPacketSizeOptions* Options, uint32_t* OutPacketSizeBytes);

/**
 * Receive the next packet for the local user, and information associated with this packet, if it exists.
 *
 * @param Options Information about who is requesting the size of their next packet, and how much data can be stored safely
 * @param OutPeerId The Remote User who sent data. Only set if there was a packet to receive.
 * @param OutSocketId The Socket ID of the data that was sent. Only set if there was a packet to receive.
 * @param OutChannel The channel the data was sent on. Only set if there was a packet to receive.
 * @param OutData Buffer to store the data being received. Must be at least EOS_P2P_GetNextReceivedPacketSize in length or data will be truncated
 * @param OutBytesWritten The amount of bytes written to OutData. Only set if there was a packet to receive.
 * @return EOS_EResult::EOS_Success - If the packet was received successfully
 *         EOS_EResult::EOS_InvalidParameters - If input was invalid
 *         EOS_EResult::EOS_NotFound - If there are no packets available for the requesting user
 *
 * @see EOS_P2P_GetNextReceivedPacketSize
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_ReceivePacket(EOS_HP2P Handle, const EOS_P2P_ReceivePacketOptions* Options, EOS_ProductUserId* OutPeerId, EOS_P2P_SocketId* OutSocketId, uint8_t* OutChannel, void* OutData, uint32_t* OutBytesWritten);

/**
 * Listen for incoming connection requests on a particular Socket ID, or optionally all Socket IDs. The bound function
 * will only be called if the connection has not already been accepted.
 *
 * @param Options Information about who would like notifications, and (optionally) only for a specific socket
 * @param ClientData This value is returned to the caller when ConnectionRequestHandler is invoked
 * @param ConnectionRequestHandler The callback to be fired when we receive a connection request
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 *
 * @see EOS_P2P_RemoveNotifyPeerConnectionRequest
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyPeerConnectionRequest(EOS_HP2P Handle, const EOS_P2P_AddNotifyPeerConnectionRequestOptions* Options, void* ClientData, EOS_P2P_OnIncomingConnectionRequestCallback ConnectionRequestHandler);

/**
 * Stop listening for connection requests on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 *
 * @see EOS_P2P_AddNotifyPeerConnectionRequest
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyPeerConnectionRequest(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Listen for when a connection is established. This is fired when we first connect to a peer, when we reconnect to a peer after a connection interruption,
 * and when our underlying network connection type changes (for example, from a direct connection to relay, or vice versa). Network Connection Type changes
 * will always be broadcast with a EOS_CET_Reconnection connection type, even if the connection was not interrupted.
 *
 * @param Options Information about who would like notifications about established connections, and for which socket
 * @param ClientData This value is returned to the caller when ConnectionEstablishedHandler is invoked
 * @param ConnectionEstablishedHandler The callback to be fired when a connection has been established
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 *
 * @see EOS_P2P_AddNotifyPeerConnectionInterrupted
 * @see EOS_P2P_AddNotifyPeerConnectionClosed
 * @see EOS_P2P_RemoveNotifyPeerConnectionEstablished
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyPeerConnectionEstablished(EOS_HP2P Handle, const EOS_P2P_AddNotifyPeerConnectionEstablishedOptions* Options, void* ClientData, EOS_P2P_OnPeerConnectionEstablishedCallback ConnectionEstablishedHandler);

/**
 * Stop notifications for connections being established on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 *
 * @see EOS_P2P_AddNotifyPeerConnectionEstablished
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyPeerConnectionEstablished(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Listen for when a previously opened connection is interrupted. The connection will automatically attempt to reestablish, but it may not be successful.
 *
 * If a connection reconnects, it will trigger the P2P PeerConnectionEstablished notification with the EOS_CET_Reconnection connection type.
 * If a connection fails to reconnect, it will trigger the P2P PeerConnectionClosed notification.
 *
 * @param Options Information about who would like notifications about interrupted connections, and for which socket
 * @param ClientData This value is returned to the caller when ConnectionInterruptedHandler is invoked
 * @param ConnectionInterruptedHandler The callback to be fired when an open connection has been interrupted
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 *
 * @see EOS_P2P_AddNotifyPeerConnectionEstablished
 * @see EOS_P2P_AddNotifyPeerConnectionClosed
 * @see EOS_P2P_RemoveNotifyPeerConnectionInterrupted
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyPeerConnectionInterrupted(EOS_HP2P Handle, const EOS_P2P_AddNotifyPeerConnectionInterruptedOptions* Options, void* ClientData, EOS_P2P_OnPeerConnectionInterruptedCallback ConnectionInterruptedHandler);

/**
 * Stop notifications for connections being interrupted on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 *
 * @see EOS_P2P_AddNotifyPeerConnectionInterrupted
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyPeerConnectionInterrupted(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Listen for when a previously opened connection is closed.
 *
 * @param Options Information about who would like notifications about closed connections, and for which socket
 * @param ClientData This value is returned to the caller when ConnectionClosedHandler is invoked
 * @param ConnectionClosedHandler The callback to be fired when an open connection has been closed
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 *
 * @see EOS_P2P_AddNotifyPeerConnectionEstablished
 * @see EOS_P2P_AddNotifyPeerConnectionInterrupted
 * @see EOS_P2P_RemoveNotifyPeerConnectionClosed
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyPeerConnectionClosed(EOS_HP2P Handle, const EOS_P2P_AddNotifyPeerConnectionClosedOptions* Options, void* ClientData, EOS_P2P_OnRemoteConnectionClosedCallback ConnectionClosedHandler);

/**
 * Stop notifications for connections being closed on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 *
 * @see EOS_P2P_AddNotifyPeerConnectionClosed
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyPeerConnectionClosed(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Accept or Request a connection with a specific peer on a specific Socket ID.
 *
 * If this connection was not already locally accepted, we will securely message the peer, and trigger a PeerConnectionRequest notification notifying
 * them of the connection request. If the PeerConnectionRequest notification is not bound for all Socket IDs or for the requested Socket ID in particular,
 * the request will be silently ignored.
 *
 * If the remote peer accepts the connection, a notification will be broadcast to the EOS_P2P_AddNotifyPeerConnectionEstablished when the connection is
 * ready to send packets.
 *
 * If multiple Socket IDs are accepted with one peer, they will share one physical socket.
 *
 * Even if a connection is already locally accepted, EOS_EResult::EOS_Success will still be returned if the input was valid.
 *
 * @param Options Information about who would like to accept a connection, and which connection
 * @return EOS_EResult::EOS_Success - if the provided data is valid
 *         EOS_EResult::EOS_InvalidParameters - if the provided data is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_AcceptConnection(EOS_HP2P Handle, const EOS_P2P_AcceptConnectionOptions* Options);

/**
 * For all (or optionally one specific) Socket ID(s) with a specific peer: stop receiving packets, drop any locally queued packets, and if no other
 * Socket ID is using the connection with the peer, close the underlying connection.
 *
 * If your application wants to migrate an existing connection with a peer it already connected to, it is recommended to call EOS_P2P_AcceptConnection
 * with the new Socket ID first before calling EOS_P2P_CloseConnection, to prevent the shared physical socket from being torn down prematurely.
 *
 * @param Options Information about who would like to close a connection, and which connection.
 * @return EOS_EResult::EOS_Success - if the provided data is valid
 *         EOS_EResult::EOS_InvalidParameters - if the provided data is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_CloseConnection(EOS_HP2P Handle, const EOS_P2P_CloseConnectionOptions* Options);

/**
 * Close any open Connections for a specific Peer Connection ID.
 *
 * @param Options Information about who would like to close connections, and by what socket ID
 * @return EOS_EResult::EOS_Success - if the provided data is valid
 *         EOS_EResult::EOS_InvalidParameters - if the provided data is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_CloseConnections(EOS_HP2P Handle, const EOS_P2P_CloseConnectionsOptions* Options);

/**
 * Query the current NAT-type of our connection.
 *
 * @param Options Information about what version of the EOS_P2P_QueryNATType API is supported
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when we finish querying our NAT type
 */
EOS_DECLARE_FUNC(void) EOS_P2P_QueryNATType(EOS_HP2P Handle, const EOS_P2P_QueryNATTypeOptions* Options, void* ClientData, const EOS_P2P_OnQueryNATTypeCompleteCallback CompletionDelegate);

/**
 * Get our last-queried NAT-type, if it has been successfully queried.
 *
 * @param Options Information about what version of the EOS_P2P_GetNATType API is supported
 * @param OutNATType The queried NAT Type, or unknown if unknown
 * @return EOS_EResult::EOS_Success - if we have cached data
 *         EOS_EResult::EOS_NotFound - If we do not have queried data cached
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetNATType(EOS_HP2P Handle, const EOS_P2P_GetNATTypeOptions* Options, EOS_ENATType* OutNATType);

/**
 * Set how relay servers are to be used. This setting does not immediately apply to existing connections, but may apply to existing
 * connections if the connection requires renegotiation.
 *
 * @param Options Information about relay server config options
 * @return EOS_EResult::EOS_Success - if the options were set successfully
 *         EOS_EResult::EOS_InvalidParameters - if the options are invalid in some way
 *
 * @see EOS_ERelayControl
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_SetRelayControl(EOS_HP2P Handle, const EOS_P2P_SetRelayControlOptions* Options);

/**
 * Get the current relay control setting.
 *
 * @param Options Information about what version of the EOS_P2P_GetRelayControl API is supported
 * @param OutRelayControl The relay control setting currently configured
 * @return EOS_EResult::EOS_Success - if the input was valid
 *         EOS_EResult::EOS_InvalidParameters - if the input was invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetRelayControl(EOS_HP2P Handle, const EOS_P2P_GetRelayControlOptions* Options, EOS_ERelayControl* OutRelayControl);

/**
 * Set configuration options related to network ports.
 *
 * @param Options Information about network ports config options
 * @return EOS_EResult::EOS_Success - if the options were set successfully
 *         EOS_EResult::EOS_InvalidParameters - if the options are invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_SetPortRange(EOS_HP2P Handle, const EOS_P2P_SetPortRangeOptions* Options);

/**
 * Get the current chosen port and the amount of other ports to try above the chosen port if the chosen port is unavailable.
 *
 * @param Options Information about what version of the EOS_P2P_GetPortRange API is supported
 * @param OutPort The port that will be tried first
 * @param OutNumAdditionalPortsToTry The amount of ports to try above the value in OutPort, if OutPort is unavailable
 * @return EOS_EResult::EOS_Success - if the input options were valid
 *         EOS_EResult::EOS_InvalidParameters - if the input was invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetPortRange(EOS_HP2P Handle, const EOS_P2P_GetPortRangeOptions* Options, uint16_t* OutPort, uint16_t* OutNumAdditionalPortsToTry);

/**
 * Sets the maximum packet queue sizes that packets waiting to be sent or received can use. If the packet queue
 * size is made smaller than the current queue size while there are packets in the queue that would push this
 * packet size over, existing packets are kept but new packets may not be added to the full queue until enough
 * packets are sent or received.
 *
 * @param Options Information about packet queue size
 * @return EOS_EResult::EOS_Success - if the input options were valid
 *         EOS_EResult::EOS_InvalidParameters - if the input was invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_SetPacketQueueSize(EOS_HP2P Handle, const EOS_P2P_SetPacketQueueSizeOptions* Options);

/**
 * Gets the current cached information related to the incoming and outgoing packet queues.
 *
 * @param Options Information about what version of the EOS_P2P_GetPacketQueueInfo API is supported
 * @param OutPacketQueueInfo The current information of the incoming and outgoing packet queues
 * @return EOS_EResult::EOS_Success - if the input options were valid
 *         EOS_EResult::EOS_InvalidParameters - if the input was invalid in some way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_GetPacketQueueInfo(EOS_HP2P Handle, const EOS_P2P_GetPacketQueueInfoOptions* Options, EOS_P2P_PacketQueueInfo* OutPacketQueueInfo);

/**
 * Listen for when our packet queue has become full. This event gives an opportunity to read packets to make
 * room for new incoming packets. If this event fires and no packets are read by calling EOS_P2P_ReceivePacket
 * or the packet queue size is not increased by EOS_P2P_SetPacketQueueSize, any packets that are received after
 * this event are discarded until there is room again in the queue.
 *
 * @param Options Information about what version of the EOS_P2P_AddNotifyIncomingPacketQueueFull API is supported
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param IncomingPacketQueueFullHandler The callback to be fired when the incoming packet queue is full
 * @return A valid notification ID if successfully bound, or EOS_INVALID_NOTIFICATIONID otherwise
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_P2P_AddNotifyIncomingPacketQueueFull(EOS_HP2P Handle, const EOS_P2P_AddNotifyIncomingPacketQueueFullOptions* Options, void* ClientData, EOS_P2P_OnIncomingPacketQueueFullCallback IncomingPacketQueueFullHandler);

/**
 * Stop listening for full incoming packet queue events on a previously bound handler.
 *
 * @param NotificationId The previously bound notification ID
 */
EOS_DECLARE_FUNC(void) EOS_P2P_RemoveNotifyIncomingPacketQueueFull(EOS_HP2P Handle, EOS_NotificationId NotificationId);

/**
 * Clear queued incoming and outgoing packets.
 *
 * @param Options Information about which queues should be cleared
 * @return EOS_EResult::EOS_Success - if the input options were valid (even if queues were empty and no packets where cleared)
 *         EOS_EResult::EOS_IncompatibleVersion - if wrong API version
 *         EOS_EResult::EOS_InvalidUser - if an invalid/remote user was used
 *         EOS_EResult::EOS_InvalidParameters - if input was invalid in other way
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_P2P_ClearPacketQueue(EOS_HP2P Handle, const EOS_P2P_ClearPacketQueueOptions* Options);

```

`EAC_SDK/SDK/include/eos_p2p_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_P2PHandle* EOS_HP2P;

/**
 * A packet's maximum size in bytes
 */
#define EOS_P2P_MAX_PACKET_SIZE 1170

/**
 * The maximum amount of unique Socket ID connections that can be opened with each remote user. As this limit is only per remote user, you may have more
 * than this number of Socket IDs across multiple remote users.
 */
#define EOS_P2P_MAX_CONNECTIONS 32

/**
 * Categories of NAT strictness.
 */
EOS_ENUM(EOS_ENATType,
	/** NAT type either unknown (remote) or we are unable to determine it (local) */
	EOS_NAT_Unknown = 0,
	/** All peers can directly-connect to you */
	EOS_NAT_Open = 1,
	/** You can directly-connect to other Moderate and Open peers */
	EOS_NAT_Moderate = 2,
	/** You can only directly-connect to Open peers */
	EOS_NAT_Strict = 3
);

/** The most recent version of the EOS_P2P_SocketId structure. */
#define EOS_P2P_SOCKETID_API_LATEST 1

/** The total buffer size of a EOS_P2P_SocketId SocketName, including space for the null-terminator */
#define EOS_P2P_SOCKETID_SOCKETNAME_SIZE 33

/**
 * P2P Socket ID
 *
 * The Socket ID contains an application-defined name for the connection between a local person and another peer.
 *
 * When a remote user receives a connection request from you, they will receive this information.  It can be important
 * to only accept connections with a known socket-name and/or from a known user, to prevent leaking of private
 * information, such as a user's IP address. Using the socket name as a secret key can help prevent such leaks. Shared
 * private data, like a private match's Session ID are good candidates for a socket name.
 */
EOS_STRUCT(EOS_P2P_SocketId, (
	/** API Version: Set this to EOS_P2P_SOCKETID_API_LATEST. */
	int32_t ApiVersion;
	/** A name for the connection. Must be a NULL-terminated string of between 1-32 alpha-numeric characters (A-Z, a-z, 0-9, '-', '_', ' ', '+', '=', '.') */
	char SocketName[EOS_P2P_SOCKETID_SOCKETNAME_SIZE];
));

/**
 * Types of packet reliability.
 *
 * Ordered packets will only be ordered relative to other ordered packets. Reliable/unreliable and ordered/unordered communication
 * can be sent on the same Socket ID and Channel.
 */
EOS_ENUM(EOS_EPacketReliability,
	/** Packets will only be sent once and may be received out of order */
	EOS_PR_UnreliableUnordered = 0,
	/** Packets may be sent multiple times and may be received out of order */
	EOS_PR_ReliableUnordered = 1,
	/** Packets may be sent multiple times and will be received in order */
	EOS_PR_ReliableOrdered = 2
);

/** The most recent version of the EOS_P2P_SendPacket API. */
#define EOS_P2P_SENDPACKET_API_LATEST 3

/**
 * Structure containing information about the data being sent and to which player
 */
EOS_STRUCT(EOS_P2P_SendPacketOptions, (
	/** API Version: Set this to EOS_P2P_SENDPACKET_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is sending this packet */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the Peer you would like to send a packet to */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID for data you are sending in this packet */
	const EOS_P2P_SocketId* SocketId;
	/** Channel associated with this data */
	uint8_t Channel;
	/** The size of the data to be sent to the RemoteUser */
	uint32_t DataLengthBytes;
	/** The data to be sent to the RemoteUser */
	const void* Data;
	/** If false and we do not already have an established connection to the peer, this data will be dropped */
	EOS_Bool bAllowDelayedDelivery;
	/** Setting to control the delivery reliability of this packet */
	EOS_EPacketReliability Reliability;
	/**
	 * If set to EOS_TRUE, EOS_P2P_SendPacket will not automatically establish a connection with the RemoteUserId and will require explicit calls to
	 * EOS_P2P_AcceptConnection first whenever the connection is closed. If set to EOS_FALSE, EOS_P2P_SendPacket will automatically accept and start
	 * the connection any time it is called and the connection is not already open.
	 */
	EOS_Bool bDisableAutoAcceptConnection;
));

/** The most recent version of the EOS_P2P_GetNextReceivedPacketSize API. */
#define EOS_P2P_GETNEXTRECEIVEDPACKETSIZE_API_LATEST 2

/**
 * Structure containing information about who would like to receive a packet.
 */
EOS_STRUCT(EOS_P2P_GetNextReceivedPacketSizeOptions, (
	/** API Version: Set this to EOS_P2P_GETNEXTRECEIVEDPACKETSIZE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is receiving the packet */
	EOS_ProductUserId LocalUserId;
	/** An optional channel to request the data for. If NULL, we're retrieving the size of the next packet on any channel. */
	const uint8_t* RequestedChannel;

));

/** The most recent version of the EOS_P2P_ReceivePacket API. */
#define EOS_P2P_RECEIVEPACKET_API_LATEST 2

/**
 * Structure containing information about who would like to receive a packet, and how much data can be stored safely.
 */
EOS_STRUCT(EOS_P2P_ReceivePacketOptions, (
	/** API Version: Set this to EOS_P2P_RECEIVEPACKET_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who is receiving the packet */
	EOS_ProductUserId LocalUserId;
	/** The maximum amount of data in bytes that can be safely copied to OutData in the function call */
	uint32_t MaxDataSizeBytes;
	/** An optional channel to request the data for. If NULL, we're retrieving the next packet on any channel */
	const uint8_t* RequestedChannel;
));

/** The most recent version of the EOS_P2P_AddNotifyPeerConnectionRequest API. */
#define EOS_P2P_ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST 1

/**
 * Structure containing information about who would like connection notifications, and about which socket.
 */
EOS_STRUCT(EOS_P2P_AddNotifyPeerConnectionRequestOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who is listening for incoming connection requests */
	EOS_ProductUserId LocalUserId;
	/** The optional socket ID to listen for, used as a filter for incoming connection requests; If NULL, incoming connection requests will not be filtered */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Structure containing information about an incoming connection request.
 */
EOS_STRUCT(EOS_P2P_OnIncomingConnectionRequestInfo, (
	/** Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged */
	void* ClientData;
	/** The Product User ID of the local user who is being requested to open a P2P session with RemoteUserId */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who requested a peer connection with the local user */
	EOS_ProductUserId RemoteUserId;
	/** The ID of the socket the Remote User wishes to communicate on */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Callback for information related to incoming connection requests.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnIncomingConnectionRequestCallback, const EOS_P2P_OnIncomingConnectionRequestInfo* Data);

/** The most recent version of the EOS_P2P_AddNotifyPeerConnectionEstablished API. */
#define EOS_P2P_ADDNOTIFYPEERCONNECTIONESTABLISHED_API_LATEST 1

/**
 * Structure containing information about which connections should be notified
 */
EOS_STRUCT(EOS_P2P_AddNotifyPeerConnectionEstablishedOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONESTABLISHED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like to receive notifications */
	EOS_ProductUserId LocalUserId;
	/** The optional socket ID, used as a filter for established connections. If NULL, this function handler will be called for all sockets */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Type of established connection
 */
EOS_ENUM(EOS_EConnectionEstablishedType,
	/** The connection is brand new */
	EOS_CET_NewConnection = 0,
	/** The connection is reestablished (reconnection) */
	EOS_CET_Reconnection = 1
);

/**
 * Types of network connections.
 */
EOS_ENUM(EOS_ENetworkConnectionType,
	/** There is no established connection */
	EOS_NCT_NoConnection = 0,
	/** A direct connection to the peer over the Internet or Local Network */
	EOS_NCT_DirectConnection = 1,
	/** A relayed connection using Epic-provided servers to the peer over the Internet */
	EOS_NCT_RelayedConnection = 2
);

/**
 * Structure containing information about a connection being established
 */
EOS_STRUCT(EOS_P2P_OnPeerConnectionEstablishedInfo, (
	/** Client-specified data passed into EOS_P2P_AddNotifyPeerConnectionEstablished */
	void* ClientData;
	/** The Product User ID of the local user who is being notified of a connection being established */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who this connection was with */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection being established */
	const EOS_P2P_SocketId* SocketId;
	/** Information if this is a new connection or reconnection */
	EOS_EConnectionEstablishedType ConnectionType;
	/** What type of network connection is being used for this connection */
	EOS_ENetworkConnectionType NetworkType;
));

/**
 * Callback for information related to new connections being established
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnPeerConnectionEstablishedCallback, const EOS_P2P_OnPeerConnectionEstablishedInfo* Data);


/** The most recent version of the EOS_P2P_AddNotifyPeerConnectionInterrupted API. */
#define EOS_P2P_ADDNOTIFYPEERCONNECTIONINTERRUPTED_API_LATEST 1

/**
 * Structure containing information about who would like notifications about interrupted connections, and for which socket.
 */
EOS_STRUCT(EOS_P2P_AddNotifyPeerConnectionInterruptedOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONINTERRUPTED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like notifications */
	EOS_ProductUserId LocalUserId;
	/** An optional socket ID to filter interrupted connections on. If NULL, this function handler will be called for all interrupted connections */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Structure containing information about an connection request that is that was interrupted.
 */
EOS_STRUCT(EOS_P2P_OnPeerConnectionInterruptedInfo, (
	/** Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged */
	void* ClientData;
	/** The local user who is being notified of a connection that was interrupted */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who this connection was with */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection that was interrupted */
	const EOS_P2P_SocketId* SocketId;
));


/**
 * Callback for information related to open connections that are interrupted.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnPeerConnectionInterruptedCallback, const EOS_P2P_OnPeerConnectionInterruptedInfo* Data);

/** The most recent version of the EOS_P2P_AddNotifyPeerConnectionClosed API. */
#define EOS_P2P_ADDNOTIFYPEERCONNECTIONCLOSED_API_LATEST 1

/**
 * Structure containing information about who would like notifications about closed connections, and for which socket.
 */
EOS_STRUCT(EOS_P2P_AddNotifyPeerConnectionClosedOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYPEERCONNECTIONCLOSED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like notifications */
	EOS_ProductUserId LocalUserId;
	/** The optional socket ID to listen for to be closed. If NULL, this function handler will be called for all closed connections */
	const EOS_P2P_SocketId* SocketId;
));

/**
 * Reasons why a P2P connection was closed
 */
EOS_ENUM(EOS_EConnectionClosedReason,
	/** The connection was closed for unknown reasons. This most notably happens during application shutdown. */
	EOS_CCR_Unknown = 0,
	/** The connection was at least locally accepted, but was closed by the local user via a call to EOS_P2P_CloseConnection / EOS_P2P_CloseConnections. */
	EOS_CCR_ClosedByLocalUser = 1,
	/** The connection was at least locally accepted, but was gracefully closed by the remote user via a call to EOS_P2P_CloseConnection / EOS_P2P_CloseConnections. */
	EOS_CCR_ClosedByPeer = 2,
	/** The connection was at least locally accepted, but was not remotely accepted in time. */
	EOS_CCR_TimedOut = 3,
	/** The connection was accepted, but the connection could not be created due to too many other existing connections */
	EOS_CCR_TooManyConnections = 4,
	/** The connection was accepted, The remote user sent an invalid message */
	EOS_CCR_InvalidMessage = 5,
	/** The connection was accepted, but the remote user sent us invalid data */
	EOS_CCR_InvalidData = 6,
	/** The connection was accepted, but we failed to ever establish a connection with the remote user due to connectivity issues. */
	EOS_CCR_ConnectionFailed = 7,
	/** The connection was accepted and established, but the peer silently went away. */
	EOS_CCR_ConnectionClosed = 8,
	/** The connection was locally accepted, but we failed to negotiate a connection with the remote user. This most commonly occurs if the local user goes offline or is logged-out during the connection process. */
	EOS_CCR_NegotiationFailed = 9,
	/** The connection was accepted, but there was an internal error occurred and the connection cannot be created or continue. */
	EOS_CCR_UnexpectedError = 10
);

/**
 * Structure containing information about an connection request that is being closed.
 */
EOS_STRUCT(EOS_P2P_OnRemoteConnectionClosedInfo, (
	/** Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged */
	void* ClientData;
	/** The local user who is being notified of a connection being closed */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who this connection was with */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection being closed */
	const EOS_P2P_SocketId* SocketId;
	/** The reason the connection was closed (if known) */
	EOS_EConnectionClosedReason Reason;
));

/**
 * Callback for information related to open connections being closed.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnRemoteConnectionClosedCallback, const EOS_P2P_OnRemoteConnectionClosedInfo* Data);

/** The most recent version of the EOS_P2P_AcceptConnection API. */
#define EOS_P2P_ACCEPTCONNECTION_API_LATEST 1

/**
 * Structure containing information about who would like to accept a connection, and which connection.
 */
EOS_STRUCT(EOS_P2P_AcceptConnectionOptions, (
	/** API Version: Set this to EOS_P2P_ACCEPTCONNECTION_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is accepting any pending or future connections with RemoteUserId */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user who has either sent a connection request or is expected to in the future */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection to accept on */
	const EOS_P2P_SocketId* SocketId;
));

/** The most recent version of the EOS_P2P_CloseConnection API. */
#define EOS_P2P_CLOSECONNECTION_API_LATEST 1

/**
 * Structure containing information about who would like to close a connection, and which connection.
 */
EOS_STRUCT(EOS_P2P_CloseConnectionOptions, (
	/** API Version: Set this to EOS_P2P_CLOSECONNECTION_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like to close a previously accepted connection (or decline a pending invite) */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the remote user to disconnect from (or to reject a pending invite from) */
	EOS_ProductUserId RemoteUserId;
	/** The socket ID of the connection to close (or optionally NULL to not accept any connection requests from the Remote User) */
	const EOS_P2P_SocketId* SocketId;
));

/** The most recent version of the EOS_P2P_CloseConnections API. */
#define EOS_P2P_CLOSECONNECTIONS_API_LATEST 1

/**
 * Structure containing information about who would like to close connections, and by what socket ID
 */
EOS_STRUCT(EOS_P2P_CloseConnectionsOptions, (
	/** API Version: Set this to EOS_P2P_CLOSECONNECTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who would like to close all connections that use a particular socket ID */
	EOS_ProductUserId LocalUserId;
	/** The socket ID of the connections to close */
	const EOS_P2P_SocketId* SocketId;
));

/** The most recent version of the EOS_P2P_QueryNATType API. */
#define EOS_P2P_QUERYNATTYPE_API_LATEST 1

/**
 * Structure containing information needed to query NAT-types
 */
EOS_STRUCT(EOS_P2P_QueryNATTypeOptions, (
	/** API Version: Set this to EOS_P2P_QUERYNATTYPE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Structure containing information about the local network NAT type
 */
EOS_STRUCT(EOS_P2P_OnQueryNATTypeCompleteInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful query, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_P2P_QueryNATType */
	void* ClientData;
	/** The queried NAT type */
	EOS_ENATType NATType;
));

/**
 * Callback for information related to our NAT type query completing.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnQueryNATTypeCompleteCallback, const EOS_P2P_OnQueryNATTypeCompleteInfo* Data);

/** The most recent version of the EOS_P2P_GetNATType API. */
#define EOS_P2P_GETNATTYPE_API_LATEST 1

/**
 * Structure containing information needed to get previously queried NAT-types
 */
EOS_STRUCT(EOS_P2P_GetNATTypeOptions, (
	/** API Version: Set this to EOS_P2P_GETNATTYPE_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Setting for controlling whether relay servers are used.
 *
 * Please see the following EOS_ERelayControl value compatibility-chart to better understand how changing this value
 * can affect compatibility between clients with different settings.
 *
 * +------------------------------+---------------------+-------------------------------+---------------------+
 * |                              |   EOS_RC_NoRelays   |  EOS_RC_AllowRelays (Default) |  EOS_RC_ForceRelays |
 * +------------------------------+---------------------+-------------------------------+---------------------+
 * | EOS_RC_NoRelays              |  Compatible         |  Compatible                   |  Connection Failure |
 * | EOS_RC_AllowRelays (Default) |  Compatible         |  Compatible                   |  Compatible         |
 * | EOS_RC_ForceRelays           |  Connection Failure |  Compatible                   |  Compatible         |
 * +------------------------------+---------------------+-------------------------------+---------------------+
 */
EOS_ENUM(EOS_ERelayControl,
	/** Peer connections will never attempt to use relay servers. Clients with restrictive NATs may not be able to connect to peers. */
	EOS_RC_NoRelays = 0,
	/** Peer connections will attempt to use relay servers, but only after direct connection attempts fail. This is the default value if not changed. */
	EOS_RC_AllowRelays = 1,
	/** Peer connections will only ever use relay servers. This will add latency to all connections, but will hide IP Addresses from peers. */
	EOS_RC_ForceRelays = 2
);

/** The most recent version of the EOS_P2P_SetRelayControl API. */
#define EOS_P2P_SETRELAYCONTROL_API_LATEST 1

/**
 * Structure containing information about new relay configurations.
 */
EOS_STRUCT(EOS_P2P_SetRelayControlOptions, (
	/** API Version: Set this to EOS_P2P_SETRELAYCONTROL_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The requested level of relay servers for P2P connections. This setting is only applied to new P2P connections, or when existing P2P connections
	 * reconnect during a temporary connectivity outage. Peers with an incompatible setting to the local setting will not be able to connect.
	 */
	EOS_ERelayControl RelayControl;
));

/** The most recent version of the EOS_P2P_GetRelayControl API. */
#define EOS_P2P_GETRELAYCONTROL_API_LATEST 1

/**
 * Structure containing information about getting the relay control setting.
 */
EOS_STRUCT(EOS_P2P_GetRelayControlOptions, (
	/** API Version: Set this to EOS_P2P_GETRELAYCONTROL_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_P2P_SetPortRange API. */
#define EOS_P2P_SETPORTRANGE_API_LATEST 1

/**
 * Structure containing information about new port range settings.
 */
EOS_STRUCT(EOS_P2P_SetPortRangeOptions, (
	/** API Version: Set this to EOS_P2P_SETPORTRANGE_API_LATEST. */
	int32_t ApiVersion;
	/** The ideal port to use for P2P traffic. The default value is 7777. If set to 0, the OS will choose a port. If set to 0, MaxAdditionalPortsToTry must be set to 0. */
	uint16_t Port;
	/**
	 * The maximum amount of additional ports to try if Port is unavailable. Ports will be tried from Port to Port + MaxAdditionalPortsToTry
	 * inclusive, until one is available or we run out of ports. If no ports are available, P2P connections will fail. The default value is 99.
	 */
	uint16_t MaxAdditionalPortsToTry;
));

/** The most recent version of the EOS_P2P_GetPortRange API. */
#define EOS_P2P_GETPORTRANGE_API_LATEST 1

/**
 * Structure containing information about getting the configured port range settings.
 */
EOS_STRUCT(EOS_P2P_GetPortRangeOptions, (
	/** API Version: Set this to EOS_P2P_GETPORTRANGE_API_LATEST. */
	int32_t ApiVersion;
));

/** Helper constant to signify that the packet queue is allowed to grow indefinitely */
#define EOS_P2P_MAX_QUEUE_SIZE_UNLIMITED 0

/** The most recent version of the EOS_P2P_SetPacketQueueSize API. */
#define EOS_P2P_SETPACKETQUEUESIZE_API_LATEST 1

/**
 * Structure containing information about new packet queue size settings.
 */
EOS_STRUCT(EOS_P2P_SetPacketQueueSizeOptions, (
	/** API Version: Set this to EOS_P2P_SETPACKETQUEUESIZE_API_LATEST. */
	int32_t ApiVersion;
	/** The ideal maximum amount of bytes the Incoming packet queue can consume */
	uint64_t IncomingPacketQueueMaxSizeBytes;
	/** The ideal maximum amount of bytes the Outgoing packet queue can consume */
	uint64_t OutgoingPacketQueueMaxSizeBytes;
));

/** The most recent version of the EOS_P2P_GetPacketQueueInfo API. */
#define EOS_P2P_GETPACKETQUEUEINFO_API_LATEST 1

/**
 * Structure containing information needed to get the current packet queue information.
 */
EOS_STRUCT(EOS_P2P_GetPacketQueueInfoOptions, (
	/** API Version: Set this to EOS_P2P_GETPACKETQUEUEINFO_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Information related to the current state of the packet queues. It is possible for the current size
 * to be larger than the maximum size if the maximum size changes or if the maximum queue size is
 * set to EOS_P2P_MAX_QUEUE_SIZE_UNLIMITED.
 */
EOS_STRUCT(EOS_P2P_PacketQueueInfo, (
	/** The maximum size in bytes of the incoming packet queue */
	uint64_t IncomingPacketQueueMaxSizeBytes;
	/** The current size in bytes of the incoming packet queue */
	uint64_t IncomingPacketQueueCurrentSizeBytes;
	/** The current number of queued packets in the incoming packet queue */
	uint64_t IncomingPacketQueueCurrentPacketCount;
	/** The maximum size in bytes of the outgoing packet queue */
	uint64_t OutgoingPacketQueueMaxSizeBytes;
	/** The current size in bytes of the outgoing packet queue */
	uint64_t OutgoingPacketQueueCurrentSizeBytes;
	/** The current amount of queued packets in the outgoing packet queue */
	uint64_t OutgoingPacketQueueCurrentPacketCount;
));

/** The most recent version of the EOS_P2P_AddNotifyIncomingPacketQueueFull API. */
#define EOS_P2P_ADDNOTIFYINCOMINGPACKETQUEUEFULL_API_LATEST 1

/**
 * Structure containing information about what version of the EOS_P2P_AddNotifyIncomingPacketQueueFull function is supported.
 */
EOS_STRUCT(EOS_P2P_AddNotifyIncomingPacketQueueFullOptions, (
	/** API Version: Set this to EOS_P2P_ADDNOTIFYINCOMINGPACKETQUEUEFULL_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Structure containing information about the packet queue's state and the incoming packet that would overflow the queue
 */
EOS_STRUCT(EOS_P2P_OnIncomingPacketQueueFullInfo, (
	/** Client-specified data passed into AddNotifyIncomingPacketQueueFull */
	void* ClientData;
	/** The maximum size in bytes the incoming packet queue is allowed to use */
	uint64_t PacketQueueMaxSizeBytes;
	/** The current size in bytes the incoming packet queue is currently using */
	uint64_t PacketQueueCurrentSizeBytes;
	/** The Product User ID of the local user who is receiving the packet that would overflow the queue */
	EOS_ProductUserId OverflowPacketLocalUserId;
	/** The channel the incoming packet is for */
	uint8_t OverflowPacketChannel;
	/** The size in bytes of the incoming packet (and related metadata) that would overflow the queue */
	uint32_t OverflowPacketSizeBytes;
));

/**
 * Callback for information related to incoming connection requests.
 */
EOS_DECLARE_CALLBACK(EOS_P2P_OnIncomingPacketQueueFullCallback, const EOS_P2P_OnIncomingPacketQueueFullInfo* Data);

/** The most recent version of the EOS_P2P_ClearPacketQueue API. */
#define EOS_P2P_CLEARPACKETQUEUE_API_LATEST 1

/**
 * Structure containing information about the packet queue to be cleared
 */
EOS_STRUCT(EOS_P2P_ClearPacketQueueOptions, (
	/** API Version: Set this to EOS_P2P_CLEARPACKETQUEUE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user for whom we want to clear the queued packets */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID to who (outgoing) or from who (incoming) packets are queued */
	EOS_ProductUserId RemoteUserId;
	/** The socket used for packets to be cleared */
	const EOS_P2P_SocketId* SocketId;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_platform_prereqs.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/******************************************************************************
 *
 * Please refer to https://dev.epicgames.com/docs/services for more details
 * on platform specific development.
 *
 * Some platforms need additional setup before `eos_base.h` is called.
 * The `eos_base.h` header is included by all EOS SDK headers.  This header
 * file provides one way of allowing cross platform development with minimal
 * setup.
 *
 * To use this add the EOS_BUILD_PLATFORM_NAME define when building platforms
 * which need to include a `<Platform>/eos_<Platform>_base.h`. The value of
 * EOS_BUILD_PLATFORM_NAME will be placed in the `<Platform>` spot.  Not all
 * platforms need one of these base header files. Blank files are still provided
 * for the platforms that do not require it.
 *
 * Alternatives to this header are to have the necessary file explicitly
 * included.  This is a good solution if only a single platform is needed.
 * For example:
 *   #include "ThePlatform/eos_ThePlatform_base.h"
 *   #include "eos_sdk.h"
 *   #include "eos_friends_types.h"
 *
 * Another option is to use the macros provided by the custom compiler to
 * determine which include to use.
 * For example:
 *   #if defined(__THECOMPILER__)
 *   #include "ThePlatform/eos_ThePlatform_base.h"
 *   #elif defined(__SOMECOMPILER__)
 *   #include "SomePlatform/eos_SomePlatform_base.h"
 *   #endif
 *   #include "eos_sdk.h"
 *   #include "eos_friends_types.h"
 *
 ******************************************************************************/

#if defined(EOS_BUILD_PLATFORM_NAME)

#if defined(EOS_USE_DLLEXPORT) || defined(USE_CALL) || defined(EOS_MEMORY_CALL)
#error \
The macros EOS_MEMORY_CALL, EOS_CALL, and EOS_USE_DLLEXPORT where unexpectedly partially defined. \
This can occur if `eos_platform_prereqs.h` is included after `eos_base.h` is included. \
Please refer to https://dev.epicgames.com/docs/services for more details.
#endif

#undef EOS_PREPROCESSOR_TO_STRING
#define EOS_PREPROCESSOR_TO_STRING(x) EOS_PREPROCESSOR_TO_STRING_INNER(x)
#undef EOS_PREPROCESSOR_TO_STRING_INNER
#define EOS_PREPROCESSOR_TO_STRING_INNER(x) #x
#undef EOS_PREPROCESSOR_JOIN
#define EOS_PREPROCESSOR_JOIN(x,y) EOS_PREPROCESSOR_JOIN_INNER(x,y)
#undef EOS_PREPROCESSOR_JOIN_INNER
#define EOS_PREPROCESSOR_JOIN_INNER(x,y) x##y
#define EOS_BUILD_PLATFORM_HEADER_BASE EOS_PREPROCESSOR_TO_STRING(EOS_PREPROCESSOR_JOIN(EOS_BUILD_PLATFORM_NAME/eos_,EOS_PREPROCESSOR_JOIN(EOS_BUILD_PLATFORM_NAME,_base.h)))

#include EOS_BUILD_PLATFORM_HEADER_BASE

#endif


```

`EAC_SDK/SDK/include/eos_playerdatastorage.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_playerdatastorage_types.h"

/**
 * The following EOS_PlayerDataStorage_* functions allow you to query file metadata; create/upload files; and duplicate, read, and delete existing files
 */

/**
 * Query a specific file's metadata, such as file names, size, and a MD5 hash of the data. This is not required before a file may be opened, saved, copied, or deleted. Once a file has
 * been queried, its metadata will be available by the EOS_PlayerDataStorage_CopyFileMetadataAtIndex and EOS_PlayerDataStorage_CopyFileMetadataByFilename functions.
 *
 * @param QueryFileOptions Object containing properties related to which user is querying files, and what file is being queried
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the query operation completes
 *
 * @return EOS_Success if the query completes successfully and a file is found
 *         EOS_NotFound if no file is found
 *
 * @see EOS_PlayerDataStorage_GetFileMetadataCount
 * @see EOS_PlayerDataStorage_CopyFileMetadataAtIndex
 * @see EOS_PlayerDataStorage_CopyFileMetadataByFilename
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_QueryFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_QueryFileOptions* QueryFileOptions, void* ClientData, const EOS_PlayerDataStorage_OnQueryFileCompleteCallback CompletionCallback);

/**
 * Query the file metadata, such as file names, size, and a MD5 hash of the data, for all files owned by this user for this application. This is not required before a file may be opened,
 * saved, copied, or deleted.
 *
 * @param QueryFileListOptions Object containing properties related to which user is querying files
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the query operation completes
 *
 * @return EOS_Success if the query completes successfully (whether any files are found or not)
 *
 * @see EOS_PlayerDataStorage_GetFileMetadataCount
 * @see EOS_PlayerDataStorage_CopyFileMetadataAtIndex
 * @see EOS_PlayerDataStorage_CopyFileMetadataByFilename
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_QueryFileList(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_QueryFileListOptions* QueryFileListOptions, void* ClientData, const EOS_PlayerDataStorage_OnQueryFileListCompleteCallback CompletionCallback);

/**
 * Create the cached copy of a file's metadata by filename. The metadata will be for the last retrieved or successfully saved version, and will not include any changes that have not
 * completed writing. The returned pointer must be released by the user when no longer needed.
 *
 * @param CopyFileMetadataOptions Object containing properties related to which user is requesting metadata, and for which filename
 * @param OutMetadata A copy of the FileMetadata structure will be set if successful.  This data must be released by calling EOS_PlayerDataStorage_FileMetadata_Release.
 * @return EOS_EResult::EOS_Success if the metadata is currently cached, otherwise an error result explaining what went wrong
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorage_CopyFileMetadataByFilename(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions* CopyFileMetadataOptions, EOS_PlayerDataStorage_FileMetadata ** OutMetadata);

/**
 * Get the count of files we have previously queried information for and files we have previously read from / written to.
 *
 * @param GetFileMetadataCountOptions Object containing properties related to which user is requesting the metadata count
 * @param OutFileMetadataCount If successful, the count of metadata currently cached
 * @return EOS_EResult::EOS_Success if the input was valid, otherwise an error result explaining what went wrong
 *
 * @see EOS_PlayerDataStorage_CopyFileMetadataAtIndex
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorage_GetFileMetadataCount(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_GetFileMetadataCountOptions* GetFileMetadataCountOptions, int32_t* OutFileMetadataCount);

/**
 * Get the cached copy of a file's metadata by index. The metadata will be for the last retrieved or successfully saved version, and will not include any local changes that have not been
 * committed by calling SaveFile. The returned pointer must be released by the user when no longer needed.
 *
 * @param CopyFileMetadataOptions Object containing properties related to which user is requesting metadata, and at what index
 * @param OutMetadata A copy of the FileMetadata structure will be set if successful.  This data must be released by calling EOS_PlayerDataStorage_FileMetadata_Release.
 * @return EOS_EResult::EOS_Success if the requested metadata is currently cached, otherwise an error result explaining what went wrong
 *
 * @see EOS_PlayerDataStorage_GetFileMetadataCount
 * @see EOS_PlayerDataStorage_FileMetadata_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorage_CopyFileMetadataAtIndex(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions* CopyFileMetadataOptions, EOS_PlayerDataStorage_FileMetadata ** OutMetadata);

/**
 * Copies the data of an existing file to a new filename. This action happens entirely on the server and will not upload the contents of the source destination file from the host. This
 * function paired with a subsequent EOS_PlayerDataStorage_DeleteFile can be used to rename a file. If successful, the destination file's metadata will be updated in our local cache.
 *
 * @param DuplicateOptions Object containing properties related to which user is duplicating the file, and what the source and destination file names are
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the duplicate operation completes
 *
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_DuplicateFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_DuplicateFileOptions* DuplicateOptions, void* ClientData, const EOS_PlayerDataStorage_OnDuplicateFileCompleteCallback CompletionCallback);

/**
 * Deletes an existing file in the cloud. If successful, the file's data will be removed from our local cache.
 *
 * @param DeleteOptions Object containing properties related to which user is deleting the file, and what file name is
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the delete operation completes
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_DeleteFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_DeleteFileOptions* DeleteOptions, void* ClientData, const EOS_PlayerDataStorage_OnDeleteFileCompleteCallback CompletionCallback);

/**
 * Retrieve the contents of a specific file, potentially downloading the contents if we do not have a local copy, from the cloud. This request will occur asynchronously, potentially over
 * multiple frames. All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at
 * least once if the request is started successfully.
 *
 * @param ReadOptions Object containing properties related to which user is opening the file, what the file's name is, and related mechanisms for copying the data
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the read operation completes
 * @return A valid Player Data Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
 *
 * @return EOS_Success if the file is exists and the read operation completes successfully
 *         EOS_NotFound if no file is found
 *
 * @see EOS_PlayerDataStorageFileTransferRequest_Release
 */
EOS_DECLARE_FUNC(EOS_HPlayerDataStorageFileTransferRequest) EOS_PlayerDataStorage_ReadFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_ReadFileOptions* ReadOptions, void* ClientData, const EOS_PlayerDataStorage_OnReadFileCompleteCallback CompletionCallback);

/**
 * Write new data to a specific file, potentially overwriting any existing file by the same name, to the cloud. This request will occur asynchronously, potentially over multiple frames.
 * All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at least once if the
 * request is started successfully.
 *
 * @param WriteOptions Object containing properties related to which user is writing the file, what the file's name is, and related mechanisms for writing the data
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the write operation completes
 * @return A valid Player Data Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
 *
 * @see EOS_PlayerDataStorageFileTransferRequest_Release
 */
EOS_DECLARE_FUNC(EOS_HPlayerDataStorageFileTransferRequest) EOS_PlayerDataStorage_WriteFile(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_WriteFileOptions* WriteOptions, void* ClientData, const EOS_PlayerDataStorage_OnWriteFileCompleteCallback CompletionCallback);

/**
 * Clear previously cached file data. This operation will be done asynchronously. All cached files except those corresponding to the transfers in progress will be removed.
 * Warning: Use this with care. Cache system generally tries to clear old and unused cached files from time to time. Unnecessarily clearing cache can degrade performance as SDK will have to re-download data.
 *
 * @param Options Object containing properties related to which user is deleting cache
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the delete cache operation completes
 * @return EOS_Success if the operation was started correctly, otherwise an error result explaining what went wrong
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorage_DeleteCache(EOS_HPlayerDataStorage Handle, const EOS_PlayerDataStorage_DeleteCacheOptions* Options, void* ClientData, const EOS_PlayerDataStorage_OnDeleteCacheCompleteCallback CompletionCallback);

/**
 * Below are helper functions to retrieve information about a file request handle, or to attempt to cancel a request in progress.
 */

/**
 * Get the current state of a file request.
 *
 * @return EOS_Success if complete and successful, EOS_PlayerDataStorage_RequestInProgress if the request is still in progress, or another state for failure.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorageFileTransferRequest_GetFileRequestState(EOS_HPlayerDataStorageFileTransferRequest Handle);

/**
 * Get the file name of the file this request is for. OutStringLength will always be set to the string length of the file name if it is not NULL.
 *
 * @param FilenameStringBufferSizeBytes The maximum number of bytes that can be written to OutStringBuffer
 * @param OutStringBuffer The buffer to write the NULL-terminated utf8 file name into, if successful
 * @param OutStringLength How long the file name is (not including null terminator)
 * @return EOS_Success if the file name was successfully written to OutFilenameBuffer, a failure result otherwise
 *
 * @see EOS_PLAYERDATASTORAGE_FILENAME_MAX_LENGTH_BYTES
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorageFileTransferRequest_GetFilename(EOS_HPlayerDataStorageFileTransferRequest Handle, uint32_t FilenameStringBufferSizeBytes, char* OutStringBuffer, int32_t* OutStringLength);

/**
 * Attempt to cancel this file request in progress. This is a best-effort command and is not guaranteed to be successful if the request has completed before this function is called.
 *
 * @return EOS_Success if cancel is successful, EOS_NoChange if request had already completed (can't be canceled), EOS_AlreadyPending if it's already been canceled before (this is a final state for canceled request and won't change over time).
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PlayerDataStorageFileTransferRequest_CancelRequest(EOS_HPlayerDataStorageFileTransferRequest Handle);

```

`EAC_SDK/SDK/include/eos_playerdatastorage_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** Maximum File Name Length in bytes */
#define EOS_PLAYERDATASTORAGE_FILENAME_MAX_LENGTH_BYTES 64

EXTERN_C typedef struct EOS_PlayerDataStorageHandle* EOS_HPlayerDataStorage;

/** Timestamp value representing an undefined time for Player Data Storage. */
#define EOS_PLAYERDATASTORAGE_TIME_UNDEFINED -1

#define EOS_PLAYERDATASTORAGE_FILEMETADATA_API_LATEST 3

/**
 * Metadata information for a specific file
 */
EOS_STRUCT(EOS_PlayerDataStorage_FileMetadata, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_FILEMETADATA_API_LATEST. */
	int32_t ApiVersion;
	/** The total size of the file in bytes (Includes file header in addition to file contents) */
	uint32_t FileSizeBytes;
	/** The MD5 Hash of the entire file (including additional file header), in hex digits */
	const char* MD5Hash;
	/** The file's name */
	const char* Filename;
	/**
	 * The POSIX timestamp when the file was saved last time or EOS_PLAYERDATASTORAGE_TIME_UNDEFINED if the time is undefined.
	 * It will be undefined after a file is written and uploaded at first before a query operation is completed.
	 */
	int64_t LastModifiedTime;
	/** The size of data (payload) in file in unencrypted (original) form. */
	uint32_t UnencryptedDataSizeBytes;
));

/**
 * Free the memory used by the file metadata
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorage_FileMetadata_Release(EOS_PlayerDataStorage_FileMetadata* FileMetadata);

/** The most recent version of the EOS_PlayerDataStorage_QueryFile API. */
#define EOS_PLAYERDATASTORAGE_QUERYFILE_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_QUERYFILE_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_QUERYFILEOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_QUERYFILE_API_LATEST

/**
 * Input data for the EOS_PlayerDataStorage_QueryFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_QueryFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_QUERYFILE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting file metadata */
	EOS_ProductUserId LocalUserId;
	/** The name of the file being queried */
	const char* Filename;
));

/**
 * Data containing information about a query file request
 */
EOS_STRUCT(EOS_PlayerDataStorage_QueryFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file query request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
));
/**
 * Callback for when EOS_PlayerDataStorage_QueryFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnQueryFileCompleteCallback, const EOS_PlayerDataStorage_QueryFileCallbackInfo* Data);

/** The most recent version of the EOS_PlayerDataStorage_QueryFileList API. */
#define EOS_PLAYERDATASTORAGE_QUERYFILELIST_API_LATEST 2
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_QUERYFILELIST_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_QUERYFILELISTOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_QUERYFILELIST_API_LATEST

/**
 * Input data for the EOS_PlayerDataStorage_QueryFileList function
 */
EOS_STRUCT(EOS_PlayerDataStorage_QueryFileListOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_QUERYFILELIST_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who requested file metadata */
	EOS_ProductUserId LocalUserId;
));

/**
 * Data containing information about a query file list request
 */
EOS_STRUCT(EOS_PlayerDataStorage_QueryFileListCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file query request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** A count of files that were found, if successful */
	uint32_t FileCount;
));
/**
 * Callback for when EOS_PlayerDataStorage_QueryFileList completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnQueryFileListCompleteCallback, const EOS_PlayerDataStorage_QueryFileListCallbackInfo* Data);

/** The most recent version of the EOS_PlayerDataStorage_GetFileMetadataCount API. */
#define EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNT_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNT_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNTOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNT_API_LATEST

/**
 * Input data for the EOS_PlayerDataStorage_GetFileMetadataCount function
 */
EOS_STRUCT(EOS_PlayerDataStorage_GetFileMetadataCountOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_GETFILEMETADATACOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is requesting file metadata */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_PlayerDataStorage_CopyFileMetadataAtIndex API. */
#define EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEX_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEX_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEX_API_LATEST

/**
 * Input data for the CopyFileMetadataAtIndex function
 */
EOS_STRUCT(EOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is requesting file metadata */
	EOS_ProductUserId LocalUserId;
	/** The index to get data for */
	uint32_t Index;
));

/** The most recent version of the EOS_PlayerDataStorage_CopyFileMetadataByFilename API. */
#define EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST

/**
 * Input data for the CopyFileMetadataByFilename function
 */
EOS_STRUCT(EOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is requesting file metadata */
	EOS_ProductUserId LocalUserId;
	/** The file's name to get data for */
	const char* Filename;
));

/** The most recent version of the EOS_PlayerDataStorage_DuplicateFile API. */
#define EOS_PLAYERDATASTORAGE_DUPLICATEFILE_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_DUPLICATEFILE_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_DUPLICATEFILEOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_DUPLICATEFILE_API_LATEST

/**
 * Input data for the EOS_PlayerDataStorage_DuplicateFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_DuplicateFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_DUPLICATEFILE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who authorized the duplication of the requested file; must be the original file's owner */
	EOS_ProductUserId LocalUserId;
	/** The name of the existing file to duplicate */
	const char* SourceFilename;
	/** The name of the new file */
	const char* DestinationFilename;
));

/**
 * Data containing the result information for a duplicate file request
 */
EOS_STRUCT(EOS_PlayerDataStorage_DuplicateFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file duplicate request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Callback for when EOS_PlayerDataStorage_DuplicateFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnDuplicateFileCompleteCallback, const EOS_PlayerDataStorage_DuplicateFileCallbackInfo* Data);

/** The most recent version of the EOS_PlayerDataStorage_DeleteFile API. */
#define EOS_PLAYERDATASTORAGE_DELETEFILE_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_DELETEFILE_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_DELETEFILEOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_DELETEFILE_API_LATEST

/**
 * Input data for the EOS_PlayerDataStorage_DeleteFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_DeleteFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_DELETEFILE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who authorizes deletion of the file; must be the file's owner */
	EOS_ProductUserId LocalUserId;
	/** The name of the file to delete */
	const char* Filename;
));

/**
 * Data containing the result information for a delete file request
 */
EOS_STRUCT(EOS_PlayerDataStorage_DeleteFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file deletion request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Callback for when EOS_PlayerDataStorage_DeleteFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnDeleteFileCompleteCallback, const EOS_PlayerDataStorage_DeleteFileCallbackInfo* Data);

/**
 * Handle type to a File Request
 */
EXTERN_C typedef struct EOS_PlayerDataStorageFileTransferRequestHandle* EOS_HPlayerDataStorageFileTransferRequest;

/**
 * Free the memory used by a cloud-storage file request handle. This will not cancel a request in progress.
 */
EOS_DECLARE_FUNC(void) EOS_PlayerDataStorageFileTransferRequest_Release(EOS_HPlayerDataStorageFileTransferRequest PlayerDataStorageFileTransferHandle);


/**
 * Data containing the information about a file transfer in progress (or one that has completed)
 */
EOS_STRUCT(EOS_PlayerDataStorage_FileTransferProgressCallbackInfo, (
	/** Client-specified data passed into the file request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The file name of the file being transferred */
	const char* Filename;
	/** Amount of bytes transferred so far in this request, out of TotalFileSizeBytes */
	uint32_t BytesTransferred;
	/** The total size of the file being transferred (Includes file header in addition to file contents, can be slightly more than expected) */
	uint32_t TotalFileSizeBytes;
));

/**
 * Callback for when there is a progress update for a file transfer in progress
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnFileTransferProgressCallback, const EOS_PlayerDataStorage_FileTransferProgressCallbackInfo* Data);


/**
 * Return results for EOS_PlayerDataStorage_OnReadFileDataCallback callbacks to return
 */
EOS_ENUM(EOS_PlayerDataStorage_EReadResult,
	/** Signifies the data was read successfully, and we should continue to the next chunk if possible */
	EOS_RR_ContinueReading = 1,
	/** Signifies there was a failure reading the data, and the request should end */
	EOS_RR_FailRequest = 2,
	/** Signifies the request should be canceled, but not due to an error */
	EOS_RR_CancelRequest = 3
);

/**
 * Data containing data for a chunk of a file being read
 */
EOS_STRUCT(EOS_PlayerDataStorage_ReadFileDataCallbackInfo, (
	/** Client-specified data passed into the file request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The file name being read */
	const char* Filename;
	/** The total file size of the file being read */
	uint32_t TotalFileSizeBytes;
	/** Is this chunk the last chunk of data? */
	EOS_Bool bIsLastChunk;
	/** The length of DataChunk in bytes that can be safely read */
	uint32_t DataChunkLengthBytes;
	/** Pointer to the start of data to be read */
	const void* DataChunk;
));

/**
 * Callback for when we have data ready to be read from the requested file. It is undefined how often this will be called during a single tick.
 *
 * @param Data Struct containing a chunk of data to read, as well as some metadata for the file being read
 * @return The result of the read operation. If this value is not EOS_RR_ContinueReading, this callback will not be called again for the same request
 */
EOS_DECLARE_CALLBACK_RETVALUE(EOS_PlayerDataStorage_EReadResult, EOS_PlayerDataStorage_OnReadFileDataCallback, const EOS_PlayerDataStorage_ReadFileDataCallbackInfo* Data);

/** The most recent version of the EOS_PlayerDataStorage_ReadFile API. */
#define EOS_PLAYERDATASTORAGE_READFILE_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_READFILE_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_READFILEOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_READFILE_API_LATEST

/**
 * Input data for the EOS_PlayerDataStorage_ReadFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_ReadFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_READFILE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is reading the requested file */
	EOS_ProductUserId LocalUserId;
	/** The file name to read; this file must already exist */
	const char* Filename;
	/** The maximum amount of data in bytes should be available to read in a single EOS_PlayerDataStorage_OnReadFileDataCallback call */
	uint32_t ReadChunkLengthBytes;
	/** Callback function that handles data as it comes in, and can stop the transfer early */
	EOS_PlayerDataStorage_OnReadFileDataCallback ReadFileDataCallback;
	/** Optional callback function to be informed of download progress, if the file is not already locally cached; if provided, this will be called at least once before completion if the request is successfully started */
	EOS_PlayerDataStorage_OnFileTransferProgressCallback FileTransferProgressCallback;
));


/**
 * Data containing the result of a read file request
 */
EOS_STRUCT(EOS_PlayerDataStorage_ReadFileCallbackInfo, (
	/** The result code for the operation.
	 * EOS_Success: The request was successful.
	 * EOS_Canceled: The request was canceled.
	 * EOS_TooManyRequests: There are too many requests in progress for the local user at this time.
	 * EOS_AlreadyPending: There is another requests in progress for the specified file by this user.
	 * EOS_CacheDirectoryMissing: The cache directory was not set when calling EOS_Platform_Create.
	 * EOS_CacheDirectoryInvalid: The cache directory provided when calling EOS_Platform_Create was invalid.
	 * EOS_PlayerDataStorage_UserThrottled: There were too many requests to the Data Storage service recently by the local user. The application must wait some time before trying again.
	 * EOS_PlayerDataStorage_EncryptionKeyNotSet: The encryption key value was not set when calling EOS_Platform_Create.
	 * EOS_PlayerDataStorage_FileCorrupted: The downloaded or cached file was corrupted or invalid in some way. What exactly is wrong with the file is returned in the logs (potentially retryable).
	 * EOS_InvalidState: The read operation is not allowed (e.g. when application is suspended).
	 * EOS_UnexpectedError: An unexpected error occurred either downloading, or reading the downloaded file. This most commonly means there were file IO issues such as: permission issues, disk is full, etc. (potentially retryable)
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file read request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The filename of the file that has been finished reading */
	const char* Filename;
));

/**
 * Callback for when EOS_PlayerDataStorage_ReadFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnReadFileCompleteCallback, const EOS_PlayerDataStorage_ReadFileCallbackInfo* Data);


/**
 * Return results for EOS_PlayerDataStorage_OnWriteFileDataCallback callbacks to return
 */
EOS_ENUM(EOS_PlayerDataStorage_EWriteResult,
	/** Signifies the data was written successfully, and we should write the data the file */
	EOS_WR_ContinueWriting = 1,
	/** Signifies all data has now been written successfully, and we should upload the data to the cloud */
	EOS_WR_CompleteRequest = 2,
	/** Signifies there was a failure writing the data, and the request should end */
	EOS_WR_FailRequest = 3,
	/** Signifies the request should be canceled, but not due to an error */
	EOS_WR_CancelRequest = 4
);

/**
 * Data containing data for a chunk of a file being written
 */
EOS_STRUCT(EOS_PlayerDataStorage_WriteFileDataCallbackInfo, (
	/** Client-specified data passed into the file write request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The file name that is being written to */
	const char* Filename;
	/** The maximum amount of data in bytes that can be written safely to DataBuffer */
	uint32_t DataBufferLengthBytes;
));

/**
 * Callback for when we are ready to get more data to be written into the requested file. It is undefined how often this will be called during a single tick.
 *
 * @param Data Struct containing metadata for the file being written to, as well as the max length in bytes that can be safely written to DataBuffer
 * @param OutDataBuffer A buffer to write data into, to be appended to the end of the file that is being written to. The maximum length of this value is provided in the Info parameter. The number of bytes written to this buffer should be set in OutDataWritten.
 * @param OutDataWritten The length of the data written to OutDataBuffer. This must be less than or equal than the DataBufferLengthBytes provided in the Info parameter
 * @return The result of the write operation. If this value is not EOS_WR_ContinueWriting, this callback will not be called again for the same request. If this is set to EOS_WR_FailRequest or EOS_WR_CancelRequest, all data written during the request will not be saved
 */
EOS_DECLARE_CALLBACK_RETVALUE(EOS_PlayerDataStorage_EWriteResult, EOS_PlayerDataStorage_OnWriteFileDataCallback, const EOS_PlayerDataStorage_WriteFileDataCallbackInfo* Data, void* OutDataBuffer, uint32_t* OutDataWritten);

/** The most recent version of the EOS_PlayerDataStorage_WriteFile API. */
#define EOS_PLAYERDATASTORAGE_WRITEFILE_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_WRITEFILE_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_WRITEFILEOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_WRITEFILE_API_LATEST

/**
 * Input data for the EOS_PlayerDataStorage_WriteFile function
 */
EOS_STRUCT(EOS_PlayerDataStorage_WriteFileOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_WRITEFILE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is writing the requested file to the cloud */
	EOS_ProductUserId LocalUserId;
	/** The name of the file to write; if this file already exists, the contents will be replaced if the write request completes successfully */
	const char* Filename;
	/** Requested maximum amount of data (in bytes) that can be written to the file per tick */
	uint32_t ChunkLengthBytes;
	/** Callback function that provides chunks of data to be written into the requested file */
	EOS_PlayerDataStorage_OnWriteFileDataCallback WriteFileDataCallback;
	/** Optional callback function to inform the application of upload progress; will be called at least once if set */
	EOS_PlayerDataStorage_OnFileTransferProgressCallback FileTransferProgressCallback;
));

/**
 * The result information for a request to write data to a file
 */
EOS_STRUCT(EOS_PlayerDataStorage_WriteFileCallbackInfo, (
	/** The result code for the operation.
	 * EOS_Success: The request was successful.
	 * EOS_Canceled: The request was canceled.
	 * EOS_TooManyRequests: There are too many requests in progress for the local user at this time.
	 * EOS_AlreadyPending: There is another requests in progress for the specified file by this user.
	 * EOS_CacheDirectoryMissing: The cache directory was not set when calling EOS_Platform_Create.
	 * EOS_CacheDirectoryInvalid: The cache directory provided when calling EOS_Platform_Create was invalid.
	 * EOS_PlayerDataStorage_UserThrottled: There were too many requests to the Data Storage service recently by the local user. The application must wait some time before trying again.
	 * EOS_PlayerDataStorage_EncryptionKeyNotSet: The encryption key value was not set when calling EOS_Platform_Create.
	 * EOS_InvalidState: The read operation is not allowed (e.g. when application is suspended).
	 * EOS_UnexpectedError: An unexpected error occurred either downloading, or reading the downloaded file. This most commonly means there were file IO issues such as: permission issues, disk is full, etc. (potentially retryable)
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file write request */
	void* ClientData;
	/** The Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The file name that is being written to */
	const char* Filename;
));

/**
 * Callback for when EOS_PlayerDataStorage_WriteFile completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnWriteFileCompleteCallback, const EOS_PlayerDataStorage_WriteFileCallbackInfo* Data);

/** The most recent version of the EOS_PlayerDataStorage_DeleteCache API. */
#define EOS_PLAYERDATASTORAGE_DELETECACHE_API_LATEST 1
/** DEPRECATED! Use EOS_PLAYERDATASTORAGE_DELETECACHE_API_LATEST instead. */
#define EOS_PLAYERDATASTORAGE_DELETECACHEOPTIONS_API_LATEST EOS_PLAYERDATASTORAGE_DELETECACHE_API_LATEST

/**
 * Input data for the EOS_TitleStorage_DeleteCache function
 */
EOS_STRUCT(EOS_PlayerDataStorage_DeleteCacheOptions, (
	/** API Version: Set this to EOS_PLAYERDATASTORAGE_DELETECACHE_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is deleting his cache */
	EOS_ProductUserId LocalUserId;
));

/**
 * Structure containing the result of a delete cache operation
 */
EOS_STRUCT(EOS_PlayerDataStorage_DeleteCacheCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the delete cache request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Callback for when EOS_PlayerDataStorage_DeleteCache completes
 */
EOS_DECLARE_CALLBACK(EOS_PlayerDataStorage_OnDeleteCacheCompleteCallback, const EOS_PlayerDataStorage_DeleteCacheCallbackInfo* Data);


#pragma pack(pop)
```

`EAC_SDK/SDK/include/eos_presence.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_presence_types.h"

/**
 * The Presence methods enable you to query and read other player's presence information, or modify your own.
 *
 * QueryPresence must be called once per login, per remote user, before data will be available. It is currently only possible to query presence for
 * users that are on your friends list, all other queries will return no results.
 *
 * @see EOS_Platform_GetPresenceInterface
 */

/**
 * Query a user's presence. This must complete successfully before CopyPresence will have valid results. If HasPresence returns true for a remote
 * user, this does not need to be called.
 *
 * @param Options Object containing properties related to who is querying presence and for what user
 * @param ClientData Optional pointer to help track this request, that is returned in the completion callback
 * @param CompletionDelegate Pointer to a function that handles receiving the completion information
 */
EOS_DECLARE_FUNC(void) EOS_Presence_QueryPresence(EOS_HPresence Handle, const EOS_Presence_QueryPresenceOptions* Options, void* ClientData, const EOS_Presence_OnQueryPresenceCompleteCallback CompletionDelegate);

/**
 * Check if we already have presence for a user
 *
 * @param Options Object containing properties related to who is requesting presence and for what user
 * @return EOS_TRUE if we have presence for the requested user, or EOS_FALSE if the request was invalid or we do not have cached data
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_Presence_HasPresence(EOS_HPresence Handle, const EOS_Presence_HasPresenceOptions* Options);

/**
 * Get a user's cached presence object. If successful, this data must be released by calling EOS_Presence_Info_Release
 *
 * @param Options Object containing properties related to who is requesting presence and for what user
 * @param OutPresence A pointer to a pointer of Presence Info. If the returned result is success, this will be set to data that must be later released, otherwise this will be set to NULL
 * @return Success if we have cached data, or an error result if the request was invalid or we do not have cached data.
 *
 * @see EOS_Presence_Info_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Presence_CopyPresence(EOS_HPresence Handle, const EOS_Presence_CopyPresenceOptions* Options, EOS_Presence_Info ** OutPresence);

/**
 * Creates a presence modification handle. This handle can used to add multiple changes to your presence that can be applied with EOS_Presence_SetPresence.
 * The resulting handle must be released by calling EOS_PresenceModification_Release once it has been passed to EOS_Presence_SetPresence.
 *
 * @param Options Object containing properties related to the user modifying their presence
 * @param OutPresenceModificationHandle Pointer to a Presence Modification Handle to be set if successful
 * @return Success if we successfully created the Presence Modification Handle pointed at in OutPresenceModificationHandle, or an error result if the input data was invalid
 *
 * @see EOS_PresenceModification_Release
 * @see EOS_Presence_SetPresence
 * @see EOS_PresenceModification_SetStatus
 * @see EOS_PresenceModification_SetRawRichText
 * @see EOS_PresenceModification_SetData
 * @see EOS_PresenceModification_DeleteData
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Presence_CreatePresenceModification(EOS_HPresence Handle, const EOS_Presence_CreatePresenceModificationOptions* Options, EOS_HPresenceModification* OutPresenceModificationHandle);

/**
 * Sets your new presence with the data applied to a PresenceModificationHandle. The PresenceModificationHandle can be released safely after calling this function.
 *
 * @param Options Object containing a PresenceModificationHandle and associated user data
 * @param ClientData Optional pointer to help track this request, that is returned in the completion callback
 * @param CompletionDelegate Pointer to a function that handles receiving the completion information
 *
 * @see EOS_Presence_CreatePresenceModification
 * @see EOS_PresenceModification_Release
 */
EOS_DECLARE_FUNC(void) EOS_Presence_SetPresence(EOS_HPresence Handle, const EOS_Presence_SetPresenceOptions* Options, void* ClientData, const EOS_Presence_SetPresenceCompleteCallback CompletionDelegate);

/**
 * Register to receive notifications when presence changes.
 * @note If the returned NotificationId is valid, you must call EOS_Presence_RemoveNotifyOnPresenceChanged when you no longer wish to have your NotificationHandler called.
 *
 *
 * @param ClientData Data the is returned to when NotificationHandler is invoked
 * @param NotificationHandler The callback to be fired when a presence change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_Presence_RemoveNotifyOnPresenceChanged
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Presence_AddNotifyOnPresenceChanged(EOS_HPresence Handle, const EOS_Presence_AddNotifyOnPresenceChangedOptions* Options, void* ClientData, const EOS_Presence_OnPresenceChangedCallback NotificationHandler);

/**
 * Unregister a previously bound notification handler from receiving presence update notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Presence_RemoveNotifyOnPresenceChanged(EOS_HPresence Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when a user accepts a join game option via the social overlay.
 * @note If the returned NotificationId is valid, you must call EOS_Presence_RemoveNotifyJoinGameAccepted when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Presence_AddNotifyJoinGameAccepted(EOS_HPresence Handle, const EOS_Presence_AddNotifyJoinGameAcceptedOptions* Options, void* ClientData, const EOS_Presence_OnJoinGameAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a join game option via the social overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Presence_RemoveNotifyJoinGameAccepted(EOS_HPresence Handle, EOS_NotificationId InId);

/**
 * Gets a join info custom game-data string for a specific user. This is a helper function for reading the presence data related to how a user can be joined.
 * Its meaning is entirely application dependent.
 *
 * This value will be valid only after a QueryPresence call has successfully completed.
 *
 * @param Options Object containing an associated user
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH.
 * @param InOutBufferLength Used as an input to define the OutBuffer length.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the location string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if there is user or the location string was not found.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the location string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Presence_GetJoinInfo(EOS_HPresence Handle, const EOS_Presence_GetJoinInfoOptions* Options, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * To modify your own presence, you must call EOS_Presence_CreatePresenceModification to create a Presence Modification handle. To modify that handle, call
 * EOS_PresenceModification_* methods. Once you are finished, call EOS_Presence_SetPresence with your handle. You must then release your Presence Modification
 * handle by calling EOS_PresenceModification_Release.
 */

/**
 * Modifies a user's online status to be the new state.
 *
 * @param Options Object containing properties related to setting a user's Status
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_SetStatus(EOS_HPresenceModification Handle, const EOS_PresenceModification_SetStatusOptions* Options);

/**
 * Modifies a user's Rich Presence string to a new state. This is the exact value other users will see
 * when they query the local user's presence.
 *
 * @param Options Object containing properties related to setting a user's RichText string
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 *
 * @see EOS_PRESENCE_RICH_TEXT_MAX_VALUE_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_SetRawRichText(EOS_HPresenceModification Handle, const EOS_PresenceModification_SetRawRichTextOptions* Options);

/**
 * Modifies one or more rows of user-defined presence data for a local user. At least one InfoData object
 * must be specified.
 *
 * @param Options Object containing an array of new presence data.
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 *
 * @see EOS_PRESENCE_DATA_MAX_KEYS
 * @see EOS_PRESENCE_DATA_MAX_KEY_LENGTH
 * @see EOS_PRESENCE_DATA_MAX_VALUE_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_SetData(EOS_HPresenceModification Handle, const EOS_PresenceModification_SetDataOptions* Options);

/**
 * Removes one or more rows of user-defined presence data for a local user. At least one DeleteDataInfo object
 * must be specified.
 *
 * @param Options Object containing an array of new presence data.
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 *
 * @see EOS_PRESENCE_DATA_MAX_KEYS
 * @see EOS_PRESENCE_DATA_MAX_KEY_LENGTH
 * @see EOS_PRESENCE_DATA_MAX_VALUE_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_DeleteData(EOS_HPresenceModification Handle, const EOS_PresenceModification_DeleteDataOptions* Options);

/**
 * Sets your new join info custom game-data string. This is a helper function for reading the presence data related to how a user can be joined.
 * Its meaning is entirely application dependent.
 *
 * @param Options Object containing a join info string and associated user data
 * @return Success if modification was added successfully, otherwise an error code related to the problem
 *
 * @see EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_PresenceModification_SetJoinInfo(EOS_HPresenceModification Handle, const EOS_PresenceModification_SetJoinInfoOptions* Options);

```

`EAC_SDK/SDK/include/eos_presence_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"
#include "eos_ui_types.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_PresenceHandle* EOS_HPresence;
EXTERN_C typedef struct EOS_PresenceModificationHandle* EOS_HPresenceModification;

/**
 * Presence Status states of a user
 *
 * @see EOS_Presence_CopyPresence
 * @see EOS_PresenceModification_SetStatus
 */
EOS_ENUM(EOS_Presence_EStatus,
	/** The status of the account is offline or not known */
	EOS_PS_Offline = 0,
	/** The status of the account is online */
	EOS_PS_Online = 1,
	/** The status of the account is away */
	EOS_PS_Away = 2,
	/** The status of the account is away, and has been away for a while */
	EOS_PS_ExtendedAway = 3,
	/** The status of the account is do-not-disturb */
	EOS_PS_DoNotDisturb = 4
);


#define EOS_PRESENCE_DATARECORD_API_LATEST 1

/**
 * An individual presence data record that belongs to a EOS_Presence_Info object. This object is released when its parent EOS_Presence_Info object is released.
 *
 * @see EOS_Presence_Info
 */
EOS_STRUCT(EOS_Presence_DataRecord, (
	/** API Version: Set this to EOS_PRESENCE_DATARECORD_API_LATEST. */
	int32_t ApiVersion;
	/** The name of this data */
	const char* Key;
	/** The value of this data */
	const char* Value;
));


#define EOS_PRESENCE_INFO_API_LATEST 3

/**
 * All the known presence information for a specific user. This object must be released by calling EOS_Presence_Info_Release.
 *
 * @see EOS_Presence_CopyPresence
 * @see EOS_Presence_Info_Release
 */
EOS_STRUCT(EOS_Presence_Info, (
	/** API Version: Set this to EOS_PRESENCE_INFO_API_LATEST. */
	int32_t ApiVersion;
	/** The status of the user */
	EOS_Presence_EStatus Status;
	/** The Epic Account ID of the user */
	EOS_EpicAccountId UserId;
	/** The product ID that the user is logged in from */
	const char* ProductId;
	/** The version of the product the user is logged in from */
	const char* ProductVersion;
	/** The platform of that the user is logged in from */
	const char* Platform;
	/** The rich-text of the user */
	const char* RichText;
	/** The count of records available */
	int32_t RecordsCount;
	/** The first data record, or NULL if RecordsCount is not at least 1 */
	const EOS_Presence_DataRecord* Records;
	/** The user-facing name for the product the user is logged in from */
	const char* ProductName;
	/** The integrated platform that the user is logged in with */
	const char* IntegratedPlatform;
));


#define EOS_PRESENCE_QUERYPRESENCE_API_LATEST 1

/**
 * Data for the EOS_Presence_QueryPresence function
 */
EOS_STRUCT(EOS_Presence_QueryPresenceOptions, (
	/** API Version: Set this to EOS_PRESENCE_QUERYPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose presence data you want to retrieve; this value must be either the user making the request, or a friend of that user */
	EOS_EpicAccountId TargetUserId;
));

/**
 * The result meta-data for a presence query.
 */
EOS_STRUCT(EOS_Presence_QueryPresenceCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful query, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_Presence_QueryPresence */
	void* ClientData;
	/** The Epic Account ID of the local user who made this request */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose presence was potentially queried */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Callback for information related to EOS_Presence_QueryPresence finishing.
 */
EOS_DECLARE_CALLBACK(EOS_Presence_OnQueryPresenceCompleteCallback, const EOS_Presence_QueryPresenceCallbackInfo* Data);


#define EOS_PRESENCE_HASPRESENCE_API_LATEST 1

/**
 * Data for the EOS_Presence_HasPresence function.
 */
EOS_STRUCT(EOS_Presence_HasPresenceOptions, (
	/** API Version: Set this to EOS_PRESENCE_HASPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose cached presence data you want to locate */
	EOS_EpicAccountId TargetUserId;
));


#define EOS_PRESENCE_COPYPRESENCE_API_LATEST 3
/**
 * Data for the EOS_Presence_CopyPresence function.
 */
EOS_STRUCT(EOS_Presence_CopyPresenceOptions, (
	/** API Version: Set this to EOS_PRESENCE_COPYPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user whose cached presence data you want to copy from the cache */
	EOS_EpicAccountId TargetUserId;
));


/**
 * Release the memory associated with an EOS_Presence_Info structure and its sub-objects. This must be called on data retrieved from EOS_Presence_CopyPresence.
 * This can be safely called on a NULL presence info object.
 *
 * @param PresenceInfo The presence info structure to be release
 */
EOS_DECLARE_FUNC(void) EOS_Presence_Info_Release(EOS_Presence_Info* PresenceInfo);


#define EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST 1
/**
 * Data for the EOS_Presence_CreatePresenceModification function.
 */
EOS_STRUCT(EOS_Presence_CreatePresenceModificationOptions, (
	/** API Version: Set this to EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
));


/**
 * Release the memory associated with an EOS_HPresenceModification handle. This must be called on Handles retrieved from EOS_Presence_CreatePresenceModification.
 * This can be safely called on a NULL presence modification handle. This also may be safely called while a call to SetPresence is still pending.
 *
 * @param PresenceModificationHandle The presence modification handle to release
 *
 * @see EOS_Presence_CreatePresenceModification
 */
EOS_DECLARE_FUNC(void) EOS_PresenceModification_Release(EOS_HPresenceModification PresenceModificationHandle);


#define EOS_PRESENCE_SETPRESENCE_API_LATEST 1
/**
 * Data for the EOS_Presence_SetPresence function.
 */
EOS_STRUCT(EOS_Presence_SetPresenceOptions, (
	/** API Version: Set this to EOS_PRESENCE_SETPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local, logged-in user making the request */
	EOS_EpicAccountId LocalUserId;
	/** The handle to the presence update */
	EOS_HPresenceModification PresenceModificationHandle;
));

/**
 * The result meta-data from setting a user's presence.
 */
EOS_STRUCT(EOS_Presence_SetPresenceCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned if presence was successfully set, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_Presence_SetPresence */
	void* ClientData;
	/** The Epic Account ID of the local user that had their presence set */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Callback for information related to EOS_Presence_SetPresence finishing.
 */
EOS_DECLARE_CALLBACK(EOS_Presence_SetPresenceCompleteCallback, const EOS_Presence_SetPresenceCallbackInfo* Data);


#define EOS_PRESENCE_ADDNOTIFYONPRESENCECHANGED_API_LATEST 1
/**
 * Data for the EOS_Presence_AddNotifyOnPresenceChanged function.
 */
EOS_STRUCT(EOS_Presence_AddNotifyOnPresenceChangedOptions, (
	/** API Version: Set this to EOS_PRESENCE_ADDNOTIFYONPRESENCECHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Data containing which users presence has changed
 */
EOS_STRUCT(EOS_Presence_PresenceChangedCallbackInfo, (
	/** Client-specified data passed into EOS_Presence_AddNotifyOnPresenceChanged */
	void* ClientData;
	/** The Epic Account ID of the local user who is being informed for PresenceUserId's presence change */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who had their presence changed */
	EOS_EpicAccountId PresenceUserId;
));

/** The most recent version of the EOS_Presence_AddNotifyJoinGameAccepted API. */
#define EOS_PRESENCE_ADDNOTIFYJOINGAMEACCEPTED_API_LATEST 2

EOS_STRUCT(EOS_Presence_AddNotifyJoinGameAcceptedOptions, (
	/** API Version: Set this to EOS_PRESENCE_ADDNOTIFYJOINGAMEACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Presence_OnJoinGameAcceptedCallback Function.
 */
EOS_STRUCT(EOS_Presence_JoinGameAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Presence_AddNotifyJoinGameAccepted */
	void* ClientData;
	/**
	 * The Join Info custom game-data string to use to join the target user.
	 * Set to a null pointer to delete the value.
	 */
	const char* JoinInfo;
	/** The Epic Account ID of the user who accepted the invitation */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the user who sent the invitation */
	EOS_EpicAccountId TargetUserId;
	/**
	 * If the value is not EOS_UI_EVENTID_INVALID then it must be passed back to the SDK using EOS_UI_AcknowledgeEventId.
	 * This should be done after attempting to join the game and either succeeding or failing to connect.
	 * This is necessary to allow the Social Overlay UI to manage the `Join` button.
	 */
	EOS_UI_EventId UiEventId;
));

/**
 * Function prototype definition for notifications that come from EOS_Presence_AddNotifyJoinGameAccepted
 *
 * @param Data A EOS_Presence_JoinGameAcceptedCallbackInfo containing the output information and result
 *
 * @note EOS_UI_AcknowledgeEventId must be called with any valid UiEventId passed via the data.
 */
EOS_DECLARE_CALLBACK(EOS_Presence_OnJoinGameAcceptedCallback, const EOS_Presence_JoinGameAcceptedCallbackInfo* Data);

/**
 * Callback for information related to notifications from EOS_Presence_AddNotifyOnPresenceChanged triggering.
 */
EOS_DECLARE_CALLBACK(EOS_Presence_OnPresenceChangedCallback, const EOS_Presence_PresenceChangedCallbackInfo* Data);

#define EOS_PRESENCE_GETJOININFO_API_LATEST 1
/**
 * Data for the EOS_Presence_GetJoinInfo function.
 */
EOS_STRUCT(EOS_Presence_GetJoinInfoOptions, (
	/** API Version: Set this to EOS_PRESENCE_GETJOININFO_API_LATEST. */
	int32_t ApiVersion;
	/** The local user's Epic Account ID */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID to query for join info; this value must either be a logged-in local user, or a friend of that user */
	EOS_EpicAccountId TargetUserId;
));

#define EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH EOS_PRESENCE_DATA_MAX_VALUE_LENGTH

#define EOS_PRESENCEMODIFICATION_SETJOININFO_API_LATEST 1
/**
 * Data for the EOS_PresenceModification_SetJoinInfo function.
 */
EOS_STRUCT(EOS_PresenceModification_SetJoinInfoOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_SETJOININFO_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The string which will be advertised as this player's join info.
	 * An application is expected to freely define the meaning of this string to use for connecting to an active game session.
	 * The string should not exceed EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH in length.
	 * This affects the ability of the Social Overlay to show game related actions to take in the player's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	const char* JoinInfo;
));


/**
 * The maximum of allowed individual pieces of data a user may have. This value is subject to change and data structures should be designed to allow for greater
 * numbers than this.
 */
#define EOS_PRESENCE_DATA_MAX_KEYS 32

/**
 * The maximum allowed length a data's key may be. This value is subject to change and data structures should be designed to allow for greater numbers than this.
 */
#define EOS_PRESENCE_DATA_MAX_KEY_LENGTH 64

/**
 * The maximum allowed length a data's value may be. This value is subject to change and data structures should be designed to allow for greater numbers than this.
 */
#define EOS_PRESENCE_DATA_MAX_VALUE_LENGTH 255

/**
 * The maximum allowed length a user's rich text string may be. This value is subject to change and data structures should be designed to allow for greater numbers
 * than this.
 */
#define EOS_PRESENCE_RICH_TEXT_MAX_VALUE_LENGTH 255

/**
 * The presence key used to specify the local platform's presence string on platforms that use tokenized presence.
 * For use with EOS_PresenceModification_SetData.
 *
 * @see EOS_PresenceModification_SetData
 * @see EOS_Presence_DataRecord
 */
#define EOS_PRESENCE_KEY_PLATFORM_PRESENCE "EOS_PlatformPresence"

/** The most recent version of the EOS_PresenceModification_SetStatus API. */
#define EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST 1

/** DEPRECATED! Use EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST instead. */
#define EOS_PRESENCE_SETSTATUS_API_LATEST EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST

/**
 * Data for the EOS_PresenceModification_SetStatus function.
 */
EOS_STRUCT(EOS_PresenceModification_SetStatusOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_SETSTATUS_API_LATEST. */
	int32_t ApiVersion;
	/** The status of the user */
	EOS_Presence_EStatus Status;
));

/** The most recent version of the EOS_PresenceModification_SetRawRichText function. */
#define EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST 1

/** DEPRECATED! Use EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST instead. */
#define EOS_PRESENCE_SETRAWRICHTEXT_API_LATEST EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST

/**
 * Data for the EOS_PresenceModification_SetRawRichText API.
 */
EOS_STRUCT(EOS_PresenceModification_SetRawRichTextOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_SETRAWRICHTEXT_API_LATEST. */
	int32_t ApiVersion;
	/** The status of the user */
	const char* RichText;
));

/** The most recent version of the EOS_PresenceModification_SetData API. */
#define EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST 1

/** DEPRECATED! Use EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST instead. */
#define EOS_PRESENCE_SETDATA_API_LATEST EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST

/**
 * Data for the EOS_PresenceModification_SetData function.
 */
EOS_STRUCT(EOS_PresenceModification_SetDataOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_SETDATA_API_LATEST. */
	int32_t ApiVersion;
	/** The count of records to set */
	int32_t RecordsCount;
	/** The pointer to start of a sequential array of Presence DataRecords */
	const EOS_Presence_DataRecord* Records;
));

#define EOS_PRESENCEMODIFICATION_DATARECORDID_API_LATEST 1

/**
 * Data for identifying which data records should be deleted.
 */
EOS_STRUCT(EOS_PresenceModification_DataRecordId, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_DATARECORDID_API_LATEST. */
	int32_t ApiVersion;
	/** The key to be deleted from the data record */
	const char* Key;
));

/** Most recent version of the EOS_PresenceModification_DeleteData API. */
#define EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST 1

/** DEPRECATED! Use EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST instead. */
#define EOS_PRESENCE_DELETEDATA_API_LATEST EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST

/**
 * Data for the EOS_PresenceModification_DeleteData function.
 */
EOS_STRUCT(EOS_PresenceModification_DeleteDataOptions, (
	/** API Version: Set this to EOS_PRESENCEMODIFICATION_DELETEDATA_API_LATEST. */
	int32_t ApiVersion;
	/** The count of data keys to delete */
	int32_t RecordsCount;
	/** The pointer to start of a sequential array */
	const EOS_PresenceModification_DataRecordId* Records;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_progressionsnapshot.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_progressionsnapshot_types.h"

/**
 * Progression Snapshots allow you to store player specific game state.
 *
 * BeginSnapshot must be called to obtain a handle for a given player.
 * AddProgression allows you to add Key/Value pairs that represent some state for that player in the game.
 * SubmitSnapshot sends all the progression data you have added (via AddProgression) to the service.
 * EndSnapshot cleans up internal resources allocated for that snapshot.
 * DeleteSnapshot wipes out all data associated with a particular player.
 *
 * @see EOS_Platform_GetProgressionSnapshotInterface
 */

/**
 * Creates a new progression-snapshot resource for a given user.
 *
 * @param Options Object containing properties that identifies the PUID this Snapshot will belong to.
 * @param OutSnapshotId A progression-snapshot identifier output parameter. Use that identifier to reference the snapshot in the other APIs.
 *
 * @return EOS_Success when successful.
 *          EOS_ProgressionSnapshot_SnapshotIdUnavailable when no IDs are available. This is irrecoverable state.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ProgressionSnapshot_BeginSnapshot(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_BeginSnapshotOptions* Options, uint32_t* OutSnapshotId);

/**
 * Stores a Key/Value pair in memory for a given snapshot.
 * If multiple calls happen with the same key, the last invocation wins, overwriting the previous value for that
 * given key.
 *
 * The order in which the Key/Value pairs are added is stored as is for later retrieval/display.
 * Ideally, you would make multiple calls to AddProgression() followed by a single call to SubmitSnapshot().
 *
 * @return EOS_Success when successful; otherwise, EOS_NotFound
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ProgressionSnapshot_AddProgression(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_AddProgressionOptions* Options);

/**
 * Saves the previously added Key/Value pairs of a given Snapshot to the service.
 *
 * Note: This will overwrite any prior progression data stored with the service that's associated with the user.
 */
EOS_DECLARE_FUNC(void) EOS_ProgressionSnapshot_SubmitSnapshot(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_SubmitSnapshotOptions* Options, void* ClientData, const EOS_ProgressionSnapshot_OnSubmitSnapshotCallback CompletionDelegate);

/**
 * Cleans up and releases resources associated with the given progression snapshot identifier.
 *
 * @return EOS_Success when successful; otherwise, EOS_NotFound
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ProgressionSnapshot_EndSnapshot(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_EndSnapshotOptions* Options);

/**
 * Wipes out all progression data for the given user from the service. However, any previous progression data that haven't
 * been submitted yet are retained.
 */
EOS_DECLARE_FUNC(void) EOS_ProgressionSnapshot_DeleteSnapshot(EOS_HProgressionSnapshot Handle, const EOS_ProgressionSnapshot_DeleteSnapshotOptions* Options, void* ClientData, const EOS_ProgressionSnapshot_OnDeleteSnapshotCallback CompletionDelegate);

```

`EAC_SDK/SDK/include/eos_progressionsnapshot_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** Handle to the ProgressionSnapshot interface */
EXTERN_C typedef struct EOS_ProgressionSnapshotHandle* EOS_HProgressionSnapshot;

#define EOS_INVALID_PROGRESSIONSNAPSHOTID  0

#define EOS_PROGRESSIONSNAPSHOT_BEGINSNAPSHOT_API_LATEST 1
EOS_STRUCT(EOS_ProgressionSnapshot_BeginSnapshotOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_BEGINSNAPSHOT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user to whom the key/value pair belong */
	EOS_ProductUserId LocalUserId;
));

#define EOS_PROGRESSIONSNAPSHOT_ADDPROGRESSION_API_LATEST  1
EOS_STRUCT(EOS_ProgressionSnapshot_AddProgressionOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_ADDPROGRESSION_API_LATEST. */
	int32_t ApiVersion;
	/** The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function. */
	uint32_t SnapshotId;
	/** The key in a key/value pair of progression entry */
	const char* Key;
	/** The value in a key/value pair of progression entry */
	const char* Value;
));

#define EOS_PROGRESSIONSNAPSHOT_SUBMITSNAPSHOT_API_LATEST   1
EOS_STRUCT(EOS_ProgressionSnapshot_SubmitSnapshotOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_SUBMITSNAPSHOT_API_LATEST. */
	int32_t ApiVersion;
	/** The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function. */
	uint32_t SnapshotId;
));

#define EOS_PROGRESSIONSNAPSHOT_ENDSNAPSHOT_API_LATEST    1
EOS_STRUCT(EOS_ProgressionSnapshot_EndSnapshotOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_ENDSNAPSHOT_API_LATEST. */
	int32_t ApiVersion;
	/** The Snapshot Id received via a EOS_ProgressionSnapshot_BeginSnapshot function. */
	uint32_t SnapshotId;
));

EOS_STRUCT(EOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** The Snapshot Id used in the Submit function. */
	uint32_t SnapshotId;
	/** Context that was passed into EOS_ProgressionSnapshot_SubmitSnapshot. */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_ProgressionSnapshot_OnSubmitSnapshotCallback, const EOS_ProgressionSnapshot_SubmitSnapshotCallbackInfo* Data);

#define EOS_PROGRESSIONSNAPSHOT_DELETESNAPSHOT_API_LATEST   1
EOS_STRUCT(EOS_ProgressionSnapshot_DeleteSnapshotOptions, (
	/** API Version: Set this to EOS_PROGRESSIONSNAPSHOT_DELETESNAPSHOT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user to whom the key/value pair belong */
	EOS_ProductUserId LocalUserId;
));

EOS_STRUCT(EOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** The Product User ID of the local user to whom the key/value pair belong */
	EOS_ProductUserId LocalUserId;
	/** Context that was passed into EOS_ProgressionSnapshot_SubmitSnapshot. */
	void* ClientData;
));
EOS_DECLARE_CALLBACK(EOS_ProgressionSnapshot_OnDeleteSnapshotCallback, const EOS_ProgressionSnapshot_DeleteSnapshotCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_reports.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_reports_types.h"

/**
 * The following EOS_Reports_* functions allow you to send reports directly from the players
 * to the back-end services without having to route these through a game server.
 */

/**
 * Sends the provided report directly to the Epic Online Services back-end.
 *
 * @param Options Structure containing the player report information.
 * @param ClientData Optional client data provided by the user of the SDK.
 * @param CompletionDelegate This function is called when the send operation completes.
 */
EOS_DECLARE_FUNC(void) EOS_Reports_SendPlayerBehaviorReport(EOS_HReports Handle, const EOS_Reports_SendPlayerBehaviorReportOptions* Options, void* ClientData, const EOS_Reports_OnSendPlayerBehaviorReportCompleteCallback CompletionDelegate);

```

`EAC_SDK/SDK/include/eos_reports_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_ReportsHandle* EOS_HReports;

/**
 * An enumeration of the different player behavior categories that can be reported.
 */
EOS_ENUM(EOS_EPlayerReportsCategory,
	/** Not used */
	EOS_PRC_Invalid = 0,
	/** The reported player is cheating */
	EOS_PRC_Cheating = 1,
	/** The reported player is exploiting the game */
	EOS_PRC_Exploiting = 2,
	/** The reported player has an offensive profile, name, etc */
	EOS_PRC_OffensiveProfile = 3,
	/** The reported player is being abusive in chat */
	EOS_PRC_VerbalAbuse = 4,
	/** The reported player is scamming other players */
	EOS_PRC_Scamming = 5,
	/** The reported player is spamming chat */
	EOS_PRC_Spamming = 6,
	/** The player is being reported for something else */
	EOS_PRC_Other = 7
);

/** Max length of a report message text, not including the null terminator. */
#define EOS_REPORTS_REPORTMESSAGE_MAX_LENGTH 512

/** Max length of a report context JSON payload, not including the null terminator. */
#define EOS_REPORTS_REPORTCONTEXT_MAX_LENGTH 4096

/** The most recent version of the EOS_Reports_SendPlayerBehaviorReport API. */
#define EOS_REPORTS_SENDPLAYERBEHAVIORREPORT_API_LATEST 2

/**
 * Input parameters for the EOS_Reports_SendPlayerBehaviorReport function.
 */
EOS_STRUCT(EOS_Reports_SendPlayerBehaviorReportOptions, (
	/** API Version: Set this to EOS_REPORTS_SENDPLAYERBEHAVIORREPORT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the reporting player */
	EOS_ProductUserId ReporterUserId;
	/** Product User ID of the reported player. */
	EOS_ProductUserId ReportedUserId;
	/** Category for the player report. */
	EOS_EPlayerReportsCategory Category;
	/**
	 * Optional plain text string associated with the report as UTF-8 encoded null-terminated string.
	 *
	 * The length of the message can be at maximum up to EOS_REPORTS_REPORTMESSAGE_MAX_LENGTH bytes
	 * and any excess characters will be truncated upon sending the report.
	 */
	const char* Message;
	/**
	 * Optional JSON string associated with the report as UTF-8 encoded null-terminated string.
	 * This is intended as a way to associate arbitrary structured context information with a report.
	 *
	 * This string needs to be valid JSON, report will fail otherwise.
	 * The length of the context can be at maximum up to EOS_REPORTS_REPORTCONTEXT_MAX_LENGTH bytes, not including the null terminator, report will fail otherwise.
	 */
	const char* Context;
));

/**
 * Output parameters for the EOS_Reports_SendPlayerBehaviorReport function.
 */
EOS_STRUCT(EOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Reports_SendPlayerBehaviorReport. */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Reports_SendPlayerBehaviorReport.
 * @param Data A EOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Reports_OnSendPlayerBehaviorReportCompleteCallback, const EOS_Reports_SendPlayerBehaviorReportCompleteCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_result.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

// This file is not intended to be included directly. Include eos_common.h instead.

/** Successful result. no further error processing needed */
EOS_RESULT_VALUE(EOS_Success, 0)

/** Failed due to no connection */
EOS_RESULT_VALUE(EOS_NoConnection, 1)
/** Failed login due to invalid credentials */
EOS_RESULT_VALUE(EOS_InvalidCredentials, 2)
/** Failed due to invalid or missing user */
EOS_RESULT_VALUE(EOS_InvalidUser, 3)
/** Failed due to invalid or missing authentication token for user (e.g. not logged in) */
EOS_RESULT_VALUE(EOS_InvalidAuth, 4)
/** Failed due to invalid access */
EOS_RESULT_VALUE(EOS_AccessDenied, 5)
/** If the client does not possess the permission required */
EOS_RESULT_VALUE(EOS_MissingPermissions, 6)
/** If the token provided does not represent an account */
EOS_RESULT_VALUE(EOS_Token_Not_Account, 7)
/** Throttled due to too many requests */
EOS_RESULT_VALUE(EOS_TooManyRequests, 8)
/** Async request was already pending */
EOS_RESULT_VALUE(EOS_AlreadyPending, 9)
/** Invalid parameters specified for request */
EOS_RESULT_VALUE(EOS_InvalidParameters, 10)
/** Invalid request */
EOS_RESULT_VALUE(EOS_InvalidRequest, 11)
/** Failed due to unable to parse or recognize a backend response */
EOS_RESULT_VALUE(EOS_UnrecognizedResponse, 12)
/** Incompatible client for backend version */
EOS_RESULT_VALUE(EOS_IncompatibleVersion, 13)
/** Not configured correctly for use */
EOS_RESULT_VALUE(EOS_NotConfigured, 14)
/** Already configured for use. */
EOS_RESULT_VALUE(EOS_AlreadyConfigured, 15)
/** Feature not available on this implementation */
EOS_RESULT_VALUE(EOS_NotImplemented, 16)
/** Operation was canceled (likely by user) */
EOS_RESULT_VALUE(EOS_Canceled, 17)
/** The requested information was not found */
EOS_RESULT_VALUE(EOS_NotFound, 18)
/** An error occurred during an asynchronous operation, and it will be retried. Callbacks receiving this result will be called again in the future. */
EOS_RESULT_VALUE(EOS_OperationWillRetry, 19)
/** The request had no effect */
EOS_RESULT_VALUE(EOS_NoChange, 20)
/** The request attempted to use multiple or inconsistent API versions */
EOS_RESULT_VALUE(EOS_VersionMismatch, 21)
/** A maximum limit was exceeded on the client, different from EOS_TooManyRequests */
EOS_RESULT_VALUE(EOS_LimitExceeded, 22)
/** Feature or client ID performing the operation has been disabled. */
EOS_RESULT_VALUE(EOS_Disabled, 23)
/** Duplicate entry not allowed */
EOS_RESULT_VALUE(EOS_DuplicateNotAllowed, 24)
/** Required parameters are missing. DEPRECATED: This error is no longer used. */
EOS_RESULT_VALUE(EOS_MissingParameters_DEPRECATED, 25)
/** Sandbox ID is invalid */
EOS_RESULT_VALUE(EOS_InvalidSandboxId, 26)
/** Request timed out */
EOS_RESULT_VALUE(EOS_TimedOut, 27)
/** A query returned some but not all of the requested results. */
EOS_RESULT_VALUE(EOS_PartialResult, 28)
/** Client is missing the whitelisted role */
EOS_RESULT_VALUE(EOS_Missing_Role, 29)
/** Client is missing the whitelisted feature */
EOS_RESULT_VALUE(EOS_Missing_Feature, 30)
/** The sandbox given to the backend is invalid */
EOS_RESULT_VALUE(EOS_Invalid_Sandbox, 31)
/** The deployment given to the backend is invalid */
EOS_RESULT_VALUE(EOS_Invalid_Deployment, 32)
/** The product ID specified to the backend is invalid */
EOS_RESULT_VALUE(EOS_Invalid_Product, 33)
/** The product user ID specified to the backend is invalid */
EOS_RESULT_VALUE(EOS_Invalid_ProductUserID, 34)
/** There was a failure with the backend service */
EOS_RESULT_VALUE(EOS_ServiceFailure, 35)
/** Cache directory is not set in platform options. */
EOS_RESULT_VALUE(EOS_CacheDirectoryMissing, 36)
/** Cache directory is not accessible. */
EOS_RESULT_VALUE(EOS_CacheDirectoryInvalid, 37)
/** The request failed because resource was in an invalid state */
EOS_RESULT_VALUE(EOS_InvalidState, 38)
/** Request is in progress */
EOS_RESULT_VALUE(EOS_RequestInProgress, 39)
/** Application is suspended */
EOS_RESULT_VALUE(EOS_ApplicationSuspended, 40)
/** Network is disconnected */
EOS_RESULT_VALUE(EOS_NetworkDisconnected, 41)

/** Account locked due to login failures */
EOS_RESULT_VALUE(EOS_Auth_AccountLocked, 1001)
/** Account locked by update operation. */
EOS_RESULT_VALUE(EOS_Auth_AccountLockedForUpdate, 1002)
/** Refresh token used was invalid */
EOS_RESULT_VALUE(EOS_Auth_InvalidRefreshToken, 1003)
/** Invalid access token, typically when switching between backend environments */
EOS_RESULT_VALUE(EOS_Auth_InvalidToken, 1004)
/** Invalid bearer token */
EOS_RESULT_VALUE(EOS_Auth_AuthenticationFailure, 1005)
/** Invalid platform token */
EOS_RESULT_VALUE(EOS_Auth_InvalidPlatformToken, 1006)
/** Auth parameters are not associated with this account */
EOS_RESULT_VALUE(EOS_Auth_WrongAccount, 1007)
/** Auth parameters are not associated with this client */
EOS_RESULT_VALUE(EOS_Auth_WrongClient, 1008)
/** Full account is required */
EOS_RESULT_VALUE(EOS_Auth_FullAccountRequired, 1009)
/** Headless account is required */
EOS_RESULT_VALUE(EOS_Auth_HeadlessAccountRequired, 1010)
/** Password reset is required */
EOS_RESULT_VALUE(EOS_Auth_PasswordResetRequired, 1011)
/** Password was previously used and cannot be reused */
EOS_RESULT_VALUE(EOS_Auth_PasswordCannotBeReused, 1012)
/** Authorization code/exchange code has expired */
EOS_RESULT_VALUE(EOS_Auth_Expired, 1013)
/** Consent has not been given by the user */
EOS_RESULT_VALUE(EOS_Auth_ScopeConsentRequired, 1014)
/** The application has no profile on the backend */
EOS_RESULT_VALUE(EOS_Auth_ApplicationNotFound, 1015)
/** The requested consent wasn't found on the backend */
EOS_RESULT_VALUE(EOS_Auth_ScopeNotFound, 1016)
/** This account has been denied access to login */
EOS_RESULT_VALUE(EOS_Auth_AccountFeatureRestricted, 1017)
/** The overlay failed to load the Account Portal. This can range from general overlay failure, to overlay failed to connect to the web server, to overlay failed to render the web page. */
EOS_RESULT_VALUE(EOS_Auth_AccountPortalLoadError, 1018)
/** An attempted login has failed due to the user needing to take corrective action on their account. */
EOS_RESULT_VALUE(EOS_Auth_CorrectiveActionRequired, 1019)

/** Pin grant code initiated */
EOS_RESULT_VALUE(EOS_Auth_PinGrantCode, 1020)
/** Pin grant code attempt expired */
EOS_RESULT_VALUE(EOS_Auth_PinGrantExpired, 1021)
/** Pin grant code attempt pending */
EOS_RESULT_VALUE(EOS_Auth_PinGrantPending, 1022)

/** External auth source did not yield an account */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthNotLinked, 1030)
/** External auth access revoked */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthRevoked, 1032)
/** External auth token cannot be interpreted */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthInvalid, 1033)
/** External auth cannot be linked to his account due to restrictions */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthRestricted, 1034)
/** External auth cannot be used for login */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthCannotLogin, 1035)
/** External auth is expired */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthExpired, 1036)
/** External auth cannot be removed since it's the last possible way to login */
EOS_RESULT_VALUE(EOS_Auth_ExternalAuthIsLastLoginType, 1037)

/** Exchange code not found */
EOS_RESULT_VALUE(EOS_Auth_ExchangeCodeNotFound, 1040)
/** Originating exchange code session has expired */
EOS_RESULT_VALUE(EOS_Auth_OriginatingExchangeCodeSessionExpired, 1041)

/** The account has been disabled and cannot be used for authentication */
EOS_RESULT_VALUE(EOS_Auth_AccountNotActive, 1050)

/** MFA challenge required */
EOS_RESULT_VALUE(EOS_Auth_MFARequired, 1060)

/** Parental locks are in place */
EOS_RESULT_VALUE(EOS_Auth_ParentalControls, 1070)

/** Korea real ID association required but missing */
EOS_RESULT_VALUE(EOS_Auth_NoRealId, 1080)

/** Silent login failed when EOS_LF_NO_USER_INTERFACE was specified, and user interaction is needed before the user can be logged in. */
EOS_RESULT_VALUE(EOS_Auth_UserInterfaceRequired, 1090)

/** An outgoing friend invitation is awaiting acceptance; sending another invite to the same user is erroneous */
EOS_RESULT_VALUE(EOS_Friends_InviteAwaitingAcceptance, 2000)
/** There is no friend invitation to accept/reject */
EOS_RESULT_VALUE(EOS_Friends_NoInvitation, 2001)
/** Users are already friends, so sending another invite is erroneous */
EOS_RESULT_VALUE(EOS_Friends_AlreadyFriends, 2003)
/** Users are not friends, so deleting the friend is erroneous */
EOS_RESULT_VALUE(EOS_Friends_NotFriends, 2004)
/** Remote user has too many invites to receive new invites */
EOS_RESULT_VALUE(EOS_Friends_TargetUserTooManyInvites, 2005)
/** Local user has too many invites to send new invites */
EOS_RESULT_VALUE(EOS_Friends_LocalUserTooManyInvites, 2006)
/** Remote user has too many friends to make a new friendship */
EOS_RESULT_VALUE(EOS_Friends_TargetUserFriendLimitExceeded, 2007)
/** Local user has too many friends to make a new friendship */
EOS_RESULT_VALUE(EOS_Friends_LocalUserFriendLimitExceeded, 2008)

/** Request data was null or invalid */
EOS_RESULT_VALUE(EOS_Presence_DataInvalid, 3000)
/** Request contained too many or too few unique data items, or the request would overflow the maximum amount of data allowed */
EOS_RESULT_VALUE(EOS_Presence_DataLengthInvalid, 3001)
/** Request contained data with an invalid key */
EOS_RESULT_VALUE(EOS_Presence_DataKeyInvalid, 3002)
/** Request contained data with a key too long or too short */
EOS_RESULT_VALUE(EOS_Presence_DataKeyLengthInvalid, 3003)
/** Request contained data with an invalid value */
EOS_RESULT_VALUE(EOS_Presence_DataValueInvalid, 3004)
/** Request contained data with a value too long */
EOS_RESULT_VALUE(EOS_Presence_DataValueLengthInvalid, 3005)
/** Request contained an invalid rich text string */
EOS_RESULT_VALUE(EOS_Presence_RichTextInvalid, 3006)
/** Request contained a rich text string that was too long */
EOS_RESULT_VALUE(EOS_Presence_RichTextLengthInvalid, 3007)
/** Request contained an invalid status state */
EOS_RESULT_VALUE(EOS_Presence_StatusInvalid, 3008)

/** The entitlement retrieved is stale, requery for updated information */
EOS_RESULT_VALUE(EOS_Ecom_EntitlementStale, 4000)
/** The offer retrieved is stale, requery for updated information */
EOS_RESULT_VALUE(EOS_Ecom_CatalogOfferStale, 4001)
/** The item or associated structure retrieved is stale, requery for updated information */
EOS_RESULT_VALUE(EOS_Ecom_CatalogItemStale, 4002)
/** The one or more offers has an invalid price. This may be caused by the price setup. */
EOS_RESULT_VALUE(EOS_Ecom_CatalogOfferPriceInvalid, 4003)
/** The checkout page failed to load */
EOS_RESULT_VALUE(EOS_Ecom_CheckoutLoadError, 4004)
/** The player closed the purchase flow overlay after clicking the purchase button. The purchase may still go through, and the game needs to query unredeemed entitlements for a short time. */
EOS_RESULT_VALUE(EOS_Ecom_PurchaseProcessing, 4005)

/** Session is already in progress */
EOS_RESULT_VALUE(EOS_Sessions_SessionInProgress, 5000)
/** Too many players to register with this session */
EOS_RESULT_VALUE(EOS_Sessions_TooManyPlayers, 5001)
/** Client has no permissions to access this session */
EOS_RESULT_VALUE(EOS_Sessions_NoPermission, 5002)
/** Session already exists in the system */
EOS_RESULT_VALUE(EOS_Sessions_SessionAlreadyExists, 5003)
/** Session lock required for operation */
EOS_RESULT_VALUE(EOS_Sessions_InvalidLock, 5004)
/** Invalid session reference */
EOS_RESULT_VALUE(EOS_Sessions_InvalidSession, 5005)
/** Sandbox ID associated with auth didn't match */
EOS_RESULT_VALUE(EOS_Sessions_SandboxNotAllowed, 5006)
/** Invite failed to send */
EOS_RESULT_VALUE(EOS_Sessions_InviteFailed, 5007)
/** Invite was not found with the service */
EOS_RESULT_VALUE(EOS_Sessions_InviteNotFound, 5008)
/** This client may not modify the session */
EOS_RESULT_VALUE(EOS_Sessions_UpsertNotAllowed, 5009)
/** Backend nodes unavailable to process request */
EOS_RESULT_VALUE(EOS_Sessions_AggregationFailed, 5010)
/** Individual backend node is as capacity */
EOS_RESULT_VALUE(EOS_Sessions_HostAtCapacity, 5011)
/** Sandbox on node is at capacity */
EOS_RESULT_VALUE(EOS_Sessions_SandboxAtCapacity, 5012)
/** An anonymous operation was attempted on a non anonymous session */
EOS_RESULT_VALUE(EOS_Sessions_SessionNotAnonymous, 5013)
/** Session is currently out of sync with the backend, data is saved locally but needs to sync with backend */
EOS_RESULT_VALUE(EOS_Sessions_OutOfSync, 5014)
/** User has received too many invites */
EOS_RESULT_VALUE(EOS_Sessions_TooManyInvites, 5015)
/** Presence session already exists for the client */
EOS_RESULT_VALUE(EOS_Sessions_PresenceSessionExists, 5016)
/** Deployment on node is at capacity */
EOS_RESULT_VALUE(EOS_Sessions_DeploymentAtCapacity, 5017)
/** Session operation not allowed */
EOS_RESULT_VALUE(EOS_Sessions_NotAllowed, 5018)
/** Session operation not allowed */
EOS_RESULT_VALUE(EOS_Sessions_PlayerSanctioned, 5019)

/** Request filename was invalid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FilenameInvalid, 6000)
/** Request filename was too long */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FilenameLengthInvalid, 6001)
/** Request filename contained invalid characters */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FilenameInvalidChars, 6002)
/** Request operation would grow file too large */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileSizeTooLarge, 6003)
/** Request file length is not valid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileSizeInvalid, 6004)
/** Request file handle is not valid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileHandleInvalid, 6005)
/** Request data is invalid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_DataInvalid, 6006)
/** Request data length was invalid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_DataLengthInvalid, 6007)
/** Request start index was invalid */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_StartIndexInvalid, 6008)
/** Request is in progress */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_RequestInProgress, 6009)
/** User is marked as throttled which means he can't perform some operations because limits are exceeded. */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_UserThrottled, 6010)
/** Encryption key is not set during SDK init. */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_EncryptionKeyNotSet, 6011)
/** User data callback returned error (EOS_PlayerDataStorage_EWriteResult::EOS_WR_FailRequest or EOS_PlayerDataStorage_EReadResult::EOS_RR_FailRequest) */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_UserErrorFromDataCallback, 6012)
/** User is trying to read file that has header from newer version of SDK. Game/SDK needs to be updated. */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileHeaderHasNewerVersion, 6013)
/** The file is corrupted. In some cases retry can fix the issue. */
EOS_RESULT_VALUE(EOS_PlayerDataStorage_FileCorrupted, 6014)

/** EOS Auth service deemed the external token invalid */
EOS_RESULT_VALUE(EOS_Connect_ExternalTokenValidationFailed, 7000)
/** EOS Auth user already exists */
EOS_RESULT_VALUE(EOS_Connect_UserAlreadyExists, 7001)
/** EOS Auth expired */
EOS_RESULT_VALUE(EOS_Connect_AuthExpired, 7002)
/** EOS Auth invalid token */
EOS_RESULT_VALUE(EOS_Connect_InvalidToken, 7003)
/** EOS Auth doesn't support this token type */
EOS_RESULT_VALUE(EOS_Connect_UnsupportedTokenType, 7004)
/** EOS Auth Account link failure */
EOS_RESULT_VALUE(EOS_Connect_LinkAccountFailed, 7005)
/** EOS Auth External service for validation was unavailable */
EOS_RESULT_VALUE(EOS_Connect_ExternalServiceUnavailable, 7006)
/** EOS Auth External Service configuration failure with Dev Portal */
EOS_RESULT_VALUE(EOS_Connect_ExternalServiceConfigurationFailure, 7007)
/** EOS Auth Account link failure. Tried to link Nintendo Network Service Account without first linking Nintendo Account. DEPRECATED: The requirement has been removed and this error is no longer used. */
EOS_RESULT_VALUE(EOS_Connect_LinkAccountFailedMissingNintendoIdAccount_DEPRECATED, 7008)

/** The social overlay page failed to load */
EOS_RESULT_VALUE(EOS_UI_SocialOverlayLoadError, 8000)
/** Virtual Memory Functions are an inconsistent mix of functions and nullptrs */
EOS_RESULT_VALUE(EOS_UI_InconsistentVirtualMemoryFunctions, 8001)

/** Client has no permissions to modify this lobby */
EOS_RESULT_VALUE(EOS_Lobby_NotOwner, 9000)
/** Lobby lock required for operation */
EOS_RESULT_VALUE(EOS_Lobby_InvalidLock, 9001)
/** Lobby already exists in the system */
EOS_RESULT_VALUE(EOS_Lobby_LobbyAlreadyExists, 9002)
/** Lobby is already in progress */
EOS_RESULT_VALUE(EOS_Lobby_SessionInProgress, 9003)
/** Too many players to register with this lobby */
EOS_RESULT_VALUE(EOS_Lobby_TooManyPlayers, 9004)
/** Client has no permissions to access this lobby */
EOS_RESULT_VALUE(EOS_Lobby_NoPermission, 9005)
/** Invalid lobby session reference */
EOS_RESULT_VALUE(EOS_Lobby_InvalidSession, 9006)
/** Sandbox ID associated with auth didn't match */
EOS_RESULT_VALUE(EOS_Lobby_SandboxNotAllowed, 9007)
/** Invite failed to send */
EOS_RESULT_VALUE(EOS_Lobby_InviteFailed, 9008)
/** Invite was not found with the service */
EOS_RESULT_VALUE(EOS_Lobby_InviteNotFound, 9009)
/** This client may not modify the lobby */
EOS_RESULT_VALUE(EOS_Lobby_UpsertNotAllowed, 9010)
/** Backend nodes unavailable to process request */
EOS_RESULT_VALUE(EOS_Lobby_AggregationFailed, 9011)
/** Individual backend node is as capacity */
EOS_RESULT_VALUE(EOS_Lobby_HostAtCapacity, 9012)
/** Sandbox on node is at capacity */
EOS_RESULT_VALUE(EOS_Lobby_SandboxAtCapacity, 9013)
/** User has received too many invites */
EOS_RESULT_VALUE(EOS_Lobby_TooManyInvites, 9014)
/** Deployment on node is at capacity */
EOS_RESULT_VALUE(EOS_Lobby_DeploymentAtCapacity, 9015)
/** Lobby operation not allowed */
EOS_RESULT_VALUE(EOS_Lobby_NotAllowed, 9016)
/** While restoring a lost connection lobby ownership changed and only local member data was updated */
EOS_RESULT_VALUE(EOS_Lobby_MemberUpdateOnly, 9017)
/** Presence lobby already exists for the client */
EOS_RESULT_VALUE(EOS_Lobby_PresenceLobbyExists, 9018)
/** Operation requires lobby with voice enabled */
EOS_RESULT_VALUE(EOS_Lobby_VoiceNotEnabled, 9019)
/** The client platform does not match the allowed platform list for the lobby. */
EOS_RESULT_VALUE(EOS_Lobby_PlatformNotAllowed, 9020)

/** User callback that receives data from storage returned error. */
EOS_RESULT_VALUE(EOS_TitleStorage_UserErrorFromDataCallback, 10000)
/** User forgot to set Encryption key during platform init. Title Storage can't work without it. */
EOS_RESULT_VALUE(EOS_TitleStorage_EncryptionKeyNotSet, 10001)
/** Downloaded file is corrupted. */
EOS_RESULT_VALUE(EOS_TitleStorage_FileCorrupted, 10002)
/** Downloaded file's format is newer than client SDK version. */
EOS_RESULT_VALUE(EOS_TitleStorage_FileHeaderHasNewerVersion, 10003)

/** ModSdk process is already running. This error comes from the EOSSDK. */
EOS_RESULT_VALUE(EOS_Mods_ModSdkProcessIsAlreadyRunning, 11000)
/** ModSdk command is empty. Either the ModSdk configuration file is missing or the manifest location is empty. */
EOS_RESULT_VALUE(EOS_Mods_ModSdkCommandIsEmpty, 11001)
/** Creation of the ModSdk process failed. This error comes from the SDK. */
EOS_RESULT_VALUE(EOS_Mods_ModSdkProcessCreationFailed, 11002)
/** A critical error occurred in the external ModSdk process that we were unable to resolve. */
EOS_RESULT_VALUE(EOS_Mods_CriticalError, 11003)
/** A internal error occurred in the external ModSdk process that we were unable to resolve. */
EOS_RESULT_VALUE(EOS_Mods_ToolInternalError, 11004)
/** A IPC failure occurred in the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_IPCFailure, 11005)
/** A invalid IPC response received in the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_InvalidIPCResponse, 11006)
/** A URI Launch failure occurred in the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_URILaunchFailure, 11007)
/** Attempting to perform an action with a mod that is not installed. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_ModIsNotInstalled, 11008)
/** Attempting to perform an action on a game that the user doesn't own. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_UserDoesNotOwnTheGame, 11009)
/** Invalid result of the request to get the offer for the mod. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_OfferRequestByIdInvalidResult, 11010)
/** Could not find the offer for the mod. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_CouldNotFindOffer, 11011)
/** Request to get the offer for the mod failed. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_OfferRequestByIdFailure, 11012)
/** Request to purchase the mod failed. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_PurchaseFailure, 11013)
/** Attempting to perform an action on a game that is not installed or is partially installed. This error comes from the external ModSdk process. */
EOS_RESULT_VALUE(EOS_Mods_InvalidGameInstallInfo, 11014)
/** Failed to get manifest location. Either the ModSdk configuration file is missing or the manifest location is empty */
EOS_RESULT_VALUE(EOS_Mods_CannotGetManifestLocation, 11015)
/** Attempting to perform an action with a mod that does not support the current operating system. */
EOS_RESULT_VALUE(EOS_Mods_UnsupportedOS, 11016)

/** The anti-cheat client protection is not available. Check that the game was started using the anti-cheat bootstrapper. */
EOS_RESULT_VALUE(EOS_AntiCheat_ClientProtectionNotAvailable, 12000)
/** The current anti-cheat mode is incorrect for using this API */
EOS_RESULT_VALUE(EOS_AntiCheat_InvalidMode, 12001)
/** The ProductId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK */
EOS_RESULT_VALUE(EOS_AntiCheat_ClientProductIdMismatch, 12002)
/** The SandboxId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK */
EOS_RESULT_VALUE(EOS_AntiCheat_ClientSandboxIdMismatch, 12003)
/** (ProtectMessage/UnprotectMessage) No session key is available, but it is required to complete this operation */
EOS_RESULT_VALUE(EOS_AntiCheat_ProtectMessageSessionKeyRequired, 12004)
/** (ProtectMessage/UnprotectMessage) Message integrity is invalid */
EOS_RESULT_VALUE(EOS_AntiCheat_ProtectMessageValidationFailed, 12005)
/** (ProtectMessage/UnprotectMessage) Initialization failed */
EOS_RESULT_VALUE(EOS_AntiCheat_ProtectMessageInitializationFailed, 12006)
/** (RegisterPeer) Peer is already registered */
EOS_RESULT_VALUE(EOS_AntiCheat_PeerAlreadyRegistered, 12007)
/** (UnregisterPeer) Peer does not exist */
EOS_RESULT_VALUE(EOS_AntiCheat_PeerNotFound, 12008)
/** (ReceiveMessageFromPeer) Invalid call: Peer is not protected */
EOS_RESULT_VALUE(EOS_AntiCheat_PeerNotProtected, 12009)
/** The DeploymentId provided to the anti-cheat client helper executable does not match what was used to initialize the EOS SDK */
EOS_RESULT_VALUE(EOS_AntiCheat_ClientDeploymentIdMismatch, 12010)
/** EOS Connect DeviceID auth method is not supported for anti-cheat */
EOS_RESULT_VALUE(EOS_AntiCheat_DeviceIdAuthIsNotSupported, 12011)

/** EOS RTC room cannot accept more participants */
EOS_RESULT_VALUE(EOS_RTC_TooManyParticipants, 13000)
/** EOS RTC room already exists*/
EOS_RESULT_VALUE(EOS_RTC_RoomAlreadyExists, 13001)
/** The user kicked out from the room */
EOS_RESULT_VALUE(EOS_RTC_UserKicked, 13002)
/** The user is banned */
EOS_RESULT_VALUE(EOS_RTC_UserBanned, 13003)
/** EOS RTC room was left successfully */
EOS_RESULT_VALUE(EOS_RTC_RoomWasLeft, 13004)
/** Connection dropped due to long timeout */
EOS_RESULT_VALUE(EOS_RTC_ReconnectionTimegateExpired, 13005)
/** EOS RTC room was left due to platform release */
EOS_RESULT_VALUE(EOS_RTC_ShutdownInvoked, 13006)
/** EOS RTC operation failed because the user is in the local user's block list */
EOS_RESULT_VALUE(EOS_RTC_UserIsInBlocklist, 13007)

/** The number of available Snapshot IDs have all been exhausted. */
EOS_RESULT_VALUE(EOS_ProgressionSnapshot_SnapshotIdUnavailable, 14000)

/** The KWS user does not have a parental email associated with the account.  The parent account was unlinked or deleted */
EOS_RESULT_VALUE(EOS_KWS_ParentEmailMissing, 15000)
/** The KWS user is no longer a minor and trying to update the parent email */
EOS_RESULT_VALUE(EOS_KWS_UserGraduated, 15001)

/** EOS Android VM not stored */
EOS_RESULT_VALUE(EOS_Android_JavaVMNotStored, 17000)
/** EOS Android if Reserved is set it must reference stored VM */
EOS_RESULT_VALUE(EOS_Android_ReservedMustReferenceLocalVM, 17001)
/** EOS Android Reserved must not be provided */
EOS_RESULT_VALUE(EOS_Android_ReservedMustBeNull, 17002)

/** Patch required before the user can use the privilege */
EOS_RESULT_VALUE(EOS_Permission_RequiredPatchAvailable, 18000)
/** System update required before the user can use the privilege */
EOS_RESULT_VALUE(EOS_Permission_RequiredSystemUpdate, 18001)
/** Parental control failure usually */
EOS_RESULT_VALUE(EOS_Permission_AgeRestrictionFailure, 18002)
/** Premium Account Subscription required but not available */
EOS_RESULT_VALUE(EOS_Permission_AccountTypeFailure, 18003)
/** User restricted from chat */
EOS_RESULT_VALUE(EOS_Permission_ChatRestriction, 18004)
/** User restricted from User Generated Content */
EOS_RESULT_VALUE(EOS_Permission_UGCRestriction, 18005)
/** Online play is restricted */
EOS_RESULT_VALUE(EOS_Permission_OnlinePlayRestricted, 18006)

/** The application was not launched through the Bootstrapper. Desktop crossplay functionality is unavailable. */
EOS_RESULT_VALUE(EOS_DesktopCrossplay_ApplicationNotBootstrapped, 19000)
/** The redistributable service is not installed. */
EOS_RESULT_VALUE(EOS_DesktopCrossplay_ServiceNotInstalled, 19001)
/** The desktop crossplay service failed to start. */
EOS_RESULT_VALUE(EOS_DesktopCrossplay_ServiceStartFailed, 19002)
/** The desktop crossplay service is no longer running for an unknown reason. */
EOS_RESULT_VALUE(EOS_DesktopCrossplay_ServiceNotRunning, 19003)

/** When sending the custom invite failed. */
EOS_RESULT_VALUE(EOS_CustomInvites_InviteFailed, 20000)

/** The best display name could not be safely determined. */
EOS_RESULT_VALUE(EOS_UserInfo_BestDisplayNameIndeterminate, 22000)

/** OnNetworkRequested_DEPRECATED callback not set when initializing platform */
EOS_RESULT_VALUE(EOS_ConsoleInit_OnNetworkRequestedDeprecatedCallbackNotSet, 23000)
/** CacheStorageSizeKB must be a multiple of 16 **/
EOS_RESULT_VALUE(EOS_ConsoleInit_CacheStorage_SizeKBNotMultipleOf16, 23001)
/** CacheStorageSizeKB is less than the minimum allowed **/
EOS_RESULT_VALUE(EOS_ConsoleInit_CacheStorage_SizeKBBelowMinimumSize, 23002)
/** CacheStorageSizeKB is greater than the maximum allowed (4000 MB) **/
EOS_RESULT_VALUE(EOS_ConsoleInit_CacheStorage_SizeKBExceedsMaximumSize, 23003)
/** CacheStorageIndex is out of its allowed range **/
EOS_RESULT_VALUE(EOS_ConsoleInit_CacheStorage_IndexOutOfRangeRange, 23004)

/** An unexpected error that we cannot identify has occurred. */
EOS_RESULT_VALUE_LAST(EOS_UnexpectedError, 0x7FFFFFFF)

```

`EAC_SDK/SDK/include/eos_rtc.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_rtc_types.h"
#include "eos_rtc_audio_types.h"
#include "eos_rtc_data_types.h"

/**
 * The RTC Interface is used to manage joining and leaving rooms.
 *
 * @see EOS_Platform_GetRTCInterface
 */

/**
 * Get a handle to the Audio interface
 * @return EOS_HRTCAudio handle
 *
 * @see eos_rtc_audio.h
 * @see eos_rtc_audio_types.h
 */
EOS_DECLARE_FUNC(EOS_HRTCAudio) EOS_RTC_GetAudioInterface(EOS_HRTC Handle);

/**
 * Get a handle to the Data interface
 * @return EOS_HRTCData handle
 *
 * @see eos_rtc_data.h
 * @see eos_rtc_data_types.h
 */
EOS_DECLARE_FUNC(EOS_HRTCData) EOS_RTC_GetDataInterface(EOS_HRTC Handle);

/**
 * Use this function to join a room.
 *
 * This function does not need to called for the Lobby RTC Room system; doing so will return EOS_AccessDenied. The lobby system will
 * automatically join and leave RTC Rooms for all lobbies that have RTC rooms enabled.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_RTC_JoinRoom(EOS_HRTC Handle, const EOS_RTC_JoinRoomOptions* Options, void* ClientData, const EOS_RTC_OnJoinRoomCallback CompletionDelegate);

/**
 * Use this function to leave a room and clean up all the resources associated with it. This function has to always be called when the
 * room is abandoned even if the user is already disconnected for other reasons.
 *
 * This function does not need to called for the Lobby RTC Room system; doing so will return EOS_AccessDenied. The lobby system will
 * automatically join and leave RTC Rooms for all lobbies that have RTC rooms enabled.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if not in the specified room
 */
EOS_DECLARE_FUNC(void) EOS_RTC_LeaveRoom(EOS_HRTC Handle, const EOS_RTC_LeaveRoomOptions* Options, void* ClientData, const EOS_RTC_OnLeaveRoomCallback CompletionDelegate);

/**
 * Use this function to block a participant already connected to the room. After blocking them no media will be sent or received between
 * that user and the local user. This method can be used after receiving the OnParticipantStatusChanged notification.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if either the local user or specified participant are not in the specified room
 *         EOS_RTC_UserIsInBlocklist The user is in one of the platform's applicable block lists and thus an RTC unblock is not allowed.
 */
EOS_DECLARE_FUNC(void) EOS_RTC_BlockParticipant(EOS_HRTC Handle, const EOS_RTC_BlockParticipantOptions* Options, void* ClientData, const EOS_RTC_OnBlockParticipantCallback CompletionDelegate);

/**
 * Register to receive notifications when disconnected from the room. If the returned NotificationId is valid, you must call
 * EOS_RTC_RemoveNotifyDisconnected when you no longer wish to have your CompletionDelegate called.
 *
 * This function will always return EOS_INVALID_NOTIFICATIONID when used with lobby RTC room. To be notified of the connection
 * status of a Lobby-managed RTC room, use the EOS_Lobby_AddNotifyRTCRoomConnectionChanged function instead.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a participant is disconnected from the room
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTC_RemoveNotifyDisconnected
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTC_AddNotifyDisconnected(EOS_HRTC Handle, const EOS_RTC_AddNotifyDisconnectedOptions* Options, void* ClientData, const EOS_RTC_OnDisconnectedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving room disconnection notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTC_RemoveNotifyDisconnected(EOS_HRTC Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when a participant's status changes (e.g: join or leave the room), or when the participant is added or removed
 * from an applicable block list (e.g: Epic block list and/or current platform's block list).
 * If the returned NotificationId is valid, you must call EOS_RTC_RemoveNotifyParticipantStatusChanged when you no longer wish to have your CompletionDelegate called.
 *
 * If you register to this notification before joining a room, you will receive a notification for every member already in the room when you join said room.
 * This allows you to know who is already in the room when you join.
 *
 * To be used effectively with a Lobby-managed RTC room, this should be registered during the EOS_Lobby_CreateLobby or EOS_Lobby_JoinLobby completion
 * callbacks when the ResultCode is EOS_Success. If this notification is registered after that point, it is possible to miss notifications for
 * already-existing room participants.
 *
 * You can use this notification to detect internal automatic RTC blocks due to block lists.
 * When a participant joins a room and while the system resolves the block list status of said participant, the participant is set to blocked and you'll receive
 * a notification with ParticipantStatus set to EOS_RTCPS_Joined and bParticipantInBlocklist set to true.
 * Once the block list status is resolved, if the player is not in any applicable block list(s), it is then unblocked and a new notification is sent with
 * ParticipantStatus set to EOS_RTCPS_Joined and bParticipantInBlocklist set to false.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a participant changes status
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @note This notification is also raised when the local user joins the room, but NOT when the local user leaves the room.
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTC_RemoveNotifyParticipantStatusChanged
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTC_AddNotifyParticipantStatusChanged(EOS_HRTC Handle, const EOS_RTC_AddNotifyParticipantStatusChangedOptions* Options, void* ClientData, const EOS_RTC_OnParticipantStatusChangedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving participant status change notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTC_RemoveNotifyParticipantStatusChanged(EOS_HRTC Handle, EOS_NotificationId NotificationId);

/**
 * Use this function to control settings.
 *
 * The available settings are documented as part of EOS_RTC_SetSettingOptions.
 *
 * @param Options structure containing the parameters for the operation
 * @return EOS_Success when the setting is successfully set, EOS_NotFound when the setting is unknown, EOS_InvalidParameters when the value is invalid.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTC_SetSetting(EOS_HRTC Handle, const EOS_RTC_SetSettingOptions* Options);

/**
 * Use this function to control settings for the specific room.
 *
 * The available settings are documented as part of EOS_RTC_SetRoomSettingOptions.
 *
 * @param Options structure containing the parameters for the operation
 * @return EOS_Success when the setting is successfully set, EOS_NotFound when the setting is unknown, EOS_InvalidParameters when the value is invalid.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTC_SetRoomSetting(EOS_HRTC Handle, const EOS_RTC_SetRoomSettingOptions* Options);

/**
 * Register to receive notifications to receiving periodical statistics update. If the returned NotificationId is valid, you must call
 * EOS_RTC_RemoveNotifyRoomStatisticsUpdated when you no longer wish to have your StatisticsUpdateHandler called.
 *
 * @param ClientData Arbitrary data that is passed back in the StatisticsUpdateHandler
 * @param CompletionDelegate The callback to be fired when a statistics updated.
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTC_RemoveNotifyRoomStatisticsUpdated
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTC_AddNotifyRoomStatisticsUpdated(EOS_HRTC Handle, const EOS_RTC_AddNotifyRoomStatisticsUpdatedOptions* Options, void* ClientData, const EOS_RTC_OnRoomStatisticsUpdatedCallback StatisticsUpdateHandler);

/**
 * Unregister a previously bound notification handler from receiving periodical statistics update notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTC_RemoveNotifyRoomStatisticsUpdated(EOS_HRTC Handle, EOS_NotificationId NotificationId);

```

`EAC_SDK/SDK/include/eos_rtc_admin.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_rtc_admin_types.h"

/**
 * The RTC Admin interface.
 *
 * This is used to manage admin-specific RTC features, such as requesting join tokens, kick users, etc.
 *
 * @see EOS_Platform_GetRTCAdminInterface
 */

/**
 * Query for a list of user tokens for joining a room.
 *
 * Each query generates a query id ( see EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo ) which should be used
 * to retrieve the tokens from inside the callback.
 *
 *This query id and query result itself are only valid for the duration of the callback.
 *
 * @param Options Structure containing information about the application whose user tokens we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the query join room token operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_RTCAdmin_QueryJoinRoomToken(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_QueryJoinRoomTokenOptions* Options, void* ClientData, const EOS_RTCAdmin_OnQueryJoinRoomTokenCompleteCallback CompletionDelegate);

/**
 * Fetches a user token when called inside of the OnQueryJoinRoomTokenComplete callback.
 *
 * @param Options Structure containing the index being accessed
 * @param OutUserToken The user token for the given index, if it exists and is valid. Use EOS_RTCAdmin_UserToken_Release when finished
 *
 * @note The order of the tokens doesn't necessarily match the order of the EOS_ProductUserId array specified in the EOS_RTCAdmin_QueryJoinRoomTokenOptions when
 * initiating the query.
 *
 * @see EOS_RTCAdmin_UserToken_Release
 *
 * @return EOS_Success if the information is available and passed out in OutUserToken
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the user token is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAdmin_CopyUserTokenByIndex(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_CopyUserTokenByIndexOptions* Options, EOS_RTCAdmin_UserToken ** OutUserToken);

/**
 * Fetches a user token for a given user ID when called inside of the OnQueryJoinRoomTokenComplete callback.
 *
 * @param Options Structure containing the user ID being accessed
 * @param OutUserToken The user token for the given user ID, if it exists and is valid. Use EOS_RTCAdmin_UserToken_Release when finished
 *
 * @see EOS_RTCAdmin_UserToken_Release
 *
 * @return EOS_Success if the information is available and passed out in OutUserToken
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the user token is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAdmin_CopyUserTokenByUserId(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_CopyUserTokenByUserIdOptions* Options, EOS_RTCAdmin_UserToken ** OutUserToken);

/**
 * Starts an asynchronous task that removes a participant from a room and revokes their token.
 *
 * @param Options structure containing the room and user to revoke the token from.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 */
EOS_DECLARE_FUNC(void) EOS_RTCAdmin_Kick(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_KickOptions* Options, void* ClientData, const EOS_RTCAdmin_OnKickCompleteCallback CompletionDelegate);

/**
 * Starts an asynchronous task remotely mutes/unmutes a room participant.
 *
 * This remotely mutes the specified participant, so no audio is sent from that participant to any other participant in the room.
 *
 * @param Options structure containing the room and user to mute.
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 */
EOS_DECLARE_FUNC(void) EOS_RTCAdmin_SetParticipantHardMute(EOS_HRTCAdmin Handle, const EOS_RTCAdmin_SetParticipantHardMuteOptions* Options, void* ClientData, const EOS_RTCAdmin_OnSetParticipantHardMuteCompleteCallback CompletionDelegate);

```

`EAC_SDK/SDK/include/eos_rtc_admin_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_RTCAdminHandle* EOS_HRTCAdmin;

/** The most recent version of the EOS_RTCAdmin_QueryJoinRoomToken API */
#define EOS_RTCADMIN_QUERYJOINROOMTOKEN_API_LATEST 2

/**
 * Input parameters for the EOS_RTCAdmin_QueryJoinRoomToken function.
 */
EOS_STRUCT(EOS_RTCAdmin_QueryJoinRoomTokenOptions, (
	/** API Version: Set this to EOS_RTCADMIN_QUERYJOINROOMTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID for local user who is querying join room tokens. */
	EOS_ProductUserId LocalUserId;
	/** Room name to request a token for. */
	const char* RoomName;
	/** An array of Product User IDs indicating the users to retrieve a token for. */
	EOS_ProductUserId* TargetUserIds;
	/** The number of users included in the query. */
	uint32_t TargetUserIdsCount;
	/**
	 * Array of IP Addresses, one for each of the users we're querying tokens for.
	 * There should be TargetUserIdsCount Ip Addresses, you can set an entry to NULL if not known.
	 * If TargetUserIpAddresses is set to NULL IP Addresses will be ignored.
	 * IPv4 format: "0.0.0.0"
	 * IPv6 format: "0:0:0:0:0:0:0:0"
	 */
	const char** TargetUserIpAddresses;
));

/**
 * Data containing the result information for a query join room token request.
 */
EOS_STRUCT(EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_RTCAdmin_QueryJoinRoomToken. */
	void* ClientData;
	/** Room the request was made for. */
	const char* RoomName;
	/** URL passed to backend to join room. */
	const char* ClientBaseUrl;
	/** If the query completed successfully, this contains an identifier that should be used to retrieve the tokens.
	 * This identifier is only valid for the duration of the callback.
	 *
	 * @see EOS_RTCAdmin_CopyUserTokenByIndex
	 * @see EOS_RTCAdmin_CopyUserTokenByUserId
	 */
	uint32_t QueryId;
	/** How many token received as result of the query */
	uint32_t TokenCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_RTCAdmin_QueryJoinRoomToken
 * @param Data An EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_RTCAdmin_OnQueryJoinRoomTokenCompleteCallback, const EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo* Data);

/** The most recent version of the EOS_RTCAdmin_UserToken struct. */
#define EOS_RTCADMIN_USERTOKEN_API_LATEST 1

/**
 * Contains information about a collection of user tokens for joining a room.
 */
EOS_STRUCT(EOS_RTCAdmin_UserToken, (
	/** API Version: Set this to EOS_RTCADMIN_USERTOKEN_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user who owns this user token. */
	EOS_ProductUserId ProductUserId;
	/** Access token to enable a user to join a room */
	const char* Token;
));

/** The most recent version of the EOS_RTCAdmin_CopyUserTokenByIndexOptions struct. */
#define EOS_RTCADMIN_COPYUSERTOKENBYINDEX_API_LATEST 2

/**
 * Input parameters for the EOS_RTCAdmin_CopyUserTokenByIndex function.
 */
EOS_STRUCT(EOS_RTCAdmin_CopyUserTokenByIndexOptions, (
	/** API Version: Set this to EOS_RTCADMIN_COPYUSERTOKENBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the user token to retrieve from the cache. */
	uint32_t UserTokenIndex;
	/** Query identifier received as part of a previous query.
	 * @see EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo
	 */
	uint32_t QueryId;
));

/** The most recent version of the EOS_RTCAdmin_CopyUserTokenByUserIdOptions struct. */
#define EOS_RTCADMIN_COPYUSERTOKENBYUSERID_API_LATEST 2

/**
 * Input parameters for the EOS_RTCAdmin_CopyUserTokenByUserId function.
 */
EOS_STRUCT(EOS_RTCAdmin_CopyUserTokenByUserIdOptions, (
	/** API Version: Set this to EOS_RTCADMIN_COPYUSERTOKENBYUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose user token we're copying. */
	EOS_ProductUserId TargetUserId;
	/** Query identifier received as part of a previous query.
	 * @see EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo
	 */
	uint32_t QueryId;
));

/**
 * Release the memory associated with EOS_RTCAdmin_UserToken. This must be called on data retrieved from
 * EOS_RTCAdmin_CopyUserTokenByIndex or EOS_RTCAdmin_CopyUserTokenByUserId.
 *
 * @param UserToken - The user token to release.
 *
 * @see EOS_RTCAdmin_UserToken
 * @see EOS_RTCAdmin_CopyUserTokenByIndex
 * @see EOS_RTCAdmin_CopyUserTokenByUserId
 */
EOS_DECLARE_FUNC(void) EOS_RTCAdmin_UserToken_Release(EOS_RTCAdmin_UserToken* UserToken);

/** The most recent version of the EOS_RTCAdmin_Kick API */
#define EOS_RTCADMIN_KICK_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAdmin_Kick function.
 */
EOS_STRUCT(EOS_RTCAdmin_KickOptions, (
	/** API Version: Set this to EOS_RTCADMIN_KICK_API_LATEST. */
	int32_t ApiVersion;
	/** Room name to kick the participant from */
	const char* RoomName;
	/** Product User ID of the participant to kick from the room */
	EOS_ProductUserId TargetUserId;
));

/**
 * Data containing the result information for a kick participant request.
 */
EOS_STRUCT(EOS_RTCAdmin_KickCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the kick request */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_RTCAdmin_Kick
 * @param Data An EOS_RTCAdmin_KickCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_RTCAdmin_OnKickCompleteCallback, const EOS_RTCAdmin_KickCompleteCallbackInfo* Data);

/** The most recent version of the EOS_RTCAdmin_SetParticipantHardMuteOptions struct. */
#define EOS_RTCADMIN_SETPARTICIPANTHARDMUTE_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAdmin_SetParticipantHardMute function.
 */
EOS_STRUCT(EOS_RTCAdmin_SetParticipantHardMuteOptions, (
	/** API Version: Set this to EOS_RTCADMIN_SETPARTICIPANTHARDMUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Room to kick the participant from */
	const char* RoomName;
	/** Product User ID of the participant to hard mute for every participant in the room. */
	EOS_ProductUserId TargetUserId;
	/** Hard mute status (Mute on or off) */
	EOS_Bool bMute;
));

/**
 * Data containing the result information for a hard mute request.
 */
EOS_STRUCT(EOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the hard mute request */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_RTCAdmin_OnSetParticipantHardMuteCompleteCallback, const EOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo* Data);

#pragma pack(pop)


```

`EAC_SDK/SDK/include/eos_rtc_audio.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_rtc_audio_types.h"

/**
 * The RTC Audio Interface. This is used to manage Audio specific RTC features
 *
 * @see EOS_RTC_GetAudioInterface
 */

/**
 * Use this function to push a new audio buffer to be sent to the participants of a room.
 *
 * This should only be used if Manual Audio Input was enabled locally for the specified room.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the buffer was successfully queued for sending
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if the specified room was not found
 *         EOS_InvalidState if manual recording was not enabled when joining the room.
 * @see EOS_RTC_JoinRoomOptions
 * @see EOS_Lobby_LocalRTCOptions
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_SendAudio(EOS_HRTCAudio Handle, const EOS_RTCAudio_SendAudioOptions* Options);

/**
 * Use this function to tweak outgoing audio options for a room.
 *
 * @note Due to internal implementation details, this function requires that you first register to any notification for room
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if the local user is not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_UpdateSending(EOS_HRTCAudio Handle, const EOS_RTCAudio_UpdateSendingOptions* Options, void* ClientData, const EOS_RTCAudio_OnUpdateSendingCallback CompletionDelegate);

/**
 * Use this function to tweak incoming audio options for a room.
 *
 * @note Due to internal implementation details, this function requires that you first register to any notification for room
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if either the local user or specified participant are not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_UpdateReceiving(EOS_HRTCAudio Handle, const EOS_RTCAudio_UpdateReceivingOptions* Options, void* ClientData, const EOS_RTCAudio_OnUpdateReceivingCallback CompletionDelegate);

/**
 * Use this function to change outgoing audio volume for a room.
 *
 * @note Due to internal implementation details, this function requires that you first register to any notification for room
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if the local user is not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_UpdateSendingVolume(EOS_HRTCAudio Handle, const EOS_RTCAudio_UpdateSendingVolumeOptions* Options, void* ClientData, const EOS_RTCAudio_OnUpdateSendingVolumeCallback CompletionDelegate);

/**
 * Use this function to change incoming audio volume for a room.
 *
 * @note Due to internal implementation details, this function requires that you first register to any notification for room
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or on error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if the local user is not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_UpdateReceivingVolume(EOS_HRTCAudio Handle, const EOS_RTCAudio_UpdateReceivingVolumeOptions* Options, void* ClientData, const EOS_RTCAudio_OnUpdateReceivingVolumeCallback CompletionDelegate);

/**
 * Use this function to change participant audio volume for a room.
 *
 * @note Due to internal implementation details, this function requires that you first register to any notification for room
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if either the local user or specified participant are not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_UpdateParticipantVolume(EOS_HRTCAudio Handle, const EOS_RTCAudio_UpdateParticipantVolumeOptions* Options, void* ClientData, const EOS_RTCAudio_OnUpdateParticipantVolumeCallback CompletionDelegate);

/**
 * Register to receive notifications when a room participant audio status is updated (f.e when mute state changes or speaking flag changes).
 *
 * The notification is raised when the participant's audio status is updated. In order not to miss any participant status changes, applications need to add the notification before joining a room.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyParticipantUpdated when you no longer wish
 * to have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a participant changes audio status
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyParticipantUpdated
 * @see EOS_RTCAudio_ParticipantUpdatedCallbackInfo
 * @see EOS_ERTCAudioStatus
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyParticipantUpdated(EOS_HRTCAudio Handle, const EOS_RTCAudio_AddNotifyParticipantUpdatedOptions* Options, void* ClientData, const EOS_RTCAudio_OnParticipantUpdatedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving participant updated notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyParticipantUpdated(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when an audio device is added or removed to the system.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioDevicesChanged when you no longer wish
 * to have your CompletionDelegate called.
 *
 * The library will try to use user selected audio device while following these rules:
 * - if none of the audio devices has been available and connected before - the library will try to use it;
 * - if user selected device failed for some reason, default device will be used instead (and user selected device will be memorized);
 * - if user selected a device but it was not used for some reason (and default was used instead), when devices selection is triggered we will try to use user selected device again;
 * - triggers to change a device: when new audio device appears or disappears - library will try to use previously user selected;
 * - if for any reason, a device cannot be used - the library will fallback to using default;
 * - if a configuration of the current audio device has been changed, it will be restarted.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when an audio device change occurs
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioDevicesChanged
 * @see EOS_RTCAudio_SetAudioInputSettingsOptions
 * @see EOS_RTCAudio_SetAudioOutputSettingsOptions
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioDevicesChanged(EOS_HRTCAudio Handle, const EOS_RTCAudio_AddNotifyAudioDevicesChangedOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioDevicesChangedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving audio devices notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioDevicesChanged(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when audio input state changed.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioInputState when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when audio input state changes
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioInputState
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioInputState(EOS_HRTCAudio Handle, const EOS_RTCAudio_AddNotifyAudioInputStateOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioInputStateCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving notifications on audio input state changed.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioInputState(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when audio output state changed.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioOutputState when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when audio output state changes
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioOutputState
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioOutputState(EOS_HRTCAudio Handle, const EOS_RTCAudio_AddNotifyAudioOutputStateOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioOutputStateCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving notifications on audio output state changed.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioOutputState(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications when local audio buffers are about to be encoded and sent.
 *
 * This gives you access to the audio data about to be sent, allowing for example the implementation of custom filters/effects.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioBeforeSend when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @note The CompletionDelegate may be called from a thread other than the one from which the SDK is ticking.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when local audio buffers are about to be encoded and sent
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioBeforeSend
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioBeforeSend(EOS_HRTCAudio Handle, const EOS_RTCAudio_AddNotifyAudioBeforeSendOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioBeforeSendCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving local audio buffers before they are encoded and sent.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioBeforeSend(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Register to receive notifications with remote audio buffers before they are rendered.
 *
 * This gives you access to the audio data received, allowing for example the implementation of custom filters/effects.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCAudio_RemoveNotifyAudioBeforeRender when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @note The CompletionDelegate may be called from a thread other than the one from which the SDK is ticking.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when remote audio buffers are about to be rendered
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCAudio_RemoveNotifyAudioBeforeRender
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCAudio_AddNotifyAudioBeforeRender(EOS_HRTCAudio Handle, const EOS_RTCAudio_AddNotifyAudioBeforeRenderOptions* Options, void* ClientData, const EOS_RTCAudio_OnAudioBeforeRenderCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving remote audio buffers before they are rendered.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RemoveNotifyAudioBeforeRender(EOS_HRTCAudio Handle, EOS_NotificationId NotificationId);

/**
 * Use this function to inform the audio system of a user.
 *
 * This function is only necessary for some platforms.
 *
 * @param Options structure containing the parameters for the operation
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the user was successfully registered
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_UnexpectedError otherwise
 *
 * @see EOS_RTCAudio_UnregisterPlatformUser
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_RegisterPlatformUser(EOS_HRTCAudio Handle, const EOS_RTCAudio_RegisterPlatformUserOptions* Options, void* ClientData, const EOS_RTCAudio_OnRegisterPlatformUserCallback CompletionDelegate);

/**
 * Use this function to remove a user that was added with EOS_RTCAudio_RegisterPlatformUser.
 *
 * This function is only necessary for some platforms.
 *
 * @param Options structure containing the parameters for the operation
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the user was successfully unregistered
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_UnexpectedError otherwise
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_UnregisterPlatformUser(EOS_HRTCAudio Handle, const EOS_RTCAudio_UnregisterPlatformUserOptions* Options, void* ClientData, const EOS_RTCAudio_OnUnregisterPlatformUserCallback CompletionDelegate);

/**
 * Query for a list of audio input devices available in the system together with their specifications.
 *
 * @param Options structure containing the parameters for the operation
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_QueryInputDevicesInformation(EOS_HRTCAudio Handle, const EOS_RTCAudio_QueryInputDevicesInformationOptions* Options, void* ClientData, const EOS_RTCAudio_OnQueryInputDevicesInformationCallback CompletionDelegate);

/**
 * Fetch the number of audio input devices available in the system that are cached locally.
 *
 * The returned value should not be cached and should instead be used immediately with
 * the EOS_RTCAudio_CopyInputDeviceInformationByIndex function.
 *
 * @param Options structure containing the parameters for the operation
 * @return The number of audio input devices available in the system or 0 if there is an error
 *
 * @see EOS_RTCAudio_CopyInputDeviceInformationByIndex
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(uint32_t) EOS_RTCAudio_GetInputDevicesCount(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetInputDevicesCountOptions* Options);

/**
 * Fetches an audio input device's information from then given index that are cached locally.
 *
 * @param Options structure containing the index being accessed
 * @param OutInputDeviceInformation The audio input device's information for the given index, if it exists and is valid, use EOS_RTCAudio_InputDeviceInformation_Release when finished
 * @return EOS_Success if the information is available and passed out in OutInputDeviceInformation
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the audio input device's information is not found
 *
 * @see EOS_RTCAudio_InputDeviceInformation_Release
 * @see EOS_RTCAudio_GetAudioInputDevicesCount
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_CopyInputDeviceInformationByIndex(EOS_HRTCAudio Handle, const EOS_RTCAudio_CopyInputDeviceInformationByIndexOptions* Options, EOS_RTCAudio_InputDeviceInformation ** OutInputDeviceInformation);

/**
 * Query for a list of audio output devices available in the system together with their specifications.
 *
 * @param Options structure containing the parameters for the operation
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_QueryOutputDevicesInformation(EOS_HRTCAudio Handle, const EOS_RTCAudio_QueryOutputDevicesInformationOptions* Options, void* ClientData, const EOS_RTCAudio_OnQueryOutputDevicesInformationCallback CompletionDelegate);

/**
 * Fetch the number of audio output devices available in the system that are cached locally.
 *
 * The returned value should not be cached and should instead be used immediately with
 * the EOS_RTCAudio_CopyOutputDeviceInformationByIndex function.
 *
 * @param Options structure containing the parameters for the operation
 * @return The number of audio output devices available in the system or 0 if there is an error
 *
 * @see EOS_RTCAudio_CopyOutputDeviceInformationByIndex
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(uint32_t) EOS_RTCAudio_GetOutputDevicesCount(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetOutputDevicesCountOptions* Options);

/**
 * Fetches an audio output device's information from then given index that are cached locally.
 *
 * @param Options structure containing the index being accessed
 * @param OutOutputDeviceInformation The audio output device's information for the given index, if it exists and is valid, use EOS_RTCAudio_OutputDeviceInformation_Release when finished
 * @return EOS_Success if the information is available and passed out in OutOutputDeviceInformation
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the audio output device's information is not found
 *
 * @see EOS_RTCAudio_OutputDeviceInformation_Release
 * @see EOS_RTCAudio_GetAudioOutputDevicesCount
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_CopyOutputDeviceInformationByIndex(EOS_HRTCAudio Handle, const EOS_RTCAudio_CopyOutputDeviceInformationByIndexOptions* Options, EOS_RTCAudio_OutputDeviceInformation ** OutOutputDeviceInformation);

/**
 * Use this function to set audio input device settings, such as the active input device, or platform AEC.
 *
 * @param Options structure containing the parameters for the operation
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the setting was successful
 *         EOS_InvalidParameters if any of the parameters are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_SetInputDeviceSettings(EOS_HRTCAudio Handle, const EOS_RTCAudio_SetInputDeviceSettingsOptions* Options, void* ClientData, const EOS_RTCAudio_OnSetInputDeviceSettingsCallback CompletionDelegate);

/**
 * Use this function to set audio output device settings, such as the active output device.
 *
 * @param Options structure containing the parameters for the operation
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the setting was successful
 *         EOS_InvalidParameters if any of the parameters are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_SetOutputDeviceSettings(EOS_HRTCAudio Handle, const EOS_RTCAudio_SetOutputDeviceSettingsOptions* Options, void* ClientData, const EOS_RTCAudio_OnSetOutputDeviceSettingsCallback CompletionDelegate);

/**
 * DEPRECATED! Use EOS_RTCAudio_RegisterPlatformUser instead.
 *
 * Use this function to inform the audio system of a user.
 *
 * This function is only necessary for some platforms.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the user was successfully registered, EOS_UnexpectedError otherwise.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_RegisterPlatformAudioUser(EOS_HRTCAudio Handle, const EOS_RTCAudio_RegisterPlatformAudioUserOptions* Options);

/**
 * DEPRECATED! Use EOS_RTCAudio_UnregisterPlatformUser instead.
 *
 * Use this function to remove a user that was added with EOS_RTCAudio_RegisterPlatformAudioUser.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the user was successfully unregistered, EOS_UnexpectedError otherwise.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_UnregisterPlatformAudioUser(EOS_HRTCAudio Handle, const EOS_RTCAudio_UnregisterPlatformAudioUserOptions* Options);

/**
 * DEPRECATED! Use EOS_RTCAudio_QueryInputDevicesInformation, EOS_RTCAudio_GetInputDevicesCount instead.
 *
 * Returns the number of audio input devices available in the system.
 *
 * The returned value should not be cached and should instead be used immediately with the EOS_RTCAudio_GetAudioInputDeviceByIndex
 * function.
 *
 * @param Options structure containing the parameters for the operation
 * @return The number of audio input devices
 * @see EOS_RTCAudio_GetAudioInputDeviceByIndex
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(uint32_t) EOS_RTCAudio_GetAudioInputDevicesCount(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetAudioInputDevicesCountOptions* Options);

/**
 * DEPRECATED! Use EOS_RTCAudio_QueryInputDevicesInformation, EOS_RTCAudio_CopyInputDeviceInformationByIndex instead.
 *
 * Fetches an audio input device's info from then given index. The returned value should not be cached and important
 * information should be copied off of the result object immediately.
 *
 * @param Options structure containing the index being accessed
 * @return A pointer to the device information, or NULL on error. You should NOT keep hold of this pointer.
 * @see EOS_RTCAudio_GetAudioInputDevicesCount
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(const EOS_RTCAudio_AudioInputDeviceInfo *) EOS_RTCAudio_GetAudioInputDeviceByIndex(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetAudioInputDeviceByIndexOptions* Options);

/**
 * DEPRECATED! Use EOS_RTCAudio_QueryOutputDevicesInformation, EOS_RTCAudio_GetOutputDevicesCount instead.
 *
 * Returns the number of audio output devices available in the system.
 *
 * The returned value should not be cached and should instead be used immediately with the EOS_RTCAudio_GetAudioOutputDeviceByIndex
 * function.
 *
 * @param Options structure containing the parameters for the operation
 * @return The number of audio output devices
 * @see EOS_RTCAudio_GetAudioOutputDeviceByIndex
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(uint32_t) EOS_RTCAudio_GetAudioOutputDevicesCount(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetAudioOutputDevicesCountOptions* Options);

/**
 * DEPRECATED! Use EOS_RTCAudio_QueryOutputDevicesInformation, EOS_RTCAudio_CopyOutputDeviceInformationByIndex instead.
 *
 * Fetches an audio output device's info from then given index.
 *
 * The returned value should not be cached and important information should be copied off of the result object immediately.
 *
 * @param Options structure containing the index being accessed
 * @return A pointer to the device information, or NULL on error. You should NOT keep hold of this pointer.
 * @see EOS_RTCAudio_GetAudioOutputDevicesCount
 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
 */
EOS_DECLARE_FUNC(const EOS_RTCAudio_AudioOutputDeviceInfo *) EOS_RTCAudio_GetAudioOutputDeviceByIndex(EOS_HRTCAudio Handle, const EOS_RTCAudio_GetAudioOutputDeviceByIndexOptions* Options);

/**
 * DEPRECATED! Use EOS_RTCAudio_SetInputDeviceSettings instead.
 *
 * Use this function to set audio input settings, such as the active input device, volume, or platform AEC.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the setting was successful
 *         EOS_InvalidParameters if any of the parameters are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_SetAudioInputSettings(EOS_HRTCAudio Handle, const EOS_RTCAudio_SetAudioInputSettingsOptions* Options);

/**
 * DEPRECATED! Use EOS_RTCAudio_SetOutputDeviceSettings instead.
 *
 * Use this function to set audio output settings, such as the active output device or volume.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success if the setting was successful
 *         EOS_InvalidParameters if any of the parameters are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCAudio_SetAudioOutputSettings(EOS_HRTCAudio Handle, const EOS_RTCAudio_SetAudioOutputSettingsOptions* Options);

```

`EAC_SDK/SDK/include/eos_rtc_audio_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_RTCAudioHandle* EOS_HRTCAudio;

/**
 * An enumeration of the different audio channel statuses.
 */
EOS_ENUM(EOS_ERTCAudioStatus,
	/** Audio unsupported by the source (no devices) */
	EOS_RTCAS_Unsupported = 0,
	/** Audio enabled */
	EOS_RTCAS_Enabled = 1,
	/** Audio disabled */
	EOS_RTCAS_Disabled = 2,
	/** Audio disabled by the administrator */
	EOS_RTCAS_AdminDisabled = 3,
	/** Audio channel is disabled temporarily for both sending and receiving */
	EOS_RTCAS_NotListeningDisabled = 4
);

/** The most recent version of the EOS_RTCAudio_AddNotifyParticipantUpdated API. */
#define EOS_RTCAUDIO_ADDNOTIFYPARTICIPANTUPDATED_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyParticipantUpdated.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyParticipantUpdatedOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYPARTICIPANTUPDATED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyParticipantUpdated registered event.
 */
EOS_STRUCT(EOS_RTCAudio_ParticipantUpdatedCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyParticipantUpdated. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The participant updated. */
	EOS_ProductUserId ParticipantId;
	/** The participant speaking / non-speaking status. */
	EOS_Bool bSpeaking;
	/** The participant audio status (enabled, disabled). */
	EOS_ERTCAudioStatus AudioStatus;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnParticipantUpdatedCallback, const EOS_RTCAudio_ParticipantUpdatedCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioDevicesChanged API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIODEVICESCHANGED_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioDevicesChanged.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioDevicesChangedOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIODEVICESCHANGED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioDevicesChanged registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioDevicesChangedCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioDevicesChanged. */
	void* ClientData;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioDevicesChangedCallback, const EOS_RTCAudio_AudioDevicesChangedCallbackInfo* Data);

/**
 * An enumeration of the different audio input device statuses.
 */
EOS_ENUM(EOS_ERTCAudioInputStatus,
	/** The device is not in use right now (e.g., you are alone in the room). In such cases, the hardware resources are not allocated. */
	EOS_RTCAIS_Idle = 0,
	/** The device is being used and capturing audio. */
	EOS_RTCAIS_Recording = 1,
	/**
	 * The SDK is in a recording state, but actually capturing silence because the device is exclusively being used by the platform at the moment.
	 * This only applies to certain platforms.
	 */
	EOS_RTCAIS_RecordingSilent = 2,
	/**
	 * The SDK is in a recording state, but actually capturing silence because the device is disconnected (e.g., the microphone is not plugged in).
	 * This only applies to certain platforms.
	 */
	EOS_RTCAIS_RecordingDisconnected = 3,
	/** Something failed while trying to use the device. */
	EOS_RTCAIS_Failed = 4
);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioInputState API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIOINPUTSTATE_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioInputState.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioInputStateOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIOINPUTSTATE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioInputState registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioInputStateCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioInputState. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The status of the audio input. */
	EOS_ERTCAudioInputStatus Status;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioInputStateCallback, const EOS_RTCAudio_AudioInputStateCallbackInfo* Data);

/**
 * An enumeration of the different audio output device statuses.
 */
EOS_ENUM(EOS_ERTCAudioOutputStatus,
	/** The device is not in used right now (e.g: you are alone in the room). In such cases, the hardware resources are not allocated. */
	EOS_RTCAOS_Idle = 0,
	/** Device is in use */
	EOS_RTCAOS_Playing = 1,
	/** Something failed while trying to use the device */
	EOS_RTCAOS_Failed = 2
);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioOutputState API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIOOUTPUTSTATE_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioOutputState.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioOutputStateOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIOOUTPUTSTATE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioOutputState registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioOutputStateCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioOutputState. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The status of the audio output. */
	EOS_ERTCAudioOutputStatus Status;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioOutputStateCallback, const EOS_RTCAudio_AudioOutputStateCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioBeforeSend API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIOBEFORESEND_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioBeforeSend.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioBeforeSendOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIOBEFORESEND_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
));


/** The most recent version of the EOS_RTCAudio_AudioBuffer API */
#define EOS_RTCAUDIO_AUDIOBUFFER_API_LATEST 1

/**
 * This struct is used to represent an audio buffer received in callbacks from EOS_RTCAudio_AddNotifyAudioBeforeSend and EOS_RTCAudio_AddNotifyAudioBeforeRender.
 */
EOS_STRUCT(EOS_RTCAudio_AudioBuffer, (
	/** API Version: Set this to EOS_RTCAUDIO_AUDIOBUFFER_API_LATEST. */
	int32_t ApiVersion;
	/** Pointer to the data with the interleaved audio frames in signed 16 bits format. */
	int16_t* Frames;
	/**
	 * Number of frames available in the Frames buffer.
	 * @note This is the number of frames in a channel, not the total number of frames in the buffer.
	 */
	uint32_t FramesCount;
	/** Sample rate for the samples in the Frames buffer. */
	uint32_t SampleRate;
	/** Number of channels for the samples in the Frames buffer. */
	uint32_t Channels;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioBeforeSend registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioBeforeSendCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioBeforeSend. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** Audio buffer. */
	EOS_RTCAudio_AudioBuffer* Buffer;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioBeforeSendCallback, const EOS_RTCAudio_AudioBeforeSendCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_AddNotifyAudioBeforeRender API. */
#define EOS_RTCAUDIO_ADDNOTIFYAUDIOBEFORERENDER_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_AddNotifyAudioBeforeRender.
 */
EOS_STRUCT(EOS_RTCAudio_AddNotifyAudioBeforeRenderOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_ADDNOTIFYAUDIOBEFORERENDER_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
	/**
	 * Mixed audio or unmixed audio.
	 */
	EOS_Bool bUnmixedAudio;
));


/**
 * This struct is passed in with a call to EOS_RTCAudio_AddNotifyAudioBeforeRender registered event.
 */
EOS_STRUCT(EOS_RTCAudio_AudioBeforeRenderCallbackInfo, (
	/** Client-specified data passed into EOS_RTCAudio_AddNotifyAudioBeforeRender. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/**
	 * Audio buffer.
	 */
	EOS_RTCAudio_AudioBuffer* Buffer;
	/**
	 * The Product User ID of the participant if bUnmixedAudio was set to true when setting the notifications, or empty if
	 * bUnmixedAudio was set to false and thus the buffer is the mixed audio of all participants
	 */
	EOS_ProductUserId ParticipantId;
));

EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnAudioBeforeRenderCallback, const EOS_RTCAudio_AudioBeforeRenderCallbackInfo* Data);


/** The most recent version of the EOS_RTCAudio_SendAudio API. */
#define EOS_RTCAUDIO_SENDAUDIO_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_SendAudio.
 */
EOS_STRUCT(EOS_RTCAudio_SendAudioOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_SENDAUDIO_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
	/**
	 * Audio buffer, which must have a duration of 10 ms.
	 * @note The SDK makes a copy of buffer. There is no need to keep the buffer around after calling EOS_RTCAudio_SendAudio
	 */
	EOS_RTCAudio_AudioBuffer* Buffer;
));

/** The most recent version of the EOS_RTCAudio_UpdateSending API. */
#define EOS_RTCAUDIO_UPDATESENDING_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_UpdateSending
 */
EOS_STRUCT(EOS_RTCAudio_UpdateSendingOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UPDATESENDING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** Muted or unmuted audio track status */
	EOS_ERTCAudioStatus AudioStatus;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnUpdateSendingCallback.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateSendingCallbackInfo, (
	/** This returns:
	 * EOS_Success if sending of channels of the local user was successfully enabled/disabled.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_UpdateSending. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** Muted or unmuted audio track status */
	EOS_ERTCAudioStatus AudioStatus;
));

/**
 * Callback for completion of update sending request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnUpdateSendingCallback, const EOS_RTCAudio_UpdateSendingCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_UpdateReceiving API. */
#define EOS_RTCAUDIO_UPDATERECEIVING_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_UpdateReceiving.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateReceivingOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UPDATERECEIVING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The participant to modify or null to update the global configuration */
	EOS_ProductUserId ParticipantId;
	/** Mute or unmute audio track */
	EOS_Bool bAudioEnabled;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnUpdateReceivingCallback.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateReceivingCallbackInfo, (
	/** This returns:
	 * EOS_Success if receiving of channels of remote users was successfully enabled/disabled.
     * EOS_NotFound if the participant isn't found by ParticipantId.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_UpdateReceiving. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The participant to modify or null to update the global configuration */
	EOS_ProductUserId ParticipantId;
	/** Muted or unmuted audio track */
	EOS_Bool bAudioEnabled;
));

/**
 * Callback for completion of update receiving request
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnUpdateReceivingCallback, const EOS_RTCAudio_UpdateReceivingCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_UpdateSendingVolume API. */
#define EOS_RTCAUDIO_UPDATESENDINGVOLUME_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_UpdateSendingVolume
 */
EOS_STRUCT(EOS_RTCAudio_UpdateSendingVolumeOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UPDATESENDINGVOLUME_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The volume to be set for sent audio (range 0.0 to 100.0). Volume 50 means that the audio volume is not modified
	 * and stays in its source value. */
	float Volume;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnUpdateSendingVolumeCallback.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateSendingVolumeCallbackInfo, (
	/** This returns:
	 * EOS_Success if sending volume of channels of the local user was successfully changed.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_UpdateSendingVolume. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The volume that was set for sent audio (range 0.0 to 100.0). */
	float Volume;
));

/**
 * Callback for completion of update sending volume request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnUpdateSendingVolumeCallback, const EOS_RTCAudio_UpdateSendingVolumeCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_UpdateReceivingVolume API. */
#define EOS_RTCAUDIO_UPDATERECEIVINGVOLUME_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_UpdateReceivingVolume
 */
EOS_STRUCT(EOS_RTCAudio_UpdateReceivingVolumeOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UPDATERECEIVINGVOLUME_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The volume to be set for received audio (range 0.0 to 100.0). Volume 50 means that the audio volume is not modified
	 * and stays in its source value. */
	float Volume;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnUpdateReceivingVolumeCallback.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateReceivingVolumeCallbackInfo, (
	/** This returns:
	 * EOS_Success if receiving volume of channels of the local user was successfully changed.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_UpdateReceivingVolume. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The volume that was set for received audio (range 0.0 to 100.0). */
	float Volume;
));

/**
 * Callback for completion of update receiving volume request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnUpdateReceivingVolumeCallback, const EOS_RTCAudio_UpdateReceivingVolumeCallbackInfo* Data);


/** The most recent version of the EOS_RTCAudio_UpdateParticipantVolume API. */
#define EOS_RTCAUDIO_UPDATEPARTICIPANTVOLUME_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_UpdateParticipantVolume
 */
EOS_STRUCT(EOS_RTCAudio_UpdateParticipantVolumeOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UPDATEPARTICIPANTVOLUME_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The participant to modify or null to update the global configuration */
	EOS_ProductUserId ParticipantId;
	/** The volume to be set for received audio (range 0.0 to 100.0). Volume 50 means that the audio volume is not modified
	 * and stays in its source value. */
	float Volume;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnUpdateParticipantVolumeCallback.
 */
EOS_STRUCT(EOS_RTCAudio_UpdateParticipantVolumeCallbackInfo, (
	/** This returns:
	 * EOS_Success if volume of remote participant audio was successfully changed.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_UpdateParticipantVolume. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The participant to modify or null to update the global configuration */
	EOS_ProductUserId ParticipantId;
	/** The volume that was set for received audio (range 0.0 to 100.0). */
	float Volume;
));

/**
 * Callback for completion of update participant volume request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnUpdateParticipantVolumeCallback, const EOS_RTCAudio_UpdateParticipantVolumeCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_RegisterPlatformUser API. */
#define EOS_RTCAUDIO_REGISTERPLATFORMUSER_API_LATEST 1

/**
 * This struct is used to inform the audio system of a user.
 */
EOS_STRUCT(EOS_RTCAudio_RegisterPlatformUserOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_REGISTERPLATFORMUSER_API_LATEST. */
	int32_t ApiVersion;
	/** Platform dependent user id. */
	const char* PlatformUserId;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnRegisterPlatformUserCallback.
 */
EOS_STRUCT(EOS_RTCAudio_OnRegisterPlatformUserCallbackInfo, (
	/** This returns:
	 * EOS_Success if the user was successfully registered.
	 * EOS_InvalidParameters if any of the parameters are incorrect.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_RegisterPlatformUser. */
	void* ClientData;
	/** Platform dependent user id. */
	const char* PlatformUserId;
));

/**
 * Callback for completion of register platform user request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnRegisterPlatformUserCallback, const EOS_RTCAudio_OnRegisterPlatformUserCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_UnregisterPlatformUser API. */
#define EOS_RTCAUDIO_UNREGISTERPLATFORMUSER_API_LATEST 1

/**
 * This struct is used to remove a user from the audio system.
 */
EOS_STRUCT(EOS_RTCAudio_UnregisterPlatformUserOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UNREGISTERPLATFORMUSER_API_LATEST. */
	int32_t ApiVersion;
	/** The account of a user associated with this event. */
	const char* PlatformUserId;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnUnregisterPlatformUserCallback.
 */
EOS_STRUCT(EOS_RTCAudio_OnUnregisterPlatformUserCallbackInfo, (
	/** This returns:
	 * EOS_Success if the user was successfully unregistered.
	 * EOS_InvalidParameters if any of the parameters are incorrect.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_UnregisterPlatformUser. */
	void* ClientData;
	/** Platform dependent user id. */
	const char* PlatformUserId;
));

/**
 * Callback for completion of unregister platform user request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnUnregisterPlatformUserCallback, const EOS_RTCAudio_OnUnregisterPlatformUserCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_QueryInputDevicesInformation API. */
#define EOS_RTCAUDIO_QUERYINPUTDEVICESINFORMATION_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_QueryInputDevicesInformation.
 */
EOS_STRUCT(EOS_RTCAudio_QueryInputDevicesInformationOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_QUERYINPUTDEVICESINFORMATION_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnQueryInputDevicesInformationCallback.
 */
EOS_STRUCT(EOS_RTCAudio_OnQueryInputDevicesInformationCallbackInfo, (
	/** This returns:
	 * EOS_Success if the operation succeeded.
	 * EOS_InvalidParameters if any of the parameters are incorrect.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_QueryInputDevicesInformation. */
	void* ClientData;
));

/**
 * Callback for completion of query input devices information request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnQueryInputDevicesInformationCallback, const EOS_RTCAudio_OnQueryInputDevicesInformationCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_GetInputDevicesCount API. */
#define EOS_RTCAUDIO_GETINPUTDEVICESCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetInputDevicesCount function.
 */
EOS_STRUCT(EOS_RTCAudio_GetInputDevicesCountOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETINPUTDEVICESCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_RTCAudio_CopyInputDeviceInformationByIndex API. */
#define EOS_RTCAUDIO_COPYINPUTDEVICEINFORMATIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_CopyInputDeviceInformationByIndex function.
 */
EOS_STRUCT(EOS_RTCAudio_CopyInputDeviceInformationByIndexOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_COPYINPUTDEVICEINFORMATIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the audio input device's information to retrieve. */
	uint32_t DeviceIndex;
));

/** The most recent version of the EOS_RTCAudio_InputDeviceInformation struct. */
#define EOS_RTCAUDIO_INPUTDEVICEINFORMATION_API_LATEST 1

/**
 * This struct is used to get information about a specific audio input device.
 */
EOS_STRUCT(EOS_RTCAudio_InputDeviceInformation, (
	/** API Version: Set this to EOS_RTCAUDIO_INPUTDEVICEINFORMATION_API_LATEST. */
	int32_t ApiVersion;
	/** True if this is the default audio input device in the system. */
	EOS_Bool bDefaultDevice;
	/**
	 * The persistent unique id of the audio input device.
	 * The value can be cached - invalidated only when the audio device pool is changed.
	 *
	 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
	 */
	const char* DeviceId;
	/** Human-readable name of the audio input device */
	const char* DeviceName;
));

/**
 * Release the memory associated with EOS_RTCAudio_InputDeviceInformation. This must be called on data retrieved from
 * EOS_RTCAudio_CopyInputDeviceInformationByIndex.
 *
 * @param DeviceInformation - The audio input device's information to release.
 *
 * @see EOS_RTCAudio_InputDeviceInformation
 * @see EOS_RTCAudio_CopyInputDeviceInformationByIndex
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_InputDeviceInformation_Release(EOS_RTCAudio_InputDeviceInformation* DeviceInformation);

/** The most recent version of the EOS_RTCAudio_QueryOutputDevicesInformation API. */
#define EOS_RTCAUDIO_QUERYOUTPUTDEVICESINFORMATION_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCAudio_QueryOutputDevicesInformation.
 */
EOS_STRUCT(EOS_RTCAudio_QueryOutputDevicesInformationOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_QUERYOUTPUTDEVICESINFORMATION_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnQueryOutputDevicesInformationCallback.
 */
EOS_STRUCT(EOS_RTCAudio_OnQueryOutputDevicesInformationCallbackInfo, (
	/** This returns:
	 * EOS_Success if the operation succeeded.
	 * EOS_InvalidParameters if any of the parameters are incorrect.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_QueryOutputDevicesInformation. */
	void* ClientData;
));

/**
 * Callback for completion of query output devices information request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnQueryOutputDevicesInformationCallback, const EOS_RTCAudio_OnQueryOutputDevicesInformationCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_GetOutputDevicesCount API. */
#define EOS_RTCAUDIO_GETOUTPUTDEVICESCOUNT_API_LATEST 1

/**
 * Output parameters for the EOS_RTCAudio_GetOutputDevicesCount function.
 */
EOS_STRUCT(EOS_RTCAudio_GetOutputDevicesCountOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETOUTPUTDEVICESCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_RTCAudio_CopyOutputDeviceInformationByIndex API. */
#define EOS_RTCAUDIO_COPYOUTPUTDEVICEINFORMATIONBYINDEX_API_LATEST 1

/**
 * Output parameters for the EOS_RTCAudio_CopyOutputDeviceInformationByIndex function.
 */
EOS_STRUCT(EOS_RTCAudio_CopyOutputDeviceInformationByIndexOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_COPYOUTPUTDEVICEINFORMATIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the audio output device's information to retrieve. */
	uint32_t DeviceIndex;
));

/** The most recent version of the EOS_RTCAudio_OutputDeviceInformation struct. */
#define EOS_RTCAUDIO_OUTPUTDEVICEINFORMATION_API_LATEST 1

/**
 * This struct is used to get information about a specific audio output device.
 */
EOS_STRUCT(EOS_RTCAudio_OutputDeviceInformation, (
	/** API Version: Set this to EOS_RTCAUDIO_OUTPUTDEVICEINFORMATION_API_LATEST. */
	int32_t ApiVersion;
	/** True if this is the default audio output device in the system. */
	EOS_Bool bDefaultDevice;
	/**
	 * The persistent unique id of the audio output device.
	 * The value can be cached - invalidated only when the audio device pool is changed.
	 *
	 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
	 */
	const char* DeviceId;
	/** Human-readable name of the audio output device */
	const char* DeviceName;
));

/**
 * Release the memory associated with EOS_RTCAudio_OutputDeviceInformation. This must be called on data retrieved from
 * EOS_RTCAudio_CopyOutputDeviceInformationByIndex.
 *
 * @param DeviceInformation - The audio output device's information to release.
 *
 * @see EOS_RTCAudio_OutputDeviceInformation
 * @see EOS_RTCAudio_CopyOutputDeviceInformationByIndex
 */
EOS_DECLARE_FUNC(void) EOS_RTCAudio_OutputDeviceInformation_Release(EOS_RTCAudio_OutputDeviceInformation* DeviceInformation);

/** The most recent version of the EOS_RTCAudio_SetInputDeviceSettings API. */
#define EOS_RTCAUDIO_SETINPUTDEVICESETTINGS_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_SetInputDeviceSettings.
 */
EOS_STRUCT(EOS_RTCAudio_SetInputDeviceSettingsOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_SETINPUTDEVICESETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/**
	 * The device Id to be used for this user. Pass NULL or empty string to use a default input device.
	 *
	 * If the device ID is invalid, the default device will be used instead.
	 * Despite this fact, that device ID will be stored and the library will try to move on it when an audio device pool is being changed.
	 *
	 * The actual hardware audio input device usage depends on the current payload and optimized not to use it
	 * when generated audio frames cannot be processed by someone else based on a scope of rules (For instance, when a client is alone in a room).
	 *
	 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
	 */
	const char* RealDeviceId;
	/** Enable or disable Platform AEC (Acoustic Echo Cancellation) if available. */
	EOS_Bool bPlatformAEC;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnSetInputDeviceSettingsCallback.
 */
EOS_STRUCT(EOS_RTCAudio_OnSetInputDeviceSettingsCallbackInfo, (
	/** This returns:
	 * EOS_Success if the operation succeeded.
	 * EOS_InvalidParameters if any of the parameters are incorrect.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_SetInputDeviceSettings. */
	void* ClientData;
	/** Associated audio input device Id. */
	const char* RealDeviceId;
));

/**
 * Callback for completion of set input device settings request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnSetInputDeviceSettingsCallback, const EOS_RTCAudio_OnSetInputDeviceSettingsCallbackInfo* Data);

/** The most recent version of the EOS_RTCAudio_SetOutputDeviceSettings API. */
#define EOS_RTCAUDIO_SETOUTPUTDEVICESETTINGS_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_SetOutputDeviceSettings.
 */
EOS_STRUCT(EOS_RTCAudio_SetOutputDeviceSettingsOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_SETOUTPUTDEVICESETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/**
	 * The device Id to be used for this user. Pass NULL or empty string to use a default output device.
	 *
	 * If the device ID is invalid, the default device will be used instead.
	 * Despite this fact, that device ID will be stored and the library will try to move on it when an audio device pool is being changed.
	 *
	 * The actual hardware audio output device usage depends on the current payload and optimized not to use it
	 * when generated audio frames cannot be processed by someone else based on a scope of rules (For instance, when a client is alone in a room).
	 *
	 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
	 */
	const char* RealDeviceId;
));

/**
 * This struct is passed in with a call to EOS_RTCAudio_OnSetOutputDeviceSettingsCallback.
 */
EOS_STRUCT(EOS_RTCAudio_OnSetOutputDeviceSettingsCallbackInfo, (
	/** This returns:
	 * EOS_Success if the operation succeeded.
	 * EOS_InvalidParameters if any of the parameters are incorrect.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCAudio_SetOutputDeviceSettings. */
	void* ClientData;
	/** Associated audio output device Id. */
	const char* RealDeviceId;
));

/**
 * Callback for completion of set output device settings request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCAudio_OnSetOutputDeviceSettingsCallback, const EOS_RTCAudio_OnSetOutputDeviceSettingsCallbackInfo* Data);

#pragma pack(pop)

#include "eos_rtc_audio_types_deprecated.inl"

```

`EAC_SDK/SDK/include/eos_rtc_audio_types_deprecated.inl`:

```inl
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

/**
 * This file contains the deprecated types for EOS RTC Audio. In a future version, these types will be removed.
 */

#pragma pack(push, 8)

/** The most recent version of the EOS_RTCAudio_RegisterPlatformAudioUser API. */
#define EOS_RTCAUDIO_REGISTERPLATFORMAUDIOUSER_API_LATEST 1

/**
 * This struct is used to inform the audio system of a user.
 */
EOS_STRUCT(EOS_RTCAudio_RegisterPlatformAudioUserOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_REGISTERPLATFORMAUDIOUSER_API_LATEST. */
	int32_t ApiVersion;
	/** Platform dependent user id. */
	const char* UserId;
));

/** The most recent version of the EOS_RTCAudio_UnregisterPlatformAudioUser API. */
#define EOS_RTCAUDIO_UNREGISTERPLATFORMAUDIOUSER_API_LATEST 1

/**
 * This struct is used to remove a user from the audio system.
 */
EOS_STRUCT(EOS_RTCAudio_UnregisterPlatformAudioUserOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_UNREGISTERPLATFORMAUDIOUSER_API_LATEST. */
	int32_t ApiVersion;
	/** The account of a user associated with this event. */
	const char* UserId;
));

/** The most recent version of the EOS_RTCAudio_GetAudioInputDevicesCount API. */
#define EOS_RTCAUDIO_GETAUDIOINPUTDEVICESCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetAudioInputDevicesCount function.
 */
EOS_STRUCT(EOS_RTCAudio_GetAudioInputDevicesCountOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETAUDIOINPUTDEVICESCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_RTCAudio_GetAudioInputDeviceByIndex API. */
#define EOS_RTCAUDIO_GETAUDIOINPUTDEVICEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetAudioInputDeviceByIndex function.
 */
EOS_STRUCT(EOS_RTCAudio_GetAudioInputDeviceByIndexOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETAUDIOINPUTDEVICEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the device info to retrieve. */
	uint32_t DeviceInfoIndex;
));

/** The most recent version of the EOS_RTCAudio_AudioInputDeviceInfo struct. */
#define EOS_RTCAUDIO_AUDIOINPUTDEVICEINFO_API_LATEST 1

/**
 * This struct is used to get information about a specific input device.
 */
EOS_STRUCT(EOS_RTCAudio_AudioInputDeviceInfo, (
	/** API Version: Set this to EOS_RTCAUDIO_AUDIOINPUTDEVICEINFO_API_LATEST. */
	int32_t ApiVersion;
	/** True if this is the default audio input device in the system. */
	EOS_Bool bDefaultDevice;
	/**
	 * The persistent unique id of the device.
	 * The value can be cached - invalidated only when the audio device pool is changed.
	 *
	 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
	 */
	const char* DeviceId;
	/** Human-readable name of the device */
	const char* DeviceName;
));

/** The most recent version of the EOS_RTCAudio_GetAudioOutputDevicesCount API. */
#define EOS_RTCAUDIO_GETAUDIOOUTPUTDEVICESCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetAudioOutputDevicesCount function.
 */
EOS_STRUCT(EOS_RTCAudio_GetAudioOutputDevicesCountOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETAUDIOOUTPUTDEVICESCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_RTCAudio_GetAudioOutputDeviceByIndex API. */
#define EOS_RTCAUDIO_GETAUDIOOUTPUTDEVICEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_RTCAudio_GetAudioOutputDeviceByIndex function.
 */
EOS_STRUCT(EOS_RTCAudio_GetAudioOutputDeviceByIndexOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_GETAUDIOOUTPUTDEVICEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the device info to retrieve. */
	uint32_t DeviceInfoIndex;
));

/** The most recent version of the EOS_RTCAudio_AudioOutputDeviceInfo struct. */
#define EOS_RTCAUDIO_AUDIOOUTPUTDEVICEINFO_API_LATEST 1

/**
 * This struct is used to get information about a specific output device.
 */
EOS_STRUCT(EOS_RTCAudio_AudioOutputDeviceInfo, (
	/** API Version: Set this to EOS_RTCAUDIO_AUDIOOUTPUTDEVICEINFO_API_LATEST. */
	int32_t ApiVersion;
	/** True if this is the default audio output device in the system. */
	EOS_Bool bDefaultDevice;
	/**
	 * The persistent unique id of the device.
	 * The value can be cached - invalidated only when the audio device pool is changed.
	 *
	 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
	 */
	const char* DeviceId;
	/** The human readable name of the device */
	const char* DeviceName;
));

/** The most recent version of the EOS_RTCAudio_SetAudioInputSettings API. */
#define EOS_RTCAUDIO_SETAUDIOINPUTSETTINGS_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_SetAudioInputSettings.
 */
EOS_STRUCT(EOS_RTCAudio_SetAudioInputSettingsOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_SETAUDIOINPUTSETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/**
	 * The device Id to be used for this user. Pass NULL or empty string to use default input device.
	 *
	 * If the device ID is invalid, the default device will be used instead.
	 * Despite this fact, that device ID will be stored and the library will try to move on it when an audio device pool is being changed.
	 *
	 * The actual hardware audio device usage depends on the current payload and optimized not to use it
	 * when generated audio frames cannot be processed by someone else based on a scope of rules (For instance, when a client is alone in a room).
	 *
	 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
	 */
	const char* DeviceId;
	/**
	 * The volume to be used for all rooms of this user (range 0.0 to 100.0).
	 *
	 * At the moment, the only value that produce any effect is 0.0 (silence). Any other value is ignored and causes no change to the volume.
	 */
	float Volume;
	/** Enable or disable Platform AEC (Acoustic Echo Cancellation) if available. */
	EOS_Bool bPlatformAEC;
));

/** The most recent version of the EOS_RTCAudio_SetAudioOutputSettings API. */
#define EOS_RTCAUDIO_SETAUDIOOUTPUTSETTINGS_API_LATEST 1

/**
 * This struct is used to call EOS_RTCAudio_SetAudioOutputSettings.
 */
EOS_STRUCT(EOS_RTCAudio_SetAudioOutputSettingsOptions, (
	/** API Version: Set this to EOS_RTCAUDIO_SETAUDIOOUTPUTSETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/**
	 * The device Id to be used for this user. Pass NULL or empty string to use default output device.
	 *
	 * If the device ID is invalid, the default device will be used instead.
	 * Despite of this fact, that device ID will be stored and the library will try to move on it when a device pool is being changed.
	 *
	 * The actual hardware audio device usage depends on the current payload and optimized not to use it
	 * when generated audio frames cannot be processed by someone else based on a scope of rules (For instance, when a client is alone in a room).
	 *
	 * @see EOS_RTCAudio_AddNotifyAudioDevicesChanged
	 *
	 */
	const char* DeviceId;
	/**
	 * The volume to be used for all rooms of this user (range 0.0 to 100.0).
	 *
	 * Volume 50.0 means that the audio volume is not modified and stays in its source value.
	 */
	float Volume;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_rtc_data.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_rtc_data_types.h"

/**
 * The RTC Data Interface. This is used to manage Data specific RTC features
 *
 * @see EOS_RTC_GetDataInterface
 */

/**
 * Register to receive notifications with remote data packet received.
 * If the returned NotificationId is valid, you must call EOS_RTCData_RemoveNotifyDataReceived when you no longer wish to
 * have your CompletionDelegate called.
 *
 * @note The CompletionDelegate may be called from a thread other than the one from which the SDK is ticking.
 *
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a data packet is received
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCData_RemoveNotifyDataReceived
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCData_AddNotifyDataReceived(EOS_HRTCData Handle, const EOS_RTCData_AddNotifyDataReceivedOptions* Options, void* ClientData, const EOS_RTCData_OnDataReceivedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving remote data packets.
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCData_RemoveNotifyDataReceived(EOS_HRTCData Handle, EOS_NotificationId NotificationId);

/**
 * Use this function to send a data packet to the rest of participants.
 *
 * @param Options structure containing the parameters for the operation.
 * @return EOS_Success the data packet was queued for sending
 *         EOS_InvalidParameters if any of the options are invalid
 *         EOS_NotFound if the specified room was not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_RTCData_SendData(EOS_HRTCData Handle, const EOS_RTCData_SendDataOptions* Options);

/**
 * Use this function to tweak outgoing data options for a room.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if the local user is not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCData_UpdateSending(EOS_HRTCData Handle, const EOS_RTCData_UpdateSendingOptions* Options, void* ClientData, const EOS_RTCData_OnUpdateSendingCallback CompletionDelegate);

/**
 * Use this function to tweak incoming data options for a room.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when the operation completes, either successfully or in error
 * @return EOS_Success if the operation succeeded
 *         EOS_InvalidParameters if any of the parameters are incorrect
 *         EOS_NotFound if either the local user or specified participant are not in the room
 */
EOS_DECLARE_FUNC(void) EOS_RTCData_UpdateReceiving(EOS_HRTCData Handle, const EOS_RTCData_UpdateReceivingOptions* Options, void* ClientData, const EOS_RTCData_OnUpdateReceivingCallback CompletionDelegate);

/**
 * Register to receive notifications when a room participant data status is updated (f.e when connection state changes).
 *
 * The notification is raised when the participant's data status is updated. In order not to miss any participant status changes, applications need to add the notification before joining a room.
 *
 * If the returned NotificationId is valid, you must call EOS_RTCData_RemoveNotifyParticipantUpdated when you no longer wish
 * to have your CompletionDelegate called.
 *
 * @param Options structure containing the parameters for the operation.
 * @param ClientData Arbitrary data that is passed back in the CompletionDelegate
 * @param CompletionDelegate The callback to be fired when a participant changes data status
 * @return Notification ID representing the registered callback if successful, an invalid NotificationId if not
 *
 * @see EOS_INVALID_NOTIFICATIONID
 * @see EOS_RTCData_RemoveNotifyParticipantUpdated
 * @see EOS_RTCData_ParticipantUpdatedCallbackInfo
 * @see EOS_ERTCDataStatus
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_RTCData_AddNotifyParticipantUpdated(EOS_HRTCData Handle, const EOS_RTCData_AddNotifyParticipantUpdatedOptions* Options, void* ClientData, const EOS_RTCData_OnParticipantUpdatedCallback CompletionDelegate);

/**
 * Unregister a previously bound notification handler from receiving participant updated notifications
 *
 * @param NotificationId The Notification ID representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_RTCData_RemoveNotifyParticipantUpdated(EOS_HRTCData Handle, EOS_NotificationId NotificationId);

```

`EAC_SDK/SDK/include/eos_rtc_data_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_RTCDataHandle* EOS_HRTCData;

/** The maximum length of data chunk in bytes that can be sent and received */
#define EOS_RTCDATA_MAX_PACKET_SIZE 1170

/** The most recent version of the EOS_RTCData_SendData API. */
#define EOS_RTCDATA_SENDDATA_API_LATEST 1

/**
 * An enumeration of the different data channel statuses.
 */
EOS_ENUM(EOS_ERTCDataStatus,
	/** Data unsupported */
	EOS_RTCDS_Unsupported = 0,
	/** Data enabled */
	EOS_RTCDS_Enabled = 1,
	/** Data disabled */
	EOS_RTCDS_Disabled = 2
);

/** The most recent version of the EOS_RTCData_AddNotifyParticipantUpdated API. */
#define EOS_RTCDATA_ADDNOTIFYPARTICIPANTUPDATED_API_LATEST 1

/**
 * This struct is used to call EOS_RTCData_AddNotifyParticipantUpdated.
 */
EOS_STRUCT(EOS_RTCData_AddNotifyParticipantUpdatedOptions, (
	/** API Version: Set this to EOS_RTCDATA_ADDNOTIFYPARTICIPANTUPDATED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTCData_OnParticipantUpdatedCallback registered event.
 */
EOS_STRUCT(EOS_RTCData_ParticipantUpdatedCallbackInfo, (
	/** Client-specified data passed into EOS_RTCData_AddNotifyParticipantUpdated. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The participant updated. */
	EOS_ProductUserId ParticipantId;
	/** The data channel status. */
	EOS_ERTCDataStatus DataStatus;
));

EOS_DECLARE_CALLBACK(EOS_RTCData_OnParticipantUpdatedCallback, const EOS_RTCData_ParticipantUpdatedCallbackInfo* Data);

/**
 * This struct is used to call EOS_RTCData_SendData.
 */
EOS_STRUCT(EOS_RTCData_SendDataOptions, (
	/** API Version: Set this to EOS_RTCDATA_SENDDATA_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
	/** The size of the data to be sent to the other participants. Max value is EOS_RTCDATA_MAX_PACKET_SIZE. */
	uint32_t DataLengthBytes;
	/** The data to be sent to the other participants */
	const void* Data;
));

/** The most recent version of the EOS_RTCData_AddNotifyDataReceived API. */
#define EOS_RTCDATA_ADDNOTIFYDATARECEIVED_API_LATEST 1

/**
 * This struct is used to call EOS_RTCData_AddNotifyDataReceived.
 */
EOS_STRUCT(EOS_RTCData_AddNotifyDataReceivedOptions, (
	/** API Version: Set this to EOS_RTCDATA_ADDNOTIFYDATARECEIVED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The  room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTCData_AddNotifyDataReceived registered event.
 */
EOS_STRUCT(EOS_RTCData_DataReceivedCallbackInfo, (
	/** Client-specified data passed into EOS_RTCData_AddNotifyDataReceived. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The size of the data received. Max value is EOS_RTCDATA_MAX_PACKET_SIZE. */
	uint32_t DataLengthBytes;
	/** The data received. */
	const void* Data;
	/** The Product User ID of the participant which sent the data. */
	EOS_ProductUserId ParticipantId;
));

EOS_DECLARE_CALLBACK(EOS_RTCData_OnDataReceivedCallback, const EOS_RTCData_DataReceivedCallbackInfo* Data);

/** The most recent version of the EOS_RTCData_UpdateSending API. */
#define EOS_RTCDATA_UPDATESENDING_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCData_UpdateSending
 */
EOS_STRUCT(EOS_RTCData_UpdateSendingOptions, (
	/** API Version: Set this to EOS_RTCDATA_UPDATESENDING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** Creates or destroys data channel */
	EOS_Bool bDataEnabled;
));

/**
 * This struct is passed in with a call to EOS_RTCData_OnUpdateSendingCallback.
 */
EOS_STRUCT(EOS_RTCData_UpdateSendingCallbackInfo, (
	/** This returns:
	 * EOS_Success if sending of channels of the local user was successfully enabled/disabled.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCData_UpdateSending. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** Created or destroyed data channel */
	EOS_Bool bDataEnabled;
));

/**
 * Callback for completion of update sending request.
 */
EOS_DECLARE_CALLBACK(EOS_RTCData_OnUpdateSendingCallback, const EOS_RTCData_UpdateSendingCallbackInfo* Data);

/** The most recent version of the EOS_RTCData_UpdateReceiving API. */
#define EOS_RTCDATA_UPDATERECEIVING_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTCData_UpdateReceiving.
 */
EOS_STRUCT(EOS_RTCData_UpdateReceivingOptions, (
	/** API Version: Set this to EOS_RTCDATA_UPDATERECEIVING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The participant to modify or null to update the global configuration */
	EOS_ProductUserId ParticipantId;
	/** Creates or destroys data channel subscription */
	EOS_Bool bDataEnabled;
));

/**
 * This struct is passed in with a call to EOS_RTCData_OnUpdateReceivingCallback.
 */
EOS_STRUCT(EOS_RTCData_UpdateReceivingCallbackInfo, (
	/** This returns:
	 * EOS_Success if receiving of channels of remote users was successfully enabled/disabled.
	 * EOS_NotFound if the participant isn't found by ParticipantId.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTCData_UpdateReceiving. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room this settings should be applied on. */
	const char* RoomName;
	/** The participant to modify or null to update the global configuration */
	EOS_ProductUserId ParticipantId;
	/** Created or destroyed data channel */
	EOS_Bool bDataEnabled;
));

/**
 * Callback for completion of update receiving request
 */
EOS_DECLARE_CALLBACK(EOS_RTCData_OnUpdateReceivingCallback, const EOS_RTCData_UpdateReceivingCallbackInfo* Data);


#pragma pack(pop)


```

`EAC_SDK/SDK/include/eos_rtc_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_RTCHandle* EOS_HRTC;

/** Participant RTC's status change */
EOS_ENUM(EOS_ERTCParticipantStatus,
	/** Participant joined the room */
	EOS_RTCPS_Joined = 0,
	/** Participant left the room */
	EOS_RTCPS_Left = 1
);

/** The most recent version of the EOS_RTC_JoinRoom API. */
#define EOS_RTC_JOINROOM_API_LATEST 1

/**
 * Enables echo mode.
 * This can be used during development to have the server send your voice back to you so you don't need 2 clients to test
 * if voice is being sent and received.
 *
 * @see EOS_RTC_JoinRoomOptions::Flags
 */
#define EOS_RTC_JOINROOMFLAGS_ENABLE_ECHO 0x01


/**
 * Enables the (optional) data channel feature for RTC rooms. This feature allows members of a room to send packets to all
 * members of a room they are in, and automatically receive data packets sent by other players in that room.
 * Data packets sent this way will be automatically relayed by EOS RTC servers to all other members of the room that are listening.
 * It is not currently possible to send packets to only a subset of members of a room chosen by the sender, all members
 * listening will receive the data.
 *
 * @see EOS_RTC_JoinRoomOptions::Flags
 */
#define EOS_RTC_JOINROOMFLAGS_ENABLE_DATACHANNEL 0x04


/**
 * This struct is used to call EOS_RTC_JoinRoom.
 */
EOS_STRUCT(EOS_RTC_JoinRoomOptions, (
	/** API Version: Set this to EOS_RTC_JOINROOM_API_LATEST. */
	int32_t ApiVersion;
	/** The product user id of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room the user would like to join. */
	const char* RoomName;
	/** The room the user would like to join. */
	const char* ClientBaseUrl;
	/** Authorization credential token to join the room. */
	const char* ParticipantToken;
	/** The participant id used to join the room. If set to NULL the LocalUserId will be used instead. */
	EOS_ProductUserId ParticipantId;

	/** Join room flags, e.g. EOS_RTC_JOINROOMFLAGS_ENABLE_ECHO. This is a bitwise-or union of the defined flags. */
	uint32_t Flags;
	/** Enable or disable Manual Audio Input. If manual audio input is enabled audio recording is not started and the audio
	 * buffers must be passed manually using EOS_RTCAudio_SendAudio.
	 */
	EOS_Bool bManualAudioInputEnabled;
	/** Enable or disable Manual Audio Output. If manual audio output is enabled audio rendering is not started and the audio
	 * buffers must be received with EOS_RTCAudio_AddNotifyAudioBeforeRender and rendered manually.
	 */
	EOS_Bool bManualAudioOutputEnabled;
));

#define EOS_RTC_OPTION_KEY_MAXCHARCOUNT 256
#define EOS_RTC_OPTION_VALUE_MAXCHARCOUNT 256

/** The most recent version of the EOS_RTC_Option struct. */
#define EOS_RTC_OPTION_API_LATEST 1

/**
 * This struct is used to get information about a specific option.
 */
EOS_STRUCT(EOS_RTC_Option, (
	/** API Version: Set this to EOS_RTC_OPTION_API_LATEST. */
	int32_t ApiVersion;
	/** The unique key of the option. The max size of the string is EOS_RTC_OPTION_KEY_MAXCHARCOUNT. */
	const char* Key;
	/** The value of the option. The max size of the string is EOS_RTC_OPTION_VALUE_MAXCHARCOUNT. */
	const char* Value;
));

/**
 * This struct is passed in with a call to EOS_RTC_OnJoinRoomCallback.
 */
EOS_STRUCT(EOS_RTC_JoinRoomCallbackInfo, (
	/** This returns:
	 * EOS_Success if the channel was successfully joined.
	 * EOS_NoConnection: unable to connect to RTC servers (retryable).
	 * EOS_InvalidAuth: if the token is invalid (not retryable).
	 * EOS_RTC_TooManyParticipants: if the room cannot accept more participants (not retryable).
	 * EOS_AccessDenied: if the room name belongs to the Lobby voice system (not retryable).
	 * EOS_UnexpectedError otherwise (retryable).
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTC_JoinRoom. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room the user was trying to join. */
	const char* RoomName;
	/** The room option items count. */
	uint32_t RoomOptionsCount;
	/**
	 * The room option items.
	 */
	const EOS_RTC_Option* RoomOptions;
));

/**
 * Callback for completion of room join request.
 */
EOS_DECLARE_CALLBACK(EOS_RTC_OnJoinRoomCallback, const EOS_RTC_JoinRoomCallbackInfo* Data);

/** The most recent version of the EOS_RTC_LeaveRoom API. */
#define EOS_RTC_LEAVEROOM_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_LeaveRoom.
 */
EOS_STRUCT(EOS_RTC_LeaveRoomOptions, (
	/** API Version: Set this to EOS_RTC_LEAVEROOM_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user requesting to leave the room */
	EOS_ProductUserId LocalUserId;
	/** The room to leave. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTC_OnLeaveRoomCallback.
 */
EOS_STRUCT(EOS_RTC_LeaveRoomCallbackInfo, (
	/** This returns:
	 * EOS_Success if the channel was successfully left.
	 * EOS_AccessDenied if the room name belongs to the Lobby voice system.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTC_LeaveRoomOptions. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room the user was trying to leave. */
	const char* RoomName;
));

/**
 * Callback for completion of room leave request.
 */
EOS_DECLARE_CALLBACK(EOS_RTC_OnLeaveRoomCallback, const EOS_RTC_LeaveRoomCallbackInfo* Data);

/** The most recent version of the EOS_RTC_BlockParticipant API. */
#define EOS_RTC_BLOCKPARTICIPANT_API_LATEST 1

/**
 * This struct is passed in with a call to EOS_RTC_BlockParticipant.
 */
EOS_STRUCT(EOS_RTC_BlockParticipantOptions, (
	/** API Version: Set this to EOS_RTC_BLOCKPARTICIPANT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room the users should be blocked on. */
	const char* RoomName;
	/** Product User ID of the participant to block */
	EOS_ProductUserId ParticipantId;
	/** Block or unblock the participant */
	EOS_Bool bBlocked;
));

/**
 * This struct is passed in with a call to EOS_RTC_OnBlockParticipantCallback.
 */
EOS_STRUCT(EOS_RTC_BlockParticipantCallbackInfo, (
	/** This returns:
	 * EOS_Success if the channel was successfully blocked.
	 * EOS_UnexpectedError otherwise.
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTC_BlockParticipant. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room the users should be blocked on. */
	const char* RoomName;
	/** The Product User ID of the participant being blocked */
	EOS_ProductUserId ParticipantId;
	/** The block state that should have been set */
	EOS_Bool bBlocked;
));

/**
 * Callback for completion of block participants request.
 */
EOS_DECLARE_CALLBACK(EOS_RTC_OnBlockParticipantCallback, const EOS_RTC_BlockParticipantCallbackInfo* Data);

/** The most recent version of the EOS_RTC_AddNotifyDisconnected API. */
#define EOS_RTC_ADDNOTIFYDISCONNECTED_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_AddNotifyDisconnected.
 */
EOS_STRUCT(EOS_RTC_AddNotifyDisconnectedOptions, (
	/** API Version: Set this to EOS_RTC_ADDNOTIFYDISCONNECTED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTC_AddNotifyDisconnected registered event.
 */
EOS_STRUCT(EOS_RTC_DisconnectedCallbackInfo, (
	/** This returns:
	 * EOS_Success The room was left cleanly.
	 * EOS_NoConnection: There was a network issue connecting to the server (retryable).
	 * EOS_RTC_UserKicked: The user has been kicked by the server (retryable).
	 * EOS_ServiceFailure: A known error occurred during interaction with the server (retryable).
	 * EOS_UnexpectedError Unexpected error (retryable).
	 */
	EOS_EResult ResultCode;
	/** Client-specified data passed into EOS_RTC_AddNotifyDisconnected. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
));

EOS_DECLARE_CALLBACK(EOS_RTC_OnDisconnectedCallback, const EOS_RTC_DisconnectedCallbackInfo* Data);

#define EOS_RTC_PARTICIPANTMETADATA_KEY_MAXCHARCOUNT 256
#define EOS_RTC_PARTICIPANTMETADATA_VALUE_MAXCHARCOUNT 256

/** The most recent version of the EOS_RTC_ParticipantMetadata struct. */
#define EOS_RTC_PARTICIPANTMETADATA_API_LATEST 1

/**
 * This struct is used to get information about a specific participant metadata item.
 */
EOS_STRUCT(EOS_RTC_ParticipantMetadata, (
	/** API Version: Set this to EOS_RTC_PARTICIPANTMETADATA_API_LATEST. */
	int32_t ApiVersion;
	/** The unique key of this metadata item. The max size of the string is EOS_RTC_PARTICIPANTMETADATA_KEY_MAXCHARCOUNT. */
	const char* Key;
	/** The value of this metadata item. The max size of the string is EOS_RTC_PARTICIPANTMETADATA_VALUE_MAXCHARCOUNT. */
	const char* Value;
));

/** The most recent version of the EOS_RTC_AddNotifyParticipantStatusChanged API. */
#define EOS_RTC_ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_AddNotifyParticipantStatusChanged.
 */
EOS_STRUCT(EOS_RTC_AddNotifyParticipantStatusChangedOptions, (
	/** API Version: Set this to EOS_RTC_ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTC_AddNotifyParticipantStatusChanged registered event.
 */
EOS_STRUCT(EOS_RTC_ParticipantStatusChangedCallbackInfo, (
	/** Client-specified data passed into EOS_RTC_AddNotifyParticipantStatusChanged. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** The participant whose status changed. */
	EOS_ProductUserId ParticipantId;
	/** What status change occurred */
	EOS_ERTCParticipantStatus ParticipantStatus;
	/** The participant metadata items count.
	 * This is only set for the first notification where ParticipantStatus is EOS_RTCPS_Joined. Subsequent notifications
	 * such as when bParticipantInBlocklist changes will not contain any metadata.
	 */
	uint32_t ParticipantMetadataCount;
	/** The participant metadata items.
	 * This is only set for the first notification where ParticipantStatus is EOS_RTCPS_Joined. Subsequent notifications
	 * such as when bParticipantInBlocklist changes will not contain any metadata.
	 */
	const EOS_RTC_ParticipantMetadata* ParticipantMetadata;
	/** The participant's block list status, if ParticipantStatus is EOS_RTCPS_Joined.
	 * This is set to true if the participant is in any of the local user's applicable block lists,
	 * such Epic block list or any of the current platform's block lists.
	 * It can be used to detect when an internal automatic RTC block is applied because of trust and safety restrictions.
	 */
	EOS_Bool bParticipantInBlocklist;
));

EOS_DECLARE_CALLBACK(EOS_RTC_OnParticipantStatusChangedCallback, const EOS_RTC_ParticipantStatusChangedCallbackInfo* Data);



/**
 * RTC SetSettings API
 */

/** The most recent version of the EOS_RTC_SetSetting API. */
#define EOS_RTC_SETSETTING_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_SetSetting
 *
 * Available values of SettingName:
 * - DisableEchoCancelation: Disables the use of echo cancellation for the audio channel. Default "False".
 * - DisableNoiseSupression: Disables the use of noise suppression for the audio channel. Default "False".
 * - DisableAutoGainControl: Disables the use of auto gain control for the audio channel. Default "False".
 * - DisableDtx: Allows to disable the use of DTX.  Default "False".
 */
EOS_STRUCT(EOS_RTC_SetSettingOptions, (
	/** API Version: Set this to EOS_RTC_SETSETTING_API_LATEST. */
	int32_t ApiVersion;
	/** Setting that should be set. */
	const char* SettingName;
	/** Value to set the setting to. */
	const char* SettingValue;
));

/** The most recent version of the EOS_RTC_SetRoomSetting API. */
#define EOS_RTC_SETROOMSETTING_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_SetRoomSetting
 *
 * Available values of SettingName:
 * - DisableEchoCancelation: Disables the use of echo cancellation for the audio channel. Default "False".
 * - DisableNoiseSupression: Disables the use of noise suppression for the audio channel. Default "False".
 * - DisableAutoGainControl: Disables the use of auto gain control for the audio channel. Default "False".
 * - DisableDtx: Allows to disable the use of DTX.  Default "False".
 */
EOS_STRUCT(EOS_RTC_SetRoomSettingOptions, (
	/** API Version: Set this to EOS_RTC_SETROOMSETTING_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room the setting will be applied to. */
	const char* RoomName;
	/** Setting that should be set. */
	const char* SettingName;
	/** Value to set the setting to. */
	const char* SettingValue;
));


/**
 * RTC Statistics API
 */

/** The most recent version of the EOS_RTC_AddNotifyRoomStatisticsUpdated API. */
#define EOS_RTC_ADDNOTIFYROOMSTATISTICSUPDATED_API_LATEST 1

/**
 * This struct is used to call EOS_RTC_AddNotifyRoomStatisticsUpdated.
 */
EOS_STRUCT(EOS_RTC_AddNotifyRoomStatisticsUpdatedOptions, (
	/** API Version: Set this to EOS_RTC_ADDNOTIFYROOMSTATISTICSUPDATED_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user trying to request this operation. */
	EOS_ProductUserId LocalUserId;
	/** The room this event is registered on. */
	const char* RoomName;
));

/**
 * This struct is passed in with a call to EOS_RTC_AddNotifyRoomStatisticsUpdated registered event.
 */
EOS_STRUCT(EOS_RTC_RoomStatisticsUpdatedInfo, (
	/** Client-specified data passed into EOS_RTC_AddNotifyRoomStatisticsUpdated. */
	void* ClientData;
	/** The Product User ID of the user who initiated this request. */
	EOS_ProductUserId LocalUserId;
	/** The room associated with this event. */
	const char* RoomName;
	/** Statistics in JSON format */
	const char* Statistic;
));

EOS_DECLARE_CALLBACK(EOS_RTC_OnRoomStatisticsUpdatedCallback, const EOS_RTC_RoomStatisticsUpdatedInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_sanctions.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_sanctions_types.h"

/**
 * Start an asynchronous query to retrieve any active sanctions for a specified user.
 * Call EOS_Sanctions_GetPlayerSanctionCount and EOS_Sanctions_CopyPlayerSanctionByIndex to retrieve the data.
 *
 * @param Options Structure containing the input parameters
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the async operation completes, either successfully or in error
 *
 * @see EOS_Sanctions_GetPlayerSanctionCount
 * @see EOS_Sanctions_CopyPlayerSanctionByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Sanctions_QueryActivePlayerSanctions(EOS_HSanctions Handle, const EOS_Sanctions_QueryActivePlayerSanctionsOptions* Options, void* ClientData, const EOS_Sanctions_OnQueryActivePlayerSanctionsCallback CompletionDelegate);

/**
 * Fetch the number of player sanctions that have been retrieved for a given player.
 * You must call QueryActivePlayerSanctions first to retrieve the data from the service backend.
 *
 * @param Options Structure containing the input parameters
 *
 * @see EOS_Sanctions_QueryActivePlayerSanctions
 * @see EOS_Sanctions_CopyPlayerSanctionByIndex
 *
 * @return Number of available sanctions for this player.
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Sanctions_GetPlayerSanctionCount(EOS_HSanctions Handle, const EOS_Sanctions_GetPlayerSanctionCountOptions* Options);

/**
 * Copies an active player sanction.
 * You must call QueryActivePlayerSanctions first to retrieve the data from the service backend.
 * On success, EOS_Sanctions_PlayerSanction_Release must be called on OutSanction to free memory.
 *
 * @param Options Structure containing the input parameters
 * @param OutSanction The player sanction data for the given index, if it exists and is valid
 *
 * @see EOS_Sanctions_QueryActivePlayerSanctions
 * @see EOS_Sanctions_PlayerSanction_Release
 *
 * @return EOS_Success if the information is available and passed out in OutSanction
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the player achievement is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sanctions_CopyPlayerSanctionByIndex(EOS_HSanctions Handle, const EOS_Sanctions_CopyPlayerSanctionByIndexOptions* Options, EOS_Sanctions_PlayerSanction ** OutSanction);

/**
 * Create a sanction appeal on behalf of a local user.
 * Note that for creating the sanction appeal you'll need the sanction reference id, which is available through CopyPlayerSanctionByIndex.
 *
 * @param Options Structure containing the player sanction appeal information.
 * @param ClientData Optional client data provided by the user of the SDK.
 * @param CompletionDelegate This function is called when the send operation completes.
 */
EOS_DECLARE_FUNC(void) EOS_Sanctions_CreatePlayerSanctionAppeal(EOS_HSanctions Handle, const EOS_Sanctions_CreatePlayerSanctionAppealOptions* Options, void* ClientData, const EOS_Sanctions_CreatePlayerSanctionAppealCallback CompletionDelegate);

```

`EAC_SDK/SDK/include/eos_sanctions_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_SanctionsHandle* EOS_HSanctions;

/** The most recent version of the EOS_Sanctions_PlayerSanction struct. */
#define EOS_SANCTIONS_PLAYERSANCTION_API_LATEST 2

/**
 * Contains information about a single player sanction.
 */
EOS_STRUCT(EOS_Sanctions_PlayerSanction, (
	/** API Version: Set this to EOS_SANCTIONS_PLAYERSANCTION_API_LATEST. */
	int32_t ApiVersion;
	/** The POSIX timestamp when the sanction was placed */
	int64_t TimePlaced;
	/** The action associated with this sanction */
	const char* Action;
	/** The POSIX timestamp when the sanction will expire. If the sanction is permanent, this will be 0. */
	int64_t TimeExpires;
	/** A unique identifier for this specific sanction */
	const char* ReferenceId;
));

/** The most recent version of the EOS_Sanctions_QueryActivePlayerSanctions API. */
#define EOS_SANCTIONS_QUERYACTIVEPLAYERSANCTIONS_API_LATEST 2

/**
 * Input parameters for the EOS_Sanctions_QueryActivePlayerSanctions API.
 */
EOS_STRUCT(EOS_Sanctions_QueryActivePlayerSanctionsOptions, (
	/** API Version: Set this to EOS_SANCTIONS_QUERYACTIVEPLAYERSANCTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user whose active sanctions are to be retrieved. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID of the local user who initiated this request. Dedicated servers should set this to null. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Sanctions_QueryActivePlayerSanctions function.
 */
EOS_STRUCT(EOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sanctions_QueryActivePlayerSanctions. */
	void* ClientData;
	/** Target Product User ID that was passed to EOS_Sanctions_QueryActivePlayerSanctions. */
	EOS_ProductUserId TargetUserId;
	/** The Product User ID of the local user who initiated this request, if applicable. */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sanctions_QueryActivePlayerSanctions
 * @param Data A EOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sanctions_OnQueryActivePlayerSanctionsCallback, const EOS_Sanctions_QueryActivePlayerSanctionsCallbackInfo* Data);

/** The most recent version of the EOS_Sanctions_GetPlayerSanctionCount API. */
#define EOS_SANCTIONS_GETPLAYERSANCTIONCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Sanctions_GetPlayerSanctionCount function.
 */
EOS_STRUCT(EOS_Sanctions_GetPlayerSanctionCountOptions, (
	/** API Version: Set this to EOS_SANCTIONS_GETPLAYERSANCTIONCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user whose sanction count should be returned */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_Sanctions_CopyPlayerSanctionByIndex API. */
#define EOS_SANCTIONS_COPYPLAYERSANCTIONBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Sanctions_CopyPlayerSanctionByIndex function
 */
EOS_STRUCT(EOS_Sanctions_CopyPlayerSanctionByIndexOptions, (
	/** API Version: Set this to EOS_SANCTIONS_COPYPLAYERSANCTIONBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the user whose active sanctions are to be copied */
	EOS_ProductUserId TargetUserId;
	/** Index of the sanction to retrieve from the cache */
	uint32_t SanctionIndex;
));

/**
 * Release the memory associated with a player sanction.
 * This must be called on data retrieved from EOS_Sanctions_CopyPlayerSanctionByIndex.
 *
 * @param Sanction - The sanction data to release.
 *
 * @see EOS_Sanctions_PlayerSanction
 * @see EOS_Sanctions_CopyPlayerSanctionByIndex
 */
EOS_DECLARE_FUNC(void) EOS_Sanctions_PlayerSanction_Release(EOS_Sanctions_PlayerSanction* Sanction);

/** Sanction appeal reason codes */
EOS_ENUM(EOS_ESanctionAppealReason,
	/** Not used */
	EOS_SAR_Invalid = 0,
	/** Incorrectly placed sanction */
	EOS_SAR_IncorrectSanction = 1,
	/** The account was compromised, typically this means stolen */
	EOS_SAR_CompromisedAccount = 2,
	/** The punishment is considered too severe by the user */
	EOS_SAR_UnfairPunishment = 3,
	/** The user admits to rulebreaking, but still appeals for forgiveness */
	EOS_SAR_AppealForForgiveness = 4
);

/** The most recent version of the EOS_Sanctions_CreatePlayerSanctionAppeal struct. */
#define EOS_SANCTIONS_CREATEPLAYERSANCTIONAPPEAL_API_LATEST 1

/**
 * Input parameters for the EOS_Sanctions_CreatePlayerSanctionAppeal function.
 */
EOS_STRUCT(EOS_Sanctions_CreatePlayerSanctionAppealOptions, (
	/** API Version: Set this to EOS_SANCTIONS_CREATEPLAYERSANCTIONAPPEAL_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user sending their own sanction appeal. */
	EOS_ProductUserId LocalUserId;
	/** Reason code for the appeal. */
	EOS_ESanctionAppealReason Reason;
	/** A unique identifier for the specific sanction */
	const char* ReferenceId;
));

/**
 * Output parameters for the EOS_Sanctions_CreatePlayerSanctionAppealCallbackInfo function.
 */
EOS_STRUCT(EOS_Sanctions_CreatePlayerSanctionAppealCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sanctions_CreatePlayerSanctionAppeal. */
	void* ClientData;
	/** A unique identifier for the specific sanction that was appealed */
	const char* ReferenceId;
));

/**
 * Function definition for callbacks passed to EOS_Sanctions_CreatePlayerSanctionAppeal.
 * @param Data - EOS_Sanctions_CreatePlayerSanctionAppealCallbackInfo containing the output information and result.
 */
EOS_DECLARE_CALLBACK(EOS_Sanctions_CreatePlayerSanctionAppealCallback, const EOS_Sanctions_CreatePlayerSanctionAppealCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_sdk.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_init.h"
#include "eos_metrics_types.h"
#include "eos_auth_types.h"
#include "eos_ecom_types.h"
#include "eos_ui_types.h"
#include "eos_friends_types.h"
#include "eos_presence_types.h"
#include "eos_p2p_types.h"
#include "eos_sessions_types.h"
#include "eos_lobby_types.h"
#include "eos_userinfo_types.h"
#include "eos_playerdatastorage_types.h"
#include "eos_titlestorage_types.h"
#include "eos_connect.h"
#include "eos_achievements_types.h"
#include "eos_stats_types.h"
#include "eos_leaderboards_types.h"
#include "eos_mods_types.h"
#include "eos_anticheatclient_types.h"
#include "eos_anticheatserver_types.h"
#include "eos_reports_types.h"
#include "eos_sanctions_types.h"
#include "eos_kws_types.h"
#include "eos_rtc_types.h"
#include "eos_rtc_admin_types.h"
#include "eos_progressionsnapshot_types.h"
#include "eos_custominvites_types.h"
#include "eos_integratedplatform_types.h"

/**
 * The Platform Instance is used to gain access to all other Epic Online Service interfaces and to drive internal operations through the Tick.
 * All Platform Instance calls take a handle of type EOS_HPlatform as the first parameter.
 * EOS_HPlatform handles are created by calling EOS_Platform_Create and subsequently released by calling EOS_Platform_Release.
 *
 * @see eos_init.h
 * @see EOS_Initialize
 * @see EOS_Platform_Create
 * @see EOS_Platform_Release
 * @see EOS_Shutdown
 */

/**
 * Notify the platform instance to do work. This function must be called frequently in order for the services provided by the SDK to properly
 * function. For tick-based applications, it is usually desirable to call this once per-tick.
 */
EOS_DECLARE_FUNC(void) EOS_Platform_Tick(EOS_HPlatform Handle);

/**
 * Get a handle to the Metrics Interface.
 * @return EOS_HMetrics handle
 *
 * @see eos_metrics.h
 * @see eos_metrics_types.h
 */
EOS_DECLARE_FUNC(EOS_HMetrics) EOS_Platform_GetMetricsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Auth Interface.
 * @return EOS_HAuth handle
 *
 * @see eos_auth.h
 * @see eos_auth_types.h
 */
EOS_DECLARE_FUNC(EOS_HAuth) EOS_Platform_GetAuthInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Connect Interface.
 * @return EOS_HConnect handle
 *
 * @see eos_connect.h
 * @see eos_connect_types.h
 */
EOS_DECLARE_FUNC(EOS_HConnect) EOS_Platform_GetConnectInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Ecom Interface.
 * @return EOS_HEcom handle
 *
 * @see eos_ecom.h
 * @see eos_ecom_types.h
 */
EOS_DECLARE_FUNC(EOS_HEcom) EOS_Platform_GetEcomInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the UI Interface.
 * @return EOS_HUI handle
 *
 * @see eos_ui.h
 * @see eos_ui_types.h
 */
EOS_DECLARE_FUNC(EOS_HUI) EOS_Platform_GetUIInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Friends Interface.
 * @return EOS_HFriends handle
 *
 * @see eos_friends.h
 * @see eos_friends_types.h
 */
EOS_DECLARE_FUNC(EOS_HFriends) EOS_Platform_GetFriendsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Presence Interface.
 * @return EOS_HPresence handle
 *
 * @see eos_presence.h
 * @see eos_presence_types.h
 */
EOS_DECLARE_FUNC(EOS_HPresence) EOS_Platform_GetPresenceInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Sessions Interface.
 * @return EOS_HSessions handle
 *
 * @see eos_sessions.h
 * @see eos_sessions_types.h
 */
EOS_DECLARE_FUNC(EOS_HSessions) EOS_Platform_GetSessionsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Lobby Interface.
 * @return EOS_HLobby handle
 *
 * @see eos_lobby.h
 * @see eos_lobby_types.h
 */
EOS_DECLARE_FUNC(EOS_HLobby) EOS_Platform_GetLobbyInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the UserInfo Interface.
 * @return EOS_HUserInfo handle
 *
 * @see eos_userinfo.h
 * @see eos_userinfo_types.h
 */
EOS_DECLARE_FUNC(EOS_HUserInfo) EOS_Platform_GetUserInfoInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Peer-to-Peer Networking Interface.
 * @return EOS_HP2P handle
 *
 * @see eos_p2p.h
 * @see eos_p2p_types.h
 */
EOS_DECLARE_FUNC(EOS_HP2P) EOS_Platform_GetP2PInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Real Time Communications Interface (RTC).
 * From the RTC interface you can retrieve the handle to the audio interface (RTCAudio), which is a component of RTC.
 * @return EOS_HRTC handle
 *
 * @see EOS_RTC_GetAudioInterface
 * @see eos_rtc.h
 * @see eos_rtc_types.h
 */
EOS_DECLARE_FUNC(EOS_HRTC) EOS_Platform_GetRTCInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the RTC Admin interface
 * @return EOS_HRTCAdmin handle
 *
 * @see eos_rtc_admin.h
 * @see eos_admin_types.h
 */
EOS_DECLARE_FUNC(EOS_HRTCAdmin) EOS_Platform_GetRTCAdminInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the PlayerDataStorage Interface.
 * @return EOS_HPlayerDataStorage handle
 *
 * @see eos_playerdatastorage.h
 * @see eos_playerdatastorage_types.h
 */
EOS_DECLARE_FUNC(EOS_HPlayerDataStorage) EOS_Platform_GetPlayerDataStorageInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the TitleStorage Interface.
 * @return EOS_HTitleStorage handle
 *
 * @see eos_titlestorage.h
 * @see eos_titlestorage_types.h
 */
EOS_DECLARE_FUNC(EOS_HTitleStorage) EOS_Platform_GetTitleStorageInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Achievements Interface.
 * @return EOS_HAchievements handle
 *
 * @see eos_achievements.h
 * @see eos_achievements_types.h
 */
EOS_DECLARE_FUNC(EOS_HAchievements) EOS_Platform_GetAchievementsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Stats Interface.
 * @return EOS_HStats handle
 *
 * @see eos_stats.h
 * @see eos_stats_types.h
 */
EOS_DECLARE_FUNC(EOS_HStats) EOS_Platform_GetStatsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Leaderboards Interface.
 * @return EOS_HLeaderboards handle
 *
 * @see eos_leaderboards.h
 * @see eos_leaderboards_types.h
 */
EOS_DECLARE_FUNC(EOS_HLeaderboards) EOS_Platform_GetLeaderboardsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Mods Interface.
 * @return EOS_HMods handle
 *
 * @see eos_mods.h
 * @see eos_mods_types.h
 */
EOS_DECLARE_FUNC(EOS_HMods) EOS_Platform_GetModsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Anti-Cheat Client Interface.
 * @return EOS_HAntiCheatClient handle
 *
 * @see eos_anticheatclient.h
 * @see eos_anticheatclient_types.h
 */
EOS_DECLARE_FUNC(EOS_HAntiCheatClient) EOS_Platform_GetAntiCheatClientInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Anti-Cheat Server Interface.
 * @return EOS_HAntiCheatServer handle
 *
 * @see eos_anticheatserver.h
 * @see eos_anticheatserver_types.h
 */
EOS_DECLARE_FUNC(EOS_HAntiCheatServer) EOS_Platform_GetAntiCheatServerInterface(EOS_HPlatform Handle);

/**
 * Get the active country code that the SDK will send to services which require it.
 * This returns the override value otherwise it will use the country code of the given user.
 * This is currently used for determining pricing.
 * Get a handle to the ProgressionSnapshot Interface.
 * @return EOS_HProgressionSnapshot handle
 *
 * @see eos_progressionsnapshot.h
 * @see eos_progressionsnapshot_types.h
 */
EOS_DECLARE_FUNC(EOS_HProgressionSnapshot) EOS_Platform_GetProgressionSnapshotInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Reports Interface.
 * @return EOS_HReports handle
 *
 * @see eos_reports.h
 * @see eos_reports_types.h
 */
EOS_DECLARE_FUNC(EOS_HReports) EOS_Platform_GetReportsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Sanctions Interface.
 * @return EOS_HSanctions handle
 *
 * @see eos_sanctions.h
 * @see eos_sanctions_types.h
 */
EOS_DECLARE_FUNC(EOS_HSanctions) EOS_Platform_GetSanctionsInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Kids Web Service Interface.
 * @return EOS_HKWS handle
 *
 * @see eos_kws.h
 * @see eos_kws_types.h
 */
EOS_DECLARE_FUNC(EOS_HKWS) EOS_Platform_GetKWSInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Custom Invites Interface.
 * @return EOS_HCustomInvites handle
 *
 * @see eos_custominvites.h
 * @see eos_custominvites_types.h
 */
EOS_DECLARE_FUNC(EOS_HCustomInvites) EOS_Platform_GetCustomInvitesInterface(EOS_HPlatform Handle);

/**
 * Get a handle to the Integrated Platform Interface.
 * @return EOS_HIntegratedPlatform handle
 *
 * @see eos_integratedplatform.h
 * @see eos_integratedplatform_types.h
 */
EOS_DECLARE_FUNC(EOS_HIntegratedPlatform) EOS_Platform_GetIntegratedPlatformInterface(EOS_HPlatform Handle);

/**
 * This only will return the value set as the override otherwise EOS_NotFound is returned.
 * This is not currently used for anything internally.
 *
 * @param LocalUserId The account to use for lookup if no override exists.
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_COUNTRYCODE_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the active country code string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if there is not an override country code for the user.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the country code string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see eos_ecom.h
 * @see EOS_COUNTRYCODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetActiveCountryCode(EOS_HPlatform Handle, EOS_EpicAccountId LocalUserId, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Get the active locale code that the SDK will send to services which require it.
 * This returns the override value otherwise it will use the locale code of the given user.
 * This is used for localization. This follows ISO 639.
 *
 * @param LocalUserId The account to use for lookup if no override exists.
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_LOCALECODE_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the active locale code string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if there is neither an override nor an available locale code for the user.
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the locale code string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see eos_ecom.h
 * @see EOS_LOCALECODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetActiveLocaleCode(EOS_HPlatform Handle, EOS_EpicAccountId LocalUserId, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Get the override country code that the SDK will send to services which require it.
 * This is not currently used for anything internally.
 *
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_COUNTRYCODE_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the override country code string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the country code string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see eos_ecom.h
 * @see EOS_COUNTRYCODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetOverrideCountryCode(EOS_HPlatform Handle, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Get the override locale code that the SDK will send to services which require it.
 * This is used for localization. This follows ISO 639.
 *
 * @param OutBuffer The buffer into which the character data should be written.  The buffer must be long enough to hold a string of EOS_LOCALECODE_MAX_LENGTH.
 * @param InOutBufferLength The size of the OutBuffer in characters.
 *                          The input buffer should include enough space to be null-terminated.
 *                          When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
 *
 * @return An EOS_EResult that indicates whether the override locale code string was copied into the OutBuffer.
 *         EOS_Success if the information is available and passed out in OutBuffer
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_LimitExceeded - The OutBuffer is not large enough to receive the locale code string. InOutBufferLength contains the required minimum length to perform the operation successfully.
 *
 * @see eos_ecom.h
 * @see EOS_LOCALECODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetOverrideLocaleCode(EOS_HPlatform Handle, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Set the override country code that the SDK will send to services which require it.
 * This is not currently used for anything internally.
 *
 * @return An EOS_EResult that indicates whether the override country code string was saved.
 *         EOS_Success if the country code was overridden
 *         EOS_InvalidParameters if you pass an invalid country code
 *
 * @see eos_ecom.h
 * @see EOS_COUNTRYCODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_SetOverrideCountryCode(EOS_HPlatform Handle, const char* NewCountryCode);

/**
 * Set the override locale code that the SDK will send to services which require it.
 * This is used for localization. This follows ISO 639.
 *
 * @return An EOS_EResult that indicates whether the override locale code string was saved.
 *         EOS_Success if the locale code was overridden
 *         EOS_InvalidParameters if you pass an invalid locale code
 *
 * @see eos_ecom.h
 * @see EOS_LOCALECODE_MAX_LENGTH
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_SetOverrideLocaleCode(EOS_HPlatform Handle, const char* NewLocaleCode);

/**
 * Checks if the app was launched through the Epic Games Launcher, and relaunches it through the Epic Games Launcher if it wasn't.
 *
 * NOTE: During the call to EOS_Platform_Create, the command line that was used to launch the app is inspected, and if it is
 * recognized as coming from the Epic Games Launcher, an environment variable is set to 1. The name of the environment variable
 * is defined by EOS_PLATFORM_CHECKFORLAUNCHERANDRESTART_ENV_VAR.
 *
 * You can force the EOS_Platform_CheckForLauncherAndRestart API to relaunch the title by
 * explicitly unsetting this environment variable before calling EOS_Platform_CheckForLauncherAndRestart.
 *
 * @return An EOS_EResult is returned to indicate success or an error.
 *
 * EOS_Success is returned if the app is being restarted. You should quit your process as soon as possible.
 * EOS_NoChange is returned if the app was already launched through the Epic Launcher, and no action needs to be taken.
 * EOS_UnexpectedError is returned if the LauncherCheck module failed to initialize, or the module tried and failed to restart the app.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_CheckForLauncherAndRestart(EOS_HPlatform Handle);

/**
 * Windows only.
 * Checks that the application is ready to use desktop crossplay functionality, with the necessary prerequisites having been met.
 *
 * This function verifies that the application was launched through the Bootstrapper application,
 * the redistributable service has been installed and is running in the background,
 * and that the overlay has been loaded successfully.
 *
 * On Windows, the desktop crossplay functionality is required to use Epic accounts login
 * with applications that are distributed outside the Epic Games Store.
 *
 * @param Options input structure that specifies the API version.
 * @param OutDesktopCrossplayStatusInfo output structure to receive the desktop crossplay status information.
 *
 * @return An EOS_EResult is returned to indicate success or an error.
 *		   EOS_NotImplemented is returned on non-Windows platforms.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_GetDesktopCrossplayStatus(EOS_HPlatform Handle, const EOS_Platform_GetDesktopCrossplayStatusOptions* Options, EOS_Platform_DesktopCrossplayStatusInfo* OutDesktopCrossplayStatusInfo);

/**
 * Notify a change in application state.
 *
 * @note Calling SetApplicationStatus must happen before Tick when foregrounding for the cases where we won't get the background notification.
 *
 * @param NewStatus The new status for the application.
 *
 * @return An EOS_EResult that indicates whether we changed the application status successfully.
 *         EOS_Success if the application was changed successfully.
 *         EOS_InvalidParameters if the value of NewStatus is invalid.
 *         EOS_NotImplemented if EOS_AS_BackgroundConstrained or EOS_AS_BackgroundUnconstrained are attempted to be set on platforms that do not have such application states.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_SetApplicationStatus(EOS_HPlatform Handle, const EOS_EApplicationStatus NewStatus);

/**
 * Retrieves the current application state as told to the SDK by the application.
 *
 * @return The current application status.
 */
EOS_DECLARE_FUNC(EOS_EApplicationStatus) EOS_Platform_GetApplicationStatus(EOS_HPlatform Handle);

/**
 * Notify a change in network state.
 *
 * @param NewStatus The new network status.
 *
 * @return An EOS_EResult that indicates whether we changed the network status successfully.
 *         EOS_Success if the network was changed successfully.
 *         EOS_InvalidParameters if the value of NewStatus is invalid.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Platform_SetNetworkStatus(EOS_HPlatform Handle, const EOS_ENetworkStatus NewStatus);

/**
 * Retrieves the current network state as told to the SDK by the application.
 *
 * @return The current network status.
 */
EOS_DECLARE_FUNC(EOS_ENetworkStatus) EOS_Platform_GetNetworkStatus(EOS_HPlatform Handle);

```

`EAC_SDK/SDK/include/eos_sessions.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_sessions_types.h"

/**
 * The Session Interface is used to manage sessions that can be advertised with the backend service
 * All Session Interface calls take a handle of type EOS_HSessions as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetSessionsInterface function.
 *
 * @see EOS_Platform_GetSessionsInterface
 */

/**
 * Creates a session modification handle (EOS_HSessionModification).  The session modification handle is used to build a new session and can be applied with EOS_Sessions_UpdateSession
 * The EOS_HSessionModification must be released by calling EOS_SessionModification_Release once it no longer needed.
 *
 * @param Options Required fields for the creation of a session such as a name, bucketid, and max players
 * @param OutSessionModificationHandle Pointer to a Session Modification Handle only set if successful
 * @return EOS_Success if we successfully created the Session Modification Handle pointed at in OutSessionModificationHandle, or an error result if the input data was invalid
 *
 * @see EOS_SessionModification_Release
 * @see EOS_Sessions_UpdateSession
 * @see EOS_HSessionModification
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CreateSessionModification(EOS_HSessions Handle, const EOS_Sessions_CreateSessionModificationOptions* Options, EOS_HSessionModification* OutSessionModificationHandle);

/**
 * Creates a session modification handle (EOS_HSessionModification). The session modification handle is used to modify an existing session and can be applied with EOS_Sessions_UpdateSession.
 * The EOS_HSessionModification must be released by calling EOS_SessionModification_Release once it is no longer needed.
 *
 * @param Options Required fields such as session name
 * @param OutSessionModificationHandle Pointer to a Session Modification Handle only set if successful
 * @return EOS_Success if we successfully created the Session Modification Handle pointed at in OutSessionModificationHandle, or an error result if the input data was invalid
 *
 * @see EOS_SessionModification_Release
 * @see EOS_Sessions_UpdateSession
 * @see EOS_HSessionModification
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_UpdateSessionModification(EOS_HSessions Handle, const EOS_Sessions_UpdateSessionModificationOptions* Options, EOS_HSessionModification* OutSessionModificationHandle);

/**
 * Update a session given a session modification handle created by EOS_Sessions_CreateSessionModification or EOS_Sessions_UpdateSessionModification
 *
 * @param Options Structure containing information about the session to be updated
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the update operation completes, either successfully or in error
 *
 * @return EOS_Success if the update completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to be updated does not exist
 *         EOS_LimitExceeded if a new session cannot be created because doing so would exceed the maximum allowed concurrent session count
 *         EOS_InvalidUser if the local user associated with the session to update does not exist or is not authenticated
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_UpdateSession(EOS_HSessions Handle, const EOS_Sessions_UpdateSessionOptions* Options, void* ClientData, const EOS_Sessions_OnUpdateSessionCallback CompletionDelegate);

/**
 * Destroy a session given a session name
 *
 * @param Options Structure containing information about the session to be destroyed
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the destroy operation completes, either successfully or in error
 *
 * @return EOS_Success if the destroy completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_AlreadyPending if the session is already marked for destroy
 *         EOS_NotFound if a session to be destroyed does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_DestroySession(EOS_HSessions Handle, const EOS_Sessions_DestroySessionOptions* Options, void* ClientData, const EOS_Sessions_OnDestroySessionCallback CompletionDelegate);

/**
 * Join a session, creating a local session under a given session name.  Backend will validate various conditions to make sure it is possible to join the session.
 *
 * @param Options Structure containing information about the session to be joined
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the join operation completes, either successfully or in error
 *
 * @return EOS_Success if the join completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_SessionAlreadyExists if the session is already exists or is in the process of being joined
 *         EOS_InvalidUser if the local user associated with the local session to be created does not exist or is not authenticated
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_JoinSession(EOS_HSessions Handle, const EOS_Sessions_JoinSessionOptions* Options, void* ClientData, const EOS_Sessions_OnJoinSessionCallback CompletionDelegate);

/**
 * Mark a session as started, making it unable to find if session properties indicate "join in progress" is not available
 *
 * @param Options Structure containing information about the session to be started
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the start operation completes, either successfully or in error
 *
 * @return EOS_Success if the start completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to be started does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_StartSession(EOS_HSessions Handle, const EOS_Sessions_StartSessionOptions* Options, void* ClientData, const EOS_Sessions_OnStartSessionCallback CompletionDelegate);

/**
 * Mark a session as ended, making it available to find if "join in progress" was disabled.  The session may be started again if desired
 *
 * @param Options Structure containing information about the session to be ended
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the end operation completes, either successfully or in error
 *
 * @return EOS_Success if the end completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to be ended does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_EndSession(EOS_HSessions Handle, const EOS_Sessions_EndSessionOptions* Options, void* ClientData, const EOS_Sessions_OnEndSessionCallback CompletionDelegate);

/**
 * Register a group of players with the session, allowing them to invite others or otherwise indicate they are part of the session for determining a full session
 *
 * @param Options Structure containing information about the session and players to be registered
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the registration operation completes, either successfully or in error
 *
 * @return EOS_Success if the register completes successfully
 *         EOS_NoChange if the players to register registered previously
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to register players does not exist
 *         EOS_LimitExceeded if registering the requested players would drive the total number of registered players beyond EOS_SESSIONS_MAXREGISTEREDPLAYERS (API Version <= 2)
 *         EOS_Sessions_TooManyPlayers if registering the requested players would drive the total number of registered players beyond EOS_SESSIONS_MAXREGISTEREDPLAYERS (API Version > 2)
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RegisterPlayers(EOS_HSessions Handle, const EOS_Sessions_RegisterPlayersOptions* Options, void* ClientData, const EOS_Sessions_OnRegisterPlayersCallback CompletionDelegate);

/**
 * Unregister a group of players with the session, freeing up space for others to join
 *
 * @param Options Structure containing information about the session and players to be unregistered
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the unregistration operation completes, either successfully or in error
 *
 * @return EOS_Success if the unregister completes successfully
 *         EOS_NoChange if the players to unregister were not found
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_Sessions_OutOfSync if the session is out of sync and will be updated on the next connection with the backend
 *         EOS_NotFound if a session to be unregister players does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_UnregisterPlayers(EOS_HSessions Handle, const EOS_Sessions_UnregisterPlayersOptions* Options, void* ClientData, const EOS_Sessions_OnUnregisterPlayersCallback CompletionDelegate);

/**
 * Send an invite to another player.  User must have created the session or be registered in the session or else the call will fail
 *
 * @param Options Structure containing information about the session and player to invite
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the send invite operation completes, either successfully or in error
 *
 * @return EOS_Success if the send invite completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the session to send the invite from does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_SendInvite(EOS_HSessions Handle, const EOS_Sessions_SendInviteOptions* Options, void* ClientData, const EOS_Sessions_OnSendInviteCallback CompletionDelegate);

/**
 * Reject an invite from another player.
 *
 * @param Options Structure containing information about the invite to reject
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the reject invite operation completes, either successfully or in error
 *
 * @return EOS_Success if the invite rejection completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the invite does not exist
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RejectInvite(EOS_HSessions Handle, const EOS_Sessions_RejectInviteOptions* Options, void* ClientData, const EOS_Sessions_OnRejectInviteCallback CompletionDelegate);

/**
 * Retrieve all existing invites for a single user
 *
 * @param Options Structure containing information about the invites to query
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the query invites operation completes, either successfully or in error
 *
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_QueryInvites(EOS_HSessions Handle, const EOS_Sessions_QueryInvitesOptions* Options, void* ClientData, const EOS_Sessions_OnQueryInvitesCallback CompletionDelegate);

/**
 * Get the number of known invites for a given user
 *
 * @param Options the Options associated with retrieving the current invite count
 *
 * @return number of known invites for a given user or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Sessions_GetInviteCount(EOS_HSessions Handle, const EOS_Sessions_GetInviteCountOptions* Options);

/**
 * Retrieve an invite ID from a list of active invites for a given user
 *
 * @param Options Structure containing the input parameters
 *
 * @return EOS_Success if the input is valid and an invite ID was returned
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_NotFound if the invite doesn't exist
 *
 * @see EOS_Sessions_GetInviteCount
 * @see EOS_Sessions_CopySessionHandleByInviteId
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_GetInviteIdByIndex(EOS_HSessions Handle, const EOS_Sessions_GetInviteIdByIndexOptions* Options, char* OutBuffer, int32_t* InOutBufferLength);

/**
 * Create a session search handle.  This handle may be modified to include various search parameters.
 * Searching is possible in three methods, all mutually exclusive
 * - set the session ID to find a specific session
 * - set the target user ID to find a specific user
 * - set session parameters to find an array of sessions that match the search criteria
 *
 * @param Options Structure containing required parameters such as the maximum number of search results
 * @param OutSessionSearchHandle The new search handle or null if there was an error creating the search handle
 *
 * @return EOS_Success if the search creation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CreateSessionSearch(EOS_HSessions Handle, const EOS_Sessions_CreateSessionSearchOptions* Options, EOS_HSessionSearch* OutSessionSearchHandle);

/**
 * Create a handle to an existing active session.
 *
 * @param Options Structure containing information about the active session to retrieve
 * @param OutSessionHandle The new active session handle or null if there was an error
 *
 * @return EOS_Success if the session handle was created successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the active session doesn't exist
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CopyActiveSessionHandle(EOS_HSessions Handle, const EOS_Sessions_CopyActiveSessionHandleOptions* Options, EOS_HActiveSession* OutSessionHandle);

/**
 * Register to receive session invites.
 * @note If the returned NotificationId is valid, you must call EOS_Sessions_RemoveNotifySessionInviteReceived when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the session invite notification
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param NotificationFn A callback that is fired when a session invite for a user has been received
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifySessionInviteReceived(EOS_HSessions Handle, const EOS_Sessions_AddNotifySessionInviteReceivedOptions* Options, void* ClientData, const EOS_Sessions_OnSessionInviteReceivedCallback NotificationFn);

/**
 * Unregister from receiving session invites.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifySessionInviteReceived(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a user accepts a session invite via the social overlay.
 * @note If the returned NotificationId is valid, you must call EOS_Sessions_RemoveNotifySessionInviteAccepted when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifySessionInviteAccepted(EOS_HSessions Handle, const EOS_Sessions_AddNotifySessionInviteAcceptedOptions* Options, void* ClientData, const EOS_Sessions_OnSessionInviteAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a session invite via the social overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifySessionInviteAccepted(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a user rejects a session invite.
 * @note If the returned NotificationId is valid, you must call EOS_Sessions_RemoveNotifySessionInviteRejected when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifySessionInviteRejected(EOS_HSessions Handle, const EOS_Sessions_AddNotifySessionInviteRejectedOptions* Options, void* ClientData, const EOS_Sessions_OnSessionInviteRejectedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user rejects a session invite via the social overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifySessionInviteRejected(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications when a user accepts a session join game via the social overlay.
 * @note If the returned NotificationId is valid, you must call EOS_Sessions_RemoveNotifyJoinSessionAccepted when you no longer wish to have your NotificationHandler called
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifyJoinSessionAccepted(EOS_HSessions Handle, const EOS_Sessions_AddNotifyJoinSessionAcceptedOptions* Options, void* ClientData, const EOS_Sessions_OnJoinSessionAcceptedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user accepts a session join game via the social overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifyJoinSessionAccepted(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * EOS_Sessions_CopySessionHandleByInviteId is used to immediately retrieve a handle to the session information from after notification of an invite
 * If the call returns an EOS_Success result, the out parameter, OutSessionHandle, must be passed to EOS_SessionDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionHandle out parameter used to receive the session handle
 *
 * @return EOS_Success if the information is available and passed out in OutSessionHandle
 *         EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the invite ID cannot be found
 *
 * @see EOS_Sessions_CopySessionHandleByInviteIdOptions
 * @see EOS_SessionDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CopySessionHandleByInviteId(EOS_HSessions Handle, const EOS_Sessions_CopySessionHandleByInviteIdOptions* Options, EOS_HSessionDetails* OutSessionHandle);

/**
 * EOS_Sessions_CopySessionHandleByUiEventId is used to immediately retrieve a handle to the session information from after notification of a join game event.
 * If the call returns an EOS_Success result, the out parameter, OutSessionHandle, must be passed to EOS_SessionDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionHandle out parameter used to receive the session handle
 *
 * @return EOS_Success if the information is available and passed out in OutSessionHandle
 *         EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the invite ID cannot be found
 *
 * @see EOS_Sessions_CopySessionHandleByUiEventIdOptions
 * @see EOS_SessionDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CopySessionHandleByUiEventId(EOS_HSessions Handle, const EOS_Sessions_CopySessionHandleByUiEventIdOptions* Options, EOS_HSessionDetails* OutSessionHandle);

/**
 * EOS_Sessions_CopySessionHandleForPresence is used to immediately retrieve a handle to the session information which was marked with bPresenceEnabled on create or join.
 * If the call returns an EOS_Success result, the out parameter, OutSessionHandle, must be passed to EOS_SessionDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionHandle out parameter used to receive the session handle
 *
 * @return EOS_Success if the information is available and passed out in OutSessionHandle
 *         EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if there is no session with bPresenceEnabled
 *
 * @see EOS_Sessions_CopySessionHandleForPresenceOptions
 * @see EOS_SessionDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_CopySessionHandleForPresence(EOS_HSessions Handle, const EOS_Sessions_CopySessionHandleForPresenceOptions* Options, EOS_HSessionDetails* OutSessionHandle);

/**
 * EOS_Sessions_IsUserInSession returns whether or not a given user can be found in a specified session
 *
 * @param Options Structure containing the input parameters
 *
 * @return EOS_Success if the user is found in the specified session
 *		   EOS_NotFound if the user is not found in the specified session
 *		   EOS_InvalidParameters if you pass an invalid invite ID or a null pointer for the out parameter
 *		   EOS_IncompatibleVersion if the API version passed in is incorrect
 *		   EOS_Invalid_ProductUserID if an invalid target user is specified
 *		   EOS_Sessions_InvalidSession if the session specified is invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_IsUserInSession(EOS_HSessions Handle, const EOS_Sessions_IsUserInSessionOptions* Options);

/**
 * Dump the contents of active sessions that exist locally to the log output, purely for debug purposes
 *
 * @param Options Options related to dumping session state such as the session name
 *
 * @return EOS_Success if the output operation completes successfully
 *         EOS_NotFound if the session specified does not exist
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Sessions_DumpSessionState(EOS_HSessions Handle, const EOS_Sessions_DumpSessionStateOptions* Options);

/**
 * Register to receive notifications about leave session requests performed by local user via the overlay.
 * When user requests to leave the session in the social overlay, the SDK does not automatically leave the session, it is up to the game to perform any necessary cleanup and call the EOS_Sessions_DestroySession method using the SessionName sent in the notification function.
 * @note If the returned NotificationId is valid, you must call EOS_Sessions_RemoveNotifyLeaveSessionRequested when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifyLeaveSessionRequested(EOS_HSessions Handle, const EOS_Sessions_AddNotifyLeaveSessionRequestedOptions* Options, void* ClientData, const EOS_Sessions_OnLeaveSessionRequestedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user performs a leave lobby action via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifyLeaveSessionRequested(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * Register to receive notifications about a session "INVITE" performed by a local user via the overlay.
 * This is only needed when a configured integrated platform has EOS_IPMF_DisableSDKManagedSessions set.  The EOS SDK will
 * then use the state of EOS_IPMF_PreferEOSIdentity and EOS_IPMF_PreferIntegratedIdentity to determine when the NotificationFn is
 * called.
 *
 * @note If the returned NotificationId is valid, you must call EOS_Sessions_RemoveNotifySendSessionNativeInviteRequested when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param NotificationFn A callback that is fired when a notification is received.
 *
 * @return handle representing the registered callback
 *
 * @see EOS_IPMF_DisableSDKManagedSessions
 * @see EOS_IPMF_PreferEOSIdentity
 * @see EOS_IPMF_PreferIntegratedIdentity
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_Sessions_AddNotifySendSessionNativeInviteRequested(EOS_HSessions Handle, const EOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions* Options, void* ClientData, const EOS_Sessions_OnSendSessionNativeInviteRequestedCallback NotificationFn);

/**
 * Unregister from receiving notifications when a user requests a send invite via the overlay.
 *
 * @param InId Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_Sessions_RemoveNotifySendSessionNativeInviteRequested(EOS_HSessions Handle, EOS_NotificationId InId);

/**
 * To modify sessions, you must call EOS_Sessions_CreateSessionModification to create a Session Modification handle. To modify that handle, call
 * EOS_HSessionModification methods. Once you are finished, call EOS_Sessions_UpdateSession with your handle. You must then release your Session Modification
 * handle by calling EOS_SessionModification_Release.
 */

/**
 * Set the bucket ID associated with this session.
 * Values such as region, game mode, etc can be combined here depending on game need.
 * Setting this is strongly recommended to improve search performance.
 *
 * @param Options Options associated with the bucket ID of the session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_InvalidParameters if the bucket ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetBucketId(EOS_HSessionModification Handle, const EOS_SessionModification_SetBucketIdOptions* Options);

/**
 * Set the host address associated with this session
 * Setting this is optional, if the value is not set the SDK will fill the value in from the service.
 * It is useful to set if other addressing mechanisms are desired or if LAN addresses are preferred during development
 *
 * @note No validation of this value occurs to allow for flexibility in addressing methods
 *
 * @param Options Options associated with the host address of the session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_InvalidParameters if the host ID is an empty string
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetHostAddress(EOS_HSessionModification Handle, const EOS_SessionModification_SetHostAddressOptions* Options);

/**
 * Set the session permissions associated with this session.
 * The permissions range from "public" to "invite only" and are described by EOS_EOnlineSessionPermissionLevel
 *
 * @param Options Options associated with the permission level of the session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetPermissionLevel(EOS_HSessionModification Handle, const EOS_SessionModification_SetPermissionLevelOptions* Options);

/**
 * Set whether or not join in progress is allowed
 * Once a session is started, it will no longer be visible to search queries unless this flag is set or the session returns to the pending or ended state
 *
 * @param Options Options associated with setting the join in progress state the session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetJoinInProgressAllowed(EOS_HSessionModification Handle, const EOS_SessionModification_SetJoinInProgressAllowedOptions* Options);

/**
 * Set the maximum number of players allowed in this session.
 * When updating the session, it is not possible to reduce this number below the current number of existing players
 *
 * @param Options Options associated with max number of players in this session
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetMaxPlayers(EOS_HSessionModification Handle, const EOS_SessionModification_SetMaxPlayersOptions* Options);

/**
 * Allows enabling or disabling invites for this session.
 * The session will also need to have `bPresenceEnabled` true.
 *
 * @param Options Options associated with invites allowed flag for this session.
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetInvitesAllowed(EOS_HSessionModification Handle, const EOS_SessionModification_SetInvitesAllowedOptions* Options);

/**
 * Set the Allowed Platform IDs for the session.
 *
 * @param Options Options associated with allowed Platform IDs for this session.
 *
 * @return EOS_Success if setting this parameter was successful
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_InvalidParameters if the attribution is missing information or otherwise invalid
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_SetAllowedPlatformIds(EOS_HSessionModification Handle, const EOS_SessionModification_SetAllowedPlatformIdsOptions* Options);

/**
 * Associate an attribute with this session
 * An attribute is something that may or may not be advertised with the session.
 * If advertised, it can be queried for in a search, otherwise the data remains local to the client
 *
 * @param Options Options to set the attribute and its advertised state
 *
 * @return EOS_Success if setting this parameter was successful
 *		   EOS_InvalidParameters if the attribution is missing information or otherwise invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_AddAttribute(EOS_HSessionModification Handle, const EOS_SessionModification_AddAttributeOptions* Options);

/**
 * Remove an attribute from this session
 *
 * @param Options Specify the key of the attribute to remove
 *
 * @return EOS_Success if removing this parameter was successful
 *		   EOS_InvalidParameters if the key is null or empty
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionModification_RemoveAttribute(EOS_HSessionModification Handle, const EOS_SessionModification_RemoveAttributeOptions* Options);

/**
 * Representation of an existing session some local players are actively involved in (via Create/Join)
 */

/**
 * EOS_ActiveSession_CopyInfo is used to immediately retrieve a copy of active session information
 * If the call returns an EOS_Success result, the out parameter, OutActiveSessionInfo, must be passed to EOS_ActiveSession_Info_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutActiveSessionInfo Out parameter used to receive the EOS_ActiveSession_Info structure.
 *
 * @return EOS_Success if the information is available and passed out in OutActiveSessionInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_ActiveSession_Info
 * @see EOS_ActiveSession_CopyInfoOptions
 * @see EOS_ActiveSession_Info_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_ActiveSession_CopyInfo(EOS_HActiveSession Handle, const EOS_ActiveSession_CopyInfoOptions* Options, EOS_ActiveSession_Info ** OutActiveSessionInfo);

/**
 * Get the number of registered players associated with this active session
 *
 * @param Options the Options associated with retrieving the registered player count
 *
 * @return number of registered players in the active session or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_ActiveSession_GetRegisteredPlayerCount(EOS_HActiveSession Handle, const EOS_ActiveSession_GetRegisteredPlayerCountOptions* Options);

/**
 * EOS_ActiveSession_GetRegisteredPlayerByIndex is used to immediately retrieve individual players registered with the active session.
 *
 * @param Options Structure containing the input parameters
 *
 * @return the product user ID for the registered player at a given index or null if that index is invalid
 *
 * @see EOS_ActiveSession_GetRegisteredPlayerCount
 * @see EOS_ActiveSession_GetRegisteredPlayerByIndexOptions
 */
EOS_DECLARE_FUNC(EOS_ProductUserId) EOS_ActiveSession_GetRegisteredPlayerByIndex(EOS_HActiveSession Handle, const EOS_ActiveSession_GetRegisteredPlayerByIndexOptions* Options);

/**
 * This class represents the details of a session, including its session properties and the attribution associated with it
 * Locally created or joined active sessions will contain this information as will search results.
 * A handle to a session is required to join a session via search or invite
 */

/**
 * EOS_SessionDetails_CopyInfo is used to immediately retrieve a copy of session information from a given source such as a active session or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutSessionInfo, must be passed to EOS_SessionDetails_Info_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionInfo Out parameter used to receive the EOS_SessionDetails_Info structure.
 *
 * @return EOS_Success if the information is available and passed out in OutSessionInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_SessionDetails_Info
 * @see EOS_SessionDetails_CopyInfoOptions
 * @see EOS_SessionDetails_Info_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionDetails_CopyInfo(EOS_HSessionDetails Handle, const EOS_SessionDetails_CopyInfoOptions* Options, EOS_SessionDetails_Info ** OutSessionInfo);

/**
 * Get the number of attributes associated with this session
 *
 * @param Options the Options associated with retrieving the attribute count
 *
 * @return number of attributes on the session or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_SessionDetails_GetSessionAttributeCount(EOS_HSessionDetails Handle, const EOS_SessionDetails_GetSessionAttributeCountOptions* Options);

/**
 * EOS_SessionDetails_CopySessionAttributeByIndex is used to immediately retrieve a copy of session attribution from a given source such as a active session or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutSessionAttribute, must be passed to EOS_SessionDetails_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionAttribute Out parameter used to receive the EOS_SessionDetails_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutSessionAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_SessionDetails_Attribute
 * @see EOS_SessionDetails_CopySessionAttributeByIndexOptions
 * @see EOS_SessionDetails_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionDetails_CopySessionAttributeByIndex(EOS_HSessionDetails Handle, const EOS_SessionDetails_CopySessionAttributeByIndexOptions* Options, EOS_SessionDetails_Attribute ** OutSessionAttribute);

/**
 * EOS_SessionDetails_CopySessionAttributeByKey is used to immediately retrieve a copy of session attribution from a given source such as a active session or a search result.
 * If the call returns an EOS_Success result, the out parameter, OutSessionAttribute, must be passed to EOS_SessionDetails_Attribute_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionAttribute Out parameter used to receive the EOS_SessionDetails_Attribute structure.
 *
 * @return EOS_Success if the information is available and passed out in OutSessionAttribute
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_SessionDetails_Attribute
 * @see EOS_SessionDetails_CopySessionAttributeByKeyOptions
 * @see EOS_SessionDetails_Attribute_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionDetails_CopySessionAttributeByKey(EOS_HSessionDetails Handle, const EOS_SessionDetails_CopySessionAttributeByKeyOptions* Options, EOS_SessionDetails_Attribute ** OutSessionAttribute);

/**
 * Class responsible for the creation, setup, and execution of a search query.
 * Search parameters are defined, the query is executed and the search results are returned within this object
 */

/**
 * Set a session ID to find and will return at most one search result.  Setting TargetUserId or SearchParameters will result in EOS_SessionSearch_Find failing
 *
 * @param Options A specific session ID for which to search
 *
 * @return EOS_Success if setting this session ID was successful
 *         EOS_InvalidParameters if the session ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_SetSessionId(EOS_HSessionSearch Handle, const EOS_SessionSearch_SetSessionIdOptions* Options);

/**
 * Set a target user ID to find and will return at most one search result.  Setting SessionId or SearchParameters will result in EOS_SessionSearch_Find failing
 * @note a search result will only be found if this user is in a public session
 *
 * @param Options a specific target user ID to find
 *
 * @return EOS_Success if setting this target user ID was successful
 *         EOS_InvalidParameters if the target user ID is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_SetTargetUserId(EOS_HSessionSearch Handle, const EOS_SessionSearch_SetTargetUserIdOptions* Options);

/**
 * Add a parameter to an array of search criteria combined via an implicit AND operator.  Setting SessionId or TargetUserId will result in EOS_SessionSearch_Find failing
 *
 * @param Options a search parameter and its comparison op
 *
 * @return EOS_Success if setting this search parameter was successful
 *         EOS_InvalidParameters if the search criteria is invalid or null
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_Sessions_AttributeData
 * @see EOS_EComparisonOp
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_SetParameter(EOS_HSessionSearch Handle, const EOS_SessionSearch_SetParameterOptions* Options);

/**
 * Remove a parameter from the array of search criteria.
 *
 * @params Options a search parameter key name to remove
 *
 * @return EOS_Success if removing this search parameter was successful
 *         EOS_InvalidParameters if the search key is invalid or null
 *         EOS_NotFound if the parameter was not a part of the search criteria
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_RemoveParameter(EOS_HSessionSearch Handle, const EOS_SessionSearch_RemoveParameterOptions* Options);

/**
 * Set the maximum number of search results to return in the query, can't be more than EOS_SESSIONS_MAX_SEARCH_RESULTS
 *
 * @param Options maximum number of search results to return in the query
 *
 * @return EOS_Success if setting the max results was successful
 *         EOS_InvalidParameters if the number of results requested is invalid
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_SetMaxResults(EOS_HSessionSearch Handle, const EOS_SessionSearch_SetMaxResultsOptions* Options);

/**
 * Find sessions matching the search criteria setup via this session search handle.
 * When the operation completes, this handle will have the search results that can be parsed
 *
 * @param Options Structure containing information about the search criteria to use
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate A callback that is fired when the search operation completes, either successfully or in error
 *
 * @return EOS_Success if the find operation completes successfully
 *         EOS_NotFound if searching for an individual session by sessionid or targetuserid returns no results
 *         EOS_InvalidParameters if any of the options are incorrect
 */
EOS_DECLARE_FUNC(void) EOS_SessionSearch_Find(EOS_HSessionSearch Handle, const EOS_SessionSearch_FindOptions* Options, void* ClientData, const EOS_SessionSearch_OnFindCallback CompletionDelegate);

/**
 * Get the number of search results found by the search parameters in this search
 *
 * @param Options Options associated with the search count
 *
 * @return return the number of search results found by the query or 0 if search is not complete
 */
EOS_DECLARE_FUNC(uint32_t) EOS_SessionSearch_GetSearchResultCount(EOS_HSessionSearch Handle, const EOS_SessionSearch_GetSearchResultCountOptions* Options);

/**
 * EOS_SessionSearch_CopySearchResultByIndex is used to immediately retrieve a handle to the session information from a given search result.
 * If the call returns an EOS_Success result, the out parameter, OutSessionHandle, must be passed to EOS_SessionDetails_Release to release the memory associated with it.
 *
 * @param Options Structure containing the input parameters
 * @param OutSessionHandle out parameter used to receive the session handle
 *
 * @return EOS_Success if the information is available and passed out in OutSessionHandle
 *         EOS_InvalidParameters if you pass an invalid index or a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *
 * @see EOS_SessionSearch_CopySearchResultByIndexOptions
 * @see EOS_SessionDetails_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_SessionSearch_CopySearchResultByIndex(EOS_HSessionSearch Handle, const EOS_SessionSearch_CopySearchResultByIndexOptions* Options, EOS_HSessionDetails* OutSessionHandle);

```

`EAC_SDK/SDK/include/eos_sessions_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"
#include "eos_ui_types.h"

#pragma pack(push, 8)

/** Handle to the sessions interface */
EXTERN_C typedef struct EOS_SessionsHandle* EOS_HSessions;
/** Handle to the calls responsible for creating/updating sessions */
EXTERN_C typedef struct EOS_SessionModificationHandle* EOS_HSessionModification;
/** Handle to a single named session that exists locally */
EXTERN_C typedef struct EOS_ActiveSessionHandle* EOS_HActiveSession;
/** Handle to a single session that may be part of a named session, search result, or invite */
EXTERN_C typedef struct EOS_SessionDetailsHandle* EOS_HSessionDetails;
/** Handle to the calls responsible for creating a search object */
EXTERN_C typedef struct EOS_SessionSearchHandle* EOS_HSessionSearch;

/**
 * Release the memory associated with session modification.
 * This must be called on data retrieved from EOS_Sessions_CreateSessionModification or EOS_Sessions_UpdateSessionModification
 *
 * @param SessionModificationHandle - The session modification handle to release
 *
 * @see EOS_Sessions_CreateSessionModification
 * @see EOS_Sessions_UpdateSessionModification
 */
EOS_DECLARE_FUNC(void) EOS_SessionModification_Release(EOS_HSessionModification SessionModificationHandle);

/**
 * Release the memory associated with an active session.
 * This must be called on data retrieved from EOS_Sessions_CopyActiveSessionHandle
 *
 * @param ActiveSessionHandle - The active session handle to release
 *
 * @see EOS_Sessions_CopyActiveSessionHandle
 */
EOS_DECLARE_FUNC(void) EOS_ActiveSession_Release(EOS_HActiveSession ActiveSessionHandle);

/**
 * Release the memory associated with a single session. This must be called on data retrieved from EOS_SessionSearch_CopySearchResultByIndex.
 *
 * @param SessionHandle - The session handle to release
 *
 * @see EOS_SessionSearch_CopySearchResultByIndex
 */
EOS_DECLARE_FUNC(void) EOS_SessionDetails_Release(EOS_HSessionDetails SessionHandle);

/**
 * Release the memory associated with a session search. This must be called on data retrieved from EOS_Sessions_CreateSessionSearch.
 *
 * @param SessionSearchHandle - The session search handle to release
 *
 * @see EOS_Sessions_CreateSessionSearch
 */
EOS_DECLARE_FUNC(void) EOS_SessionSearch_Release(EOS_HSessionSearch SessionSearchHandle);


/** All possible states of an existing named session */
EOS_ENUM(EOS_EOnlineSessionState,
	/** An online session has not been created yet */
	EOS_OSS_NoSession = 0,
	/** An online session is in the process of being created */
	EOS_OSS_Creating = 1,
	/** Session has been created but the session hasn't started (pre match lobby) */
	EOS_OSS_Pending = 2,
	/** Session has been asked to start (may take time due to communication with backend) */
	EOS_OSS_Starting = 3,
	/** The current session has started. Sessions with join in progress disabled are no longer joinable */
	EOS_OSS_InProgress = 4,
	/** The session is still valid, but the session is no longer being played (post match lobby) */
	EOS_OSS_Ending = 5,
	/** The session is closed and any stats committed */
	EOS_OSS_Ended = 6,
	/** The session is being destroyed */
	EOS_OSS_Destroying = 7
);

/** Advertisement properties for a single attribute associated with a session */
EOS_ENUM(EOS_ESessionAttributeAdvertisementType,
	/** Don't advertise via the online service */
	EOS_SAAT_DontAdvertise = 0,
	/** Advertise via the online service only */
	EOS_SAAT_Advertise = 1
);

/** Deprecated 1.4 types, do not use */
#define EOS_SAT_Boolean EOS_AT_BOOLEAN
#define EOS_SAT_Int64	EOS_AT_INT64
#define EOS_SAT_Double	EOS_AT_DOUBLE
#define EOS_SAT_String	EOS_AT_STRING

/** Deprecated 1.4 types, do not use */
#define EOS_OCO_EQUAL				EOS_CO_EQUAL
#define EOS_OCO_NOTEQUAL			EOS_CO_NOTEQUAL
#define EOS_OCO_GREATERTHAN			EOS_CO_GREATERTHAN
#define EOS_OCO_GREATERTHANOREQUAL	EOS_CO_GREATERTHANOREQUAL
#define EOS_OCO_LESSTHAN			EOS_CO_LESSTHAN
#define EOS_OCO_LESSTHANOREQUAL		EOS_CO_LESSTHANOREQUAL
#define EOS_OCO_DISTANCE			EOS_CO_DISTANCE
#define EOS_OCO_ANYOF				EOS_CO_ANYOF
#define EOS_OCO_NOTANYOF			EOS_CO_NOTANYOF


/** Maximum number of attributes allowed on the session */
#define EOS_SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTES 64
/** Maximum length of the name of the attribute associated with the session */
#define EOS_SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTE_LENGTH 64

/** Minimum number of characters allowed in the session id override */
#define EOS_SESSIONMODIFICATION_MIN_SESSIONIDOVERRIDE_LENGTH 16
/** Maximum number of characters allowed in the session id override */
#define EOS_SESSIONMODIFICATION_MAX_SESSIONIDOVERRIDE_LENGTH 64

/** The most recent version of the EOS_Sessions_CreateSessionModification API. */
#define EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST 5

/**
 * Input parameters for the EOS_Sessions_CreateSessionModification function.
 */
EOS_STRUCT(EOS_Sessions_CreateSessionModificationOptions, (
	/** API Version: Set this to EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to create */
	const char* SessionName;
	/** Bucket ID associated with the session */
	const char* BucketId;
	/** Maximum number of players allowed in the session */
	uint32_t MaxPlayers;
	/** The Product User ID of the local user associated with the session */
	EOS_ProductUserId LocalUserId;
	/**
	 * Determines whether or not this session should be the one associated with the local user's presence information.
	 * If true, this session will be associated with presence. Only one session at a time can have this flag true.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_JoinSessionOptions
	 */
	EOS_Bool bPresenceEnabled;
	/**
	 * Optional session id - set to a globally unique value to override the backend assignment
	 * If not specified the backend service will assign one to the session.  Do not mix and match.
	 * This value can be of size [EOS_SESSIONMODIFICATION_MIN_SESSIONIDOVERRIDE_LENGTH, EOS_SESSIONMODIFICATION_MAX_SESSIONIDOVERRIDE_LENGTH]
	 */
	const char* SessionId;
	/**
	 * If true, sanctioned players can neither join nor register with this session and, in the case of join,
	 * will return EOS_EResult code EOS_Sessions_PlayerSanctioned
	 */
	EOS_Bool bSanctionsEnabled;
	/** 
	 * Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are
	 * found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific
	 * header file. If null, the session will be unrestricted.
	 */
	const uint32_t* AllowedPlatformIds;
	/** Number of platform IDs in the array */
	uint32_t AllowedPlatformIdsCount;
));

/** The most recent version of the EOS_Sessions_UpdateSessionModification API. */
#define EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_UpdateSessionModification function.
 */
EOS_STRUCT(EOS_Sessions_UpdateSessionModificationOptions, (
	/** API Version: Set this to EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to update */
	const char* SessionName;
));

/** Max length of an invite ID */
#define EOS_SESSIONS_INVITEID_MAX_LENGTH 64

/** The most recent version of the EOS_Sessions_SendInvite API. */
#define EOS_SESSIONS_SENDINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_SendInvite function.
 */
EOS_STRUCT(EOS_Sessions_SendInviteOptions, (
	/** API Version: Set this to EOS_SESSIONS_SENDINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session associated with the invite */
	const char* SessionName;
	/** The Product User ID of the local user sending the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User of the remote user receiving the invitation */
	EOS_ProductUserId TargetUserId;
));

/**
 * Output parameters for the EOS_Sessions_SendInvite function.
 */
EOS_STRUCT(EOS_Sessions_SendInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_SendInvite */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_SendInvite
 * @param Data A EOS_Sessions_SendInviteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnSendInviteCallback, const EOS_Sessions_SendInviteCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_RejectInvite API. */
#define EOS_SESSIONS_REJECTINVITE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_RejectInvite function.
 */
EOS_STRUCT(EOS_Sessions_RejectInviteOptions, (
	/** API Version: Set this to EOS_SESSIONS_REJECTINVITE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user rejecting the invitation */
	EOS_ProductUserId LocalUserId;
	/** The invite ID to reject */
	const char* InviteId;
));

/**
 * Output parameters for the EOS_Sessions_RejectInvite function.
 */
EOS_STRUCT(EOS_Sessions_RejectInviteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_RejectInvite */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_RejectInvite
 * @param Data A EOS_Sessions_RejectInviteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnRejectInviteCallback, const EOS_Sessions_RejectInviteCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_QueryInvites API. */
#define EOS_SESSIONS_QUERYINVITES_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_QueryInvites function.
 */
EOS_STRUCT(EOS_Sessions_QueryInvitesOptions, (
	/** API Version: Set this to EOS_SESSIONS_QUERYINVITES_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to query for invitations */
	EOS_ProductUserId LocalUserId;
));

/**
 * Output parameters for the EOS_Sessions_QueryInvites function.
 */
EOS_STRUCT(EOS_Sessions_QueryInvitesCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_QueryInvites */
	void* ClientData;
	/** The Product User of the local user who made the request */
	EOS_ProductUserId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_QueryInvites
 * @param Data A EOS_Sessions_QueryInvites CallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnQueryInvitesCallback, const EOS_Sessions_QueryInvitesCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_GetInviteCount API. */
#define EOS_SESSIONS_GETINVITECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_GetInviteCount function.
 */
EOS_STRUCT(EOS_Sessions_GetInviteCountOptions, (
	/** API Version: Set this to EOS_SESSIONS_GETINVITECOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who has one or more invitations in the cache */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Sessions_GetInviteIdByIndex API. */
#define EOS_SESSIONS_GETINVITEIDBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_GetInviteIdByIndex function.
 */
EOS_STRUCT(EOS_Sessions_GetInviteIdByIndexOptions, (
	/** API Version: Set this to EOS_SESSIONS_GETINVITEIDBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who has an invitation in the cache */
	EOS_ProductUserId LocalUserId;
	/** Index of the invite ID to retrieve */
	uint32_t Index;
));

/** The most recent version of the EOS_Sessions_CreateSessionSearch API. */
#define EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CreateSessionSearch function.
 */
EOS_STRUCT(EOS_Sessions_CreateSessionSearchOptions, (
	/** API Version: Set this to EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST. */
	int32_t ApiVersion;
	/** Max number of results to return */
	uint32_t MaxSearchResults;
));

/** The most recent version of the EOS_Sessions_UpdateSession API. */
#define EOS_SESSIONS_UPDATESESSION_API_LATEST 1
EOS_STRUCT(EOS_Sessions_UpdateSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_UPDATESESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Builder handle */
	EOS_HSessionModification SessionModificationHandle;
));

/**
 * Output parameters for the EOS_Sessions_UpdateSession function.
 */
EOS_STRUCT(EOS_Sessions_UpdateSessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_UpdateSession */
	void* ClientData;
	/** Name of the session that was created/modified */
	const char* SessionName;
	/** ID of the session that was created/modified */
	const char* SessionId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_UpdateSession
 * @param Data A EOS_Sessions_UpdateSessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnUpdateSessionCallback, const EOS_Sessions_UpdateSessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_DestroySession API. */
#define EOS_SESSIONS_DESTROYSESSION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_DestroySession function.
 */
EOS_STRUCT(EOS_Sessions_DestroySessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_DESTROYSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to destroy */
	const char* SessionName;
));

/**
 * Output parameters for the EOS_Sessions_DestroySession function.
 */
EOS_STRUCT(EOS_Sessions_DestroySessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_DestroySession */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_DestroySession
 * @param Data A EOS_Sessions_DestroySessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnDestroySessionCallback, const EOS_Sessions_DestroySessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_JoinSession API. */
#define EOS_SESSIONS_JOINSESSION_API_LATEST 2

/**
 * Input parameters for the EOS_Sessions_JoinSession function.
 */
EOS_STRUCT(EOS_Sessions_JoinSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_JOINSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to create after joining session */
	const char* SessionName;
	/** Session handle to join */
	EOS_HSessionDetails SessionHandle;
	/** The Product User ID of the local user who is joining the session */
	EOS_ProductUserId LocalUserId;
	/**
	 * Determines whether or not this session should be the one associated with the local user's presence information.
	 * If true, this session will be associated with presence. Only one session at a time can have this flag true.
	 * This affects the ability of the Social Overlay to show game related actions to take in the user's social graph.
	 *
	 * @note The Social Overlay can handle only one of the following three options at a time:
	 * * using the bPresenceEnabled flags within the Sessions interface
	 * * using the bPresenceEnabled flags within the Lobby interface
	 * * using EOS_PresenceModification_SetJoinInfo
	 *
	 * @see EOS_PresenceModification_SetJoinInfoOptions
	 * @see EOS_Lobby_CreateLobbyOptions
	 * @see EOS_Lobby_JoinLobbyOptions
	 * @see EOS_Sessions_CreateSessionModificationOptions
	 */
	EOS_Bool bPresenceEnabled;
));

/**
 * Output parameters for the EOS_Sessions_JoinSession function.
 */
EOS_STRUCT(EOS_Sessions_JoinSessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_JoinSession */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_JoinSession
 * @param Data A EOS_Sessions_JoinSessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnJoinSessionCallback, const EOS_Sessions_JoinSessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_StartSession API. */
#define EOS_SESSIONS_STARTSESSION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_StartSession function.
 */
EOS_STRUCT(EOS_Sessions_StartSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_STARTSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to set in progress */
	const char* SessionName;
));

EOS_STRUCT(EOS_Sessions_StartSessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_StartSession */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_StartSession
 * @param Data A EOS_Sessions_StartSessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnStartSessionCallback, const EOS_Sessions_StartSessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_EndSession API. */
#define EOS_SESSIONS_ENDSESSION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_EndSession function.
 */
EOS_STRUCT(EOS_Sessions_EndSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_ENDSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session to set as no long in progress */
	const char* SessionName;
));

EOS_STRUCT(EOS_Sessions_EndSessionCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_EndSession */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_EndSession
 * @param Data A EOS_Sessions_EndSessionCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnEndSessionCallback, const EOS_Sessions_EndSessionCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_RegisterPlayers API. */
#define EOS_SESSIONS_REGISTERPLAYERS_API_LATEST 3

/**
 * Input parameters for the EOS_Sessions_RegisterPlayers function.
 */
EOS_STRUCT(EOS_Sessions_RegisterPlayersOptions, (
	/** API Version: Set this to EOS_SESSIONS_REGISTERPLAYERS_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session for which to register players */
	const char* SessionName;
	/** Array of players to register with the session */
	EOS_ProductUserId* PlayersToRegister;
	/** Number of players in the array */
	uint32_t PlayersToRegisterCount;
));

EOS_STRUCT(EOS_Sessions_RegisterPlayersCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_RegisterPlayers */
	void* ClientData;
	/** The players that were successfully registered */
	EOS_ProductUserId* RegisteredPlayers;
	/** The number of players successfully registered */
	uint32_t RegisteredPlayersCount;
	/** The players that failed to register because they are sanctioned */
	EOS_ProductUserId* SanctionedPlayers;
	/** The number of players that failed to register because they are sanctioned */
	uint32_t SanctionedPlayersCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_RegisterPlayers
 * @param Data A EOS_Sessions_RegisterPlayersCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnRegisterPlayersCallback, const EOS_Sessions_RegisterPlayersCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_UnregisterPlayers API. */
#define EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST 2

/**
 * Input parameters for the EOS_Sessions_UnregisterPlayers function.
 */
EOS_STRUCT(EOS_Sessions_UnregisterPlayersOptions, (
	/** API Version: Set this to EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session for which to unregister players */
	const char* SessionName;
	/** Array of players to unregister from the session */
	EOS_ProductUserId* PlayersToUnregister;
	/** Number of players in the array */
	uint32_t PlayersToUnregisterCount;
));

EOS_STRUCT(EOS_Sessions_UnregisterPlayersCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Sessions_UnregisterPlayers */
	void* ClientData;
	/** The players that successfully unregistered */
	EOS_ProductUserId* UnregisteredPlayers;
	/** The number of players that successfully unregistered */
	uint32_t UnregisteredPlayersCount;
));

/**
 * Function prototype definition for callbacks passed to EOS_Sessions_UnregisterPlayers
 * @param Data A EOS_Sessions_UnregisterPlayersCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnUnregisterPlayersCallback, const EOS_Sessions_UnregisterPlayersCallbackInfo* Data);

/** The most recent version of the EOS_SessionModification_SetBucketId API. */
#define EOS_SESSIONMODIFICATION_SETBUCKETID_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetBucketId function.
 */
EOS_STRUCT(EOS_SessionModification_SetBucketIdOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETBUCKETID_API_LATEST. */
	int32_t ApiVersion;
	/** The new bucket id associated with the session */
	const char* BucketId;
));

/** The most recent version of the EOS_SessionModification_SetHostAddress API. */
#define EOS_SESSIONMODIFICATION_SETHOSTADDRESS_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetHostAddress function.
 */
EOS_STRUCT(EOS_SessionModification_SetHostAddressOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETHOSTADDRESS_API_LATEST. */
	int32_t ApiVersion;
	/** A string representing the host address for the session, its meaning is up to the application */
	const char* HostAddress;
));

/** Permission level gets more restrictive further down */
EOS_ENUM(EOS_EOnlineSessionPermissionLevel,
	/** Anyone can find this session as long as it isn't full */
	EOS_OSPF_PublicAdvertised = 0,
	/** Players who have access to presence can see this session */
	EOS_OSPF_JoinViaPresence = 1,
	/** Only players with invites registered can see this session */
	EOS_OSPF_InviteOnly = 2
);

/** The most recent version of the EOS_SessionModification_SetPermissionLevel API. */
#define EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetPermissionLevel function.
 */
EOS_STRUCT(EOS_SessionModification_SetPermissionLevelOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST. */
	int32_t ApiVersion;
	/** Permission level to set on the session */
	EOS_EOnlineSessionPermissionLevel PermissionLevel;
));

/** The most recent version of the EOS_SessionModification_SetJoinInProgressAllowed API. */
#define EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetJoinInProgressAllowed function.
 */
EOS_STRUCT(EOS_SessionModification_SetJoinInProgressAllowedOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST. */
	int32_t ApiVersion;
	/** Does the session allow join in progress */
	EOS_Bool bAllowJoinInProgress;
));

/** Maximum number of players allowed in a single session */
#define EOS_SESSIONS_MAXREGISTEREDPLAYERS 1000

/** The most recent version of the EOS_SessionModification_SetMaxPlayers API. */
#define EOS_SESSIONMODIFICATION_SETMAXPLAYERS_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetMaxPlayers function.
 */
EOS_STRUCT(EOS_SessionModification_SetMaxPlayersOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETMAXPLAYERS_API_LATEST. */
	int32_t ApiVersion;
	/** Max number of players to allow in the session */
	uint32_t MaxPlayers;
));

/** The most recent version of the EOS_SessionModification_SetInvitesAllowed API. */
#define EOS_SESSIONMODIFICATION_SETINVITESALLOWED_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetInvitesAllowed function.
 */
EOS_STRUCT(EOS_SessionModification_SetInvitesAllowedOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETINVITESALLOWED_API_LATEST. */
	int32_t ApiVersion;
	/** If true then invites can currently be sent for the associated session */
	EOS_Bool bInvitesAllowed;
));

/** The most recent version of the EOS_SessionModification_SetAllowedPlatformIds API. */
#define EOS_SESSIONMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_SetAllowedPlatformIds function.
 */
EOS_STRUCT(EOS_SessionModification_SetAllowedPlatformIdsOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST. */
	int32_t ApiVersion;
	/** 
	 * Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are
	 * found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific
	 * header file. If null, the session will be unrestricted.
	 */
	const uint32_t* AllowedPlatformIds;
	/** Number of platform IDs in the array */
	uint32_t AllowedPlatformIdsCount;
));

/** Search for a matching bucket ID (value is string) */
#define EOS_SESSIONS_SEARCH_BUCKET_ID "bucket"
/** Search for empty servers only (value is true/false) */
#define EOS_SESSIONS_SEARCH_EMPTY_SERVERS_ONLY "emptyonly"
/** Search for non empty servers only (value is true/false) */
#define EOS_SESSIONS_SEARCH_NONEMPTY_SERVERS_ONLY "nonemptyonly"
/** Search for a match with min free space (value is int) */
#define EOS_SESSIONS_SEARCH_MINSLOTSAVAILABLE "minslotsavailable"

/** The most recent version of the EOS_Sessions_AttributeData struct. */
#define EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST 1

/** DEPRECATED! Use EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST instead. */
#define EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST

/**
 * Contains information about both session and search parameter attribution
 */
EOS_STRUCT(EOS_Sessions_AttributeData, (
	/** API Version: Set this to EOS_SESSIONS_ATTRIBUTEDATA_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session attribute */
	const char* Key;
	union
	{
		/** Stored as an 8 byte integer */
		int64_t AsInt64;
		/** Stored as a double precision floating point */
		double AsDouble;
		/** Stored as a boolean */
		EOS_Bool AsBool;
		/** Stored as a null terminated UTF8 string. Should not be nullptr */
		const char* AsUtf8;
	} Value;

	/** Type of value stored in the union */
	EOS_ESessionAttributeType ValueType;
));

/** The most recent version of the EOS_ActiveSession_CopyInfo function. */
#define EOS_ACTIVESESSION_COPYINFO_API_LATEST 1

/**
 * Input parameters for the EOS_ActiveSession_CopyInfo function.
 */
EOS_STRUCT(EOS_ActiveSession_CopyInfoOptions, (
	/** API Version: Set this to EOS_ACTIVESESSION_COPYINFO_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_ActiveSession_GetRegisteredPlayerCount function. */
#define EOS_ACTIVESESSION_GETREGISTEREDPLAYERCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_ActiveSession_GetRegisteredPlayerCount function.
 */
EOS_STRUCT(EOS_ActiveSession_GetRegisteredPlayerCountOptions, (
	/** API Version: Set this to EOS_ACTIVESESSION_GETREGISTEREDPLAYERCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_ActiveSession_GetRegisteredPlayerByIndex function. */
#define EOS_ACTIVESESSION_GETREGISTEREDPLAYERBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_ActiveSession_GetRegisteredPlayerByIndex function.
 */
EOS_STRUCT(EOS_ActiveSession_GetRegisteredPlayerByIndexOptions, (
	/** API Version: Set this to EOS_ACTIVESESSION_GETREGISTEREDPLAYERBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Index of the registered player to retrieve */
	uint32_t PlayerIndex;
));

/** The most recent version of the EOS_SessionDetails_Attribute struct. */
#define EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST 1

/** DEPRECATED! Use EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST instead. */
#define EOS_SESSIONS_SESSIONATTRIBUTE_API_LATEST EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST

/**
 *  An attribution value and its advertisement setting stored with a session.
 */
EOS_STRUCT(EOS_SessionDetails_Attribute, (
	/** API Version: Set this to EOS_SESSIONDETAILS_ATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute */
	EOS_Sessions_AttributeData* Data;
	/** Is this attribution advertised with the backend or simply stored locally */
	EOS_ESessionAttributeAdvertisementType AdvertisementType;
));

/**
 * Release the memory associated with a session attribute. This must be called on data retrieved from EOS_SessionDetails_CopySessionAttributeByIndex.
 *
 * @param SessionAttribute - The session attribute to release
 *
 * @see EOS_SessionDetails_CopySessionAttributeByIndex
 */
EOS_DECLARE_FUNC(void) EOS_SessionDetails_Attribute_Release(EOS_SessionDetails_Attribute* SessionAttribute);


/** The most recent version of the EOS_SessionModification_AddAttribute API. */
#define EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST 2

/**
 * Input parameters for the EOS_SessionModification_AddAttribute function.
 */
EOS_STRUCT(EOS_SessionModification_AddAttributeOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Key/Value pair describing the attribute to add to the session */
	const EOS_Sessions_AttributeData* SessionAttribute;
	/** Is this attribution advertised with the backend or simply stored locally */
	EOS_ESessionAttributeAdvertisementType AdvertisementType;
));

/** The most recent version of the EOS_SessionModification_RemoveAttribute API. */
#define EOS_SESSIONMODIFICATION_REMOVEATTRIBUTE_API_LATEST 1

/**
 * Input parameters for the EOS_SessionModification_RemoveAttribute function.
 */
EOS_STRUCT(EOS_SessionModification_RemoveAttributeOptions, (
	/** API Version: Set this to EOS_SESSIONMODIFICATION_REMOVEATTRIBUTE_API_LATEST. */
	int32_t ApiVersion;
	/** Session attribute to remove from the session */
	const char* Key;
));

/** Maximum number of search results allowed with a given query */
#define EOS_SESSIONS_MAX_SEARCH_RESULTS 200

/** The most recent version of the EOS_SessionSearch_SetMaxResults API. */
#define EOS_SESSIONSEARCH_SETMAXSEARCHRESULTS_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_SetMaxResults function.
 */
EOS_STRUCT(EOS_SessionSearch_SetMaxResultsOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_SETMAXSEARCHRESULTS_API_LATEST. */
	int32_t ApiVersion;
	/** Maximum number of search results returned with this query, may not exceed EOS_SESSIONS_MAX_SEARCH_RESULTS */
	uint32_t MaxSearchResults;
));

/** The most recent version of the EOS_SessionSearch_Find API. */
#define EOS_SESSIONSEARCH_FIND_API_LATEST 2

/**
 * Input parameters for the EOS_SessionSearch_Find function.
 */
EOS_STRUCT(EOS_SessionSearch_FindOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_FIND_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user who is searching */
	EOS_ProductUserId LocalUserId;
));

EOS_STRUCT(EOS_SessionSearch_FindCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_SessionSearch_Find */
	void* ClientData;
));

/**
 * Function prototype definition for callbacks passed to EOS_SessionSearch_Find
 * @param Data A EOS_SessionSearch_FindCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_SessionSearch_OnFindCallback, const EOS_SessionSearch_FindCallbackInfo* Data);

/** The most recent version of the EOS_SessionSearch_GetSearchResultCount API. */
#define EOS_SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_GetSearchResultCount function.
 */
EOS_STRUCT(EOS_SessionSearch_GetSearchResultCountOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_SessionSearch_CopySearchResultByIndex API. */
#define EOS_SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_CopySearchResultByIndex function.
 */
EOS_STRUCT(EOS_SessionSearch_CopySearchResultByIndexOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The index of the session to retrieve within the completed search query
	 * @see EOS_SessionSearch_GetSearchResultCount
	 */
	uint32_t SessionIndex;
));

/** The most recent version of the EOS_SessionSearch_SetSessionId API. */
#define EOS_SESSIONSEARCH_SETSESSIONID_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_SetSessionId function.
 */
EOS_STRUCT(EOS_SessionSearch_SetSessionIdOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_SETSESSIONID_API_LATEST. */
	int32_t ApiVersion;
	/** Search sessions for a specific session ID, returning at most one session */
	const char* SessionId;
));

/** The most recent version of the EOS_SessionSearch_SetTargetUserId API. */
#define EOS_SESSIONSEARCH_SETTARGETUSERID_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_SetTargetUserId function.
 */
EOS_STRUCT(EOS_SessionSearch_SetTargetUserIdOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_SETTARGETUSERID_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID to find; return any sessions where the user matching this ID is currently registered */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_SessionSearch_SetParameter API. */
#define EOS_SESSIONSEARCH_SETPARAMETER_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_SetParameter function.
 *
 * A search key may be set more than once to make multiple comparisons
 * The two comparisons are AND'd together
 * (ie, Key GREATER_THAN 5, Key NOT_EQUALS 10)
 */
EOS_STRUCT(EOS_SessionSearch_SetParameterOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_SETPARAMETER_API_LATEST. */
	int32_t ApiVersion;
	/** Search parameter describing a key and a value to compare */
	const EOS_Sessions_AttributeData* Parameter;
	/** The type of comparison to make against the search parameter */
	EOS_EOnlineComparisonOp ComparisonOp;
));

/** The most recent version of the EOS_SessionSearch_RemoveParameter API. */
#define EOS_SESSIONSEARCH_REMOVEPARAMETER_API_LATEST 1

/**
 * Input parameters for the EOS_SessionSearch_RemoveParameter function.
 *
 * Removal requires both the key and its comparator in order to remove as the same key can be used in more than one operation
 */
EOS_STRUCT(EOS_SessionSearch_RemoveParameterOptions, (
	/** API Version: Set this to EOS_SESSIONSEARCH_REMOVEPARAMETER_API_LATEST. */
	int32_t ApiVersion;
	/** Search parameter key to remove from the search */
	const char* Key;
	/** Search comparison operation associated with the key to remove */
	EOS_EOnlineComparisonOp ComparisonOp;
));

/** The most recent version of the EOS_SessionDetails_Settings struct. */
#define EOS_SESSIONDETAILS_SETTINGS_API_LATEST 4

/** Common settings associated with a single session */
EOS_STRUCT(EOS_SessionDetails_Settings, (
	/** API Version: Set this to EOS_SESSIONDETAILS_SETTINGS_API_LATEST. */
	int32_t ApiVersion;
	/** The main indexed parameter for this session, can be any string (i.e. "Region:GameMode") */
	const char* BucketId;
	/** Number of total players allowed in the session */
	uint32_t NumPublicConnections;
	/** Are players allowed to join the session while it is in the "in progress" state */
	EOS_Bool bAllowJoinInProgress;
	/** Permission level describing allowed access to the session when joining or searching for the session */
	EOS_EOnlineSessionPermissionLevel PermissionLevel;
	/** Are players allowed to send invites for the session */
	EOS_Bool bInvitesAllowed;
	/** Are sanctioned players allowed to join - sanctioned players will be rejected if set to true */
	EOS_Bool bSanctionsEnabled;
	/** 
	 * Array of platform IDs indicating the player platforms allowed to register with the session. Platform IDs are
	 * found in the EOS header file, e.g. EOS_OPT_Epic. For some platforms, the value will be in the EOS Platform specific
	 * header file. If null, the session will be unrestricted.
	 */
	const uint32_t* AllowedPlatformIds;
	/** Number of platform IDs in the array */
	uint32_t AllowedPlatformIdsCount;
));

/** The most recent version of the EOS_SessionDetails_Info struct. */
#define EOS_SESSIONDETAILS_INFO_API_LATEST 2

/** Internal details about a session, found on both active sessions and within search results */
EOS_STRUCT(EOS_SessionDetails_Info, (
	/** API Version: Set this to EOS_SESSIONDETAILS_INFO_API_LATEST. */
	int32_t ApiVersion;
	/** Session ID assigned by the backend service */
	const char* SessionId;
	/** IP address of this session as visible by the backend service */
	const char* HostAddress;
	/** Number of remaining open spaces on the session (NumPublicConnections - RegisteredPlayers */
	uint32_t NumOpenPublicConnections;
	/** Reference to the additional settings associated with this session */
	const EOS_SessionDetails_Settings* Settings;
	/** The Product User ID of the session owner. Null if the session is not owned by a user. */
	EOS_ProductUserId OwnerUserId;
	/** The client id of the session owner. Null if the session is not owned by a server. The session is owned by a server if EOS_Platform_Options::bIsServer is EOS_TRUE. */
	const char* OwnerServerClientId;
));

EOS_DECLARE_FUNC(void) EOS_SessionDetails_Info_Release(EOS_SessionDetails_Info* SessionInfo);

/** The most recent version of the EOS_SessionDetails_CopyInfo API. */
#define EOS_SESSIONDETAILS_COPYINFO_API_LATEST 1

/**
 * Input parameters for the EOS_SessionDetails_CopyInfo function.
 */
EOS_STRUCT(EOS_SessionDetails_CopyInfoOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_COPYINFO_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_SessionDetails_GetSessionAttributeCount API. */
#define EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_SessionDetails_GetSessionAttributeCount function.
 */
EOS_STRUCT(EOS_SessionDetails_GetSessionAttributeCountOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_SessionDetails_CopySessionAttributeByIndex API. */
#define EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_SessionDetails_CopySessionAttributeByIndex function.
 */
EOS_STRUCT(EOS_SessionDetails_CopySessionAttributeByIndexOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The index of the attribute to retrieve
	 * @see EOS_SessionDetails_GetSessionAttributeCount
	 */
	uint32_t AttrIndex;
));

/** The most recent version of the EOS_SessionDetails_CopySessionAttributeByKey API. */
#define EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYKEY_API_LATEST 1

/**
 * Input parameters for the EOS_SessionDetails_CopySessionAttributeByKey function.
 */
EOS_STRUCT(EOS_SessionDetails_CopySessionAttributeByKeyOptions, (
	/** API Version: Set this to EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYKEY_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the key to get the session attribution for
	 * @see EOS_SessionModification_AddAttribute
	 */
	const char* AttrKey;
));

/** The most recent version of the EOS_ActiveSession_Info struct. */
#define EOS_ACTIVESESSION_INFO_API_LATEST 1

/**
 * Top level details about an active session
 */
EOS_STRUCT(EOS_ActiveSession_Info, (
	/** API Version: Set this to EOS_ACTIVESESSION_INFO_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session */
	const char* SessionName;
	/** The Product User ID of the local user who created or joined the session */
	EOS_ProductUserId LocalUserId;
	/** Current state of the session */
	EOS_EOnlineSessionState State;
	/** Session details */
	const EOS_SessionDetails_Info* SessionDetails;
));

/**
 * Release the memory associated with an EOS_ActiveSession_Info structure. This must be called on data retrieved from EOS_ActiveSession_CopyInfo.
 *
 * @param ActiveSessionInfo - The active session structure to be released
 *
 * @see EOS_ActiveSession_Info
 * @see EOS_ActiveSession_CopyInfo
 */
EOS_DECLARE_FUNC(void) EOS_ActiveSession_Info_Release(EOS_ActiveSession_Info* ActiveSessionInfo);

/** The most recent version of the EOS_Sessions_CopyActiveSessionHandle API. */
#define EOS_SESSIONS_COPYACTIVESESSIONHANDLE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CopyActiveSessionHandle function.
 */
EOS_STRUCT(EOS_Sessions_CopyActiveSessionHandleOptions, (
	/** API Version: Set this to EOS_SESSIONS_COPYACTIVESESSIONHANDLE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session for which to retrieve a session handle */
	const char* SessionName;
));

/** The most recent version of the EOS_Sessions_AddNotifySessionInviteReceived API. */
#define EOS_SESSIONS_ADDNOTIFYSESSIONINVITERECEIVED_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_AddNotifySessionInviteReceived function.
 */
EOS_STRUCT(EOS_Sessions_AddNotifySessionInviteReceivedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYSESSIONINVITERECEIVED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnSessionInviteReceivedCallback function.
 */
EOS_STRUCT(EOS_Sessions_SessionInviteReceivedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_AddNotifySessionInviteReceived */
	void* ClientData;
	/** The Product User ID of the user who received the invite */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
	/** Invite ID used to retrieve the actual session details */
	const char* InviteId;
));

/**
 * Function prototype definition for notifications that come from EOS_Sessions_AddNotifySessionInviteReceived
 *
 * @param Data A EOS_Sessions_SessionInviteReceivedCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnSessionInviteReceivedCallback, const EOS_Sessions_SessionInviteReceivedCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_AddNotifySessionInviteAccepted API. */
#define EOS_SESSIONS_ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_AddNotifySessionInviteAccepted function.
 */
EOS_STRUCT(EOS_Sessions_AddNotifySessionInviteAcceptedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnSessionInviteAcceptedCallback function.
 */
EOS_STRUCT(EOS_Sessions_SessionInviteAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_AddNotifySessionInviteAccepted */
	void* ClientData;
	/** Session ID that should be used for joining */
	const char* SessionId;
	/** The Product User ID of the user who accepted the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
	/** Invite ID that was accepted */
	const char* InviteId;
));

/**
 * Function prototype definition for notifications that come from EOS_Sessions_AddNotifySessionInviteAccepted
 *
 * @param Data A EOS_Sessions_SessionInviteAcceptedCallbackInfo containing the output information and result
 *
 * @note The session for the invite must be joined.
 *
 * @see EOS_Sessions_CopySessionHandleByInviteId
 * @see EOS_Sessions_JoinSession
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnSessionInviteAcceptedCallback, const EOS_Sessions_SessionInviteAcceptedCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_AddNotifySessionInviteAccepted API. */
#define EOS_SESSIONS_ADDNOTIFYSESSIONINVITEREJECTED_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_AddNotifySessionInviteRejected function.
 */
EOS_STRUCT(EOS_Sessions_AddNotifySessionInviteRejectedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYSESSIONINVITEREJECTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnSessionInviteRejectedCallback function.
 */
EOS_STRUCT(EOS_Sessions_SessionInviteRejectedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_AddNotifySessionInviteRejected */
	void* ClientData;
	/** The invite ID */
	const char* InviteId;
	/** The Product User ID of the local user who rejected the invitation */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID of the user who sent the invitation */
	EOS_ProductUserId TargetUserId;
	/** Optional session ID */
	const char* SessionId;
));

/**
 * Function prototype definition for notifications that come from EOS_Sessions_AddNotifySessionInviteRejected
 *
 * @param Data A EOS_Sessions_SessionInviteRejectedCallbackInfo containing the output information and result
 *
 * @see EOS_Sessions_CopySessionHandleByInviteId
 * @see EOS_Sessions_JoinSession
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnSessionInviteRejectedCallback, const EOS_Sessions_SessionInviteRejectedCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_AddNotifyJoinSessionAccepted API. */
#define EOS_SESSIONS_ADDNOTIFYJOINSESSIONACCEPTED_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_AddNotifyJoinSessionAccepted function.
 */
EOS_STRUCT(EOS_Sessions_AddNotifyJoinSessionAcceptedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYJOINSESSIONACCEPTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnJoinSessionAcceptedCallback function.
 */
EOS_STRUCT(EOS_Sessions_JoinSessionAcceptedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_AddNotifyJoinSessionAccepted */
	void* ClientData;
	/** The Product User ID for the user who initialized the game */
	EOS_ProductUserId LocalUserId;
	/**
	 * The UI Event associated with this Join Game event.
	 * This should be used with EOS_Sessions_CopySessionHandleByUiEventId to get a handle to be used
	 * when calling EOS_Sessions_JoinSession.
	 */
	EOS_UI_EventId UiEventId;
));

/**
 * Function prototype definition for notifications that come from EOS_Sessions_AddNotifyJoinSessionAccepted
 *
 * @param Data A EOS_Sessions_JoinSessionAcceptedCallbackInfo containing the output information and result
 *
 * @note The session for the join game must be joined.
 *
 * @see EOS_Sessions_CopySessionHandleByUiEventId
 * @see EOS_Sessions_JoinSession
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnJoinSessionAcceptedCallback, const EOS_Sessions_JoinSessionAcceptedCallbackInfo* Data);


/** The most recent version of the EOS_Sessions_CopySessionHandleByInviteId API. */
#define EOS_SESSIONS_COPYSESSIONHANDLEBYINVITEID_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CopySessionHandleByInviteId function.
 */
EOS_STRUCT(EOS_Sessions_CopySessionHandleByInviteIdOptions, (
	/** API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEBYINVITEID_API_LATEST. */
	int32_t ApiVersion;
	/** Invite ID for which to retrieve a session handle */
	const char* InviteId;
));

/** The most recent version of the EOS_Sessions_CopySessionHandleByUiEventId API. */
#define EOS_SESSIONS_COPYSESSIONHANDLEBYUIEVENTID_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CopySessionHandleByUiEventId function.
 */
EOS_STRUCT(EOS_Sessions_CopySessionHandleByUiEventIdOptions, (
	/** API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEBYUIEVENTID_API_LATEST. */
	int32_t ApiVersion;
	/** UI Event associated with the session */
	EOS_UI_EventId UiEventId;
));

/** The most recent version of the EOS_Sessions_CopySessionHandleForPresence API. */
#define EOS_SESSIONS_COPYSESSIONHANDLEFORPRESENCE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_CopySessionHandleForPresence function.
 */
EOS_STRUCT(EOS_Sessions_CopySessionHandleForPresenceOptions, (
	/** API Version: Set this to EOS_SESSIONS_COPYSESSIONHANDLEFORPRESENCE_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user associated with the session */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_Sessions_IsUserInSession API. */
#define EOS_SESSIONS_ISUSERINSESSION_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_IsUserInSession function.
 */
EOS_STRUCT(EOS_Sessions_IsUserInSessionOptions, (
	/** API Version: Set this to EOS_SESSIONS_ISUSERINSESSION_API_LATEST. */
	int32_t ApiVersion;
	/** Active session name to search within */
	const char* SessionName;
	/** Product User ID to search for in the session */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_Sessions_DumpSessionState API. */
#define EOS_SESSIONS_DUMPSESSIONSTATE_API_LATEST 1

/**
 * Input parameters for the EOS_Sessions_DumpSessionState function.
 */
EOS_STRUCT(EOS_Sessions_DumpSessionStateOptions, (
	/** API Version: Set this to EOS_SESSIONS_DUMPSESSIONSTATE_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the session */
	const char* SessionName;
));

/** The most recent version of the EOS_Sessions_AddNotifyLeaveSessionRequested API. */
#define EOS_SESSIONS_ADDNOTIFYLEAVESESSIONREQUESTED_API_LATEST 1

EOS_STRUCT(EOS_Sessions_AddNotifyLeaveSessionRequestedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYLEAVESESSIONREQUESTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnLeaveSessionRequestedCallback Function.
 */
EOS_STRUCT(EOS_Sessions_LeaveSessionRequestedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_OnLeaveSessionRequestedCallback */
	void* ClientData;
	/** The Product User ID of the local user who received the leave session notification. */
	EOS_ProductUserId LocalUserId;
	/** Name of the session associated with the leave session request. */
	const char* SessionName;
));

/**
 * Function prototype definition for notifications that comes from EOS_Sessions_AddNotifyLeaveSessionRequested.
 *
 * @param Data A pointer to EOS_Sessions_LeaveSessionRequestedCallbackInfo containing the output information.
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnLeaveSessionRequestedCallback, const EOS_Sessions_LeaveSessionRequestedCallbackInfo* Data);

/** The most recent version of the EOS_Sessions_AddNotifySendSessionNativeInviteRequested API. */
#define EOS_SESSIONS_ADDNOTIFYSENDSESSIONNATIVEINVITEREQUESTED_API_LATEST 1

EOS_STRUCT(EOS_Sessions_AddNotifySendSessionNativeInviteRequestedOptions, (
	/** API Version: Set this to EOS_SESSIONS_ADDNOTIFYSENDSESSIONNATIVEINVITEREQUESTED_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Sessions_OnSendSessionNativeInviteRequestedCallback Function.
 */
EOS_STRUCT(EOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo, (
	/** Context that was passed into EOS_Sessions_AddNotifySendSessionNativeInviteRequested */
	void* ClientData;
	/**
	 * Identifies this event which will need to be acknowledged with EOS_UI_AcknowledgeEventId().
	 * @see EOS_UI_AcknowledgeEventId
	 */
	EOS_UI_EventId UiEventId;
	/** The Product User ID of the local user who is inviting. */
	EOS_ProductUserId LocalUserId;
	/**
	 * The Native Platform Account Type. If only a single integrated platform is configured then
	 * this will always reference that platform.
	 */
	EOS_IntegratedPlatformType TargetNativeAccountType;
	/** The Native Platform Account ID of the target user being invited. */
	const char* TargetUserNativeAccountId;
	/** Session ID that the user is being invited to */
	const char* SessionId;
));

/**
 * Function prototype definition for notifications that comes from EOS_Sessions_AddNotifySendSessionNativeInviteRequested
 *
 * @param Data A EOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo containing the output information and result
 *
 * @note After processing the callback EOS_UI_AcknowledgeEventId must be called.
 *
 * @see EOS_UI_AcknowledgeEventId
 */
EOS_DECLARE_CALLBACK(EOS_Sessions_OnSendSessionNativeInviteRequestedCallback, const EOS_Sessions_SendSessionNativeInviteRequestedCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_stats.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_stats_types.h"

/**
 * The Stats Interface manages user stats like number of items collected, fastest completion time for a level, number of wins/losses, number of times that a user has performed a certain action, and so on.
 * You can use stats to determine when to unlock achievements and how to use rank users in leaderboards.
 * All Stats Interface calls take a handle of type EOS_HStats as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetStatsInterface function.
 *
 * @see EOS_Platform_GetStatsInterface
 */

/**
 * Ingest a stat by the amount specified in Options.
 * When the operation is complete and the delegate is triggered the stat will be uploaded to the backend to be processed.
 * The stat may not be updated immediately and an achievement using the stat may take a while to be unlocked once the stat has been uploaded.
 *
 * @param Options Structure containing information about the stat we're ingesting.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate This function is called when the ingest stat operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_InvalidUser if target user ID is missing or incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Stats_IngestStat(EOS_HStats Handle, const EOS_Stats_IngestStatOptions* Options, void* ClientData, const EOS_Stats_OnIngestStatCompleteCallback CompletionDelegate);

/**
 * Query for a list of stats for a specific player.
 *
 * @param Options Structure containing information about the player whose stats we're retrieving.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate This function is called when the query player stats operation completes.
 *
 * @return EOS_Success if the operation completes successfully
 *         EOS_InvalidParameters if any of the options are incorrect
 *         EOS_InvalidUser if target user ID is missing or incorrect
 */
EOS_DECLARE_FUNC(void) EOS_Stats_QueryStats(EOS_HStats Handle, const EOS_Stats_QueryStatsOptions* Options, void* ClientData, const EOS_Stats_OnQueryStatsCompleteCallback CompletionDelegate);

/**
 * Fetch the number of stats that are cached locally.
 *
 * @param Options The Options associated with retrieving the stat count
 *
 * @see EOS_Stats_CopyStatByIndex
 *
 * @return Number of stats or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_Stats_GetStatsCount(EOS_HStats Handle, const EOS_Stats_GetStatCountOptions* Options);

/**
 * Fetches a stat from a given index. Use EOS_Stats_Stat_Release when finished with the data.
 *
 * @param Options Structure containing the Product User ID and index being accessed
 * @param OutStat The stat data for the given index, if it exists and is valid
 *
 * @see EOS_Stats_Stat_Release
 *
 * @return EOS_Success if the information is available and passed out in OutStat
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the stat is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Stats_CopyStatByIndex(EOS_HStats Handle, const EOS_Stats_CopyStatByIndexOptions* Options, EOS_Stats_Stat ** OutStat);

/**
 * Fetches a stat from cached stats by name. Use EOS_Stats_Stat_Release when finished with the data.
 *
 * @param Options Structure containing the Product User ID and name being accessed
 * @param OutStat The stat data for the given name, if it exists and is valid
 *
 * @see EOS_Stats_Stat_Release
 *
 * @return EOS_Success if the information is available and passed out in OutStat
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the stat is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_Stats_CopyStatByName(EOS_HStats Handle, const EOS_Stats_CopyStatByNameOptions* Options, EOS_Stats_Stat ** OutStat);

```

`EAC_SDK/SDK/include/eos_stats_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_StatsHandle* EOS_HStats;

/** The most recent version of the EOS_Stats_IngestData struct. */
#define EOS_STATS_INGESTDATA_API_LATEST 1

/**
 * Contains information about a single stat to ingest.
 */
EOS_STRUCT(EOS_Stats_IngestData, (
	/** API Version: Set this to EOS_STATS_INGESTDATA_API_LATEST. */
	int32_t ApiVersion;
	/** The name of the stat to ingest. */
	const char* StatName;
	/** The amount to ingest the stat. */
	int32_t IngestAmount;
));

/** Maximum number of stats that can be ingested in a single EOS_Stats_IngestStat operation. */
#define EOS_STATS_MAX_INGEST_STATS 3000

/** The most recent version of the EOS_Stats_IngestStat struct. */
#define EOS_STATS_INGESTSTAT_API_LATEST 3

/**
 * Input parameters for the EOS_Stats_IngestStat function.
 */
EOS_STRUCT(EOS_Stats_IngestStatOptions, (
	/** API Version: Set this to EOS_STATS_INGESTSTAT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting the ingest.  Set to null for dedicated server. */
	EOS_ProductUserId LocalUserId;
	/** Stats to ingest. */
	const EOS_Stats_IngestData* Stats;
	/** The number of stats to ingest, may not exceed EOS_STATS_MAX_INGEST_STATS. */
	uint32_t StatsCount;
	/** The Product User ID for the user whose stat is being ingested. */
	EOS_ProductUserId TargetUserId;
));

/**
 * Data containing the result information for an ingest stat request.
 * 
 * NOTE: A result code of EOS_Success indicates the ingest request 
 * reached the server successfully, but does not guarantee successful processing. 
 * For example, if an incorrect StatName value is provided in the ingest call, 
 * processing may still fail.
 * 
 */
EOS_STRUCT(EOS_Stats_IngestStatCompleteCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Stats_IngestStat. */
	void* ClientData;
	/** The Product User ID for the user requesting the ingest */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID for the user whose stat is being ingested */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Stats_IngestStat
 * @param Data A EOS_Stats_IngestStatCompleteCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_Stats_OnIngestStatCompleteCallback, const EOS_Stats_IngestStatCompleteCallbackInfo* Data);


/** Maximum number of stats that can be queried in a single EOS_Stats_QueryStats operation. */
#define EOS_STATS_MAX_QUERY_STATS 1000

/** The most recent version of the EOS_Stats_QueryStats struct. */
#define EOS_STATS_QUERYSTATS_API_LATEST 3

/**
 * Input parameters for the EOS_Stats_QueryStats function.
 */
EOS_STRUCT(EOS_Stats_QueryStatsOptions, (
	/** API Version: Set this to EOS_STATS_QUERYSTATS_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the local user requesting the stats. Set to null for dedicated server. */
	EOS_ProductUserId LocalUserId;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for start time (Optional). */
	int64_t StartTime;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for end time (Optional). */
	int64_t EndTime;
	/** An array of stat names to query for (Optional). */
	const char** StatNames;
	/** The number of stat names included in query (Optional), may not exceed EOS_STATS_MAX_QUERY_STATS. */
	uint32_t StatNamesCount;
	/** The Product User ID for the user whose stats are being retrieved */
	EOS_ProductUserId TargetUserId;
));

/** Timestamp value representing an undefined StartTime or EndTime for EOS_Stats_Stat */
#define EOS_STATS_TIME_UNDEFINED -1

/** The most recent version of the EOS_Stats_Stat struct. */
#define EOS_STATS_STAT_API_LATEST 1

/**
 * Contains information about a single player stat.
 */
EOS_STRUCT(EOS_Stats_Stat, (
	/** API Version: Set this to EOS_STATS_STAT_API_LATEST. */
	int32_t ApiVersion;
	/** Name of the stat. */
	const char* Name;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for start time. */
	int64_t StartTime;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for end time. */
	int64_t EndTime;
	/** Current value for the stat. */
	int32_t Value;
));

/** The most recent version of the EOS_Stats_GetStatsCount API. */
#define EOS_STATS_GETSTATSCOUNT_API_LATEST 1

/** DEPRECATED! Use EOS_STATS_GETSTATSCOUNT_API_LATEST instead. */
#define EOS_STATS_GETSTATCOUNT_API_LATEST EOS_STATS_GETSTATSCOUNT_API_LATEST

/**
 * Input parameters for the EOS_Stats_GetStatsCount function.
 */
EOS_STRUCT(EOS_Stats_GetStatCountOptions, (
	/** API Version: Set this to EOS_STATS_GETSTATSCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID for the user whose stats are being counted */
	EOS_ProductUserId TargetUserId;
));

/** The most recent version of the EOS_Stats_CopyStatByIndexOptions struct. */
#define EOS_STATS_COPYSTATBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_Stats_CopyStatByIndex function.
 */
EOS_STRUCT(EOS_Stats_CopyStatByIndexOptions, (
	/** API Version: Set this to EOS_STATS_COPYSTATBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who owns the stat */
	EOS_ProductUserId TargetUserId;
	/** Index of the stat to retrieve from the cache */
	uint32_t StatIndex;
));

/** The most recent version of the EOS_Stats_CopyStatByNameOptions struct. */
#define EOS_STATS_COPYSTATBYNAME_API_LATEST 1

/**
 * Input parameters for the EOS_Stats_CopyStatByName function.
 */
EOS_STRUCT(EOS_Stats_CopyStatByNameOptions, (
	/** API Version: Set this to EOS_STATS_COPYSTATBYNAME_API_LATEST. */
	int32_t ApiVersion;
	/** The Product User ID of the user who owns the stat */
	EOS_ProductUserId TargetUserId;
	/** Name of the stat to retrieve from the cache */
	const char* Name;
));

/**
 * Release the memory associated with a stat. This must be called on data retrieved from EOS_Stats_CopyStatByIndex or EOS_Stats_CopyStatByName.
 *
 * @param Stat - The stat data to release.
 *
 * @see EOS_Stats_Stat
 * @see EOS_Stats_CopyStatByIndex
 * @see EOS_Stats_CopyStatByName
 */
EOS_DECLARE_FUNC(void) EOS_Stats_Stat_Release(EOS_Stats_Stat* Stat);

/**
 * Data containing the result information for querying a player's stats request.
 */
EOS_STRUCT(EOS_Stats_OnQueryStatsCompleteCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_Stats_QueryStats */
	void* ClientData;
	/** The Product User ID of the user who initiated this request */
	EOS_ProductUserId LocalUserId;
	/** The Product User ID whose stats which were retrieved */
	EOS_ProductUserId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_Stats_QueryStats
 *
 * @param Data A EOS_Stats_OnQueryStatsCompleteCallbackInfo containing the output information and result
 *
 * @see EOS_Stats_Stat_Release
 */
EOS_DECLARE_CALLBACK(EOS_Stats_OnQueryStatsCompleteCallback, const EOS_Stats_OnQueryStatsCompleteCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_titlestorage.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_titlestorage_types.h"

/**
 * The following EOS_TitleStorage_* functions allow you to query metadata for available files from title storage as well as download and read their contents.
 */

/**
 * Query a specific file's metadata, such as file names, size, and a MD5 hash of the data. This is not required before a file may be opened. Once a file has
 * been queried, its metadata will be available by the EOS_TitleStorage_CopyFileMetadataAtIndex and EOS_TitleStorage_CopyFileMetadataByFilename functions.
 *
 * @param Options Object containing properties related to which user is querying files, and what file is being queried
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the query operation completes
 *
 * @return EOS_Success if the query completes successfully and a file is found
 *         EOS_NotFound if no file is found
 *
 * @see EOS_TitleStorage_GetFileMetadataCount
 * @see EOS_TitleStorage_CopyFileMetadataAtIndex
 * @see EOS_TitleStorage_CopyFileMetadataByFilename
 */
EOS_DECLARE_FUNC(void) EOS_TitleStorage_QueryFile(EOS_HTitleStorage Handle, const EOS_TitleStorage_QueryFileOptions* Options, void* ClientData, const EOS_TitleStorage_OnQueryFileCompleteCallback CompletionCallback);

/**
 * Query the file metadata, such as file names, size, and a MD5 hash of the data, for all files available for current user based on their settings (such as game role) and tags provided.
 * This is not required before a file can be downloaded by name.
 *
 * @param Options Object containing properties related to which user is querying files and the list of tags
 * @param ClientData Optional pointer to help clients track this request, that is returned in the completion callback
 * @param CompletionCallback This function is called when the query operation completes
 *
 * @return EOS_Success if the query completes successfully (whether any files are found or not)
 *
 * @see EOS_TitleStorage_GetFileMetadataCount
 * @see EOS_TitleStorage_CopyFileMetadataAtIndex
 * @see EOS_TitleStorage_CopyFileMetadataByFilename
 */
EOS_DECLARE_FUNC(void) EOS_TitleStorage_QueryFileList(EOS_HTitleStorage Handle, const EOS_TitleStorage_QueryFileListOptions* Options, void* ClientData, const EOS_TitleStorage_OnQueryFileListCompleteCallback CompletionCallback);

/**
 * Create a cached copy of a file's metadata by filename. The metadata will be for the last retrieved or successfully saved version, and will not include any changes that have not
 * completed writing. The returned pointer must be released by the user when no longer needed.
 *
 * @param Options Object containing properties related to which user is requesting metadata, and for which filename
 * @param OutMetadata A copy of the FileMetadata structure will be set if successful.  This data must be released by calling EOS_TitleStorage_FileMetadata_Release.
 * @return EOS_Success if the metadata is currently cached, otherwise an error result explaining what went wrong
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorage_CopyFileMetadataByFilename(EOS_HTitleStorage Handle, const EOS_TitleStorage_CopyFileMetadataByFilenameOptions* Options, EOS_TitleStorage_FileMetadata ** OutMetadata);

/**
 * Get the count of files we have previously queried information for and files we have previously read from / written to.
 *
 * @param Options Object containing properties related to which user is requesting the metadata count
 * @return If successful, the count of metadata currently cached. Returns 0 on failure.
 *
 * @see EOS_TitleStorage_CopyFileMetadataAtIndex
 */
EOS_DECLARE_FUNC(uint32_t) EOS_TitleStorage_GetFileMetadataCount(EOS_HTitleStorage Handle, const EOS_TitleStorage_GetFileMetadataCountOptions* Options);

/**
 * Get the cached copy of a file's metadata by index. The metadata will be for the last retrieved version. The returned pointer must be released by the user when no longer needed.
 *
 * @param Options Object containing properties related to which user is requesting metadata, and at what index
 * @param OutMetadata A copy of the FileMetadata structure will be set if successful.  This data must be released by calling EOS_TitleStorage_FileMetadata_Release.
 * @return EOS_Success if the requested metadata is currently cached, otherwise an error result explaining what went wrong.
 *
 * @see EOS_TitleStorage_GetFileMetadataCount
 * @see EOS_TitleStorage_FileMetadata_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorage_CopyFileMetadataAtIndex(EOS_HTitleStorage Handle, const EOS_TitleStorage_CopyFileMetadataAtIndexOptions* Options, EOS_TitleStorage_FileMetadata ** OutMetadata);

/**
 * Retrieve the contents of a specific file, potentially downloading the contents if we do not have a local copy, from the cloud. This request will occur asynchronously, potentially over
 * multiple frames. All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at
 * least once if the request is started successfully.
 *
 * @param Options Object containing properties related to which user is opening the file, what the file's name is, and related mechanisms for copying the data
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the read operation completes
 * @return A valid Title Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
 *
 * @return EOS_Success if the file is exists and the read operation completes successfully
 *         EOS_NotFound if no file is found
 *
 * @see EOS_TitleStorageFileTransferRequest_Release
 */
EOS_DECLARE_FUNC(EOS_HTitleStorageFileTransferRequest) EOS_TitleStorage_ReadFile(EOS_HTitleStorage Handle, const EOS_TitleStorage_ReadFileOptions* Options, void* ClientData, const EOS_TitleStorage_OnReadFileCompleteCallback CompletionCallback);

/**
 * Clear previously cached file data. This operation will be done asynchronously. All cached files except those corresponding to the transfers in progress will be removed.
 * Warning: Use this with care. Cache system generally tries to clear old and unused cached files from time to time. Unnecessarily clearing cache can degrade performance as SDK will have to re-download data.
 *
 * @param Options Object containing properties related to which user is deleting cache
 * @param ClientData Optional pointer to help clients track this request, that is returned in associated callbacks
 * @param CompletionCallback This function is called when the delete cache operation completes
 * @return EOS_Success if the operation was started correctly, otherwise an error result explaining what went wrong
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorage_DeleteCache(EOS_HTitleStorage Handle, const EOS_TitleStorage_DeleteCacheOptions* Options, void* ClientData, const EOS_TitleStorage_OnDeleteCacheCompleteCallback CompletionCallback);

/**
 * Below are helper functions to retrieve information about a file request handle, or to attempt to cancel a request in progress.
 */

/**
 * Get the current state of a file request.
 *
 * @return EOS_Success if complete and successful, EOS_RequestInProgress if the request is still in progress, or another state for failure.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorageFileTransferRequest_GetFileRequestState(EOS_HTitleStorageFileTransferRequest Handle);

/**
 * Get the file name of the file this request is for. OutStringLength will always be set to the string length of the file name if it is not NULL.
 *
 * @param FilenameStringBufferSizeBytes The maximum number of bytes that can be written to OutStringBuffer
 * @param OutStringBuffer The buffer to write the NULL-terminated utf8 file name into, if successful
 * @param OutStringLength How long the file name is (not including null terminator)
 * @return EOS_Success if the file name was successfully written to OutFilenameBuffer, a failure result otherwise
 *
 * @see EOS_TITLESTORAGE_FILENAME_MAX_LENGTH_BYTES
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorageFileTransferRequest_GetFilename(EOS_HTitleStorageFileTransferRequest Handle, uint32_t FilenameStringBufferSizeBytes, char* OutStringBuffer, int32_t* OutStringLength);

/**
 * Attempt to cancel this file request in progress. This is a best-effort command and is not guaranteed to be successful if the request has completed before this function is called.
 *
 * @return EOS_Success if cancel is successful, EOS_NoChange if request had already completed (can't be canceled), EOS_AlreadyPending if it's already been canceled before (this is a final state for canceled request and won't change over time).
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_TitleStorageFileTransferRequest_CancelRequest(EOS_HTitleStorageFileTransferRequest Handle);

```

`EAC_SDK/SDK/include/eos_titlestorage_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** Maximum File Name Length in bytes */
#define EOS_TITLESTORAGE_FILENAME_MAX_LENGTH_BYTES 64

EXTERN_C typedef struct EOS_TitleStorageHandle* EOS_HTitleStorage;

/** The most recent version of the EOS_TitleStorage_FileMetadata API. */
#define EOS_TITLESTORAGE_FILEMETADATA_API_LATEST 2

/**
 * Metadata information for a specific file
 */
EOS_STRUCT(EOS_TitleStorage_FileMetadata, (
	/** API Version: Set this to EOS_TITLESTORAGE_FILEMETADATA_API_LATEST. */
	int32_t ApiVersion;
	/** The total size of the file in bytes (Includes file header in addition to file contents). */
	uint32_t FileSizeBytes;
	/** The MD5 Hash of the entire file (including additional file header), in hex digits */
	const char* MD5Hash;
	/** The file's name */
	const char* Filename;
	/** The size of data (payload) in file in unencrypted (original) form. */
	uint32_t UnencryptedDataSizeBytes;
));

/**
 * Free the memory used by the file metadata
 */
EOS_DECLARE_FUNC(void) EOS_TitleStorage_FileMetadata_Release(EOS_TitleStorage_FileMetadata* FileMetadata);

/** The most recent version of the EOS_TitleStorage_QueryFile API. */
#define EOS_TITLESTORAGE_QUERYFILE_API_LATEST 1
/** DEPRECATED! Use EOS_TITLESTORAGE_QUERYFILE_API_LATEST instead. */
#define EOS_TITLESTORAGE_QUERYFILEOPTIONS_API_LATEST EOS_TITLESTORAGE_QUERYFILE_API_LATEST

/**
 * Input data for the EOS_TitleStorage_QueryFile function
 */
EOS_STRUCT(EOS_TitleStorage_QueryFileOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_QUERYFILE_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user requesting file metadata (optional) */
	EOS_ProductUserId LocalUserId;
	/** The requested file's name */
	const char* Filename;
));

/**
 * Structure containing information about a query file request
 */
EOS_STRUCT(EOS_TitleStorage_QueryFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file query request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
));

/**
 * Callback for when EOS_TitleStorage_QueryFile completes
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnQueryFileCompleteCallback, const EOS_TitleStorage_QueryFileCallbackInfo* Data);

/** The most recent version of the EOS_TitleStorage_QueryFileList API. */
#define EOS_TITLESTORAGE_QUERYFILELIST_API_LATEST 1
/** DEPRECATED! Use EOS_TITLESTORAGE_QUERYFILELIST_API_LATEST instead. */
#define EOS_TITLESTORAGE_QUERYFILELISTOPTIONS_API_LATEST EOS_TITLESTORAGE_QUERYFILELIST_API_LATEST

/**
 * Input data for the EOS_TitleStorage_QueryFileList function
 */
EOS_STRUCT(EOS_TitleStorage_QueryFileListOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_QUERYFILELIST_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who requested file metadata (optional) */
	EOS_ProductUserId LocalUserId;
	/** List of tags to use for lookup. */
	const char* const* ListOfTags;
	/** Number of tags specified in ListOfTags */
	uint32_t ListOfTagsCount;
));

/**
 * Structure containing information about a query file list request
 */
EOS_STRUCT(EOS_TitleStorage_QueryFileListCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file query request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
	/** A count of files that were found, if successful */
	uint32_t FileCount;
));

/**
 * Callback for when EOS_TitleStorage_QueryFileList completes
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnQueryFileListCompleteCallback, const EOS_TitleStorage_QueryFileListCallbackInfo* Data);

/** The most recent version of the EOS_TitleStorage_GetFileMetadataCount API. */
#define EOS_TITLESTORAGE_GETFILEMETADATACOUNT_API_LATEST 1
/** DEPRECATED! Use EOS_TITLESTORAGE_GETFILEMETADATACOUNT_API_LATEST instead. */
#define EOS_TITLESTORAGE_GETFILEMETADATACOUNTOPTIONS_API_LATEST EOS_TITLESTORAGE_GETFILEMETADATACOUNT_API_LATEST

/**
 * Input data for the EOS_TitleStorage_GetFileMetadataCount function
 */
EOS_STRUCT(EOS_TitleStorage_GetFileMetadataCountOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_GETFILEMETADATACOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is requesting file metadata (optional) */
	EOS_ProductUserId LocalUserId;
));

/** The most recent version of the EOS_TitleStorage_CopyFileMetadataAtIndex API. */
#define EOS_TITLESTORAGE_COPYFILEMETADATAATINDEX_API_LATEST 1
/** DEPRECATED! Use EOS_TITLESTORAGE_COPYFILEMETADATAATINDEX_API_LATEST instead. */
#define EOS_TITLESTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST EOS_TITLESTORAGE_COPYFILEMETADATAATINDEX_API_LATEST

/**
 * Input data for the CopyFileMetadataAtIndex function
 */
EOS_STRUCT(EOS_TitleStorage_CopyFileMetadataAtIndexOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_COPYFILEMETADATAATINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is requesting file metadata (optional) */
	EOS_ProductUserId LocalUserId;
	/** The index to get data for */
	uint32_t Index;
));

/** The most recent version of the EOS_TitleStorage_CopyFileMetadataByFilename API. */
#define EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST 1
/** DEPRECATED! Use EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST instead. */
#define EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST


/**
 * Input data for the CopyFileMetadataByFilename function
 */
EOS_STRUCT(EOS_TitleStorage_CopyFileMetadataByFilenameOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_COPYFILEMETADATABYFILENAME_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is requesting file metadata (optional) */
	EOS_ProductUserId LocalUserId;
	/** The file's name to get data for */
	const char* Filename;
));

/**
 * Handle type to a File Request
 */
EXTERN_C typedef struct EOS_TitleStorageFileTransferRequestHandle* EOS_HTitleStorageFileTransferRequest;

/**
 * Free the memory used by a cloud-storage file request handle. This will not cancel a request in progress.
 */
EOS_DECLARE_FUNC(void) EOS_TitleStorageFileTransferRequest_Release(EOS_HTitleStorageFileTransferRequest TitleStorageFileTransferHandle);

/**
 * Structure containing the information about a file transfer in progress (or one that has completed)
 */
EOS_STRUCT(EOS_TitleStorage_FileTransferProgressCallbackInfo, (
	/** Client-specified data passed into the file request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
	/** The file name of the file being transferred */
	const char* Filename;
	/** Amount of bytes transferred so far in this request, out of TotalFileSizeBytes */
	uint32_t BytesTransferred;
	/** The total size of the file being transferred (Includes file header in addition to file contents, can be slightly more than expected) */
	uint32_t TotalFileSizeBytes;
));

/**
 * Callback for when there is a progress update for a file transfer in progress
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnFileTransferProgressCallback, const EOS_TitleStorage_FileTransferProgressCallbackInfo* Data);

/**
 * Return results for EOS_TitleStorage_OnReadFileDataCallback callbacks
 */
EOS_ENUM(EOS_TitleStorage_EReadResult,
	/** Signifies the data was read successfully, and we should continue to the next chunk if possible */
	EOS_TS_RR_ContinueReading = 1,
	/** Signifies there was a failure reading the data, and the request should end */
	EOS_TS_RR_FailRequest = 2,
	/** Signifies the request should be canceled, but not due to an error */
	EOS_TS_RR_CancelRequest = 3
);

/**
 * Structure containing data for a chunk of a file being read
 */
EOS_STRUCT(EOS_TitleStorage_ReadFileDataCallbackInfo, (
	/** Client-specified data passed into the file request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
	/** The file name being read */
	const char* Filename;
	/** The total file size of the file being read */
	uint32_t TotalFileSizeBytes;
	/** Is this chunk the last chunk of data? */
	EOS_Bool bIsLastChunk;
	/** The length of DataChunk in bytes that can be safely read */
	uint32_t DataChunkLengthBytes;
	/** Pointer to the start of data to be read */
	const void* DataChunk;
));

/**
 * Callback for when we have data ready to be read from the requested file. It is undefined how often this will be called during a single tick.
 *
 * @param Data Struct containing a chunk of data to read, as well as some metadata for the file being read
 * @return The result of the read operation. If this value is not EOS_TS_RR_ContinueReading, this callback will not be called again for the same request
 */
EOS_DECLARE_CALLBACK_RETVALUE(EOS_TitleStorage_EReadResult, EOS_TitleStorage_OnReadFileDataCallback, const EOS_TitleStorage_ReadFileDataCallbackInfo* Data);

/** The most recent version of the EOS_TitleStorage_ReadFile API. */
#define EOS_TITLESTORAGE_READFILE_API_LATEST 1
/** DEPRECATED! Use EOS_TITLESTORAGE_READFILE_API_LATEST instead. */
#define EOS_TITLESTORAGE_READFILEOPTIONS_API_LATEST EOS_TITLESTORAGE_READFILE_API_LATEST

/**
 * Input data for the EOS_TitleStorage_ReadFile function
 */
EOS_STRUCT(EOS_TitleStorage_ReadFileOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_READFILE_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is reading the requested file (optional) */
	EOS_ProductUserId LocalUserId;
	/** The file name to read; this file must already exist */
	const char* Filename;
	/** The maximum amount of data in bytes should be available to read in a single EOS_TitleStorage_OnReadFileDataCallback call */
	uint32_t ReadChunkLengthBytes;
	/** Callback function to handle copying read data */
	EOS_TitleStorage_OnReadFileDataCallback ReadFileDataCallback;
	/** Optional callback function to be informed of download progress, if the file is not already locally cached. If set, this will be called at least once before completion if the request is successfully started */
	EOS_TitleStorage_OnFileTransferProgressCallback FileTransferProgressCallback;
));

/**
 * Structure containing the result of a read file request
 */
EOS_STRUCT(EOS_TitleStorage_ReadFileCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the file read request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
	/** The filename of the file that has been finished reading */
	const char* Filename;
));

/**
 * Callback for when EOS_TitleStorage_ReadFile completes
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnReadFileCompleteCallback, const EOS_TitleStorage_ReadFileCallbackInfo* Data);

/** The most recent version of the EOS_TitleStorage_DeleteCache API. */
#define EOS_TITLESTORAGE_DELETECACHE_API_LATEST 1
/** DEPRECATED! Use EOS_TITLESTORAGE_DELETECACHE_API_LATEST instead. */
#define EOS_TITLESTORAGE_DELETECACHEOPTIONS_API_LATEST EOS_TITLESTORAGE_DELETECACHE_API_LATEST

/**
 * Input data for the EOS_TitleStorage_DeleteCache function
 */
EOS_STRUCT(EOS_TitleStorage_DeleteCacheOptions, (
	/** API Version: Set this to EOS_TITLESTORAGE_DELETECACHE_API_LATEST. */
	int32_t ApiVersion;
	/** Product User ID of the local user who is deleting his cache (optional) */
	EOS_ProductUserId LocalUserId;
));

/**
 * Structure containing the result of a delete cache operation
 */
EOS_STRUCT(EOS_TitleStorage_DeleteCacheCallbackInfo, (
	/** Result code for the operation. EOS_Success is returned for a successful request, other codes indicate an error */
	EOS_EResult ResultCode;
	/** Client-specified data passed into the delete cache request */
	void* ClientData;
	/** Product User ID of the local user who initiated this request (optional, will only be present in case it was provided during operation start) */
	EOS_ProductUserId LocalUserId;
));

/**
 * Callback for when EOS_TitleStorage_DeleteCache completes
 */
EOS_DECLARE_CALLBACK(EOS_TitleStorage_OnDeleteCacheCompleteCallback, const EOS_TitleStorage_DeleteCacheCallbackInfo* Data);

#pragma pack(pop)
```

`EAC_SDK/SDK/include/eos_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"
#include "eos_integratedplatform_types.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_PlatformHandle* EOS_HPlatform;

/** Max length of a client id, not including the terminating null. */
#define EOS_PLATFORM_CLIENTCREDENTIALS_CLIENTID_MAX_LENGTH 64

/** Max length of a client secret, not including the terminating null. */
#define EOS_PLATFORM_CLIENTCREDENTIALS_CLIENTSECRET_MAX_LENGTH 64

/** Client credentials. */
EOS_STRUCT(EOS_Platform_ClientCredentials, (
	/** Client ID of the service permissions entry. Set to NULL if no service permissions are used. Max length is EOS_PLATFORM_CLIENTCREDENTIALS_CLIENTID_MAX_LENGTH. */
	const char* ClientId;
	/** Client secret for accessing the set of permissions. Set to NULL if no service permissions are used. Max length is EOS_PLATFORM_CLIENTCREDENTIALS_CLIENTSECRET_MAX_LENGTH. */
	const char* ClientSecret;
));

/** All background modes supported by the RTC components */
EOS_ENUM(EOS_ERTCBackgroundMode,
	/** 
	 * Upon entering a background application status, all logged in users leave any RTC rooms. All subsequent attempts to join any RTC rooms will be rejected.
	 * Upon returning to a foreground application status, all subsequent attempts to join any RTC rooms will be allowed.
	 */
	EOS_RTCBM_LeaveRooms = 0,
	/** 
	 * Application status has no effect on RTC rooms. Audio is captured from input devices and is played to output devices.
	 * Games should obtain consent from users and otherwise make users aware this is occurring.
	 */
	EOS_RTCBM_KeepRoomsAlive = 1
);

/** The most recent version of the EOS_Platform_RTCOptions API. */
#define EOS_PLATFORM_RTCOPTIONS_API_LATEST 2

/** Platform RTC options. */
EOS_STRUCT(EOS_Platform_RTCOptions, (
	/** API Version: Set this to EOS_PLATFORM_RTCOPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * This field is for platform specific initialization if any.
	 *
	 * If provided then the structure will be located in <System>/eos_<System>.h.
	 * The structure will be named EOS_<System>_RTCOptions.
	 */
	void* PlatformSpecificOptions;
	/** Configures RTC behavior upon entering to any background application statuses */
	EOS_ERTCBackgroundMode BackgroundMode;
));

#define EOS_COUNTRYCODE_MAX_LENGTH 4
#define EOS_COUNTRYCODE_MAX_BUFFER_LEN (EOS_COUNTRYCODE_MAX_LENGTH + 1)
#define EOS_LOCALECODE_MAX_LENGTH 9
#define EOS_LOCALECODE_MAX_BUFFER_LEN (EOS_LOCALECODE_MAX_LENGTH + 1)

#define EOS_PLATFORM_OPTIONS_API_LATEST 14

/** Platform Creation Flags used in EOS_Platform_Create */

/** A bit that indicates the SDK is being loaded in a game editor, like Unity or UE4 Play-in-Editor */
#define EOS_PF_LOADING_IN_EDITOR				0x00001
/** A bit that indicates the SDK should skip initialization of the overlay, which is used by the in-app purchase flow and social overlay. This bit is implied by EOS_PF_LOADING_IN_EDITOR */
#define EOS_PF_DISABLE_OVERLAY					0x00002
/** A bit that indicates the SDK should skip initialization of the social overlay, which provides an overlay UI for social features. This bit is implied by EOS_PF_LOADING_IN_EDITOR or EOS_PF_DISABLE_OVERLAY */
#define EOS_PF_DISABLE_SOCIAL_OVERLAY			0x00004
/** A reserved bit */
#define EOS_PF_RESERVED1						0x00008
/** A bit that indicates your game would like to opt-in to experimental Direct3D 9 support for the overlay. This flag is only relevant on Windows */
#define EOS_PF_WINDOWS_ENABLE_OVERLAY_D3D9		0x00010
/** A bit that indicates your game would like to opt-in to experimental Direct3D 10 support for the overlay. This flag is only relevant on Windows */
#define EOS_PF_WINDOWS_ENABLE_OVERLAY_D3D10		0x00020
/** A bit that indicates your game would like to opt-in to experimental OpenGL support for the overlay. This flag is only relevant on Windows */
#define EOS_PF_WINDOWS_ENABLE_OVERLAY_OPENGL	0x00040
/** A bit that indicates your game would like to opt-in to automatic unloading of the overlay module when possible. This flag is only relevant on Consoles */
#define EOS_PF_CONSOLE_ENABLE_OVERLAY_AUTOMATIC_UNLOADING 	0x00080

/** Max length of a product id, not including the terminating null. */
#define EOS_PLATFORM_OPTIONS_PRODUCTID_MAX_LENGTH 64

/** Max length of a sandbox id, not including the terminating null. */
#define EOS_PLATFORM_OPTIONS_SANDBOXID_MAX_LENGTH 64

/** Length of an encryption key, not including the terminating null. */
#define EOS_PLATFORM_OPTIONS_ENCRYPTIONKEY_LENGTH 64

/** Max length of a deployment id, not including the terminating null. */
#define EOS_PLATFORM_OPTIONS_DEPLOYMENTID_MAX_LENGTH 64

/** Platform options for EOS_Platform_Create. */
EOS_STRUCT(EOS_Platform_Options, (
	/** API Version: Set this to EOS_PLATFORM_OPTIONS_API_LATEST. */
	int32_t ApiVersion;
	/** A reserved field that should always be nulled. */
	void* Reserved;
	/** The product ID for the running application, found on the dev portal. Max length is EOS_PLATFORM_OPTIONS_PRODUCTID_MAX_LENGTH. */
	const char* ProductId;
	/** The sandbox ID for the running application, found on the dev portal. Max length is EOS_PLATFORM_OPTIONS_SANDBOXID_MAX_LENGTH. */
	const char* SandboxId;
	/** Set of service permissions associated with the running application */
	EOS_Platform_ClientCredentials ClientCredentials;
	/** Set this to EOS_FALSE if the application is running as a client with a local user, otherwise set to EOS_TRUE (e.g. for a dedicated game server) */
	EOS_Bool bIsServer;
	/** Used by Player Data Storage and Title Storage. Must be null initialized if unused. 256-bit Encryption Key for file encryption in hexadecimal format; EOS_PLATFORM_OPTIONS_ENCRYPTIONKEY_LENGTH hex chars. */
	const char* EncryptionKey;
	/** The override country code to use for the logged in user. (EOS_COUNTRYCODE_MAX_LENGTH)*/
	const char* OverrideCountryCode;
	/** The override locale code to use for the logged in user. This follows ISO 639. (EOS_LOCALECODE_MAX_LENGTH)*/
	const char* OverrideLocaleCode;
	/** The deployment ID for the running application, found on the dev portal. Max length is EOS_PLATFORM_OPTIONS_DEPLOYMENTID_MAX_LENGTH. */
	const char* DeploymentId;
	/** Platform creation flags, e.g. EOS_PF_LOADING_IN_EDITOR. This is a bitwise-or union of the defined flags. */
	uint64_t Flags;
	/** Used by Player Data Storage and Title Storage. Must be null initialized if unused. Cache directory path. Absolute path to the folder that is going to be used for caching temporary data. The path is created if it's missing. */
	const char* CacheDirectory;
	/**
	 * A budget, measured in milliseconds, for EOS_Platform_Tick to do its work. When the budget is met or exceeded (or if no work is available), EOS_Platform_Tick will return.
	 * This allows your game to amortize the cost of SDK work across multiple frames in the event that a lot of work is queued for processing.
	 * Zero is interpreted as "perform all available work".
	 */
	uint32_t TickBudgetInMilliseconds;
	/** RTC options. Setting to NULL will disable RTC features (e.g. voice) */
	const EOS_Platform_RTCOptions* RTCOptions;
	/**
	 * A handle that contains all the options for setting up integrated platforms.
	 * When set to NULL, the EOS Integrated Platform behavior for the host platform will be disabled.
	 */
	EOS_HIntegratedPlatformOptionsContainer IntegratedPlatformOptionsContainerHandle;
	/** Pointer to EOS_<Platform>_SystemSpecificOptions. This structure will be located in <Platform>/eos_<Platform>.h */
	const void* SystemSpecificOptions;
	/** 
	 * Number of seconds for a task to wait for the network to become available before timing out with an EOS_TimedOut error.
	 * This timeout period applies when the network status is not EOS_NS_Online. Tasks that need the network will queue for up to
	 * this timeout until EOS_Platform_SetNetworkStatus is used to set the network status to online.
	 * 
	 * Pass a null pointer to use the default. 
	 * Otherwise, pass a pointer to a double containing the number of seconds for tasks that are waiting for network to time out.
	 * 
	 * @see EOS_Platform_SetNetworkStatus
	 * @see EOS_ENetworkStatus
	 */
	double* TaskNetworkTimeoutSeconds;
));

/**
 * All possible states of the application.
 */
EOS_ENUM(EOS_EApplicationStatus,
	/**
	 * Xbox only.
	 *
	 * Notifies the SDK that the application has entered constrained mode.
	 * While in constrained mode, the application has reduced access to reserved system resources.
	 */
	EOS_AS_BackgroundConstrained = 0,
	/**
	 * Xbox only.
	 *
	 * Notifies the SDK that the application has returned from constrained mode,
	 * and is back to running in a regular state with full access to system resources.
	 * 
	 * The SDK will handle this state change and automatically transition its active state to EOS_AS_Foreground.
	 * As result, after the application has set the EOS_AS_BackgroundUnconstrained state,
	 * calling EOS_Platform_GetApplicationStatus will return EOS_AS_Foreground as the persisted active state.
	 */
	EOS_AS_BackgroundUnconstrained = 1,
	/**
	 * Notifies the SDK that the application has been put into suspended state by the platform system.
	 */
	EOS_AS_BackgroundSuspended = 2,
	/**
	 * Notifies the SDK that the application has been resumed from suspended state.
	 *
	 * This is the default active state on all platforms.
	 */
	EOS_AS_Foreground = 3
);

/**
 * Gets the string representation of an EOS_EApplicationStatus value.
 *
 * Example: EOS_EApplicationStatus_ToString(EOS_EApplicationStatus::EOS_AS_Foreground) returns "EOS_AS_Foreground".
 *
 * @param ApplicationStatus EOS_EApplicationStatus value to get as string.
 *
 * @return Pointer to a static string representing the input enum value.
 *         The returned string is guaranteed to be non-null, and must not be freed by the application.
 */
EOS_DECLARE_FUNC(const char*) EOS_EApplicationStatus_ToString(EOS_EApplicationStatus ApplicationStatus);

/**
 * All possible states of the network.
 */
EOS_ENUM(EOS_ENetworkStatus,
	/**
	 * Networking unavailable.
	 */
	EOS_NS_Disabled = 0,
	/**
	 * Not connected to the internet. Only local area networking (LAN) may be available.
	 */
	EOS_NS_Offline = 1,
	/**
	 * Connected to the internet.
	 */
	EOS_NS_Online = 2
);

/**
 * Gets the string representation of an EOS_ENetworkStatus value.
 *
 * Example: EOS_ENetworkStatus_ToString(EOS_ENetworkStatus::EOS_NS_Online) returns "EOS_NS_Online".
 *
 * @param NetworkStatus EOS_ENetworkStatus value to get as string.
 *
 * @return Pointer to a static string representing the input enum value.
 *         The returned string is guaranteed to be non-null, and must not be freed by the application.
 */
EOS_DECLARE_FUNC(const char*) EOS_ENetworkStatus_ToString(EOS_ENetworkStatus NetworkStatus);

/**
 * Possible statuses for the availability of desktop crossplay functionality.
 *
 * @see EOS_Platform_GetDesktopCrossplayStatus
 */
EOS_ENUM(EOS_EDesktopCrossplayStatus,
	/**
	 * Desktop crossplay is ready to use.
	 */
	EOS_DCS_OK = 0,
	/**
	 * The application was not launched through the Bootstrapper.
	 */
	EOS_DCS_ApplicationNotBootstrapped = 1,
	/**
	 * The redistributable service is not installed.
	 */
	EOS_DCS_ServiceNotInstalled = 2,
	/**
	 * The service failed to start.
	 */
	EOS_DCS_ServiceStartFailed = 3,
	/**
	 * The service was started successfully, but is no longer running in the background, for an unknown reason.
	 */
	EOS_DCS_ServiceNotRunning = 4,
	/**
	 * The application has explicitly disabled the overlay through SDK initialization flags.
	 */
	EOS_DCS_OverlayDisabled = 5,
	/**
	 * The overlay is not installed.
	 *
	 * As the overlay is automatically installed and kept up-to-date by the redistributable service,
	 * this indicates that the user may have separately manually removed the installed overlay files.
	 */
	EOS_DCS_OverlayNotInstalled = 6,
	/**
	 * The overlay was not loaded due to failing trust check on the digital signature of the file on disk.
	 *
	 * This error typically indicates one of the following root causes:
	 * - The Operating System's local certificate store is out of date.
	 * - The local system clock has skewed and is in the wrong time.
	 * - The file has been tampered with.
	 * - The file trust check timed out, either due to an issue with the local system or network connectivity.
	 *
	 * The first troubleshooting steps should be to check for any available Operating System updates,
	 * for example using the Windows Update, as well as verifying that the system time is correctly set.
	 */
	EOS_DCS_OverlayTrustCheckFailed = 7,
	/**
	 * The overlay failed to load.
	 */
	EOS_DCS_OverlayLoadFailed = 8
);

/** The most recent version of the EOS_Platform_GetDesktopCrossplayStatus API. */
#define EOS_PLATFORM_GETDESKTOPCROSSPLAYSTATUS_API_LATEST 1

/**
 * Input parameters for the EOS_Platform_GetDesktopCrossplayStatus function.
 */
EOS_STRUCT(EOS_Platform_GetDesktopCrossplayStatusOptions, (
	/** API Version: Set this to EOS_PLATFORM_GETDESKTOPCROSSPLAYSTATUS_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Output parameters for the EOS_Platform_GetDesktopCrossplayStatus function.
 */
EOS_STRUCT(EOS_Platform_DesktopCrossplayStatusInfo, (
	/**
	 * Status for the availability of desktop crossplay functionality.
	 *
	 * It is recommended to include this value in application logs, and as part of
	 * any player-facing error screens to help troubleshooting possible issues.
	 */
	EOS_EDesktopCrossplayStatus Status;
	/**
	 * This field is set when the Status is EOS_DCS_ServiceStartFailed.
	 *
	 * Possible values for this field are not documented. However, it is recommended
	 * to be also included in application logs, and as part of any player-facing
	 * error screens.
	 */
	int32_t ServiceInitResult;
));

/** DEPRECATED: This alias will be removed in a future version, please use EOS_Platform_DesktopCrossplayStatusInfo to avoid API breaking changes in the future. */
#define EOS_Platform_GetDesktopCrossplayStatusInfo EOS_Platform_DesktopCrossplayStatusInfo

/** 
 * The name of the env var used to determine if the game was launched by the Epic Games Launcher.
 * 
 * During the call to EOS_Platform_Create, the command line that was used to launch the app is inspected, and if it is
 * recognized as coming from the Epic Games Launcher, this environment variable is set to 1. 
 *
 * NOTE: You can force the EOS_Platform_CheckForLauncherAndRestart API to relaunch the title by 
 * explicitly unsetting this environment variable before calling EOS_Platform_CheckForLauncherAndRestart.
 */
#define EOS_PLATFORM_CHECKFORLAUNCHERANDRESTART_ENV_VAR "EOS_LAUNCHED_BY_EPIC"

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_ui.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_ui_types.h"

/**
 * The UI Interface is used to access the Social Overlay UI.  Each UI component will have a function for
 * opening it.  All UI Interface calls take a handle of type EOS_HUI as the first parameter.
 * This handle can be retrieved from an EOS_HPlatform handle by using the EOS_Platform_GetUIInterface function.
 *
 * @see EOS_Platform_GetUIInterface
 */

/**
 * Opens the Social Overlay with a request to show the friends list.
 *
 * @param Options Structure containing the Epic Account ID of the friends list to show.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate A callback that is fired when the request to show the friends list has been sent to the Social Overlay, or on an error.
 *
 * @return EOS_Success If the Social Overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the Social Overlay is not properly configured.
 *         EOS_NoChange If the Social Overlay is already visible.
 *         EOS_ApplicationSuspended If the application is suspended.
 *         EOS_NetworkDisconnected If the network is disconnected.
 */
EOS_DECLARE_FUNC(void) EOS_UI_ShowFriends(EOS_HUI Handle, const EOS_UI_ShowFriendsOptions* Options, void* ClientData, const EOS_UI_OnShowFriendsCallback CompletionDelegate);

/**
 * Hides the active Social Overlay.
 *
 * @param Options Structure containing the Epic Account ID of the browser to close.
 * @param ClientData Arbitrary data that is passed back to you in the CompletionDelegate.
 * @param CompletionDelegate A callback that is fired when the request to hide the friends list has been processed, or on an error.
 *
 * @return EOS_Success If the Social Overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the Social Overlay is not properly configured.
 *         EOS_NoChange If the Social Overlay is already hidden.
 */
EOS_DECLARE_FUNC(void) EOS_UI_HideFriends(EOS_HUI Handle, const EOS_UI_HideFriendsOptions* Options, void* ClientData, const EOS_UI_OnHideFriendsCallback CompletionDelegate);

/**
 * Gets the friends overlay visibility.
 *
 * @param Options Structure containing the Epic Account ID of the friends Social Overlay owner.
 *
 * @return EOS_TRUE If the overlay is visible.
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_UI_GetFriendsVisible(EOS_HUI Handle, const EOS_UI_GetFriendsVisibleOptions* Options);

/**
 * Gets the friends overlay exclusive input state.
 *
 * @param Options Structure containing the Epic Account ID of the friends Social Overlay owner.
 *
 * @return EOS_TRUE If the overlay has exclusive input.
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_UI_GetFriendsExclusiveInput(EOS_HUI Handle, const EOS_UI_GetFriendsExclusiveInputOptions* Options);

/**
 * Register to receive notifications when the overlay display settings are updated.
 * Newly registered handlers will always be called the next tick with the current state.
 * @note If the returned NotificationId is valid, you must call EOS_UI_RemoveNotifyDisplaySettingsUpdated when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the NotificationFn.
 * @param NotificationFn A callback that is fired when the overlay display settings are updated.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_UI_AddNotifyDisplaySettingsUpdated(EOS_HUI Handle, const EOS_UI_AddNotifyDisplaySettingsUpdatedOptions* Options, void* ClientData, const EOS_UI_OnDisplaySettingsUpdatedCallback NotificationFn);

/**
 * Unregister from receiving notifications when the overlay display settings are updated.
 *
 * @param Id Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_UI_RemoveNotifyDisplaySettingsUpdated(EOS_HUI Handle, EOS_NotificationId Id);

/**
 * Updates the current Toggle Friends Key. This key can be used by the user to toggle the friends
 * overlay when available. The default value represents `Shift + F3` as `((int32_t)EOS_UIK_Shift | (int32_t)EOS_UIK_F3)`.
 * The provided key should satisfy EOS_UI_IsValidKeyCombination. The value EOS_UIK_None is specially handled
 * by resetting the key binding to the system default.
 *
 * @param Options Structure containing the key combination to use.
 *
 * @return EOS_Success If the overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the overlay is not properly configured.
 *         EOS_NoChange If the key combination did not change.
 *
 * @see EOS_UI_IsValidKeyCombination
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_SetToggleFriendsKey(EOS_HUI Handle, const EOS_UI_SetToggleFriendsKeyOptions* Options);

/**
 * Returns the current Toggle Friends Key. This key can be used by the user to toggle the friends
 * overlay when available. The default value represents `Shift + F3` as `((int32_t)EOS_UIK_Shift | (int32_t)EOS_UIK_F3)`.
 *
 * @param Options Structure containing any options that are needed to retrieve the key.
 * @return A valid key combination which represent a single key with zero or more modifier keys.
 *         EOS_UIK_None will be returned if any error occurs.
 */
EOS_DECLARE_FUNC(EOS_UI_EKeyCombination) EOS_UI_GetToggleFriendsKey(EOS_HUI Handle, const EOS_UI_GetToggleFriendsKeyOptions* Options);

/**
 * Determine if a key combination is valid. A key combinations must have a single key and at least one modifier.
 * The single key must be one of the following: F1 through F12, Space, Backspace, Escape, or Tab.
 * The modifier key must be one or more of the following: Shift, Control, or Alt.
 *
 * @param KeyCombination The key to test.
 * @return EOS_TRUE if the provided key combination is valid.
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_UI_IsValidKeyCombination(EOS_HUI Handle, EOS_UI_EKeyCombination KeyCombination);

/**
 * Updates the current Toggle Friends Button. This button can be used by the user to toggle the friends
 * overlay when available.
 *
 * The default value is EOS_UISBF_None.
 * The provided button must satisfy EOS_UI_IsValidButtonCombination.
 *
 * On PC the EOS Overlay automatically listens to gamepad input and routes it to the overlay when appropriate. If this button is configured, the user may open the overlay using either this button or the toggle friends key.
 * On console platforms, the game must be calling EOS_UI_ReportInputState to route gamepad input to the EOS Overlay.
 *
 * Note: If you do not have a button mapped, it'll suppress the part of the toast notification that prompts the user to press it.
 *
 * @param Options Structure containing the button combination to use.
 *
 * @return EOS_Success If the overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the overlay is not properly configured.
 *         EOS_NoChange If the button combination did not change.
 *
 * @see EOS_UI_IsValidButtonCombination
 * @see EOS_UI_ReportInputState
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_SetToggleFriendsButton(EOS_HUI Handle, const EOS_UI_SetToggleFriendsButtonOptions* Options);

/**
 * Returns the current Toggle Friends Button.  This button can be used by the user to toggle the friends
 * overlay when available. The default value is EOS_UISBF_None.
 *
 * @param Options Structure containing any options that are needed to retrieve the button.
 * @return A valid button combination which represents any number of buttons.
 *         EOS_UIK_None will be returned if any error occurs.
 */
EOS_DECLARE_FUNC(EOS_UI_EInputStateButtonFlags) EOS_UI_GetToggleFriendsButton(EOS_HUI Handle, const EOS_UI_GetToggleFriendsButtonOptions* Options);

/**
 * Determine if a button combination is valid.
 *
 * @param ButtonCombination The button to test.
 * @return EOS_TRUE if the provided button combination is valid.
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_UI_IsValidButtonCombination(EOS_HUI Handle, EOS_UI_EInputStateButtonFlags ButtonCombination);

/**
 * Define any preferences for any display settings.
 *
 * @param Options Structure containing any options that are needed to set
 * @return EOS_Success If the overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the overlay is not properly configured.
 *         EOS_NoChange If the preferences did not change.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_SetDisplayPreference(EOS_HUI Handle, const EOS_UI_SetDisplayPreferenceOptions* Options);

/**
 * Returns the current notification location display preference.
 * @return The current notification location display preference.
 */
EOS_DECLARE_FUNC(EOS_UI_ENotificationLocation) EOS_UI_GetNotificationLocationPreference(EOS_HUI Handle);

/**
 * Lets the SDK know that the given UI event ID has been acknowledged and should be released.
 *
 * @return An EOS_EResult is returned to indicate success or an error.
 *
 * EOS_Success is returned if the UI event ID has been acknowledged.
 * EOS_NotFound is returned if the UI event ID does not exist.
 *
 * @see EOS_Presence_JoinGameAcceptedCallbackInfo
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_AcknowledgeEventId(EOS_HUI Handle, const EOS_UI_AcknowledgeEventIdOptions* Options);

/**
 * Pushes platform agnostic input state to the SDK. The state is passed to the EOS Overlay on console platforms.
 * This function has an empty implementation (i.e. returns EOS_NotImplemented) on all non-consoles platforms.
 *
 * @param Options Structure containing the input state
 *
 * @return EOS_Success If the Social Overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_NotConfigured If the Social Overlay is not properly configured.
 *         EOS_ApplicationSuspended If the application is suspended.
 *         EOS_NotImplemented If this function is not implemented on the current platform.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_ReportInputState(EOS_HUI Handle, const EOS_UI_ReportInputStateOptions* Options);

/**
 * Gives the Overlay the chance to issue its own drawing commands on console platforms.
 * Issued by the hosting application after it has finished the backbuffer and is ready to trigger presenting it.
 * As this process can be involved and rather varied depending on platform we do not plan to make the call
 * replace the standard "present" call, but rather expect it to be issued "just before" that call.
 * This function has an empty implementation (i.e. returns EOS_NotImplemented) on all non-consoles platforms.
 * @param PlatformSpecificInputData will vary from platform to platform.
 *        Main difference will be due to a platforms ability to provide multiple rendering queues.
 *
 * @return An EOS_EResult is returned to indicate success or an error.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_PrePresent(EOS_HUI Handle, const EOS_UI_PrePresentOptions* Options);

/**
 * Requests that the Social Overlay open and display the "Block User" flow for the specified user.
 *
 * @param ClientData Arbitrary data that is passed back to you in the NotificationFn.
 * @param NotificationFn A callback that is fired when the user exits the Block UI.
 *
 * @return EOS_Success If the overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_ApplicationSuspended If the application is suspended.
 *         EOS_NetworkDisconnected If the network is disconnected.
 */
EOS_DECLARE_FUNC(void) EOS_UI_ShowBlockPlayer(EOS_HUI Handle, const EOS_UI_ShowBlockPlayerOptions* Options, void* ClientData, const EOS_UI_OnShowBlockPlayerCallback CompletionDelegate);

/**
 * Requests that the Social Overlay open and display the "Report User" flow for the specified user.
 *
 * @param ClientData Arbitrary data that is passed back to you in the NotificationFn.
 * @param NotificationFn A callback that is fired when the user exits the Report UI.
 *
 * @return EOS_Success If the overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_ApplicationSuspended If the application is suspended.
 *         EOS_NetworkDisconnected If the network is disconnected.
 */
EOS_DECLARE_FUNC(void) EOS_UI_ShowReportPlayer(EOS_HUI Handle, const EOS_UI_ShowReportPlayerOptions* Options, void* ClientData, const EOS_UI_OnShowReportPlayerCallback CompletionDelegate);

/**
 * Sets the bIsPaused state of the overlay.
 * While true then all notifications will be delayed until after the bIsPaused is false again.
 * While true then the key and button events will not toggle the overlay.
 * If the Overlay was visible before being paused then it will be hidden.
 * If it is known that the Overlay should now be visible after being paused then it will be shown.
 *
 * @return EOS_Success If the overlay has been notified about the request.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_NotConfigured If the overlay is not properly configured.
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UI_PauseSocialOverlay(EOS_HUI Handle, const EOS_UI_PauseSocialOverlayOptions* Options);

/**
 * Gets the bIsPaused state of the overlay as set by any previous calls to EOS_UI_PauseSocialOverlay().
 *
 * @return EOS_TRUE If the overlay is paused.
 *
 * @see EOS_UI_PauseSocialOverlay
 */
EOS_DECLARE_FUNC(EOS_Bool) EOS_UI_IsSocialOverlayPaused(EOS_HUI Handle, const EOS_UI_IsSocialOverlayPausedOptions* Options);

/**
 * Register to receive notifications from the memory monitor.
 * Newly registered handlers will always be called the next tick with the current state.
 * @note If the returned NotificationId is valid, you must call EOS_UI_RemoveNotifyMemoryMonitor when you no longer wish to have your NotificationHandler called.
 *
 * @param Options Structure containing information about the request.
 * @param ClientData Arbitrary data that is passed back to you in the NotificationFn.
 * @param NotificationFn A callback that is fired when the overlay display settings are updated.
 *
 * @return handle representing the registered callback
 */
EOS_DECLARE_FUNC(EOS_NotificationId) EOS_UI_AddNotifyMemoryMonitor(EOS_HUI Handle, const EOS_UI_AddNotifyMemoryMonitorOptions* Options, void* ClientData, const EOS_UI_OnMemoryMonitorCallback NotificationFn);

/**
 * Unregister from receiving notifications when the memory monitor posts a notification.
 *
 * @param Id Handle representing the registered callback
 */
EOS_DECLARE_FUNC(void) EOS_UI_RemoveNotifyMemoryMonitor(EOS_HUI Handle, EOS_NotificationId Id);

/**
 * Requests that the native ID for a target player be identified and the native profile be displayed for that player.
 *
 * @param ClientData Arbitrary data that is passed back to you in the NotificationFn.
 * @param CompletionDelegate A callback that is fired when the profile has been shown.
 *
 * @return EOS_Success If the native SDK has been requested to display a profile.
 *         EOS_IncompatibleVersion if the API version passed in is incorrect.
 *         EOS_InvalidParameters If any of the options are incorrect.
 *         EOS_ApplicationSuspended If the application is suspended.
 *         EOS_NetworkDisconnected If the network is disconnected.
 *         EOS_NotFound If the platform ID for the target player cannot be found.
 */
EOS_DECLARE_FUNC(void) EOS_UI_ShowNativeProfile(EOS_HUI Handle, const EOS_UI_ShowNativeProfileOptions* Options, void* ClientData, const EOS_UI_OnShowNativeProfileCallback CompletionDelegate);

```

`EAC_SDK/SDK/include/eos_ui_buttons.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

// This file is not intended to be included directly. Include eos_ui_types.h instead.

/** No buttons */
EOS_UI_KEY_ENTRY_FIRST(EOS_UISBF_, None, 0)
/** Controller directional pad left */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, DPad_Left, (1 << 0))
/** Controller directional pad right */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, DPad_Right, (1 << 1))
/** Controller directional pad down */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, DPad_Down, (1 << 2))
/** Controller directional pad up */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, DPad_Up, (1 << 3))
/** Controller left main face button */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, FaceButton_Left, (1 << 4))
/** Controller right main face button */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, FaceButton_Right, (1 << 5))
/** Controller bottom main face button */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, FaceButton_Bottom, (1 << 6))
/** Controller top main face button */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, FaceButton_Top, (1 << 7))
/** Controller left upper shoulder button. */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, LeftShoulder, (1 << 8))
/** Controller right upper shoulder button. */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, RightShoulder, (1 << 9))
/** Controller left lower trigger button. */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, LeftTrigger, (1 << 10))
/** Controller right lower trigger button. */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, RightTrigger, (1 << 11))
/** Controller special button on left. */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, Special_Left, (1 << 12))
/** Controller special button on right. */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, Special_Right, (1 << 13))
/** Controller left thumbstick as a button. */
EOS_UI_KEY_MODIFIER(EOS_UISBF_, LeftThumbstick, (1 << 14))
/** Controller right thumbstick as a button. */
EOS_UI_KEY_MODIFIER_LAST(EOS_UISBF_, RightThumbstick, (1 << 15))
```

`EAC_SDK/SDK/include/eos_ui_keys.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

// This file is not intended to be included directly. Include eos_ui_types.h instead.

/** Number of bits to shift the modifiers into the integer. */
EOS_UI_KEY_CONSTANT(EOS_UIK_, ModifierShift, 16)
/** A mask to isolate the single key. */
EOS_UI_KEY_CONSTANT(EOS_UIK_, KeyTypeMask, (1 << EOS_UIK_ModifierShift) - 1)
/** A mask to isolate the modifier keys. */
EOS_UI_KEY_CONSTANT(EOS_UIK_, ModifierMask, ~EOS_UIK_KeyTypeMask)

/** The Shift key */
EOS_UI_KEY_MODIFIER(EOS_UIK_, Shift, (1 << EOS_UIK_ModifierShift))
/** The Control key */
EOS_UI_KEY_MODIFIER(EOS_UIK_, Control, (2 << EOS_UIK_ModifierShift))
/** The Alt key */
EOS_UI_KEY_MODIFIER(EOS_UIK_, Alt, (4 << EOS_UIK_ModifierShift))
/** The Windows key on a Windows keyboard or the Command key on a Mac keyboard */
EOS_UI_KEY_MODIFIER(EOS_UIK_, Meta, (8 << EOS_UIK_ModifierShift))
EOS_UI_KEY_CONSTANT(EOS_UIK_, ValidModifierMask, (EOS_UIK_Shift | EOS_UIK_Control | EOS_UIK_Alt | EOS_UIK_Meta))

EOS_UI_KEY_ENTRY_FIRST(EOS_UIK_, None, 0)
EOS_UI_KEY_ENTRY(EOS_UIK_, Space)
EOS_UI_KEY_ENTRY(EOS_UIK_, Backspace)
EOS_UI_KEY_ENTRY(EOS_UIK_, Tab)
EOS_UI_KEY_ENTRY(EOS_UIK_, Escape)

EOS_UI_KEY_ENTRY(EOS_UIK_, PageUp)
EOS_UI_KEY_ENTRY(EOS_UIK_, PageDown)
EOS_UI_KEY_ENTRY(EOS_UIK_, End)
EOS_UI_KEY_ENTRY(EOS_UIK_, Home)
EOS_UI_KEY_ENTRY(EOS_UIK_, Insert)
EOS_UI_KEY_ENTRY(EOS_UIK_, Delete)

EOS_UI_KEY_ENTRY(EOS_UIK_, Left)
EOS_UI_KEY_ENTRY(EOS_UIK_, Up)
EOS_UI_KEY_ENTRY(EOS_UIK_, Right)
EOS_UI_KEY_ENTRY(EOS_UIK_, Down)

EOS_UI_KEY_ENTRY(EOS_UIK_, Key0)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key1)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key2)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key3)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key4)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key5)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key6)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key7)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key8)
EOS_UI_KEY_ENTRY(EOS_UIK_, Key9)

EOS_UI_KEY_ENTRY(EOS_UIK_, KeyA)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyB)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyC)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyD)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyE)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyF)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyG)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyH)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyI)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyJ)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyK)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyL)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyM)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyN)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyO)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyP)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyQ)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyR)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyS)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyT)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyU)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyV)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyW)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyX)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyY)
EOS_UI_KEY_ENTRY(EOS_UIK_, KeyZ)

EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad0)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad1)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad2)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad3)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad4)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad5)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad6)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad7)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad8)
EOS_UI_KEY_ENTRY(EOS_UIK_, Numpad9)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadAsterisk)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadPlus)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadMinus)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadPeriod)
EOS_UI_KEY_ENTRY(EOS_UIK_, NumpadDivide)

EOS_UI_KEY_ENTRY(EOS_UIK_, F1)
EOS_UI_KEY_ENTRY(EOS_UIK_, F2)
EOS_UI_KEY_ENTRY(EOS_UIK_, F3)
EOS_UI_KEY_ENTRY(EOS_UIK_, F4)
EOS_UI_KEY_ENTRY(EOS_UIK_, F5)
EOS_UI_KEY_ENTRY(EOS_UIK_, F6)
EOS_UI_KEY_ENTRY(EOS_UIK_, F7)
EOS_UI_KEY_ENTRY(EOS_UIK_, F8)
EOS_UI_KEY_ENTRY(EOS_UIK_, F9)
EOS_UI_KEY_ENTRY(EOS_UIK_, F10)
EOS_UI_KEY_ENTRY(EOS_UIK_, F11)
EOS_UI_KEY_ENTRY(EOS_UIK_, F12)
EOS_UI_KEY_ENTRY(EOS_UIK_, F13)
EOS_UI_KEY_ENTRY(EOS_UIK_, F14)
EOS_UI_KEY_ENTRY(EOS_UIK_, F15)
EOS_UI_KEY_ENTRY(EOS_UIK_, F16)
EOS_UI_KEY_ENTRY(EOS_UIK_, F17)
EOS_UI_KEY_ENTRY(EOS_UIK_, F18)
EOS_UI_KEY_ENTRY(EOS_UIK_, F19)
EOS_UI_KEY_ENTRY(EOS_UIK_, F20)
EOS_UI_KEY_ENTRY(EOS_UIK_, F21)
EOS_UI_KEY_ENTRY(EOS_UIK_, F22)
EOS_UI_KEY_ENTRY(EOS_UIK_, F23)
EOS_UI_KEY_ENTRY(EOS_UIK_, F24)

EOS_UI_KEY_ENTRY(EOS_UIK_, OemPlus)
EOS_UI_KEY_ENTRY(EOS_UIK_, OemComma)
EOS_UI_KEY_ENTRY(EOS_UIK_, OemMinus)
EOS_UI_KEY_ENTRY(EOS_UIK_, OemPeriod)
/** ';' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem1)
/** '/' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem2)
/** '~' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem3)
/** '[' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem4)
/** '\' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem5)
/** ']' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem6)
/** '"' for US layout, others vary */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem7)
/** varies on all layouts */
EOS_UI_KEY_ENTRY(EOS_UIK_, Oem8)

/** Maximum key enumeration value. */
EOS_UI_KEY_CONSTANT_LAST(EOS_UIK_, MaxKeyType)

```

`EAC_SDK/SDK/include/eos_ui_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

/** Handle to the UI interface */
EXTERN_C typedef struct EOS_UIHandle* EOS_HUI;

/** ID representing a specific UI event. */
EXTERN_C typedef uint64_t EOS_UI_EventId;
#define EOS_UI_EVENTID_INVALID 0

/** The most recent version of the EOS_UI_ShowFriends API. */
#define EOS_UI_SHOWFRIENDS_API_LATEST 1

/**
 * Input parameters for the EOS_UI_ShowFriends function.
 */
EOS_STRUCT(EOS_UI_ShowFriendsOptions, (
	/** API Version: Set this to EOS_UI_SHOWFRIENDS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose friend list is being shown. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_UI_ShowFriends function.
 */
EOS_STRUCT(EOS_UI_ShowFriendsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UI_ShowFriends */
	void* ClientData;
	/** The Epic Account ID of the user whose friend list is being shown. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_ShowFriends
 * @param Data A EOS_UI_ShowFriendsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnShowFriendsCallback, const EOS_UI_ShowFriendsCallbackInfo* Data);

/** The most recent version of the EOS_UI_HideFriends API. */
#define EOS_UI_HIDEFRIENDS_API_LATEST 1

/**
 * Input parameters for the EOS_UI_HideFriends function.
 */
EOS_STRUCT(EOS_UI_HideFriendsOptions, (
	/** API Version: Set this to EOS_UI_HIDEFRIENDS_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose friend list is being shown. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Output parameters for the EOS_UI_HideFriends function.
 */
EOS_STRUCT(EOS_UI_HideFriendsCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UI_HideFriends */
	void* ClientData;
	/** The Epic Account ID of the user whose friend list is being shown. */
	EOS_EpicAccountId LocalUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_HideFriends
 * @param Data A EOS_UI_HideFriendsCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnHideFriendsCallback, const EOS_UI_HideFriendsCallbackInfo* Data);

/** The most recent version of the EOS_UI_GetFriendsVisible API. */
#define EOS_UI_GETFRIENDSVISIBLE_API_LATEST 1

/**
 * Input parameters for the EOS_UI_GetFriendsVisible function.
 */
EOS_STRUCT(EOS_UI_GetFriendsVisibleOptions, (
	/** API Version: Set this to EOS_UI_GETFRIENDSVISIBLE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose overlay is being checked. */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_UI_GetFriendsExclusiveInput API. */
#define EOS_UI_GETFRIENDSEXCLUSIVEINPUT_API_LATEST 1

/**
 * Input parameters for the EOS_UI_GetFriendsExclusiveInput function.
 */
EOS_STRUCT(EOS_UI_GetFriendsExclusiveInputOptions, (
	/** API Version: Set this to EOS_UI_GETFRIENDSEXCLUSIVEINPUT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user whose overlay is being checked. */
	EOS_EpicAccountId LocalUserId;
));

/** The most recent version of the EOS_UI_AddNotifyDisplaySettingsUpdated API. */
#define EOS_UI_ADDNOTIFYDISPLAYSETTINGSUPDATED_API_LATEST 1

/**
 * Input parameters for the EOS_UI_AddNotifyDisplaySettingsUpdated function.
 */
EOS_STRUCT(EOS_UI_AddNotifyDisplaySettingsUpdatedOptions, (
	/** API Version: Set this to EOS_UI_ADDNOTIFYDISPLAYSETTINGSUPDATED_API_LATEST. */
	int32_t ApiVersion;
));

EOS_STRUCT(EOS_UI_OnDisplaySettingsUpdatedCallbackInfo, (
	/** Context that was passed into EOS_UI_AddNotifyDisplaySettingsUpdated */
	void* ClientData;
	/** True when any portion of the overlay is visible. */
	EOS_Bool bIsVisible;
	/**
	 * True when the overlay has switched to exclusive input mode.
	 * While in exclusive input mode, no keyboard or mouse input will be sent to the game.
	 */
	EOS_Bool bIsExclusiveInput;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_AddNotifyDisplaySettingsUpdated
 * @param Data A EOS_UI_OnDisplaySettingsUpdatedCallbackInfo containing the current display state.
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnDisplaySettingsUpdatedCallback, const EOS_UI_OnDisplaySettingsUpdatedCallbackInfo* Data);

/**
 * Enum flags for storing a key combination. The low 16 bits are the key type, and modifiers are
 * stored in the next significant bits
 */
#define EOS_UI_KEY_CONSTANT(Prefix, Name, Value) Prefix ## Name = Value,
#define EOS_UI_KEY_MODIFIER(Prefix, Name, Value) Prefix ## Name = Value,
#define EOS_UI_KEY_MODIFIER_LAST(Prefix, Name, Value) Prefix ## Name = Value
#define EOS_UI_KEY_ENTRY_FIRST(Prefix, Name, Value) Prefix ## Name = Value,
#define EOS_UI_KEY_ENTRY(Prefix, Name) Prefix ## Name,
#define EOS_UI_KEY_CONSTANT_LAST(Prefix, Name) Prefix ## Name
EOS_ENUM_START(EOS_UI_EKeyCombination)
#include "eos_ui_keys.h"
EOS_ENUM_END(EOS_UI_EKeyCombination);
EOS_ENUM_BOOLEAN_OPERATORS(EOS_UI_EKeyCombination)

/**
 * Flags used in EOS_UI_ReportInputStateOptions to identify buttons which are down.
 */
EOS_ENUM_START(EOS_UI_EInputStateButtonFlags)
#include "eos_ui_buttons.h"
EOS_ENUM_END(EOS_UI_EInputStateButtonFlags);
EOS_ENUM_BOOLEAN_OPERATORS(EOS_UI_EInputStateButtonFlags);
#undef EOS_UI_KEY_CONSTANT
#undef EOS_UI_KEY_MODIFIER
#undef EOS_UI_KEY_MODIFIER_LAST
#undef EOS_UI_KEY_ENTRY_FIRST
#undef EOS_UI_KEY_ENTRY
#undef EOS_UI_KEY_CONSTANT_LAST

/** The most recent version of the EOS_UI_SetToggleFriendsKey API. */
#define EOS_UI_SETTOGGLEFRIENDSKEY_API_LATEST 1

/**
 * Input parameters for the EOS_UI_SetToggleFriendsKey function.
 */
EOS_STRUCT(EOS_UI_SetToggleFriendsKeyOptions, (
	/** API Version: Set this to EOS_UI_SETTOGGLEFRIENDSKEY_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The new key combination which will be used to toggle the friends overlay.
	 * The combination can be any set of modifiers and one key.
	 * A value of EOS_UIK_None will cause the key to revert to the default.
	 */
	EOS_UI_EKeyCombination KeyCombination;
));

/** The most recent version of the EOS_UI_GetToggleFriendsKey API. */
#define EOS_UI_GETTOGGLEFRIENDSKEY_API_LATEST 1

/**
 * Input parameters for the EOS_UI_GetToggleFriendsKey function.
 */
EOS_STRUCT(EOS_UI_GetToggleFriendsKeyOptions, (
	/** API Version: Set this to EOS_UI_GETTOGGLEFRIENDSKEY_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_UI_SetToggleFriendsButton API. */
#define EOS_UI_SETTOGGLEFRIENDSBUTTON_API_LATEST 1

/**
 * Input parameters for the EOS_UI_SetToggleFriendsButton function.
 */
EOS_STRUCT(EOS_UI_SetToggleFriendsButtonOptions, (
	/** API Version: Set this to EOS_UI_SETTOGGLEFRIENDSBUTTON_API_LATEST. */
	int32_t ApiVersion;
	/**
	 * The new button which will be used to toggle the friends overlay.
	 * It can be any combination of buttons.
	 * The default value is No Button. Set the value to EOS_UISBF_None to revert to the default.
	 */
	EOS_UI_EInputStateButtonFlags ButtonCombination;
));

/** The most recent version of the EOS_UI_GetToggleFriendsButton API. */
#define EOS_UI_GETTOGGLEFRIENDSBUTTON_API_LATEST 1

/**
 * Input parameters for the EOS_UI_GetToggleFriendsButton function.
 */
EOS_STRUCT(EOS_UI_GetToggleFriendsButtonOptions, (
	/** API Version: Set this to EOS_UI_GETTOGGLEFRIENDSBUTTON_API_LATEST. */
	int32_t ApiVersion;
));

/**
 * Notification locations to be used to set the preference
 * for pop-up.
 *
 * @see EOS_UI_SetDisplayPreference
 */
EOS_ENUM(EOS_UI_ENotificationLocation,
	EOS_UNL_TopLeft,
	EOS_UNL_TopRight,
	EOS_UNL_BottomLeft,
	EOS_UNL_BottomRight
);

/** The most recent version of the EOS_UI_SetDisplayPreference API. */
#define EOS_UI_SETDISPLAYPREFERENCE_API_LATEST 1

/**
 * Input parameters for the EOS_UI_SetDisplayPreference function.
 */
EOS_STRUCT(EOS_UI_SetDisplayPreferenceOptions, (
	/** API Version: Set this to EOS_UI_SETDISPLAYPREFERENCE_API_LATEST. */
	int32_t ApiVersion;
	/** Preference for notification pop-up locations. */
	EOS_UI_ENotificationLocation NotificationLocation;
));


/** The most recent version of the EOS_UI_AcknowledgeEventId API. */
#define EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST 1

/** DEPRECATED! Use EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST instead. */
#define EOS_UI_ACKNOWLEDGECORRELATIONID_API_LATEST EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST

/**
 * Input parameters for the EOS_UI_AcknowledgeEventId.
 */
EOS_STRUCT(EOS_UI_AcknowledgeEventIdOptions, (
	/** API Version: Set this to EOS_UI_ACKNOWLEDGEEVENTID_API_LATEST. */
	int32_t ApiVersion;
	/** The ID being acknowledged. */
	EOS_UI_EventId UiEventId;
	/**
	 * The result to use for the acknowledgment.
	 * When acknowledging EOS_Presence_JoinGameAcceptedCallbackInfo this should be the
	 * result code from the JoinSession call.
	 */
	EOS_EResult Result;
));

/** The most recent version of the EOS_UI_ReportInputState API. */
#define EOS_UI_REPORTINPUTSTATE_API_LATEST 2

/**
 * Input parameters for the EOS_UI_ReportInputState function.
 */
EOS_STRUCT(EOS_UI_ReportInputStateOptions, (
	/** API Version: Set this to EOS_UI_REPORTINPUTSTATE_API_LATEST. */
	int32_t ApiVersion;

	/** Flags to identify the current buttons which are pressed. */
	EOS_UI_EInputStateButtonFlags ButtonDownFlags;

	/**
	 * Whether the current platform and configuration uses the right face button as the default accept button.
	 * When this flag is true, the right face button is the accept action, and the down face button is the cancel action.
	 * When this flag is false, the right face button is the cancel action, and the down face button is the accept action.
	 */
	EOS_Bool bAcceptIsFaceButtonRight;

	/** The current state of the mouse button. */
	EOS_Bool bMouseButtonDown;

	/** The current x-position of the mouse. */
	uint32_t MousePosX;

	/** The current y-position of the mouse. */
	uint32_t MousePosY;

	/** The gamepad or player index */
	uint32_t GamepadIndex;

	/** Left analog stick horizontal movement in [-1, 1]. Negative for left, positive for right */
	float LeftStickX;

	/** Left analog stick vertical movement in [-1, 1]. Negative for up, positive for down */
	float LeftStickY;

	/** Right analog stick horizontal movement in [-1, 1]. Negative for left, positive for right */
	float RightStickX;

	/** Right analog stick vertical movement in [-1, 1]. Negative for up, positive for down */
	float RightStickY;

	/** Left trigger analog value in [0, 1] */
	float LeftTrigger;

	/** Right trigger analog value in [0, 1] */
	float RightTrigger;
));

/** The most recent version of the EOS_UI_PrePresent API. */
#define EOS_UI_PREPRESENT_API_LATEST 1

/**
 * Parameters for the EOS_UI_PrePresent function.
 */
EOS_STRUCT(EOS_UI_PrePresentOptions, (
	/** API Version: Set this to EOS_UI_PREPRESENT_API_LATEST. */
	int32_t ApiVersion;
	/** Platform specific data. */
	const void* PlatformSpecificData;
));

/** The most recent version of the EOS_UI_ShowBlockPlayer API. */
#define EOS_UI_SHOWBLOCKPLAYER_API_LATEST 1

/**
 * Parameters for the EOS_UI_ShowBlockPlayer function.
 */
EOS_STRUCT(EOS_UI_ShowBlockPlayerOptions, (
	/** API Version: Set this to EOS_UI_SHOWBLOCKPLAYER_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Online Services Account ID of the user who is requesting the Block. */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Online Services Account ID of the user whose is being Blocked. */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_UI_ShowBlockPlayer function.
 */
EOS_STRUCT(EOS_UI_OnShowBlockPlayerCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UI_ShowBlockPlayer */
	void* ClientData;
	/** The Epic Online Services Account ID of the user who requested the block. */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Online Services Account ID of the user who was to be blocked. */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_ShowBlockPlayer
 * @param Data A EOS_UI_OnShowBlockPlayerCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnShowBlockPlayerCallback, const EOS_UI_OnShowBlockPlayerCallbackInfo* Data);

/** The most recent version of the EOS_UI_ShowReportPlayer API. */
#define EOS_UI_SHOWREPORTPLAYER_API_LATEST 1

/**
 * Parameters for the EOS_UI_ShowReportPlayer function.
 */
EOS_STRUCT(EOS_UI_ShowReportPlayerOptions, (
	/** API Version: Set this to EOS_UI_SHOWREPORTPLAYER_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Online Services Account ID of the user who is requesting the Report. */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Online Services Account ID of the user whose is being Reported. */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_UI_ShowReportPlayer function.
 */
EOS_STRUCT(EOS_UI_OnShowReportPlayerCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UI_ShowReportPlayer */
	void* ClientData;
	/** The Epic Online Services Account ID of the user who requested the Report. */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Online Services Account ID of the user who was to be Reported. */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_ShowReportPlayer
 * @param Data A EOS_UI_OnShowReportPlayerCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnShowReportPlayerCallback, const EOS_UI_OnShowReportPlayerCallbackInfo* Data);

/** The most recent version of the EOS_UI_ShowNativeProfile API. */
#define EOS_UI_SHOWNATIVEPROFILE_API_LATEST 1

/**
 * Parameters for the EOS_UI_ShowNativeProfile function.
 */
EOS_STRUCT(EOS_UI_ShowNativeProfileOptions, (
	/** API Version: Set this to EOS_UI_SHOWNATIVEPROFILE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Online Services Account ID of the user who is requesting the profile. */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Online Services Account ID of the user whose profile is being requested. */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_UI_ShowNativeProfile function.
 */
EOS_STRUCT(EOS_UI_ShowNativeProfileCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UI_ShowNativeProfile */
	void* ClientData;
	/** The Epic Online Services Account ID of the user who requested the profile. */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Online Services Account ID of the user who was to have a profile shown. */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UI_ShowNativeProfile
 * @param Data A EOS_UI_ShowNativeProfileCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UI_OnShowNativeProfileCallback, const EOS_UI_ShowNativeProfileCallbackInfo* Data);


/** The most recent version of the EOS_UI_PauseSocialOverlay API. */
#define EOS_UI_PAUSESOCIALOVERLAY_API_LATEST 1

/**
 * Input parameters for the EOS_UI_PauseSocialOverlay function.
 */
EOS_STRUCT(EOS_UI_PauseSocialOverlayOptions, (
	/** API Version: Set this to EOS_UI_PAUSESOCIALOVERLAY_API_LATEST. */
	int32_t ApiVersion;
	/** The desired bIsPaused state of the overlay. */
	EOS_Bool bIsPaused;
));

/** The most recent version of the EOS_UI_IsSocialOverlayPaused API. */
#define EOS_UI_ISSOCIALOVERLAYPAUSED_API_LATEST 1

/**
 * Input parameters for the EOS_UI_IsSocialOverlayPaused function.
 */
EOS_STRUCT(EOS_UI_IsSocialOverlayPausedOptions, (
	/** API Version: Set this to EOS_UI_ISSOCIALOVERLAYPAUSED_API_LATEST. */
	int32_t ApiVersion;
));

/** The most recent version of the EOS_UI_Rect struct. */
#define EOS_UI_RECT_API_LATEST 1

/**
 * A rectangle.
 */
EOS_STRUCT(EOS_UI_Rect, (
	/** API Version: Set this to EOS_UI_RECT_API_LATEST. */
	int32_t ApiVersion;
	/** Left coordinate. */
	int32_t X;
	/** Top coordinate. */
	int32_t Y;
	/** Width. */
	uint32_t Width;
	/** Height. */
	uint32_t Height;
));

/** The most recent version of the EOS_UI_MemoryMonitorCallbackInfo struct. */
#define EOS_UI_MEMORYMONITORCALLBACKINFO_API_LATEST 1

/** A structure representing a memory monitoring message. */
EOS_STRUCT(EOS_UI_MemoryMonitorCallbackInfo, (
	/** Context that was passed into EOS_UI_AddNotifyMemoryMonitor */
	void* ClientData;

	/**
	 * This field is for system specific memory monitor report.
	 *
	 * If provided then the structure will be located in eos_<platform>_ui.h
	 * The structure will be named EOS_<platform>_MemoryMonitorReport.
	 */
	const void* SystemMemoryMonitorReport;
));

/** The most recent version of the EOS_UI_AddNotifyMemoryMonitor API. */
#define EOS_UI_ADDNOTIFYMEMORYMONITOR_API_LATEST 1
// For backward compatibility. Please use the value above as this will be removed in a later version
#define EOS_UI_ADDNOTIFYMEMORYMONITOROPTIONS_API_LATEST EOS_UI_ADDNOTIFYMEMORYMONITOR_API_LATEST

/**
 * Input parameters for the EOS_UI_AddNotifyMemoryMonitor function.
 */
EOS_STRUCT(EOS_UI_AddNotifyMemoryMonitorOptions, (
	/** API Version: Set this to EOS_UI_ADDNOTIFYMEMORYMONITOR_API_LATEST. */
	int32_t ApiVersion;
));

EOS_DECLARE_CALLBACK(EOS_UI_OnMemoryMonitorCallback, const EOS_UI_MemoryMonitorCallbackInfo* Data);

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_userinfo.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_userinfo_types.h"

/**
 * The UserInfo Interface is used to receive user information for Epic Account IDs from the backend services and to retrieve that information once it is cached.
 * All UserInfo Interface calls take a handle of type EOS_HUserInfo as the first parameter.
 * This handle can be retrieved from a EOS_HPlatform handle by using the EOS_Platform_GetUserInfoInterface function.
 *
 * @see EOS_Platform_GetUserInfoInterface
 */

/**
 * EOS_UserInfo_QueryUserInfo is used to start an asynchronous query to retrieve information, such as display name, about another account.
 * Once the callback has been fired with a successful ResultCode, it is possible to call EOS_UserInfo_CopyUserInfo to receive an EOS_UserInfo containing the available information.
 *
 * @param Options structure containing the input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_CopyUserInfo
 * @see EOS_UserInfo_QueryUserInfoOptions
 * @see EOS_UserInfo_OnQueryUserInfoCallback
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_QueryUserInfo(EOS_HUserInfo Handle, const EOS_UserInfo_QueryUserInfoOptions* Options, void* ClientData, const EOS_UserInfo_OnQueryUserInfoCallback CompletionDelegate);

/**
 * EOS_UserInfo_QueryUserInfoByDisplayName is used to start an asynchronous query to retrieve user information by display name. This can be useful for getting the EOS_EpicAccountId for a display name.
 * Once the callback has been fired with a successful ResultCode, it is possible to call EOS_UserInfo_CopyUserInfo to receive an EOS_UserInfo containing the available information.
 *
 * @param Options structure containing the input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_CopyUserInfo
 * @see EOS_UserInfo_QueryUserInfoByDisplayNameOptions
 * @see EOS_UserInfo_OnQueryUserInfoByDisplayNameCallback
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_QueryUserInfoByDisplayName(EOS_HUserInfo Handle, const EOS_UserInfo_QueryUserInfoByDisplayNameOptions* Options, void* ClientData, const EOS_UserInfo_OnQueryUserInfoByDisplayNameCallback CompletionDelegate);

/**
 * EOS_UserInfo_QueryUserInfoByExternalAccount is used to start an asynchronous query to retrieve user information by external accounts.
 * This can be useful for getting the EOS_EpicAccountId for external accounts.
 * Once the callback has been fired with a successful ResultCode, it is possible to call CopyUserInfo to receive an EOS_UserInfo containing the available information.
 *
 * @param Options structure containing the input parameters
 * @param ClientData arbitrary data that is passed back to you in the CompletionDelegate
 * @param CompletionDelegate a callback that is fired when the async operation completes, either successfully or in error
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_QueryUserInfoByExternalAccountOptions
 * @see EOS_UserInfo_OnQueryUserInfoByExternalAccountCallback
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_QueryUserInfoByExternalAccount(EOS_HUserInfo Handle, const EOS_UserInfo_QueryUserInfoByExternalAccountOptions* Options, void* ClientData, const EOS_UserInfo_OnQueryUserInfoByExternalAccountCallback CompletionDelegate);

/**
 * EOS_UserInfo_CopyUserInfo is used to immediately retrieve a copy of user information based on an Epic Account ID, cached by a previous call to EOS_UserInfo_QueryUserInfo.
 * If the call returns an EOS_Success result, the out parameter, OutUserInfo, must be passed to EOS_UserInfo_Release to release the memory associated with it.
 *
 * @param Options structure containing the input parameters
 * @param OutUserInfo out parameter used to receive the EOS_UserInfo structure.
 *
 * @return EOS_Success if the information is available and passed out in OutUserInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the user info is not locally cached. The information must have been previously cached by a call to EOS_UserInfo_QueryUserInfo
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_CopyUserInfoOptions
 * @see EOS_UserInfo_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyUserInfo(EOS_HUserInfo Handle, const EOS_UserInfo_CopyUserInfoOptions* Options, EOS_UserInfo ** OutUserInfo);

/**
 * Fetch the number of external user infos that are cached locally.
 *
 * @param Options The options associated with retrieving the external user info count
 *
 * @see EOS_UserInfo_CopyExternalUserInfoByIndex
 *
 * @return The number of external user infos, or 0 if there is an error
 */
EOS_DECLARE_FUNC(uint32_t) EOS_UserInfo_GetExternalUserInfoCount(EOS_HUserInfo Handle, const EOS_UserInfo_GetExternalUserInfoCountOptions* Options);

/**
 * Fetches an external user info from a given index.
 *
 * @param Options Structure containing the index being accessed
 * @param OutExternalUserInfo The external user info. If it exists and is valid, use EOS_UserInfo_ExternalUserInfo_Release when finished
 *
 * @see EOS_UserInfo_ExternalUserInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutExternalUserInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the external user info is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyExternalUserInfoByIndex(EOS_HUserInfo Handle, const EOS_UserInfo_CopyExternalUserInfoByIndexOptions* Options, EOS_UserInfo_ExternalUserInfo ** OutExternalUserInfo);

/**
 * Fetches an external user info for a given external account type.
 *
 * @param Options Structure containing the account type being accessed
 * @param OutExternalUserInfo The external user info. If it exists and is valid, use EOS_UserInfo_ExternalUserInfo_Release when finished
 *
 * @see EOS_UserInfo_ExternalUserInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutExternalUserInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the external user info is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyExternalUserInfoByAccountType(EOS_HUserInfo Handle, const EOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions* Options, EOS_UserInfo_ExternalUserInfo ** OutExternalUserInfo);

/**
 * Fetches an external user info for a given external account ID.
 *
 * @param Options Structure containing the account ID being accessed
 * @param OutExternalUserInfo The external user info. If it exists and is valid, use EOS_UserInfo_ExternalUserInfo_Release when finished
 *
 * @see EOS_UserInfo_ExternalUserInfo_Release
 *
 * @return EOS_Success if the information is available and passed out in OutExternalUserInfo
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_NotFound if the external user info is not found
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyExternalUserInfoByAccountId(EOS_HUserInfo Handle, const EOS_UserInfo_CopyExternalUserInfoByAccountIdOptions* Options, EOS_UserInfo_ExternalUserInfo ** OutExternalUserInfo);

/**
 * EOS_UserInfo_CopyBestDisplayName is used to immediately retrieve a copy of user's best display name based on an Epic Account ID.
 * This uses data cached by a previous call to EOS_UserInfo_QueryUserInfo, EOS_UserInfo_QueryUserInfoByDisplayName or EOS_UserInfo_QueryUserInfoByExternalAccount as well as EOS_Connect_QueryExternalAccountMappings.
 * If the call returns an EOS_Success result, the out parameter, OutBestDisplayName, must be passed to EOS_UserInfo_BestDisplayName_Release to release the memory associated with it.
 *
 * @details The current priority for picking display name is as follows:
 * 1. Target is online and friends with user, then use presence platform to determine display name
 * 2. Target is in same lobby or is the owner of a lobby search result, then use lobby platform to determine display name (this requires the target's product user id to be cached)
 * 3. Target is in same rtc room, then use rtc room platform to determine display name (this requires the target's product user id to be cached)
 * @param Options structure containing the input parameters
 * @param OutBestDisplayName out parameter used to receive the EOS_UserInfo_BestDisplayName structure.
 *
 * @return EOS_Success if the information is available and passed out in OutBestDisplayName
 *         EOS_UserInfo_BestDisplayNameIndeterminate unable to determine a cert friendly display name for user, one potential solution would be to call EOS_UserInfo_CopyBestDisplayNameWithPlatform with EOS_OPT_Epic for the platform, see doc for more details
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the user info or product user id is not locally cached
 *
 * @see EOS_UserInfo_QueryUserInfo
 * @see EOS_UserInfo_QueryUserInfoByDisplayName
 * @see EOS_UserInfo_QueryUserInfoByExternalAccount
 * @see EOS_Connect_QueryExternalAccountMappings
 * @see EOS_UserInfo_CopyBestDisplayNameWithPlatform
 * @see EOS_UserInfo_CopyBestDisplayNameOptions
 * @see EOS_UserInfo_BestDisplayName
 * @see EOS_UserInfo_BestDisplayName_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyBestDisplayName(EOS_HUserInfo Handle, const EOS_UserInfo_CopyBestDisplayNameOptions* Options, EOS_UserInfo_BestDisplayName ** OutBestDisplayName);

/**
 * EOS_UserInfo_CopyBestDisplayNameWithPlatform is used to immediately retrieve a copy of user's best display name based on an Epic Account ID.
 * This uses data cached by a previous call to EOS_UserInfo_QueryUserInfo, EOS_UserInfo_QueryUserInfoByDisplayName or EOS_UserInfo_QueryUserInfoByExternalAccount.
 * If the call returns an EOS_Success result, the out parameter, OutBestDisplayName, must be passed to EOS_UserInfo_BestDisplayName_Release to release the memory associated with it.
 *
 * @details The current priority for picking display name is as follows:
 * 1. If platform is non-epic, then use platform display name (if the platform is linked to the account)
 * 2. If platform is epic and user has epic display name, then use epic display name
 * 3. If platform is epic and user has no epic display name, then use linked external account display name
 * @param Options structure containing the input parameters
 * @param OutBestDisplayName out parameter used to receive the EOS_UserInfo_BestDisplayName structure.
 *
 * @return EOS_Success if the information is available and passed out in OutBestDisplayName
 *         EOS_UserInfo_BestDisplayNameIndeterminate unable to determine a cert friendly display name for user
 *         EOS_InvalidParameters if you pass a null pointer for the out parameter
 *         EOS_IncompatibleVersion if the API version passed in is incorrect
 *         EOS_NotFound if the user info is not locally cached
 *
 * @see EOS_UserInfo_QueryUserInfo
 * @see EOS_UserInfo_QueryUserInfoByDisplayName
 * @see EOS_UserInfo_QueryUserInfoByExternalAccount
 * @see EOS_UserInfo_CopyBestDisplayNameWithPlatformOptions
 * @see EOS_UserInfo_BestDisplayName
 * @see EOS_UserInfo_BestDisplayName_Release
 */
EOS_DECLARE_FUNC(EOS_EResult) EOS_UserInfo_CopyBestDisplayNameWithPlatform(EOS_HUserInfo Handle, const EOS_UserInfo_CopyBestDisplayNameWithPlatformOptions* Options, EOS_UserInfo_BestDisplayName ** OutBestDisplayName);

/**
 * EOS_UserInfo_GetLocalPlatformType is used to retrieve the online platform type of the current running instance of the game.
 *
 * @param Options structure containing the input parameters
 *
 * @return the online platform type of the current running instance of the game
 *
 * @see EOS_UserInfo_GetLocalPlatformTypeOptions
 */
EOS_DECLARE_FUNC(EOS_OnlinePlatformType) EOS_UserInfo_GetLocalPlatformType(EOS_HUserInfo Handle, const EOS_UserInfo_GetLocalPlatformTypeOptions* Options);

```

`EAC_SDK/SDK/include/eos_userinfo_types.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

#pragma pack(push, 8)

EXTERN_C typedef struct EOS_UserInfoHandle* EOS_HUserInfo;

/**
 * EOS_UserInfo_QueryUserInfo is used to start an asynchronous query to retrieve information, such as display name, about another account.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_UserInfo_QueryUserInfo API. */
#define EOS_USERINFO_QUERYUSERINFO_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_QueryUserInfo function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoOptions, (
	/** API Version: Set this to EOS_USERINFO_QUERYUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Output parameters for the EOS_UserInfo_QueryUserInfo Function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UserInfo_QueryUserInfo */
	void* ClientData;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UserInfo_QueryUserInfo
 * @param Data A EOS_UserInfo_QueryUserInfoCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UserInfo_OnQueryUserInfoCallback, const EOS_UserInfo_QueryUserInfoCallbackInfo* Data);


/**
 * EOS_UserInfo_QueryUserInfoByDisplayName is used to start an asynchronous query to retrieve user information by display name. This can be useful for getting the EOS_EpicAccountId for a display name.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_UserInfo_QueryUserInfoByDisplayName API. */
#define EOS_USERINFO_QUERYUSERINFOBYDISPLAYNAME_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_QueryUserInfoByDisplayName function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoByDisplayNameOptions, (
	/** API Version: Set this to EOS_USERINFO_QUERYUSERINFOBYDISPLAYNAME_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** Raw display name (un-sanitized) of the player being queried */
	const char* DisplayName;
));

/**
 * Output parameters for the EOS_UserInfo_QueryUserInfoByDisplayName Function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UserInfo_QueryUserInfoByDisplayName */
	void* ClientData;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** Display name (un-sanitized) of the player being queried. This memory is only valid during the scope of the callback. */
	const char* DisplayName;
));

/**
 * Function prototype definition for callbacks passed to EOS_UserInfo_QueryUserInfo
 * @param Data A EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UserInfo_OnQueryUserInfoByDisplayNameCallback, const EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo* Data);


/**
 * EOS_UserInfo_QueryUserInfoByExternalAccount is used to start an asynchronous query to retrieve user information by external account type.
 * This can be useful for getting the EOS_EpicAccountId for an external account.
 * The following types are used to work with the API.
 */

/** The most recent version of the EOS_UserInfo_QueryUserInfoByExternalAccount API. */
#define EOS_USERINFO_QUERYUSERINFOBYEXTERNALACCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_QueryUserInfoByExternalAccount function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoByExternalAccountOptions, (
	/** API Version: Set this to EOS_USERINFO_QUERYUSERINFOBYEXTERNALACCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** External account ID of the user whose information is being retrieved */
	const char* ExternalAccountId;
	/** Account type of the external user info to query */
	EOS_EExternalAccountType AccountType;
));

/**
 * Output parameters for the EOS_UserInfo_QueryUserInfoByExternalAccount Function.
 */
EOS_STRUCT(EOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo, (
	/** The EOS_EResult code for the operation. EOS_Success indicates that the operation succeeded; other codes indicate errors. */
	EOS_EResult ResultCode;
	/** Context that was passed into EOS_UserInfo_QueryUserInfoByExternalAccount */
	void* ClientData;
	/** The Epic Account ID of the local player who requested the information */
	EOS_EpicAccountId LocalUserId;
	/** External account id of the user whose information has been retrieved */
	const char* ExternalAccountId;
	/** Account type of the external account id */
	EOS_EExternalAccountType AccountType;
	/** Account ID of the player whose information has been retrieved */
	EOS_EpicAccountId TargetUserId;
));

/**
 * Function prototype definition for callbacks passed to EOS_UserInfo_QueryUserInfoByExternalAccount
 * @param Data A EOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo containing the output information and result
 */
EOS_DECLARE_CALLBACK(EOS_UserInfo_OnQueryUserInfoByExternalAccountCallback, const EOS_UserInfo_QueryUserInfoByExternalAccountCallbackInfo* Data);


/**
 * EOS_UserInfo_CopyUserInfo is used to immediately retrieve user information for an account ID, cached by a previous call to EOS_UserInfo_QueryUserInfo.
 * The following types are used to work with the API.
 */

/** The maximum length of display names, in displayable characters */
#define EOS_USERINFO_MAX_DISPLAYNAME_CHARACTERS 16

/** The maximum length of display names when encoded as UTF-8 as returned by EOS_UserInfo_CopyUserInfo. This length does not include the null terminator. */
#define EOS_USERINFO_MAX_DISPLAYNAME_UTF8_LENGTH 64

/** The most recent version of the EOS_UserInfo_CopyUserInfo API. */
#define EOS_USERINFO_COPYUSERINFO_API_LATEST 3

/** A structure that contains the user information. These structures are created by EOS_UserInfo_CopyUserInfo and must be passed to EOS_UserInfo_Release. */
EOS_STRUCT(EOS_UserInfo, (
	/** API Version: Set this to EOS_USERINFO_COPYUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user */
	EOS_EpicAccountId UserId;
	/** The name of the owner's country. This may be null */
	const char* Country;
	/** The display name (un-sanitized). This may be null */
	const char* DisplayName;
	/** The ISO 639 language code for the user's preferred language. This may be null */
	const char* PreferredLanguage;
	/** A nickname/alias for the target user assigned by the local user. This may be null */
	const char* Nickname;
	/** The raw display name (sanitized). This may be null */
	const char* DisplayNameSanitized;
));

/**
 * Input parameters for the EOS_UserInfo_CopyUserInfo function.
 */
EOS_STRUCT(EOS_UserInfo_CopyUserInfoOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/**
 *
 * @param UserInfo - The user info structure to release
 *
 * @see EOS_UserInfo
 * @see EOS_UserInfo_CopyUserInfo
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_Release(EOS_UserInfo* UserInfo);

/** The most recent version of the EOS_UserInfo_ExternalUserInfo struct. */
#define EOS_USERINFO_EXTERNALUSERINFO_API_LATEST 2

/**
 * Contains information about a single external user info.
 */
EOS_STRUCT(EOS_UserInfo_ExternalUserInfo, (
	/** API Version: Set this to EOS_USERINFO_EXTERNALUSERINFO_API_LATEST. */
	int32_t ApiVersion;
	/** The type of the external account */
	EOS_EExternalAccountType AccountType;
	/** The ID of the external account. Can be null */
	const char* AccountId;
	/** The display name of the external account (un-sanitized). Can be null */
	const char* DisplayName;
	/** The display name of the external account (sanitized). Can be null */
	const char* DisplayNameSanitized;
));

/** The most recent version of the EOS_Achievements_GetAchievementDefinitionCount API. */
#define EOS_USERINFO_GETEXTERNALUSERINFOCOUNT_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_GetExternalUserInfoCount function.
 */
EOS_STRUCT(EOS_UserInfo_GetExternalUserInfoCountOptions, (
	/** API Version: Set this to EOS_USERINFO_GETEXTERNALUSERINFOCOUNT_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/** The most recent version of the EOS_UserInfo_CopyExternalUserInfoByIndexOptions struct. */
#define EOS_USERINFO_COPYEXTERNALUSERINFOBYINDEX_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_CopyExternalUserInfoByIndex function.
 */
EOS_STRUCT(EOS_UserInfo_CopyExternalUserInfoByIndexOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYINDEX_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** Index of the external user info to retrieve from the cache */
	uint32_t Index;
));

/** The most recent version of the EOS_UserInfo_CopyExternalUserInfoByIndexOptions struct. */
#define EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTTYPE_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_CopyExternalUserInfoByAccountType function.
 */
EOS_STRUCT(EOS_UserInfo_CopyExternalUserInfoByAccountTypeOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTTYPE_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** Account type of the external user info to retrieve from the cache */
	EOS_EExternalAccountType AccountType;
));

/** The most recent version of the EOS_UserInfo_CopyExternalUserInfoByAccountIdOptions struct. */
#define EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTID_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_CopyExternalUserInfoByAccountId function.
 */
EOS_STRUCT(EOS_UserInfo_CopyExternalUserInfoByAccountIdOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYEXTERNALUSERINFOBYACCOUNTID_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** The external account ID associated with the (external) user info to retrieve from the cache; cannot be null */
	const char* AccountId;
));

/**
 * Release the memory associated with external user info. This must be called on data retrieved from
 * EOS_UserInfo_CopyExternalUserInfoByIndexOptions.
 *
 * @param ExternalUserInfo The external user info to release.
 *
 * @see EOS_UserInfo_ExternalUserInfo
 * @see EOS_UserInfo_CopyExternalUserInfoByIndex
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_ExternalUserInfo_Release(EOS_UserInfo_ExternalUserInfo* ExternalUserInfo);

/** The most recent version of the EOS_UserInfo_BestDisplayName API. */
#define EOS_USERINFO_BESTDISPLAYNAME_API_LATEST 1

/** A structure that contains the user information. These structures are created by EOS_UserInfo_CopyBestDisplayName or EOS_UserInfo_CopyBestDisplayNameWithPlatform and must be passed to EOS_UserInfo_BestDisplayName_Release. */
EOS_STRUCT(EOS_UserInfo_BestDisplayName, (
	/** API Version: Set this to EOS_USERINFO_BESTDISPLAYNAME_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the user */
	EOS_EpicAccountId UserId;
	/** The display name (un-sanitized). This may be null */
	const char* DisplayName;
	/** The raw display name (sanitized). This may be null */
	const char* DisplayNameSanitized;
	/** A nickname/alias for the target user assigned by the local user. This may be null */
	const char* Nickname;
	/** The platform type for the user which corresponds to the display name */
	EOS_OnlinePlatformType PlatformType;
));

/**
 * Release the memory associated with EOS_UserInfo_BestDisplayName. This must be called on data retrieved from
 * EOS_UserInfo_CopyBestDisplayNameWithPlatform.
 *
 * @param BestDisplayName - The EOS_UserInfo_BestDisplayName structure to release
 *
 * @see EOS_UserInfo_BestDisplayName
 * @see EOS_UserInfo_CopyBestDisplayName
 * @see EOS_UserInfo_CopyBestDisplayNameWithPlatform
 */
EOS_DECLARE_FUNC(void) EOS_UserInfo_BestDisplayName_Release(EOS_UserInfo_BestDisplayName* BestDisplayName);

/** The most recent version of the EOS_UserInfo_CopyBestDisplayName API. */
#define EOS_USERINFO_COPYBESTDISPLAYNAME_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_CopyBestDisplayName function.
 */
EOS_STRUCT(EOS_UserInfo_CopyBestDisplayNameOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYBESTDISPLAYNAME_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
));

/** The most recent version of the EOS_UserInfo_CopyBestDisplayNameWithPlatform API. */
#define EOS_USERINFO_COPYBESTDISPLAYNAMEWITHPLATFORM_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_CopyBestDisplayNameWithPlatform function.
 */
EOS_STRUCT(EOS_UserInfo_CopyBestDisplayNameWithPlatformOptions, (
	/** API Version: Set this to EOS_USERINFO_COPYBESTDISPLAYNAMEWITHPLATFORM_API_LATEST. */
	int32_t ApiVersion;
	/** The Epic Account ID of the local player requesting the information */
	EOS_EpicAccountId LocalUserId;
	/** The Epic Account ID of the player whose information is being retrieved */
	EOS_EpicAccountId TargetUserId;
	/** The platform type of the player whose information is being retrieved */
	EOS_OnlinePlatformType TargetPlatformType;
));

/** The most recent version of the EOS_UserInfo_GetLocalPlatformType API. */
#define EOS_USERINFO_GETLOCALPLATFORMTYPE_API_LATEST 1

/**
 * Input parameters for the EOS_UserInfo_GetLocalPlatformType function.
 */
EOS_STRUCT(EOS_UserInfo_GetLocalPlatformTypeOptions, (
	/** API Version: Set this to EOS_USERINFO_GETLOCALPLATFORMTYPE_API_LATEST. */
	int32_t ApiVersion;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/eos_version.h`:

```h

// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

// These numbers define the banner SDK version, and are the most significant numbers when ordering two engine versions (that is, a 4.12.* version is always
// newer than a 4.11.* version, regardless of the changelist that it was built with)
#define EOS_MAJOR_VERSION	1
#define EOS_MINOR_VERSION	16
#define EOS_PATCH_VERSION	3
 
// Macros for encoding strings
#define EOS_VERSION_STRINGIFY_2(x) #x
#define EOS_VERSION_STRINGIFY(x) EOS_VERSION_STRINGIFY_2(x)

// Various strings used for engine resources
#define EOS_COMPANY_NAME  "Epic Games, Inc."
#define EOS_COPYRIGHT_STRING "Copyright Epic Games, Inc. All Rights Reserved."
#define EOS_PRODUCT_NAME "Epic Online Services SDK"
#define EOS_PRODUCT_IDENTIFIER "Epic Online Services SDK"

#define EOS_VERSION_STRING_BASE                  \
	EOS_VERSION_STRINGIFY(EOS_MAJOR_VERSION) "." \
	EOS_VERSION_STRINGIFY(EOS_MINOR_VERSION) "." \
	EOS_VERSION_STRINGIFY(EOS_PATCH_VERSION)

#if defined(BUILT_FROM_CHANGELIST)
#define EOS_VERSION_STRING_AFTERCL               \
	EOS_VERSION_STRING_BASE "-"                  \
	EOS_VERSION_STRINGIFY(BUILT_FROM_CHANGELIST)
#else
#define EOS_VERSION_STRING_AFTERCL \
    EOS_VERSION_STRING_BASE
#endif

#if defined(BUILT_FOR_SDK_VERSION)
#define EOS_VERSION_STRING                       \
	EOS_VERSION_STRING_AFTERCL "+"               \
	EOS_VERSION_STRINGIFY(BUILT_FOR_SDK_VERSION)
#else
#define EOS_VERSION_STRING     \
	EOS_VERSION_STRING_AFTERCL
#endif

#ifndef RC_INVOKED

#include "eos_base.h"

/**
 * Get the version of the compiled EOSSDK binary
 * MAJOR.MINOR.PATCH-CHANGELIST#-PLATFORMSDKVERSION
 * 
 * It is the version available at runtime
 * It should match the version of the headers being used
 * 
 * @return the version of the compiled EOSSDK binary
 */
EOS_DECLARE_FUNC(const char*) EOS_GetVersion(void);

#endif /* #ifndef RC_INVOKED */

```

`EAC_SDK/SDK/include/linux/eos_Linux.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/********************************************************************
 * Provided to allow EOS_BUILD_PLATFORM_NAME to be defined even for
 * platforms that do not require it when using eos_platform_prereqs.h
 ********************************************************************/
```

`EAC_SDK/SDK/include/linux/eos_Linux_base.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/********************************************************************
 * Provided to allow EOS_BUILD_PLATFORM_NAME to be defined even for
 * platforms that do not require it when using eos_platform_prereqs.h
 ********************************************************************/
```

`EAC_SDK/SDK/include/mac/eos_Mac.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

```

`EAC_SDK/SDK/include/mac/eos_Mac_base.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/********************************************************************
 * Provided to allow EOS_BUILD_PLATFORM_NAME to be defined even for
 * platforms that do not require it when using eos_platform_prereqs.h
 ********************************************************************/
```

`EAC_SDK/SDK/include/windows/eos_Windows.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_types.h"

#pragma pack(push, 8)

/** The most recent version of the EOS_Windows_RTCOptions structure. */
#define EOS_WINDOWS_RTCOPTIONS_API_LATEST 1

/**
 * Options for initializing rtc functionality required for some platforms.
 */
EOS_STRUCT(EOS_Windows_RTCOptions, (
	/** API Version: Set this to EOS_WINDOWS_RTCOPTIONS_API_LATEST. */
	int32_t ApiVersion;

	/** The absolute path to a `xaudio2_9redist.dll` dependency, including the file name. */
	const char* XAudio29DllPath;
));

#pragma pack(pop)

```

`EAC_SDK/SDK/include/windows/eos_Windows_base.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/********************************************************************
 * Provided to allow EOS_BUILD_PLATFORM_NAME to be defined even for
 * platforms that do not require it when using eos_platform_prereqs.h
 ********************************************************************/
```

`EAC_SDK/Samples/Achievements/Achievements.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>Achievements</RootNamespace>
    <ProjectGuid>{DE49D417-147B-4684-9FE1-3B733AF02889}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Achievements</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_LIBCURL_ENABLED;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Achievements/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/External/curl/Include;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);libcurl.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_LIBCURL_ENABLED;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Achievements/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/External/curl/Include;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies);libcurl.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release;$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_LIBCURL_ENABLED;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Achievements/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/External/curl/Include;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);libcurl.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release;$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release\libcurl.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_LIBCURL_ENABLED;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Achievements/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/External/curl/Include;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies);libcurl.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release;$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release\libcurl.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_LIBCURL_ENABLED;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Achievements/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/External/curl/Include;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);libcurl.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release;$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_LIBCURL_ENABLED;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Achievements/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/External/curl/Include;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies);libcurl.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release;$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_LIBCURL_ENABLED;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Achievements/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/External/curl/Include;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies);libcurl.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_LIBCURL_ENABLED;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Achievements/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/External/curl/Include;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies);libcurl.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release;$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_achievements.h" />
    <ClInclude Include="..\..\SDK\Include\eos_achievements_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_stats.h" />
    <ClInclude Include="..\..\SDK\Include\eos_stats_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\HTTPClient.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\NotificationDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Achievements.h" />
    <ClInclude Include="Source\AchievementsDefinitionsDialog.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\SampleConstants.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\HTTPClient.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\NotificationDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Achievements.cpp" />
    <ClCompile Include="Source\AchievementsDefinitionsDialog.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/Achievements/Achievements.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Achievements.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\AchievementsDefinitionsDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_achievements.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_achievements_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_stats.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_stats_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\NotificationDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\HTTPClient.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Achievements.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\AchievementsDefinitionsDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
	<ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\NotificationDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\HTTPClient.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/Achievements/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
xcopy /D /Y /R /Q ..\Shared\External\curl\Lib\Win32\libcurl.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R /Q ..\Shared\External\curl\Lib\Win32\libcurl.dll .\Bin\Win32\Release_DX\
xcopy /D /Y /R /Q ..\Shared\External\curl\Lib\Win64\libcurl.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R /Q ..\Shared\External\curl\Lib\Win64\libcurl.dll .\Bin\Win64\Release_DX\
pause
```

`EAC_SDK/Samples/Achievements/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/Achievements/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\curl\Lib\Win32\libcurl.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\curl\Lib\Win32\libcurl.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\curl\Lib\Win64\libcurl.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\curl\Lib\Win64\libcurl.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/Achievements/Source/Achievements.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "Utils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "Achievements.h"
#include "HTTPClient.h"
#include <eos_sdk.h>
#include <eos_achievements.h>
#include <eos_stats.h>

#include <time.h>

void FPlayerAchievementData::InitFromSDKData(EOS_Achievements_PlayerAchievement* PlayerAchievement)
{
	if (PlayerAchievement->AchievementId)
	{
		AchievementId = FStringUtils::Widen(PlayerAchievement->AchievementId);
	}

	// Note: Undefined = EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED
	UnlockTime = PlayerAchievement->UnlockTime;

	if (PlayerAchievement->StatInfoCount == 0)
	{
		// We have no stats so use overall progress
		Progress = PlayerAchievement->Progress;
	}
	else
	{
		double NumStatsCompleted = 0.0;

		for (int32_t StatIndex = 0; StatIndex < PlayerAchievement->StatInfoCount; ++StatIndex)
		{
			std::wstring StatName = FStringUtils::Widen(PlayerAchievement->StatInfo[StatIndex].Name);

			FStatProgress StatProgress;
			StatProgress.CurValue = PlayerAchievement->StatInfo[StatIndex].CurrentValue;
			StatProgress.ThresholdValue = PlayerAchievement->StatInfo[StatIndex].ThresholdValue;

			Stats.emplace(StatName, StatProgress);

			if (StatProgress.CurValue >= StatProgress.ThresholdValue)
			{
				NumStatsCompleted += 1.0;
			}
		}

		Progress = NumStatsCompleted * (1.0 / PlayerAchievement->StatInfoCount);
	}
}

FAchievements::FAchievements()
	: AchievementsUnlockedNotificationId(EOS_INVALID_NOTIFICATIONID)
{
	
}

FAchievements::~FAchievements()
{
}

void FAchievements::Init()
{
	if (FPlatform::GetPlatformHandle() != nullptr)
	{
		AchievementsHandle = EOS_Platform_GetAchievementsInterface(FPlatform::GetPlatformHandle());

		StatsHandle = EOS_Platform_GetStatsInterface(FPlatform::GetPlatformHandle());

		/*if (FPlatform::GetPlatformHandle())
		{
			DefaultLanguage = L"en";
			EOS_Platform_SetOverrideLocaleCode(FPlatform::GetPlatformHandle(), FStringUtils::Narrow(DefaultLanguage).c_str());
		}*/

		SubscribeToAchievementsUnlockedNotification();
	}
}

void FAchievements::OnShutdown()
{
	UnsubscribeFromAchievementsUnlockedNotification();
}

void FAchievements::Update()
{

}

void FAchievements::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedOut(UserId);
	}
	else if (!bDebugNotify && Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		QueryDefinitions();
		QueryPlayerAchievements(Event.GetProductUserId());
		QueryStats();
	}
	else if (!bDebugNotify && Event.GetType() == EGameEventType::AchievementsUnlocked)
	{
		QueryPlayerAchievements(Event.GetProductUserId());
	}
	else if (!bDebugNotify && Event.GetType() == EGameEventType::StatsIngested)
	{
		QueryPlayerAchievements(Event.GetProductUserId());
	}
}

void FAchievements::OnLoggedIn(FEpicAccountId UserId)
{
	
}

void FAchievements::OnLoggedOut(FEpicAccountId UserId)
{
	if (FPlayerManager::Get().GetNumPlayers() == 0)
	{
		FGameEvent Event(EGameEventType::NoUserLoggedIn);
		FGame::Get().OnGameEvent(Event);
	}
}

bool FAchievements::CheckAndTriggerDownloadForIconData(const std::wstring& URL)
{
	auto Iter = IconsData.find(URL);
	if (Iter == IconsData.end())
	{
		FHTTPClient::GetInstance().PerformHTTPRequest(FStringUtils::Narrow(URL), FHTTPClient::EHttpRequestMethod::GET, std::string(), [URL](FHTTPClient::HTTPErrorCode ErrorCode, const std::vector<char>& Data)
		{
			if (ErrorCode == 200)
			{
				FGame::Get().GetAchievements()->IconsData[URL] = Data;
			}
			else
			{
				std::string ErrorString(Data.data(), Data.size());
				FDebugLog::LogError(L"Could not load icon data. HTTP Request failed: %ls", FStringUtils::Widen(ErrorString).c_str());
				FGame::Get().GetAchievements()->IconsData.erase(URL);
			}
		}
		);
		IconsData[URL] = std::vector<char>();
		return true;
	}
	else
	{
		return false;
	}
}

void FAchievements::QueryDefinitions()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"FAchievements - QueryDefinitions: Current player is invalid!");
		return;
	}

	EOS_Achievements_QueryDefinitionsOptions QueryDefinitionsOptions = {};
	QueryDefinitionsOptions.ApiVersion = EOS_ACHIEVEMENTS_QUERYDEFINITIONS_API_LATEST;
	QueryDefinitionsOptions.LocalUserId = Player->GetProductUserID();

	EOS_Achievements_QueryDefinitions(AchievementsHandle, &QueryDefinitionsOptions, nullptr, AchievementDefinitionsReceivedCallbackFn);
}

void FAchievements::QueryPlayerAchievements(FProductUserId UserId)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Achievements - QueryPlayerAchievements: Current player is invalid!");
		return;
	}

	if (!UserId.IsValid())
	{
		// Use local player's id
		UserId = Player->GetProductUserID();
	}

	EOS_Achievements_QueryPlayerAchievementsOptions QueryPlayerAchievementsOptions = {};
	QueryPlayerAchievementsOptions.ApiVersion = EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST;
	QueryPlayerAchievementsOptions.LocalUserId = Player->GetProductUserID();
	QueryPlayerAchievementsOptions.TargetUserId = UserId;

	EOS_Achievements_QueryPlayerAchievements(AchievementsHandle, &QueryPlayerAchievementsOptions, nullptr, PlayerAchievementsReceivedCallbackFn);
}

void FAchievements::UnlockAchievements(const std::vector<std::wstring>& AchievementIds)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Achievements - UnlockAchievements: Current player is invalid!");
		return;
	}

	EOS_Achievements_UnlockAchievementsOptions UnlockAchievementsOptions = {};
	UnlockAchievementsOptions.ApiVersion = EOS_ACHIEVEMENTS_UNLOCKACHIEVEMENTS_API_LATEST;
	UnlockAchievementsOptions.UserId = Player->GetProductUserID();
	UnlockAchievementsOptions.AchievementsCount = (uint32_t)AchievementIds.size();
	UnlockAchievementsOptions.AchievementIds = new const char*[AchievementIds.size()];
	std::vector<std::string> NarrowIDs;
	for (std::wstring AchievementId : AchievementIds)
	{
		NarrowIDs.emplace_back(FStringUtils::Narrow(AchievementId));
	}
	for (uint32_t Index = 0; Index < AchievementIds.size(); ++Index)
	{
		UnlockAchievementsOptions.AchievementIds[Index] = NarrowIDs[Index].c_str();
	}

	EOS_Achievements_UnlockAchievements(AchievementsHandle, &UnlockAchievementsOptions, nullptr, UnlockAchievementsReceivedCallbackFn);

	delete[] UnlockAchievementsOptions.AchievementIds;
}

void FAchievements::SubscribeToAchievementsUnlockedNotification()
{
	UnsubscribeFromAchievementsUnlockedNotification();

	EOS_Achievements_AddNotifyAchievementsUnlockedV2Options AchievementsUnlockedNotifyOptions = {};
	AchievementsUnlockedNotifyOptions.ApiVersion = EOS_ACHIEVEMENTS_ADDNOTIFYACHIEVEMENTSUNLOCKEDV2_API_LATEST;
	AchievementsUnlockedNotificationId = EOS_Achievements_AddNotifyAchievementsUnlockedV2(AchievementsHandle, &AchievementsUnlockedNotifyOptions, nullptr, AchievementsUnlockedReceivedCallbackFn);
}

void FAchievements::UnsubscribeFromAchievementsUnlockedNotification()
{
	if (AchievementsUnlockedNotificationId != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Achievements_RemoveNotifyAchievementsUnlocked(AchievementsHandle, AchievementsUnlockedNotificationId);
		AchievementsUnlockedNotificationId = EOS_INVALID_NOTIFICATIONID;
	}
}

bool FAchievements::GetIconData(const std::wstring& AchievementId, std::vector<char>& OutData, bool bLocked /*= false*/)
{
	std::shared_ptr<FAchievementsDefinitionData> AchievementDefinition;
	if (!GetDefinitionFromId(AchievementId, AchievementDefinition) || !AchievementDefinition)
	{
		return false;
	}

	const std::wstring IconURL = (bLocked) ? AchievementDefinition->LockedIconURL : AchievementDefinition->UnlockedIconURL;
	if (IconsData.find(IconURL) != IconsData.end())
	{
		OutData = IconsData[IconURL];
		return !OutData.empty();
	}
	else
	{
		return false;
	}
}

void EOS_CALL FAchievements::AchievementDefinitionsReceivedCallbackFn(const EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Achievements - Get Definitions Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] Achievements - Get Definitions Complete");

	FGame::Get().GetAchievements()->CacheAchievementsDefinitions();
}

void EOS_CALL FAchievements::PlayerAchievementsReceivedCallbackFn(const EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Achievements - Get Player Achievements Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] Achievements - Get Player Achievements Completed - LocalUserId: %ls, TargetUserId: %ls", FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->LocalUserId)).c_str(), FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->TargetUserId)).c_str());

	FGame::Get().GetAchievements()->CachePlayerAchievements(Data->TargetUserId);

	FGameEvent Event(EGameEventType::PlayerAchievementsReceived, Data->TargetUserId);
	FGame::Get().OnGameEvent(Event);
}

void EOS_CALL FAchievements::UnlockAchievementsReceivedCallbackFn(const EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Achievements - Unlock Achievements Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] Achievements - Unlock Achievement Completed - User ID: %ls", FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->UserId)).c_str());
}

void EOS_CALL FAchievements::StatsIngestCallbackFn(const EOS_Stats_IngestStatCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Achievements - Ingest Stats Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] Achievements - Stats Ingest Complete");

	FGameEvent Event(EGameEventType::StatsIngested, Data->TargetUserId);
	FGame::Get().OnGameEvent(Event);
}

void EOS_CALL FAchievements::StatsQueryCallbackFn(const EOS_Stats_OnQueryStatsCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Achievements - Query Stats Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FGame::Get().GetAchievements()->CacheStats(Data->TargetUserId);

	FDebugLog::Log(L"[EOS SDK] Achievements - Stats Query Complete");

	FGameEvent Event(EGameEventType::StatsQueried, Data->TargetUserId);
	FGame::Get().OnGameEvent(Event);
}

void EOS_CALL FAchievements::AchievementsUnlockedReceivedCallbackFn(const EOS_Achievements_OnAchievementsUnlockedCallbackV2Info* Data)
{
	const std::wstring WideAchievementId = FStringUtils::Widen(Data->AchievementId);
	FDebugLog::Log(L"Achievements Unlocked: %ls", WideAchievementId.c_str());
	FGame::Get().GetAchievements()->NotifyUnlockedAchievement(WideAchievementId);

	FGameEvent Event(EGameEventType::AchievementsUnlocked, Data->UserId);
	FGame::Get().OnGameEvent(Event);
}

void FAchievements::CacheAchievementsDefinitions()
{
	EOS_HAchievements AchievementsHandle = EOS_Platform_GetAchievementsInterface(FPlatform::GetPlatformHandle());

	EOS_Achievements_GetAchievementDefinitionCountOptions AchievementDefinitionsCountOptions = {};
	AchievementDefinitionsCountOptions.ApiVersion = EOS_ACHIEVEMENTS_GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST;

	uint32_t AchievementDefinitionsCount = EOS_Achievements_GetAchievementDefinitionCount(AchievementsHandle, &AchievementDefinitionsCountOptions);

	EOS_Achievements_CopyAchievementDefinitionV2ByIndexOptions CopyOptions = {};
	CopyOptions.ApiVersion = EOS_ACHIEVEMENTS_COPYDEFINITIONV2BYACHIEVEMENTID_API_LATEST;

	// Clear definitions
	CachedAchievementsDefinitionData.clear();

	for (CopyOptions.AchievementIndex = 0; CopyOptions.AchievementIndex < AchievementDefinitionsCount; ++CopyOptions.AchievementIndex)
	{
		EOS_Achievements_DefinitionV2* AchievementDef = NULL;
		EOS_EResult CopyAchievementDefinitionsResult = EOS_Achievements_CopyAchievementDefinitionV2ByIndex(AchievementsHandle, &CopyOptions, &AchievementDef);
		if (CopyAchievementDefinitionsResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"CopyAchievementDefinitions Failure!");
			break;
		}

		std::shared_ptr<FAchievementsDefinitionData> AchievementsDefinition = std::make_shared<FAchievementsDefinitionData>();

		AchievementsDefinition->bIsHidden = AchievementDef->bIsHidden;

		AchievementsDefinition->AchievementId = FStringUtils::Widen(AchievementDef->AchievementId);

		if (AchievementDef->UnlockedDisplayName)
		{
			AchievementsDefinition->UnlockedDisplayName = FStringUtils::Widen(AchievementDef->UnlockedDisplayName);
		}

		if (AchievementDef->UnlockedDescription)
		{
			AchievementsDefinition->UnlockedDescription = FStringUtils::Widen(AchievementDef->UnlockedDescription);
		}

		if (AchievementDef->LockedDisplayName)
		{
			AchievementsDefinition->LockedDisplayName = FStringUtils::Widen(AchievementDef->LockedDisplayName);
		}

		if (AchievementDef->LockedDescription)
		{
			AchievementsDefinition->LockedDescription = FStringUtils::Widen(AchievementDef->LockedDescription);
		}

		if (AchievementDef->FlavorText)
		{
			AchievementsDefinition->FlavorText = FStringUtils::Widen(AchievementDef->FlavorText);
		}

		if (AchievementDef->UnlockedIconURL)
		{
			AchievementsDefinition->UnlockedIconURL = FStringUtils::Widen(AchievementDef->UnlockedIconURL);
			CheckAndTriggerDownloadForIconData(AchievementsDefinition->UnlockedIconURL);
		}

		if (AchievementDef->LockedIconURL)
		{
			AchievementsDefinition->LockedIconURL = FStringUtils::Widen(AchievementDef->LockedIconURL);
			CheckAndTriggerDownloadForIconData(AchievementsDefinition->LockedIconURL);
		}

		for (uint32_t StatIndex = 0; StatIndex < AchievementDef->StatThresholdsCount; ++StatIndex)
		{
			FStatInfo StatInfo;
			StatInfo.Name = FStringUtils::Widen(AchievementDef->StatThresholds[StatIndex].Name);
			StatInfo.ThresholdValue = AchievementDef->StatThresholds[StatIndex].Threshold;
			AchievementsDefinition->StatInfo.emplace_back(StatInfo);
		}

		CachedAchievementsDefinitionData.emplace_back(AchievementsDefinition);

		// Release Achievement Definition
		EOS_Achievements_DefinitionV2_Release(AchievementDef);
	}

	PrintAchievementDefinitions();

	FGameEvent Event(EGameEventType::DefinitionsReceived);
	FGame::Get().OnGameEvent(Event);
}

void FAchievements::CachePlayerAchievements(const EOS_ProductUserId UserId)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"CachePlayerAchievements - Local user is invalid");
		return;
	}

	EOS_HAchievements AchievementsHandle = EOS_Platform_GetAchievementsInterface(FPlatform::GetPlatformHandle());

	EOS_Achievements_GetPlayerAchievementCountOptions AchievementsCountOptions = {};
	AchievementsCountOptions.ApiVersion = EOS_ACHIEVEMENTS_GETPLAYERACHIEVEMENTCOUNT_API_LATEST;
	AchievementsCountOptions.UserId = UserId;

	uint32_t AchievementsCount = EOS_Achievements_GetPlayerAchievementCount(AchievementsHandle, &AchievementsCountOptions);

	EOS_Achievements_CopyPlayerAchievementByIndexOptions CopyOptions = {};
	CopyOptions.ApiVersion = EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST;
	CopyOptions.TargetUserId = UserId;
	CopyOptions.LocalUserId = Player->GetProductUserID();

	// Clear user achievements
	CachedPlayerAchievements.erase(UserId);

	std::vector<std::shared_ptr<FPlayerAchievementData>> PlayerAchievements;
	std::vector<std::shared_ptr<FPlayerAchievementData>> UnlockedAchievements;

	for (CopyOptions.AchievementIndex = 0; CopyOptions.AchievementIndex < AchievementsCount; ++CopyOptions.AchievementIndex)
	{
		EOS_Achievements_PlayerAchievement* Achievement = NULL;
		EOS_EResult CopyAchievementResult = EOS_Achievements_CopyPlayerAchievementByIndex(AchievementsHandle, &CopyOptions, &Achievement);
		if (CopyAchievementResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"CopyPlayerAchievement Failure!");
			break;
		}

		std::shared_ptr<FPlayerAchievementData> PlayerAchievement = std::make_shared<FPlayerAchievementData>();
		PlayerAchievement->InitFromSDKData(Achievement);
		PlayerAchievements.push_back(PlayerAchievement);

		if (PlayerAchievement->UnlockTime != EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED)
		{
			UnlockedAchievements.push_back(PlayerAchievement);
		}

		// Release
		EOS_Achievements_PlayerAchievement_Release(Achievement);
	}

	CachedPlayerAchievements.emplace(UserId, PlayerAchievements);

	PrintPlayerAchievements(UserId);
}

void FAchievements::CacheStats(const EOS_ProductUserId UserId)
{
	EOS_HStats StatsHandle = EOS_Platform_GetStatsInterface(FPlatform::GetPlatformHandle());

	EOS_Stats_GetStatCountOptions StatCountOptions = {};
	StatCountOptions.ApiVersion = EOS_STATS_GETSTATCOUNT_API_LATEST;
	StatCountOptions.TargetUserId = UserId;

	uint32_t StatsCount = EOS_Stats_GetStatsCount(StatsHandle, &StatCountOptions);

	EOS_Stats_Stat* Stat = NULL;
	EOS_Stats_CopyStatByIndexOptions CopyByIndexOptions = {};
	CopyByIndexOptions.ApiVersion = EOS_STATS_COPYSTATBYINDEX_API_LATEST;
	CopyByIndexOptions.TargetUserId = UserId;

	// Clear user stats
	CachedStats.erase(UserId);

	std::vector<std::shared_ptr<FStatData>> Stats;

	for (CopyByIndexOptions.StatIndex = 0; CopyByIndexOptions.StatIndex < StatsCount; ++CopyByIndexOptions.StatIndex)
	{
		EOS_EResult CopyStatResult = EOS_Stats_CopyStatByIndex(StatsHandle, &CopyByIndexOptions, &Stat);
		if (CopyStatResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Copy Stat failure");
			break;
		}

		std::shared_ptr<FStatData> StatData = std::make_shared<FStatData>();

		if (Stat->Name)
		{
			StatData->Name = FStringUtils::Widen(Stat->Name);
		}

		// Note: Undefined = EOS_STATS_QUERYSTATS_API_LATEST
		StatData->StartTime = Stat->StartTime;
		StatData->EndTime = Stat->EndTime;

		StatData->Value = Stat->Value;

		Stats.emplace_back(StatData);

		// Release
		EOS_Stats_Stat_Release(Stat);
	}

	CachedStats.emplace(UserId, Stats);

	PrintStats(UserId);
}

void FAchievements::PrintAchievementDefinitions()
{
	// Print info
	FDebugLog::Log(L"%d Achievements:", CachedAchievementsDefinitionData.size());

	for (uint32_t AchievementIndex = 0; AchievementIndex < CachedAchievementsDefinitionData.size(); ++AchievementIndex)
	{
		FDebugLog::Log(L"-------------");
		FDebugLog::Log(L"Achievement: %d", AchievementIndex + 1);

		std::shared_ptr<FAchievementsDefinitionData> AchievementDef = CachedAchievementsDefinitionData[AchievementIndex];

		FDebugLog::Log(L"Is Hidden: %ls", AchievementDef->bIsHidden ? L"true" : L"false");

		if (!AchievementDef->AchievementId.empty())
		{
			FDebugLog::Log(L"Achievement ID: %ls", AchievementDef->AchievementId.c_str());
		}
		if (!AchievementDef->UnlockedDisplayName.empty())
		{
			FDebugLog::Log(L"Display Name: %ls", AchievementDef->UnlockedDisplayName.c_str());
		}
		if (!AchievementDef->UnlockedDescription.empty())
		{
			FDebugLog::Log(L"Description: %ls", AchievementDef->UnlockedDescription.c_str());
		}
		if (!AchievementDef->LockedDisplayName.empty())
		{
			FDebugLog::Log(L"Locked Display Name: %ls", AchievementDef->LockedDisplayName.c_str());
		}
		if (!AchievementDef->LockedDescription.empty())
		{
			FDebugLog::Log(L"Locked Description: %ls", AchievementDef->LockedDescription.c_str());
		}
		if (!AchievementDef->UnlockedIconURL.empty())
		{
			FDebugLog::Log(L"Unlocked Icon: %ls", AchievementDef->UnlockedIconURL.c_str());
		}
		if (!AchievementDef->LockedIconURL.empty())
		{
			FDebugLog::Log(L"Locked Icon: %ls", AchievementDef->LockedIconURL.c_str());
		}
		if (!AchievementDef->FlavorText.empty())
		{
			FDebugLog::Log(L"Flavor text: %ls", AchievementDef->FlavorText.c_str());
		}
		if (!AchievementDef)
		{
			FDebugLog::Log(L"Flavor text: %ls", AchievementDef->FlavorText.c_str());
		}

		FDebugLog::Log(L"-------------");
	}
}

void FAchievements::PrintPlayerAchievements(FProductUserId UserId)
{
	auto it = CachedPlayerAchievements.find(UserId);
	if (it != CachedPlayerAchievements.end())
	{
		int AchievementIndex = 0;
		std::vector<std::shared_ptr<FPlayerAchievementData>> AchData = it->second;

		FDebugLog::Log(L"%d Achievements for UserId: %ls", AchData.size(), UserId.ToString().c_str());

		for (std::shared_ptr<FPlayerAchievementData> NextAchievement : AchData)
		{
			FDebugLog::Log(L"-------------");
			FDebugLog::Log(L"Achievement: %d", AchievementIndex + 1);

			if (!NextAchievement->AchievementId.empty())
			{
				FDebugLog::Log(L"Achievement ID: %ls", NextAchievement->AchievementId.c_str());
			}
			FDebugLog::Log(L"Progress: %f", NextAchievement->Progress);
			if (NextAchievement->UnlockTime == EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED)
			{
				FDebugLog::Log(L"Unlock Time: Undefined");
			}
			else
			{
				std::wstring DateTimeStrW = FUtils::ConvertUnixTimestampToUTCString(NextAchievement->UnlockTime);
				FDebugLog::Log(L"Unlock Time: %ls", DateTimeStrW.c_str());
			}

			FDebugLog::Log(L"Stat Info: %d", NextAchievement->Stats.size());
			for (auto Itr = NextAchievement->Stats.begin(); Itr != NextAchievement->Stats.end(); ++Itr)
			{
				FDebugLog::Log(L"  Name: %ls, Current: %d, Threshold: %d",
					Itr->first.c_str(),
					Itr->second.CurValue,
					Itr->second.ThresholdValue);
			}

			FDebugLog::Log(L"-------------");

			++AchievementIndex;
		}
	}
}

void FAchievements::PrintStats(FProductUserId UserId)
{
	auto it = CachedStats.find(UserId);
	if (it != CachedStats.end())
	{
		int StatIndex = 0;
		std::vector<std::shared_ptr<FStatData>> StatData = it->second;

		FDebugLog::Log(L"%d Stat for UserId: %ls", StatData.size(), UserId.ToString().c_str());

		for (std::shared_ptr<FStatData> NextStat : StatData)
		{
			FDebugLog::Log(L"-------------");
			FDebugLog::Log(L"Stat: %d", StatIndex + 1);

			FDebugLog::Log(L"Name: %ls", NextStat->Name.c_str());
			if (NextStat->StartTime == EOS_STATS_TIME_UNDEFINED)
			{
				FDebugLog::Log(L"Start Time: Undefined");
			}
			else
			{
				std::wstring StartTimeStrW = FUtils::ConvertUnixTimestampToUTCString(NextStat->StartTime);
				FDebugLog::Log(L"Start Time: %ls", StartTimeStrW.c_str());
			}
			if (NextStat->EndTime == EOS_STATS_TIME_UNDEFINED)
			{
				FDebugLog::Log(L"End Time: Undefined");
			}
			else
			{
				std::wstring EndTimeStrW = FUtils::ConvertUnixTimestampToUTCString(NextStat->EndTime);
				FDebugLog::Log(L"End Time: %ls", EndTimeStrW.c_str());
			}
			FDebugLog::Log(L"Value: %d", NextStat->Value);

			FDebugLog::Log(L"-------------");

			++StatIndex;
		}
	}
}

void FAchievements::NotifyUnlockedAchievement(const std::wstring& AchievementId)
{
	std::wstring Msg = L"Achievement Unlocked: " + AchievementId;
	FGameEvent Event(EGameEventType::AddNotification, Msg);
	FGame::Get().OnGameEvent(Event);
}

std::vector<std::shared_ptr<FAchievementsDefinitionData>>& FAchievements::GetCachedDefinitions()
{
	return CachedAchievementsDefinitionData;
}

std::vector<std::wstring> FAchievements::GetDefinitionIds()
{
	std::vector<std::wstring> DefinitionIds;

	for (std::shared_ptr<FAchievementsDefinitionData>& NextDefinition : CachedAchievementsDefinitionData)
	{
		if (!NextDefinition->AchievementId.empty())
		{
			DefinitionIds.emplace_back(NextDefinition->AchievementId);
		}
	}

	return DefinitionIds;
}

bool FAchievements::GetDefinitionFromId(const std::wstring& AchievementId, std::shared_ptr<FAchievementsDefinitionData>& OutDef)
{
	for (std::shared_ptr<FAchievementsDefinitionData> NextDefinition : CachedAchievementsDefinitionData)
	{
		if (NextDefinition->AchievementId == AchievementId)
		{
			OutDef = NextDefinition;
			return true;
		}
	}

	return false;
}

bool FAchievements::GetDefinitionFromIndex(int InIndex, std::shared_ptr<FAchievementsDefinitionData>& OutDef)
{
	int Index = 0;
	for (std::shared_ptr<FAchievementsDefinitionData> NextDefinition : CachedAchievementsDefinitionData)
	{
		if (Index == InIndex)
		{
			OutDef = NextDefinition;
			return true;
		}
		++Index;
	}

	return false;
}

bool FAchievements::GetCachedPlayerAchievements(FProductUserId UserId, std::vector<std::shared_ptr<FPlayerAchievementData>>& OutAchievements)
{
	auto it = CachedPlayerAchievements.find(UserId.AccountId);
	if (it != CachedPlayerAchievements.end())
	{
		OutAchievements = it->second;
		return true;
	}

	return false;
}

bool FAchievements::GetPlayerAchievementFromId(const std::wstring& AchievementId, std::shared_ptr<FPlayerAchievementData>& OutAchievement)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		return false;
	}

	auto it = CachedPlayerAchievements.find(Player->GetProductUserID());
	if (it != CachedPlayerAchievements.end())
	{
		std::vector< std::shared_ptr<FPlayerAchievementData>> AchData = it->second;
		for (std::shared_ptr<FPlayerAchievementData> NextAchievement : AchData)
		{
			if (NextAchievement->AchievementId == AchievementId)
			{
				OutAchievement = NextAchievement;
				return true;
			}
		}
	}

	return false;
}

void FAchievements::SetDefaultLanguage()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		DefaultLanguage = FStringUtils::Widen(Player->GetLocale());
	}
	else
	{
		char Buffer[EOS_LOCALECODE_MAX_BUFFER_LEN];
		int32_t BufferLen = sizeof(Buffer);
		if (EOS_Platform_GetOverrideLocaleCode(FPlatform::GetPlatformHandle(), Buffer, &BufferLen) == EOS_EResult::EOS_Success)
		{
			DefaultLanguage = FStringUtils::Widen(Buffer);
		}
		else
		{
			DefaultLanguage = L"en";
		}
	}
}

std::wstring FAchievements::GetDefaultLanguage()
{
	return DefaultLanguage;
}

void FAchievements::IngestStats(const std::vector<FStatIngest>& Stats)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Achievements - IngestStats: Current player is invalid!");
		return;
	}

	EOS_Stats_IngestStatOptions StatsIngestOptions = {};
	StatsIngestOptions.ApiVersion = EOS_STATS_INGESTSTAT_API_LATEST;
	StatsIngestOptions.LocalUserId = Player->GetProductUserID();
	StatsIngestOptions.TargetUserId = Player->GetProductUserID();
	StatsIngestOptions.StatsCount = (uint32_t)Stats.size();

	EOS_Stats_IngestData* IngestData = new EOS_Stats_IngestData[Stats.size()];

	std::vector<std::string> NarrowStatNames;
	for (FStatIngest Stat : Stats)
	{
		NarrowStatNames.emplace_back(FStringUtils::Narrow(Stat.Name));
	}

	for (uint32_t Index = 0; Index < Stats.size(); ++Index)
	{
		IngestData[Index].ApiVersion = EOS_STATS_INGESTDATA_API_LATEST;
		IngestData[Index].StatName = NarrowStatNames[Index].c_str();
		IngestData[Index].IngestAmount = Stats[Index].Amount;
	}

	StatsIngestOptions.Stats = IngestData;

	EOS_Stats_IngestStat(StatsHandle, &StatsIngestOptions, nullptr, StatsIngestCallbackFn);

	delete[] IngestData;
}

void FAchievements::IngestStat(const std::wstring& StatName, int Amount)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Achievements - IngestStat: Current player is invalid!");
		return;
	}

	if (StatName.empty())
	{
		FDebugLog::LogError(L"Achievements - IngestStat: Stat Name is empty");
		return;
	}

	if (Amount <= 0)
	{
		FDebugLog::LogError(L"Achievements - IngestStat: Amount is invalid");
		return;
	}

	EOS_Stats_IngestStatOptions StatsIngestOptions = {};
	StatsIngestOptions.ApiVersion = EOS_STATS_INGESTSTAT_API_LATEST;
	StatsIngestOptions.LocalUserId = Player->GetProductUserID();
	StatsIngestOptions.TargetUserId = Player->GetProductUserID();
	StatsIngestOptions.StatsCount = 1;

	EOS_Stats_IngestData* IngestData = new EOS_Stats_IngestData[StatsIngestOptions.StatsCount];

	IngestData[0].ApiVersion = EOS_STATS_INGESTDATA_API_LATEST;
	std::string Name = FStringUtils::Narrow(StatName);
	IngestData[0].StatName = Name.c_str();
	IngestData[0].IngestAmount = Amount;

	StatsIngestOptions.Stats = IngestData;

	EOS_Stats_IngestStat(StatsHandle, &StatsIngestOptions, nullptr, StatsIngestCallbackFn);

	delete[] IngestData;
}

void FAchievements::IngestStat(const std::wstring& StatName, int Amount, FProductUserId TargetUserId)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Achievements - IngestStat: Current player is invalid!");
		return;
	}

	if (!TargetUserId.IsValid())
	{
		FDebugLog::LogError(L"Achievements - IngestStat: Target player is invalid!");
		return;
	}

	if (StatName.empty())
	{
		FDebugLog::LogError(L"Achievements - IngestStat: Stat Name is empty");
		return;
	}

	if (Amount <= 0)
	{
		FDebugLog::LogError(L"Achievements - IngestStat: Amount is invalid");
		return;
	}

	EOS_Stats_IngestStatOptions StatsIngestOptions = {};
	StatsIngestOptions.ApiVersion = EOS_STATS_INGESTSTAT_API_LATEST;
	StatsIngestOptions.LocalUserId = Player->GetProductUserID();
	StatsIngestOptions.TargetUserId = TargetUserId;
	StatsIngestOptions.StatsCount = 1;

	EOS_Stats_IngestData* IngestData = new EOS_Stats_IngestData[StatsIngestOptions.StatsCount];

	IngestData[0].ApiVersion = EOS_STATS_INGESTDATA_API_LATEST;
	std::string Name = FStringUtils::Narrow(StatName);
	IngestData[0].StatName = Name.c_str();
	IngestData[0].IngestAmount = Amount;

	StatsIngestOptions.Stats = IngestData;

	EOS_Stats_IngestStat(StatsHandle, &StatsIngestOptions, nullptr, StatsIngestCallbackFn);

	delete[] IngestData;
}

void FAchievements::QueryStats()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Achievements - QueryStats: Current player is invalid!");
		return;
	}

	// Query Player Stats
	EOS_Stats_QueryStatsOptions StatsQueryOptions = {};
	StatsQueryOptions.ApiVersion = EOS_STATS_QUERYSTATS_API_LATEST;
	StatsQueryOptions.LocalUserId = Player->GetProductUserID();
	StatsQueryOptions.TargetUserId = Player->GetProductUserID();

	// Optional params
	StatsQueryOptions.StartTime = EOS_STATS_TIME_UNDEFINED;
	StatsQueryOptions.EndTime = EOS_STATS_TIME_UNDEFINED;
	StatsQueryOptions.StatNamesCount = 0;
	StatsQueryOptions.StatNames = NULL;

	//StatsQueryOptions.StartTime = 1575417600; // 12/04/2019 @ 12:00am (UTC)
	//StatsQueryOptions.EndTime = 1575590400; // 12/06/2019 @ 12:00am (UTC)
	//StatsQueryOptions.StatNamesCount = 2;
	//StatsQueryOptions.StatNames = new const char*[StatsQueryOptions.StatNamesCount];
	//StatsQueryOptions.StatNames[0] = "test_sum_stat_1";
	//StatsQueryOptions.StatNames[1] = "test_sum_stat_2";

	EOS_Stats_QueryStats(StatsHandle, &StatsQueryOptions, nullptr, StatsQueryCallbackFn);

	//delete[] StatsQueryOptions.StatNames;
}

```

`EAC_SDK/Samples/Achievements/Source/Achievements.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_sdk.h"
#include "eos_achievements.h"
#include "AccountHelpers.h"

/**
 * Stat info
 */
struct FStatInfo
{
	/** Stat name. */
	std::wstring Name;

	/** Stat threshold value. */
	int32_t ThresholdValue = 0;
};

/**
 * Structure to store all data related to achievements definitions.
 */
struct FAchievementsDefinitionData
{
	FAchievementsDefinitionData() = default;

	/** Achievement ID that can be used to uniquely identify the achievement. */
	std::wstring AchievementId;
	/** Localized display name for the achievement when it has been unlocked. */
	std::wstring UnlockedDisplayName;
	/** Localized description for the achievement when it has been unlocked. */
	std::wstring UnlockedDescription;
	/** Localized display name for the achievement when it is locked or hidden. */
	std::wstring LockedDisplayName;
	/** Localized description for the achievement when it is locked or hidden. */
	std::wstring LockedDescription;
	/** Localized flavor text that can be used by the game in an arbitrary manner. This may be null if there is no data configured in the dev portal */
	std::wstring FlavorText;
	/** URL of an icon to display for the achievement when it is unlocked. This may be null if there is no data configured in the dev portal */
	std::wstring UnlockedIconURL;
	/** URL of an icon to display for the achievement when it is locked or hidden. This may be null if there is no data configured in the dev portal */
	std::wstring LockedIconURL;
	/** True if achievement is hidden, false otherwise. */
	EOS_Bool bIsHidden = EOS_FALSE;
	/** Array of info for stats info. */
	std::vector<FStatInfo> StatInfo;
};

/**
 * Progress for a player stat
 */
struct FStatProgress
{
	/** Current value of player stat. */
	int32_t CurValue = 0;

	/** Threshold value of player stat. */
	int32_t ThresholdValue = 0;
};

/**
 * Structure to store all data related to player achievements.
 */
struct FPlayerAchievementData
{
	FPlayerAchievementData() = default;
	void InitFromSDKData(EOS_Achievements_PlayerAchievement* PlayerAchievement);

	/** Achievement ID that can be used to uniquely identify the achievement. */
	std::wstring AchievementId;
	/** Progress towards completing this achievement (as a percentage). */
	double Progress = 0.0;
	/** If not EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED then this is the POSIX timestamp that the achievement was unlocked */
	int64_t UnlockTime = 0;
	/** Array of info for player stats progress. */
	std::map<std::wstring, FStatProgress> Stats;
};

/**
 * Structure to store all data related to stats.
 */
struct FStatData
{
	FStatData() = default;

	/** Stat name. */
	std::wstring Name;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for Start Time */
	int64_t StartTime = 0;
	/** If not EOS_STATS_TIME_UNDEFINED then this is the POSIX timestamp for End Time */
	int64_t EndTime = 0;
	/** Stat value */
	int Value = 0;
};

/**
 * A single stat to ingest
 */
struct FStatIngest
{
public:
	/** Name of Stat to ingest */
	std::wstring Name;
	/** Ingest amount */
	int Amount = 0;
};

/**
 * Manages achievements.
 */
class FAchievements
{
public:
	/**
	 * Constructor
	 */
	FAchievements() noexcept(false);

	/**
	 * No copying or copy assignment allowed for this class.
	 */
	FAchievements(FAchievements const&) = delete;
	FAchievements& operator=(FAchievements const&) = delete;

	/**
	 * Destructor
	 */
	virtual ~FAchievements();

	/**
	 * Initialization
	 */
	void Init();

	/**
	 * Called during shutdown to allow cleanup.
	 */
	void OnShutdown();

	/**
	 * Update
	 */
	void Update();

	/**
	 * Receives game event
	 *
	 * @param Event - Game event to act on
	 */
	void OnGameEvent(const FGameEvent& Event);

	/**
	 * Starts requesting achievement definitions
	 */
	void QueryDefinitions();

	/**
	 * Starts requesting player achievements
	 */
	void QueryPlayerAchievements(FProductUserId UserId);

	/**
	 * Starts requesting unlocking of achievements
	 *
	 * @param AchievementIds - Ids of achievements to unlock
	 */
	void UnlockAchievements(const std::vector<std::wstring>& AchievementIds);

	/**
	 * Called after achievement definitions have been received, stores definitions to show on UI
	 */
	void CacheAchievementsDefinitions();

	/**
	 * Called after player achievements have been received, stores achievements to show progress on UI
	 */
	void CachePlayerAchievements(const EOS_ProductUserId UserId);

	/**
	 * Called after stats have been queried
	 */
	void CacheStats(const EOS_ProductUserId UserId);

	/**
	 * Prints info about Cached Achievement Definitions
	 */
	void PrintAchievementDefinitions();

	/**
	 * Prints info about Cached Player Achievements
	 */
	void PrintPlayerAchievements(FProductUserId UserId);

	/**
	 * Prints info about Cached Stats
	 */
	void PrintStats(FProductUserId UserId);

	/**
	 * Sends notification for unlocked achievement
	 */
	void NotifyUnlockedAchievement(const std::wstring& AchievementId);

	/**
	 * Return the current state of the debug notify flag.
	 */
	bool GetDebugNotify() const { return bDebugNotify; }

	/**
	 * Toggle the debug notify flag then return it.
	 */
	bool ToggleDebugNotify() { bDebugNotify = !bDebugNotify; return bDebugNotify; }

	/**
	 * Gets stored achievement definitions
	 */
	std::vector<std::shared_ptr<FAchievementsDefinitionData>>& GetCachedDefinitions();

	/**
	 * Gets Ids for all stored achievement definitions
	 */
	std::vector<std::wstring> GetDefinitionIds();

	/**
	 * Retrieves achievement definition matching the achievement Id given
	 *
	 * @return True if definition is found, false otherwise
	 */
	bool GetDefinitionFromId(const std::wstring& AchievementId, std::shared_ptr<FAchievementsDefinitionData>& OutDef);

	/**
	 * Retrieves achievement definition matching the index for the achievement based on the order the definitions were stored
	 *
	 * @return True if definition is found, false otherwise
	 */
	bool GetDefinitionFromIndex(int InIndex, std::shared_ptr<FAchievementsDefinitionData>& OutDef);

	/**
	 * Retrieves stored player achievements data for a specified user
	 *
	 * @return True if achievements are found, false otherwise
	 */
	bool GetCachedPlayerAchievements(FProductUserId UserId, std::vector<std::shared_ptr<FPlayerAchievementData>>& OutAchievements);

	/**
	 * Retrieves stored player achievement data based on achievement Id
	 *
	 * @return True if achievement is found, false otherwise
	 */
	bool GetPlayerAchievementFromId(const std::wstring& AchievementId, std::shared_ptr<FPlayerAchievementData>& OutAchievement);

	/** Sets the default language for achievement info display. */
	void SetDefaultLanguage();

	/** Gets default language to use for achievement info display. */
	std::wstring GetDefaultLanguage();

	/**
	 * Starts requesting stats ingest
	 *
	 * @param Stats - Stats to ingest
	 */
	void IngestStats(const std::vector<FStatIngest>& Stats);

	/**
	 * Starts requesting stats ingest for single stat
	 *
	 * @param StatName - Name of Stat to ingest
	 * @param Amount - Amount to ingest
	 */
	void IngestStat(const std::wstring& StatName, int Amount);

	/**
	 * Starts requesting stats ingest for single stat
	 *
	 * @param StatName - Name of Stat to ingest
	 * @param Amount - Amount to ingest
	 * @param TargetUserId - User ID for the target user whose stat we're ingesting
	 */
	void IngestStat(const std::wstring& StatName, int Amount, FProductUserId TargetUserId);

	/**
	 * Starts querying stats for current user
	 */
	void QueryStats();

	/**
	 * Subscribe to achievements unlocked notifications
	 */
	void SubscribeToAchievementsUnlockedNotification();

	/**
	 * Unsubscribe from achievements unlocked notifications
	 */
	void UnsubscribeFromAchievementsUnlockedNotification();

	/** 
	 * Get Icon data for specific achievement. Returns true when data is retrieved successfully.
	 */
	bool GetIconData(const std::wstring& AchievementId, std::vector<char>& OutData, bool bLocked = false);

private:
	/**
	 * Called after a user has logged in
	 */
	void OnLoggedIn(FEpicAccountId UserId);

	/**
	 * Called after a user has logged out
	 */
	void OnLoggedOut(FEpicAccountId UserId);

	/** 
	 * Check and trigger download for icon data.
	 */
	bool CheckAndTriggerDownloadForIconData(const std::wstring& URL);

	/**
	 * Callback called after achievement definitions have been retrieved
	 */
	static void EOS_CALL AchievementDefinitionsReceivedCallbackFn(const EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo* Data);

	/**
	 * Callback called after player achievements data has been retrieved
	 */
	static void EOS_CALL PlayerAchievementsReceivedCallbackFn(const EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo* Data);

	/**
	 * Callback called after achievements have been unlocked
	 */
	static void EOS_CALL UnlockAchievementsReceivedCallbackFn(const EOS_Achievements_OnUnlockAchievementsCompleteCallbackInfo* Data);

	/**
	 * Callback called after stats have been ingested
	 */
	static void EOS_CALL StatsIngestCallbackFn(const EOS_Stats_IngestStatCompleteCallbackInfo* Data);

	/**
	 * Callback called after stats have been queried
	 */
	static void EOS_CALL StatsQueryCallbackFn(const EOS_Stats_OnQueryStatsCompleteCallbackInfo* Data);

	/**
	 * Callback called after achievement has been unlocked
	 */
	static void EOS_CALL AchievementsUnlockedReceivedCallbackFn(const EOS_Achievements_OnAchievementsUnlockedCallbackV2Info* Data);

	/** Default Language */
	std::wstring DefaultLanguage;

	/** Handle to EOS SDK achievements system */
	EOS_HAchievements AchievementsHandle = nullptr;

	/** Handle to EOS SDK stats system */
	EOS_HStats StatsHandle = nullptr;

	/** Notification Id for achievement unlocked */
	EOS_NotificationId AchievementsUnlockedNotificationId = EOS_INVALID_NOTIFICATIONID;

	/** Cached data with user achievement definitions */
	std::vector<std::shared_ptr<FAchievementsDefinitionData>> CachedAchievementsDefinitionData;

	/** Cached data with player achievements */
	std::map<EOS_ProductUserId, std::vector<std::shared_ptr<FPlayerAchievementData>>> CachedPlayerAchievements;

	/** Cached data with stats */
	std::map<EOS_ProductUserId, std::vector<std::shared_ptr<FStatData>>> CachedStats;

	/** Downloaded and cached data for achievement icons */
	std::unordered_map<std::wstring, std::vector<char>> IconsData;

	/**
	 * When true then queries from this class will be disabled and the app will
	 * rely on the automatic queries performed by the SDK for the Social Overlay.
	 */
	bool bDebugNotify = false;
};

```

`EAC_SDK/Samples/Achievements/Source/AchievementsDefinitionsDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "AchievementsDefinitionsDialog.h"
#include "Achievements.h"
#include "Utils/Utils.h"

template<>
std::shared_ptr<FAchievementsDefinitionName> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& Data)
{
	return std::make_shared<FAchievementsDefinitionName>(Pos, Size, Layer, Data, L"Assets/black_grey_button.dds");
}

void FAchievementsDefinitionName::SetFocused(bool bValue)
{
	if (BackgroundImage && bValue != IsFocused())
	{
		FColor CurrentColor = BackgroundImage->GetBackgroundColor();

		const float Diff = 0.3f;
		FColor Adjustment = (bValue) ? FColor(Diff, Diff, Diff, Diff) : FColor(-Diff, -Diff, -Diff, 0.0f);

		CurrentColor.A += Adjustment.A;
		CurrentColor.R += Adjustment.R;
		CurrentColor.G += Adjustment.G;
		CurrentColor.B += Adjustment.B;

		BackgroundImage->SetBackgroundColor(CurrentColor);
	}

	FTextLabelWidget::SetFocused(bValue);
}

void FAchievementsDefinitionName::SetData(const std::wstring& Data)
{
	if (Font)
	{
		const Vector2 TextSize = Font->MeasureString(Data.c_str());
		const float TextWidth = TextSize.x;
		const float TextHeight = TextSize.y;
		const float TextFieldWidth = Size.x - HorizontalOffset;

		//We need to truncate
		if (TextFieldWidth < TextWidth && TextFieldWidth > 0.0f)
		{
			const size_t NumTotalChars = Data.size();
			const size_t NumCharsThatCanFitApproximately = static_cast<size_t>((TextFieldWidth / TextWidth) * NumTotalChars) - 1;

			//Don't truncate when we have small number of characters
			if (NumTotalChars > 10)
			{
				std::wstring TruncatedString;

				//Take first 30% of text
				const size_t FirstPartOfTextSize = static_cast<size_t>(NumCharsThatCanFitApproximately * 0.3);
				const size_t LastPartOfTextSize = NumCharsThatCanFitApproximately - FirstPartOfTextSize - 3; //3 is for ... chars

				TruncatedString = Data.substr(0, FirstPartOfTextSize) + L"..." + Data.substr(NumTotalChars - LastPartOfTextSize);

				SetText(TruncatedString);
				return;
			}
		}
	}

	SetText(Data);
}

template<>
std::shared_ptr<FAchievementsDefinitionInfo> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& Data)
{
	return std::make_shared<FAchievementsDefinitionInfo>(Pos, Size, Layer, Data, L"Assets/black_grey_button.dds");
}

void FAchievementsDefinitionInfo::SetFocused(bool bValue)
{
	
}

const Vector2 DefinitionsPosition = Vector2(10.0f, 270.0f);

FAchievementsDefinitionsDialog::FAchievementsDefinitionsDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer),
	CurrentSelectionIndex(-1),
	CurrentLanguageIndex(0),
	UpdateStatsIngestButtonCounter(0)
{
	HeaderLabel = std::make_shared<FTextLabelWidget>(
		DefinitionsPosition,
		Vector2(DialogSize.x, 25.0f),
		Layer - 1,
		std::wstring(L"Achievements"),
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	HeaderLabel->SetFont(DialogNormalFont);

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/console.dds",
		FColor(1.f, 1.f, 1.f, 1.f));

	AchievementsDefinitionNames = std::make_shared<FAchievementsDefinitionNamesList>(
		DialogPos,
		DialogSize,
		DialogLayer - 1,
		20.0f, // entry height
		20.0f, // label height
		15.0f, // scroller width
		L"", // background
		L"Definitions", // title text
		DialogNormalFont, // normal text
		DialogNormalFont, // title
		DialogSmallFont,
		DialogTinyFont);

	AchievementsDefinitionsList = std::make_shared<FAchievementsDefinitionsList>(
		DialogPos,
		DialogSize,
		DialogLayer - 1,
		20.0f, // entry height
		20.0f, // label height
		15.0f, // scroller width
		L"", // background
		L"Selected Definition Info", //title text
		DialogTinyFont, // normal text
		DialogNormalFont, // title
		DialogTinyFont,
		DialogTinyFont);

	LanguageLabel = std::make_shared<FTextLabelWidget>(
		DefinitionsPosition,
		Vector2(DialogSize.x, 25.0f),
		Layer - 1,
		std::wstring(L"Language: en"),
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	LanguageLabel->SetFont(DialogSmallFont);
	LanguageLabel->Hide();

	UnlockAchievementButton = std::make_shared<FButtonWidget>(
		Vector2(100.0f, 0.0f),
		Vector2(70, 25.f),
		Layer - 1,
		L"Unlock",
		assets::DefaultButtonAssets,
		DialogSmallFont,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
		);
	UnlockAchievementButton->SetBackgroundColors(assets::DefaultButtonColors);
	UnlockAchievementButton->SetOnPressedCallback([this]()
	{
		UnlockSelectedAchievement();
	});
	UnlockAchievementButton->Disable();

	UpdatePlayerAchievementsButton = std::make_shared<FButtonWidget>(
		Vector2(100.0f, 0.0f),
		Vector2(70, 25.f),
		Layer - 1,
		L"Update",
		assets::DefaultButtonAssets,
		DialogSmallFont,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
		);
	UpdatePlayerAchievementsButton->SetBackgroundColors(assets::DefaultButtonColors);
	UpdatePlayerAchievementsButton->SetOnPressedCallback([this]()
	{
		FGame::Get().GetAchievements()->QueryPlayerAchievements(FProductUserId());
		FGame::Get().GetAchievements()->QueryStats();
	});
	UpdatePlayerAchievementsButton->Disable();

	StatsIngestLabel = std::make_shared<FTextLabelWidget>(
		Vector2(50.f, 50.f),
		Vector2(100.f, 30.f),
		Layer - 1,
		L"Stats:",
		L"");
	StatsIngestLabel->SetFont(DialogSmallFont);

	StatsIngestNameField = std::make_shared<FTextFieldWidget>(
		Vector2(50.f, 50.f),
		Vector2(150.f, 30.f),
		Layer - 1,
		L"Name",
		L"Assets/textfield.dds",
		DialogSmallFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left);
	StatsIngestNameField->SetBorderColor(Color::UIBorderGrey);
	StatsIngestNameField->Disable();

	StatsIngestAmountField = std::make_shared<FTextFieldWidget>(
		Vector2(50.f, 50.f),
		Vector2(80.f, 30.f),
		Layer - 1,
		L"Amount",
		L"Assets/textfield.dds",
		DialogSmallFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left);
	StatsIngestAmountField->SetBorderColor(Color::UIBorderGrey);
	StatsIngestAmountField->Disable();

	StatsIngestButton = std::make_shared<FButtonWidget>(
		Vector2(100.0f, 0.0f),
		Vector2(60, 25.f),
		Layer - 1,
		L"Ingest Stat",
		assets::DefaultButtonAssets,
		DialogSmallFont,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
		);
	StatsIngestButton->SetBackgroundColors(assets::DefaultButtonColors);
	StatsIngestButton->SetOnPressedCallback([this]()
	{
		StatsIngest();
	});
	StatsIngestButton->Disable();

	LockedIconStateLabel = std::make_shared<FTextLabelWidget>(
		Vector2(50.f, 50.f),
		Vector2(50.0f, 50.f),
		Layer - 1,
		L"Locked icon: NA",
		L"");
	LockedIconStateLabel->SetFont(DialogSmallFont);

	UnlockedIconStateLabel = std::make_shared<FTextLabelWidget>(
		Vector2(50.f, 50.f),
		Vector2(50.0f, 50.f),
		Layer - 1,
		L"Unlocked icon: NA",
		L"");
	UnlockedIconStateLabel->SetFont(DialogSmallFont);

	CurrentDefinition = std::make_shared<FAchievementsDefinitionData>();
}

void FAchievementsDefinitionsDialog::Update()
{
	FDialog::Update();

	if (AchievementsDefinitionNames)
	{
		AchievementsDefinitionNames->Update();
	}

	if (AchievementsDefinitionsList)
	{
		AchievementsDefinitionsList->Update();
	}

	UpdateStatsIngestButtonState();

	//Update Icon UI
	UpdateIcons();
}

void FAchievementsDefinitionsDialog::Create()
{
	if (HeaderLabel) HeaderLabel->Create();
	if (BackgroundImage) BackgroundImage->Create();
	if (LanguageLabel) LanguageLabel->Create();

	if (AchievementsDefinitionNames)
	{
		AchievementsDefinitionNames->Create();
		AchievementsDefinitionNames->SetOnEntrySelectedCallback([this](size_t Index) { this->OnDefinitionNamesEntrySelected(Index); });
	}

	if (AchievementsDefinitionsList)
	{
		AchievementsDefinitionsList->Create();
	}

	if (UnlockAchievementButton) UnlockAchievementButton->Create();
	if (UpdatePlayerAchievementsButton) UpdatePlayerAchievementsButton->Create();

	if (StatsIngestLabel) StatsIngestLabel->Create();
	if (StatsIngestNameField) StatsIngestNameField->Create();
	if (StatsIngestAmountField) StatsIngestAmountField->Create();
	if (StatsIngestButton) StatsIngestButton->Create();

	if (LockedIconStateLabel) LockedIconStateLabel->Create();
	if (UnlockedIconStateLabel) UnlockedIconStateLabel->Create();

	AddWidget(HeaderLabel);
	AddWidget(BackgroundImage);
	AddWidget(AchievementsDefinitionNames);
	AddWidget(AchievementsDefinitionsList);
	AddWidget(LanguageLabel);
	AddWidget(UnlockAchievementButton);
	AddWidget(UpdatePlayerAchievementsButton);
	AddWidget(StatsIngestLabel);
	AddWidget(StatsIngestNameField);
	AddWidget(StatsIngestAmountField);
	AddWidget(StatsIngestButton);
	AddWidget(LockedIconStateLabel);
	AddWidget(UnlockedIconStateLabel);
}

void FAchievementsDefinitionsDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	Vector2 NATDocsButtonSize = Vector2(25.0f, 25.0f);

	if (HeaderLabel) HeaderLabel->SetPosition(Pos);
	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y + 20.f));

	if (AchievementsDefinitionNames)
	{
		AchievementsDefinitionNames->SetPosition(Position + Vector2(10.0f, HeaderLabel->GetSize().y + 5.0f));

		if (AchievementsDefinitionsList)
		{
			AchievementsDefinitionsList->SetPosition(Vector2(AchievementsDefinitionNames->GetPosition().x + AchievementsDefinitionNames->GetSize().x + 7.f,
															 AchievementsDefinitionNames->GetPosition().y));

			if (LanguageLabel) LanguageLabel->SetPosition(AchievementsDefinitionsList->GetPosition() + Vector2(180.f, 0.f));

			if (UnlockAchievementButton) UnlockAchievementButton->SetPosition(AchievementsDefinitionsList->GetPosition() + Vector2(260.f, -30.f));
			if (UpdatePlayerAchievementsButton) UpdatePlayerAchievementsButton->SetPosition(AchievementsDefinitionsList->GetPosition() + Vector2(350.f, -30.f));
		}
	}

	if (StatsIngestLabel) StatsIngestLabel->SetPosition(GetPosition() + GetSize() - Vector2(435.f, 35.f));
	if (StatsIngestNameField) StatsIngestNameField->SetPosition(GetPosition() + GetSize() - Vector2(355.f, 35.f));
	if (StatsIngestAmountField) StatsIngestAmountField->SetPosition(GetPosition() + GetSize() - Vector2(200.f, 35.f));
	if (StatsIngestButton) StatsIngestButton->SetPosition(GetPosition() + GetSize() - Vector2(110.f, 35.f));
	if (LockedIconStateLabel) LockedIconStateLabel->SetPosition(GetPosition() + GetSize() - Vector2(450.f, 90.f));
	if (UnlockedIconStateLabel) UnlockedIconStateLabel->SetPosition(GetPosition() + GetSize() - Vector2(250.0f, 90.f));
	if (LockedIcon) LockedIcon->SetPosition(LockedIconStateLabel->GetPosition() + Vector2(130.0f, 0.0f));
	if (UnlockedIcon) UnlockedIcon->SetPosition(UnlockedIconStateLabel->GetPosition() + Vector2(130.0f, 0.0f));
}

void FAchievementsDefinitionsDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (HeaderLabel) HeaderLabel->SetSize(Vector2(NewSize.x, 25.0f));
	if (BackgroundImage) BackgroundImage->SetSize(NewSize);

	if (StatsIngestLabel) StatsIngestLabel->SetSize(Vector2(100.f, 30.f));
	if (StatsIngestNameField) StatsIngestNameField->SetSize(Vector2(150.f, 30.f));
	if (StatsIngestAmountField) StatsIngestAmountField->SetSize(Vector2(80.f, 30.f));
	if (StatsIngestButton) StatsIngestButton->SetSize(Vector2(100.f, 30.f));
}

void FAchievementsDefinitionsDialog::SetWindowSize(Vector2 WindowSize)
{
	const Vector2 DialogSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 30.0f, WindowSize.y - 90.0f);
	if (BackgroundImage) BackgroundImage->SetSize(DialogSize);
	if (HeaderLabel) HeaderLabel->SetSize(Vector2(DialogSize.x, 20.0f));

	const Vector2 NamesListSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 100.0f, WindowSize.y - 200.0f - DefinitionsPosition.y);
	if (AchievementsDefinitionNames) AchievementsDefinitionNames->SetSize(NamesListSize);

	const Vector2 DefinitionsListSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) + 130.0f, WindowSize.y - 280.0f - DefinitionsPosition.y);
	if (AchievementsDefinitionsList) AchievementsDefinitionsList->SetSize(DefinitionsListSize);
}

void FAchievementsDefinitionsDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		if (UnlockAchievementButton) UnlockAchievementButton->Enable();
		if (UpdatePlayerAchievementsButton) UpdatePlayerAchievementsButton->Enable();

		if (AchievementsDefinitionNames) AchievementsDefinitionNames->SetEntriesVisible(true);
		if (AchievementsDefinitionsList) AchievementsDefinitionsList->SetEntriesVisible(true);

		if (StatsIngestNameField) StatsIngestNameField->Enable();
		if (StatsIngestAmountField) StatsIngestAmountField->Enable();

		UpdateDefaultLanugage();
	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		FGame::Get().GetAchievements()->QueryDefinitions();
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		UpdateInfoList();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		UpdateInfoList();
	}
	else if (Event.GetType() == EGameEventType::NoUserLoggedIn)
	{
		ClearCurrentSelection();

		UpdateInfoList();

		ClearCurrentDefinition();

		SetInfoList(CurrentDefinition);

		HideAchievementDefinitions();

		if (UnlockAchievementButton) UnlockAchievementButton->Disable();
		if (UpdatePlayerAchievementsButton) UpdatePlayerAchievementsButton->Disable();
		if (StatsIngestNameField) StatsIngestNameField->Disable();
		if (StatsIngestAmountField) StatsIngestAmountField->Disable();
	}
	else if (Event.GetType() == EGameEventType::DefinitionsReceived)
	{
		OnAchievementDefinitionsReceived();
	}
	else if (Event.GetType() == EGameEventType::PlayerAchievementsReceived)
	{
		FProductUserId ProductUserId = Event.GetProductUserId();
		OnPlayerAchievementsReceived(ProductUserId);
	}
	else if (Event.GetType() == EGameEventType::AchievementsUnlocked)
	{
		FProductUserId ProductUserId = Event.GetProductUserId();
		OnPlayerAchievementsUnlocked(ProductUserId);
	}
}

void FAchievementsDefinitionsDialog::HideAchievementDefinitions()
{
	if (AchievementsDefinitionNames)
	{
		AchievementsDefinitionNames->SetEntriesVisible(false);
	}

	if (AchievementsDefinitionsList)
	{
		AchievementsDefinitionsList->SetEntriesVisible(false);
	}

	if (LanguageLabel) LanguageLabel->Hide();

	if (UnlockAchievementButton) UnlockAchievementButton->Hide();
}

void FAchievementsDefinitionsDialog::OnAchievementDefinitionsReceived()
{
	if (AchievementsDefinitionNames)
	{
		DefinitionNamesList = FGame::Get().GetAchievements()->GetDefinitionIds();

		AchievementsDefinitionNames->RefreshData(DefinitionNamesList);

		if (AchievementsDefinitionNames)
		{
			AchievementsDefinitionNames->SetEntriesVisible(true);
		}

		if (CurrentSelectionIndex >= 0 && CurrentSelectionIndex < (int)DefinitionNamesList.size())
		{
			CurrentSelection = DefinitionNamesList[CurrentSelectionIndex];

			if (FGame::Get().GetAchievements()->GetDefinitionFromIndex(CurrentSelectionIndex, CurrentDefinition))
			{
				InvalidateDefinitionIcons();
				SetInfoList(CurrentDefinition);
			}
		}
	}

	UpdateInfoList();

	// Test
	//SetTestInfo();
}

void FAchievementsDefinitionsDialog::OnPlayerAchievementsReceived(FProductUserId UserId)
{
	UpdateInfoList();

	FGame::Get().GetAchievements()->QueryDefinitions();
}

void FAchievementsDefinitionsDialog::OnPlayerAchievementsUnlocked(FProductUserId UserId)
{
	UpdateInfoList();
}

void FAchievementsDefinitionsDialog::ClearDefinitionsList()
{
	AchievementsDefinitionsList->Reset();
}

void FAchievementsDefinitionsDialog::ShowDefinitionsList()
{
	AchievementsDefinitionsList->SetEntriesVisible(true);
}

void FAchievementsDefinitionsDialog::HideDefinitionsList()
{
	AchievementsDefinitionsList->SetEntriesVisible(false);
	SetFocused(false);
}

void FAchievementsDefinitionsDialog::OnDefinitionNamesEntrySelected(size_t Index)
{
	if (Index >= DefinitionNamesList.size())
		return;

	CurrentSelection = DefinitionNamesList[Index];

	CurrentSelectionIndex = (int)Index;

	if (FGame::Get().GetAchievements()->GetDefinitionFromIndex(CurrentSelectionIndex, CurrentDefinition))
	{
		InvalidateDefinitionIcons();
		SetInfoList(CurrentDefinition);
	}
}

void FAchievementsDefinitionsDialog::ClearCurrentSelection()
{
	CurrentSelection.clear();
	CurrentSelectionIndex = -1;
}

void FAchievementsDefinitionsDialog::UpdateInfoList()
{
	if (CurrentSelectionIndex == -1)
	{
		DefinitionsList.clear();

		if (UnlockAchievementButton) UnlockAchievementButton->Disable();
	}
	else
	{
		SetInfoList(CurrentDefinition);
	}
}

void FAchievementsDefinitionsDialog::UpdateIcons()
{
	//Check if icon data became available
	if (CurrentDefinition && !CurrentDefinition->AchievementId.empty())
	{
		LockedIconStateLabel->Show();
		UnlockedIconStateLabel->Show();

		UpdateIcon(LockedIcon, true, LockedIconStateLabel);
		UpdateIcon(UnlockedIcon, false, UnlockedIconStateLabel);
	}
	else
	{
		LockedIconStateLabel->Hide();
		UnlockedIconStateLabel->Hide();
	}
}

void FAchievementsDefinitionsDialog::UpdateIcon(std::shared_ptr<FSpriteWidget>& IconWidget, const bool bLocked, std::shared_ptr<FTextLabelWidget> LabelWidget)
{
	bool bIconTextureBroken = IconWidget && !IconWidget->IsTextureValid();
	bool bIconDataLoaded = true;
	if (!IconWidget && !bIconTextureBroken)
	{
		std::vector<char> IconData;
		if (FGame::Get().GetAchievements()->GetIconData(CurrentDefinition->AchievementId, IconData, bLocked))
		{
			const std::wstring& IconURL = (bLocked) ? CurrentDefinition->LockedIconURL : CurrentDefinition->UnlockedIconURL;

			IconWidget = std::make_shared<FSpriteWidget>(
				LabelWidget->GetPosition() + Vector2(130.0f, 0.0f),
				LabelWidget->GetSize(),
				LabelWidget->GetLayer(),
				IconURL,
				IconData
				);
			IconWidget->Create();

			if (IconWidget->IsTextureValid())
			{
				AddWidget(IconWidget);
			}
			else
			{
				bIconTextureBroken = true;
				IconWidget->Hide();
			}
		}
		else
		{
			bIconDataLoaded = false;
		}
	}

	std::wstring IconString = (bLocked) ? std::wstring(L"Locked icon: ") : std::wstring(L"Unlocked icon: ");

	if (IconWidget && !bIconTextureBroken)
	{
		LabelWidget->SetText(IconString);
	}
	else
	{
		if (!bIconDataLoaded)
		{
			LabelWidget->SetText(IconString + L" Downloading");
		}
		else
		{
			LabelWidget->SetText(IconString + L" Invalid format");
		}
	}
}

void FAchievementsDefinitionsDialog::UnlockSelectedAchievement()
{
	if (!CurrentSelection.empty())
	{
		std::vector<std::wstring> AchievementIds;
		AchievementIds.emplace_back(CurrentSelection);

		FGame::Get().GetAchievements()->UnlockAchievements(AchievementIds);
	}
}

void FAchievementsDefinitionsDialog::StatsIngest()
{
	if (StatsIngestNameField && StatsIngestAmountField)
	{
		std::wstring StatsIngestName = StatsIngestNameField->GetText();
		if (!StatsIngestName.empty() && StatsIngestName != StatsIngestNameField->GetInitialText())
		{
			std::wstring StatsIngestAmountStr = StatsIngestAmountField->GetText();
			if (!StatsIngestAmountStr.empty() && StatsIngestAmountStr != StatsIngestAmountField->GetInitialText())
			{
				int StatsIngestAmount = std::stoi(StatsIngestAmountStr);

				FGame::Get().GetAchievements()->IngestStat(StatsIngestName, StatsIngestAmount);
			}
		}
	}
}

void FAchievementsDefinitionsDialog::UpdateStatsIngestButtonState()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		if (StatsIngestButton)
		{
			StatsIngestButton->Disable();
		}
		return;
	}

	UpdateStatsIngestButtonCounter++;
	if (UpdateStatsIngestButtonCounter < 30)
	{
		return;
	}

	if (StatsIngestButton)
	{
		StatsIngestButton->Disable();
		if (StatsIngestNameField && StatsIngestAmountField)
		{
			std::wstring StatsIngestName = StatsIngestNameField->GetText();
			if (!StatsIngestName.empty() && StatsIngestName != StatsIngestNameField->GetInitialText())
			{
				std::wstring StatsIngestAmountStr = StatsIngestAmountField->GetText();
				if (!StatsIngestAmountStr.empty() && StatsIngestAmountStr != StatsIngestAmountField->GetInitialText())
				{
					StatsIngestButton->Enable();
				}
			}
		}
	}

	UpdateStatsIngestButtonCounter = 0;
}

void FAchievementsDefinitionsDialog::SetTestInfo()
{
	CurrentDefinition->AchievementId = L"Achievement 2";
	CurrentDefinition->bIsHidden = true;
	CurrentDefinition->UnlockedDisplayName = L"Test Achievement";
	CurrentDefinition->UnlockedDescription = L"Test Achievement";
	CurrentDefinition->LockedDisplayName = L"Locked";
	CurrentDefinition->LockedDescription = L"Locked";
	CurrentDefinition->LockedIconURL = L"LockedIconURL";
	CurrentDefinition->UnlockedIconURL = L"UnlockedURL";
	CurrentDefinition->FlavorText = L"Flavor description";
	FStatInfo StatInfo;
	StatInfo.Name = L"stat_1";
	StatInfo.ThresholdValue = 5;
	CurrentDefinition->StatInfo.clear();
	CurrentDefinition->StatInfo.emplace_back(StatInfo);

	DefinitionNamesList.clear();
	for (int i = 0; i < 10; ++i)
	{
		wchar_t Name[16] = {};
		wsprintf(Name, L"Achievement %d", i + 1);
		std::wstring NameStr = std::wstring(Name);

		DefinitionNamesList.emplace_back(NameStr);
	}

	if (AchievementsDefinitionNames)
	{
		AchievementsDefinitionNames->RefreshData(DefinitionNamesList);
	}

	SetInfoList(CurrentDefinition);

	if (UnlockAchievementButton) UnlockAchievementButton->Enable();
}

void FAchievementsDefinitionsDialog::ClearCurrentDefinition()
{
	CurrentDefinition->AchievementId = L"";
	CurrentDefinition->bIsHidden = false;
	CurrentDefinition->UnlockedDisplayName = L"";
	CurrentDefinition->UnlockedDescription = L"";
	CurrentDefinition->LockedDisplayName = L"";
	CurrentDefinition->LockedDescription = L"";
	CurrentDefinition->LockedIconURL = L"";
	CurrentDefinition->UnlockedIconURL = L"";
	CurrentDefinition->FlavorText = L"";
	CurrentDefinition->StatInfo.clear();
}

void FAchievementsDefinitionsDialog::InvalidateDefinitionIcons()
{
	if (LockedIcon)
	{
		RemoveWidgets<FSpriteWidget>({ LockedIcon });
		LockedIcon.reset();
	}

	if (UnlockedIcon)
	{
		RemoveWidgets<FSpriteWidget>({ UnlockedIcon });
		UnlockedIcon.reset();
	}
}

void FAchievementsDefinitionsDialog::UpdateDefaultLanugage()
{
	FGame::Get().GetAchievements()->SetDefaultLanguage();
	std::wstring DefaultLanguage = FGame::Get().GetAchievements()->GetDefaultLanguage();

	SetInfoList(CurrentDefinition);
}

void FAchievementsDefinitionsDialog::SetInfoList(std::shared_ptr<FAchievementsDefinitionData> Def)
{
	DefinitionsList.clear();

	if (!Def->AchievementId.empty())
	{
		std::wstring AchievementId = L"ID: " + Def->AchievementId;
		DefinitionsList.emplace_back(AchievementId);

		std::wstring DisplayName = L"Unlocked Display Name: " + Def->UnlockedDisplayName;
		DefinitionsList.emplace_back(DisplayName);

		std::wstring Description = L"Unlocked Description: " + Def->UnlockedDescription;
		DefinitionsList.emplace_back(Description);

		std::wstring LockedDisplayName = L"Locked Display Name: " + Def->LockedDisplayName;
		DefinitionsList.emplace_back(LockedDisplayName);

		std::wstring LockedDescription = L"Locked Description: " + Def->LockedDescription;
		DefinitionsList.emplace_back(LockedDescription);

		std::wstring FlavorText = L"Flavor Text: " + Def->FlavorText;
		DefinitionsList.emplace_back(FlavorText);

		std::wstring IsHidden;
		if (Def->bIsHidden == EOS_TRUE)
		{
			IsHidden = L"Hidden: true";
		}
		else
		{
			IsHidden = L"Hidden: false";
		}
		DefinitionsList.emplace_back(IsHidden);

		wchar_t StatInfoStr[256] = L"Stat Thresholds: ";
		for (const FStatInfo& StatInfo : Def->StatInfo)
		{
			swprintf(StatInfoStr, 256, L"%ls '%ls': %d", StatInfoStr, StatInfo.Name.c_str(), StatInfo.ThresholdValue);
		}
		DefinitionsList.emplace_back(StatInfoStr);

		std::shared_ptr<FPlayerAchievementData> PlayerAchievement;
		if (FGame::Get().GetAchievements()->GetPlayerAchievementFromId(Def->AchievementId, PlayerAchievement))
		{
			if (!PlayerAchievement->Stats.empty())
			{
				wchar_t StatProgressStr[256] = L"Stat Progress: ";
				for (auto Iter : PlayerAchievement->Stats)
				{
					swprintf(StatProgressStr, 256, L"%ls '%ls': %d/%d", StatProgressStr, Iter.first.c_str(), Iter.second.CurValue, Iter.second.ThresholdValue);
				}
				DefinitionsList.emplace_back(StatProgressStr);
			}

			const bool bUnlocked = PlayerAchievement->UnlockTime != EOS_ACHIEVEMENTS_ACHIEVEMENT_UNLOCKTIME_UNDEFINED;
			wchar_t ProgressStr[32] = {};
			swprintf(ProgressStr, 32, L"%f", (!bUnlocked) ? PlayerAchievement->Progress : 1.0f);
			std::wstring Progress = L"Total Progress: " + std::wstring(ProgressStr);
			DefinitionsList.emplace_back(Progress);
		}
	}
	else
	{
		if (!Def->LockedDisplayName.empty())
		{
			std::wstring LockedDisplayName = L"Locked Display Name: " + Def->LockedDisplayName;
			DefinitionsList.emplace_back(LockedDisplayName);
		}
	}

	if (AchievementsDefinitionsList)
	{
		AchievementsDefinitionsList->RefreshData(DefinitionsList);

		if (AchievementsDefinitionsList)
		{
			AchievementsDefinitionsList->SetEntriesVisible(true);
		}
	}

	if (LanguageLabel)
	{
		LanguageLabel->SetText(L"Language: " + FGame::Get().GetAchievements()->GetDefaultLanguage());
		LanguageLabel->Show();
	}

	if (FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()) == nullptr)
	{
		if (UnlockAchievementButton) UnlockAchievementButton->Disable();
	}
	else
	{
		if (UnlockAchievementButton) UnlockAchievementButton->Enable();
	}
}

```

`EAC_SDK/Samples/Achievements/Source/AchievementsDefinitionsDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "ListView.h"

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;
struct FAchievementsDefinitionData;

/**
 * Achievements Definitions Name
 */
class FAchievementsDefinitionName : public FTextLabelWidget
{
public:
	FAchievementsDefinitionName(Vector2 LabelPos,
		Vector2 LabelSize,
		UILayer LabelLayer,
		const std::wstring& LabelText,
		const std::wstring& LabelAssetFile) : FTextLabelWidget(LabelPos, LabelSize, LabelLayer, LabelText, LabelAssetFile, Color::White, Color::White, EAlignmentType::Left)
	{}

	void SetFocused(bool bValue) override;

	/**
	* Implementation of 'SetData' for List view. Compresses the string (by truncating the middle part) to match the widget size before setting this text.
	*/
	void SetData(const std::wstring& Data);
};

template<>
std::shared_ptr<FAchievementsDefinitionName> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& Data);

using FAchievementsDefinitionNamesList = FListViewWidget<std::wstring, FAchievementsDefinitionName>;

/**
 * Achievements Definitions Info
 */
class FAchievementsDefinitionInfo : public FTextLabelWidget
{
public:
	FAchievementsDefinitionInfo(Vector2 LabelPos,
		Vector2 LabelSize,
		UILayer LabelLayer,
		const std::wstring& LabelText,
		const std::wstring& LabelAssetFile) : FTextLabelWidget(LabelPos, LabelSize, LabelLayer, LabelText, LabelAssetFile, Color::White, Color::White, EAlignmentType::Left)
	{}

	void SetFocused(bool bValue) override;
};

template<>
std::shared_ptr<FAchievementsDefinitionInfo> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& Data);

using FAchievementsDefinitionsList = FListViewWidget<std::wstring, FAchievementsDefinitionInfo>;

/**
 * Achievements Definitions dialog
 */
class FAchievementsDefinitionsDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FAchievementsDefinitionsDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FAchievementsDefinitionsDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;

	/** Set Window Size */
	void SetWindowSize(Vector2 WindowSize);

	/** Sets proportion console is using */
	void SetWindowProportion(Vector2 InWindowProportion) { ConsoleWindowProportion = InWindowProportion; }

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

private:
	/** Hides achievement definitions */
	void HideAchievementDefinitions();

	/** Achievement definitions have been received */
	void OnAchievementDefinitionsReceived();

	/** Player achievements have been received */
	void OnPlayerAchievementsReceived(FProductUserId UserId);

	/** Player achievements have been unlocked */
	void OnPlayerAchievementsUnlocked(FProductUserId UserId);

	void ClearDefinitionsList();

	void ShowDefinitionsList();

	void HideDefinitionsList();

	void OnDefinitionNamesEntrySelected(size_t Index);

	void ClearCurrentSelection();

	void UpdateInfoList();

	void UpdateIcons();

	void UpdateIcon(std::shared_ptr<FSpriteWidget>& IconWidget, const bool bLocked, std::shared_ptr<FTextLabelWidget> LabelWidget);

	void UnlockSelectedAchievement();

	void StatsIngest();

	void UpdateStatsIngestButtonState();

	void SetTestInfo();

	void ClearCurrentDefinition();

	void InvalidateDefinitionIcons();

	void UpdateDefaultLanugage();

	void SetInfoList(std::shared_ptr<FAchievementsDefinitionData> Def);

	/** Header label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Language label */
	std::shared_ptr<FTextLabelWidget> LanguageLabel;

	/** Unlock Achievement button */
	std::shared_ptr<FButtonWidget> UnlockAchievementButton;

	/** Update Player Achievements button */
	std::shared_ptr<FButtonWidget> UpdatePlayerAchievementsButton;

	/** Stats ingest label */
	std::shared_ptr<FTextLabelWidget> StatsIngestLabel;

	/** Stats ingest name */
	std::shared_ptr<FTextFieldWidget> StatsIngestNameField;

	/** Stats ingest amount */
	std::shared_ptr<FTextFieldWidget> StatsIngestAmountField;

	/** Stats Ingest button */
	std::shared_ptr<FButtonWidget> StatsIngestButton;

	/** Achievement Icon (Locked) */
	std::shared_ptr<FSpriteWidget> LockedIcon;

	/** Achievement Icon (Unlocked) */
	std::shared_ptr<FSpriteWidget> UnlockedIcon;

	/** Label that output icon status when there is no icon to show (e.g. it's being loaded) */
	std::shared_ptr<FTextLabelWidget> LockedIconStateLabel;

	/** Label that output icon status when there is no icon to show (e.g. it's being loaded) */
	std::shared_ptr<FTextLabelWidget> UnlockedIconStateLabel;

	/** List of achievement definition name entries */
	std::shared_ptr<FAchievementsDefinitionNamesList> AchievementsDefinitionNames;

	/** List of achievement definitions entries */
	std::shared_ptr<FAchievementsDefinitionsList> AchievementsDefinitionsList;

	/** List of achievement definition names */
	std::vector<std::wstring> DefinitionNamesList;

	/** List of achievement definition info */
	std::vector<std::wstring> DefinitionsList;

	/** Currently selected entry */
	std::wstring CurrentSelection;

	/** Currently selected entry index */
	int CurrentSelectionIndex;

	/** Part of window that console is taking */
	Vector2 ConsoleWindowProportion;

	/** Currently selected definition */
	std::shared_ptr<FAchievementsDefinitionData> CurrentDefinition;

	/** Languages available to display info */
	std::vector<std::wstring> AvailableLanguages;

	/** Current Language Index */
	int CurrentLanguageIndex;

	/** Counter to update stats ingest button */
	int UpdateStatsIngestButtonCounter;
};

```

`EAC_SDK/Samples/Achievements/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Game.h"
#include "Menu.h"
#include "Level.h"
#include "Achievements.h"
#include "HTTPClient.h"
#include "Console.h"
#include "Platform.h"

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	Achievements = std::make_unique<FAchievements>();

	CreateConsoleCommands();
}

FGame::~FGame()
{

}

void FGame::Init()
{
	FBaseGame::Init();

	Achievements->Init();
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" GETDEFS - to request retrieval of achievement definitions;",
			L" GETPLAYER - to request retrieval of current user's achievements data;",
			L" UNLOCK - to unlock a named achievement;",
			L" INGEST - to ingest a stat;",
			L" QUERYSTATS - to query stats;",
			L" DEBUGNOTIFY - to toggle the debug notify flag;",
			L" URL - to make an HTTP lookup."
		};

		AppendHelpMessageLines(ExtraHelpMessageLines);

		// Achievements
		Console->AddCommand(L"GETDEFS", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetAchievements())
				{
					FGame::Get().GetAchievements()->QueryDefinitions();
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"GETPLAYER", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetAchievements())
				{
					if (args.size() == 1)
					{
						std::string NarrowUserIdStr = FStringUtils::Narrow(args[0]);
						EOS_ProductUserId ProductUserId = FAccountHelpers::ProductUserIDFromString(NarrowUserIdStr.c_str());
						if (ProductUserId != nullptr)
						{
							// Get player's achievements
							FGame::Get().GetAchievements()->QueryPlayerAchievements(ProductUserId);
						}
						else
						{
							FGame::Get().GetConsole()->AddLine(L"GETPLAYER called with an invalid user id");
						}
					}
					else
					{
						// Get local player's achievements
						FGame::Get().GetAchievements()->QueryPlayerAchievements(FProductUserId());
					}
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"UNLOCK", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (args.size() == 1)
				{
					if (FGame::Get().GetAchievements())
					{
						std::vector<std::wstring> AchievementIds;
						AchievementIds.emplace_back(args[0]);

						FGame::Get().GetAchievements()->UnlockAchievements(AchievementIds);
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"Error: name of achievement is required.");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"INGEST", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (args.size() == 2)
				{
					if (FGame::Get().GetAchievements())
					{
						try
						{
							FGame::Get().GetAchievements()->IngestStat(args[0], std::stoi(args[1]));
						}
						catch (const std::invalid_argument&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest - invalid argument");
						}
						catch (const std::out_of_range&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest - out of range.");
						}
						catch (const std::exception&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest, undefined error.");
						}
					}
				}
				else if (args.size() == 3)
				{
					if (FGame::Get().GetAchievements())
					{
						std::string NarrowUserIdStr = FStringUtils::Narrow(args[2]);
						EOS_ProductUserId TargetUserId = FAccountHelpers::ProductUserIDFromString(NarrowUserIdStr.c_str());
						if (TargetUserId != nullptr)
						{
							try
							{
								FGame::Get().GetAchievements()->IngestStat(args[0], std::stoi(args[1]), TargetUserId);
							}
							catch (const std::invalid_argument&)
							{
								FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest - invalid argument");
							}
							catch (const std::out_of_range&)
							{
								FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest - out of range.");
							}
							catch (const std::exception&)
							{
								FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest, undefined error.");
							}
						}
						else
						{
							FGame::Get().GetConsole()->AddLine(L"INGEST called with an invalid user id");
						}
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"Error: name of stat and ingest amount is required, target user id is optional");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"DEBUGNOTIFY", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetAchievements())
				{
					if (FGame::Get().GetAchievements()->ToggleDebugNotify()) {
						FDebugLog::LogWarning(L"Achievements query disabled to allow debugging of notification.");
					} else {
						FDebugLog::LogWarning(L"Achievements query re-enabled.");
					}
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"QUERYSTATS", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetAchievements())
				{
					FGame::Get().GetAchievements()->QueryStats();
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"URL", [](const std::vector<std::wstring>& args)
		{
			if (args.size() == 1)
			{
				FHTTPClient::GetInstance().PerformHTTPRequest(FStringUtils::Narrow(args[0]), FHTTPClient::EHttpRequestMethod::GET, std::string(), [](FHTTPClient::HTTPErrorCode ErrorCode, const std::vector<char>& Data)
				{
					if (ErrorCode == 200)
					{
						FGame::Get().GetConsole()->AddLine(L"HTTP Request success: ");
						std::string ResponseString(Data.data(), Data.size());
						FGame::Get().GetConsole()->AddLine(FStringUtils::Widen(ResponseString));
					}
					else
					{
						std::string ErrorString(Data.data(), Data.size());
						FDebugLog::LogError(L"HTTP Request failed: %ls", FStringUtils::Widen(ErrorString).c_str());
					}
				}
				);
			}
		});

	}
}

void FGame::Update()
{
	FBaseGame::Update();

	Achievements->Update();
	FHTTPClient::GetInstance().Update();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);

	Achievements->OnGameEvent(Event);
}

void FGame::OnShutdown()
{
	//Achievements must be cleared before we destroy SDK platform.
	if (Achievements)
	{
		Achievements->OnShutdown();
	}

	FBaseGame::OnShutdown();

	FHTTPClient::ClearInstance();
}

const std::unique_ptr<FAchievements>& FGame::GetAchievements()
{
	return Achievements;
}

```

`EAC_SDK/Samples/Achievements/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FAchievements;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Initialization
	*/
	virtual void Init() override;

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	* Called just before shutting down the game. Allows to finish current operations.
	*/
	virtual void OnShutdown() override;

	/** 
	 * Getter for achievements component.
	 */
	const std::unique_ptr<FAchievements>& GetAchievements();

protected:
	/**
	* Creates all console commands
	*/
	virtual void CreateConsoleCommands() override;

	/** Achievements component */
	std::unique_ptr<FAchievements> Achievements;
};

```

`EAC_SDK/Samples/Achievements/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/Achievements/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "FriendsDialog.h"
#include "ExitDialog.h"
#include "NotificationDialog.h"
#include "AuthDialogs.h"
#include "AchievementsDefinitionsDialog.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "PopupDialog.h"

const Vector2 ConsoleDialogSizeProportion = Vector2(0.68f, 0.35f);
const float AchievementDefinitionsDialogPositionY = 140.0f;

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreateFriendsDialog();

	FBaseMenu::Create();

	AuthDialogs->SetSingleUserOnly(true);

	CreateAchievementsDefinitionsDialog();
	CreateNotificationDialog();
}

void FMenu::Release()
{
	FBaseMenu::Release();

	if (AchievementsDefinitionsDialog)
	{
		AchievementsDefinitionsDialog->Release();
		AchievementsDefinitionsDialog.reset();
	}
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * ConsoleDialogSizeProportion.x, WindowSize.y * ConsoleDialogSizeProportion.y);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (AchievementsDefinitionsDialog)
		{
			AchievementsDefinitionsDialog->SetWindowSize(WindowSize);

			Vector2 AchDefDialogSize = Vector2(ConsoleWidgetSize.x, WindowSize.y - ConsoleDialog->GetSize().y - AchievementDefinitionsDialogPositionY - 10.0f);
			AchievementsDefinitionsDialog->SetSize(AchDefDialogSize);

			Vector2 AchDefDialogPos = Vector2(ConsoleWidgetPos.x, ConsoleWidgetPos.y - AchDefDialogSize.y - 10.f);
			AchievementsDefinitionsDialog->SetPosition(AchDefDialogPos);
		}

		if (FriendsDialog)
		{
			Vector2 FriendsDialogSize = Vector2(WindowSize.x - ConsoleDialog->GetSize().x - 30.f,
				AchievementsDefinitionsDialog->GetSize().y + ConsoleDialog->GetSize().y + 10.f);
			FriendsDialog->SetSize(FriendsDialogSize);

			Vector2 FriendDialogPos = Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
				AchievementDefinitionsDialogPositionY - 10.0f);
			FriendsDialog->SetPosition(FriendDialogPos);
		}
	}

	if (NotificationDialog)
	{
		NotificationDialog->SetPosition(Vector2(WindowSize.x - NotificationDialog->GetSize().x - 30.f, 30.f));
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}


void FMenu::CreateNotificationDialog()
{
	NotificationDialog = std::make_shared<FNotificationDialog>(
		Vector2(200.f, 200.f),
		Vector2(330.f, 60.f),
		5,
		NormalFont->GetFont(),
		SmallFont->GetFont());

	NotificationDialog->SetBorderColor(Color::UIBorderGrey);
	NotificationDialog->Create();

	AddDialog(NotificationDialog);

	HideDialog(NotificationDialog);
}

void FMenu::CreateAchievementsDefinitionsDialog()
{
	const float FX = ConsoleDialog->GetPosition().x;
	const float FY = AchievementDefinitionsDialogPositionY;
	const float Width = ConsoleDialog->GetSize().x;
	const float Height = (ConsoleDialog->GetSize().y / ConsoleDialogSizeProportion.y) * (1.0f - ConsoleDialogSizeProportion.y);

	AchievementsDefinitionsDialog = std::make_shared<FAchievementsDefinitionsDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	AchievementsDefinitionsDialog->SetWindowProportion(ConsoleDialogSizeProportion);

	AchievementsDefinitionsDialog->SetBorderColor(Color::UIBorderGrey);

	AchievementsDefinitionsDialog->Create();

	AddDialog(AchievementsDefinitionsDialog);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::ToggleNotification)
	{
		if (NotificationDialog->IsShown())
		{
			HideDialog(NotificationDialog);
		}
		else
		{
			ShowDialog(NotificationDialog);
		}
	}

	if (AchievementsDefinitionsDialog) AchievementsDefinitionsDialog->OnGameEvent(Event);
	if (NotificationDialog) NotificationDialog->OnGameEvent(Event);

	FBaseMenu::OnGameEvent(Event);
}
```

`EAC_SDK/Samples/Achievements/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FNotificationDialog;
class FAchievementsDefinitionsDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> console) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	virtual void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

private:

	/**
	 * Creates the notification dialog
	 */
	void CreateNotificationDialog();

	/**
	 * Creates achievements definitions dialog
	 */
	void CreateAchievementsDefinitionsDialog();

	/** Notification Dialog */
	std::shared_ptr<FNotificationDialog> NotificationDialog;

	/** Achievements Definitions Dialog dialog */
	std::shared_ptr<FAchievementsDefinitionsDialog> AchievementsDefinitionsDialog;
};

```

`EAC_SDK/Samples/Achievements/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Achievements";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/Achievements/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/Achievements/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/AntiCheat/Client/AntiCheat.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>AntiCheat</RootNamespace>
    <ProjectGuid>{60F44F5F-335C-4080-B282-0CB14249BD5B}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>AntiCheat</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/AntiCheat/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;..\$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86\SDL2_net.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/AntiCheat/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;../$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;..\$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86\SDL2_net.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/AntiCheat/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;..\$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64\SDL2_net.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/AntiCheat/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;../$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;..\$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64\SDL2_net.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/AntiCheat/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;..\$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86\SDL2_net.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/AntiCheat/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;../$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;..\$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86\SDL2_net.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/AntiCheat/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;..\$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64\SDL2_net.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/AntiCheat/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;../$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;..\$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64\SDL2_net.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatclient.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatclient_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatcommon_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatserver.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatserver_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\StringViewListEntry.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TableRowView.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TableView.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\..\Shared\Source\pch.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\AntiCheatClient.h" />
    <ClInclude Include="Source\AntiCheatDialog.h" />
    <ClInclude Include="Source\AntiCheatNetworkTransport.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\TCPClient.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TableRowView.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\AntiCheatClient.cpp" />
    <ClCompile Include="Source\AntiCheatDialog.cpp" />
    <ClCompile Include="Source\AntiCheatNetworkTransport.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\TCPClient.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\..\Shared\Assets\addbutton.dds" />
    <Image Include="..\..\Shared\Assets\button.dds" />
    <Image Include="..\..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\..\Shared\Assets\console.dds" />
    <Image Include="..\..\Shared\Assets\friendback.dds" />
    <Image Include="..\..\Shared\Assets\friends.dds" />
    <Image Include="..\..\Shared\Assets\Logo.dds" />
    <Image Include="..\..\Shared\Assets\menu_background.dds" />
    <Image Include="..\..\Shared\Assets\nobutton.dds" />
    <Image Include="..\..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\..\Shared\Assets\search.dds" />
    <Image Include="..\..\Shared\Assets\solid_white.dds" />
    <Image Include="..\..\Shared\Assets\textfield.dds" />
    <Image Include="..\..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="..\..\Shared\Source\Graphics\GUI\TableView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/AntiCheat/Client/AntiCheat.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatclient.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatclient_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatcommon_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatserver.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_anticheatserver_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TableRowView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TableView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\StringViewListEntry.h" />
    <ClInclude Include="Source\AntiCheatClient.h" />
    <ClInclude Include="Source\AntiCheatDialog.h" />
    <ClInclude Include="Source\AntiCheatNetworkTransport.h" />
    <ClInclude Include="Source\TCPClient.h" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TableRowView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClInclude Include="..\..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClCompile Include="..\..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp" />
    <ClCompile Include="Source\AntiCheatClient.cpp" />
    <ClCompile Include="Source\AntiCheatDialog.cpp" />
    <ClCompile Include="Source\AntiCheatNetworkTransport.cpp" />
    <ClCompile Include="Source\TCPClient.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
    <None Include="..\..\Shared\Source\Graphics\GUI\TableView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/AntiCheat/Client/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/AntiCheat/Client/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/AntiCheat/Client/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/AntiCheat/Client/Source/AntiCheatClient.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.



#include "Game.h"
#include "GameEvent.h"
#include "Platform.h"
#include "AntiCheatNetworkTransport.h"
#include "AntiCheatClient.h"

#include "DebugLog.h"
#include "AccountHelpers.h"

#include <eos_anticheatclient.h>

FAntiCheatClient::FAntiCheatClient()
{
	FGame::Get().GetAntiCheatNetworkTransport()->SetOnNewMessageCallback([this](const void* Data, uint32_t Length)
	{
		OnMessageFromServerReceived(Data, Length);
	});
	FGame::Get().GetAntiCheatNetworkTransport()->SetOnClientActionRequiredCallback([this](EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo Message)
	{
		FDebugLog::Log(L"OnClientActionRequired: ClientAction=%d, ClientActionReasonCode=%d, ClientActionReasonDetails=%ls", Message.ClientAction, Message.ActionReasonCode, FStringUtils::Widen(Message.ActionReasonDetailsString).c_str());
		FGameEvent Event(EGameEventType::AntiCheatKicked);
		FGame::Get().OnGameEvent(Event);
	});
}

FAntiCheatClient::~FAntiCheatClient()
{

}

void FAntiCheatClient::Init()
{
	AntiCheatClientHandle = EOS_Platform_GetAntiCheatClientInterface(FPlatform::GetPlatformHandle());
	if (!AntiCheatClientHandle)
	{
		FDebugLog::LogWarning(L"Can't get a handle to the Anti-Cheat Client Interface. Please, start the game via Anti-Cheat bootstrapper.");
		return;
	}
}

bool FAntiCheatClient::Start(const std::string& Host, int Port, const FProductUserId& LocalUserId, const std::string& EOSConnectIdTokenJWT)
{
	if (!ConnectToAntiCheatServer(Host, Port))
	{
		FDebugLog::LogError(L"ConnectToAntiCheatServer Error");
		return false;
	}

	if (!AddNotifyMessageToServerCallback())
	{
		DisconnectFromAntiCheatServer();
		FDebugLog::LogError(L"AddNotifyMessageToServerCallback Error");
		return false;
	}

	if (!BeginSession(LocalUserId))
	{
		RemoveNotifyMessageToServerCallback();
		DisconnectFromAntiCheatServer();
		FDebugLog::LogError(L"BeginSession Error");
		return false;
	}

	SendRegistrationInfoToAntiCheatServer(LocalUserId, EOSConnectIdTokenJWT);
	bConnected = true;

	return true;
}

void FAntiCheatClient::Stop()
{
	if (bConnected)
	{
		RemoveNotifyMessageToServerCallback();
		EndSession();
		DisconnectFromAntiCheatServer();
		bConnected = false;
	}
}

void FAntiCheatClient::EndSession()
{
	EOS_AntiCheatClient_EndSessionOptions EndSessionOptions{};
	EndSessionOptions.ApiVersion = EOS_ANTICHEATCLIENT_ENDSESSION_API_LATEST;
	EOS_AntiCheatClient_EndSession(AntiCheatClientHandle, &EndSessionOptions);
}

void FAntiCheatClient::PollStatus()
{
	EOS_AntiCheatClient_PollStatusOptions Options = {};
	Options.ApiVersion = EOS_ANTICHEATCLIENT_POLLSTATUS_API_LATEST;
	Options.OutMessageLength = 256;

	EOS_EAntiCheatClientViolationType Type = {};
	std::array<char, 256> Message = {};

	const EOS_EResult Result = EOS_AntiCheatClient_PollStatus(AntiCheatClientHandle, &Options, &Type, &Message[0]);

	if (Result == EOS_EResult::EOS_NotFound)
	{
		FDebugLog::Log(L"EOS_AntiCheatClient_PollStatus: No violations found.");
	}
	else
	{
		FDebugLog::Log(L"EOS_AntiCheatClient_PollStatus: ViolationType=%d, Message=%ls", Type,  FStringUtils::Widen(Message.data()).c_str());
	}
}

void FAntiCheatClient::OnShutdown()
{
	Stop();
}

void FAntiCheatClient::OnMessageFromServerReceived(const void* Data, uint32_t DataLengthBytes) const
{
	EOS_AntiCheatClient_ReceiveMessageFromServerOptions ReceiveMessageFromServerOptions = {};

	ReceiveMessageFromServerOptions.ApiVersion = EOS_ANTICHEATCLIENT_RECEIVEMESSAGEFROMSERVER_API_LATEST;
	ReceiveMessageFromServerOptions.Data = Data;
	ReceiveMessageFromServerOptions.DataLengthBytes = DataLengthBytes;

	EOS_AntiCheatClient_ReceiveMessageFromServer(AntiCheatClientHandle, &ReceiveMessageFromServerOptions);
}

bool FAntiCheatClient::AddNotifyMessageToServerCallback()
{
	EOS_AntiCheatClient_AddNotifyMessageToServerOptions Options = {};
	Options.ApiVersion = EOS_ANTICHEATCLIENT_ADDNOTIFYMESSAGETOSERVER_API_LATEST;
	NotificationId = EOS_AntiCheatClient_AddNotifyMessageToServer(AntiCheatClientHandle, &Options, nullptr, OnMessageToServerCallback);

	return NotificationId != EOS_INVALID_NOTIFICATIONID;
}

void FAntiCheatClient::RemoveNotifyMessageToServerCallback()
{
	EOS_AntiCheatClient_RemoveNotifyMessageToServer(AntiCheatClientHandle, NotificationId);
}

bool FAntiCheatClient::BeginSession(const FProductUserId& LocalUserId)
{
	EOS_AntiCheatClient_BeginSessionOptions Options = {};
	Options.ApiVersion = EOS_ANTICHEATCLIENT_BEGINSESSION_API_LATEST;
	Options.LocalUserId = LocalUserId;
	Options.Mode = EOS_EAntiCheatClientMode::EOS_ACCM_ClientServer;

	const EOS_EResult Result = EOS_AntiCheatClient_BeginSession(AntiCheatClientHandle, &Options);

	return Result == EOS_EResult::EOS_Success;
}

bool FAntiCheatClient::ConnectToAntiCheatServer(const std::string& Host, int Port)
{
	const bool bIsConnected = FGame::Get().GetAntiCheatNetworkTransport()->Connect(Host.c_str(), Port);
	return bIsConnected;
}

void FAntiCheatClient::DisconnectFromAntiCheatServer()
{
	FGame::Get().GetAntiCheatNetworkTransport()->Disconnect();
}

void FAntiCheatClient::SendRegistrationInfoToAntiCheatServer(const FProductUserId& LocalUserId, const std::string& EOSConnectIdTokenJWT)
{
	FAntiCheatNetworkTransport::FRegistrationInfoMessage Message;

	Message.ProductUserId = FStringUtils::Narrow(LocalUserId.ToString());
	Message.EOSConnectIdTokenJWT = EOSConnectIdTokenJWT;
	Message.ClientPlatform = EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Windows;

	FGame::Get().GetAntiCheatNetworkTransport()->Send(Message);
}

void FAntiCheatClient::OnMessageToServerCallback(const EOS_AntiCheatClient_OnMessageToServerCallbackInfo* Message)
{
	FGame::Get().GetAntiCheatNetworkTransport()->Send(Message);
}

```

`EAC_SDK/Samples/AntiCheat/Client/Source/AntiCheatClient.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_anticheatclient_types.h>

class FGameEvent;

template<typename> struct TEpicAccountId;
using FProductUserId = TEpicAccountId<EOS_ProductUserId>;

class FAntiCheatClient
{
public:
	/**
	* Constructor
	*/
	FAntiCheatClient() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FAntiCheatClient(FAntiCheatClient const&) = delete;
	FAntiCheatClient& operator=(FAntiCheatClient const&) = delete;

	/**
	 * Destructor
	 */
	virtual ~FAntiCheatClient();

	void Init();
	void OnShutdown();

	bool Start(const std::string& Host, int Port, const FProductUserId& LocalUserId, const std::string& EOSConnectIdTokenJWT);
	void Stop();

	void PollStatus();

private:
	bool AddNotifyMessageToServerCallback();
	void RemoveNotifyMessageToServerCallback();
	bool BeginSession(const FProductUserId& LocalUserId);
	void EndSession();

	bool ConnectToAntiCheatServer(const std::string& Host, int Port);
	void SendRegistrationInfoToAntiCheatServer(const FProductUserId& LocalUserId, const std::string& EOSConnectIdTokenJWT);
	void DisconnectFromAntiCheatServer();

	void OnMessageFromServerReceived(const void* Data, uint32_t DataLengthBytes) const;
	static void EOS_CALL OnMessageToServerCallback(const EOS_AntiCheatClient_OnMessageToServerCallbackInfo* Message);

private:
	EOS_HAntiCheatClient AntiCheatClientHandle = nullptr;
	EOS_NotificationId NotificationId = EOS_INVALID_NOTIFICATIONID;
	bool bConnected = false;
};


```

`EAC_SDK/Samples/AntiCheat/Client/Source/AntiCheatDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "Game.h"
#include "Authentication.h"
#include "AntiCheatDialog.h"
#include "AntiCheatClient.h"
#include "DebugLog.h"
#include "GameEvent.h"
#include "Player.h"
#include "Sprite.h"

constexpr float HeaderLabelHeight = 30.0f;

FAntiCheatDialog::FAntiCheatDialog(
	Vector2 InPosition,
	Vector2 InSize,
	UILayer InLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont)
	: FDialog(InPosition, InSize, InLayer)
{
	HeaderLabel = std::make_shared<FTextLabelWidget>(
		Position,
		Vector2(Size.x, HeaderLabelHeight),
		Layer - 1,
		L"ANTICHEAT",
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	HeaderLabel->SetFont(DialogSmallFont);
	HeaderLabel->SetBorderColor(Color::UIBorderGrey);

	BackgroundImage = std::make_shared<FSpriteWidget>(
		Position,
		Size,
		Layer,
		L"Assets/texteditor.dds");

	IPLabel = std::make_shared<FTextLabelWidget>(
		Vector2(50.f, 50.f),
		Vector2(100.f, 30.f),
		Layer - 1,
		L"IP:",
		L"");
	IPLabel->SetFont(DialogNormalFont);

	PortLabel = std::make_shared<FTextLabelWidget>(
		Vector2(50.f, 50.f),
		Vector2(100.f, 30.f),
		Layer - 1,
		L"Port:",
		L"");
	PortLabel->SetFont(DialogNormalFont);

	JoinGameButton = std::make_shared<FButtonWidget>(
		Vector2(0.f, 0.f),
		Vector2(0, 0.f),
		Layer - 1,
		L"JOIN GAME",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		Color::UIButtonBlue
		);
	JoinGameButton->SetBackgroundColors(assets::DefaultButtonColors);
	JoinGameButton->SetOnPressedCallback([this]()
	{
		OnJoinGameButtonPressed();
	});

	LeaveGameButton = std::make_shared<FButtonWidget>(
		Vector2(0.f, 0.f),
		Vector2(0, 0.f),
		Layer - 1,
		L"LEAVE GAME",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		Color::UIButtonBlue
		);
	LeaveGameButton->SetBackgroundColors(assets::DefaultButtonColors);
	LeaveGameButton->SetOnPressedCallback([this]()
	{
		OnLeaveGameButtonPressed();
	});
	LeaveGameButton->Disable();

	PollStatusButton = std::make_shared<FButtonWidget>(
		Vector2(0.f, 0.f),
		Vector2(0, 0.f),
		Layer - 1,
		L"POLL STATUS",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		Color::UIButtonBlue
		);
	PollStatusButton->SetBackgroundColors(assets::DefaultButtonColors);
	PollStatusButton->SetOnPressedCallback([this]()
	{
		OnPollStatusButtonPressed();
	});
	PollStatusButton->Disable();

	IPField = std::make_shared<FTextFieldWidget>(
		Vector2(50.f, 50.f),
		Vector2(150.f, 30.f),
		Layer - 1,
		L"127.0.0.1",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left);
	IPField->SetBorderColor(Color::UIBorderGrey);

	PortField = std::make_shared<FTextFieldWidget>(
		Vector2(50.f, 50.f),
		Vector2(150.f, 30.f),
		Layer - 1,
		L"1234",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left);
	PortField->SetBorderColor(Color::UIBorderGrey);

	HideUI();
}

void FAntiCheatDialog::SetWindowProportion(Vector2 InWindowProportion)
{
	ConsoleWindowProportion = InWindowProportion;
}

void FAntiCheatDialog::SetWindowSize(Vector2 WindowSize)
{
	const Vector2 DefListSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 40.0f, WindowSize.y - 200.0f);
	const Vector2 DialogSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 30.0f, WindowSize.y - 90.0f);

	if (HeaderLabel) HeaderLabel->SetSize(Vector2(DialogSize.x, HeaderLabelHeight));
	if (BackgroundImage) BackgroundImage->SetSize(DialogSize);
}

void FAntiCheatDialog::Create()
{
	if (HeaderLabel) HeaderLabel->Create();
	if (BackgroundImage) BackgroundImage->Create();
	if (JoinGameButton) JoinGameButton->Create();
	if (LeaveGameButton) JoinGameButton->Create();
	if (PollStatusButton) PollStatusButton->Create();
	if (IPLabel) IPLabel->Create();
	if (IPField) IPField->Create();
	if (PortLabel) PortLabel->Create();
	if (PortField) PortField->Create();

	AddWidget(HeaderLabel);
	AddWidget(BackgroundImage);
	AddWidget(JoinGameButton);
	AddWidget(LeaveGameButton);
	AddWidget(PollStatusButton);
	AddWidget(IPLabel);
	AddWidget(IPField);
	AddWidget(PortLabel);
	AddWidget(PortField);
}

void FAntiCheatDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (HeaderLabel) HeaderLabel->SetPosition(Pos);
	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y));
	if (IPLabel) IPLabel->SetPosition(Pos + Vector2(0.f, 80.f));
	if (IPField) IPField->SetPosition(Pos + Vector2(90.f, 80.f));
	if (PortLabel) PortLabel->SetPosition(Pos + Vector2(0.f, 120.f));
	if (PortField) PortField->SetPosition(Pos + Vector2(90.f, 120.f));
	if (JoinGameButton) JoinGameButton->SetPosition(PortLabel->GetPosition() + Vector2(35.f, 60.f));
	if (LeaveGameButton) LeaveGameButton->SetPosition(JoinGameButton->GetPosition() + Vector2(0.f, 40.f));
	if (PollStatusButton) PollStatusButton->SetPosition(LeaveGameButton->GetPosition() + Vector2(0.f, 80.f));
}

void FAntiCheatDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (HeaderLabel) HeaderLabel->SetSize(Vector2(NewSize.x, HeaderLabelHeight));
	if (BackgroundImage) BackgroundImage->SetSize(Vector2(NewSize.x, NewSize.y));
	if (JoinGameButton) JoinGameButton->SetSize(Vector2(220.f, 30.f));
	if (LeaveGameButton) LeaveGameButton->SetSize(Vector2(220.f, 30.f));
	if (PollStatusButton) PollStatusButton->SetSize(Vector2(220.f, 30.f));
	if (IPLabel) IPLabel->SetSize(Vector2(100.f, 30.f));
	if (IPField) IPField->SetSize(Vector2(160.f, 30.f));
	if (PortLabel) PortLabel->SetSize(Vector2(100.f, 30.f));
	if (PortField) PortField->SetSize(Vector2(160.f, 30.f));
}

void FAntiCheatDialog::ShowUI()
{
	if (IPLabel)
	{
		IPLabel->Enable();
		IPLabel->Show();
	}

	if (IPField)
	{
		IPField->Enable();
		IPField->Show();
	}

	if (PortLabel)
	{
		PortLabel->Enable();
		PortLabel->Show();
	}

	if (PortField)
	{
		PortField->Enable();
		PortField->Show();
	}

	if (JoinGameButton)
	{
		JoinGameButton->Show();
	}

	if (LeaveGameButton)
	{
		LeaveGameButton->Show();
	}

	if (PollStatusButton)
	{
		PollStatusButton->Show();
	}
}

void FAntiCheatDialog::HideUI()
{
	if (IPLabel)
	{
		IPLabel->Hide();
	}

	if (IPField)
	{
		IPField->Disable();
		IPField->Hide();
	}

	if (PortLabel)
	{
		PortLabel->Hide();
	}

	if (PortField)
	{
		PortField->Disable();
		PortField->Hide();
	}

	if (JoinGameButton)
	{
		JoinGameButton->Hide();
	}

	if (LeaveGameButton)
	{
		LeaveGameButton->Hide();
	}

	if (PollStatusButton)
	{
		PollStatusButton->Hide();
	}

	SetFocused(false);
}

void FAntiCheatDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		ShowUI();
	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		LeaveGame();
		HideUI();
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		HideUI();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		ShowUI();
	}
	else if (Event.GetType() == EGameEventType::AntiCheatKicked)
	{
		LeaveGame();
	}
}

void FAntiCheatDialog::OnJoinGameButtonPressed()
{
	const PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (!Player)
	{
		FDebugLog::LogError(L"AntiCheatDialog - OnJoinGameButtonPressed: Current player is invalid!");
		return;
	}

	const std::string IP = FStringUtils::Narrow(IPField->GetText());
	const int Port = std::stoi(PortField->GetText());

	// Get a Connect ID Token which will be sent to the server as part of the registration message.
	EOS_ProductUserId ProductUserId = Player->GetProductUserID();
	std::string ConnectIdToken = FGame::Get().GetAuthentication()->GetConnectIdToken(ProductUserId);
	if (ConnectIdToken.empty())
	{
		FDebugLog::LogError(L"AntiCheatDialog - OnJoinGameButtonPressed: Failed to get Connect ID Token!");
		return;
	}

	const bool bDidSessionBegin = FGame::Get().GetAntiCheatClient()->Start(IP, Port, Player->GetProductUserID(), ConnectIdToken.c_str());
	if (bDidSessionBegin)
	{
		JoinGameButton->Disable();
		JoinGameButton->SetFocused(false);

		LeaveGameButton->Enable();
		LeaveGameButton->SetFocused(true);

		PollStatusButton->Enable();
	}
}

void FAntiCheatDialog::OnLeaveGameButtonPressed()
{
	LeaveGame();	
}

void FAntiCheatDialog::OnPollStatusButtonPressed()
{
	FGame::Get().GetAntiCheatClient()->PollStatus();
}

void FAntiCheatDialog::LeaveGame()
{
	FGame::Get().GetAntiCheatClient()->Stop();

	LeaveGameButton->Disable();
	LeaveGameButton->SetFocused(false);

	PollStatusButton->Disable();

	JoinGameButton->Enable();
	JoinGameButton->SetFocused(true);
}

```

`EAC_SDK/Samples/AntiCheat/Client/Source/AntiCheatDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "TextLabel.h"
#include "TextField.h"
#include "Button.h"
#include "Font.h"

class FGameEvent;

class FAntiCheatDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FAntiCheatDialog(Vector2 InPosition, 
		Vector2 InSize, 
		UILayer InLayer, 
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FAntiCheatDialog() override = default;

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;

	/** Sets proportion console is using */
	void SetWindowProportion(Vector2 InWindowProportion);

	/** Set Window Size */
	void SetWindowSize(Vector2 WindowSize);

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	void ShowUI();
	void HideUI();

	void OnJoinGameButtonPressed();
	void OnLeaveGameButtonPressed();
	void OnPollStatusButtonPressed();

private:

	void LeaveGame();

	/** Header Label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Part of window that console is taking */
	Vector2 ConsoleWindowProportion;

	/** Join Game button */
	std::shared_ptr<FButtonWidget> JoinGameButton;

	/** Leave Game button */
	std::shared_ptr<FButtonWidget> LeaveGameButton;

	/** Poll Status button */
	std::shared_ptr<FButtonWidget> PollStatusButton;

	/** IP (Host) label */
	std::shared_ptr<FTextLabelWidget> IPLabel;

	/** IP (Host) field */
	std::shared_ptr<FTextFieldWidget> IPField;

	/** Port label */
	std::shared_ptr<FTextLabelWidget> PortLabel;

	/** Port field */
	std::shared_ptr<FTextFieldWidget> PortField;
};


```

`EAC_SDK/Samples/AntiCheat/Client/Source/AntiCheatNetworkTransport.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "AntiCheatNetworkTransport.h"

FAntiCheatNetworkTransport::FAntiCheatNetworkTransport(): TCPClient(4096)
{
	TCPClient.SetOnBufferReceivedCallback([this](char* Buffer, size_t Length) { Receive(Buffer, Length); });
}

FAntiCheatNetworkTransport::~FAntiCheatNetworkTransport()
{

}

bool FAntiCheatNetworkTransport::Connect(const char* Host, uint16_t Port)
{
	return TCPClient.Connect(Host, Port);
}

void FAntiCheatNetworkTransport::Disconnect()
{
	TCPClient.Disconnect();
}

void FAntiCheatNetworkTransport::SetOnNewMessageCallback(FOnNewMessageCallback Callback)
{
	OnNewMessageCallback = std::move(Callback);
}

void FAntiCheatNetworkTransport::SetOnClientActionRequiredCallback(FOnClientActionRequiredCallback Callback)
{
	OnClientActionRequiredCallback = std::move(Callback);
}

void FAntiCheatNetworkTransport::Send(const EOS_AntiCheatClient_OnMessageToServerCallbackInfo* Message)
{
	char Buffer[4096] = {};
	size_t BufferPos = {};

	constexpr FMessageType MessageType = FMessageType::Opaque;
	const uint32_t MessageLength = Message->MessageDataSizeBytes;

	Write(MessageType, Buffer, BufferPos);
	Write(MessageLength, Buffer, BufferPos);
	Write(Message->MessageData, Message->MessageDataSizeBytes, Buffer, BufferPos);

	TCPClient.Send(Buffer, BufferPos);
}

void FAntiCheatNetworkTransport::Send(const FRegistrationInfoMessage& Message)
{
	char Buffer[4096] = {};
	size_t BufferPos = {};

	constexpr FMessageType MessageType = FMessageType::RegistrationInfo;
	const uint32_t MessageLength = 
		static_cast<uint32_t>(Message.ProductUserId.size() + 1) +
		sizeof(Message.ClientPlatform);

	Write(MessageType, Buffer, BufferPos);
	Write(MessageLength, Buffer, BufferPos);

	Write(Message.ProductUserId.c_str(), Message.ProductUserId.size() + 1, Buffer, BufferPos);
	Write(Message.EOSConnectIdTokenJWT.c_str(), Message.EOSConnectIdTokenJWT.size() + 1, Buffer, BufferPos);
	Write(Message.ClientPlatform, Buffer, BufferPos);

	TCPClient.Send(Buffer, BufferPos);
}

size_t FAntiCheatNetworkTransport::ProcessMessage(char* Buffer, size_t StartPosition)
{
	size_t Position = StartPosition;

	const FMessageType MessageType = Read<FMessageType>(Buffer, Position);
	const uint32_t MessageLength = Read<uint32_t>(Buffer, Position);

	if (MessageType == FMessageType::Opaque)
	{
		const char* Message = Read<char*>(Buffer, MessageLength, Position);
		OnNewMessageCallback(Message, MessageLength);
	}
	else if (MessageType == FMessageType::ClientActionRequired)
	{
		EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo Message = {};
		Message.ClientAction = Read<EOS_EAntiCheatCommonClientAction>(Buffer, Position);
		Message.ActionReasonCode = Read<EOS_EAntiCheatCommonClientActionReason>(Buffer, Position);
		Message.ActionReasonDetailsString = Read<char*>(Buffer, strlen(Buffer + Position) + 1, Position);
		OnClientActionRequiredCallback(Message);
	}

	return Position - StartPosition;
}

void FAntiCheatNetworkTransport::Receive(char* Buffer, size_t Length)
{
	size_t Position = 0;
	size_t BytesRemaining = Length;
	while (BytesRemaining > 0)
	{
		const size_t BytesRead = ProcessMessage(Buffer, Position);
		Position += BytesRead;
		BytesRemaining -= BytesRead;
	}
}

void FAntiCheatNetworkTransport::Update()
{
	TCPClient.Update();
}

```

`EAC_SDK/Samples/AntiCheat/Client/Source/AntiCheatNetworkTransport.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "TCPClient.h"

#include <eos_anticheatclient_types.h>

class FAntiCheatNetworkTransport
{
public:
	struct FRegistrationInfoMessage
	{
		std::string ProductUserId;
		std::string EOSConnectIdTokenJWT;
		EOS_EAntiCheatCommonClientPlatform ClientPlatform = EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Unknown;
	};

	/**
	* Constructor
	*/
	FAntiCheatNetworkTransport() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FAntiCheatNetworkTransport(FAntiCheatNetworkTransport const&) = delete;
	FAntiCheatNetworkTransport& operator=(FAntiCheatNetworkTransport const&) = delete;

	/**
	 * Destructor
	 */
	virtual ~FAntiCheatNetworkTransport();

	bool Connect(const char* Host, uint16_t Port);
	void Disconnect();

	using FOnNewMessageCallback = std::function<void(const void*, uint32_t)>;
	void SetOnNewMessageCallback(FOnNewMessageCallback Callback);

	using FOnClientActionRequiredCallback = std::function<void(EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo)>;
	void SetOnClientActionRequiredCallback(FOnClientActionRequiredCallback Callback);

	void Send(const EOS_AntiCheatClient_OnMessageToServerCallbackInfo* Message);
	void Send(const FRegistrationInfoMessage& Message);

	void Update();

private:
	size_t ProcessMessage(char* Buffer, size_t StartPosition);
	void Receive(char* Buffer, size_t Length);

	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value>>
	void Write(T ObjectToWrite, char* Buffer, size_t& Position)
	{
		memcpy(&Buffer[Position], &ObjectToWrite, sizeof(ObjectToWrite));
		Position += sizeof(ObjectToWrite);
	}

	template<typename T, typename = std::enable_if_t<std::is_pointer<T>::value>>
	void Write(T ObjectToWrite, size_t Size, char* Buffer, size_t& Position)
	{
		memcpy(&Buffer[Position], ObjectToWrite, Size);
		Position += Size;
	}

	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value>>
	T Read(char* Buffer, size_t& StartingPosition)
	{
		T ObjectToRead;
		memcpy(&ObjectToRead, &Buffer[StartingPosition], sizeof(ObjectToRead));
		StartingPosition += sizeof(ObjectToRead);
		return ObjectToRead;
	}

	template<typename T, typename = std::enable_if_t<std::is_pointer<T>::value>>
	T Read(char* Buffer, size_t BytesToRead, size_t& StartingPosition)
	{
		T Result = &Buffer[StartingPosition];
		StartingPosition += BytesToRead;
		return Result;
	}

private:
	enum class FMessageType : char
	{
		Opaque = 1,
		RegistrationInfo = 2,
		ClientActionRequired = 3
	};

	FTCPClient TCPClient;

	FOnNewMessageCallback OnNewMessageCallback;
	FOnClientActionRequiredCallback OnClientActionRequiredCallback;
};


```

`EAC_SDK/Samples/AntiCheat/Client/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Menu.h"
#include "Level.h"
#include "Game.h"
#include "AntiCheatClient.h"
#include "AntiCheatNetworkTransport.h"
#include "Authentication.h"

FGame::FGame() noexcept(false) :
	FBaseGame()
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	AntiCheatNetworkTransport = std::make_unique<FAntiCheatNetworkTransport>();
	AntiCheatClient = std::make_unique<FAntiCheatClient>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
	
}

void FGame::Init()
{
	FBaseGame::Init();
	FBaseGame::GetAuthentication()->SetDefaultLoginScope(EOS_EAuthScopeFlags::EOS_AS_BasicProfile);

	AntiCheatClient->Init();
}

void FGame::Update()
{
	FBaseGame::Update();

	AntiCheatNetworkTransport->Update();
}

void FGame::OnShutdown()
{
	AntiCheatClient->OnShutdown();

	FBaseGame::OnShutdown();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);
}

const std::unique_ptr<FAntiCheatClient>& FGame::GetAntiCheatClient()
{
	return AntiCheatClient;
}

const std::unique_ptr<FAntiCheatNetworkTransport>& FGame::GetAntiCheatNetworkTransport()
{
	return AntiCheatNetworkTransport;
}

```

`EAC_SDK/Samples/AntiCheat/Client/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FAntiCheatClient;
class FAntiCheatNetworkTransport;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Initialization
	*/
	virtual void Init() override;

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Called just before shutting down the game. Allows to finish current operations.
	*/
	virtual void OnShutdown() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/** 
	 * Getter for Anti-Cheat Client component.
	 */
	const std::unique_ptr<FAntiCheatClient>& GetAntiCheatClient();

	/** 
	 * Getter for Anti-Cheat Network Transport component.
	 */
	const std::unique_ptr<FAntiCheatNetworkTransport>& GetAntiCheatNetworkTransport();

protected:
	/** Anti-Cheat Client component */
	std::unique_ptr<FAntiCheatClient> AntiCheatClient;

	/** Anti-Cheat Network Transport component */
	std::unique_ptr<FAntiCheatNetworkTransport> AntiCheatNetworkTransport;
};

```

`EAC_SDK/Samples/AntiCheat/Client/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/AntiCheat/Client/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Menu.h"
#include "AuthDialogs.h"
#include "AntiCheatDialog.h"
#include "ConsoleDialog.h"
#include "ExitDialog.h"
#include "PopupDialog.h"
#include "Sprite.h"

const Vector2 ConsoleDialogSizeProportion = Vector2(0.68f, 0.35f);

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false) :
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreateAntiCheatDialog();

	FBaseMenu::Create();
}

void FMenu::Release()
{
	FBaseMenu::Release();

	if (AntiCheatDialog)
	{
		AntiCheatDialog->Release();
		AntiCheatDialog.reset();
	}
}

void FMenu::CreateAntiCheatDialog()
{
	const float FX = 100.0f;
	const float FY = 100.0f;
	const float Width = 300.0f;
	const float Height = 300.0f;

	AntiCheatDialog = std::make_shared<FAntiCheatDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont());

	AntiCheatDialog->SetWindowProportion(ConsoleDialogSizeProportion);
	AntiCheatDialog->SetBorderColor(Color::UIBorderGrey);

	AntiCheatDialog->Create();

	AddDialog(AntiCheatDialog);
}

void FMenu::CreateAuthDialogs()
{
	AuthDialogs = std::make_shared<FAuthDialogs>(
		AntiCheatDialog,
		L"AntiCheat",
		BoldSmallFont->GetFont(),
		SmallFont->GetFont(),
		TinyFont->GetFont());

	AuthDialogs->SetUserLabelOffset(Vector2(0.0f, -5.0f));
	AuthDialogs->Create();

	AuthDialogs->SetSingleUserOnly(true);
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * 0.7f, WindowSize.y * 0.75f);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (AntiCheatDialog)
		{
			Vector2 FriendsDialogSize = Vector2(WindowSize.x - ConsoleDialog->GetSize().x - 30.f,
				ConsoleDialog->GetSize().y);
			AntiCheatDialog->SetSize(FriendsDialogSize);

			Vector2 FriendDialogPos = Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
				ConsoleDialog->GetPosition().y);
			AntiCheatDialog->SetPosition(FriendDialogPos);
		}
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	FBaseMenu::OnGameEvent(Event);

	if (AntiCheatDialog) AntiCheatDialog->OnGameEvent(Event);
}
```

`EAC_SDK/Samples/AntiCheat/Client/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FAntiCheatDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Updates layout of elements
	*/
	virtual void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
    * Creates the Anti-Cheat dialog
    */
	void CreateAntiCheatDialog();

	/**
	* Destructor
	*/
	virtual ~FMenu() = default;

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

protected:
	/**
	 * Create auth dialogs
	 */
	virtual void CreateAuthDialogs() override;

private:
	/** Anti-Cheat Dialog */
	std::shared_ptr<FAntiCheatDialog> AntiCheatDialog;
};

```

`EAC_SDK/Samples/AntiCheat/Client/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "AntiCheat";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/AntiCheat/Client/Source/TCPClient.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "TCPClient.h"
#include "DebugLog.h"

FTCPClient::FTCPClient(size_t MaxBufferSizeBytes)
{
	SDLNet_Init();
	SocketSet = SDLNet_AllocSocketSet(1);

	Buffer.resize(MaxBufferSizeBytes);
}

FTCPClient::~FTCPClient()
{
	Disconnect();
	SDLNet_Quit();
}

bool FTCPClient::Connect(const char* Host, uint16_t Port)
{
	IPaddress IP;
	SDLNet_ResolveHost(&IP, Host, Port);
	
	Client = SDLNet_TCP_Open(&IP);
	if (!Client)
	{
		FDebugLog::LogError(L"Connect to server failed");
		return false;
	}
	SDLNet_TCP_AddSocket(SocketSet, Client);

	bIsConnected = true;
	return bIsConnected;
}

void FTCPClient::Disconnect()
{
	if (!bIsConnected)
	{
		return;
	}

	SDLNet_TCP_DelSocket(SocketSet, Client);
	SDLNet_TCP_Close(Client);

	Client = nullptr;
	bIsConnected = false;
	FDebugLog::LogWarning(L"Disconnected from server");
}

void FTCPClient::Send(const void* Data, size_t Length)
{
	if (!bIsConnected)
	{
		return;
	}

	SDLNet_TCP_Send(Client, Data, static_cast<int>(Length));
}

void FTCPClient::SetOnBufferReceivedCallback(std::function<void(char*, int)> Callback)
{
	OnBufferReceivedCallback = std::move(Callback);
}

void FTCPClient::Update()
{
	if (!bIsConnected)
	{
		return;
	}
	
	SDLNet_CheckSockets(SocketSet, 0);
	
	if (SDLNet_SocketReady(Client))
	{
		const int ReceivedBufferLength = SDLNet_TCP_Recv(Client, &Buffer[0], static_cast<int>(Buffer.size()));
		if (ReceivedBufferLength > 0)
		{
			OnBufferReceivedCallback(&Buffer[0], ReceivedBufferLength);
		}
		else
		{
			Disconnect();
		}
	}
}
```

`EAC_SDK/Samples/AntiCheat/Client/Source/TCPClient.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#define WITHOUT_SDL
#include "SDL_net.h"

class FTCPClient
{
public:
	/**
	 * No default constructor for this class
	 */
	FTCPClient() = delete;

	/**
	 * Constructor
	 */
	FTCPClient(size_t MaxBufferSizeBytes);

	/**
	 * No copying or copy assignment allowed for this class.
	 */
	FTCPClient(FTCPClient const&) = delete;
	FTCPClient& operator=(FTCPClient const&) = delete;

	/**
	 * Destructor
	 */
	virtual ~FTCPClient();

	bool Connect(const char* Host, uint16_t Port);
	void Disconnect();

	void Send(const void* Data, size_t Length);
	void SetOnBufferReceivedCallback(std::function<void(char*, int)> Callback);

	void Update();

private:
	bool bIsConnected = false;

	TCPsocket Client = nullptr;
	SDLNet_SocketSet SocketSet;

	std::vector<char> Buffer;

	std::function<void(char*, int)> OnBufferReceivedCallback;
};


```

`EAC_SDK/Samples/AntiCheat/Client/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/AntiCheat/Client/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/AntiCheat/Server/AntiCheatServer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{66E419CA-A396-4A05-BE97-300BFAE97825}</ProjectGuid>
    <RootNamespace>AntiCheatServer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../$(EOSSDKIncludes);../$(EOSSDKSamplesRoot)/AntiCheat/Server/Source;../$(EOSSDKSamplesRoot)/AntiCheat/Server/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/NotForLicensees/Source/Core;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86\Debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86\Debug\SDL2_net.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../$(EOSSDKIncludes);../$(EOSSDKSamplesRoot)/AntiCheat/Server/Source;../$(EOSSDKSamplesRoot)/AntiCheat/Server/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/NotForLicensees/Source/Core;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/lib/x86/Release%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x86\Release\SDL2_net.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../$(EOSSDKIncludes);../$(EOSSDKSamplesRoot)/AntiCheat/Server/Source;../$(EOSSDKSamplesRoot)/AntiCheat/Server/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/NotForLicensees/Source/Core;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp14</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/lib/x64/Debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64\Debug\SDL2_net.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../$(EOSSDKIncludes);../$(EOSSDKSamplesRoot)/AntiCheat/Server/Source;../$(EOSSDKSamplesRoot)/AntiCheat/Server/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/NotForLicensees/Source/Core;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp14</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_net/lib/x64/Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;SDL2_net.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_net\lib\x64\Release\SDL2_net.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\AntiCheatNetworkTransport.cpp" />
    <ClCompile Include="Source\AntiCheatServer.cpp" />
    <ClCompile Include="Source\Main\Main.cpp" />
    <ClCompile Include="Source\Main\ServerMain.cpp" />
    <ClCompile Include="Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Source\EosSdk.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <ClCompile Include="Source\TCPClient.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="Source\AntiCheatNetworkTransport.h" />
    <ClInclude Include="Source\AntiCheatServer.h" />
    <ClInclude Include="Source\Main\Main.h" />
    <ClInclude Include="Source\NonCopyable.h" />
    <ClInclude Include="Source\pch.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\EosSdk.h" />
    <ClInclude Include="Source\TCPClient.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EAC_SDK/Samples/AntiCheat/Server/AntiCheatServer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{dd833a82-590b-493f-a4d1-87b48427e8f3}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{877d3ba7-b77b-42d5-a38e-a7a6420ed9e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Main">
      <UniqueIdentifier>{d848b34a-2c50-4bc7-abdc-2f347fdacd68}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\EosSdk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Source\Main\Main.cpp">
      <Filter>Source Files\Main</Filter>
    </ClCompile>
    <ClCompile Include="Source\Main\ServerMain.cpp">
      <Filter>Source Files\Main</Filter>
    </ClCompile>
    <ClCompile Include="Source\TCPClient.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\AntiCheatNetworkTransport.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\AntiCheatServer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Source\pch.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\EosSdk.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Source\Main\Main.h">
      <Filter>Source Files\Main</Filter>
    </ClInclude>
    <ClInclude Include="Source\TCPClient.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\AntiCheatNetworkTransport.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\AntiCheatServer.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\NonCopyable.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/AntiCheat/Server/Source/AntiCheatNetworkTransport.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "AntiCheatNetworkTransport.h"

FAntiCheatNetworkTransport::FAntiCheatNetworkTransport()
	: TCPClient(10, 4096)
{
	TCPClient.SetOnBufferReceivedCallback([this](void* From, char* Buffer, size_t Length) { Receive(From, Buffer, Length); });
	TCPClient.SetOnClientDisconnectedCallback([this](void* Which) { OnClientDisconnectedCallback(Which); });
	TCPClient.Open(1234);
}

void FAntiCheatNetworkTransport::Send(const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Message)
{
	char Buffer[4096] = {};
	size_t BufferPos = {};

	constexpr FMessageType MessageType = FMessageType::ClientActionRequired;
	const uint32_t MessageLength = 
		sizeof(Message->ActionReasonCode) +
		sizeof(Message->ClientAction) +
		static_cast<uint32_t>(strlen(Message->ActionReasonDetailsString)) + 1;

	Write(MessageType, Buffer, BufferPos);
	Write(MessageLength, Buffer, BufferPos);
	Write(Message->ClientAction, Buffer, BufferPos);
	Write(Message->ActionReasonCode, Buffer, BufferPos);
	Write(Message->ActionReasonDetailsString, strlen(Message->ActionReasonDetailsString) + 1, Buffer, BufferPos);

	TCPClient.Send(Message->ClientHandle, &Buffer, BufferPos);
}

void FAntiCheatNetworkTransport::Send(const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Message)
{
	char Buffer[4096] = {};
	size_t BufferPos = {};

	constexpr FMessageType MessageType = FMessageType::Opaque;
	const uint32_t MessageLength = Message->MessageDataSizeBytes;

	Write(MessageType, Buffer, BufferPos);
	Write(MessageLength, Buffer, BufferPos);
	Write(Message->MessageData, Message->MessageDataSizeBytes, Buffer, BufferPos);

	TCPClient.Send(Message->ClientHandle, Buffer, BufferPos);
}

void FAntiCheatNetworkTransport::CloseClientConnection(void* ClientHandle)
{
	TCPClient.CloseClientConnection(reinterpret_cast<TCPsocket>(ClientHandle));
}

size_t FAntiCheatNetworkTransport::ProcessMessage(void* From, char* Buffer, size_t StartPosition)
{
	size_t Position = StartPosition;

	const FMessageType MessageType = Read<FMessageType>(Buffer, Position);
	const uint32_t MessageLength = Read<uint32_t>(Buffer, Position);

	if (MessageType == FMessageType::Opaque)
	{
		const char* Message = Read<char*>(Buffer, MessageLength, Position);
		OnNewMessageCallback(From, Message, MessageLength);
	}
	else if (MessageType == FMessageType::RegistrationInfo)
	{
		FRegistrationInfoMessage Message = {};
		Message.ProductUserId = Read<char*>(Buffer, strlen(Buffer + Position) + 1, Position);
		Message.EOSConnectIdTokenJWT = Read<char*>(Buffer, strlen(Buffer + Position) + 1, Position);
		Message.ClientPlatform = Read<EOS_EAntiCheatCommonClientPlatform>(Buffer, Position);
		OnNewClientCallback(From, Message);
	}

	return Position - StartPosition;
}

void FAntiCheatNetworkTransport::Receive(void* From, char* Buffer, size_t Length)
{
	size_t Position = 0;
	size_t BytesRemaining = Length;
	while (BytesRemaining > 0)
	{
		const size_t BytesRead = ProcessMessage(From, Buffer, Position);
		Position += BytesRead;
		BytesRemaining -= BytesRead;
	}
}

FAntiCheatNetworkTransport& FAntiCheatNetworkTransport::GetInstance()
{
	static FAntiCheatNetworkTransport Instance;
	return Instance;
}

void FAntiCheatNetworkTransport::Update()
{
	TCPClient.Update();
}

void FAntiCheatNetworkTransport::SetOnNewMessageCallback(FOnNewMessageCallback Callback)
{
	OnNewMessageCallback = std::move(Callback);
}

void FAntiCheatNetworkTransport::SetOnNewClientCallback(FOnNewClientCallback Callback)
{
	OnNewClientCallback = std::move(Callback);
}

void FAntiCheatNetworkTransport::SetOnClientDisconnectedCallback(FOnClientDisconnectedCallback Callback)
{
	OnClientDisconnectedCallback = std::move(Callback);
}

```

`EAC_SDK/Samples/AntiCheat/Server/Source/AntiCheatNetworkTransport.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_anticheatserver_types.h"
#include "TCPClient.h"

#include <cstring>
#include <type_traits>

class FAntiCheatNetworkTransport
{
public:
	struct FRegistrationInfoMessage
	{
		const char* ProductUserId = nullptr;
		const char* EOSConnectIdTokenJWT = nullptr;
		EOS_EAntiCheatCommonClientPlatform ClientPlatform = EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Unknown;
	};

	static FAntiCheatNetworkTransport& GetInstance();

	using FOnNewMessageCallback = std::function<void(void*, const void*, uint32_t)>;
	void SetOnNewMessageCallback(FOnNewMessageCallback Callback);

	using FOnNewClientCallback = std::function<void(void*, FRegistrationInfoMessage)>;
	void SetOnNewClientCallback(FOnNewClientCallback Callback);

	using FOnClientDisconnectedCallback = std::function<void(void*)>;
	void SetOnClientDisconnectedCallback(FOnClientDisconnectedCallback Callback);

	void Update();

	void Send(const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Message);
	void Send(const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Message);

	void CloseClientConnection(void* ClientHandle);

private:
	FAntiCheatNetworkTransport();

	void Receive(void* From, char* Buffer, size_t Length);
	size_t ProcessMessage(void* From, char* Buffer, size_t StartPosition);

	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value>>
	void Write(T ObjectToWrite, char* Buffer, size_t& Position)
	{
		memcpy(&Buffer[Position], &ObjectToWrite, sizeof(ObjectToWrite));
		Position += sizeof(ObjectToWrite);
	}

	template<typename T, typename = std::enable_if_t<std::is_pointer<T>::value>>
	void Write(T ObjectToWrite, size_t Size, char* Buffer, size_t& Position)
	{
		memcpy(&Buffer[Position], ObjectToWrite, Size);
		Position += Size;
	}

	template<typename T, typename = std::enable_if_t<!std::is_pointer<T>::value>>
	T Read(char* Buffer, size_t& StartingPosition)
	{
		T ObjectToRead;
		memcpy(&ObjectToRead, &Buffer[StartingPosition], sizeof(ObjectToRead));
		StartingPosition += sizeof(ObjectToRead);
		return ObjectToRead;
	}

	template<typename T, typename = std::enable_if_t<std::is_pointer<T>::value>>
	T Read(char* Buffer, size_t BytesToRead, size_t& StartingPosition)
	{
		T Result = &Buffer[StartingPosition];
		StartingPosition += BytesToRead;
		return Result;
	}

private:
	enum class FMessageType : char
	{
		Opaque = 1,
		RegistrationInfo = 2,
		ClientActionRequired = 3
	};

	FTCPClient TCPClient;

	FOnNewMessageCallback OnNewMessageCallback;
	FOnNewClientCallback OnNewClientCallback;
	FOnClientDisconnectedCallback OnClientDisconnectedCallback;
};


```

`EAC_SDK/Samples/AntiCheat/Server/Source/AntiCheatServer.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "AntiCheatServer.h"

#include "AntiCheatNetworkTransport.h"
#include "DebugLog.h"
#include "eos_connect.h"
#include "eos_anticheatserver.h"
#include "eos_anticheatserver_types.h"
#include "eos_sdk.h"
#include "TCPClient.h"

void FAntiCheatServer::Init(EOS_HPlatform Platform)
{
	ConnectHandle = EOS_Platform_GetConnectInterface(Platform);
	AntiCheatServerHandle = EOS_Platform_GetAntiCheatServerInterface(Platform);
}

void FAntiCheatServer::BeginSession()
{
	{
		EOS_AntiCheatServer_AddNotifyMessageToClientOptions Options = {};
		Options.ApiVersion = EOS_ANTICHEATSERVER_ADDNOTIFYMESSAGETOCLIENT_API_LATEST;
		MessageToClientId = EOS_AntiCheatServer_AddNotifyMessageToClient(AntiCheatServerHandle, &Options, this, OnMessageToClientCb);
	}

	{
		EOS_AntiCheatServer_AddNotifyClientActionRequiredOptions Options = {};
		Options.ApiVersion = EOS_ANTICHEATSERVER_ADDNOTIFYCLIENTACTIONREQUIRED_API_LATEST;
		ClientActionRequiredId = EOS_AntiCheatServer_AddNotifyClientActionRequired(AntiCheatServerHandle, &Options, this, OnClientActionRequiredCb);
	}

	{
		EOS_AntiCheatServer_BeginSessionOptions Options = {};
		Options.ApiVersion = EOS_ANTICHEATSERVER_BEGINSESSION_API_LATEST;
		Options.RegisterTimeoutSeconds = EOS_ANTICHEATSERVER_BEGINSESSION_MAX_REGISTERTIMEOUT;
		Options.ServerName = "Anti-Cheat Samples Server";
		Options.bEnableGameplayData = EOS_FALSE;
		Options.LocalUserId = nullptr;
		EOS_AntiCheatServer_BeginSession(AntiCheatServerHandle, &Options);
	}
}

void FAntiCheatServer::VerifyIdToken(EOS_ProductUserId ExpectedUserId, const char* ConnectIdTokenJWT, void* ClientData, const EOS_Connect_OnVerifyIdTokenCallback Callback)
{
	EOS_Connect_IdToken Token = {};
	Token.ApiVersion = EOS_CONNECT_IDTOKEN_API_LATEST;
	Token.ProductUserId = ExpectedUserId;
	Token.JsonWebToken = ConnectIdTokenJWT;

	EOS_Connect_VerifyIdTokenOptions Options = {};
	Options.ApiVersion = EOS_CONNECT_VERIFYIDTOKEN_API_LATEST;
	Options.IdToken = &Token;

	EOS_Connect_VerifyIdToken(ConnectHandle, &Options, ClientData, Callback);
}

void FAntiCheatServer::RegisterClient(void* ClientHandle, FAntiCheatNetworkTransport::FRegistrationInfoMessage Message)
{
	EOS_AntiCheatServer_RegisterClientOptions Options = {};
	Options.ApiVersion = EOS_ANTICHEATSERVER_REGISTERCLIENT_API_LATEST;
	Options.ClientHandle = ClientHandle;

	// The ClientPlatform value was validated using an EOS Connect ID token before this function is called.
	Options.ClientPlatform = Message.ClientPlatform;
	if (Message.ClientPlatform == EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Windows ||
		Message.ClientPlatform == EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Mac ||
		Message.ClientPlatform == EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Linux)
	{
		Options.ClientType = EOS_EAntiCheatCommonClientType::EOS_ACCCT_ProtectedClient;
	}
	else
	{
		Options.ClientType = EOS_EAntiCheatCommonClientType::EOS_ACCCT_UnprotectedClient;
	}
	
	// The ProductUserId value was validated using an EOS Connect ID token before this function is called.
	Options.UserId = EOS_ProductUserId_FromString(Message.ProductUserId);

	EOS_AntiCheatServer_RegisterClient(AntiCheatServerHandle, &Options);
}

void FAntiCheatServer::UnregisterClient(void* ClientHandle)
{
	EOS_AntiCheatServer_UnregisterClientOptions Options = {};
	Options.ApiVersion = EOS_ANTICHEATSERVER_UNREGISTERCLIENT_API_LATEST;
	Options.ClientHandle = ClientHandle;

	EOS_AntiCheatServer_UnregisterClient(AntiCheatServerHandle, &Options);
}

void FAntiCheatServer::EndSession()
{
	EOS_AntiCheatServer_RemoveNotifyMessageToClient(AntiCheatServerHandle, MessageToClientId);
	EOS_AntiCheatServer_RemoveNotifyClientActionRequired(AntiCheatServerHandle, ClientActionRequiredId);

	EOS_AntiCheatServer_EndSessionOptions Options = {};
	Options.ApiVersion = EOS_ANTICHEATSERVER_ENDSESSION_API_LATEST;
	EOS_AntiCheatServer_EndSession(AntiCheatServerHandle, &Options);
}

void FAntiCheatServer::OnMessageFromClientReceived(void* ClientHandle, const void* Data, uint32_t DataLengthBytes)
{
	EOS_AntiCheatServer_ReceiveMessageFromClientOptions Options = {};

	Options.ApiVersion = EOS_ANTICHEATSERVER_RECEIVEMESSAGEFROMCLIENT_API_LATEST;
	Options.ClientHandle = ClientHandle;
	Options.Data = Data;
	Options.DataLengthBytes = DataLengthBytes;

	EOS_AntiCheatServer_ReceiveMessageFromClient(AntiCheatServerHandle, &Options);
}

void FAntiCheatServer::OnMessageToClientCb(const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Message)
{
	FAntiCheatNetworkTransport::GetInstance().Send(Message);
}

void FAntiCheatServer::OnClientActionRequiredCb(const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Message)
{
	FAntiCheatNetworkTransport::GetInstance().Send(Message);
	FAntiCheatNetworkTransport::GetInstance().CloseClientConnection(Message->ClientHandle);
}

```

`EAC_SDK/Samples/AntiCheat/Server/Source/AntiCheatServer.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "AntiCheatNetworkTransport.h"

#include "eos_connect_types.h"
#include "eos_anticheatserver_types.h"
#include "eos_types.h"

class FAntiCheatServer
{
public:
	void Init(EOS_HPlatform Platform);
	void BeginSession();
	void EndSession();

	void VerifyIdToken(EOS_ProductUserId ExpectedUserId, const char* ConnectIdTokenJWT, void* ClientData, const EOS_Connect_OnVerifyIdTokenCallback Callback);
	void RegisterClient(void* ClientHandle, FAntiCheatNetworkTransport::FRegistrationInfoMessage Message);
	void UnregisterClient(void* ClientHandle);

	void OnMessageFromClientReceived(void* ClientHandle, const void* Data, uint32_t DataLengthBytes);
	
private:
	static void EOS_CALL OnMessageToClientCb(const EOS_AntiCheatCommon_OnMessageToClientCallbackInfo* Data);
	static void EOS_CALL OnClientActionRequiredCb(const EOS_AntiCheatCommon_OnClientActionRequiredCallbackInfo* Data);

private:
	EOS_HConnect ConnectHandle = nullptr;
	EOS_HAntiCheatServer AntiCheatServerHandle = nullptr;

	EOS_NotificationId MessageToClientId;
	EOS_NotificationId ClientActionRequiredId;
};


```

`EAC_SDK/Samples/AntiCheat/Server/Source/EosSdk.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "EosSdk.h"

#include "SampleConstants.h"

#include "DebugLog.h"
#include "Utils.h"
#include "StringUtils.h"
#include "CommandLine.h"

#if ALLOW_RESERVED_OPTIONS
#include "ReservedPlatformOptions.h"
#endif

#ifdef _WIN32
#include "Windows/eos_Windows.h"
#endif

#include <eos_logging.h>

constexpr char SampleConstants::ProductId[];
constexpr char SampleConstants::SandboxId[];
constexpr char SampleConstants::DeploymentId[];
constexpr char SampleConstants::ClientCredentialsId[];
constexpr char SampleConstants::ClientCredentialsSecret[];
constexpr char SampleConstants::EncryptionKey[];
constexpr char SampleConstants::GameName[];

EOS_Bool FEosSdk::LoadAndInitSdk()
{
	FDebugLog::Log(L"[EOS SDK] Initializing ...");

	// Init EOS SDK
	EOS_InitializeOptions SDKOptions = {};
	SDKOptions.ApiVersion = EOS_INITIALIZE_API_LATEST;
	SDKOptions.AllocateMemoryFunction = nullptr;
	SDKOptions.ReallocateMemoryFunction = nullptr;
	SDKOptions.ReleaseMemoryFunction = nullptr;
	SDKOptions.ProductName = SampleConstants::GameName;
	SDKOptions.ProductVersion = "1.0";
	SDKOptions.Reserved = nullptr;
	SDKOptions.SystemInitializeOptions = nullptr;
	SDKOptions.OverrideThreadAffinity = nullptr;

	EOS_EResult InitResult = EOS_Initialize(&SDKOptions);
	if (InitResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::Log(L"[EOS SDK] Init Failed!");
		return EOS_FALSE;
	}

	FDebugLog::Log(L"[EOS SDK] Initialized. Setting Logging Callback ...");

	EOS_EResult SetLogCallbackResult = EOS_Logging_SetCallback([](const EOS_LogMessage* InMsg) {
		if (InMsg != nullptr && InMsg->Level != EOS_ELogLevel::EOS_LOG_Off)
		{
			if (InMsg->Level == EOS_ELogLevel::EOS_LOG_Error || InMsg->Level == EOS_ELogLevel::EOS_LOG_Fatal)
			{
				FDebugLog::Log(L"[EOS SDK] ERROR %ls: %ls", FStringUtils::Widen(InMsg->Category).c_str(), FStringUtils::Widen(InMsg->Message).c_str());
			}
			else if (InMsg->Level == EOS_ELogLevel::EOS_LOG_Warning)
			{
				FDebugLog::Log(L"[EOS SDK] WARNING %ls: %ls", FStringUtils::Widen(InMsg->Category).c_str(), FStringUtils::Widen(InMsg->Message).c_str());
			}
			else
			{
				FDebugLog::Log(L"[EOS SDK] %ls: %ls", FStringUtils::Widen(InMsg->Category).c_str(), FStringUtils::Widen(InMsg->Message).c_str());
			}
		}
	});

	if (SetLogCallbackResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::Log(L"[EOS SDK] Set Logging Callback Failed!");
	}
	else
	{
		FDebugLog::Log(L"[EOS SDK] Logging Callback Set");
		EOS_Logging_SetLogLevel(EOS_ELogCategory::EOS_LC_ALL_CATEGORIES, EOS_ELogLevel::EOS_LOG_VeryVerbose);
	}

	// Create platform instance
	EOS_Platform_Options PlatformOptions = {};
	PlatformOptions.ApiVersion = EOS_PLATFORM_OPTIONS_API_LATEST;
	PlatformOptions.bIsServer = EOS_TRUE;
	PlatformOptions.EncryptionKey = SampleConstants::EncryptionKey;
	PlatformOptions.OverrideCountryCode = nullptr;
	PlatformOptions.OverrideLocaleCode = nullptr;
	PlatformOptions.Flags = EOS_PF_DISABLE_OVERLAY; // no overlay needed for the server app
	PlatformOptions.CacheDirectory = FUtils::GetTempDirectory();

	bool bHasInvalidParamProductId = false;
	bool bHasInvalidParamSandboxId = false;
	bool bHasInvalidParamDeploymentId = false;
	bool bHasInvalidParamClientCreds = false;

	std::string ProductId = SampleConstants::ProductId;
	std::string SandboxId = SampleConstants::SandboxId;
	std::string DeploymentId = SampleConstants::DeploymentId;

	// Use Command Line vars to populate vars if they exist
	std::wstring CmdProductID = FCommandLine::Get().GetParamValue(CommandLineConstants::ProductId);
	if (!CmdProductID.empty())
	{
		ProductId = FStringUtils::Narrow(CmdProductID);
	}
	bHasInvalidParamProductId = ProductId.empty() ? true : false;

	bHasInvalidParamSandboxId = false;
	std::wstring CmdSandboxID = FCommandLine::Get().GetParamValue(CommandLineConstants::SandboxId);
	if (!CmdSandboxID.empty())
	{
		SandboxId = FStringUtils::Narrow(CmdSandboxID);
	}
	bHasInvalidParamSandboxId = SandboxId.empty() ? true : false;

	std::wstring CmdDeploymentID = FCommandLine::Get().GetParamValue(CommandLineConstants::DeploymentId);
	if (!CmdDeploymentID.empty())
	{
		DeploymentId = FStringUtils::Narrow(CmdDeploymentID);
	}
	bHasInvalidParamDeploymentId = DeploymentId.empty() ? true : false;

	PlatformOptions.ProductId = ProductId.c_str();
	PlatformOptions.SandboxId = SandboxId.c_str();
	PlatformOptions.DeploymentId = DeploymentId.c_str();

	std::string ClientId = SampleConstants::ClientCredentialsId;
	std::string ClientSecret = SampleConstants::ClientCredentialsSecret;

	// Use Command Line vars to populate vars if they exist
	std::wstring CmdClientID = FCommandLine::Get().GetParamValue(CommandLineConstants::ClientId);
	if (!CmdClientID.empty())
	{
		ClientId = FStringUtils::Narrow(CmdClientID);
	}
	std::wstring CmdClientSecret = FCommandLine::Get().GetParamValue(CommandLineConstants::ClientSecret);
	if (!CmdClientSecret.empty())
	{
		ClientSecret = FStringUtils::Narrow(CmdClientSecret);
	}

	bHasInvalidParamClientCreds = false;
	if (!ClientId.empty() && !ClientSecret.empty())
	{
		PlatformOptions.ClientCredentials.ClientId = ClientId.c_str();
		PlatformOptions.ClientCredentials.ClientSecret = ClientSecret.c_str();
	}
	else if (!ClientId.empty() || !ClientSecret.empty())
	{
		bHasInvalidParamClientCreds = true;
	}
	else
	{
		PlatformOptions.ClientCredentials.ClientId = nullptr;
		PlatformOptions.ClientCredentials.ClientSecret = nullptr;
	}

	if (bHasInvalidParamProductId ||
		bHasInvalidParamSandboxId ||
		bHasInvalidParamDeploymentId ||
		bHasInvalidParamClientCreds)
	{
		return false;
	}

#if ALLOW_RESERVED_OPTIONS
	SetReservedPlatformOptions(PlatformOptions);
#else
	PlatformOptions.Reserved = NULL;
#endif // ALLOW_RESERVED_OPTIONS

	PlatformHandle = EOS_Platform_Create(&PlatformOptions);

	if (PlatformHandle == nullptr)
	{
		return false;
	}

	return EOS_TRUE;
}

EOS_Bool FEosSdk::Shutdown()
{
	if (PlatformHandle != nullptr)
	{
		EOS_Platform_Release(PlatformHandle);
		PlatformHandle = nullptr;
	}

	EOS_EResult ShutdownResult = EOS_Shutdown();

	if (ShutdownResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::Log(L"SDK Failed to shutdown Err:%d\n", static_cast<int32_t>(ShutdownResult));
		return EOS_FALSE;
	}

	FDebugLog::Log(L"Attempting to unload the SDK...");

	return EOS_TRUE;
}

void FEosSdk::Tick()
{
	EOS_Platform_Tick(PlatformHandle);
}

```

`EAC_SDK/Samples/AntiCheat/Server/Source/EosSdk.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_sdk.h>

class FEosSdk
{
public:
	FEosSdk() = default;

	FEosSdk(const FEosSdk&) = delete;
	FEosSdk& operator=(const FEosSdk&) = delete;

	EOS_Bool LoadAndInitSdk();
	EOS_Bool Shutdown();

	/** Processes queued requests */
	void Tick();

public:
	/** Handle to EOS SDK Platform */
	EOS_HPlatform PlatformHandle = nullptr;
};

```

`EAC_SDK/Samples/AntiCheat/Server/Source/Main/MacMain.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

int MainDriverMac(int argc, const char* argv[], int (*Driver)(int, const char*[]));


```

`EAC_SDK/Samples/AntiCheat/Server/Source/Main/MacMain.mm`:

```mm
// Copyright Epic Games, Inc. All Rights Reserved.

#include "MacMain.h"

#if __APPLE__

#import <CoreFoundation/CoreFoundation.h>
#import <AppKit/AppKit.h>

@interface AppDelegate : NSObject <NSApplicationDelegate>
@property (nonatomic, assign) int argc;
@property (nonatomic, assign) const char** argv;
@property (atomic, retain) NSThread* logicThread;
@property (nonatomic, assign) int exitCode;
@property (nonatomic, assign) int (*Driver)(int, const char* []);

- (id)initWithCommandLineParams:(int)argc argv:(const char* [])argv driver:(int (*)(int, const char* []))Driver;
@end

@implementation AppDelegate
- (id)initWithCommandLineParams:(int)argc argv:(const char* [])argv driver:(int (*)(int, const char* []))Driver
{
	if (!Driver) {
		return nil;
	}
	
	if (self = [super init]) {
		_argc = argc;
		_argv = argv;
		_Driver = Driver;
		_logicThread = NULL;
		_exitCode = -1;
	}
	return self;
}

- (void)dealloc
{
	[_logicThread release];
	[super dealloc];
}

- (void)handleQuitEvent:(NSAppleEventDescriptor*)event withReplyEvent:(NSAppleEventDescriptor*)replyEvent
{
	self.exitCode = -1;
	[self terminate];
}

- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
{
	self.exitCode = -1;
	[self terminate];
	return NSTerminateCancel;
}

- (void)applicationDidFinishLaunching:(NSNotification *)notification
{
	NSAppleEventManager* eventManager = [NSAppleEventManager sharedAppleEventManager];
	[eventManager setEventHandler:self andSelector:@selector(handleQuitEvent:withReplyEvent:) forEventClass:kCoreEventClass andEventID:kAEQuitApplication];
	
	self.logicThread = [[NSThread alloc] initWithBlock:^{
		self.exitCode = (*self.Driver)(self.argc, self.argv);
		[self terminate];
	}];
	[self.logicThread start];
}

- (void)terminate
{
	NSEvent* dummyEvent = [NSEvent otherEventWithType:NSEventTypeApplicationDefined location:{0, 0} modifierFlags:0 timestamp:0 windowNumber:0 context:nil subtype:0 data1:0 data2:0];
	[NSApp stop:self];
	[NSApp postEvent:dummyEvent atStart:TRUE];
}

@end

void DisableAppNap(void)
{
	if ([[NSProcessInfo processInfo] respondsToSelector:@selector(beginActivityWithOptions:reason:)])
	{
		[[NSProcessInfo processInfo] beginActivityWithOptions:0x00FFFFFF reason:@"Not sleepy and don't want to nap"];
	}
}

#endif

int MainDriverMac(int argc, const char* argv[], int (*Driver)(int, const char*[]))
{
#if __APPLE__
	DisableAppNap();
	NSAutoreleasePool* AutoreleasePool = [NSAutoreleasePool new];
	NSApplication* app = [NSApplication sharedApplication];
	AppDelegate* delegate = [[AppDelegate alloc] initWithCommandLineParams:argc argv:argv driver:Driver];
	app.delegate = delegate;
	[app run];
	app.delegate = NULL;
	
	int returnValue = [delegate exitCode];
	[delegate release];
	[AutoreleasePool release];
	return returnValue;
#else
	(void)Driver;
	return 0;
#endif
}


```

`EAC_SDK/Samples/AntiCheat/Server/Source/Main/Main.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "Main.h"

#include "DebugLog.h"
#include "StringUtils.h"
#include "CommandLine.h"
#include "Settings.h"

#define CONSOLE_COL_WHITE "\033[1m\033[37m"		// White
#define CONSOLE_COL_RED "\033[1m\033[31m"		// Red
#define CONSOLE_COL_YELLOW "\033[1m\033[33m"	// Yellow
#define CONSOLE_COL_RESET "\033[0m"				// Reset

std::unique_ptr<FMain> Main;

FMain::FMain() noexcept(false)
{
	FDebugLog::Init();

	FDebugLog::AddTarget(FDebugLog::ELogTarget::Console);
	FDebugLog::AddTarget(FDebugLog::ELogTarget::File);

#ifdef _WIN32
	FDebugLog::AddTarget(FDebugLog::ELogTarget::DebugOutput);

	if (HANDLE ConsoleHandle = GetStdHandle(STD_OUTPUT_HANDLE))
	{
		DWORD ConsoleMode = 0;
		GetConsoleMode( ConsoleHandle, &ConsoleMode );
		ConsoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
		SetConsoleMode(ConsoleHandle, ConsoleMode);
	}
#endif // _WIN32
}

FMain::~FMain()
{
	FDebugLog::Close();
}

void FMain::InitCommandLine()
{

}

void FMain::PrintToConsole(const std::wstring& Message)
{
	const std::string Msg = CONSOLE_COL_WHITE + FStringUtils::Narrow(Message) + CONSOLE_COL_RESET;
	puts(Msg.c_str());
}

void FMain::PrintWarningToConsole(const std::wstring& Message)
{
	const std::string Msg = CONSOLE_COL_YELLOW + FStringUtils::Narrow(Message) + CONSOLE_COL_RESET;
	puts(Msg.c_str());
}

void FMain::PrintErrorToConsole(const std::wstring& Message)
{
	const std::string Msg = CONSOLE_COL_RED + FStringUtils::Narrow(Message) + CONSOLE_COL_RESET;
	puts(Msg.c_str());
}
```

`EAC_SDK/Samples/AntiCheat/Server/Source/Main/Main.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/**
* Main class for Windows project
*/
class FMain
{
public:
	/**
	* Constructor
	*/
	FMain() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMain(FMain const&) = delete;
	FMain& operator=(FMain const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMain();

	/**
	* Initializes command line
	*/
	void InitCommandLine();

	/**
	* Utility function for printing a message to in-game console
	*
	* @param Message - Message to print to console
	*/
	void PrintToConsole(const std::wstring& Message);

	/**
	* Utility function for printing a warning message to in-game console
	*
	* @param Message - Message to print to console
	*/
	void PrintWarningToConsole(const std::wstring& Message);

	/**
	* Utility function for printing an error message to in-game console
	*
	* @param Message - Message to print to console
	*/
	void PrintErrorToConsole(const std::wstring& Message);
};

/** Global accessor for main */
extern std::unique_ptr<FMain> Main;
```

`EAC_SDK/Samples/AntiCheat/Server/Source/Main/ServerMain.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "EosSdk.h"

#include "Main.h"

#ifdef __APPLE__
#include "MacMain.h"
#endif


#include "DebugLog.h"
#include "StringUtils.h"
#include "CommandLine.h"
#include "Settings.h"
#include "SampleConstants.h"
#include "AntiCheatNetworkTransport.h"
#include "AntiCheatServer.h"

using namespace std;

bool bIsRunning = true;

#ifdef _WIN32
BOOL WINAPI ConsoleHandler(DWORD CtrlType)
{
	static const WCHAR* EventNames[7] = {
		L"CTRL_C_EVENT",
		L"CTRL_BREAK_EVENT",
		L"CTRL_CLOSE_EVENT",
		L"", // Reserved
		L"", // Reserved
		L"CTRL_LOGOFF_EVENT",
		L"CTRL_SHUTDOWN_EVENT"
	};

	switch (CtrlType)
	{
		case CTRL_C_EVENT:
		case CTRL_BREAK_EVENT:
		case CTRL_CLOSE_EVENT:
		case CTRL_LOGOFF_EVENT:
		case CTRL_SHUTDOWN_EVENT:
			FDebugLog::Log(L"Exiting due to %ls...", EventNames[CtrlType]);
			bIsRunning = false;			
			return TRUE;

		default:
			return FALSE;
	}
}
#endif // _WIN32

int MasterMain(int Argc, const char* Args[])
{
	std::wstring CommandLine;
	for (int i = 0; i < Argc; ++i)
	{
		CommandLine += (FStringUtils::Widen(Args[i]) + L" ");
	}

	FCommandLine::Get().Init(const_cast<LPWSTR>(CommandLine.c_str()));
	FSettings::Get().Init();

	Main = std::make_unique<FMain>();
	Main->InitCommandLine();

	FDebugLog::Log(L"EOS AntiCheat Server Sample");

	bIsRunning = true;

#ifdef _WIN32
	if (!SetConsoleCtrlHandler(ConsoleHandler, TRUE))
	{
		FDebugLog::LogError(L"Could not set control handler!");
		return 1;
	}
#endif // _WIN32

	// parse listen port
	uint16 Port = SampleConstants::ServerPort;
	if (FCommandLine::Get().HasParam(CommandLineConstants::ServerPort))
	{
		try
		{
			Port = static_cast<uint16>(std::stoi(FCommandLine::Get().GetParamValue(CommandLineConstants::ServerPort)));
		}
		catch (const std::invalid_argument&)
		{
			FDebugLog::LogError(L"Error: Can't parse port - invalid argument");
		}
		catch (const std::out_of_range&)
		{
			FDebugLog::LogError(L"Error: Can't parse port - out of range.");
		}
		catch (const std::exception&)
		{
			FDebugLog::LogError(L"Error: Can't parse port, undefined error.");
		}
	}

	// create and load sdk
	FEosSdkPtr EosSdk = std::make_shared<FEosSdk>();
	if (!EosSdk->LoadAndInitSdk())
	{
		FDebugLog::LogError(L"Unable to initialize sdk!");
		return 1;
	}

	FDebugLog::Log(L"Listening on port %d", Port);
	FDebugLog::Log(L"(ctrl - c) to exit");

	FAntiCheatServer Server;

	Server.Init(EosSdk->PlatformHandle);

	Server.BeginSession();

	FAntiCheatNetworkTransport::GetInstance().SetOnNewClientCallback([&Server](void* ClientHandle, FAntiCheatNetworkTransport::FRegistrationInfoMessage Message)
	{
		struct VerifyCallbackHelper
		{
			FAntiCheatServer* Server = nullptr;
			void* ClientHandle = nullptr;
			FAntiCheatNetworkTransport::FRegistrationInfoMessage Message;
		};
		auto VerifyCallback = [](const EOS_Connect_VerifyIdTokenCallbackInfo* Data)
		{
			// Called when the Connect ID Token validation operation is complete.
			bool bIsValidationOk = false;
			VerifyCallbackHelper* Helper = reinterpret_cast<VerifyCallbackHelper*>(Data->ClientData);
			if (Data->ResultCode == EOS_EResult::EOS_Success)
			{
				if (Data->bIsAccountInfoPresent)
				{
					FDebugLog::Log(L"EOS Connect ID Token DeviceType: %ls", FStringUtils::Widen(Data->DeviceType).c_str());

					bool bIsPlatformOk = true;
					switch (Helper->Message.ClientPlatform)
					{
						// The anti-cheat client does not support consoles or mobile devices, so we must handle
						// the anti-cheat ClientPlatform and related ClientType with care to prevent exploits.

						// If the user registration message claims to be on console, verify that an actual console device is being used.
						// See platform types here https://dev.epicgames.com/docs/game-services/eos-connect-interface#user-verification-using-an-id-token
						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Nintendo:
							if (strcmp(Data->DeviceType, "Switch") != 0)
							{
								FDebugLog::LogError(L"Player claims to be on Nintendo but EOS Connect ID Token DeviceType doesn't match");
								bIsPlatformOk = false;
							}
							break;
						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_PlayStation:
							if (strcmp(Data->DeviceType, "PSVITA") != 0 && strcmp(Data->Platform, "PS3") != 0 && strcmp(Data->Platform, "PS4") != 0 && strcmp(Data->Platform, "PS5") != 0)
							{
								FDebugLog::LogError(L"Player claims to be on Playstation but EOS Connect ID Token DeviceType doesn't match");
								bIsPlatformOk = false;
							}
							break;
						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Xbox:
							if (strcmp(Data->DeviceType, "Xbox360") != 0 && strcmp(Data->Platform, "XboxOne") != 0)
							{
								FDebugLog::LogError(L"Player claims to be on Xbox but EOS Connect ID Token DeviceType doesn't match");
								bIsPlatformOk = false;
							}
							break;

						// These platforms do not require verification because they have anti-cheat client support and we will 
						// require it by setting the anti-cheat ClientType to EOS_ACCCT_ProtectedClient in RegisterClient.
						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Windows:
						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Mac:
						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Linux:
							break;
							
						// If the user registration message claims to be a mobile device and your game supports mobile clients,
						// you must must implement your own check to verify that players are really using the claimed device type.
						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Android:
						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_iOS:
							// Your own platform check could go here. This sample does not support mobile clients.
							FDebugLog::LogError(L"Player claims to be on mobile but this sample does not support mobile clients");
							bIsPlatformOk = false;
							break;

						case EOS_EAntiCheatCommonClientPlatform::EOS_ACCCP_Unknown:
						default:
							FDebugLog::LogError(L"Player claims to be on an unknown platform");
							bIsPlatformOk = false;
							break;
					}

					// On success, continue to anti-cheat registration.
					if (bIsPlatformOk)
					{
						bIsValidationOk = true;
						Helper->Server->RegisterClient(Helper->ClientHandle, Helper->Message);
					}
				}
			}

			if (!bIsValidationOk)
			{
				// On failure, the player should not be allowed to continue connecting to the server.
				FDebugLog::LogError(L"EOS Connect ID Token verification failed, player will be removed");
				FAntiCheatNetworkTransport::GetInstance().CloseClientConnection(Helper->ClientHandle);
			}
			delete Helper;
		};

		// We must verify the the player's identity using the provided Connect ID Token before we allow them to continue connecting.
		Server.VerifyIdToken(EOS_ProductUserId_FromString(Message.ProductUserId), Message.EOSConnectIdTokenJWT, new VerifyCallbackHelper{&Server, ClientHandle, Message}, VerifyCallback);
	});
	FAntiCheatNetworkTransport::GetInstance().SetOnClientDisconnectedCallback([&Server](void* ClientHandle) 
	{
		// is active
		Server.UnregisterClient(ClientHandle);
	});
	FAntiCheatNetworkTransport::GetInstance().SetOnNewMessageCallback([&Server](void* ClientHandle, const void* Data, uint32_t Length)
	{
		Server.OnMessageFromClientReceived(ClientHandle, Data, Length);
	});

	// main loop
	while (bIsRunning)
	{
		FAntiCheatNetworkTransport::GetInstance().Update();

		// update the sdk on the mainthread
		EosSdk->Tick();
		
		// simulate other server activity
		std::this_thread::sleep_for(std::chrono::milliseconds(30));
	}

	Server.EndSession();

	// then shutdown the sdk
	EosSdk->Shutdown();

	return 0;
}

int main(int argc, const char *argv[])
{

#if __APPLE__
	int returnValue = MainDriverMac(argc, argv, &MasterMain);
#else
	int returnValue = MasterMain(argc, argv);
#endif
	
	return returnValue;
}

```

`EAC_SDK/Samples/AntiCheat/Server/Source/NonCopyable.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

class FNonCopyable
{
public:
	FNonCopyable() = default;

	FNonCopyable(const FNonCopyable&) = delete;
	FNonCopyable& operator=(const FNonCopyable&) = delete;
};

```

`EAC_SDK/Samples/AntiCheat/Server/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "AntiCheat Server";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";

	/** Server Port */
	static constexpr uint16 ServerPort = 1234;
};

```

`EAC_SDK/Samples/AntiCheat/Server/Source/TCPClient.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "TCPClient.h"
#include "DebugLog.h"

FTCPClient::FTCPClient(int MaxSockets, size_t MaxBufferSizeBytes)
{
	SDLNet_Init();

	ClientsSockets.reserve(MaxSockets);
	SocketSet = SDLNet_AllocSocketSet(MaxSockets + 1); // +1 for the Server socket

	Buffer.resize(MaxBufferSizeBytes);
}

FTCPClient::~FTCPClient()
{
	CloseServerConnection();
	for (TCPsocket ClientSocket : ClientsSockets)
	{
		CloseClientConnection(ClientSocket);
	}

	SDLNet_FreeSocketSet(SocketSet);
	SDLNet_Quit();
}

void FTCPClient::Open(uint16_t Port)
{
	IPaddress IP;
	SDLNet_ResolveHost(&IP, nullptr, Port);
	
	ServerSocket = SDLNet_TCP_Open(&IP);
	SDLNet_TCP_AddSocket(SocketSet, ServerSocket);
}

void FTCPClient::Send(void* To, const void* Data, size_t Length)
{
	SDLNet_TCP_Send(reinterpret_cast<TCPsocket>(To), Data, static_cast<int>(Length));
}

void FTCPClient::SetOnClientDisconnectedCallback(FOnClientDisconnectedCallback Callback)
{
	OnClientDisconnectedCallback = std::move(Callback);
}

void FTCPClient::SetOnBufferReceivedCallback(FOnBufferReceivedCallback Callback)
{
	OnBufferReceivedCallback = std::move(Callback);
}

void FTCPClient::OpenNewClientConnection()
{
	TCPsocket NewlyConnectedClientSocket = SDLNet_TCP_Accept(ServerSocket);

	SDLNet_TCP_AddSocket(SocketSet, NewlyConnectedClientSocket);
	ClientsSockets.push_back(NewlyConnectedClientSocket);
}

void FTCPClient::CloseClientConnection(TCPsocket Socket)
{
	OnClientDisconnectedCallback(Socket);

	ClientsSockets.erase(std::find(ClientsSockets.begin(), ClientsSockets.end(), Socket));
	SDLNet_TCP_DelSocket(SocketSet, Socket);

	SDLNet_TCP_Close(Socket);
}

void FTCPClient::CloseServerConnection() const
{
	if (ServerSocket)
	{
		SDLNet_TCP_DelSocket(SocketSet, ServerSocket);
		SDLNet_TCP_Close(ServerSocket);
	}
}

void FTCPClient::Update()
{
	SDLNet_CheckSockets(SocketSet, 0);

	for (TCPsocket ClientSocket : ClientsSockets)
	{
		if (SDLNet_SocketReady(ClientSocket))
		{
			const int ReceivedBufferLength = SDLNet_TCP_Recv(ClientSocket, &Buffer[0], static_cast<int>(Buffer.size()));
			if (ReceivedBufferLength > 0)
			{
				OnBufferReceivedCallback(ClientSocket, &Buffer[0], static_cast<size_t>(ReceivedBufferLength));
			}
			else
			{
				CloseClientConnection(ClientSocket);
			}
		}
	}
	if (SDLNet_SocketReady(ServerSocket))
	{
		OpenNewClientConnection();
	}
	
}

```

`EAC_SDK/Samples/AntiCheat/Server/Source/TCPClient.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#define WITHOUT_SDL
#include "SDL_net.h"

#include <vector>
#include <functional>

class FTCPClient final
{
public:
	/**
	 * No default constructor for this class
	 */
	FTCPClient() = delete;

	/**
	 * Constructor
	 */
	FTCPClient(int MaxSockets, size_t MaxBufferSizeBytes);

	/**
	 * No copying or copy assignment allowed for this class.
	 */
	FTCPClient(FTCPClient const&) = delete;
	FTCPClient& operator=(FTCPClient const&) = delete;

	/**
	 * Destructor
	 */
	virtual ~FTCPClient();

	void Open(uint16_t Port);
	void Send(void* To, const void* Data, size_t Length);

	using FOnBufferReceivedCallback = std::function<void(void*, char*, int)>;
	void SetOnBufferReceivedCallback(FOnBufferReceivedCallback Callback);

	using FOnClientDisconnectedCallback = std::function<void(void*)>;
	void SetOnClientDisconnectedCallback(FOnClientDisconnectedCallback Callback);

	void Update();

private:
	friend class FAntiCheatNetworkTransport;
	void OpenNewClientConnection();
	void CloseClientConnection(TCPsocket ClientSocket);

	void CloseServerConnection() const;

private:
	TCPsocket ServerSocket = nullptr;
	std::vector<TCPsocket> ClientsSockets;

	SDLNet_SocketSet SocketSet;

	std::vector<char> Buffer;

	FOnBufferReceivedCallback OnBufferReceivedCallback;
	FOnClientDisconnectedCallback OnClientDisconnectedCallback;
};


```

`EAC_SDK/Samples/AntiCheat/Server/Source/pch.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

```

`EAC_SDK/Samples/AntiCheat/Server/Source/pch.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <memory>
#include <mutex>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <fstream>
#include <cassert>
#include <future>
#include <iterator>
#include <queue>
#include <unordered_set>
#include <chrono>
#include <random>

#include <stdarg.h>

#ifdef _WIN32
#include <WinSDKVer.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0600
#endif
#include <SDKDDKVer.h>

// Use the C++ standard templated min/max
#define NOMINMAX

// DirectX apps don't need GDI
#define NODRAWTEXT
#define NOGDI
#define NOBITMAP

// Include <mcx.h> if you need this
#define NOMCX

// Include <winsvc.h> if you need this
#define NOSERVICE

// WinHelp is deprecated
#define NOHELP

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <wincodec.h>
#include <shellapi.h>
#endif //_WIN32

// Linux does not have _DEBUG in debug builds
#if !defined(NDEBUG) && !defined(_DEBUG)
#define _DEBUG
#endif

#if ALLOW_RESERVED_OPTIONS
#define DEV_BUILD
#endif

#ifndef _WIN32
typedef wchar_t WCHAR;
typedef wchar_t* LPWSTR, *PWSTR;
#define sprintf_s snprintf
#define __cdecl
#define wsprintf(BUF, FMT, ...) swprintf(BUF, sizeof(BUF)/sizeof(wchar_t), FMT, __VA_ARGS__)
#define OutputDebugStringW(STRING) wprintf(STRING)
#endif // !_WIN32

using uint16 = unsigned short;

class FEosSdk;
using FEosSdkPtr = std::shared_ptr<FEosSdk>;

using FScopedLock = std::lock_guard<std::mutex>;

using ServerTimePoint = std::chrono::time_point<std::chrono::steady_clock>;

// remove elements matching predicate, returns number of removed elements
template<class T, class A, class Predicate>
size_t erase_if(std::vector<T, A>& c, Predicate pred) {
	const size_t numBefore = c.size();
	c.erase(std::remove_if(c.begin(), c.end(), pred), c.end());
	return numBefore - c.size();
}
```

`EAC_SDK/Samples/AntiCheat/Server/cmake/FindSDL2.cmake`:

```cmake
# - Find SDL2
# Find the SDL2 headers and libraries
#
#  SDL2::SDL2 - Imported target to use for building a library
#  SDL2::SDL2main - Imported interface target to use if you want SDL and SDLmain.
#  SDL2_FOUND - True if SDL2 was found.
#  SDL2_DYNAMIC - If we found a DLL version of SDL (meaning you might want to copy a DLL from SDL2::SDL2)
#
# Original Author:
# 2015 Ryan Pavlik <ryan.pavlik@gmail.com> <abiryan@ryand.net>
#
# Copyright Sensics, Inc. 2015.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)

# Set up architectures (for windows) and prefixes (for mingw builds)
if(WIN32)
	if(MINGW)
		include(MinGWSearchPathExtras OPTIONAL)
		if(MINGWSEARCH_TARGET_TRIPLE)
			set(SDL2_PREFIX ${MINGWSEARCH_TARGET_TRIPLE})
		endif()
	endif()
	if(CMAKE_SIZEOF_VOID_P EQUAL 8)
		set(SDL2_LIB_PATH_SUFFIX lib/x64)
		if(NOT MSVC AND NOT SDL2_PREFIX)
			set(SDL2_PREFIX x86_64-w64-mingw32)
		endif()
	else()
		set(SDL2_LIB_PATH_SUFFIX lib/x86)
		if(NOT MSVC AND NOT SDL2_PREFIX)
			set(SDL2_PREFIX i686-w64-mingw32)
		endif()
	endif()
endif()

if(SDL2_PREFIX)
	set(SDL2_ORIGPREFIXPATH ${CMAKE_PREFIX_PATH})
	if(SDL2_ROOT_DIR)
		list(APPEND CMAKE_PREFIX_PATH "${SDL2_ROOT_DIR}")
	endif()
	if(CMAKE_PREFIX_PATH)
		foreach(_prefix ${CMAKE_PREFIX_PATH})
			list(APPEND CMAKE_PREFIX_PATH "${_prefix}/${SDL2_PREFIX}")
		endforeach()
	endif()
	if(MINGWSEARCH_PREFIXES)
		list(APPEND CMAKE_PREFIX_PATH ${MINGWSEARCH_PREFIXES})
	endif()
endif()

# Invoke pkgconfig for hints
find_package(PkgConfig QUIET)
set(SDL2_INCLUDE_HINTS)
set(SDL2_LIB_HINTS)
if(PKG_CONFIG_FOUND)
	pkg_search_module(SDL2PC QUIET sdl2)
	if(SDL2PC_INCLUDE_DIRS)
		set(SDL2_INCLUDE_HINTS ${SDL2PC_INCLUDE_DIRS})
	endif()
	if(SDL2PC_LIBRARY_DIRS)
		set(SDL2_LIB_HINTS ${SDL2PC_LIBRARY_DIRS})
	endif()
endif()

include(FindPackageHandleStandardArgs)

find_library(SDL2_LIBRARY
	NAMES
	SDL2
	HINTS
	${SDL2_LIB_HINTS}
	PATHS
	${SDL2_ROOT_DIR}
	ENV SDL2DIR
	PATH_SUFFIXES lib SDL2 ${SDL2_LIB_PATH_SUFFIX})

set(_sdl2_framework FALSE)
# Some special-casing if we've found/been given a framework.
# Handles whether we're given the library inside the framework or the framework itself.
if(APPLE AND "${SDL2_LIBRARY}" MATCHES "(/[^/]+)*.framework(/.*)?$")
	set(_sdl2_framework TRUE)
	set(SDL2_FRAMEWORK "${SDL2_LIBRARY}")
	# Move up in the directory tree as required to get the framework directory.
	while("${SDL2_FRAMEWORK}" MATCHES "(/[^/]+)*.framework(/.*)$" AND NOT "${SDL2_FRAMEWORK}" MATCHES "(/[^/]+)*.framework$")
		get_filename_component(SDL2_FRAMEWORK "${SDL2_FRAMEWORK}" DIRECTORY)
	endwhile()
	if("${SDL2_FRAMEWORK}" MATCHES "(/[^/]+)*.framework$")
		set(SDL2_FRAMEWORK_NAME ${CMAKE_MATCH_1})
		# If we found a framework, do a search for the header ahead of time that will be more likely to get the framework header.
		find_path(SDL2_INCLUDE_DIR
			NAMES
			SDL_haptic.h # this file was introduced with SDL2
			HINTS
			"${SDL2_FRAMEWORK}/Headers/")
	else()
		# For some reason we couldn't get the framework directory itself.
		# Shouldn't happen, but might if something is weird.
		unset(SDL2_FRAMEWORK)
	endif()
endif()

find_path(SDL2_INCLUDE_DIR
	NAMES
	SDL_haptic.h # this file was introduced with SDL2
	HINTS
	${SDL2_INCLUDE_HINTS}
	PATHS
	${SDL2_ROOT_DIR}
	ENV SDL2DIR
	PATH_SUFFIXES include include/sdl2 include/SDL2 SDL2)

if(WIN32 AND SDL2_LIBRARY)
	find_file(SDL2_RUNTIME_LIBRARY
		NAMES
		SDL2.dll
		libSDL2.dll
		HINTS
		${SDL2_LIB_HINTS}
		PATHS
		${SDL2_ROOT_DIR}
		ENV SDL2DIR
		PATH_SUFFIXES bin lib ${SDL2_LIB_PATH_SUFFIX})
endif()


if(WIN32 OR ANDROID OR IOS OR (APPLE AND NOT _sdl2_framework))
	set(SDL2_EXTRA_REQUIRED SDL2_SDLMAIN_LIBRARY)
	find_library(SDL2_SDLMAIN_LIBRARY
		NAMES
		SDL2main
		PATHS
		${SDL2_ROOT_DIR}
		ENV SDL2DIR
		PATH_SUFFIXES lib ${SDL2_LIB_PATH_SUFFIX})
endif()

if(MINGW AND NOT SDL2PC_FOUND)
	find_library(SDL2_MINGW_LIBRARY mingw32)
	find_library(SDL2_MWINDOWS_LIBRARY mwindows)
endif()

if(SDL2_PREFIX)
	# Restore things the way they used to be.
	set(CMAKE_PREFIX_PATH ${SDL2_ORIGPREFIXPATH})
endif()

# handle the QUIETLY and REQUIRED arguments and set QUATLIB_FOUND to TRUE if
# all listed variables are TRUE
include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(SDL2
	DEFAULT_MSG
	SDL2_LIBRARY
	SDL2_INCLUDE_DIR
	${SDL2_EXTRA_REQUIRED})

if(SDL2_FOUND)
	if(NOT TARGET SDL2::SDL2)
		# Create SDL2::SDL2
		if(WIN32 AND SDL2_RUNTIME_LIBRARY)
			set(SDL2_DYNAMIC TRUE)
			add_library(SDL2::SDL2 SHARED IMPORTED)
			set_target_properties(SDL2::SDL2
				PROPERTIES
				IMPORTED_IMPLIB "${SDL2_LIBRARY}"
				IMPORTED_LOCATION "${SDL2_RUNTIME_LIBRARY}"
				INTERFACE_INCLUDE_DIRECTORIES "${SDL2_INCLUDE_DIR}"
			)
		else()
			add_library(SDL2::SDL2 UNKNOWN IMPORTED)
			if(SDL2_FRAMEWORK AND SDL2_FRAMEWORK_NAME)
				# Handle the case that SDL2 is a framework and we were able to decompose it above.
				set_target_properties(SDL2::SDL2 PROPERTIES
					IMPORTED_LOCATION "${SDL2_FRAMEWORK}/${SDL2_FRAMEWORK_NAME}")
			elseif(_sdl2_framework AND SDL2_LIBRARY MATCHES "(/[^/]+)*.framework$")
				# Handle the case that SDL2 is a framework and SDL_LIBRARY is just the framework itself.

				# This takes the basename of the framework, without the extension,
				# and sets it (as a child of the framework) as the imported location for the target.
				# This is the library symlink inside of the framework.
				set_target_properties(SDL2::SDL2 PROPERTIES
					IMPORTED_LOCATION "${SDL2_LIBRARY}/${CMAKE_MATCH_1}")
			else()
				# Handle non-frameworks (including non-Mac), as well as the case that we're given the library inside of the framework
				set_target_properties(SDL2::SDL2 PROPERTIES
					IMPORTED_LOCATION "${SDL2_LIBRARY}")
			endif()
			set_target_properties(SDL2::SDL2
				PROPERTIES
				INTERFACE_INCLUDE_DIRECTORIES "${SDL2_INCLUDE_DIR}"
			)
		endif()

		if(APPLE)
			# Need Cocoa here, is always a framework
			find_library(SDL2_COCOA_LIBRARY Cocoa)
			list(APPEND SDL2_EXTRA_REQUIRED SDL2_COCOA_LIBRARY)
			if(SDL2_COCOA_LIBRARY)
				set_target_properties(SDL2::SDL2 PROPERTIES
						IMPORTED_LINK_INTERFACE_LIBRARIES ${SDL2_COCOA_LIBRARY})
			endif()
		endif()


		# Compute what to do with SDL2main
		set(SDL2MAIN_LIBRARIES SDL2::SDL2)
		add_library(SDL2::SDL2main INTERFACE IMPORTED)
		if(SDL2_SDLMAIN_LIBRARY)
			add_library(SDL2::SDL2main_real STATIC IMPORTED)
			set_target_properties(SDL2::SDL2main_real
				PROPERTIES
				IMPORTED_LOCATION "${SDL2_SDLMAIN_LIBRARY}")
			set(SDL2MAIN_LIBRARIES SDL2::SDL2main_real ${SDL2MAIN_LIBRARIES})
		endif()
		if(MINGW)
			# MinGW requires some additional libraries to appear earlier in the link line.
			if(SDL2PC_LIBRARIES)
				# Use pkgconfig-suggested extra libraries if available.
				list(REMOVE_ITEM SDL2PC_LIBRARIES SDL2main SDL2)
				set(SDL2MAIN_LIBRARIES ${SDL2PC_LIBRARIES} ${SDL2MAIN_LIBRARIES})
			else()
				# fall back to extra libraries specified in pkg-config in
				# an official binary distro of SDL2 for MinGW I downloaded
				if(SDL2_MINGW_LIBRARY)
					set(SDL2MAIN_LIBRARIES ${SDL2_MINGW_LIBRARY} ${SDL2MAIN_LIBRARIES})
				endif()
				if(SDL2_MWINDOWS_LIBRARY)
					set(SDL2MAIN_LIBRARIES ${SDL2_MWINDOWS_LIBRARY} ${SDL2MAIN_LIBRARIES})
				endif()
			endif()
			set_target_properties(SDL2::SDL2main
				PROPERTIES
				INTERFACE_COMPILE_DEFINITIONS "main=SDL_main")
		endif()
		set_target_properties(SDL2::SDL2main
			PROPERTIES
			INTERFACE_LINK_LIBRARIES "${SDL2MAIN_LIBRARIES}")
	endif()
	mark_as_advanced(SDL2_ROOT_DIR)
endif()

mark_as_advanced(SDL2_LIBRARY
	SDL2_RUNTIME_LIBRARY
	SDL2_INCLUDE_DIR
	SDL2_SDLMAIN_LIBRARY
	SDL2_COCOA_LIBRARY
	SDL2_MINGW_LIBRARY
	SDL2_MWINDOWS_LIBRARY)
```

`EAC_SDK/Samples/AntiCheat/Server/cmake/FindSDL2NET.cmake`:

```cmake
FIND_PATH(SDL2NET_INCLUDE_DIR SDL_net.h
  HINTS
  $ENV{SDL2NETDIR}
  PATH_SUFFIXES include/SDL2 include
  PATHS
  ~/Library/Frameworks
  /Library/Frameworks
  /usr/local/include/SDL2
  /usr/include/SDL2
  /sw 
  /opt/local
  /opt/csw
  /opt
)

FIND_LIBRARY(SDL2NET_LIBRARY
  NAMES SDL2_net
  HINTS
  $ENV{SDL2NETDIR}
  /usr/lib
  /usr/lib64
  PATH_SUFFIXES lib64 lib
  PATHS
  /sw
  /opt/local
  /opt/csw
  /opt
)

INCLUDE(FindPackageHandleStandardArgs)

FIND_PACKAGE_HANDLE_STANDARD_ARGS(SDL2NET REQUIRED_VARS SDL2NET_LIBRARY SDL2NET_INCLUDE_DIR)
```

`EAC_SDK/Samples/AuthAndFriends/AuthAndFriends.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Steam_Debug_SDL|Win32">
      <Configuration>Steam_Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Steam_Debug_SDL|x64">
      <Configuration>Steam_Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Steam_Debug_DX|Win32">
      <Configuration>Steam_Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Steam_Debug_DX|x64">
      <Configuration>Steam_Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Steam_Release_SDL|Win32">
      <Configuration>Steam_Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Steam_Release_SDL|x64">
      <Configuration>Steam_Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Steam_Release_DX|Win32">
      <Configuration>Steam_Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Steam_Release_DX|x64">
      <Configuration>Steam_Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>AuthAndFriends</RootNamespace>
    <ProjectGuid>{4C365618-2FAB-4A1D-8574-AEBA7CF96907}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>AuthAndFriends</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";EOS_STEAM_ENABLED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes);$(EOSSDKIncludes);$(SteamSDK)/public</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;steam_api.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);$(SteamSDK)/redistributable_bin;$(SteamSDK)/public/steam/lib/win32;$(SteamSDK)/redistributable_bin;$(SteamSDK)/public/steam/lib/win32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(SteamSDK)\redistributable_bin\steam_api.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q steam_appid.txt $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";EOS_STEAM_ENABLED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes);$(SteamSDK)/public</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;steam_api.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;$(SteamSDK)/redistributable_bin;$(SteamSDK)/public/steam/lib/win32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(SteamSDK)\redistributable_bin\steam_api.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q steam_appid.txt $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";EOS_STEAM_ENABLED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes);$(SteamSDK)/public</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;steam_api64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);$(SteamSDK)/redistributable_bin/win64;$(SteamSDK)/public/steam/lib/win64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(SteamSDK)\redistributable_bin\win64\steam_api64.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q steam_appid.txt $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";EOS_STEAM_ENABLED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes);$(SteamSDK)/public</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;steam_api64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;$(SteamSDK)/redistributable_bin/win64;$(SteamSDK)/public/steam/lib/win64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(SteamSDK)\redistributable_bin\win64\steam_api64.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q steam_appid.txt $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";EOS_STEAM_ENABLED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes);$(SteamSDK)/public</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;steam_api.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);$(SteamSDK)/redistributable_bin;$(SteamSDK)/public/steam/lib/win32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(SteamSDK)\redistributable_bin\steam_api.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q steam_appid.txt $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";EOS_STEAM_ENABLED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes);$(SteamSDK)/public</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;steam_api.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;$(SteamSDK)/redistributable_bin;$(SteamSDK)/public/steam/lib/win32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(SteamSDK)\redistributable_bin\steam_api.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q steam_appid.txt $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";EOS_STEAM_ENABLED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes);$(SteamSDK)/public</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;steam_api64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);$(SteamSDK)/redistributable_bin/win64;$(SteamSDK)/public/steam/lib/win64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(SteamSDK)\redistributable_bin\win64\steam_api64.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q steam_appid.txt $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";EOS_STEAM_ENABLED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/AuthAndFriends/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes);$(SteamSDK)/public</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;steam_api64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;$(SteamSDK)/redistributable_bin/win64;$(SteamSDK)/public/steam/lib/win64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(SteamSDK)\redistributable_bin\win64\steam_api64.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q steam_appid.txt $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\..\SDK\Public\eos_custominvites.h" />
    <ClInclude Include="..\..\SDK\Public\eos_custominvites_types.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\DropDownList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Steam\SteamManager.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\CustomInviteReceivedDialog.h" />
    <ClInclude Include="Source\CustomInvites.h" />
    <ClInclude Include="Source\CustomInvitesDialog.h" />
    <ClInclude Include="Source\CustomInviteSendDialog.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\SampleConstants.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\DropDownList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Steam_Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Steam_Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Steam_Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Steam\SteamManager.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\CustomInviteReceivedDialog.cpp" />
    <ClCompile Include="Source\CustomInvites.cpp" />
    <ClCompile Include="Source\CustomInvitesDialog.cpp" />
    <ClCompile Include="Source\CustomInviteSendDialog.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/AuthAndFriends/AuthAndFriends.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Steam\SteamManager.h">
      <Filter>SharedSource\Steam</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Public\eos_custominvites.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Public\eos_custominvites_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\CustomInviteReceivedDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\CustomInvites.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\CustomInvitesDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\CustomInviteSendDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\DropDownList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Steam">
      <UniqueIdentifier>{5a13139b-bd19-4dff-8399-6d964d47a2f9}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Steam\SteamManager.cpp">
      <Filter>SharedSource\Steam</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="Source\CustomInviteReceivedDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\CustomInvites.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\CustomInvitesDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\CustomInviteSendDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\DropDownList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/AuthAndFriends/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/AuthAndFriends/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/AuthAndFriends/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/AuthAndFriends/Source/CustomInviteReceivedDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "Sprite.h"
#include "TextLabel.h"
#include "Checkbox.h"
#include "Button.h"
#include "CustomInviteReceivedDialog.h"
#include "StringUtils.h"
#include "TextEditor.h"
#include "GameEvent.h"

FCustomInviteReceivedDialog::FCustomInviteReceivedDialog(Vector2 InPos,
						 Vector2 InSize,
						 UILayer InLayer,
						 FontPtr InNormalFont,
						 FontPtr InSmallFont) :
	FDialog(InPos, InSize, InLayer)
{
	Vector2 DummyVector{};
	Background = std::make_shared<FSpriteWidget>(
		DummyVector,
		DummyVector,
		InLayer,
		L"",
		Color::Black);
	AddWidget(Background);

	FromNameLabel = std::make_shared<FTextLabelWidget>(
		DummyVector,
		DummyVector,
		InLayer - 1,
		L"Custom Invite received from: ",
		L"");
	FromNameLabel->SetFont(InNormalFont);
	AddWidget(FromNameLabel);

	FromNameValue = std::make_shared<FTextLabelWidget>(
		DummyVector,
		DummyVector,
		InLayer - 1,
		L"xxxxxxxx",
		L"");
	FromNameValue->SetFont(InNormalFont);
	AddWidget(FromNameValue);

	PayloadLabel = std::make_shared<FTextLabelWidget>(
		DummyVector,
		DummyVector,
		InLayer - 1,
		L"Payload Contents:",
		L"");
	PayloadLabel->SetFont(InNormalFont);
	AddWidget(PayloadLabel);

	PayloadValue = std::make_shared<FTextEditorWidget>(
		DummyVector,
		DummyVector,
		InLayer - 1,
		L"yyyyyyy",
		L"Assets/textfield.dds",
		InNormalFont,
		FColor(0.5f, 0.5f, 0.5f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f)
		);
	PayloadValue->SetEditingEnabled(false);
	AddWidget(PayloadValue);

	AcceptInviteButton = std::make_shared<FButtonWidget>(
		DummyVector,
		DummyVector,
		InLayer - 1,
		L"Accept",
		assets::DefaultButtonAssets,
		InSmallFont,
		Color::UIButtonBlue);
	AcceptInviteButton->SetOnPressedCallback([this]()
	{
		Hide();
		FGame::Get().GetCustomInvites()->AcceptLatestInvite();
	});
	AcceptInviteButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(AcceptInviteButton);

	DeclineInviteButton = std::make_shared<FButtonWidget>(
		DummyVector,
		DummyVector,
		InLayer - 1,
		L"Decline",
		assets::DefaultButtonAssets,
		InSmallFont,
		Color::UIButtonBlue);
	DeclineInviteButton->SetOnPressedCallback([this]()
	{
		Hide();
		FGame::Get().GetCustomInvites()->RejectLatestInvite();
	});
	DeclineInviteButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(DeclineInviteButton);
}

void FCustomInviteReceivedDialog::SetPosition(Vector2 NewPosition)
{
 	IWidget::SetPosition(NewPosition);

	Background->SetPosition(NewPosition);
	FromNameLabel->SetPosition(Vector2(NewPosition.x, NewPosition.y + 25.0f));
	FromNameValue->SetPosition(Vector2(FromNameLabel->GetPosition().x + 250.f, FromNameLabel->GetPosition().y));
	PayloadLabel->SetPosition(Vector2(FromNameLabel->GetPosition().x, FromNameLabel->GetPosition().y + FromNameLabel->GetSize().y));
	PayloadValue->SetPosition(Vector2(FromNameLabel->GetPosition().x + 250.f, PayloadLabel->GetPosition().y));
	AcceptInviteButton->SetPosition(Vector2(FromNameLabel->GetPosition().x + 5.f, PayloadValue->GetPosition().y + PayloadValue->GetSize().y - 5.f));
	DeclineInviteButton->SetPosition(Vector2(AcceptInviteButton->GetPosition().x + AcceptInviteButton->GetSize().x + 10.f, AcceptInviteButton->GetPosition().y));
}

void FCustomInviteReceivedDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	Background->SetSize(NewSize);
	FromNameLabel->SetSize(Vector2(150.f, 25.f));
	FromNameValue->SetSize(Vector2(150.f, 25.f));
	PayloadLabel->SetSize(Vector2(150.f, 25.f));
	PayloadValue->SetSize(Vector2(300.f, 80.f));
	AcceptInviteButton->SetSize(Vector2(100.f, 30.f));
	DeclineInviteButton->SetSize(Vector2(100.f, 30.f));
}

void FCustomInviteReceivedDialog::OnEscapePressed()
{
	FGame::Get().GetCustomInvites()->RejectLatestInvite();
	Hide();
}

void FCustomInviteReceivedDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::CustomInviteReceived)
	{
		FromNameValue->SetText(FGame::Get().GetCustomInvites()->LatestReceivedFromId.ToString());
		PayloadValue->SetText(FGame::Get().GetCustomInvites()->LatestReceivedPayload);
	}
	else if (Event.GetType() == EGameEventType::CustomInviteDeclined)
	{
		FromNameValue->ClearText();
		PayloadValue->Clear();
	}
}

```

`EAC_SDK/Samples/AuthAndFriends/Source/CustomInviteReceivedDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FCheckboxWidget;
class FButtonWidget;
class FTextEditorWidget;

/**
 * Lobby Invite Received dialog (simple popup to accept or decline the invitation)
 */
class FCustomInviteReceivedDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FCustomInviteReceivedDialog(Vector2 InPos,
		Vector2 InSize,
		UILayer InLayer,
		FontPtr InNormalFont,
		FontPtr InSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FCustomInviteReceivedDialog() {}

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 Pos) override;
	virtual void OnEscapePressed() override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

private:

	/** The name of friend who invited to lobby. */
	std::wstring FriendName;

	/** InviteId for the custom invite to accept/reject */
	std::string CustomInvite;

	/** Background */
	WidgetPtr Background;

	/** "From" */
	std::shared_ptr<FTextLabelWidget> FromNameLabel;

	/** From */
	std::shared_ptr<FTextLabelWidget> FromNameValue;

	/** "Payload" */
	std::shared_ptr<FTextLabelWidget> PayloadLabel;

	/** Actual payload */
	std::shared_ptr<FTextEditorWidget> PayloadValue;

	/** Accept invite button */
	std::shared_ptr<FButtonWidget> AcceptInviteButton;

	/** Decline invite button */
	std::shared_ptr<FButtonWidget> DeclineInviteButton;
};

```

`EAC_SDK/Samples/AuthAndFriends/Source/CustomInviteSendDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "Sprite.h"
#include "TextLabel.h"
#include "Button.h"
#include "StringUtils.h"
#include "CustomInviteSendDialog.h"
#include "TextEditor.h"
#include "DropDownList.h"

#define CUSTOMINVITE_DIALOG_PAYLOAD_LABEL_WIDTH		250.f
#define CUSTOMINVITE_DIALOG_PAYLOAD_TEXT_WIDTH		150.f
#define CUSTOMINVITE_DIALOG_PAYLOAD_TEXT_HEIGHT		75.f
#define CUSTOMINVITE_DIALOG_PAYLOAD_TEXTENTRY_WIDTH 150.f
#define CUSTOMINVITE_DIALOG_PAYLOAD_TEXTENTRY_HEIGHT 75.f
#define CUSTOMINVITE_DIALOG_SETPAYLOAD_BUTTON_WIDTH  100.f
#define CUSTOMINVITE_DIALOG_SETPAYLOAD_BUTTON_HEIGHT 30.f
#define CUSTOMINVITE_DIALOG_FRIENDLIST_LIST_WIDTH    300.f
#define CUSTOMINVITE_DIALOG_FRIENDLIST_LIST_HEIGHT   40.f
#define CUSTOMINVITE_DIALOG_FRIENDLIST_LIST_MAXHEIGHT  200.f

FCustomInviteSendDialog::FCustomInviteSendDialog(Vector2 InPos,
						 Vector2 InSize,
						 UILayer InLayer,
						 FontPtr InNormalFont,
						 FontPtr InSmallFont) :
	FDialog(InPos, InSize, InLayer)
{
	Vector2 DummyVector{};  // the position / size values are irrelevant in constructor

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DummyVector,
		DummyVector,
		InLayer,
		L"");
	AddWidget(BackgroundImage);

	// "Current Payload:"
	CurrentPayloadLabel = std::make_shared<FTextLabelWidget>(
		DummyVector,
		DummyVector,
		InLayer,
		L"Current Custom Invite Payload",
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	CurrentPayloadLabel->SetFont(InNormalFont);
	AddWidget(CurrentPayloadLabel);

	PayloadTextEditor = std::make_shared<FTextEditorWidget>(
		DummyVector,
		DummyVector,
		InLayer,
		L"Enter custom invite payload...",
		L"Assets/textfield.dds",
		InSmallFont,
		FColor(0.5f, 0.5f, 0.5f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f)
		);
	PayloadTextEditor->SetBorderColor(Color::UIBorderGrey);
	PayloadTextEditor->SetBorderOffsets(Vector2(4.f, 4.f));
	AddWidget(PayloadTextEditor);

	SetPayloadButton = std::make_shared<FButtonWidget>(
		DummyVector,
		DummyVector,
		InLayer,
		L"Set Payload >>",
		assets::DefaultButtonAssets,
		InSmallFont,
		Color::UIButtonBlue,
		FColor(1.f, 1.f, 1.f, 1.f));
	SetPayloadButton->SetOnPressedCallback([this]()
	{
		SetOutgoingCustomInvitePayload(PayloadTextEditor->GetText());
	});
	AddWidget(SetPayloadButton);
	SetPayloadButton->Disable();

	// <current payload value>
	CurrentPayloadText = std::make_shared<FTextEditorWidget>(
		DummyVector,
		DummyVector,
		InLayer,
		L"",
		L"",
		InSmallFont,
		FColor(1.f, 1.f, 1.f, 1.f),
		Color::LawnGreen);
	CurrentPayloadText->SetBorderColor(Color::UIBorderGrey);
	CurrentPayloadText->SetEditingEnabled(false);
	CurrentPayloadText->SetBorderOffsets(Vector2(4.f, 4.f));
	AddWidget(CurrentPayloadText);

	InviteTargetDropdown = std::make_shared<FDropDownList>(
		DummyVector,
		DummyVector,
		Vector2(CUSTOMINVITE_DIALOG_FRIENDLIST_LIST_WIDTH, CUSTOMINVITE_DIALOG_FRIENDLIST_LIST_MAXHEIGHT),  // can't be dummy, currently there is no mutator
		InLayer,
		L"Target Friend: ",
		std::vector<std::wstring>({ L"No Friends", }),
		InNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	AddWidget(InviteTargetDropdown);

	SendInviteButton = std::make_shared<FButtonWidget>(
		DummyVector,
		DummyVector,
		InLayer,
		L"Send Invite",
		assets::DefaultButtonAssets,
		InSmallFont,
		Color::UIButtonBlue,
		FColor(1.f, 1.f, 1.f, 1.f));
	SendInviteButton->SetOnPressedCallback([this]()
	{
		SendPayloadToFriend(InviteTargetDropdown->GetCurrentSelection());
	});
	AddWidget(SendInviteButton);
	SendInviteButton->Disable();
}

void FCustomInviteSendDialog::Create()
{
	FDialog::Create();

	// set up an initial payload
	const std::string InitialPayload = "A1B2C3D4E5";
	const std::wstring WideInitialPayload = FStringUtils::Widen(std::move(InitialPayload));
	SetOutgoingCustomInvitePayload(WideInitialPayload);

	RebuildFriendsList(FGame::Get().GetFriends()->GetFriends());
	FGame::Get().GetFriends()->SubscribeToFriendStatusUpdates(this, [this](const std::vector<FFriendData>& Friends)
	{
		RebuildFriendsList(Friends);
	});
}

void FCustomInviteSendDialog::Release()
{
	FDialog::Release();

	FGame::Get().GetFriends()->UnsubscribeToFriendStatusUpdates(this);
}

void FCustomInviteSendDialog::OnUIEvent(const FUIEvent& Event)
{
	FDialog::OnUIEvent(Event);
}

void FCustomInviteSendDialog::Update()
{
	FDialog::Update();

	// Do we need to refresh data?
	uint64_t NewFriendsDirtyCounter = FGame::Get().GetFriends()->GetDirtyCounter();
	if (NewFriendsDirtyCounter != FriendsDirtyCounter)
	{
		const std::vector<FFriendData>& Friends = FGame::Get().GetFriends()->GetFriends();
		RebuildFriendsList(Friends);
	}

	// Enable / disable set payload button based on current payload text
	if (PayloadTextEditor)
	{
		std::wstring TextValue = PayloadTextEditor->GetText();
		if (TextValue.empty() || TextValue == PayloadTextEditor->GetInitialText())
		{
			SetPayloadButton->Disable();
		}
		else
		{
			SetPayloadButton->Enable();
		}
	}
}


void FCustomInviteSendDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (BackgroundImage && CurrentPayloadLabel && CurrentPayloadText && PayloadTextEditor && SetPayloadButton)
	{
		BackgroundImage->SetPosition(Vector2(Pos.x - 20.f, Pos.y));

		CurrentPayloadLabel->SetPosition(Vector2(Pos.x + 5.f, Pos.y + 5.f));

		PayloadTextEditor->SetPosition(Vector2(CurrentPayloadLabel->GetPosition().x,
										CurrentPayloadLabel->GetPosition().y + CurrentPayloadLabel->GetSize().y));

		SetPayloadButton->SetPosition(Vector2(PayloadTextEditor->GetPosition().x + PayloadTextEditor->GetSize().x,
												PayloadTextEditor->GetPosition().y + (PayloadTextEditor->GetSize().y - SetPayloadButton->GetSize().y) / 2.f));

		CurrentPayloadText->SetPosition(Vector2(SetPayloadButton->GetPosition().x + SetPayloadButton->GetSize().x + 5.f,
												PayloadTextEditor->GetPosition().y));

		InviteTargetDropdown->SetPosition(Vector2(CurrentPayloadText->GetPosition().x + CurrentPayloadText->GetSize().x + 5.f,
													CurrentPayloadText->GetPosition().y + (CurrentPayloadText->GetSize().y - InviteTargetDropdown->GetSize().y) / 2.f));

		SendInviteButton->SetPosition(Vector2(Pos.x + 5.f, CurrentPayloadText->GetPosition().y + CurrentPayloadText->GetSize().y + 5.f));
	}
}

void FCustomInviteSendDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (BackgroundImage && CurrentPayloadLabel && CurrentPayloadText && PayloadTextEditor && SetPayloadButton && InviteTargetDropdown)
	{
		BackgroundImage->SetSize(Vector2(NewSize.x + 35.f, NewSize.y));
		CurrentPayloadLabel->SetSize(Vector2(CUSTOMINVITE_DIALOG_PAYLOAD_LABEL_WIDTH, 30.f));
		CurrentPayloadText->SetSize(Vector2(CUSTOMINVITE_DIALOG_PAYLOAD_TEXT_WIDTH, CUSTOMINVITE_DIALOG_PAYLOAD_TEXT_HEIGHT));
		PayloadTextEditor->SetSize(Vector2(CUSTOMINVITE_DIALOG_PAYLOAD_TEXTENTRY_WIDTH, CUSTOMINVITE_DIALOG_PAYLOAD_TEXTENTRY_HEIGHT));
		SetPayloadButton->SetSize(Vector2(CUSTOMINVITE_DIALOG_SETPAYLOAD_BUTTON_WIDTH, CUSTOMINVITE_DIALOG_SETPAYLOAD_BUTTON_HEIGHT));
		SendInviteButton->SetSize(Vector2(CUSTOMINVITE_DIALOG_SETPAYLOAD_BUTTON_WIDTH, CUSTOMINVITE_DIALOG_SETPAYLOAD_BUTTON_HEIGHT));
		InviteTargetDropdown->SetSize(Vector2(CUSTOMINVITE_DIALOG_FRIENDLIST_LIST_WIDTH, CUSTOMINVITE_DIALOG_FRIENDLIST_LIST_HEIGHT));
	}
}

void FCustomInviteSendDialog::OnEscapePressed()
{
	Hide();
}

EOS_EResult FCustomInviteSendDialog::SetOutgoingCustomInvitePayload(const std::wstring& Payload)
{
	EOS_EResult Result = FGame::Get().GetCustomInvites()->SetCurrentPayload(Payload);
	if (Result == EOS_EResult::EOS_Success)
	{
		if (CurrentPayloadText)
		{
			CurrentPayloadText->Clear();
			CurrentPayloadText->AddLine(std::move(Payload), Color::LawnGreen);
		}

		if (SendInviteButton)
		{
			SendInviteButton->Enable();
		}
	}

	return Result;
}

void FCustomInviteSendDialog::SendPayloadToFriend(const std::wstring& FriendName)
{
	FGame::Get().GetCustomInvites()->SendInviteToFriend(FriendName);
}

void FCustomInviteSendDialog::RebuildFriendsList(const std::vector<FFriendData>& Friends)
{
	std::vector<std::wstring> FriendNames;
	std::vector<EOS_ProductUserId> Puids;
	std::transform(Friends.begin(), Friends.end(), std::back_inserter(FriendNames),
		[](const FFriendData& Friend) -> std::wstring { return Friend.Name; });

	InviteTargetDropdown->UpdateOptionsList(FriendNames);

	FriendsDirtyCounter = FGame::Get().GetFriends()->GetDirtyCounter();
}


```

`EAC_SDK/Samples/AuthAndFriends/Source/CustomInviteSendDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "Friends.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FButtonWidget;
class FTextEditorWidget;
class FDropDownList;
class FSpriteWidget;

/**
 * Custom Invite Send dialog (simple popup to set payload or send invitation)
 */
class FCustomInviteSendDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FCustomInviteSendDialog(Vector2 InPos,
		Vector2 InSize,
		UILayer InLayer,
		FontPtr InNormalFont,
		FontPtr InSmallFont);

	/** FDialog */
	virtual void Create() override;
	virtual void Update() override;
	virtual void Release() override;
	virtual void OnUIEvent(const FUIEvent& Event) override;


	/**
	 * Destructor
	 */
	virtual ~FCustomInviteSendDialog() {}

	/** IWidget */
	virtual void SetSize(Vector2 NewSize) override;
	virtual void SetPosition(Vector2 Pos) override;
	virtual void OnEscapePressed() override;

	void SendInviteToFriend(const std::wstring& FriendName);
	void SendInviteToFriend(FProductUserId FriendId);

	void HandleFriendStatusUpdated(const std::vector<FFriendData>& Friends);

	void RebuildFriendsList(const std::vector<FFriendData>& Friends);

	/* Set the current payload for outgoing custom invites */
	EOS_EResult SetOutgoingCustomInvitePayload(const std::wstring& Payload);

	/* Send the current payload to a specific user (by name) */
	void SendPayloadToFriend(const std::wstring& FriendName);

private:
	/** Synchronized to the FFriends Dirty Counter, if numbers are different an update has occurred */
	uint64_t FriendsDirtyCounter = 0;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Current Payload label */
	std::shared_ptr<FTextLabelWidget> CurrentPayloadLabel;

	/** Current Payload text */
	std::shared_ptr<FTextEditorWidget> CurrentPayloadText;

	/** Current Payload display/edit field */
	std::shared_ptr<FTextEditorWidget> PayloadTextEditor;

	/** Set Payload button */
	std::shared_ptr<FButtonWidget> SetPayloadButton;

	/** Search by level name input */
	std::shared_ptr<FTextLabelWidget> SendInviteLabel;

	/** Drop-down list of invite targets */
	std::shared_ptr<FDropDownList> InviteTargetDropdown;

	/** Send Invite button */
	std::shared_ptr<FButtonWidget> SendInviteButton;
};

```

`EAC_SDK/Samples/AuthAndFriends/Source/CustomInvites.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Game.h"
#include "GameEvent.h"
#include "Player.h"
#include "Platform.h"
#include "eos_friends.h"
#include "eos_custominvites.h"
#include "eos_presence.h"
#include <string>
#include "Users.h"
#include "eos_custominvites.h"
#include "eos_custominvites_types.h"


FCustomInvites::FCustomInvites() noexcept(false)
{
	CurrentUserId = FEpicAccountId();
}


FCustomInvites::~FCustomInvites()
{

}

void FCustomInvites::OnLoggedIn(FEpicAccountId UserId)
{
	if (!CurrentUserId.IsValid())
	{
		SetCurrentUser(UserId);

		EOS_HCustomInvites CustomInvitesHandle = EOS_Platform_GetCustomInvitesInterface(FPlatform::GetPlatformHandle());

		// subscribe to notifications for when we receive a custom invite
		EOS_CustomInvites_AddNotifyCustomInviteReceivedOptions AddNotifyInviteReceivedOptions = {};
		AddNotifyInviteReceivedOptions.ApiVersion = EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITERECEIVED_API_LATEST;
		EOS_CustomInvites_AddNotifyCustomInviteReceived(CustomInvitesHandle, &AddNotifyInviteReceivedOptions, nullptr, StaticOnNotifyCustomInviteReceived);
		
		// subscribe to notifications for when we accept a custom invite externally (e.g. via the Overlay)
		EOS_CustomInvites_AddNotifyCustomInviteAcceptedOptions AddNotifyInviteAcceptedOptions = {};
		AddNotifyInviteAcceptedOptions.ApiVersion = EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEACCEPTED_API_LATEST;
		EOS_CustomInvites_AddNotifyCustomInviteAccepted(CustomInvitesHandle, &AddNotifyInviteAcceptedOptions, nullptr, StaticOnNotifyCustomInviteAccepted);

		// subscribe to notifications for when we reject a custom invite externally (e.g. via the Overlay)
		EOS_CustomInvites_AddNotifyCustomInviteRejectedOptions AddNotifyInviteRejectedOptions = {};
		AddNotifyInviteRejectedOptions.ApiVersion = EOS_CUSTOMINVITES_ADDNOTIFYCUSTOMINVITEREJECTED_API_LATEST;
		EOS_CustomInvites_AddNotifyCustomInviteRejected(CustomInvitesHandle, &AddNotifyInviteRejectedOptions, nullptr, StaticOnNotifyCustomInviteRejected);
	}
}

void FCustomInvites::OnConnectLoggedIn(FProductUserId ProductUserId)
{
	if (!CurrentProductUserId.IsValid())
	{
		CurrentProductUserId = ProductUserId;
	}
}

void FCustomInvites::OnLoggedOut(FEpicAccountId UserId)
{
	if (FPlayerManager::Get().GetNumPlayers() > 0)
	{
		if (GetCurrentUser() == UserId)
		{
			FGameEvent Event(EGameEventType::ShowNextUser);
			OnGameEvent(Event);
		}
	}
	else
	{
		SetCurrentUser(FEpicAccountId());
		CurrentProductUserId = FProductUserId();
	}
}

void FCustomInvites::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedOut(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		OnConnectLoggedIn(Event.GetProductUserId());
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		if (FPlayerManager::Get().GetNumPlayers() > 0)
		{
			FEpicAccountId PrevPlayerId = FPlayerManager::Get().GetPrevPlayerId(GetCurrentUser());
			if (PrevPlayerId.IsValid())
			{
				SetCurrentUser(PrevPlayerId);
			}
			else
			{
				SetCurrentUser(FEpicAccountId());
			}
		}
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		if (FPlayerManager::Get().GetNumPlayers() > 0)
		{
			FEpicAccountId NextPlayerId = FPlayerManager::Get().GetNextPlayerId(GetCurrentUser());
			if (NextPlayerId.IsValid())
			{
				SetCurrentUser(NextPlayerId);
			}
			else
			{
				SetCurrentUser(FEpicAccountId());
			}
		}
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
	}
}

void FCustomInvites::SetCurrentUser(FEpicAccountId UserId)
{
	CurrentUserId = UserId;

	if (CurrentUserId.IsValid())
	{
		PlayerPtr CurrentPlayer = FPlayerManager::Get().GetPlayer(CurrentUserId);
		if (CurrentPlayer)
		{
			CurrentProductUserId = CurrentPlayer->GetProductUserID();
		}
		else
		{
			CurrentProductUserId = FProductUserId();
		}
	}
	else
	{
		CurrentProductUserId = FProductUserId();
	}
}

void FCustomInvites::FinalizeInvite(EOS_EResult Result)
{
	EOS_HCustomInvites CustomInvitesHandle = EOS_Platform_GetCustomInvitesInterface(FPlatform::GetPlatformHandle());

	// Notify the SDK that this invite has been fully processed and can be removed from internal lists and the Overlay UI
	EOS_CustomInvites_FinalizeInviteOptions FinalizeOptions = {};
	FinalizeOptions.ApiVersion = EOS_CUSTOMINVITES_FINALIZEINVITE_API_LATEST;
	FinalizeOptions.LocalUserId = CurrentProductUserId;
	FinalizeOptions.TargetUserId = LatestReceivedFromId;
	std::string InviteId = FStringUtils::Narrow(LatestReceivedInviteId);
	FinalizeOptions.CustomInviteId = InviteId.c_str();
	FinalizeOptions.ProcessingResult = Result;
	EOS_CustomInvites_FinalizeInvite(CustomInvitesHandle, &FinalizeOptions);
}

void FCustomInvites::AcceptLatestInvite()
{
	FinalizeInvite(EOS_EResult::EOS_Success);

	LatestReceivedFromId = nullptr;
	LatestReceivedInviteId.clear();
	LatestReceivedPayload.clear();

	FGameEvent GameEvent(EGameEventType::CustomInviteAccepted);
	FGame::Get().OnGameEvent(GameEvent);
}

void FCustomInvites::RejectLatestInvite()
{
	FinalizeInvite(EOS_EResult::EOS_Success);

	LatestReceivedFromId = nullptr;
	LatestReceivedInviteId.clear();
	LatestReceivedPayload.clear();

	FGameEvent GameEvent(EGameEventType::CustomInviteDeclined);
	FGame::Get().OnGameEvent(GameEvent);
}

void EOS_CALL FCustomInvites::StaticOnNotifyCustomInviteReceived(const EOS_CustomInvites_OnCustomInviteReceivedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"CustomInvites (OnNotifyCustomInviteReceived): invite received.");
		FGame::Get().GetCustomInvites()->HandleCustomInviteReceived(Data->Payload, Data->CustomInviteId, Data->TargetUserId);
	}
	else
	{
		FDebugLog::LogError(L"CustomInvites (OnNotifyCustomInviteReceived): EOS_CustomInvites_OnCustomInviteReceivedCallbackInfo is null");
	}
}

void EOS_CALL FCustomInvites::StaticOnNotifyCustomInviteAccepted(const EOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"CustomInvites (OnNotifyCustomInviteAccepted): invite accepted from Overlay.");
		FGame::Get().GetCustomInvites()->HandleCustomInviteAccepted(Data->Payload, Data->CustomInviteId, Data->TargetUserId);
	}
	else
	{
		FDebugLog::LogError(L"CustomInvites (OnNotifyCustomInviteAccepted): EOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo is null");
	}
}

void EOS_CALL FCustomInvites::StaticOnNotifyCustomInviteRejected(const EOS_CustomInvites_CustomInviteRejectedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"CustomInvites (OnNotifyCustomInviteRejected): invite rejected from Overlay.");
		FGame::Get().GetCustomInvites()->HandleCustomInviteRejected(Data->Payload, Data->CustomInviteId, Data->TargetUserId);
	}
	else
	{
		FDebugLog::LogError(L"CustomInvites (OnNotifyCustomInviteRejected): EOS_CustomInvites_CustomInviteRejectedCallbackInfo is null");
	}
}

void FCustomInvites::HandleCustomInviteReceived(const char* Payload, const char* InviteId, FProductUserId SenderId)
{
	LatestReceivedFromId = SenderId;
	LatestReceivedInviteId = FStringUtils::Widen(InviteId);
	LatestReceivedPayload = FStringUtils::Widen(Payload);

	FGameEvent GameEvent(EGameEventType::CustomInviteReceived);
	FGame::Get().OnGameEvent(GameEvent);
}


void FCustomInvites::HandleCustomInviteAccepted(const char* Payload, const char* InviteId, FProductUserId SenderId)
{
	AcceptLatestInvite();
}

void FCustomInvites::HandleCustomInviteRejected(const char* Payload, const char* InviteId, FProductUserId SenderId)
{
	RejectLatestInvite();
}

EOS_EResult FCustomInvites::SetCurrentPayload(const std::wstring& Payload)
{
	FDebugLog::Log(L"EOS SDK SetCurrentPayload: %ls", Payload.c_str());

	EOS_HCustomInvites CustomInvitesHandle = EOS_Platform_GetCustomInvitesInterface(FPlatform::GetPlatformHandle());

	EOS_CustomInvites_SetCustomInviteOptions SetInviteOptions = {};
	SetInviteOptions.ApiVersion = EOS_CUSTOMINVITES_SETCUSTOMINVITE_API_LATEST;
	SetInviteOptions.LocalUserId = CurrentProductUserId;
	std::string NarrowPayload = FStringUtils::Narrow(Payload);
	SetInviteOptions.Payload = NarrowPayload.c_str();
	return EOS_CustomInvites_SetCustomInvite(CustomInvitesHandle, &SetInviteOptions);
}

void FCustomInvites::SendInviteToFriend(const std::wstring& FriendName)
{
	FGame::Get().GetUsers()->QueryUserInfo(CurrentUserId, FriendName, [this, FriendName](const FUserData& UserData)
	{
		FProductUserId UserId = FGame::Get().GetUsers()->GetExternalAccountMapping(UserData.UserId);
		if (UserId.IsValid())
		{
			SendInviteToFriend(UserId);
		}
		else
		{
			FDebugLog::Log(L"EOS SDK SendInviteToFriend: No External Account Mapping found for %ls", FriendName.c_str());
			// user does not have a PUID which means either:
				// it's very early on and the refresh / mapping process hasn't completed yet
				// user hasn't played this game before
		}
	});
}

void FCustomInvites::SendInviteToFriend(FProductUserId FriendId)
{
	FDebugLog::Log(L"EOS SDK SendInviteToFriend: %ls", FriendId.ToString().c_str());

	EOS_HCustomInvites CustomInvitesHandle = EOS_Platform_GetCustomInvitesInterface(FPlatform::GetPlatformHandle());

	EOS_CustomInvites_SendCustomInviteOptions SendInviteOptions = {};
	SendInviteOptions.ApiVersion = EOS_CUSTOMINVITES_SENDCUSTOMINVITE_API_LATEST;
	SendInviteOptions.LocalUserId = CurrentProductUserId;
	EOS_ProductUserId TargetUserId(FriendId.AccountId);
	SendInviteOptions.TargetUserIds = &TargetUserId;
	SendInviteOptions.TargetUserIdsCount = 1;
	EOS_CustomInvites_SendCustomInvite(CustomInvitesHandle, &SendInviteOptions, nullptr, [](const EOS_CustomInvites_SendCustomInviteCallbackInfo* Data) {});
}

```

`EAC_SDK/Samples/AuthAndFriends/Source/CustomInvites.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_sdk.h"
#include "AccountHelpers.h"

/**
* Forward declarations
*/
class FGameEvent;

/**
* Manages custom invite process for local user
*/
class FCustomInvites
{
public:
	/**
	* Constructor
	*/
	FCustomInvites() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FCustomInvites(FCustomInvites const&) = delete;
	FCustomInvites& operator=(FCustomInvites const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FCustomInvites();

	void OnLoggedIn(FEpicAccountId UserId);
	void OnConnectLoggedIn(FProductUserId ProductUserId);
	void OnLoggedOut(FEpicAccountId UserId);
	void FriendStatusChanged(FEpicAccountId LocalUserId, FEpicAccountId TargetUserId, EOS_EFriendsStatus NewStatus);
	EOS_EResult SetCurrentPayload(const std::wstring& Payload);

	void SendInviteToFriend(const std::wstring& FriendName);
	void SendInviteToFriend(FProductUserId FriendId);
	
	void OnGameEvent(const FGameEvent& Event);

	void SetCurrentUser(FEpicAccountId UserId);

	void FinalizeInvite(EOS_EResult Result);

	void AcceptLatestInvite();
	void RejectLatestInvite();

	static void EOS_CALL StaticOnNotifyCustomInviteReceived(const EOS_CustomInvites_OnCustomInviteReceivedCallbackInfo* Data);
	static void EOS_CALL StaticOnNotifyCustomInviteAccepted(const EOS_CustomInvites_OnCustomInviteAcceptedCallbackInfo* Data);
	static void EOS_CALL StaticOnNotifyCustomInviteRejected(const EOS_CustomInvites_CustomInviteRejectedCallbackInfo* Data);

	void HandleCustomInviteReceived(const char* Payload, const char* InviteId, FProductUserId SenderId);
	void HandleCustomInviteAccepted(const char* Payload, const char* InviteId, FProductUserId SenderId);
	void HandleCustomInviteRejected(const char* Payload, const char* InviteId, FProductUserId SenderId);

	/**
	 * Accessor for current user id
	 *
	 * @return User id for current user
	 */
	FEpicAccountId GetCurrentUser() { return CurrentUserId; };

	FProductUserId LatestReceivedFromId;
	std::wstring LatestReceivedInviteId;
	std::wstring LatestReceivedPayload;

private:
	/** Map that contains friend notification ids for all local users. */
	EOS_NotificationId FriendNotificationId;

	/** Id for current user. */
	FEpicAccountId CurrentUserId;

	/** Current product user id. */
	FProductUserId CurrentProductUserId;

};
```

`EAC_SDK/Samples/AuthAndFriends/Source/CustomInvitesDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "CustomInvitesDialog.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "Sprite.h"
#include "Player.h"
#include "DebugLog.h"
#include "Checkbox.h"
#include "Users.h"
#include "DropDownList.h"
#include "TextEditor.h"
#include <functional>
#include "CustomInviteSendDialog.h"
#include "CustomInviteReceivedDialog.h"
#include "Menu.h"

#define CUSTOMINVITE_DIALOG_SENDINVITEBUTTON_WIDTH		120.f
#define CUSTOMINVITE_DIALOG_SENDINVITEBUTTON_HEIGHT		40.f

#define CUSTOMINVITE_DIALOG_SENDINVITEDIALOG_WIDTH		800.f
#define CUSTOMINVITE_DIALOG_SENDINVITEDIALOG_HEIGHT		200.f


FCustomInvitesDialog::FCustomInvitesDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	Vector2 DummyVector{};  // the position / size values are irrelevant in constructor

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DummyVector,
		DummyVector,
		DialogLayer,
		L"Assets/friends.dds");
	AddWidget(BackgroundImage);

	TitleLabel = std::make_shared<FTextLabelWidget>(
		DummyVector,
		DummyVector,
		DialogLayer,
		L"CUSTOM INVITES",
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	TitleLabel->SetBorderColor(Color::UIBorderGrey);
	TitleLabel->SetFont(DialogNormalFont);
	AddWidget(TitleLabel);

	// "Send Custom Invite"
	OpenSendInviteDialogButton = std::make_shared<FButtonWidget>(
		DummyVector,
		DummyVector,
		DialogLayer,
		L"Send Custom Invite",
		assets::DefaultButtonAssets,
		DialogSmallFont,
		Color::UIButtonBlue,
		FColor(1.f, 1.f, 1.f, 1.f));
	OpenSendInviteDialogButton->SetOnPressedCallback([this]()
	{
		OpenSendInviteDialogButton->Hide();
		if (std::shared_ptr<FMenu> StrongOuterMenu = WeakOuterMenu.lock())
		{
			StrongOuterMenu->ShowDialog(CustomInviteSendDialog);
		}
	});
	AddWidget(OpenSendInviteDialogButton);
	OpenSendInviteDialogButton->Disable();

	CustomInviteSendDialog = std::make_shared<FCustomInviteSendDialog>(
		DummyVector,
		DummyVector,
		Layer - 2,
		DialogNormalFont,
		DialogSmallFont);
	CustomInviteSendDialog->Create();

	CustomInviteReceivedDialog = std::make_shared<FCustomInviteReceivedDialog>(
		DummyVector,
		DummyVector,
		Layer - 2,
		DialogNormalFont,
		DialogSmallFont);
	CustomInviteReceivedDialog->Create();
}

void FCustomInvitesDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (BackgroundImage)
	{
		BackgroundImage->SetPosition(Pos);
	}

	if (TitleLabel)
	{
		TitleLabel->SetPosition(Pos);
	}

	if (OpenSendInviteDialogButton)
	{
		OpenSendInviteDialogButton->SetPosition(Pos + Vector2((GetSize().x - OpenSendInviteDialogButton->GetSize().x) / 2.f, (GetSize().y - OpenSendInviteDialogButton->GetSize().y) / 2.f));
	}

	if (!WeakOuterMenu.expired())
	{
		std::shared_ptr<FMenu> StrongOuterMenu = WeakOuterMenu.lock();
		const Vector2& WindowSize = StrongOuterMenu->WindowSize;

		if (CustomInviteSendDialog)
		{
			CustomInviteSendDialog->SetPosition(Vector2(Pos.x, Pos.y + TitleLabel->GetSize().y + 5.f));
		}

		if (CustomInviteReceivedDialog)
		{
			CustomInviteReceivedDialog->SetPosition(CustomInviteSendDialog->GetPosition());
		}
	}
}

void FCustomInvitesDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (BackgroundImage)
	{
		BackgroundImage->SetSize(NewSize);
	}

	if (TitleLabel)
	{
		TitleLabel->SetSize(Vector2(NewSize.x, 30.0f));
	}

	if (OpenSendInviteDialogButton)
	{
		OpenSendInviteDialogButton->SetSize(Vector2(CUSTOMINVITE_DIALOG_SENDINVITEBUTTON_WIDTH, CUSTOMINVITE_DIALOG_SENDINVITEBUTTON_HEIGHT));
	}

	if (CustomInviteSendDialog)
	{
		CustomInviteSendDialog->SetSize(Vector2(CUSTOMINVITE_DIALOG_SENDINVITEDIALOG_WIDTH, CUSTOMINVITE_DIALOG_SENDINVITEDIALOG_HEIGHT));
	}

	if (CustomInviteReceivedDialog)
	{
		CustomInviteReceivedDialog->SetSize(Vector2(CUSTOMINVITE_DIALOG_SENDINVITEDIALOG_WIDTH, CUSTOMINVITE_DIALOG_SENDINVITEDIALOG_HEIGHT));
	}
}

void FCustomInvitesDialog::OnEscapePressed()
{
	if (OpenSendInviteDialogButton)
	{
		OpenSendInviteDialogButton->Show();
	}
}

void FCustomInvitesDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		Enable();
	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		Disable();
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		Disable();
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		if (FPlayerManager::Get().GetNumPlayers() == 0)
		{
			Disable();
		}
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		Disable();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		Disable();
	}
	else if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		Enable();
	}
	else if (Event.GetType() == EGameEventType::CustomInviteReceived)
	{
		if (std::shared_ptr<FMenu> StrongOuterMenu = WeakOuterMenu.lock())
		{
			if (CustomInviteSendDialog)
			{
				StrongOuterMenu->HideDialog(CustomInviteSendDialog);
			}
			if (CustomInviteReceivedDialog)
			{
				StrongOuterMenu->ShowDialog(CustomInviteReceivedDialog);
			}
		}
		if (OpenSendInviteDialogButton)
		{
			OpenSendInviteDialogButton->Hide();
		}
	}
	else if (Event.GetType() == EGameEventType::CustomInviteAccepted ||
			Event.GetType() == EGameEventType::CustomInviteDeclined)
	{
		if (std::shared_ptr<FMenu> StrongOuterMenu = WeakOuterMenu.lock())
		{
			if (CustomInviteReceivedDialog)
			{
				StrongOuterMenu->HideDialog(CustomInviteReceivedDialog);
			}
		}
		if (OpenSendInviteDialogButton)
		{
			OpenSendInviteDialogButton->Show();
		}
	}

	if (CustomInviteReceivedDialog)
	{
		CustomInviteReceivedDialog->OnGameEvent(Event);
	}
}

void FCustomInvitesDialog::SetOuterMenu(std::weak_ptr<FMenu> InOuterMenu)
{
	WeakOuterMenu = InOuterMenu;
	if (std::shared_ptr<FMenu> StrongOuterMenu = WeakOuterMenu.lock())
	{
		StrongOuterMenu->AddDialog(CustomInviteSendDialog);
		StrongOuterMenu->HideDialog(CustomInviteSendDialog);

		StrongOuterMenu->AddDialog(CustomInviteReceivedDialog);
		StrongOuterMenu->HideDialog(CustomInviteReceivedDialog);
	}
}

```

`EAC_SDK/Samples/AuthAndFriends/Source/CustomInvitesDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
/**
 * Forward declarations
 */
class FTextEditorWidget;
class FSpriteWidget;
class FTextLabelWidget;
class FDropDownList;
class FButtonWidget;
class FCustomInviteSendDialog;
class FCustomInviteReceivedDialog;
class FBaseMenu;
class FMenu;
struct FFriendData;

/**
 * Custom Invites dialog
 */
class FCustomInvitesDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FCustomInvitesDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FCustomInvitesDialog() {};

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	virtual void OnEscapePressed() override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/**
	 * Assigns the Outer Menu (used to show/hide dialogs)
	 */
	void SetOuterMenu(std::weak_ptr<FMenu> InOuterMenu);

private:

	/** Outer menu (used to show/hide dialogs) */
	std::weak_ptr<FMenu> WeakOuterMenu;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Title label */
	std::shared_ptr<FTextLabelWidget> TitleLabel;

	/** Send Invite button (opens Send Invite Dialog) */
	std::shared_ptr<FButtonWidget> OpenSendInviteDialogButton;

	/** Send Custom Invite Dialog */
	std::shared_ptr<FCustomInviteSendDialog> CustomInviteSendDialog;

	/** Custom Invite Received Dialog */
	std::shared_ptr<FCustomInviteReceivedDialog> CustomInviteReceivedDialog;
};

```

`EAC_SDK/Samples/AuthAndFriends/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Menu.h"
#include "Level.h"
#include "Game.h"
#include "Console.h"
#include "Friends.h"
#include "EosUI.h"

FGame::FGame() noexcept(false) :
	FBaseGame()
{
	Menu = std::make_shared<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	CustomInvites = std::make_unique<FCustomInvites>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();
	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" SIMULATECUSTOMINVITE - simulates an incoming custom invite, debug testing only",
		};
		AppendHelpMessageLines(ExtraHelpMessageLines);

#if defined(_DEBUG) || defined(_TEST)
		Console->AddCommand(L"SIMULATECUSTOMINVITE", [](const std::vector<std::wstring>& args)
		{
			FGame::Get().GetCustomInvites()->HandleCustomInviteReceived("TEST PAYLOAD", "inviteidINVITEIDinviteid", FAccountHelpers::ProductUserIDFromString("fakeRemoteUser-1234"));
		});

		Console->AddCommand(L"BLOCKFIRSTFRIEND", [](const std::vector<std::wstring>&)
		{
			const std::vector<FFriendData>& FriendData = FGame::Get().GetFriends()->GetFriends();
			if (FriendData.size() > 0)
			{
				const FFriendData& FirstFriend = FriendData[0];
				FGame::Get().GetEosUI()->ShowBlockPlayer(FirstFriend.UserId);
			}
		});

		Console->AddCommand(L"REPORTFIRSTFRIEND", [](const std::vector<std::wstring>&)
		{
			const std::vector<FFriendData>& FriendData = FGame::Get().GetFriends()->GetFriends();
			if (FriendData.size() > 0)
			{
				const FFriendData& FirstFriend = FriendData[0];
				FGame::Get().GetEosUI()->ShowReportPlayer(FirstFriend.UserId);
				FGame::Get().GetEosUI()->ShowFriendsOverlay();
			}
		});
#endif
	}
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	CustomInvites->OnGameEvent(Event);
	FBaseGame::OnGameEvent(Event);
}

```

`EAC_SDK/Samples/AuthAndFriends/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"
#include "CustomInvites.h"

class FCustomInvites;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/** 
	 * Constructor
	 */
	FGame() noexcept(false);

	/** 
	 * Destructor
	 */
	virtual ~FGame() override;


	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Creates all console commands
	*/
	virtual void CreateConsoleCommands() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	 * Getter for custom invites component.
	 */
	const std::unique_ptr<FCustomInvites>& GetCustomInvites() { return CustomInvites; }

protected:
	/** CustomInvites component */
	std::unique_ptr<FCustomInvites> CustomInvites;
};

```

`EAC_SDK/Samples/AuthAndFriends/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/AuthAndFriends/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Menu.h"
#include "CustomInvitesDialog.h"
#include "ConsoleDialog.h"
#include "Font.h"
#include "Sprite.h"
#include "FriendsDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "PopupDialog.h"
#include "GameEvent.h"

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false) :
	FBaseMenu(InConsole)
{

}

FMenu::~FMenu()
{

}

void FMenu::Create()
{
	CreateFriendsDialog();

	// creates console dialog, which is needed for creating custom invites dialog
	FBaseMenu::Create();

	CreateCustomInvitesDialog();
}

void FMenu::Release()
{
	if (CustomInvitesDialog)
	{
		CustomInvitesDialog->Release();
		CustomInvitesDialog.reset();
	}

	FBaseMenu::Release();
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	if (CustomInvitesDialog)
	{
		CustomInvitesDialog->OnGameEvent(Event);
	}

	FBaseMenu::OnGameEvent(Event);
}

void FMenu::CreateCustomInvitesDialog()
{
	Vector2 DummyVector{};

	CustomInvitesDialog = std::make_shared<FCustomInvitesDialog>(
		DummyVector,
		DummyVector,
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	AddDialog(CustomInvitesDialog);
	std::shared_ptr<FMenu> MenuPtr = std::static_pointer_cast<FMenu>(shared_from_this());
	CustomInvitesDialog->SetOuterMenu(std::weak_ptr<FMenu>(MenuPtr));
}

// custom invite / console frame
#define CUSTOMINVITE_CONSOLE_FRAME_WIDTH	.7f
#define CUSTOMINVITE_CONSOLE_FRAME_HEIGHT	0.99f
#define CUSTOMINVITE_CONSOLE_FRAME_SCALE	Vector2(CUSTOMINVITE_CONSOLE_FRAME_WIDTH, CUSTOMINVITE_CONSOLE_FRAME_HEIGHT)

// friends frame
#define FRIENDS_FRAME_WIDTH					1.f - CUSTOMINVITE_CONSOLE_FRAME_WIDTH
#define FRIENDS_FRAME_HEIGHT				0.99f
#define FRIENDS_FRAME_SCALE					Vector2(FRIENDS_FRAME_WIDTH, FRIENDS_FRAME_HEIGHT)

// custom invite dialog (inside custom invite / console frame)
#define CUSTOMINVITES_DIALOG_PERCENT_X		1.f
#define CUSTOMINVITES_DIALOG_PERCENT_Y		.29f
#define CUSTOMINVITE_DIALOG_SCALE			Vector2(CUSTOMINVITES_DIALOG_PERCENT_X, CUSTOMINVITES_DIALOG_PERCENT_Y)

// console dialog (inside custom invite / console frame)
#define CONSOLE_DIALOG_PERCENT_X			1.f
#define CONSOLE_DIALOG_PERCENT_Y			1.f - CUSTOMINVITES_DIALOG_PERCENT_Y
#define CONSOLE_DIALOG_SCALE				Vector2(CONSOLE_DIALOG_PERCENT_X, CONSOLE_DIALOG_PERCENT_Y)

// friends dialog (inside friends frame)
#define FRIENDS_USAGE_PERCENT_X				1.f
#define FRIENDS_USAGE_PERCENT_Y				1.f
#define FRIENDS_DIALOG_SCALE				Vector2(FRIENDS_USAGE_PERCENT_X, FRIENDS_USAGE_PERCENT_Y)

void FMenu::UpdateLayout(int Width, int Height)
{
	WindowSize = Vector2((float)Width, (float)Height);
	Vector2 LayoutPositionMarker{ };

	BackgroundImage->SetPosition(LayoutPositionMarker);
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	// move the layout cursor down 10px, recalculate available percentage
	LayoutPositionMarker += Vector2(10.f, 120.f);
	const Vector2 MainFrameOrigin{ LayoutPositionMarker };
	const Vector2 MainFrameSize{ WindowSize - MainFrameOrigin };

	const Vector2 CustomInviteConsoleFrameOrigin{ MainFrameOrigin };
	const Vector2 CustomInviteConsoleFrameSize{ Vector2::CoeffProduct(CUSTOMINVITE_CONSOLE_FRAME_SCALE, MainFrameSize) };

	const Vector2 CustomInviteDialogSize = Vector2::CoeffProduct(CUSTOMINVITE_DIALOG_SCALE, CustomInviteConsoleFrameSize);
	if (CustomInvitesDialog)
	{
		CustomInvitesDialog->SetSize(CustomInviteDialogSize);
		CustomInvitesDialog->SetPosition(CustomInviteConsoleFrameOrigin);
	}
	LayoutPositionMarker.y += CustomInviteDialogSize.y;

	const Vector2 ConsoleWidgetSize = Vector2::CoeffProduct(CONSOLE_DIALOG_SCALE, CustomInviteConsoleFrameSize);
	if (ConsoleDialog)
	{
		ConsoleDialog->SetSize(ConsoleWidgetSize);
		ConsoleDialog->SetPosition(LayoutPositionMarker);
	}

	LayoutPositionMarker = MainFrameOrigin;
	LayoutPositionMarker.x += CustomInviteConsoleFrameSize.x;

	const Vector2 FriendsFrameOrigin{ LayoutPositionMarker };
	const Vector2 FriendsFrameSize = Vector2::CoeffProduct(FRIENDS_FRAME_SCALE, MainFrameSize);

	const Vector2 FriendsWidgetSize = Vector2::CoeffProduct(FRIENDS_DIALOG_SCALE, FriendsFrameSize);
	if (FriendsDialog)
	{
		FriendsDialog->SetPosition(LayoutPositionMarker);
		FriendsDialog->SetSize(FriendsWidgetSize);
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y + 130.0f));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y + 130.0f));
	}

	if (AuthDialogs)
	{
		AuthDialogs->UpdateLayout();
	}
}
```

`EAC_SDK/Samples/AuthAndFriends/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

class FCustomInvitesDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu();

	/** 
	 * Initialize
	 */
	virtual void Create() override; 
	
	virtual void Release() override;

	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	 * Creates the Custom Invites dialogs
	 */
	virtual void CreateCustomInvitesDialog();

	virtual void UpdateLayout(int Width, int Height) override;

 	/** Custom Invites Dialog */
 	std::shared_ptr<FCustomInvitesDialog> CustomInvitesDialog;

	std::shared_ptr<FTextLabelWidget> TitleLabel;

	Vector2 WindowSize;

};

```

`EAC_SDK/Samples/AuthAndFriends/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Auth and Friends";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/AuthAndFriends/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/AuthAndFriends/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/Leaderboard/Leaderboard.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>Leaderboard</RootNamespace>
    <ProjectGuid>{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Leaderboard</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Leaderboard/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Leaderboard/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Leaderboard/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Leaderboard/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Leaderboard/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Leaderboard/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Leaderboard/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Leaderboard/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableRowView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\Leaderboard.h" />
    <ClInclude Include="Source\LeaderboardDialog.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TableRowView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\Leaderboard.cpp" />
    <ClCompile Include="Source\LeaderboardDialog.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="..\Shared\Source\Graphics\GUI\TableView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/Leaderboard/Leaderboard.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="Source\Leaderboard.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\LeaderboardDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableRowView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
	<ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Source\Leaderboard.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\LeaderboardDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TableRowView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\TableView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/Leaderboard/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "Leaderboard.h"
#include "GameEvent.h"
#include "Platform.h"
#include "Game.h"

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	Leaderboard = std::make_unique<FLeaderboard>();

	CreateConsoleCommands();
}

FGame::~FGame()
{

}

void FGame::Init()
{
	FBaseGame::Init();

	Leaderboard->Init();
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" GETDEFS - to request retrieval of leaderboard definitions;",
			L" INGEST - to ingest a stat for current logged in user;"
		};

		AppendHelpMessageLines(ExtraHelpMessageLines);

		// Leaderboards
		Console->AddCommand(L"GETDEFS", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetLeaderboard())
				{
					FGame::Get().GetLeaderboard()->QueryDefinitions();
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"ADDDEBUGDEFS", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetLeaderboard())
				{
					std::vector<std::shared_ptr<FLeaderboardsDefinitionData>> TestData;

					FLeaderboardsDefinitionData DefData;
					DefData.LeaderboardId = L"First";
					DefData.Aggregation = ELeaderboardAggregation::Max;
					DefData.StatName = L"Game Score";
					DefData.StartTime = 0;
					DefData.EndTime = 0;
					TestData.emplace_back(std::shared_ptr<FLeaderboardsDefinitionData>(new FLeaderboardsDefinitionData(DefData)));

					DefData.LeaderboardId = L"Second";
					TestData.emplace_back(std::shared_ptr<FLeaderboardsDefinitionData>(new FLeaderboardsDefinitionData(DefData)));

					DefData.LeaderboardId = L"Third";
					TestData.emplace_back(std::shared_ptr<FLeaderboardsDefinitionData>(new FLeaderboardsDefinitionData(DefData)));

					// Use the follow for testing scroller with a larger number of defs
					/*for (int i = 4; i < 20; ++i)
					{
						DefData.LeaderboardId = L"Definition" + std::to_wstring(i + 1);
						TestData.emplace_back(std::shared_ptr<FLeaderboardsDefinitionData>(new FLeaderboardsDefinitionData(DefData)));
					}*/

					//Existing data will be replaced
					FGame::Get().GetLeaderboard()->GetCachedDefinitions().swap(TestData);
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"INGEST", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (args.size() == 2)
				{
					if (FGame::Get().GetLeaderboard())
					{
						try
						{
							FGame::Get().GetLeaderboard()->IngestStat(args[0], std::stoi(args[1]));
						}
						catch (const std::invalid_argument&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest - invalid argument");
						}
						catch (const std::out_of_range&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest - out of range.");
						}
						catch (const std::exception&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't ingest, undefined error.");
						}
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"Error: name of stat and ingest amount is required.");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

	}
}

void FGame::Update()
{
	FBaseGame::Update();

	Leaderboard->Update();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);

	Leaderboard->OnGameEvent(Event);
}

const std::unique_ptr<FLeaderboard>& FGame::GetLeaderboard()
{
	return Leaderboard;
}
```

`EAC_SDK/Samples/Leaderboard/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FLeaderboard;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Initialization
	*/
	virtual void Init() override;

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	 * Getter for leaderboard component.
	 */
	const std::unique_ptr<FLeaderboard>& GetLeaderboard();

protected:
	/**
	* Creates all console commands
	*/
	virtual void CreateConsoleCommands() override;

	/** Leaderboard component */
	std::unique_ptr<FLeaderboard> Leaderboard;
};


```

`EAC_SDK/Samples/Leaderboard/Source/Leaderboard.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "Utils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "Leaderboard.h"
#include <eos_leaderboards.h>
#include <eos_stats.h>

FLeaderboard::FLeaderboard()
{
}

FLeaderboard::~FLeaderboard()
{

}

void FLeaderboard::Init()
{
	if (FPlatform::GetPlatformHandle() != nullptr)
	{
		LeaderboardsHandle = EOS_Platform_GetLeaderboardsInterface(FPlatform::GetPlatformHandle());

		StatsHandle = EOS_Platform_GetStatsInterface(FPlatform::GetPlatformHandle());
	}
}


void FLeaderboard::Update()
{

}

void FLeaderboard::OnLoggedIn(FProductUserId UserId)
{
	QueryDefinitions();
}

void FLeaderboard::OnLoggedOut(FProductUserId UserId)
{
	if (FPlayerManager::Get().GetNumPlayers() == 0)
	{
		FGameEvent Event(EGameEventType::NoUserLoggedIn);
		FGame::Get().OnGameEvent(Event);
	}

	CachedLeaderboardsDefinitionData.clear();
	CachedLeaderboardsRecordData.clear();
	CachedLeaderboardsUserScoresData.clear();
}

void FLeaderboard::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		FProductUserId UserId = Event.GetProductUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserConnectAuthExpiration)
	{
		FProductUserId UserId = Event.GetProductUserId();
		OnLoggedOut(UserId);
	}
}

void FLeaderboard::QueryDefinitions()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Leaderboard - QueryDefinitions: Current player is invalid!");
		return;
	}

	EOS_Leaderboards_QueryLeaderboardDefinitionsOptions QueryDefinitionsOptions = { 0 };
	QueryDefinitionsOptions.ApiVersion = EOS_LEADERBOARDS_QUERYLEADERBOARDDEFINITIONS_API_LATEST;
	QueryDefinitionsOptions.StartTime = EOS_LEADERBOARDS_TIME_UNDEFINED;
	QueryDefinitionsOptions.EndTime = EOS_LEADERBOARDS_TIME_UNDEFINED;
	QueryDefinitionsOptions.LocalUserId = Player->GetProductUserID();

	EOS_Leaderboards_QueryLeaderboardDefinitions(LeaderboardsHandle, &QueryDefinitionsOptions, nullptr, LeaderboardDefinitionsReceivedCallbackFn);
}

void FLeaderboard::CacheLeaderboardDefinitions()
{
	EOS_HLeaderboards LeaderboardsHandle = EOS_Platform_GetLeaderboardsInterface(FPlatform::GetPlatformHandle());

	EOS_Leaderboards_GetLeaderboardDefinitionCountOptions LeaderboardDefinitionsCountOptions = { 0 };
	LeaderboardDefinitionsCountOptions.ApiVersion = EOS_LEADERBOARDS_GETLEADERBOARDDEFINITIONCOUNT_API_LATEST;

	uint32_t LeaderboardDefinitionsCount = EOS_Leaderboards_GetLeaderboardDefinitionCount(LeaderboardsHandle, &LeaderboardDefinitionsCountOptions);

	EOS_Leaderboards_CopyLeaderboardDefinitionByIndexOptions CopyOptions = { 0 };
	CopyOptions.ApiVersion = EOS_LEADERBOARDS_COPYLEADERBOARDDEFINITIONBYINDEX_API_LATEST;

	// Clear definitions
	CachedLeaderboardsDefinitionData.clear();

	for (CopyOptions.LeaderboardIndex = 0; CopyOptions.LeaderboardIndex < LeaderboardDefinitionsCount; ++CopyOptions.LeaderboardIndex)
	{
		EOS_Leaderboards_Definition* LeaderboardDef = NULL;
		EOS_EResult CopyLeaderboardDefinitionsResult = EOS_Leaderboards_CopyLeaderboardDefinitionByIndex(LeaderboardsHandle, &CopyOptions, &LeaderboardDef);
		if (CopyLeaderboardDefinitionsResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"CopyLeaderboardDefinitions Failure!");
			break;
		}

		std::shared_ptr<FLeaderboardsDefinitionData> LeaderboardsDefinition = std::make_shared<FLeaderboardsDefinitionData>();

		if (LeaderboardDef->LeaderboardId)
		{
			LeaderboardsDefinition->LeaderboardId = FStringUtils::Widen(LeaderboardDef->LeaderboardId);
		}

		if (LeaderboardDef->StatName)
		{
			LeaderboardsDefinition->StatName = FStringUtils::Widen(LeaderboardDef->StatName);
		}

		LeaderboardsDefinition->StartTime = LeaderboardDef->StartTime;

		LeaderboardsDefinition->EndTime = LeaderboardDef->EndTime;

		switch (LeaderboardDef->Aggregation)
		{
			case EOS_ELeaderboardAggregation::EOS_LA_Min:
				LeaderboardsDefinition->Aggregation = ELeaderboardAggregation::Min;
				break;
			case EOS_ELeaderboardAggregation::EOS_LA_Max:
				LeaderboardsDefinition->Aggregation = ELeaderboardAggregation::Max;
				break;
			case EOS_ELeaderboardAggregation::EOS_LA_Sum:
				LeaderboardsDefinition->Aggregation = ELeaderboardAggregation::Sum;
				break;
			case EOS_ELeaderboardAggregation::EOS_LA_Latest:
				LeaderboardsDefinition->Aggregation = ELeaderboardAggregation::Latest;
				break;
		}

		CachedLeaderboardsDefinitionData.emplace_back(LeaderboardsDefinition);

		// Release Leaderboard Definition
		EOS_Leaderboards_Definition_Release(LeaderboardDef);
	}

	PrintLeaderboardDefinitions();

	FGameEvent Event(EGameEventType::DefinitionsReceived);
	FGame::Get().OnGameEvent(Event);
}

void FLeaderboard::PrintLeaderboardDefinitions()
{
	// Print info
	FDebugLog::Log(L"%d Leaderboards:", CachedLeaderboardsDefinitionData.size());

	for (uint32_t LeaderboardIndex = 0; LeaderboardIndex < CachedLeaderboardsDefinitionData.size(); ++LeaderboardIndex)
	{
		FDebugLog::Log(L"-------------");
		FDebugLog::Log(L"Leaderboard: %d", LeaderboardIndex + 1);

		std::shared_ptr<FLeaderboardsDefinitionData> LeaderboardDef = CachedLeaderboardsDefinitionData[LeaderboardIndex];

		if (!LeaderboardDef->LeaderboardId.empty())
		{
			FDebugLog::Log(L"Leaderboard ID: %ls", LeaderboardDef->LeaderboardId.c_str());
		}

		if (!LeaderboardDef->StatName.empty())
		{
			FDebugLog::Log(L"Stat Name: %ls", LeaderboardDef->StatName.c_str());
		}

		if (LeaderboardDef->StartTime == EOS_LEADERBOARDS_TIME_UNDEFINED)
		{
			FDebugLog::Log(L"Start Time: Undefined");
		}
		else
		{
			std::wstring DateTimeStrW = FUtils::ConvertUnixTimestampToUTCString(LeaderboardDef->StartTime);
			FDebugLog::Log(L"Start Time: %ls", DateTimeStrW.c_str());
		}

		if (LeaderboardDef->EndTime == EOS_LEADERBOARDS_TIME_UNDEFINED)
		{
			FDebugLog::Log(L"End Time: Undefined");
		}
		else
		{
			std::wstring DateTimeStrW = FUtils::ConvertUnixTimestampToUTCString(LeaderboardDef->EndTime);
			FDebugLog::Log(L"End Time: %ls", DateTimeStrW.c_str());
		}

		switch (LeaderboardDef->Aggregation)
		{
			case ELeaderboardAggregation::Min:
				FDebugLog::Log(L"Aggregation: Minimum");
				break;
			case ELeaderboardAggregation::Max:
				FDebugLog::Log(L"Aggregation: Maximum");
				break;
			case ELeaderboardAggregation::Sum:
				FDebugLog::Log(L"Aggregation: Sum");
				break;
			case ELeaderboardAggregation::Latest:
				FDebugLog::Log(L"Aggregation: Latest");
				break;
		}

		FDebugLog::Log(L"-------------");
	}
}

std::vector<std::shared_ptr<FLeaderboardsDefinitionData>>& FLeaderboard::GetCachedDefinitions()
{
	return CachedLeaderboardsDefinitionData;
}

std::vector<std::wstring> FLeaderboard::GetDefinitionIds()
{
	std::vector<std::wstring> DefinitionIds;

	for (std::shared_ptr<FLeaderboardsDefinitionData>& NextDefinition : CachedLeaderboardsDefinitionData)
	{
		if (!NextDefinition->LeaderboardId.empty())
		{
			DefinitionIds.emplace_back(NextDefinition->LeaderboardId);
		}
	}

	return DefinitionIds;
}

bool FLeaderboard::GetDefinitionFromId(std::wstring LeaderboardId, std::shared_ptr<FLeaderboardsDefinitionData>& OutDef)
{
	for (std::shared_ptr<FLeaderboardsDefinitionData> NextDefinition : CachedLeaderboardsDefinitionData)
	{
		if (NextDefinition->LeaderboardId == LeaderboardId)
		{
			OutDef = NextDefinition;
			return true;
		}
	}

	return false;
}

bool FLeaderboard::GetDefinitionFromIndex(int InIndex, std::shared_ptr<FLeaderboardsDefinitionData>& OutDef)
{
	int Index = 0;
	for (std::shared_ptr<FLeaderboardsDefinitionData> NextDefinition : CachedLeaderboardsDefinitionData)
	{
		if (Index == InIndex)
		{
			OutDef = NextDefinition;
			return true;
		}
		++Index;
	}

	return false;
}

void EOS_CALL FLeaderboard::LeaderboardDefinitionsReceivedCallbackFn(const EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Leaderboards - Query Definitions Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] Leaderboards - Query Definitions Complete");

	FGame::Get().GetLeaderboard()->CacheLeaderboardDefinitions();
}

void FLeaderboard::QueryRanks(std::wstring LeaderboardId)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Leaderboard - QueryRanks: Current player is invalid!");
		return;
	}

	std::string LeaderboardIdStr = FStringUtils::Narrow(LeaderboardId);

	EOS_Leaderboards_QueryLeaderboardRanksOptions QueryRanksOptions = { 0 };
	QueryRanksOptions.ApiVersion = EOS_LEADERBOARDS_QUERYLEADERBOARDRANKS_API_LATEST;
	QueryRanksOptions.LeaderboardId = LeaderboardIdStr.c_str();
	QueryRanksOptions.LocalUserId = Player->GetProductUserID();

	EOS_Leaderboards_QueryLeaderboardRanks(LeaderboardsHandle, &QueryRanksOptions, nullptr, LeaderboardRanksReceivedCallbackFn);
}

void FLeaderboard::CacheLeaderboardRecords()
{
	EOS_HLeaderboards LeaderboardsHandle = EOS_Platform_GetLeaderboardsInterface(FPlatform::GetPlatformHandle());

	EOS_Leaderboards_GetLeaderboardRecordCountOptions LeaderboardsRecordsCountOptions = { 0 };
	LeaderboardsRecordsCountOptions.ApiVersion = EOS_LEADERBOARDS_GETLEADERBOARDRECORDCOUNT_API_LATEST;

	uint32_t LeaderboardRecordsCount = EOS_Leaderboards_GetLeaderboardRecordCount(LeaderboardsHandle, &LeaderboardsRecordsCountOptions);

	EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions CopyOptions = { 0 };
	CopyOptions.ApiVersion = EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYINDEX_API_LATEST;

	// Clear records
	CachedLeaderboardsRecordData.clear();

	for (CopyOptions.LeaderboardRecordIndex = 0; CopyOptions.LeaderboardRecordIndex < LeaderboardRecordsCount; ++CopyOptions.LeaderboardRecordIndex)
	{
		EOS_Leaderboards_LeaderboardRecord* LeaderboardRecord = NULL;
		EOS_EResult CopyLeaderboardRecordResult = EOS_Leaderboards_CopyLeaderboardRecordByIndex(LeaderboardsHandle, &CopyOptions, &LeaderboardRecord);
		if (CopyLeaderboardRecordResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"CopyLeaderboardRecords Failure!");
			break;
		}

		std::shared_ptr<FLeaderboardsRecordData> LeaderboardRecordData = std::make_shared<FLeaderboardsRecordData>();

		LeaderboardRecordData->UserId = LeaderboardRecord->UserId;

		LeaderboardRecordData->Rank = LeaderboardRecord->Rank;

		LeaderboardRecordData->Score = LeaderboardRecord->Score;

		LeaderboardRecordData->DisplayName = FStringUtils::Widen(LeaderboardRecord->UserDisplayName);

		CachedLeaderboardsRecordData.emplace_back(LeaderboardRecordData);

		// Release Leaderboard Record
		EOS_Leaderboards_LeaderboardRecord_Release(LeaderboardRecord);
	}

	PrintLeaderboardRecords();

	FGameEvent Event(EGameEventType::LeaderboardRecordsReceived);
	FGame::Get().OnGameEvent(Event);
}

void FLeaderboard::PrintLeaderboardRecords()
{
	// Print info
	FDebugLog::Log(L"%d Leaderboard Records:", CachedLeaderboardsRecordData.size());

	for (uint32_t LeaderboardRecordIndex = 0; LeaderboardRecordIndex < CachedLeaderboardsRecordData.size(); ++LeaderboardRecordIndex)
	{
		std::shared_ptr<FLeaderboardsRecordData> LeaderboardRecord = CachedLeaderboardsRecordData[LeaderboardRecordIndex];

		FDebugLog::Log(L"[%d] User ID: %ls, User Name: %ls, Rank: %d, Score: %d",
			LeaderboardRecordIndex + 1,
			FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(LeaderboardRecord->UserId)).c_str(),
			LeaderboardRecord->DisplayName.c_str(),
			LeaderboardRecord->Rank,
			LeaderboardRecord->Score);
	}
}

std::vector<std::shared_ptr<FLeaderboardsRecordData>>& FLeaderboard::GetCachedRecords()
{
	return CachedLeaderboardsRecordData;
}

void EOS_CALL FLeaderboard::LeaderboardRanksReceivedCallbackFn(const EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Leaderboards - Query Ranks Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] Leaderboards - Query Ranks Complete, LeaderboardId=[%ls]", FStringUtils::Widen(Data->LeaderboardId).c_str());

	FGame::Get().GetLeaderboard()->CacheLeaderboardRecords();
}

void FLeaderboard::QueryUserScores(std::vector<std::wstring> LeaderboardIds, std::vector<EOS_ProductUserId>& UserIds)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Leaderboard - QueryUserScores: Current player is invalid!");
		return;
	}

	std::vector<std::wstring> StatNames;
	std::vector<EOS_ELeaderboardAggregation> StatAggregation;
	for (std::wstring LeaderboardId : LeaderboardIds)
	{
		std::shared_ptr<FLeaderboardsDefinitionData> DefData;
		if (GetDefinitionFromId(LeaderboardId, DefData))
		{
			StatNames.emplace_back(DefData->StatName);

			EOS_ELeaderboardAggregation Aggregation;
			switch (DefData->Aggregation)
			{
				case ELeaderboardAggregation::Min:
					Aggregation = EOS_ELeaderboardAggregation::EOS_LA_Min;
					break;
				case ELeaderboardAggregation::Max:
					Aggregation = EOS_ELeaderboardAggregation::EOS_LA_Max;
					break;
				case ELeaderboardAggregation::Sum:
					Aggregation = EOS_ELeaderboardAggregation::EOS_LA_Sum;
					break;
				case ELeaderboardAggregation::Latest:
					Aggregation = EOS_ELeaderboardAggregation::EOS_LA_Latest;
					break;
			}
			StatAggregation.emplace_back(Aggregation);
		}
	}

	// Query User Scores
	EOS_Leaderboards_QueryLeaderboardUserScoresOptions QueryUserScoresOptions = { 0 };
	QueryUserScoresOptions.ApiVersion = EOS_LEADERBOARDS_QUERYLEADERBOARDUSERSCORES_API_LATEST;
	QueryUserScoresOptions.UserIdsCount = (uint32_t)UserIds.size();
	EOS_ProductUserId* UserData = new EOS_ProductUserId[QueryUserScoresOptions.UserIdsCount];
	for (uint32_t UserIndex = 0; UserIndex < UserIds.size(); ++UserIndex)
	{
		UserData[UserIndex] = UserIds[UserIndex];
	}
	QueryUserScoresOptions.UserIds = UserData;
	QueryUserScoresOptions.StatInfoCount = (uint32_t)StatNames.size();
	EOS_Leaderboards_UserScoresQueryStatInfo* StatInfoData = new EOS_Leaderboards_UserScoresQueryStatInfo[QueryUserScoresOptions.StatInfoCount];
	std::vector<std::string> NarrowStatNames;
	for (std::wstring StatName : StatNames)
	{
		NarrowStatNames.emplace_back(FStringUtils::Narrow(StatName));
	}
	for (uint32_t StatIndex = 0; StatIndex < StatNames.size(); ++StatIndex)
	{
		StatInfoData[StatIndex].StatName = NarrowStatNames[StatIndex].c_str();
		StatInfoData[StatIndex].Aggregation = StatAggregation[StatIndex];
	}
	QueryUserScoresOptions.StatInfo = StatInfoData;
	QueryUserScoresOptions.StartTime = EOS_LEADERBOARDS_TIME_UNDEFINED;
	QueryUserScoresOptions.EndTime = EOS_LEADERBOARDS_TIME_UNDEFINED;
	QueryUserScoresOptions.LocalUserId = Player->GetProductUserID();

	EOS_Leaderboards_QueryLeaderboardUserScores(LeaderboardsHandle, &QueryUserScoresOptions, nullptr, LeaderboardUserScoresReceivedCallbackFn);

	delete[] UserData;
	delete[] StatInfoData;
}

void FLeaderboard::CacheLeaderboardUserScores()
{
	CachedLeaderboardsUserScoresData.clear();

	EOS_HLeaderboards LeaderboardsHandle = EOS_Platform_GetLeaderboardsInterface(FPlatform::GetPlatformHandle());

	for (uint32_t LeaderboardIndex = 0; LeaderboardIndex < CachedLeaderboardsDefinitionData.size(); ++LeaderboardIndex)
	{
		std::vector<std::shared_ptr<FLeaderboardsUserScoreData>> CachedUserScores;

		std::shared_ptr<FLeaderboardsDefinitionData> LeaderboardDef = CachedLeaderboardsDefinitionData[LeaderboardIndex];

		if (!LeaderboardDef->LeaderboardId.empty() && !LeaderboardDef->StatName.empty())
		{
			std::string StatName = FStringUtils::Narrow(LeaderboardDef->StatName);

			EOS_Leaderboards_GetLeaderboardUserScoreCountOptions LeaderboardUserScoresCountOptions = { 0 };
			LeaderboardUserScoresCountOptions.ApiVersion = EOS_LEADERBOARDS_GETLEADERBOARDUSERSCORECOUNT_API_LATEST;
			LeaderboardUserScoresCountOptions.StatName = StatName.c_str();

			uint32_t LeaderboardUserScoresCount = EOS_Leaderboards_GetLeaderboardUserScoreCount(LeaderboardsHandle, &LeaderboardUserScoresCountOptions);

			EOS_Leaderboards_CopyLeaderboardUserScoreByIndexOptions CopyOptions = { 0 };
			CopyOptions.ApiVersion = EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYINDEX_API_LATEST;
			CopyOptions.StatName = StatName.c_str();

			for (CopyOptions.LeaderboardUserScoreIndex = 0; CopyOptions.LeaderboardUserScoreIndex < LeaderboardUserScoresCount; ++CopyOptions.LeaderboardUserScoreIndex)
			{
				EOS_Leaderboards_LeaderboardUserScore* LeaderboardUserScore = NULL;
				EOS_EResult CopyLeaderboardUserScoreResult = EOS_Leaderboards_CopyLeaderboardUserScoreByIndex(LeaderboardsHandle, &CopyOptions, &LeaderboardUserScore);

				if (CopyLeaderboardUserScoreResult != EOS_EResult::EOS_Success)
				{
					FDebugLog::LogError(L"CopyLeaderboardRecords Failure!");
					break;
				}

				std::shared_ptr<FLeaderboardsUserScoreData> LeaderboardUserScoreData = std::make_shared<FLeaderboardsUserScoreData>();

				LeaderboardUserScoreData->UserId = LeaderboardUserScore->UserId;

				LeaderboardUserScoreData->Score = LeaderboardUserScore->Score;

				CachedUserScores.emplace_back(LeaderboardUserScoreData);

				// Release Leaderboard User Score
				EOS_Leaderboards_LeaderboardUserScore_Release(LeaderboardUserScore);
			}
		}

		CachedLeaderboardsUserScoresData.emplace(LeaderboardDef->LeaderboardId, CachedUserScores);
	}

	PrintLeaderboardUserScores();

	FGameEvent Event(EGameEventType::LeaderboardRecordsReceived);
	FGame::Get().OnGameEvent(Event);
}

void FLeaderboard::PrintLeaderboardUserScores()
{
	// Print info
	for (uint32_t LeaderboardIndex = 0; LeaderboardIndex < CachedLeaderboardsDefinitionData.size(); ++LeaderboardIndex)
	{
		std::shared_ptr<FLeaderboardsDefinitionData> LeaderboardDef = CachedLeaderboardsDefinitionData[LeaderboardIndex];

		if (!LeaderboardDef->LeaderboardId.empty())
		{
			const std::vector<std::shared_ptr<FLeaderboardsUserScoreData>>* CachedUserScores;
			if (GetCachedUserScoresFromLeaderboardId(LeaderboardDef->LeaderboardId, &CachedUserScores))
			{
				FDebugLog::Log(L"-------------");

				FDebugLog::Log(L"%d Leaderboard User Scores for Leaderboard ID: %ls", CachedUserScores->size(), LeaderboardDef->LeaderboardId.c_str());

				for (uint32_t LeaderboardUserScoreIndex = 0; LeaderboardUserScoreIndex < CachedUserScores->size(); ++LeaderboardUserScoreIndex)
				{
					std::shared_ptr<FLeaderboardsUserScoreData> LeaderboardUserScore = (*CachedUserScores)[LeaderboardUserScoreIndex];

					FDebugLog::Log(L"[%d] User ID: %ls, Score: %d",
						LeaderboardUserScoreIndex + 1,
						FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(LeaderboardUserScore->UserId)).c_str(),
						LeaderboardUserScore->Score);
				}

				FDebugLog::Log(L"-------------");
			}
		}
	}
}

const std::map<std::wstring, std::vector<std::shared_ptr<FLeaderboardsUserScoreData>>>& FLeaderboard::GetCachedUserScores() const
{
	return CachedLeaderboardsUserScoresData;
}

bool FLeaderboard::GetCachedUserScoresFromLeaderboardId(std::wstring LeaderboardId, const std::vector<std::shared_ptr<FLeaderboardsUserScoreData>>** OutUserScores) const
{
	if (!OutUserScores)
	{
		return false;
	}

	auto it = CachedLeaderboardsUserScoresData.find(LeaderboardId);
	if (it != CachedLeaderboardsUserScoresData.end())
	{
		*OutUserScores = &(it->second);
		return true;
	}

	*OutUserScores = nullptr;
	return false;
}

void EOS_CALL FLeaderboard::LeaderboardUserScoresReceivedCallbackFn(const EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Leaderboards - Query User Scores Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] Leaderboards - Query User Scores Complete");

	FGame::Get().GetLeaderboard()->CacheLeaderboardUserScores();
}

void FLeaderboard::IngestStat(const std::wstring& StatName, int Amount)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Leaderboard - IngestStats: Current player is invalid!");
		return;
	}

	EOS_Stats_IngestStatOptions StatsIngestOptions = { 0 };
	StatsIngestOptions.ApiVersion = EOS_STATS_INGESTSTAT_API_LATEST;
	StatsIngestOptions.LocalUserId = Player->GetProductUserID();
	StatsIngestOptions.TargetUserId = Player->GetProductUserID();
	StatsIngestOptions.StatsCount = 1;

	EOS_Stats_IngestData* IngestData = new EOS_Stats_IngestData[StatsIngestOptions.StatsCount];

	IngestData[0].ApiVersion = EOS_STATS_INGESTDATA_API_LATEST;
	std::string Name = FStringUtils::Narrow(StatName);
	IngestData[0].StatName = Name.c_str();
	IngestData[0].IngestAmount = Amount;

	StatsIngestOptions.Stats = IngestData;

	EOS_Stats_IngestStat(StatsHandle, &StatsIngestOptions, nullptr, StatsIngestCallbackFn);

	delete[] IngestData;
}

void EOS_CALL FLeaderboard::StatsIngestCallbackFn(const EOS_Stats_IngestStatCompleteCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] FLeaderboard - Ingest Stats Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] FLeaderboard - Stats Ingest Complete");

	FGameEvent Event(EGameEventType::StatsIngested, Data->TargetUserId);
	FGame::Get().OnGameEvent(Event);
}
```

`EAC_SDK/Samples/Leaderboard/Source/Leaderboard.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_sdk.h>

struct FUserData;

/**
 * Leaderboard aggregation (used to sort leaderboard user scores).
 */
enum class ELeaderboardAggregation : unsigned int
{
	/** Minimum */
	Min,
	/** Maximum */
	Max,
	/** Sum */
	Sum,
	/** Latest */
	Latest
};

/**
 * Structure to store all data related to leaderboard definitions.
 */
struct FLeaderboardsDefinitionData
{
	FLeaderboardsDefinitionData() = default;

	/** Leaderboard ID that can be used to uniquely identify the leaderboard. */
	std::wstring LeaderboardId;
	/** Name of stat to rank scores by. */
	std::wstring StatName;
	/** Start Time. */
	int64_t StartTime;
	/** End Time. */
	int64_t EndTime;
	/** Aggregation. */
	ELeaderboardAggregation Aggregation;
};

/**
 * Structure to store all data related to leaderboard ranking records.
 */
struct FLeaderboardsRecordData
{
	FLeaderboardsRecordData() = default;

	/** Product User ID. */
	EOS_ProductUserId UserId;
	/** User name */
	std::wstring DisplayName;
	/** Sorted position on leaderboard. */
	uint32_t Rank;
	/** Leaderboard score. */
	int32_t Score;
};

/**
 * Structure to store all data related to leaderboard user scores.
 */
struct FLeaderboardsUserScoreData
{
	FLeaderboardsUserScoreData() = default;

	/** User ID. */
	EOS_ProductUserId UserId;
	/** Leaderboard score. */
	int32_t Score;
};

/**
* Manages leaderboard
*/
class FLeaderboard
{
public:
	/**
	* Constructor
	*/
	FLeaderboard() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FLeaderboard(FLeaderboard const&) = delete;
	FLeaderboard& operator=(FLeaderboard const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FLeaderboard();

	/**
	 * Initialization
	 */
	void Init();

	/**
	 * Update
	 */
	void Update();	

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/**
	 * Starts requesting leaderboard definitions
	 */
	void QueryDefinitions();

	/**
	 * Called after leaderboard definitions have been received, stores leaderboard definitions
	 */
	void CacheLeaderboardDefinitions();

	/**
	 * Prints info about Cached Leaderboard Definitions
	 */
	void PrintLeaderboardDefinitions();

	/**
	 * Gets stored leaderboard definitions
	 */
	std::vector<std::shared_ptr<FLeaderboardsDefinitionData>>& GetCachedDefinitions();

	/**
	 * Gets Ids for all stored leaderboard definitions
	 */
	std::vector<std::wstring> GetDefinitionIds();

	/**
	 * Retrieves leaderboard definition matching the leaderboard Id given
	 *
	 * @return True if definition is found, false otherwise
	 */
	bool GetDefinitionFromId(std::wstring LeaderboardId, std::shared_ptr<FLeaderboardsDefinitionData>& OutDef);

	/**
	 * Retrieves leaderboard definition matching the index for the leaderboard based on the order the definitions were stored
	 *
	 * @return True if definition is found, false otherwise
	 */
	bool GetDefinitionFromIndex(int InIndex, std::shared_ptr<FLeaderboardsDefinitionData>& OutDef);

	/**
	 * Starts requesting leaderboard ranks
	 */
	void QueryRanks(std::wstring LeaderboardId);

	/**
	 * Called after leaderboard ranks have been received, stores leaderboard records
	 */
	void CacheLeaderboardRecords();

	/**
	 * Prints info about cached leaderboard records
	 */
	void PrintLeaderboardRecords();

	/**
	 * Gets stored leaderboard records
	 */
	std::vector<std::shared_ptr<FLeaderboardsRecordData>>& GetCachedRecords();

	/**
	 * Starts requesting leaderboard user scores
	 */
	void QueryUserScores(std::vector<std::wstring> LeaderboardIds, std::vector<EOS_ProductUserId>& UserIds);

	/**
	 * Called after leaderboard user scores have been received, stores leaderboard user scores
	 */
	void CacheLeaderboardUserScores();

	/**
	 * Prints info about cached leaderboard user scores
	 */
	void PrintLeaderboardUserScores();

	/**
	 * Gets all stored leaderboard user scores
	 */
	const std::map<std::wstring, std::vector<std::shared_ptr<FLeaderboardsUserScoreData>>>& GetCachedUserScores() const;

	/**
	 * Gets stored leaderboard user scores for a given leaderboard
	 */
	bool GetCachedUserScoresFromLeaderboardId(std::wstring LeaderboardId, const std::vector<std::shared_ptr<FLeaderboardsUserScoreData>>** OutUserScores) const;

	/**
	 * Starts requesting stats ingest for single stat for logged in user
	 *
	 * @param StatName - Name of Stat to ingest
	 * @param Amount - Amount to ingest
	 */
	void IngestStat(const std::wstring& StatName, int Amount);
	
private:

	/**
	 * Called when a user has logged in
	 */
	void OnLoggedIn(FProductUserId UserId);

	/**
	 * Called when a user has logged out
	 */
	void OnLoggedOut(FProductUserId UserId);

	/**
	 * Callback called after leaderboard definitions have been retrieved
	 */
	static void EOS_CALL LeaderboardDefinitionsReceivedCallbackFn(const EOS_Leaderboards_OnQueryLeaderboardDefinitionsCompleteCallbackInfo* Data);

	/**
	 * Callback called after leaderboard ranks have been retrieved
	 */
	static void EOS_CALL LeaderboardRanksReceivedCallbackFn(const EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo* Data);

	/**
	 * Callback called after leaderboard user scores have been retrieved
	 */
	static void EOS_CALL LeaderboardUserScoresReceivedCallbackFn(const EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo* Data);

	/**
	 * Callback called after stats have been ingested
	 */
	static void EOS_CALL StatsIngestCallbackFn(const EOS_Stats_IngestStatCompleteCallbackInfo* Data);

	/** Handle to EOS SDK Leaderboards system */
	EOS_HLeaderboards LeaderboardsHandle;

	/** Handle to EOS SDK stats system */
	EOS_HStats StatsHandle;

	/** Cached data with leaderboard definitions */
	std::vector<std::shared_ptr<FLeaderboardsDefinitionData>> CachedLeaderboardsDefinitionData;

	/** Cached data with leaderboard ranking records */
	std::vector<std::shared_ptr<FLeaderboardsRecordData>> CachedLeaderboardsRecordData;

	/** Cached data with mapping from leaderboard ID to leaderboard user scores */
	std::map<std::wstring, std::vector<std::shared_ptr<FLeaderboardsUserScoreData>>> CachedLeaderboardsUserScoresData;

	/** How many user info queries need to wait before finishing leaderboard records query */
	size_t NumUserInfosLeft = 0;
};

```

`EAC_SDK/Samples/Leaderboard/Source/LeaderboardDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "Leaderboard.h"
#include "TextEditor.h"
#include "LeaderboardDialog.h"
#include "TableView.h"

const Vector2 StatsPosition = Vector2(10.0f, 120.0f);
const float ButtonsHeight = 30.0f;
const float HeaderLabelHeight = 20.0f;
const wchar_t* DefaultStatsLabelValue = L"NO LEADERBOARD SELECTED";

const bool bIsTestDataEnabled = false;
const int TestNumFriends = 100;
const int TestNumUsers = 1000;

static void RebuildTableEntriesWithRecordData(std::vector<FTableViewWidget::TableRowDataType>& TableData, FTableViewWidget::TableRowDataType& Labels)
{
	TableData.clear();
	Labels.Values.clear();

	Labels.Values.push_back(L"Rank");
	Labels.Values.push_back(L"Name");
	Labels.Values.push_back(L"Score");

	std::vector<std::shared_ptr<FLeaderboardsRecordData>>& Records = FGame::Get().GetLeaderboard()->GetCachedRecords();
	TableData.reserve(Records.size());

	for (const std::shared_ptr<FLeaderboardsRecordData>& NextRecord : Records)
	{
		if (NextRecord)
		{
			FTableViewWidget::TableRowDataType Row;
			wchar_t Buffer[64];
			wsprintf(Buffer, L"%d", NextRecord->Rank);
			Row.Values.emplace_back(Buffer);
			Row.Values.emplace_back(NextRecord->DisplayName);
			wsprintf(Buffer, L"%d", NextRecord->Score);
			Row.Values.emplace_back(Buffer);

			TableData.push_back(Row);
		}
	}
}

static void RebuildTableEntriesWithFriendsData(std::wstring LeaderboardId, std::vector<FTableViewWidget::TableRowDataType>& TableData, FTableViewWidget::TableRowDataType& Labels)
{
	TableData.clear();
	Labels.Values.clear();

	Labels.Values.push_back(L"Rank");
	Labels.Values.push_back(L"Name");
	Labels.Values.push_back(L"Score");

	const std::vector<std::shared_ptr<FLeaderboardsUserScoreData>>* FriendsScores;
	if (FGame::Get().GetLeaderboard()->GetCachedUserScoresFromLeaderboardId(LeaderboardId, &FriendsScores))
	{
		TableData.reserve(FriendsScores->size());

		size_t Index = 1;
		for (const std::shared_ptr<FLeaderboardsUserScoreData>& NextRecord : *FriendsScores)
		{
			if (NextRecord)
			{
				FTableViewWidget::TableRowDataType Row;

				wchar_t Buffer[64];
				wsprintf(Buffer, L"%d", Index);
				Row.Values.emplace_back(Buffer);
				Row.Values.emplace_back(FGame::Get().GetFriends()->GetFriendName(NextRecord->UserId));

				wsprintf(Buffer, L"%d", NextRecord->Score);
				Row.Values.emplace_back(Buffer);

				TableData.push_back(Row);

				Index++;
			}
		}
	}
}

FLeaderboardDialog::FLeaderboardDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	HeaderLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Vector2(500.0f, HeaderLabelHeight),
		Layer - 1,
		std::wstring(L"Leaderboard Data: "),
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	HeaderLabel->SetFont(DialogNormalFont);

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/texteditor.dds");

	DefinitionsList = std::make_shared<FDefinitionsList>(
		DialogPos,
		DialogSize - Vector2(0.0f, ButtonsHeight),
		DialogLayer - 1,
		30.0f, //entry height
		20.0f, //label height
		10.0f, //scroller width
		L"", //background
		L"",
		DialogNormalFont,
		DialogNormalFont,
		DialogSmallFont,
		DialogTinyFont);

	StatsTableLabel = std::make_shared<FTextLabelWidget>(
		StatsPosition,
		Vector2(500.0f, 20.0f),
		Layer - 1,
		std::wstring(DefaultStatsLabelValue),
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	StatsTableLabel->SetFont(DialogNormalFont);
	StatsTableLabel->SetBorderColor(Color::UIBorderGrey);

	const Vector2 FirstButtonPos = StatsPosition + Vector2(5.0f, HeaderLabelHeight);
	UpdateSelectedButton = std::make_shared<FButtonWidget>(
		FirstButtonPos,
		Vector2(DialogSize.x, 30.0f),
		DialogLayer - 1,
		L"SHOW GLOBAL",
		assets::LargeButtonAssets,
		DialogSmallFont,
		Color::White,
		Color::White
		);
	UpdateSelectedButton->SetOnPressedCallback([this]()
	{
		this->QueryGlobalRankings();
	});
	UpdateSelectedButton->SetBackgroundColors(assets::DefaultButtonColors);

	UpdateFriendRanksButton = std::make_shared<FButtonWidget>(
		FirstButtonPos + Vector2(UpdateSelectedButton->GetSize().x + 10.0f, 0.0f),
		Vector2(DialogSize.x, 30.0f),
		DialogLayer - 1,
		L"SHOW FRIENDS",
		assets::LargeButtonAssets,
		DialogSmallFont,
		Color::White,
		Color::White
		);
	UpdateFriendRanksButton->SetOnPressedCallback([this]()
	{
		this->QueryFriends();
	});
	UpdateFriendRanksButton->SetBackgroundColors(assets::DefaultButtonColors);

	RefreshButton = std::make_shared<FButtonWidget>(
		UpdateFriendRanksButton->GetPosition() + Vector2(UpdateFriendRanksButton->GetSize().x + 10.0f, 0.0f),
		Vector2(ButtonsHeight, ButtonsHeight),
		DialogLayer - 1,
		L"",
		std::vector<std::wstring>({ L"Assets/refresh.dds" }),
		DialogSmallFont,
		Color::White,
		Color::White
		);
	RefreshButton->SetOnPressedCallback([this]()
	{
		this->RepeatLastQuery();
	});
	RefreshButton->SetBackgroundColors(assets::DefaultButtonColors);

	StatsTable = std::make_shared<FTableViewWidget>(
		StatsPosition + Vector2(0.0f, HeaderLabelHeight + ButtonsHeight),
		Vector2(500.0f, 500.0f),
		DialogLayer - 1,
		L"",
		10.0f, //scroller width
		std::vector<FTableRowData>(),
		FTableRowData());
	StatsTable->SetFonts(DialogNormalFont, DialogSmallFont);

	StatsBackground = std::make_shared<FSpriteWidget>(
		StatsPosition + Vector2(0.0f, HeaderLabelHeight),
		Vector2(500.0f, 500.0f - HeaderLabelHeight),
		DialogLayer,
		L"Assets/texteditor.dds");
	StatsBackground->SetBorderColor(Color::UIBorderGrey);
}

void FLeaderboardDialog::Update()
{
	Definitions = FGame::Get().GetLeaderboard()->GetDefinitionIds();

	if (DefinitionsList)
	{
		std::vector<std::wstring> DefinitionIds = FGame::Get().GetLeaderboard()->GetDefinitionIds();
		DefinitionsList->RefreshData(DefinitionIds);
	}

	FDialog::Update();

	if (DefinitionsList)
	{
		DefinitionsList->Update();
	}

	FDialog::Update();
}

void FLeaderboardDialog::Create()
{
	if (HeaderLabel) HeaderLabel->Create();
	if (BackgroundImage) BackgroundImage->Create();
	if (DefinitionsList) DefinitionsList->Create();
	if (StatsTableLabel) StatsTableLabel->Create();
	if (StatsTable) StatsTable->Create();
	if (StatsBackground) StatsBackground->Create();
	if (UpdateSelectedButton) UpdateSelectedButton->Create();
	if (UpdateFriendRanksButton) UpdateFriendRanksButton->Create();
	if (RefreshButton) RefreshButton->Create();

	//make entries invisible until player logs in
	if (DefinitionsList)
	{
		DefinitionsList->SetEntriesVisible(false);
		DefinitionsList->SetOnEntrySelectedCallback([this](size_t Index) { this->OnDefinitionEntrySelected(Index); });
	}

	AddWidget(HeaderLabel);
	AddWidget(BackgroundImage);
	AddWidget(DefinitionsList);
	AddWidget(StatsBackground);
	AddWidget(StatsTableLabel);
	AddWidget(StatsTable);
	AddWidget(UpdateSelectedButton);
	AddWidget(UpdateFriendRanksButton);
	AddWidget(RefreshButton);

	if (UpdateSelectedButton) UpdateSelectedButton->Disable();
	if (UpdateFriendRanksButton) UpdateFriendRanksButton->Disable();
	if (RefreshButton) RefreshButton->Disable();
}

void FLeaderboardDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (HeaderLabel) HeaderLabel->SetPosition(Pos);
	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y + 20.f));
	if (DefinitionsList) DefinitionsList->SetPosition(Position);
	if (StatsTableLabel) StatsTableLabel->SetPosition(StatsPosition);
	if (StatsBackground) StatsBackground->SetPosition(StatsPosition + Vector2(0.0f, HeaderLabelHeight));

	Vector2 FirstButtonPos = StatsPosition + Vector2(5.0f, HeaderLabelHeight);
	if (UpdateSelectedButton) UpdateSelectedButton->SetPosition(FirstButtonPos);
	if (UpdateFriendRanksButton) UpdateFriendRanksButton->SetPosition(FirstButtonPos + Vector2(UpdateSelectedButton->GetSize().x + 10.0f, 0.0f));
	if (RefreshButton) RefreshButton->SetPosition(UpdateFriendRanksButton->GetPosition() + Vector2(UpdateFriendRanksButton->GetSize().x + 10.0f, 0.0f));

	if (StatsTable) StatsTable->SetPosition(StatsPosition + Vector2(0.0f, ButtonsHeight));
}

void FLeaderboardDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);
}

void FLeaderboardDialog::SetWindowSize(Vector2 WindowSize)
{
	const Vector2 DefListSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 40.0f, WindowSize.y - 200.0f - StatsPosition.y);
	const Vector2 DialogSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 30.0f, WindowSize.y - 90.0f);

	if (BackgroundImage) BackgroundImage->SetSize(DialogSize);
	if (HeaderLabel) HeaderLabel->SetSize(Vector2(DialogSize.x, HeaderLabelHeight));
	if (DefinitionsList) DefinitionsList->SetSize(DefListSize);
	if (StatsTable) StatsTable->SetSize(Vector2(ConsoleWindowProportion.x * WindowSize.x, (1.0f - ConsoleWindowProportion.y) * WindowSize.y - StatsPosition.y - 80.0f));
	if (StatsTableLabel) StatsTableLabel->SetSize(Vector2(StatsTable->GetSize().x, HeaderLabelHeight));
	if (StatsBackground) StatsBackground->SetSize(StatsTable->GetSize() + Vector2(0.0f, ButtonsHeight));
	if (UpdateSelectedButton) UpdateSelectedButton->SetSize(Vector2(120.0f, ButtonsHeight));
	if (UpdateFriendRanksButton) UpdateFriendRanksButton->SetSize(Vector2(120.0f, ButtonsHeight));
	if (RefreshButton) RefreshButton->SetSize(Vector2(ButtonsHeight, ButtonsHeight));
}


void FLeaderboardDialog::ClearDataList()
{
	if (DefinitionsList)
	{
		DefinitionsList->Reset();
	}
	
	if (StatsTable)
	{
		StatsTable->Clear();
	}

	if (StatsTableLabel)
	{
		StatsTableLabel->SetText(DefaultStatsLabelValue);
	}
}

void FLeaderboardDialog::ShowUI()
{
	if (DefinitionsList)
	{
		DefinitionsList->SetEntriesVisible(true);
	}

	if (UpdateSelectedButton)
	{
		UpdateSelectedButton->Enable();
		UpdateSelectedButton->Show();
	}

	if (UpdateFriendRanksButton)
	{
		UpdateFriendRanksButton->Enable();
		UpdateFriendRanksButton->Show();
	}

	if (RefreshButton)
	{
		RefreshButton->Enable();
		RefreshButton->Show();
	}
}

void FLeaderboardDialog::HideUI()
{
	if (DefinitionsList)
	{
		DefinitionsList->SetEntriesVisible(false);
	}

	if (UpdateSelectedButton)
	{
		UpdateSelectedButton->Disable();
		UpdateSelectedButton->Hide();
	}

	if (UpdateFriendRanksButton)
	{
		UpdateFriendRanksButton->Disable();
		UpdateFriendRanksButton->Hide();
	}

	if (RefreshButton)
	{
		RefreshButton->Disable();
		RefreshButton->Hide();
	}

	SetFocused(false);
}

void FLeaderboardDialog::ClearCurrentSelection()
{
	CurrentSelection.clear();
	if (DefinitionsList)
	{
		DefinitionsList->SetFocused(false);
	}
	if (StatsTable)
	{
		StatsTable->Clear();
	}
}


void FLeaderboardDialog::UpdateUserInfo()
{
	if (HeaderLabel)
	{
		HeaderLabel->SetText(L"Leaderboard: log in to proceed.");
		if (FPlayerManager::Get().GetCurrentUser().IsValid())
		{
			std::wstring DisplayName = FPlayerManager::Get().GetDisplayName(FPlayerManager::Get().GetCurrentUser());
			HeaderLabel->SetText(std::wstring(L"Leaderboard: ") + DisplayName);
		}
	}
}

void FLeaderboardDialog::OnQueryInitiated()
{
	if (StatsTableLabel)
	{
		StatsTableLabel->SetText(FStringUtils::ToUpper(CurrentSelection));
	}

	if (StatsTable)
	{
		StatsTable->Clear();
	}

	LastSelection = CurrentSelection;
	bLastQueryWasFriends = bWaitingForFriendsUpdate;
}

void FLeaderboardDialog::QueryFriends()
{
	if (bIsTestDataEnabled)
	{
		ShowTestFriendsData();
		return;
	}

	if (!CurrentSelection.empty())
	{
		std::vector<EOS_ProductUserId> Friends;
		const std::vector<FFriendData>& FriendData = FGame::Get().GetFriends()->GetFriends();
		for (const FFriendData& NextFriend : FriendData)
		{
			Friends.push_back(NextFriend.UserProductUserId);
		}

		if (!Friends.empty())
		{
			bWaitingForFriendsUpdate = true;
			std::vector<std::wstring> LeaderboardIds;
			LeaderboardIds.emplace_back(CurrentSelection);
			FGame::Get().GetLeaderboard()->QueryUserScores(LeaderboardIds, Friends);
		}

		OnQueryInitiated();
	}
}

void FLeaderboardDialog::QueryGlobalRankings()
{
	if (bIsTestDataEnabled)
	{
		ShowTestGlobalData();
		return;
	}

	if (!CurrentSelection.empty())
	{
		bWaitingForFriendsUpdate = false;
		FGame::Get().GetLeaderboard()->QueryRanks(CurrentSelection);

		OnQueryInitiated();
	}
}

void FLeaderboardDialog::RepeatLastQuery()
{
	if (!LastSelection.empty())
	{
		//do the same query
		CurrentSelection = LastSelection;
		if (bLastQueryWasFriends)
		{
			QueryFriends();
		}
		else
		{
			QueryGlobalRankings();
		}
	}
}

void FLeaderboardDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		LastSelection.clear();
		UpdateUserInfo();
		ShowUI();
	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		UpdateUserInfo();
		DefinitionsList->SetEntriesVisible(false);
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		UpdateUserInfo();
		DefinitionsList->SetEntriesVisible(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		UpdateUserInfo();
		if (FPlayerManager::Get().GetNumPlayers() == 0)
		{
			ClearDataList();
			HideUI();
		}
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		ClearDataList();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		ClearDataList();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		UpdateUserInfo();
		ClearDataList();
		HideUI();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		ShowUI();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::LeaderboardRecordsReceived)
	{
		//Retrieve data and populate stats table
		if (bWaitingForFriendsUpdate)
		{
			//Friends
			std::vector<FTableViewWidget::TableRowDataType> TableRows;
			FTableViewWidget::TableRowDataType Labels;
			RebuildTableEntriesWithFriendsData(CurrentSelection, TableRows, Labels);
			StatsTable->RefreshData(std::move(TableRows));
			StatsTable->RefreshLabels(std::move(Labels));
		}
		else
		{
			//Global rankings
			std::vector<FTableViewWidget::TableRowDataType> TableRows;
			FTableViewWidget::TableRowDataType Labels;
			RebuildTableEntriesWithRecordData(TableRows, Labels);
			StatsTable->RefreshData(std::move(TableRows));
			StatsTable->RefreshLabels(std::move(Labels));
		}
	}
}

void FLeaderboardDialog::OnDefinitionEntrySelected(size_t Index)
{
	if (Index < Definitions.size())
	{
		std::wstring Name = Definitions[Index];

		CurrentSelection = Name;
	}
}

void FLeaderboardDialog::ShowTestFriendsData()
{
	std::vector<FTableViewWidget::TableRowDataType> TableRows;
	FTableViewWidget::TableRowDataType Labels;

	Labels.Values.push_back(L"Rank");
	Labels.Values.push_back(L"Name");
	Labels.Values.push_back(L"Score");

	TableRows.reserve(TestNumFriends);

	for (int UserIndex = 1; UserIndex <= TestNumFriends; ++UserIndex)
	{
		std::wstring UserIndexStr = std::to_wstring(UserIndex);

		FTableViewWidget::TableRowDataType Row;

		Row.Values.emplace_back(UserIndexStr);
		Row.Values.emplace_back(L"Friend " + UserIndexStr);
		Row.Values.emplace_back(L"" + std::to_wstring((TestNumFriends - UserIndex + 1)));
		
		TableRows.push_back(Row);
	}

	StatsTable->RefreshData(std::move(TableRows));
	StatsTable->RefreshLabels(std::move(Labels));

	StatsTableLabel->SetText(L"First");
}

void FLeaderboardDialog::ShowTestGlobalData()
{
	std::vector<FTableViewWidget::TableRowDataType> TableRows;
	FTableViewWidget::TableRowDataType Labels;

	Labels.Values.push_back(L"Rank");
	Labels.Values.push_back(L"Name");
	Labels.Values.push_back(L"Score");

	TableRows.reserve(TestNumUsers);

	for (int UserIndex = 1; UserIndex <= TestNumUsers; ++UserIndex)
	{
		std::wstring UserIndexStr = std::to_wstring(UserIndex);

		FTableViewWidget::TableRowDataType Row;

		Row.Values.emplace_back(UserIndexStr);
		Row.Values.emplace_back(L"User " + UserIndexStr);
		Row.Values.emplace_back(L"" + std::to_wstring((TestNumUsers - UserIndex + 1)));

		TableRows.push_back(Row);
	}

	StatsTable->RefreshData(std::move(TableRows));
	StatsTable->RefreshLabels(std::move(Labels));

	StatsTableLabel->SetText(L"Second");
}

```

`EAC_SDK/Samples/Leaderboard/Source/LeaderboardDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "ListView.h"
#include "SelectableStringViewListEntry.h"
#include "TableView.h"

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;
class FTextEditorWidget;

/**
 * Player Data Storage dialog
 */
class FLeaderboardDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FLeaderboardDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FLeaderboardDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	void SetWindowSize(Vector2 WindowSize);
	void SetWindowProportion(Vector2 InWindowProportion) { ConsoleWindowProportion = InWindowProportion; }


	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	void OnDefinitionEntrySelected(size_t Index);
	void ClearDataList();
	void ShowUI();
	void HideUI();
	void ClearCurrentSelection();
	void UpdateUserInfo();
	void OnQueryInitiated();
	void QueryFriends();
	void QueryGlobalRankings();
	void RepeatLastQuery();

	// Test
	void ShowTestFriendsData();
	void ShowTestGlobalData();

private:
	/** Header label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** List of leaderboard definitions to pick from */
	using FDefinitionsList = FListViewWidget<std::wstring, FSelectableStringViewListEntry>;
	std::shared_ptr<FDefinitionsList> DefinitionsList;

	/** Stats label */
	std::shared_ptr<FTextLabelWidget> StatsTableLabel;

	/** Table with stats */
	std::shared_ptr<FTableViewWidget> StatsTable;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> StatsBackground;

	/** Button to update stats for selected definition */
	std::shared_ptr<FButtonWidget> UpdateSelectedButton;

	/** Button to update friends' ranks */
	std::shared_ptr<FButtonWidget> UpdateFriendRanksButton;

	/** Button to refresh current selection */
	std::shared_ptr<FButtonWidget> RefreshButton;

	/** Available definitions */
	std::vector<std::wstring> Definitions;

	/** Currently selected definition */
	std::wstring CurrentSelection;

	/** Part of window that console is taking */
	Vector2 ConsoleWindowProportion;

	/** Are we currently waiting for friends update */
	bool bWaitingForFriendsUpdate = false;

	/** What was the selection for last query */
	std::wstring LastSelection;

	/** Were we querying for friends last time */
	bool bLastQueryWasFriends = false;
};

```

`EAC_SDK/Samples/Leaderboard/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/Leaderboard/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "LeaderboardDialog.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "PopupDialog.h"

const Vector2 ConsoleDialogSizeProportion = Vector2(0.68f, 0.35f);

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false) :
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreateLeaderboardDialog();

	FBaseMenu::Create();
}

void FMenu::Release()
{
	FBaseMenu::Release();

	if (LeaderboardDialog)
	{
		LeaderboardDialog->Release();
		LeaderboardDialog.reset();
	}
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * ConsoleDialogSizeProportion.x, WindowSize.y * ConsoleDialogSizeProportion.y);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (LeaderboardDialog)
		{
			LeaderboardDialog->SetWindowSize(WindowSize);

			Vector2 LeaderboardDialogSize = Vector2(WindowSize.x - ConsoleDialog->GetSize().x - 30.f, WindowSize.y - 130.0f);
			LeaderboardDialog->SetSize(LeaderboardDialogSize);

			Vector2 LeaderboardDialogPos = Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
				WindowSize.y - LeaderboardDialogSize.y - 10.f);
			LeaderboardDialog->SetPosition(LeaderboardDialogPos);
		}
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::CreateAuthDialogs()
{
	AuthDialogs = std::make_shared<FAuthDialogs>(
		LeaderboardDialog,
		L"Leaderboard",
		BoldSmallFont->GetFont(),
		SmallFont->GetFont(),
		TinyFont->GetFont());

	AuthDialogs->SetUserLabelOffset(Vector2(-30.0f, -10.0f));
	AuthDialogs->Create();
	AuthDialogs->SetSingleUserOnly(true);
}

void FMenu::CreateLeaderboardDialog()
{
	const float FX = 100.0f;
	const float FY = 100.0f;
	const float Width = 300.0f;
	const float Height = 300.0f;

	LeaderboardDialog = std::make_shared<FLeaderboardDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	LeaderboardDialog->SetWindowProportion(ConsoleDialogSizeProportion);
	LeaderboardDialog->SetBorderColor(Color::UIBorderGrey);
	
	LeaderboardDialog->Create();

	AddDialog(LeaderboardDialog);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	FBaseMenu::OnGameEvent(Event);

	if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		UpdateLeaderboardDialog();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		UpdateLeaderboardDialog();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		UpdateLeaderboardDialog();
	}

	if (LeaderboardDialog) LeaderboardDialog->OnGameEvent(Event);
}

void FMenu::UpdateLeaderboardDialog()
{
	if (LeaderboardDialog)
	{
		LeaderboardDialog->SetPosition(Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
			LeaderboardDialog->GetPosition().y));
	}
}

```

`EAC_SDK/Samples/Leaderboard/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FLeaderboardDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> console) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	virtual void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

protected:
	/** 
	 * Create auth dialogs
	 */
	virtual void CreateAuthDialogs() override;

	/**
	 * Creates achievements definitions dialog
	 */
	void CreateLeaderboardDialog();

	/** 
	 * Updates leaderboard dialog
	 */
	void UpdateLeaderboardDialog();

	/** Leaderboard Dialog */
	std::shared_ptr<FLeaderboardDialog> LeaderboardDialog;
};
```

`EAC_SDK/Samples/Leaderboard/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Leaderboard";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/Leaderboard/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/Leaderboard/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/Lobbies/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/Lobbies/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/Lobbies/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/Lobbies/Lobbies.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>SimpleFramework</RootNamespace>
    <ProjectGuid>{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Lobbies</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_LOBBIES;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Lobbies/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_LOBBIES;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Lobbies/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_LOBBIES;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Lobbies/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_LOBBIES;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Lobbies/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_LOBBIES;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Lobbies/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_LOBBIES;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Lobbies/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_LOBBIES;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Lobbies/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_LOBBIES;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Lobbies/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\DropDownList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableRowView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\LobbyInviteReceivedDialog.h" />
    <ClInclude Include="Source\LobbyMemberTableRowView.h" />
    <ClInclude Include="Source\LobbySearchResultTableRowView.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\NewLobbyDialog.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\Lobbies.h" />
    <ClInclude Include="Source\LobbiesDialog.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\DropDownList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TableRowView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\LobbyInviteReceivedDialog.cpp" />
    <ClCompile Include="Source\LobbyMemberTableRowView.cpp" />
    <ClCompile Include="Source\LobbySearchResultTableRowView.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\Lobbies.cpp" />
    <ClCompile Include="Source\LobbiesDialog.cpp" />
    <ClCompile Include="Source\NewLobbyDialog.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="..\Shared\Source\Graphics\GUI\TableView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/Lobbies/Lobbies.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="Source\LobbiesDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Lobbies.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\DropDownList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableRowView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="Source\NewLobbyDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\LobbyInviteReceivedDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="Source\LobbyMemberTableRowView.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\LobbySearchResultTableRowView.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
	<ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="Source\LobbiesDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Lobbies.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\DropDownList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TableRowView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="Source\NewLobbyDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\LobbyInviteReceivedDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="Source\LobbyMemberTableRowView.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\LobbySearchResultTableRowView.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\TableView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/Lobbies/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "GameEvent.h"
#include "Platform.h"
#include "Main.h"
#include "Game.h"
#include "Lobbies.h"

const double MaxTimeToShutdown = 7.0; //7 seconds


FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	Lobbies = std::make_unique<FLobbies>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
	
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" CURRENTLOBBY - to print out current lobby info;",
			L" FINDLOBBY lobby_id - to perform a lobby search;",
			L" FINDLOBBYBYBUCKETID bucket_id - to perform a lobby search by bucketid;",
			L" FINDLOBBYBYLEVEL level - to perform a lobby search by type;",
			L" CREATELOBBY bucketid level maxusers [public] [rtcenable] - to create lobby;"
		};
		AppendHelpMessageLines(ExtraHelpMessageLines);

		Console->AddCommand(L"CURRENTLOBBY", [](const std::vector<std::wstring>&)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetLobbies())
				{
					if (FGame::Get().GetLobbies()->GetCurrentLobby().IsValid())
					{
						FDebugLog::Log(L"Current lobby id: %ls", FStringUtils::Widen(FGame::Get().GetLobbies()->GetCurrentLobby().Id).c_str());
					}
					else
					{
						FDebugLog::LogError(L"No current lobby.");
					}
				}
				else
				{
					FDebugLog::LogError(L"EOS SDK Lobbies are not initialized!");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
		Console->AddCommand(L"FINDLOBBY", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetLobbies())
				{
					if (args.size() == 1)
					{
						FGame::Get().GetLobbies()->Search(FStringUtils::Narrow(args[0]), 1);
					}
					else
					{
						FDebugLog::LogError(L"Lobby id is required as the only argument.");
					}
				}
				else
				{
					FDebugLog::LogError(L"EOS SDK Lobbies are not initialized!");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
		Console->AddCommand(L"FINDLOBBYBYBUCKETID", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetLobbies())
				{
					if (args.size() == 1)
					{
						FGame::Get().GetLobbies()->SearchLobbyByBucketId(FStringUtils::Narrow(args[0]));
					}
					else
					{
						FDebugLog::LogError(L"BacketId is required as the only argument.");
					}
				}
				else
				{
					FDebugLog::LogError(L"EOS SDK Lobbies are not initialized!");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
		Console->AddCommand(L"FINDLOBBYBYLEVEL", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetLobbies())
				{
					if (args.size() == 1)
					{
						FGame::Get().GetLobbies()->SearchLobbyByLevel(FStringUtils::Narrow(FStringUtils::ToUpper(args[0])));
					}
					else
					{
						FDebugLog::LogError(L"Lobby's type is required as the only argument.");
					}
				}
				else
				{
					FDebugLog::LogError(L"EOS SDK Lobbies are not initialized!");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
		Console->AddCommand(L"CREATELOBBY", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetLobbies())
				{
					if (FGame::Get().GetLobbies()->GetCurrentLobby().IsValid())
					{
						FDebugLog::LogError(L"You already in lobby!");
					}
					else if (args.size() >= 3)
					{
						bool bPublicPermission = false;
						bool bRTCEnable = false;
						if (args.size() > 3)
						{
							for (int i = 3; i < (int)args.size(); i++)
							{
								if (FStringUtils::ToUpper(args[i]) == L"PUBLIC")
								{
									bPublicPermission = true;
								}
								else if (FStringUtils::ToUpper(args[i]) == L"RTCENABLE")
								{
									bRTCEnable = true;
								}
							}
						}
						FLobby Lobby;
						Lobby.MaxNumLobbyMembers = atoi(FStringUtils::Narrow(args[2]).c_str());
						Lobby.Permission = (bPublicPermission ? EOS_ELobbyPermissionLevel::EOS_LPL_PUBLICADVERTISED : EOS_ELobbyPermissionLevel::EOS_LPL_INVITEONLY);
						Lobby.bPresenceEnabled = true;
						Lobby.bRTCRoomEnabled = bRTCEnable;
						Lobby.bAllowInvites = true;
						Lobby.BucketId = FStringUtils::Narrow(args[0]);

						FLobbyAttribute Attribute;
						Attribute.Key = "LEVEL";
						Attribute.AsString = FStringUtils::Narrow(args[1]);
						Attribute.ValueType = FLobbyAttribute::String;
						Attribute.Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;

						Lobby.Attributes.push_back(Attribute);

						FGame::Get().GetLobbies()->CreateLobby(Lobby);
					}
					else
					{
						FDebugLog::LogError(L"Additional parameters required. Use help command");
					}
				}
				else
				{
					FDebugLog::LogError(L"EOS SDK Lobbies are not initialized!");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

	}
}

void FGame::Update()
{
	FBaseGame::Update();

	Lobbies->Update();
}



void FGame::Create()
{
	FBaseGame::Create();

	Lobbies->SubscribeToLobbyInvites();
	Lobbies->SubscribeToLobbyUpdates();
	Lobbies->SubscribeToLeaveLobbyUI();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);
	Lobbies->OnGameEvent(Event);
}

void FGame::OnShutdown()
{
	//Lobbies must be cleared before we destroy SDK platform.
	if (Lobbies)
	{
		Lobbies->OnShutdown();
	}

	FBaseGame::OnShutdown();

	ShutdownTriggeredTimestamp = Main->GetTimer().GetTotalSeconds();
}

bool FGame::IsShutdownDelayed()
{
	if (Lobbies && (Main->GetTimer().GetTotalSeconds() - ShutdownTriggeredTimestamp) < MaxTimeToShutdown)
	{
		return !Lobbies->IsReadyToShutdown();
	}

	return false;
}

const std::unique_ptr<FLobbies>& FGame::GetLobbies()
{
	return Lobbies;
}

```

`EAC_SDK/Samples/Lobbies/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FLobbies;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Create Resources
	*/
	virtual void Create() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	* Called just before shutting down the game. Allows to finish current operations.
	*/
	virtual void OnShutdown() override;

	/**
	* Called in the process of shutdown. Shutdown is delayed until this function returns false.
	* This allows to finish and cleanup something before shutting down.
	*/
	virtual bool IsShutdownDelayed() override;

	/**
	 * Getter for lobbies component.
	 */
	const std::unique_ptr<FLobbies>& GetLobbies();

protected:
	/**
	* Creates all console commands
	*/
	virtual void CreateConsoleCommands() override;

	/** Lobbies component */
	std::unique_ptr<FLobbies> Lobbies;

	/** Timestamp to know when shutdown was triggered */
	double ShutdownTriggeredTimestamp = 0.0;
};


```

`EAC_SDK/Samples/Lobbies/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/Lobbies/Source/Lobbies.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "Lobbies.h"
#include <eos_sdk.h>
#include <eos_lobby.h>
#include <eos_rtc.h>
#include <eos_rtc_audio.h>
#include <eos_rtc_data.h>

void FLobby::InitFromLobbyHandle(EOS_LobbyId InId)
{
	if (InId == nullptr)
	{
		return;
	}

	Id = InId;

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());
	if (!LobbyHandle)
	{
		FDebugLog::LogError(L"Lobbies: can't get lobby interface.");
		return;
	}

	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Lobbies - InitLobbyFromHandle: Current player is invalid!");
		return;
	}

	EOS_Lobby_CopyLobbyDetailsHandleOptions CopyHandleOptions = {};
	CopyHandleOptions.ApiVersion = EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST;
	CopyHandleOptions.LobbyId = Id.c_str();
	CopyHandleOptions.LocalUserId = Player->GetProductUserID();

	EOS_HLobbyDetails LobbyDetailsHandle = nullptr;
	EOS_EResult Result;
	Result = EOS_Lobby_CopyLobbyDetailsHandle(LobbyHandle, &CopyHandleOptions, &LobbyDetailsHandle);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies: can't get lobby info handle. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	LobbyDetailsKeeper DetailsKeeper = MakeLobbyDetailsKeeper(LobbyDetailsHandle);

	InitFromLobbyDetails(DetailsKeeper.get());
}

void FLobby::InitFromLobbyDetails(EOS_HLobbyDetails LobbyDetailsId)
{
	//get owner
	EOS_LobbyDetails_GetLobbyOwnerOptions GetOwnerOptions = {};
	GetOwnerOptions.ApiVersion = EOS_LOBBYDETAILS_GETLOBBYOWNER_API_LATEST;
	FProductUserId NewLobbyOwner = EOS_LobbyDetails_GetLobbyOwner(LobbyDetailsId, &GetOwnerOptions);
	if (NewLobbyOwner != LobbyOwner)
	{
		LobbyOwner = NewLobbyOwner;
		LobbyOwnerAccountId = FEpicAccountId();
		LobbyOwnerDisplayName.clear();
	}

	//copy lobby info
	EOS_LobbyDetails_CopyInfoOptions CopyInfoDetails = {};
	CopyInfoDetails.ApiVersion = EOS_LOBBYDETAILS_COPYINFO_API_LATEST;
	EOS_LobbyDetails_Info* LobbyInfo = nullptr;
	EOS_EResult Result = EOS_LobbyDetails_CopyInfo(LobbyDetailsId, &CopyInfoDetails, &LobbyInfo);
	if (Result != EOS_EResult::EOS_Success || !LobbyInfo)
	{
		FDebugLog::LogError(L"Lobbies: can't copy lobby info. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	Id = LobbyInfo->LobbyId;
	MaxNumLobbyMembers = LobbyInfo->MaxMembers;
	Permission = LobbyInfo->PermissionLevel;
	bAllowInvites = LobbyInfo->bAllowInvites;
	AvailableSlots = LobbyInfo->AvailableSlots;
	BucketId.assign(LobbyInfo->BucketId);
	bRTCRoomEnabled = LobbyInfo->bRTCRoomEnabled != EOS_FALSE;
	bPresenceEnabled = LobbyInfo->bPresenceEnabled != EOS_FALSE;

	EOS_LobbyDetails_Info_Release(LobbyInfo);


	//get attributes
	Attributes.clear();
	EOS_LobbyDetails_GetAttributeCountOptions CountOptions = {};
	CountOptions.ApiVersion = EOS_LOBBYDETAILS_GETATTRIBUTECOUNT_API_LATEST;
	const uint32_t AttrCount = EOS_LobbyDetails_GetAttributeCount(LobbyDetailsId, &CountOptions);
	for (uint32_t AttrIndex = 0; AttrIndex < AttrCount; ++AttrIndex)
	{
		EOS_LobbyDetails_CopyAttributeByIndexOptions AttrOptions = {};
		AttrOptions.ApiVersion = EOS_LOBBYDETAILS_COPYATTRIBUTEBYINDEX_API_LATEST;
		AttrOptions.AttrIndex = AttrIndex;
		
		EOS_Lobby_Attribute* Attr = NULL;
		EOS_EResult AttrCopyResult = EOS_LobbyDetails_CopyAttributeByIndex(LobbyDetailsId, &AttrOptions, &Attr);
		if (AttrCopyResult == EOS_EResult::EOS_Success && Attr->Data)
		{
			FLobbyAttribute NextAttribute;
			NextAttribute.InitFromAttribute(Attr);
			Attributes.push_back(NextAttribute);
		}

		//Release attribute
		EOS_Lobby_Attribute_Release(Attr);
	}

	//get members
	std::vector<FLobbyMember> OldMembers(std::move(Members));
	Members.clear();

	EOS_LobbyDetails_GetMemberCountOptions MemberCountOptions = {};
	MemberCountOptions.ApiVersion = EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST;
	const uint32_t MemberCount = EOS_LobbyDetails_GetMemberCount(LobbyDetailsId, &MemberCountOptions);
	Members.resize(MemberCount);
	for (uint32_t MemberIndex = 0; MemberIndex < MemberCount; ++MemberIndex)
	{
		EOS_LobbyDetails_GetMemberByIndexOptions MemberOptions = {};
		MemberOptions.ApiVersion = EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST;
		MemberOptions.MemberIndex = MemberIndex;
		EOS_ProductUserId MemberId = EOS_LobbyDetails_GetMemberByIndex(LobbyDetailsId, &MemberOptions);
		Members[MemberIndex].ProductId = MemberId;

		//member attributes
		EOS_LobbyDetails_GetMemberAttributeCountOptions MemberAttrCountOptions = {};
		MemberAttrCountOptions.ApiVersion = EOS_LOBBYDETAILS_GETMEMBERATTRIBUTECOUNT_API_LATEST;
		MemberAttrCountOptions.TargetUserId = MemberId;
		const uint32_t MemberAttrCount = EOS_LobbyDetails_GetMemberAttributeCount(LobbyDetailsId, &MemberAttrCountOptions);
		Members[MemberIndex].MemberAttributes.resize(MemberAttrCount);
		for (uint32_t AttributeIndex = 0; AttributeIndex < MemberAttrCount; ++AttributeIndex)
		{
			EOS_LobbyDetails_CopyMemberAttributeByIndexOptions MemberAttrCopyOptions = {};
			MemberAttrCopyOptions.ApiVersion = EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYINDEX_API_LATEST;
			MemberAttrCopyOptions.AttrIndex = AttributeIndex;
			MemberAttrCopyOptions.TargetUserId = MemberId;
			EOS_Lobby_Attribute* MemberAttribute = nullptr;
			Result = EOS_LobbyDetails_CopyMemberAttributeByIndex(LobbyDetailsId, &MemberAttrCopyOptions, &MemberAttribute);
			if (Result != EOS_EResult::EOS_Success)
			{
				FDebugLog::LogError(L"Lobbies: can't copy member attribute. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
				continue;
			}

			FLobbyAttribute NewAttribute;
			NewAttribute.InitFromAttribute(MemberAttribute);
			Members[MemberIndex].MemberAttributes[AttributeIndex] = NewAttribute;
			if (NewAttribute.Key == "SKIN")
			{
				Members[MemberIndex].InitSkinFromString(NewAttribute.AsString);
			}

			EOS_Lobby_Attribute_Release(MemberAttribute);
		}

		// Copy RTC Status from OldMembers
		for (const FLobbyMember& OldMember : OldMembers)
		{
			FLobbyMember& NewMember = Members[MemberIndex];
			if (OldMember.ProductId != Members[MemberIndex].ProductId)
			{
				continue;
			}

			// Copy RTC status to new object
			NewMember.RTCState = OldMember.RTCState;
			NewMember.CurrentColor = OldMember.CurrentColor;
			break;
		}
	}
}

FLobbySearch::~FLobbySearch()
{
	Release();
}

void FLobbySearch::Release()
{
	SearchResults.clear();

	if (SearchHandle)
	{
		EOS_LobbySearch_Release(SearchHandle);
		SearchHandle = nullptr;
	}

	ResultHandles.clear();
}

void FLobbySearch::SetNewSearch(EOS_HLobbySearch Handle)
{
	Release();
	SearchHandle = Handle;
}

void FLobbySearch::OnSearchResultsReceived(std::vector<FLobby>&& Results, std::vector<LobbyDetailsKeeper>&& Handles)
{
	SearchResults.swap(Results);
	ResultHandles.swap(Handles);
}


FLobbies::FLobbies()
{
	
}

FLobbies::~FLobbies()
{

}

void FLobbies::OnShutdown()
{
	LeaveLobby();
	UnsubscribeFromLobbyInvites();
	UnsubscribeFromLobbyUpdates();
	UnsubscribeFromLeaveLobbyUI();
}

void FLobbies::Update()
{
	if (!CurrentUserProductId.IsValid())
	{
		return;
	}

	if (bDirty)
	{
		//Check if we need to get account mappings and/or display names for members
		std::vector<FEpicAccountId> DisplayNameQuery;
		std::vector<FProductUserId> AccountMappingQuery;

		if (CurrentLobby.IsValid())
		{
			//members
			for (FLobbyMember& NextMember : CurrentLobby.Members)
			{
				if (!NextMember.AccountId.IsValid())
				{
					NextMember.AccountId = FGame::Get().GetUsers()->GetAccountMapping(NextMember.ProductId);

					//Still invalid: need to query
					if (!NextMember.AccountId.IsValid())
					{
						AccountMappingQuery.push_back(NextMember.ProductId);
					}
				}
				if(NextMember.AccountId.IsValid())
				{
					if (NextMember.DisplayName.empty())
					{
						NextMember.DisplayName = FGame::Get().GetUsers()->GetDisplayName(NextMember.AccountId);
						if (NextMember.DisplayName.empty())
						{
							DisplayNameQuery.push_back(NextMember.AccountId);
						}
					}
				}
			}

			//lobby owner
			if (!CurrentLobby.LobbyOwnerAccountId.IsValid())
			{
				CurrentLobby.LobbyOwnerAccountId = FGame::Get().GetUsers()->GetAccountMapping(CurrentLobby.LobbyOwner);

				if (!CurrentLobby.LobbyOwnerAccountId.IsValid())
				{
					AccountMappingQuery.push_back(CurrentLobby.LobbyOwner);
				}
			}
			if(CurrentLobby.LobbyOwnerAccountId.IsValid())
			{
				if (CurrentLobby.LobbyOwnerDisplayName.empty())
				{
					CurrentLobby.LobbyOwnerDisplayName = FGame::Get().GetUsers()->GetDisplayName(CurrentLobby.LobbyOwnerAccountId);
					if (CurrentLobby.LobbyOwnerDisplayName.empty())
					{
						DisplayNameQuery.push_back(CurrentLobby.LobbyOwnerAccountId);
					}
				}
			}
		}

		//Search results
		if (CurrentSearch.IsValid())
		{
			for (FLobby& NextSearchResult : CurrentSearch.GetResults())
			{
				if (NextSearchResult.IsValid())
				{
					if (!NextSearchResult.LobbyOwnerAccountId.IsValid())
					{
						NextSearchResult.LobbyOwnerAccountId = FGame::Get().GetUsers()->GetAccountMapping(NextSearchResult.LobbyOwner);
						if (!NextSearchResult.LobbyOwnerAccountId.IsValid())
						{
							AccountMappingQuery.push_back(NextSearchResult.LobbyOwner);
						}
					}
					if(NextSearchResult.LobbyOwnerAccountId.IsValid())
					{
						if (NextSearchResult.LobbyOwnerDisplayName.empty())
						{
							NextSearchResult.LobbyOwnerDisplayName = FGame::Get().GetUsers()->GetDisplayName(NextSearchResult.LobbyOwnerAccountId);
							if (NextSearchResult.LobbyOwnerDisplayName.empty())
							{
								DisplayNameQuery.push_back(NextSearchResult.LobbyOwnerAccountId);
							}
						}
					}
				}
			}
		}

		//Invites (query account mappings and/or user display names for users that send us invite)
		for (std::pair<const FProductUserId, FLobbyInvite>& NextInvitePair : Invites)
		{
			FLobbyInvite& NextInvite = NextInvitePair.second;
			if (NextInvite.FriendId.IsValid())
			{
				if (!NextInvite.FriendEpicId.IsValid())
				{
					NextInvite.FriendEpicId = FGame::Get().GetUsers()->GetAccountMapping(NextInvite.FriendId);
					if (!NextInvite.FriendEpicId)
					{
						AccountMappingQuery.push_back(NextInvite.FriendId);
					}
				}
				if (NextInvite.FriendEpicId.IsValid())
				{
					if (NextInvite.FriendDisplayName.empty())
					{
						NextInvite.FriendDisplayName = FGame::Get().GetUsers()->GetDisplayName(NextInvite.FriendEpicId);
						if (NextInvite.FriendDisplayName.empty())
						{
							DisplayNameQuery.push_back(NextInvite.FriendEpicId);
						}
					}
				}
			}
		}
		
		if (!CurrentUserProductId.IsValid())
		{
			FDebugLog::LogError(L"Lobbies - Update: Current player is invalid!");
			return;
		}

		//Query display names and account mappings
		if (!AccountMappingQuery.empty())
		{
			FGame::Get().GetUsers()->QueryAccountMappings(CurrentUserProductId, AccountMappingQuery);
		}

		for (FEpicAccountId NextId : DisplayNameQuery)
		{
			FGame::Get().GetUsers()->QueryDisplayName(NextId);
		}

		bDirty = false;
	}
}

void FLobbies::OnLoggedIn(FEpicAccountId UserId)
{
	bDirty = true;
	CurrentInvite = nullptr;
}

void FLobbies::OnLoggedOut(FEpicAccountId UserId)
{
	if (CurrentLobby.IsValid())
	{
		LeaveLobby();
	}

	CurrentSearch.Release();
	CurrentLobby.Clear();

	CurrentInvite = nullptr;
	Invites.clear();
}

void FLobbies::OnUserConnectLoggedIn(FProductUserId ProductUserId)
{
	CurrentUserProductId = ProductUserId;
	CurrentInvite = nullptr;
	bDirty = true;
}

void FLobbies::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedOut(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		FProductUserId ProductUserId = Event.GetProductUserId();
		OnUserConnectLoggedIn(ProductUserId);
	}
	else if (Event.GetType() == EGameEventType::EpicAccountsMappingRetrieved ||
		Event.GetType() == EGameEventType::ExternalAccountsMappingRetrieved ||
		Event.GetType() == EGameEventType::UserInfoRetrieved)
	{
		bDirty = true;
	}
}

void FLobbies::PopLobbyInvite()
{
	//Clear current invite (if any)
	if (CurrentInvite)
	{
		auto CurrentInviteIter = Invites.find(CurrentInvite->FriendId);
		if (CurrentInviteIter != Invites.end())
		{
			Invites.erase(CurrentInviteIter);
		}

		CurrentInvite = nullptr;
	}

	//Enable next invite
	if (!Invites.empty())
	{
		auto NextInviteIter = Invites.begin();
		CurrentInvite = &NextInviteIter->second;

		FGameEvent GameEvent(EGameEventType::LobbyInviteReceived);
		FGame::Get().OnGameEvent(GameEvent);
	}
}

bool FLobbies::CanInviteToCurrentLobby(FProductUserId ProductUserId) const
{
	if (!HasActiveLobby())
	{
		return false;
	}

	if (!ProductUserId.IsValid())
	{
		return false;
	}

	if (!CurrentLobby.bAllowInvites ||
		CurrentLobby.AvailableSlots == 0 ||
		CurrentLobby.Members.size() >= CurrentLobby.MaxNumLobbyMembers)
	{
		return false;
	}

	//Check if already in the lobby
	for (size_t MemberIndex = 0; MemberIndex < CurrentLobby.Members.size(); ++MemberIndex)
	{
		if (CurrentLobby.Members[MemberIndex].ProductId == ProductUserId)
		{
			return false;
		}
	}

	return true;
}

bool FLobbies::CreateLobby(const FLobby& Lobby)
{
	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - CreateLobby: Current player is invalid!");
		return false;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());
	if (!LobbyHandle)
	{
		FDebugLog::LogError(L"Lobbies: can't get lobby interface.");
		return false;
	}

	//Check if there is current session. Leave it.
	if (CurrentLobby.IsValid())
	{
		LeaveLobby();
	}

	EOS_Lobby_CreateLobbyOptions CreateOptions = {};
	CreateOptions.ApiVersion = EOS_LOBBY_CREATELOBBY_API_LATEST;
	CreateOptions.LocalUserId = CurrentUserProductId;
	CreateOptions.MaxLobbyMembers = Lobby.MaxNumLobbyMembers;
	CreateOptions.PermissionLevel = Lobby.Permission;
	CreateOptions.bPresenceEnabled = Lobby.IsPresenceEnabled();
	CreateOptions.bAllowInvites = Lobby.AreInvitesAllowed();
	CreateOptions.BucketId = Lobby.BucketId.c_str();
	CreateOptions.bDisableHostMigration = EOS_FALSE;
	CreateOptions.LobbyId = nullptr;

	EOS_Lobby_LocalRTCOptions LocalRTCOptions = {};
	if (Lobby.IsRTCRoomEnabled())
	{
		CreateOptions.bEnableRTCRoom = EOS_TRUE;

		LocalRTCOptions.ApiVersion = EOS_LOBBY_LOCALRTCOPTIONS_API_LATEST;
		LocalRTCOptions.Flags = EOS_RTC_JOINROOMFLAGS_ENABLE_DATACHANNEL; // Enable data channel so it can be used to notify about skin color changes
		LocalRTCOptions.bUseManualAudioInput = EOS_FALSE;
		LocalRTCOptions.bUseManualAudioOutput = EOS_FALSE;
		LocalRTCOptions.bLocalAudioDeviceInputStartsMuted = EOS_FALSE;

		CreateOptions.LocalRTCOptions = &LocalRTCOptions;
	}
	else
	{
		CreateOptions.bEnableRTCRoom = EOS_FALSE;
		CreateOptions.LocalRTCOptions = nullptr;
	}

	EOS_Lobby_CreateLobby(LobbyHandle, &CreateOptions, nullptr, OnCreateLobbyFinished);

	//Save lobby data for modification
	CurrentLobby = Lobby;
	CurrentLobby.bBeingCreated = true;
	CurrentLobby.LobbyOwner = CurrentUserProductId;

	return true;
}

bool FLobbies::DestroyCurrentLobby()
{
	if (!CurrentLobby.IsValid())
	{
		return false;
	}

	UnsubscribeFromRTCEvents();

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - DestroyCurrentLobby: Current player is invalid!");
		return false;
	}

	if (!CurrentLobby.IsOwner(CurrentUserProductId))
	{
		FDebugLog::LogError(L"Lobbies - DestroyCurrentLobby: Current player is now lobby owner!");
		return false;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_DestroyLobbyOptions DestroyOptions = {};
	DestroyOptions.ApiVersion = EOS_LOBBY_DESTROYLOBBY_API_LATEST;
	DestroyOptions.LocalUserId = CurrentUserProductId;
	DestroyOptions.LobbyId = CurrentLobby.Id.c_str();

	EOS_Lobby_DestroyLobby(LobbyHandle, &DestroyOptions, nullptr, OnDestroyLobbyFinished);

	//No matter the result we clear current lobby.
	CurrentLobby = FLobby();

	return true;
}


bool FLobbies::IsReadyToShutdown() const
{
	if (CurrentLobby.IsValid())
	{
		return false;
	}

	return !bLobbyLeaveInProgress;
}

bool FLobbies::ModifyLobby(const FLobby& LobbyChanges)
{
	if (!CurrentLobby.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - ModifyLobby: Current lobby is invalid.");
		return false;
	}

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - ModifyLobby: Current player is invalid!");
		return false;
	}

	if (!CurrentLobby.IsOwner(CurrentUserProductId))
	{
		FDebugLog::LogError(L"Lobbies - ModifyLobby: Only owner can modify lobby.");
		return false;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_UpdateLobbyModificationOptions ModifyOptions = {};
	ModifyOptions.ApiVersion = EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST;
	ModifyOptions.LobbyId = CurrentLobby.Id.c_str();
	ModifyOptions.LocalUserId = CurrentUserProductId;

	EOS_HLobbyModification LobbyModification = nullptr;
	EOS_EResult Result = EOS_Lobby_UpdateLobbyModification(LobbyHandle, &ModifyOptions, &LobbyModification);

	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies - ModifyLobby: Could not create lobby modification. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return false;
	}

	LobbyModificationKeeper ModKeeper = MakeLobbyDetailsKeeper(LobbyModification);

	//TODO: check if modification is needed by comparing current lobby against LobbyChanges

	// Lobby type
	EOS_LobbyModification_SetPermissionLevelOptions SetPermissionOptions = {};
	SetPermissionOptions.ApiVersion = EOS_LOBBYMODIFICATION_SETPERMISSIONLEVEL_API_LATEST;
	SetPermissionOptions.PermissionLevel = LobbyChanges.Permission;
	Result = EOS_LobbyModification_SetPermissionLevel(LobbyModification, &SetPermissionOptions);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies - ModifyLobby: Could not set permission level. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return false;
	}

	// BucketId
	if (!LobbyChanges.BucketId.empty())
	{
		EOS_LobbyModification_SetBucketIdOptions SetBucketIdOptions = {};
		SetBucketIdOptions.ApiVersion = EOS_LOBBYMODIFICATION_SETBUCKETID_API_LATEST;
		SetBucketIdOptions.BucketId = LobbyChanges.BucketId.c_str();
		Result = EOS_LobbyModification_SetBucketId(LobbyModification, &SetBucketIdOptions);
		if (Result != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies - ModifyLobby: Could not set the bucket id. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
			return false;
		}
	}

	// Invites allowed
	EOS_LobbyModification_SetInvitesAllowedOptions SetInvitesAllowedOptions = {};
	SetInvitesAllowedOptions.ApiVersion = EOS_LOBBYMODIFICATION_SETINVITESALLOWED_API_LATEST;
	SetInvitesAllowedOptions.bInvitesAllowed = LobbyChanges.AreInvitesAllowed() ? EOS_TRUE : EOS_FALSE;
	Result = EOS_LobbyModification_SetInvitesAllowed(LobbyModification, &SetInvitesAllowedOptions);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies - ModifyLobby: Could not set invites allowed. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return false;
	}

	// Max Players
	if (LobbyChanges.MaxNumLobbyMembers > 0)
	{
		EOS_LobbyModification_SetMaxMembersOptions SetMaxMembersOptions = {};
		SetMaxMembersOptions.ApiVersion = EOS_LOBBYMODIFICATION_SETMAXMEMBERS_API_LATEST;
		SetMaxMembersOptions.MaxMembers = LobbyChanges.MaxNumLobbyMembers;
		Result = EOS_LobbyModification_SetMaxMembers(LobbyModification, &SetMaxMembersOptions);
		if (Result != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies - ModifyLobby: Could not set max players. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
			return false;
		}
	}

	// Add Attributes (todo : check diff)
	for (size_t AttributeIndex = 0; AttributeIndex < LobbyChanges.Attributes.size(); ++AttributeIndex)
	{
		EOS_LobbyModification_AddAttributeOptions AddAttributeModOptions = {};
		AddAttributeModOptions.ApiVersion = EOS_LOBBYMODIFICATION_ADDATTRIBUTE_API_LATEST;
		EOS_Lobby_AttributeData AttributeData = LobbyChanges.Attributes[AttributeIndex].ToAttributeData();
		AddAttributeModOptions.Attribute = &AttributeData;
		AddAttributeModOptions.Visibility = LobbyChanges.Attributes[AttributeIndex].Visibility;

		Result = EOS_LobbyModification_AddAttribute(LobbyModification, &AddAttributeModOptions);
		if (Result != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies - ModifyLobby: Could not add attribute. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
			return false;
		}
	}

	//Trigger lobby update
	EOS_Lobby_UpdateLobbyOptions UpdateOptions = {};
	UpdateOptions.ApiVersion = EOS_LOBBY_UPDATELOBBY_API_LATEST;
	UpdateOptions.LobbyModificationHandle = ModKeeper.get();
	EOS_Lobby_UpdateLobby(LobbyHandle, &UpdateOptions, nullptr, OnLobbyUpdateFinished);

	return true;
}

void FLobbies::UpdateLobby()
{
	if (CurrentLobby.IsValid())
	{
		CurrentLobby.InitFromLobbyHandle(CurrentLobby.Id.c_str());
		bDirty = true;
	}
}

void FLobbies::KickMember(EOS_ProductUserId MemberId)
{
	if (!MemberId)
	{
		return;
	}

	
	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - KickMember: Current player is invalid!");
		return;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_KickMemberOptions KickMemberOptions = {};
	KickMemberOptions.ApiVersion = EOS_LOBBY_KICKMEMBER_API_LATEST;
	KickMemberOptions.TargetUserId = MemberId;
	KickMemberOptions.LobbyId = CurrentLobby.Id.c_str();
	KickMemberOptions.LocalUserId = CurrentUserProductId;

	EOS_Lobby_KickMember(LobbyHandle, &KickMemberOptions, nullptr, OnKickMemberFinished);
}

void FLobbies::PromoteMember(EOS_ProductUserId MemberId)
{
	if (!MemberId)
	{
		return;
	}

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - PromoteMember: Current player is invalid!");
		return;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_PromoteMemberOptions PromoteMemberOptions = {};
	PromoteMemberOptions.ApiVersion = EOS_LOBBY_PROMOTEMEMBER_API_LATEST;
	PromoteMemberOptions.TargetUserId = MemberId;
	PromoteMemberOptions.LocalUserId = CurrentUserProductId;
	PromoteMemberOptions.LobbyId = CurrentLobby.Id.c_str();

	EOS_Lobby_PromoteMember(LobbyHandle, &PromoteMemberOptions, nullptr, OnPromoteMemberFinished);
}

void FLobbies::JoinLobby(EOS_LobbyId Id, LobbyDetailsKeeper LobbyInfo, bool bPresenceEnabled)
{
	if (!Id)
	{
		return;
	}

	if (CurrentLobby.IsValid() && CurrentLobby.GetMemberByProductUserId(CurrentUserProductId) != nullptr)
	{
		if (CurrentLobby.Id == Id)
		{
			FDebugLog::LogError(L"Lobbies - JoinLobby: Already in the lobby!");
			return;
		}

		ActiveJoin = FLobbyJoinRequest{ Id, LobbyInfo, bPresenceEnabled };
		LeaveLobby();
	}
	else
	{
		if (!CurrentUserProductId.IsValid())
		{
			FDebugLog::LogError(L"Lobbies - JoinLobby: Current player is invalid!");
			return;
		}

		EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

		EOS_Lobby_JoinLobbyOptions JoinOptions = {};
		JoinOptions.ApiVersion = EOS_LOBBY_JOINLOBBY_API_LATEST;
		JoinOptions.LobbyDetailsHandle = LobbyInfo.get();
		JoinOptions.LocalUserId = CurrentUserProductId;
		JoinOptions.bPresenceEnabled = bPresenceEnabled;

		EOS_Lobby_LocalRTCOptions LocalRTCOptions = {};
		LocalRTCOptions.ApiVersion = EOS_LOBBY_LOCALRTCOPTIONS_API_LATEST;
		LocalRTCOptions.Flags = EOS_RTC_JOINROOMFLAGS_ENABLE_DATACHANNEL; // Enable data channel so it can be used to notify about skin color changes
		LocalRTCOptions.bUseManualAudioInput = EOS_FALSE;
		LocalRTCOptions.bUseManualAudioOutput = EOS_FALSE;
		LocalRTCOptions.bLocalAudioDeviceInputStartsMuted = EOS_FALSE;

		JoinOptions.LocalRTCOptions = &LocalRTCOptions;

		EOS_Lobby_JoinLobby(LobbyHandle, &JoinOptions, nullptr, OnJoinLobbyFinished);
	}
}

void FLobbies::JoinSearchResult(size_t Index)
{
	if (CurrentSearch.GetResults().size() > Index && CurrentSearch.GetDetailsHandles().size() > Index)
	{
		// Currently, joining from the sample UI will not allow joining a lobby in presence enabled mode.
		// It is required that all Lobbies initiated by the overlay UI be marked as presence enabled,
		// but the state of that flag can be defined for any lobbies initialed entirely by the game.
		const bool bPresenceEnabled = false;
		JoinLobby(CurrentSearch.GetResults()[Index].Id.c_str(), CurrentSearch.GetDetailsHandles()[Index], bPresenceEnabled);
	}
}

void FLobbies::RejectLobbyInvite(const std::string& InviteId)
{
	if (CurrentInvite->IsValid() && CurrentInvite->InviteId == InviteId)
	{
		if (!CurrentUserProductId.IsValid())
		{
			FDebugLog::LogError(L"Lobbies - RejectLobbyInvite: Current player is invalid!");
			return;
		}

		EOS_Lobby_RejectInviteOptions Options = {};
		Options.ApiVersion = EOS_LOBBY_REJECTINVITE_API_LATEST;
		Options.InviteId = InviteId.c_str();
		Options.LocalUserId = CurrentUserProductId;

		EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

		EOS_Lobby_RejectInvite(LobbyHandle, &Options, nullptr, OnRejectInviteFinished);

		PopLobbyInvite();
	}

	//In case lobby id does not match current invite the reject can be ignored
}

void FLobbies::LeaveLobby()
{
	if (!CurrentLobby.IsValid())
	{
		return;
	}

	UnsubscribeFromRTCEvents();

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - LeaveLobby: Current player is invalid!");
		return;
	}
	
	bLobbyLeaveInProgress = true;

	// Set this to true to test flow where owner always destroys lobby
	const bool bOwnerAlwaysDestroysLobby = false;
	const bool bDestroyLobby = CurrentLobby.IsOwner(CurrentUserProductId) && (bOwnerAlwaysDestroysLobby || CurrentLobby.Members.size() <= 1);

	//Destroy empty lobby on leave
	if (bDestroyLobby)
	{
		DestroyCurrentLobby();
		return;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_LeaveLobbyOptions LeaveOptions = {};
	LeaveOptions.ApiVersion = EOS_LOBBY_LEAVELOBBY_API_LATEST;
	LeaveOptions.LobbyId = CurrentLobby.Id.c_str();
	LeaveOptions.LocalUserId = CurrentUserProductId;
	EOS_Lobby_LeaveLobby(LobbyHandle, &LeaveOptions, nullptr, OnLeaveLobbyFinished);
	
	//No matter the result we clear current lobby.
	CurrentLobby = FLobby();
}

void FLobbies::SendInvite(FProductUserId TargetUserId)
{
	if (!CurrentLobby.IsValid() || !TargetUserId)
	{
		return;
	}

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - SendInvite: Current player is invalid!");
		return;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_SendInviteOptions SendInviteOptions = {};
	SendInviteOptions.ApiVersion = EOS_LOBBY_SENDINVITE_API_LATEST;
	SendInviteOptions.LobbyId = CurrentLobby.Id.c_str();
	SendInviteOptions.LocalUserId = CurrentUserProductId;
	SendInviteOptions.TargetUserId = TargetUserId;

	EOS_Lobby_SendInvite(LobbyHandle, &SendInviteOptions, nullptr, OnLobbyInviteSendFinished);
}

void FLobbies::ShuffleSkin()
{
	if (!CurrentLobby.IsValid())
	{
		return;
	}

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - ShuffleSkin: Current player is invalid!");
		return;
	}

	if (FLobbyMember* LocalLobbyMember = CurrentLobby.GetMemberByProductUserId(CurrentUserProductId))
	{
		if (LocalLobbyMember->MemberAttributes.empty())
		{
			FLobbyAttribute SkinAttribute;
			SkinAttribute.Key = "SKIN";
			SkinAttribute.ValueType = FLobbyAttribute::String;
			SkinAttribute.AsString = FLobbyMember::GetSkinString(LocalLobbyMember->CurrentSkin);
			LocalLobbyMember->MemberAttributes.push_back(SkinAttribute);
		}
		else
		{
			LocalLobbyMember->ShuffleSkin();
			LocalLobbyMember->MemberAttributes[0].AsString = FLobbyMember::GetSkinString(LocalLobbyMember->CurrentSkin);
		}

		SetMemberAttribute(LocalLobbyMember->MemberAttributes[0]);
	}
}

void FLobbies::ShuffleColor()
{
	if (!CurrentLobby.IsValid())
	{
		return;
	}

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - ShuffleColor: Current player is invalid!");
		return;
	}

	if (FLobbyMember* LocalLobbyMember = CurrentLobby.GetMemberByProductUserId(CurrentUserProductId))
	{
		LocalLobbyMember->ShuffleColor();			
		SendSkinColorUpdate(LocalLobbyMember->CurrentColor);
	}
}

void FLobbies::SendSkinColorUpdate(FLobbyMember::SkinColor InColor)
{
	const size_t CommandSize = sizeof(ELobbyRTCDataCommand) + sizeof(FLobbyMember::SkinColor);
	uint8_t Data[CommandSize];

	Data[0] = static_cast<uint8_t>(ELobbyRTCDataCommand::SkinColor);
	Data[1] = static_cast<uint8_t>(InColor);

	EOS_RTCData_SendDataOptions SendDataOptions{};
	SendDataOptions.ApiVersion = EOS_RTCDATA_SENDDATA_API_LATEST;
	SendDataOptions.LocalUserId = CurrentUserProductId;
	SendDataOptions.RoomName = CurrentLobby.RTCRoomName.c_str();
	SendDataOptions.Data = Data;
	SendDataOptions.DataLengthBytes = CommandSize;

	EOS_HRTC RTCHandle = EOS_Platform_GetRTCInterface(FPlatform::GetPlatformHandle());
	EOS_HRTCData RTCDataHandle = EOS_RTC_GetDataInterface(RTCHandle);

	EOS_EResult Result = EOS_RTCData_SendData(RTCDataHandle, &SendDataOptions);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies: can't send data through data channel. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
	}
}

void FLobbies::MuteAudio(FProductUserId TargetUserId)
{
	EOS_HRTC RTCHandle = EOS_Platform_GetRTCInterface(FPlatform::GetPlatformHandle());
	EOS_HRTCAudio AudioHandle = EOS_RTC_GetAudioInterface(RTCHandle);

	// Find the correct lobby member
	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(TargetUserId))
	{
		// Do not allow multiple local mutes/unmutes at the same time
		if (LobbyMember->RTCState.bMuteActionInProgress)
		{
			return;
		}

		// Set their mute action as in progress so we don't try to toggle their mute status again until it completes
		LobbyMember->RTCState.bMuteActionInProgress = true;

		// Check if we're muting ourselves vs muting someone else
		if (CurrentUserProductId == TargetUserId)
		{
			// Toggle our Mute/Unmute status
			EOS_RTCAudio_UpdateSendingOptions UpdateSendingOptions = {};
			UpdateSendingOptions.ApiVersion = EOS_RTCAUDIO_UPDATESENDING_API_LATEST;
			UpdateSendingOptions.LocalUserId = CurrentUserProductId;
			UpdateSendingOptions.RoomName = CurrentLobby.RTCRoomName.c_str();
			UpdateSendingOptions.AudioStatus = LobbyMember->RTCState.bIsAudioOutputDisabled ? EOS_ERTCAudioStatus::EOS_RTCAS_Enabled : EOS_ERTCAudioStatus::EOS_RTCAS_Disabled;

			const wchar_t* AudioStatusText = UpdateSendingOptions.AudioStatus == EOS_ERTCAudioStatus::EOS_RTCAS_Enabled ? L"Unmuted" : L"Muted";
			FDebugLog::LogError(L"Lobbies - MuteAudio: Setting audio output status to %ls", AudioStatusText);

			EOS_RTCAudio_UpdateSending(AudioHandle, &UpdateSendingOptions, nullptr, OnRTCRoomUpdateSendingComplete);
		}
		else
		{
			// Mute/Unmute others audio (this is a local-only action and does not block the other user from receiving your audio stream)
			EOS_RTCAudio_UpdateReceivingOptions UpdateReceivingOptions = {};
			UpdateReceivingOptions.ApiVersion = EOS_RTCAUDIO_UPDATERECEIVING_API_LATEST;
			UpdateReceivingOptions.LocalUserId = CurrentUserProductId;
			UpdateReceivingOptions.RoomName = CurrentLobby.RTCRoomName.c_str();
			UpdateReceivingOptions.ParticipantId = TargetUserId;
			UpdateReceivingOptions.bAudioEnabled = LobbyMember->RTCState.bIsLocallyMuted ? EOS_TRUE : EOS_FALSE;

			const wchar_t* AudioStatusText = UpdateReceivingOptions.bAudioEnabled ? L"Unmuting" : L"Muting";
			FDebugLog::LogError(L"Lobbies - MuteAudio: %ls remote player. TargetParticipantId=[%ls]",
				AudioStatusText,
				FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(TargetUserId)).c_str());

			EOS_RTCAudio_UpdateReceiving(AudioHandle, &UpdateReceivingOptions, nullptr, OnRTCRoomUpdateReceivingComplete);
		}
	}
}

void FLobbies::ToggleHardMuteMember(FProductUserId TargetUserId)
{
	if (!TargetUserId)
	{
		FDebugLog::LogError(L"Lobbies - ToggleHardMuteMember: Target player is invalid!");
		return;
	}

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - ToggleHardMuteMember: Current player is invalid!");
		return;
	}

	// Find the correct lobby member
	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(TargetUserId))
	{
		// Do not allow multiple local mutes/unmutes at the same time
		if (LobbyMember->RTCState.bHardMuteActionInProgress)
		{
			FDebugLog::LogWarning(L"Lobbies - ToggleHardMuteMember: Hard muting %ls remote player is already in progress!",
				FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(TargetUserId)).c_str());
			return;
		}

		// Set their hard mute action as in progress so we don't try to toggle their hard mute status again until it completes
		LobbyMember->RTCState.bHardMuteActionInProgress = true;

		HardMuteMember(TargetUserId, !LobbyMember->RTCState.bIsHardMuted); // toggle hard mute state
	}
}

void FLobbies::HardMuteMember(FProductUserId InTargetUserId, bool bInHardMute)
{
	EOS_Lobby_HardMuteMemberOptions HardMuteMemberOptions = {};
	HardMuteMemberOptions.ApiVersion = EOS_LOBBY_HARDMUTEMEMBER_API_LATEST;
	HardMuteMemberOptions.LobbyId = CurrentLobby.Id.c_str();
	HardMuteMemberOptions.LocalUserId = CurrentUserProductId;
	HardMuteMemberOptions.TargetUserId = InTargetUserId;
	HardMuteMemberOptions.bHardMute = bInHardMute ? EOS_TRUE : EOS_FALSE;

	const wchar_t* HardMuteStatusText = (HardMuteMemberOptions.bHardMute == EOS_TRUE) ? L"muting" : L"unmuting";
	FDebugLog::Log(L"Lobbies - HardMuteMember: %ls remote player. TargetParticipantId=[%ls]",
		HardMuteStatusText,
		FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(InTargetUserId)).c_str());

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());
	EOS_Lobby_HardMuteMember(LobbyHandle, &HardMuteMemberOptions, nullptr, OnHardMuteMemberFinished);
}

void FLobbies::SetMemberAttribute(const FLobbyAttribute& MemberAttribute)
{
	if (!CurrentLobby.IsValid())
	{
		return;
	}

	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - SetMemberAttribute: Current player is invalid!");
		return;
	}

	//Modify lobby

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_UpdateLobbyModificationOptions ModifyOptions = {};
	ModifyOptions.ApiVersion = EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST;
	ModifyOptions.LobbyId = CurrentLobby.Id.c_str();
	ModifyOptions.LocalUserId = CurrentUserProductId;

	EOS_HLobbyModification LobbyModification = nullptr;
	EOS_EResult Result = EOS_Lobby_UpdateLobbyModification(LobbyHandle, &ModifyOptions, &LobbyModification);

	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies - SetMemberAttribute: Could not create lobby modification. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	LobbyModificationKeeper ModKeeper = MakeLobbyDetailsKeeper(LobbyModification);

	//Update member attribute
	EOS_Lobby_AttributeData AttributeData = MemberAttribute.ToAttributeData();

	EOS_LobbyModification_AddMemberAttributeOptions AddAttrOptions = {};
	AddAttrOptions.ApiVersion = EOS_LOBBYMODIFICATION_ADDMEMBERATTRIBUTE_API_LATEST;
	AddAttrOptions.Attribute = &AttributeData;
	AddAttrOptions.Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;

	Result = EOS_LobbyModification_AddMemberAttribute(LobbyModification, &AddAttrOptions);

	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies - SetMemberAttribute: Could not add member attribute. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	//Trigger lobby update
	EOS_Lobby_UpdateLobbyOptions UpdateOptions = {};
	UpdateOptions.ApiVersion = EOS_LOBBY_UPDATELOBBY_API_LATEST;
	UpdateOptions.LobbyModificationHandle = ModKeeper.get();
	EOS_Lobby_UpdateLobby(LobbyHandle, &UpdateOptions, nullptr, OnLobbyUpdateFinished);
}

void FLobbies::SetInitialMemberAttribute()
{
	if (!CurrentLobby.IsValid())
	{
		return;
	}

	
	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - SetInitialMemberAttribute: Current player is invalid!");
		return;
	}

	if (FLobbyMember* LocalLobbyMember = CurrentLobby.GetMemberByProductUserId(CurrentUserProductId))
	{
		//Check if skin is already set
		if (LocalLobbyMember->MemberAttributes.empty())
		{
			FLobbyAttribute SkinAttribute;
			SkinAttribute.Key = "SKIN";
			SkinAttribute.ValueType = FLobbyAttribute::String;
			SkinAttribute.AsString = FLobbyMember::GetSkinString(LocalLobbyMember->CurrentSkin);
			SetMemberAttribute(SkinAttribute);
		}
	}
}

void FLobbies::Search(const std::vector<FLobbyAttribute>& SearchAttributes, uint32_t MaxNumResults)
{
	//Clear previous search
	CurrentSearch.Release();

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	
	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - Search: Current player is invalid!");
		return;
	}

	EOS_Lobby_CreateLobbySearchOptions CreateSearchOptions = {};
	CreateSearchOptions.ApiVersion = EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST;
	CreateSearchOptions.MaxResults = MaxNumResults;

	EOS_HLobbySearch LobbySearch = nullptr;
	EOS_EResult Result = EOS_Lobby_CreateLobbySearch(LobbyHandle, &CreateSearchOptions, &LobbySearch);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies: could not create search. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	CurrentSearch.SetNewSearch(LobbySearch);

	EOS_LobbySearch_SetParameterOptions ParamOptions = {};
	ParamOptions.ApiVersion = EOS_LOBBYSEARCH_SETPARAMETER_API_LATEST;
	ParamOptions.ComparisonOp = EOS_EComparisonOp::EOS_CO_EQUAL;

	EOS_Lobby_AttributeData AttrData;
	AttrData.ApiVersion = EOS_LOBBY_ATTRIBUTEDATA_API_LATEST;
	ParamOptions.Parameter = &AttrData;

	for (const FLobbyAttribute& NextAttr : SearchAttributes)
	{
		AttrData.Key = NextAttr.Key.c_str();

		switch (NextAttr.ValueType)
		{
		case FLobbyAttribute::Bool:
			AttrData.ValueType = EOS_ELobbyAttributeType::EOS_AT_BOOLEAN;
			AttrData.Value.AsBool = NextAttr.AsBool;
			break;
		case FLobbyAttribute::Int64:
			AttrData.ValueType = EOS_ELobbyAttributeType::EOS_AT_INT64;
			AttrData.Value.AsInt64 = NextAttr.AsInt64;
			break;
		case FLobbyAttribute::Double:
			AttrData.ValueType = EOS_ELobbyAttributeType::EOS_AT_DOUBLE;
			AttrData.Value.AsDouble = NextAttr.AsDouble;
			break;
		case FLobbyAttribute::String:
			AttrData.ValueType = EOS_ELobbyAttributeType::EOS_AT_STRING;
			//Do not use attributes with empty strings
			if (NextAttr.AsString.empty())
			{
				continue;
			}
			AttrData.Value.AsUtf8 = NextAttr.AsString.c_str();
			break;
		}

		Result = EOS_LobbySearch_SetParameter(LobbySearch, &ParamOptions);
		if (Result != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies: failed to update lobby search with parameter. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
			return;
		}
	}

	EOS_LobbySearch_FindOptions FindOptions = {};
	FindOptions.ApiVersion = EOS_LOBBYSEARCH_FIND_API_LATEST;
	FindOptions.LocalUserId = CurrentUserProductId;
	EOS_LobbySearch_Find(LobbySearch, &FindOptions, nullptr, OnLobbySearchFinished);
}

void FLobbies::Search(const std::string& LobbyId, uint32_t MaxNumResults)
{
	//Clear previous search
	CurrentSearch.Release();

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());
	
	if (!CurrentUserProductId.IsValid())
	{
		FDebugLog::LogError(L"Lobbies - Search: Current player is invalid!");
		return;
	}

	EOS_Lobby_CreateLobbySearchOptions CreateSearchOptions = {};
	CreateSearchOptions.ApiVersion = EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST;
	CreateSearchOptions.MaxResults = MaxNumResults;

	EOS_HLobbySearch LobbySearch = nullptr;
	EOS_EResult Result = EOS_Lobby_CreateLobbySearch(LobbyHandle, &CreateSearchOptions, &LobbySearch);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies: could not create search. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	CurrentSearch.SetNewSearch(LobbySearch);

	EOS_LobbySearch_SetLobbyIdOptions SetLobbyOptions = {};
	SetLobbyOptions.ApiVersion = EOS_LOBBYSEARCH_SETLOBBYID_API_LATEST;
	SetLobbyOptions.LobbyId = LobbyId.c_str();

	Result = EOS_LobbySearch_SetLobbyId(LobbySearch, &SetLobbyOptions);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies: could not set lobby id for search. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	EOS_LobbySearch_FindOptions FindOptions = {};
	FindOptions.ApiVersion = EOS_LOBBYSEARCH_FIND_API_LATEST;
	FindOptions.LocalUserId = CurrentUserProductId;
	EOS_LobbySearch_Find(LobbySearch, &FindOptions, nullptr, OnLobbySearchFinished);
}

void FLobbies::SearchLobbyByLevel(const std::string& LevelName)
{
	std::vector<FLobbyAttribute> Attributes;

	FLobbyAttribute LevelAttribute;
	LevelAttribute.Key = "LEVEL";
	LevelAttribute.ValueType = FLobbyAttribute::String;
	LevelAttribute.AsString = LevelName;
	LevelAttribute.Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;

	Attributes.push_back(LevelAttribute);

	Search(Attributes);
}

void FLobbies::SearchLobbyByBucketId(const std::string& BucketId)
{
	std::vector<FLobbyAttribute> Attributes;

	FLobbyAttribute BucketIdAttribute;
	BucketIdAttribute.Key = EOS_LOBBY_SEARCH_BUCKET_ID;
	BucketIdAttribute.ValueType = FLobbyAttribute::String;
	BucketIdAttribute.AsString = BucketId;
	BucketIdAttribute.Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;

	Attributes.push_back(BucketIdAttribute);

	Search(Attributes, 1);
}

void FLobbies::ClearSearch()
{
	CurrentSearch.Release();
}

void FLobbies::SubscribeToLobbyUpdates()
{
	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_AddNotifyLobbyUpdateReceivedOptions UpdateNotifyOptions = {};
	UpdateNotifyOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYUPDATERECEIVED_API_LATEST;

	LobbyUpdateNotification = EOS_Lobby_AddNotifyLobbyUpdateReceived(LobbyHandle, &UpdateNotifyOptions, nullptr, OnLobbyUpdateReceived);

	EOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions MemberUpdateOptions = {};
	MemberUpdateOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYMEMBERUPDATERECEIVED_API_LATEST;
	LobbyMemberUpdateNotification = EOS_Lobby_AddNotifyLobbyMemberUpdateReceived(LobbyHandle, &MemberUpdateOptions, nullptr, OnMemberUpdateReceived);

	EOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions MemberStatusOptions = {};
	MemberStatusOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYMEMBERSTATUSRECEIVED_API_LATEST;
	LobbyMemberStatusNotification = EOS_Lobby_AddNotifyLobbyMemberStatusReceived(LobbyHandle, &MemberStatusOptions, nullptr, OnMemberStatusReceived);
}

void FLobbies::UnsubscribeFromLobbyUpdates()
{
	if (LobbyUpdateNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

		EOS_Lobby_RemoveNotifyLobbyUpdateReceived(LobbyHandle, LobbyUpdateNotification);
		LobbyUpdateNotification = EOS_INVALID_NOTIFICATIONID;
	}

	if (LobbyMemberUpdateNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

		EOS_Lobby_RemoveNotifyLobbyMemberUpdateReceived(LobbyHandle, LobbyMemberUpdateNotification);
		LobbyMemberUpdateNotification = EOS_INVALID_NOTIFICATIONID;
	}

	if (LobbyMemberStatusNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

		EOS_Lobby_RemoveNotifyLobbyMemberStatusReceived(LobbyHandle, LobbyMemberStatusNotification);
		LobbyMemberStatusNotification = EOS_INVALID_NOTIFICATIONID;
	}
}

void FLobbies::SubscribeToLobbyInvites()
{
	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_AddNotifyLobbyInviteReceivedOptions InviteOptions = {};
	InviteOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYINVITERECEIVED_API_LATEST;
	LobbyInviteNotification = EOS_Lobby_AddNotifyLobbyInviteReceived(LobbyHandle, &InviteOptions, nullptr, OnLobbyInviteReceived);

	EOS_Lobby_AddNotifyLobbyInviteAcceptedOptions AcceptedOptions = {};
	AcceptedOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYINVITEACCEPTED_API_LATEST;
	LobbyInviteAcceptedNotification = EOS_Lobby_AddNotifyLobbyInviteAccepted(LobbyHandle, &AcceptedOptions, nullptr, OnLobbyInviteAccepted);

	EOS_Lobby_AddNotifyJoinLobbyAcceptedOptions JoinGameOptions = {};
	JoinGameOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYJOINLOBBYACCEPTED_API_LATEST;
	JoinLobbyAcceptedNotification = EOS_Lobby_AddNotifyJoinLobbyAccepted(LobbyHandle, &JoinGameOptions, nullptr, OnJoinLobbyAccepted);
}

void FLobbies::UnsubscribeFromLobbyInvites()
{
	if (LobbyInviteNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

		EOS_Lobby_RemoveNotifyLobbyInviteReceived(LobbyHandle, LobbyInviteNotification);
		LobbyInviteNotification = EOS_INVALID_NOTIFICATIONID;

		EOS_Lobby_RemoveNotifyLobbyInviteAccepted(LobbyHandle, LobbyInviteAcceptedNotification);
		LobbyInviteAcceptedNotification = EOS_INVALID_NOTIFICATIONID;

		EOS_Lobby_RemoveNotifyJoinLobbyAccepted(LobbyHandle, JoinLobbyAcceptedNotification);
		JoinLobbyAcceptedNotification = EOS_INVALID_NOTIFICATIONID;
	}
}

void FLobbies::SubscribeToLeaveLobbyUI()
{
	EOS_HLobby LobbiesHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_AddNotifyLeaveLobbyRequestedOptions LeaveLobbyRequestedOptions = { };
	LeaveLobbyRequestedOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLEAVELOBBYREQUESTED_API_LATEST;
	LeaveLobbyRequestedNotification = EOS_Lobby_AddNotifyLeaveLobbyRequested(LobbiesHandle, &LeaveLobbyRequestedOptions, nullptr, OnLeaveLobbyRequested);
}

void FLobbies::UnsubscribeFromLeaveLobbyUI()
{
	if (LeaveLobbyRequestedNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Lobby_RemoveNotifyLeaveLobbyRequested(EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle()), LeaveLobbyRequestedNotification);
		LeaveLobbyRequestedNotification = EOS_INVALID_NOTIFICATIONID;
	}
}

std::string FLobbies::GetRTCRoomName()
{
	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_GetRTCRoomNameOptions GetRTCRoomNameOptions = {0};
	GetRTCRoomNameOptions.ApiVersion = EOS_LOBBY_GETRTCROOMNAME_API_LATEST;
	GetRTCRoomNameOptions.LobbyId = CurrentLobby.Id.c_str();
	GetRTCRoomNameOptions.LocalUserId = CurrentUserProductId;

	char RoomNameBuffer[256];
	uint32_t InBufferSizeOutBytesWritten = sizeof(RoomNameBuffer) / sizeof(char);

	EOS_EResult GetRTCRoomNameResult = EOS_Lobby_GetRTCRoomName(LobbyHandle, &GetRTCRoomNameOptions, &RoomNameBuffer[0], &InBufferSizeOutBytesWritten);
	if (GetRTCRoomNameResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies: could not get RTC room name. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(GetRTCRoomNameResult)).c_str());
		return std::string();
	}

	// Copy from our buffer, less the null-terminator
	std::string RoomName(&RoomNameBuffer[0], InBufferSizeOutBytesWritten - 1);

	FDebugLog::Log(L"Lobbies: Found RTC Room name for lobby. RoomName: %ls", FStringUtils::Widen(RoomName).c_str());

	return RoomName;
}

void FLobbies::SubscribeToRTCEvents()
{
	if (!CurrentLobby.IsRTCRoomEnabled())
	{
		FDebugLog::Log(L"Lobbies: RTC Room is disabled.");
		return;
	}

	CurrentLobby.RTCRoomName = GetRTCRoomName();

	// We don't have a RTC Room
	if (CurrentLobby.RTCRoomName.empty())
	{
		FDebugLog::LogError(L"Lobbies: Unable to bind to RTC Room Name, failing to bind delegates.");
		return;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	// Register for connection status changes
	EOS_Lobby_AddNotifyRTCRoomConnectionChangedOptions AddNotifyRTCRoomConnectionChangedOptions = {};
	AddNotifyRTCRoomConnectionChangedOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYRTCROOMCONNECTIONCHANGED_API_LATEST;
	CurrentLobby.RTCRoomConnectionChanged = EOS_Lobby_AddNotifyRTCRoomConnectionChanged(LobbyHandle, &AddNotifyRTCRoomConnectionChangedOptions, nullptr, OnRTCRoomConnectionChangeReceived);
	if (CurrentLobby.RTCRoomConnectionChanged == EOS_INVALID_NOTIFICATIONID)
	{
		FDebugLog::LogError(L"Lobbies: Failed to bind to Lobby NotifyRTCRoomConnectionChanged notification.");
	}

	// Get the current room connection status now that we're listening for changes
	EOS_Lobby_IsRTCRoomConnectedOptions IsRTCRoomConnectedOptions = {};
	IsRTCRoomConnectedOptions.ApiVersion = EOS_LOBBY_ISRTCROOMCONNECTED_API_LATEST;
	IsRTCRoomConnectedOptions.LobbyId = CurrentLobby.Id.c_str();
	IsRTCRoomConnectedOptions.LocalUserId = CurrentUserProductId;
	EOS_Bool bIsConnected = EOS_FALSE;
	EOS_EResult IsRoomConnectedResult = EOS_Lobby_IsRTCRoomConnected(LobbyHandle, &IsRTCRoomConnectedOptions, &bIsConnected);
	if (IsRoomConnectedResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies: Failed to get RTC Room connection status: error code: %ls.", FStringUtils::Widen(EOS_EResult_ToString(IsRoomConnectedResult)).c_str());
	}
	CurrentLobby.bRTCRoomConnected = bIsConnected != EOS_FALSE;

	EOS_HRTC RTCHandle = EOS_Platform_GetRTCInterface(FPlatform::GetPlatformHandle());
	EOS_HRTCAudio RTCAudioHandle = EOS_RTC_GetAudioInterface(RTCHandle);
	EOS_HRTCData RTCDataHandle = EOS_RTC_GetDataInterface(RTCHandle);

	// Register for RTC Room participant changes
	EOS_RTC_AddNotifyParticipantStatusChangedOptions AddNotifyParticipantStatusChangedOptions = {};
	AddNotifyParticipantStatusChangedOptions.ApiVersion = EOS_RTC_ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST;
	AddNotifyParticipantStatusChangedOptions.LocalUserId = CurrentUserProductId;
	AddNotifyParticipantStatusChangedOptions.RoomName = CurrentLobby.RTCRoomName.c_str();
	CurrentLobby.RTCRoomParticipantUpdate = EOS_RTC_AddNotifyParticipantStatusChanged(RTCHandle, &AddNotifyParticipantStatusChangedOptions, nullptr, OnRTCRoomParticipantStatusChanged);
	if (CurrentLobby.RTCRoomParticipantUpdate == EOS_INVALID_NOTIFICATIONID)
	{
		FDebugLog::LogError(L"Lobbies: Failed to bind to RTC AddNotifyParticipantStatusChanged notification.");
	}

	// Register for talking changes
	EOS_RTCAudio_AddNotifyParticipantUpdatedOptions AddNotifyParticipantUpdatedOptions = {};
	AddNotifyParticipantUpdatedOptions.ApiVersion = EOS_RTCAUDIO_ADDNOTIFYPARTICIPANTUPDATED_API_LATEST;
	AddNotifyParticipantUpdatedOptions.LocalUserId = CurrentUserProductId;
	AddNotifyParticipantUpdatedOptions.RoomName = CurrentLobby.RTCRoomName.c_str();
	CurrentLobby.RTCRoomParticipantAudioUpdate = EOS_RTCAudio_AddNotifyParticipantUpdated(RTCAudioHandle, &AddNotifyParticipantUpdatedOptions, nullptr, OnRTCRoomParticipantAudioUpdateRecieved);
	if (CurrentLobby.RTCRoomParticipantAudioUpdate == EOS_INVALID_NOTIFICATIONID)
	{
		FDebugLog::LogError(L"Lobbies: Failed to bind to RTCAudio AddNotifyParticipantUpdated notification.");
	}

	EOS_RTCData_AddNotifyDataReceivedOptions AddNotifyDataReceivedOptions = {};
	AddNotifyDataReceivedOptions.ApiVersion = EOS_RTCDATA_ADDNOTIFYDATARECEIVED_API_LATEST;
	AddNotifyDataReceivedOptions.LocalUserId = CurrentUserProductId;
	AddNotifyDataReceivedOptions.RoomName = CurrentLobby.RTCRoomName.c_str();
	CurrentLobby.RTCRoomDataReceived = EOS_RTCData_AddNotifyDataReceived(RTCDataHandle, &AddNotifyDataReceivedOptions, nullptr, OnRTCRoomDataReceived);
}

void FLobbies::UnsubscribeFromRTCEvents()
{
	if (!CurrentLobby.IsValid())
	{
		return;
	}

	EOS_HRTC RTCHandle = EOS_Platform_GetRTCInterface(FPlatform::GetPlatformHandle());
	EOS_HRTCAudio RTCAudioHandle = EOS_RTC_GetAudioInterface(RTCHandle);
	if (CurrentLobby.RTCRoomParticipantAudioUpdate != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_RTCAudio_RemoveNotifyParticipantUpdated(RTCAudioHandle, CurrentLobby.RTCRoomParticipantAudioUpdate);
		CurrentLobby.RTCRoomParticipantAudioUpdate = EOS_INVALID_NOTIFICATIONID;
	}

	if (CurrentLobby.RTCRoomParticipantUpdate != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_RTC_RemoveNotifyParticipantStatusChanged(RTCHandle, CurrentLobby.RTCRoomParticipantUpdate);
		CurrentLobby.RTCRoomParticipantUpdate = EOS_INVALID_NOTIFICATIONID;
	}

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());
	if (CurrentLobby.RTCRoomConnectionChanged != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Lobby_RemoveNotifyRTCRoomConnectionChanged(LobbyHandle, CurrentLobby.RTCRoomConnectionChanged);
		CurrentLobby.RTCRoomConnectionChanged = EOS_INVALID_NOTIFICATIONID;
	}

	if (CurrentLobby.RTCRoomDataReceived != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_HRTCData RTCDataHandle = EOS_RTC_GetDataInterface(RTCHandle);

		EOS_RTCData_RemoveNotifyDataReceived(RTCDataHandle, CurrentLobby.RTCRoomDataReceived);
		CurrentLobby.RTCRoomDataReceived = EOS_INVALID_NOTIFICATIONID;
	}

	CurrentLobby.RTCRoomName.clear();
}

void FLobbies::OnLobbyCreated(EOS_LobbyId Id)
{
	if (Id && CurrentLobby.bBeingCreated)
	{
		CurrentLobby.Id = Id;
		ModifyLobby(CurrentLobby);
		if (CurrentLobby.IsRTCRoomEnabled())
		{
			SubscribeToRTCEvents();
		}
		bDirty = true;
	}
}

void FLobbies::OnLobbyUpdated(EOS_LobbyId Id)
{
	if (Id && CurrentLobby.Id == Id)
	{
		CurrentLobby.InitFromLobbyHandle(Id);
		SetInitialMemberAttribute();
		bDirty = true;
	}
}

void FLobbies::OnLobbyUpdate(EOS_LobbyId Id)
{
	if (Id && CurrentLobby.Id == Id)
	{
		CurrentLobby.InitFromLobbyHandle(Id);
		SetInitialMemberAttribute();
		bDirty = true;
	}
}

void FLobbies::OnLobbyJoined(EOS_LobbyId Id)
{
	if (CurrentLobby.IsValid() && CurrentLobby.Id != Id)
	{
		LeaveLobby();
	}

	CurrentLobby.InitFromLobbyHandle(Id);

	SetInitialMemberAttribute();

	if (CurrentLobby.IsRTCRoomEnabled())
	{
		SubscribeToRTCEvents();
	}

	bDirty = true;

	//Clear search
	if (CurrentSearch.IsValid())
	{
		CurrentSearch.Release();
	}

	PopLobbyInvite();

	FGameEvent JoinEvent(EGameEventType::LobbyJoined);
	FGame::Get().OnGameEvent(JoinEvent);
}

void FLobbies::OnLobbyJoinFailed(EOS_LobbyId Id)
{
	bDirty = true;

	PopLobbyInvite();
}

void FLobbies::OnLobbyInvite(const char* InviteId, FProductUserId SenderId)
{
	FLobbyInvite NewLobbyInvite;

	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions Options = {};
	Options.ApiVersion = EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST;
	Options.InviteId = InviteId;
	EOS_HLobbyDetails DetailsHandle = nullptr;
	EOS_EResult Result = EOS_Lobby_CopyLobbyDetailsHandleByInviteId(LobbyHandle, &Options, &DetailsHandle);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyInvite) could not get lobby details: error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}
	if (DetailsHandle == nullptr)
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyInvite) could not get lobby details: null details handle.");
		return;
	}

	NewLobbyInvite.LobbyInfo = MakeLobbyDetailsKeeper(DetailsHandle);
	NewLobbyInvite.Lobby.InitFromLobbyDetails(DetailsHandle);
	NewLobbyInvite.InviteId.assign(InviteId);

	NewLobbyInvite.FriendId = SenderId;
	NewLobbyInvite.FriendEpicId = FEpicAccountId();
	NewLobbyInvite.FriendDisplayName.clear();

	auto NewLobbyInviteIter = Invites.find(SenderId);
	if (NewLobbyInviteIter != Invites.end())
	{
		//Replace existing invite
		NewLobbyInviteIter->second.Lobby = NewLobbyInvite.Lobby;
		NewLobbyInviteIter->second.LobbyInfo = NewLobbyInvite.LobbyInfo;

		//Update dialog data in case this invite is being shown
		if (CurrentInvite == &NewLobbyInviteIter->second)
		{
			FGameEvent GameEvent(EGameEventType::LobbyInviteReceived);
			FGame::Get().OnGameEvent(GameEvent);
		}
	}
	else
	{
		//Add new invite
		Invites[SenderId] = NewLobbyInvite;
	}

	if (!CurrentInvite)
	{
		PopLobbyInvite();
	}

	bDirty = true;
}

void FLobbies::OnLobbyInviteAccepted(const char* InviteId, FProductUserId SenderId)
{
	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions Options = {};
	Options.ApiVersion = EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST;
	Options.InviteId = InviteId;
	EOS_HLobbyDetails DetailsHandle = nullptr;
	EOS_EResult Result = EOS_Lobby_CopyLobbyDetailsHandleByInviteId(LobbyHandle, &Options, &DetailsHandle);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyInviteAccepted) could not get lobby details: error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}
	if (DetailsHandle == nullptr)
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyInviteAccepted) could not get lobby details: null details handle.");
		return;
	}

	LobbyDetailsKeeper LobbyInfo = MakeLobbyDetailsKeeper(DetailsHandle);
	FLobby Lobby; 
	Lobby.InitFromLobbyDetails(DetailsHandle);

	const bool bPresenceEnabled = true;
	JoinLobby(Lobby.Id.c_str(), LobbyInfo, bPresenceEnabled);
}

void FLobbies::OnJoinLobbyAccepted(FProductUserId LocalUserId, EOS_UI_EventId UiEventId)
{
	EOS_HLobby LobbyHandle = EOS_Platform_GetLobbyInterface(FPlatform::GetPlatformHandle());

	EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions CopyOptions = {};
	CopyOptions.ApiVersion = EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYUIEVENTID_API_LATEST;
	CopyOptions.UiEventId = UiEventId;

	EOS_HLobbyDetails DetailsHandle;
	EOS_EResult Result = EOS_Lobby_CopyLobbyDetailsHandleByUiEventId(LobbyHandle, &CopyOptions, &DetailsHandle);

	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Lobbies (OnJoinLobbyAccepted) could not get lobby details: error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}
	if (DetailsHandle == nullptr)
	{
		FDebugLog::LogError(L"Lobbies (OnJoinLobbyAccepted) could not get lobby details: null details handle.");
		return;
	}

	LobbyDetailsKeeper LobbyInfo = MakeLobbyDetailsKeeper(DetailsHandle);
	FLobby Lobby; 
	Lobby.InitFromLobbyDetails(DetailsHandle);

	const bool bPresenceEnabled = true;
	JoinLobby(Lobby.Id.c_str(), LobbyInfo, bPresenceEnabled);
}

void FLobbies::OnSearchResultsReceived()
{
	EOS_LobbySearch_GetSearchResultCountOptions SearchResultOptions = {};
	SearchResultOptions.ApiVersion = EOS_LOBBYSEARCH_GETSEARCHRESULTCOUNT_API_LATEST;
	uint32_t NumSearchResults = EOS_LobbySearch_GetSearchResultCount(CurrentSearch.GetSearchHandle(), &SearchResultOptions);

	std::vector<FLobby> SearchResults;
	std::vector<LobbyDetailsKeeper> ResultHandles;

	EOS_LobbySearch_CopySearchResultByIndexOptions IndexOptions = {};
	IndexOptions.ApiVersion = EOS_LOBBYSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST;
	for (uint32_t SearchIndex = 0; SearchIndex < NumSearchResults; ++SearchIndex)
	{
		FLobby NextLobby;

		EOS_HLobbyDetails NextLobbyDetails = nullptr;
		IndexOptions.LobbyIndex = SearchIndex;
		EOS_EResult Result = EOS_LobbySearch_CopySearchResultByIndex(CurrentSearch.GetSearchHandle(), &IndexOptions, &NextLobbyDetails);
		if (Result == EOS_EResult::EOS_Success && NextLobbyDetails)
		{
			NextLobby.InitFromLobbyDetails(NextLobbyDetails);

			NextLobby.bSearchResult = true;
			SearchResults.push_back(NextLobby);
			ResultHandles.push_back(MakeLobbyDetailsKeeper(NextLobbyDetails));
		}
	}

	CurrentSearch.OnSearchResultsReceived(std::move(SearchResults), std::move(ResultHandles));
	bDirty = true;
}

void FLobbies::OnKickedFromLobby(EOS_LobbyId Id)
{
	if (CurrentLobby.IsValid() && CurrentLobby.Id == Id)
	{
		CurrentLobby.Clear();
		bDirty = true;
	}
}

void FLobbies::OnLobbyLeftOrDestroyed(EOS_LobbyId Id)
{
	bLobbyLeaveInProgress = false;
	if (ActiveJoin.IsValid())
	{
		FLobbyJoinRequest CurrentJoin(std::move(ActiveJoin));
		ActiveJoin.Clear();
		JoinLobby(CurrentJoin.Id, CurrentJoin.LobbyInfo, CurrentJoin.bPresenceEnabled);
	}
}

void FLobbies::OnHardMuteMemberFinished(EOS_LobbyId Id, FProductUserId ParticipantId, EOS_EResult Result)
{
	if (!CurrentLobby.IsValid() || CurrentLobby.Id != Id)
	{
		return;
	}

	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(ParticipantId))
	{
		LobbyMember->RTCState.bHardMuteActionInProgress = false;
			
		if (Result == EOS_EResult::EOS_Success)
		{
			FDebugLog::Log(L"Lobbies (OnHardMuteMemberFinished): success.");
			LobbyMember->RTCState.bIsHardMuted = !LobbyMember->RTCState.bIsHardMuted; // we only support toggle functionality in this sample so we know the new state
		}
		else
		{
			FDebugLog::LogError(L"Lobbies (OnHardMuteMemberFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		}
	}
}

void FLobbies::OnRTCRoomConnectionChanged(EOS_LobbyId Id, FProductUserId LocalUserId, bool bIsConnected)
{
	// Ensure this update is for our room
	if (!CurrentLobby.IsValid() || CurrentLobby.Id != Id)
	{
		return;
	}

	if (CurrentUserProductId != LocalUserId)
	{
		return;
	}

	CurrentLobby.bRTCRoomConnected = bIsConnected;

	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(LocalUserId))
	{
		LobbyMember->RTCState.bIsInRTCRoom = bIsConnected;
		if (!bIsConnected)
		{
			LobbyMember->RTCState.bIsTalking = false;
		}
	}

	bDirty = true;
}

void FLobbies::OnRTCRoomParticipantJoined(const char* RoomName, FProductUserId ParticipantId)
{
	// Ensure this update is for our room
	if (CurrentLobby.RTCRoomName.empty() || CurrentLobby.RTCRoomName != RoomName)
	{
		return;
	}

	// Find this participant in our list
	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(ParticipantId))
	{
		// Update in-room status
		LobbyMember->RTCState.bIsInRTCRoom = true;

		bDirty = true;
	}

	// Send update of skin color to new participant
	if (FLobbyMember* LocalLobbyMember = CurrentLobby.GetMemberByProductUserId(CurrentUserProductId))
	{
		SendSkinColorUpdate(LocalLobbyMember->CurrentColor);
	}
}

void FLobbies::OnRTCRoomParticipantLeft(const char* RoomName, FProductUserId ParticipantId)
{
	// Ensure this update is for our room
	if (CurrentLobby.RTCRoomName.empty() || CurrentLobby.RTCRoomName != RoomName)
	{
		return;
	}

	// Find this participant in our list
	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(ParticipantId))
	{
		// Update in-room status
		LobbyMember->RTCState.bIsInRTCRoom = false;

		// Additionally clear their talking status when they leave, just to be safe
		LobbyMember->RTCState.bIsTalking = false;

		bDirty = true;
	}
}

void FLobbies::OnRTCRoomParticipantAudioUpdated(const char* RoomName, FProductUserId ParticipantId, bool bIsTalking, bool bIsAudioDisabled, bool bIsHardMuted)
{
	// Ensure this update is for our room
	if (CurrentLobby.RTCRoomName.empty() || CurrentLobby.RTCRoomName != RoomName)
	{
		return;
	}

	// Find this participant in our list
	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(ParticipantId))
	{
		// Update talking status
		LobbyMember->RTCState.bIsTalking = bIsTalking;

		// Update the audio output status for other players
		if (LobbyMember->ProductId != CurrentUserProductId)
		{
			LobbyMember->RTCState.bIsAudioOutputDisabled = bIsAudioDisabled;
		}
		else // I could have been hard-muted by the lobby owner
		{
			LobbyMember->RTCState.bIsHardMuted = bIsHardMuted;
		}

		bDirty = true;
	}
}

void FLobbies::OnRTCRoomUpdateSendingComplete(const char* RoomName, FProductUserId ParticipantId, EOS_ERTCAudioStatus NewAudioStatus)
{
	// Ensure this update is for our room
	if (CurrentLobby.RTCRoomName.empty() || CurrentLobby.RTCRoomName != RoomName)
	{
		return;
	}

	// Ensure this update is for us
	if (CurrentUserProductId != ParticipantId)
	{
		return;
	}

	// Update our mute status
	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(ParticipantId))
	{
		LobbyMember->RTCState.bIsAudioOutputDisabled = NewAudioStatus == EOS_ERTCAudioStatus::EOS_RTCAS_Disabled;
		LobbyMember->RTCState.bMuteActionInProgress = false;
		bDirty = true;
	}
}

void FLobbies::OnRTCRoomUpdateReceivingComplete(const char* RoomName, FProductUserId ParticipantId, bool bIsMuted)
{
	// Ensure this update is for our room
	if (CurrentLobby.RTCRoomName.empty() || CurrentLobby.RTCRoomName != RoomName)
	{
		return;
	}

	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(ParticipantId))
	{
		LobbyMember->RTCState.bIsLocallyMuted = bIsMuted;
		LobbyMember->RTCState.bMuteActionInProgress = false;
		bDirty = true;
	}
}

void FLobbies::OnRTCRoomDataReceived(const char* RoomName, FProductUserId ParticipantId, const void* Data, uint32_t DataLengthBytes)
{
	// Ensure this update is for our room
	if (CurrentLobby.RTCRoomName.empty() || CurrentLobby.RTCRoomName != RoomName)
	{
		return;
	}

	if (DataLengthBytes < sizeof(ELobbyRTCDataCommand))
	{
		FDebugLog::LogError(L"Lobbies (OnRTCRoomDataReceived): wrong command format");
		return;
	}

	ELobbyRTCDataCommand Command = *(static_cast<const ELobbyRTCDataCommand*>(Data));
	const void* Payload = static_cast<const uint8_t*>(Data) + sizeof(ELobbyRTCDataCommand);

	switch (Command)
	{
	case ELobbyRTCDataCommand::SkinColor:
		{
			const size_t SkinColorCommandLength = sizeof(ELobbyRTCDataCommand) + sizeof(FLobbyMember::SkinColor);
			if (DataLengthBytes >= SkinColorCommandLength)
			{
				uint8_t SkinColorInt = *(static_cast<const uint8_t*>(Payload));
				if (static_cast<uint8_t>(FLobbyMember::SkinColor::White) <= SkinColorInt && SkinColorInt < static_cast<uint8_t>(FLobbyMember::SkinColor::Count))
				{
					OnSkinColorChanged(ParticipantId, *(static_cast<const FLobbyMember::SkinColor*>(Payload)));
				}
				else
				{
					FDebugLog::LogError(L"Lobbies (OnRTCRoomDataReceived): wrong skin color value");
				}
			}
			else
			{
				FDebugLog::LogError(L"Lobbies (OnRTCRoomDataReceived): wrong command format");
			}
		}
		break;
	default:
		FDebugLog::Log(L"Lobbies (OnRTCRoomDataReceived): unexpected command %d", Command);
	}
}

void FLobbies::OnSkinColorChanged(FProductUserId ParticipantId, const FLobbyMember::SkinColor InColor)
{
	// Find this participant in our list
	if (FLobbyMember* LobbyMember = CurrentLobby.GetMemberByProductUserId(ParticipantId))
	{
		// Update skin color of participant
		LobbyMember->CurrentColor = InColor;

		bDirty = true;
	}
}

void EOS_CALL FLobbies::OnCreateLobbyFinished(const EOS_Lobby_CreateLobbyCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnCreateLobbyFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnCreateLobbyFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnCreateLobbyFinished): lobby created.");

			FGame::Get().GetLobbies()->OnLobbyCreated(Data->LobbyId);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnCreateLobbyFinished): EOS_Lobby_CreateLobbyCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnDestroyLobbyFinished(const EOS_Lobby_DestroyLobbyCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnDestroyLobbyFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnDestroyLobbyFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnDestroyLobbyFinished): lobby destroyed.");
			FGame::Get().GetLobbies()->OnLobbyLeftOrDestroyed(Data->LobbyId);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnDestroyLobbyFinished): EOS_Lobby_DestroyLobbyCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnLobbyUpdateFinished(const EOS_Lobby_UpdateLobbyCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnLobbyUpdateFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnLobbyUpdateFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnLobbyUpdateFinished): lobby updated.");
			FGame::Get().GetLobbies()->OnLobbyUpdated(Data->LobbyId);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyUpdateFinished): EOS_Lobby_UpdateLobbyCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnLobbyUpdateReceived(const EOS_Lobby_LobbyUpdateReceivedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Lobbies (OnLobbyUpdateReceived): lobby update received.");
		FGame::Get().GetLobbies()->OnLobbyUpdate(Data->LobbyId);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyUpdateReceived): EOS_Lobby_LobbyUpdateReceivedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnMemberUpdateReceived(const EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Lobbies (OnMemberUpdateReceived): member update received.");
		//Simply update the whole lobby
		FGame::Get().GetLobbies()->OnLobbyUpdate(Data->LobbyId);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnMemberUpdateReceived): EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnMemberStatusReceived(const EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Lobbies (OnMemberStatusReceived): member status update received.");


		PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
		if (Player == nullptr)
		{
			FDebugLog::LogError(L"Lobbies - OnMemberStatusReceived: Current player is invalid!");
			return;
		}
		
		if (!Player->GetProductUserID())
		{
			FDebugLog::LogError(L"Lobbies - OnMemberStatusReceived: Current player is invalid!");

			//Simply update the whole lobby
			FGame::Get().GetLobbies()->OnLobbyUpdate(Data->LobbyId);

			return;
		}

		bool bUpdateLobby = true;
		//Current player updates need special handling
		if (Data->TargetUserId == Player->GetProductUserID())
		{
			if (Data->CurrentStatus == EOS_ELobbyMemberStatus::EOS_LMS_CLOSED ||
				Data->CurrentStatus == EOS_ELobbyMemberStatus::EOS_LMS_KICKED ||
				Data->CurrentStatus == EOS_ELobbyMemberStatus::EOS_LMS_DISCONNECTED)
			{
				FGame::Get().GetLobbies()->OnKickedFromLobby(Data->LobbyId);
				bUpdateLobby = false;
			}
		}

		if (bUpdateLobby)
		{
			//Simply update the whole lobby
			FGame::Get().GetLobbies()->OnLobbyUpdate(Data->LobbyId);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnMemberStatusReceived): EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnJoinLobbyFinished(const EOS_Lobby_JoinLobbyCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnJoinLobbyFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnJoinLobbyFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
			FGame::Get().GetLobbies()->OnLobbyJoinFailed(Data->LobbyId);
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnJoinLobbyFinished): lobby join finished.");
			FGame::Get().GetLobbies()->OnLobbyJoined(Data->LobbyId);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnJoinLobbyFinished): EOS_Lobby_JoinLobbyCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnLeaveLobbyFinished(const EOS_Lobby_LeaveLobbyCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnLeaveLobbyFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnLeaveLobbyFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnLeaveLobbyFinished): lobby left.");
			FGame::Get().GetLobbies()->OnLobbyLeftOrDestroyed(Data->LobbyId);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnLeaveLobbyFinished): EOS_Lobby_LobbyUpdateReceivedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnLobbyInviteSendFinished(const EOS_Lobby_SendInviteCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnLobbyInviteSendFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnLobbyInviteSendFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnLobbyInviteSendFinished): invite sent.");
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyInviteSendFinished): EOS_Lobby_SendInviteCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnLobbyInviteReceived(const EOS_Lobby_LobbyInviteReceivedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Lobbies (OnLobbyInviteReceived): invite received.");
		FGame::Get().GetLobbies()->OnLobbyInvite(Data->InviteId, Data->TargetUserId);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyInviteReceived): EOS_Lobby_LobbyInviteReceivedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnLobbyInviteAccepted(const EOS_Lobby_LobbyInviteAcceptedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Lobbies (OnLobbyInviteAccepted): invite received.");

		//Hide popup
		FGameEvent Event(EGameEventType::OverlayInviteToLobbyAccepted);
		FGame::Get().OnGameEvent(Event);

		FGame::Get().GetLobbies()->OnLobbyInviteAccepted(Data->InviteId, Data->TargetUserId);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnLobbyInviteAccepted): EOS_Lobby_LobbyInviteAcceptedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnJoinLobbyAccepted(const EOS_Lobby_JoinLobbyAcceptedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Lobbies (OnJoinLobbyAccepted): invite received.");

		FGame::Get().GetLobbies()->OnJoinLobbyAccepted(Data->LocalUserId, Data->UiEventId);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnJoinLobbyAccepted): EOS_Lobby_JoinLobbyAcceptedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnRejectInviteFinished(const EOS_Lobby_RejectInviteCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnRejectInviteFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnRejectInviteFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnRejectInviteFinished): invite rejected.");
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnRejectInviteFinished): EOS_Lobby_RejectInviteCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnLobbySearchFinished(const EOS_LobbySearch_FindCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnLobbySearchFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnLobbySearchFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnLobbySearchFinished): search finished.");

			FGame::Get().GetLobbies()->OnSearchResultsReceived();
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnLobbySearchFinished): EOS_LobbySearch_FindCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnKickMemberFinished(const EOS_Lobby_KickMemberCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnKickMemberFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnKickMemberFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnKickMemberFinished): member kicked.");
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnKickMemberFinished): EOS_Lobby_KickMemberCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnHardMuteMemberFinished(const EOS_Lobby_HardMuteMemberCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnHardMuteMemberFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
			return;
		}

		FGame::Get().GetLobbies()->OnHardMuteMemberFinished(Data->LobbyId, Data->TargetUserId, Data->ResultCode);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnHardMuteMemberFinished): EOS_Lobby_HardMuteMemberCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnPromoteMemberFinished(const EOS_Lobby_PromoteMemberCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnPromoteMemberFinished): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Lobbies (OnPromoteMemberFinished): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Lobbies (OnPromoteMemberFinished): member promoted.");
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnPromoteMemberFinished): EOS_Lobby_PromoteMemberCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnRTCRoomConnectionChangeReceived(const EOS_Lobby_RTCRoomConnectionChangedCallbackInfo* Data)
{
	if (Data)
	{
		const bool bIsConnected = Data->bIsConnected != EOS_FALSE;
		FDebugLog::Log(L"Lobbies (OnRTCRoomConnectionChangeReceived): connection status changed. LobbyId=[%ls] bIsConnected=[%d] DisconnectReason=[%ls]",
			FStringUtils::Widen(Data->LobbyId).c_str(),
			bIsConnected,
			FStringUtils::Widen(EOS_EResult_ToString(Data->DisconnectReason)).c_str());

		FGame::Get().GetLobbies()->OnRTCRoomConnectionChanged(Data->LobbyId, Data->LocalUserId, bIsConnected);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnRTCRoomConnectionChangeReceived): EOS_Lobby_RTCRoomConnectionChangedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnRTCRoomParticipantStatusChanged(const EOS_RTC_ParticipantStatusChangedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Lobbies (OnRTCRoomParticipantStatusChanged): participant updated.");

		const wchar_t* StatusText = Data->ParticipantStatus == EOS_ERTCParticipantStatus::EOS_RTCPS_Joined ? L"Joined" : L"Left";

		FDebugLog::Log(L"Lobbies (OnRTCRoomParticipantStatusChanged): participant updated. LocalUserId=[%ls] Room=[%ls] ParticipantUserId=[%ls] ParticipantStatus=[%ls] MetadataCount=[%u]",
			FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->LocalUserId)).c_str(),
			FStringUtils::Widen(Data->RoomName).c_str(),
			FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->ParticipantId)).c_str(),
			StatusText,
			Data->ParticipantMetadataCount);

		if (Data->ParticipantStatus == EOS_ERTCParticipantStatus::EOS_RTCPS_Joined)
		{
			FGame::Get().GetLobbies()->OnRTCRoomParticipantJoined(Data->RoomName, Data->ParticipantId);
		}
		else
		{
			FGame::Get().GetLobbies()->OnRTCRoomParticipantLeft(Data->RoomName, Data->ParticipantId);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnRTCRoomParticipantStatusChanged): EOS_RTCAudio_ParticipantUpdatedCallbackInfo is null");
	}
}


void EOS_CALL FLobbies::OnRTCRoomParticipantAudioUpdateRecieved(const EOS_RTCAudio_ParticipantUpdatedCallbackInfo* Data)
{
	if (Data)
	{
		const bool bIsTalking = Data->bSpeaking != EOS_FALSE;
		const bool bIsAudioDisabled = Data->AudioStatus != EOS_ERTCAudioStatus::EOS_RTCAS_Enabled;
		const bool bIsHardMuted = Data->AudioStatus == EOS_ERTCAudioStatus::EOS_RTCAS_AdminDisabled;

		FDebugLog::Log(L"Lobbies (OnAudioParticipantUpdateRecieved): participant audio updated. LocalUserId=[%ls] Room=[%ls] ParticipantUserId=[%ls] bIsTalking=[%d] bIsAudioDisabled=[%d (%d)]",
			FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->LocalUserId)).c_str(),
			FStringUtils::Widen(Data->RoomName).c_str(),
			FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->ParticipantId)).c_str(),
			bIsTalking,
			bIsAudioDisabled,
			static_cast<int32_t>(Data->AudioStatus));

		FGame::Get().GetLobbies()->OnRTCRoomParticipantAudioUpdated(Data->RoomName, Data->ParticipantId, bIsTalking, bIsAudioDisabled, bIsHardMuted);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnAudioParticipantUpdateRecieved): EOS_RTCAudio_ParticipantUpdatedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnRTCRoomUpdateSendingComplete(const EOS_RTCAudio_UpdateSendingCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnRTCRoomUpdateSendingComplete): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			if (Data->ResultCode != EOS_EResult::EOS_Success)
			{
				FDebugLog::LogError(L"Lobbies (OnRTCRoomUpdateSendingComplete): failed to update sending status");
			}
			else
			{
				const bool bIsAudioOutputDisabled = Data->AudioStatus != EOS_ERTCAudioStatus::EOS_RTCAS_Enabled;

				FDebugLog::Log(L"Lobbies (OnRTCRoomUpdateSendingComplete): Updated sending status successfully. LocalUserId=[%ls] Room=[%ls] bIsAudioOutputDisabled=[%d (%d)]",
					FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->LocalUserId)).c_str(),
					FStringUtils::Widen(Data->RoomName).c_str(),
					bIsAudioOutputDisabled,
					static_cast<int32_t>(Data->AudioStatus));
			}

			FGame::Get().GetLobbies()->OnRTCRoomUpdateSendingComplete(Data->RoomName, Data->LocalUserId, Data->AudioStatus);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnRTCRoomUpdateSendingComplete): EOS_RTCAudio_UpdateSendingCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnRTCRoomUpdateReceivingComplete(const EOS_RTCAudio_UpdateReceivingCallbackInfo* Data)
{
	if (Data)
	{
		if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			FDebugLog::Log(L"Lobbies (OnRTCRoomUpdateReceivingComplete): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			const bool bIsMuted = Data->bAudioEnabled == EOS_FALSE;
			if (Data->ResultCode != EOS_EResult::EOS_Success)
			{
				FDebugLog::LogError(L"Lobbies (OnRTCRoomUpdateReceivingComplete): failed to update receiving status");
			}
			else
			{
				FDebugLog::Log(L"Lobbies (OnRTCRoomUpdateReceivingComplete): Updated receiving status successfully. ParticipantId=[%ls] Room=[%ls] bIsMuted=[%d]",
					FStringUtils::Widen(FAccountHelpers::ProductUserIDToString(Data->ParticipantId)).c_str(),
					FStringUtils::Widen(Data->RoomName).c_str(),
					bIsMuted);
			}
			FGame::Get().GetLobbies()->OnRTCRoomUpdateReceivingComplete(Data->RoomName, Data->ParticipantId, bIsMuted);
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnRTCRoomUpdateReceivingComplete): EOS_RTCAudio_UpdateReceivingCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnRTCRoomDataReceived(const EOS_RTCData_DataReceivedCallbackInfo* Data)
{
	if (Data)
	{
		FGame::Get().GetLobbies()->OnRTCRoomDataReceived(Data->RoomName, Data->ParticipantId, Data->Data, Data->DataLengthBytes);
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnRTCRoomDataReceived): EOS_RTCData_DataReceivedCallbackInfo is null");
	}
}

void EOS_CALL FLobbies::OnLeaveLobbyRequested(const EOS_Lobby_LeaveLobbyRequestedCallbackInfo* Data)
{
	if (Data)
	{
		const std::string LeaveLobbyId = std::string(Data->LobbyId);
		const std::string CurrentLobbyId = FGame::Get().GetLobbies()->GetCurrentLobby().Id;
		if (LeaveLobbyId == CurrentLobbyId)
		{
			FDebugLog::Log(L"Lobbies: Leave lobby requested for LobbyId = %ls", FStringUtils::Widen(LeaveLobbyId).c_str());
			FGame::Get().GetLobbies()->LeaveLobby();
		}
		else
		{
			FDebugLog::LogError(L"Lobbies (OnLeaveLobbyRequested): Leave lobby requested on non active lobby. LeaveLobbyId = %ls, CurrentLobbyId = %ls", FStringUtils::Widen(LeaveLobbyId).c_str(), FStringUtils::Widen(CurrentLobbyId).c_str());
		}
	}
	else
	{
		FDebugLog::LogError(L"Lobbies (OnLeaveLobbyRequested): EOS_Lobby_LeaveLobbyRequestedCallbackInfo is null");
	}
}

void FLobbyAttribute::InitFromAttribute(EOS_Lobby_Attribute* Attr)
{
	if (!Attr)
	{
		return;
	}

	Visibility = Attr->Visibility;
	Key = Attr->Data->Key;
	switch (Attr->Data->ValueType)
	{
	case EOS_ELobbyAttributeType::EOS_AT_BOOLEAN:
		ValueType = FLobbyAttribute::Bool;
		AsBool = Attr->Data->Value.AsBool;
		break;
	case EOS_ELobbyAttributeType::EOS_AT_INT64:
		ValueType = FLobbyAttribute::Int64;
		AsInt64 = Attr->Data->Value.AsInt64;
		break;
	case EOS_ELobbyAttributeType::EOS_AT_DOUBLE:
		ValueType = FLobbyAttribute::Double;
		AsDouble = Attr->Data->Value.AsDouble;
		break;
	case EOS_ELobbyAttributeType::EOS_AT_STRING:
		ValueType = FLobbyAttribute::String;
		AsString = Attr->Data->Value.AsUtf8;
		break;
	}
}

EOS_Lobby_AttributeData FLobbyAttribute::ToAttributeData() const
{
	EOS_Lobby_AttributeData AttributeData;

	AttributeData.ApiVersion = EOS_LOBBY_ATTRIBUTEDATA_API_LATEST;
	AttributeData.Key = Key.c_str();

	switch (ValueType)
	{
	case FLobbyAttribute::Type::Bool:
		AttributeData.ValueType = EOS_ELobbyAttributeType::EOS_AT_BOOLEAN;
		AttributeData.Value.AsBool = AsBool;
		break;
	case FLobbyAttribute::Type::Double:
		AttributeData.ValueType = EOS_ELobbyAttributeType::EOS_AT_DOUBLE;
		AttributeData.Value.AsDouble = AsDouble;
		break;
	case FLobbyAttribute::Type::Int64:
		AttributeData.ValueType = EOS_ELobbyAttributeType::EOS_AT_INT64;
		AttributeData.Value.AsInt64 = AsInt64;
		break;
	case FLobbyAttribute::Type::String:
		AttributeData.ValueType = EOS_ELobbyAttributeType::EOS_AT_STRING;
		AttributeData.Value.AsUtf8 = AsString.c_str();
		break;
	}

	return AttributeData;
}

std::wstring FLobbyMember::GetAttributesString() const
{
	std::wstring Result;
	for (const FLobbyAttribute& Attribute : MemberAttributes)
	{
		std::wstring AttributeString = L"{ Key = " + FStringUtils::Widen(Attribute.Key);

		//We only support strings in the sample
		AttributeString += L" Value = " + FStringUtils::Widen(Attribute.AsString) + L" } ";

		Result += AttributeString;
	}

	return Result;
}

```

`EAC_SDK/Samples/Lobbies/Source/Lobbies.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_sdk.h>
#include <eos_lobby.h>
#include <eos_lobby_types.h>
#include <eos_rtc_types.h>
#include <eos_rtc_audio_types.h>
#include <eos_rtc_data_types.h>

/**
 * Simple Attribute struct to contain lobby attribute information. It can have a value from one of the available types.
 */
struct FLobbyAttribute
{
	enum Type
	{
		String,
		Int64,
		Double,
		Bool
	};
	Type ValueType = Type::String;

	//Only one of the following properties will have valid data (depending on 'ValueType')
	int64_t AsInt64 = 0;
	double AsDouble = 0.0;
	bool AsBool = false;
	std::string AsString;

	//Attribute key
	std::string Key;

	//Is this attribute public or private to the lobby and its members
	EOS_ELobbyAttributeVisibility Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;

	bool operator==(const FLobbyAttribute& Other) const
	{
		return ValueType == Other.ValueType &&
			AsInt64 == Other.AsInt64 &&
			AsDouble == Other.AsDouble &&
			AsBool == Other.AsBool &&
			Key == Other.Key &&
			Visibility == Other.Visibility &&
			AsString == Other.AsString;
	}

	bool operator !=(const FLobbyAttribute& Other) const
	{
		return !(operator==(Other));
	}

	void InitFromAttribute(EOS_Lobby_Attribute* Attr);
	EOS_Lobby_AttributeData ToAttributeData() const;
};

struct FLobbyMember
{
	enum class Skin : int32_t
	{
		Peasant = 0,
		Knight,
		Princess,
		Joker,
		Mage,
		Count
	};

	enum class SkinColor : uint8_t
	{
		White = 0,
		Yellow,
		LightGreen,
		Pink,
		Aqua,
		Count
	};

	std::wstring GetAttributesString() const;
	void ShuffleSkin()
	{
		CurrentSkin = static_cast<Skin>(static_cast<int32_t>(CurrentSkin) + 1);
		if (CurrentSkin >= Skin::Count)
		{
			CurrentSkin = Skin::Peasant;
		}
	}
	void ShuffleColor()
	{
		CurrentColor = static_cast<SkinColor>(static_cast<int32_t>(CurrentColor) + 1);
		if (CurrentColor >= SkinColor::Count)
		{
			CurrentColor = SkinColor::White;
		}

	}
	static std::string GetSkinString(Skin InSkin)
	{
		switch (InSkin)
		{
		case Skin::Peasant:
			return "Peasant";
		case Skin::Knight:
			return "Knight";
		case Skin::Princess:
			return "Princess";
		case Skin::Joker:
			return "Joker";
		case Skin::Mage:
			return "Mage";
		default:
			return "INVALID";
		}

		return "INVALID";
	}

	static FColor GetSkinColor(SkinColor InColor)
	{
		switch (InColor)
		{
		case SkinColor::White:
			return Color::White;
		case SkinColor::Yellow:
			return Color::Yellow;
		case SkinColor::LightGreen:
			return Color::LightGreen;
		case SkinColor::Pink:
			return Color::Pink;
		case SkinColor::Aqua:
			return Color::Aqua;
		default:
			return Color::White;
		}
	}

	void InitSkinFromString(const std::string& SkinString)
	{
		for (int32_t SkinInt = 0; SkinInt < static_cast<int32_t>(Skin::Count); ++SkinInt)
		{
			Skin NextSkin = static_cast<Skin>(SkinInt);
			if (SkinString == GetSkinString(NextSkin))
			{
				CurrentSkin = NextSkin;
				return;
			}
		}

		//fallback
		CurrentSkin = Skin::Peasant;
	}

	FEpicAccountId AccountId;
	FProductUserId ProductId;
	std::wstring DisplayName;
	Skin CurrentSkin = Skin::Peasant;
	SkinColor CurrentColor = SkinColor::White;
	std::vector<FLobbyAttribute> MemberAttributes;

	/** Container for all RTC-related state of this lobby member */
	struct FLobbyRTCState
	{
		/** Is this person currently connected to the RTC room? */
		bool bIsInRTCRoom = false;
		/** Is this person currently talking (audible sounds from their audio output) */
		bool bIsTalking = false;
		/** We have locally muted this person (others can still hear them) */
		bool bIsLocallyMuted = false;
		/** Is this person hard muted (muted for everyone in the lobby by lobby owner */
		bool bIsHardMuted = false;
		/** Has this person muted their own audio output (nobody can hear them)*/
		bool bIsAudioOutputDisabled = false;
		/** Are we currently muting this person? */
		bool bMuteActionInProgress = false;
		/** Are we currently hard muting this person? */
		bool bHardMuteActionInProgress = false;
	};
	FLobbyRTCState RTCState;
};

/** 
 * Game lobby class. Contains lobby information such as game settings, participants and their own attributes.
 */
struct FLobby
{
	bool IsValid() const { return !Id.empty(); }
	bool IsOwner(EOS_ProductUserId UserProductId) const { return FProductUserId(UserProductId) == LobbyOwner; }
	bool AreInvitesAllowed() const { return bAllowInvites; }
	bool IsPresenceEnabled() const { return bPresenceEnabled; }
	bool IsRTCRoomEnabled() const { return bRTCRoomEnabled; }

	void Clear() { Id = std::string(); }

	void InitFromLobbyHandle(EOS_LobbyId Id);
	void InitFromLobbyDetails(EOS_HLobbyDetails Id);

	bool operator==(const FLobby& Other) const
	{
		return Id == Other.Id;
	}

	bool operator !=(const FLobby& Other) const
	{
		return !operator==(Other);
	}

	const FLobbyAttribute* GetAttribute(std::string AttrKey) const
	{
		for (const FLobbyAttribute& NextAttr : Attributes)
		{
			if (NextAttr.Key == AttrKey)
			{
				return &NextAttr;
			}
		}

		return nullptr;
	}

	FLobbyMember* GetMemberByProductUserId(const FProductUserId& ProductId)
	{
		for (FLobbyMember& LobbyMember : Members)
		{
			if (LobbyMember.ProductId == ProductId)
			{
				return &LobbyMember;
			}
		}

		return nullptr;
	}

	EOS_ELobbyPermissionLevel Permission = EOS_ELobbyPermissionLevel::EOS_LPL_PUBLICADVERTISED;

	std::vector<FLobbyAttribute> Attributes;
	std::vector<FLobbyMember> Members;

	std::string Id;
	FProductUserId LobbyOwner;
	FEpicAccountId LobbyOwnerAccountId;
	std::wstring LobbyOwnerDisplayName;
	std::string BucketId;
	uint32_t MaxNumLobbyMembers = 0;
	uint32_t AvailableSlots = 0;
	bool bAllowInvites = true;

	/** Cached copy of the RoomName of the RTC room that our lobby has, if any */
	std::string RTCRoomName;
	/** Are we currently connected to an RTC room? */
	bool bRTCRoomConnected = false;
	/** Notification for RTC connection status changes */
	EOS_NotificationId RTCRoomConnectionChanged = EOS_INVALID_NOTIFICATIONID;
	/** Notification for RTC room participant updates (new players or players leaving) */
	EOS_NotificationId RTCRoomParticipantUpdate = EOS_INVALID_NOTIFICATIONID;
	/** Notification for RTC audio updates (talking status or mute changes) */
	EOS_NotificationId RTCRoomParticipantAudioUpdate = EOS_INVALID_NOTIFICATIONID;
	/** Notification for RTC data receiving */
	EOS_NotificationId RTCRoomDataReceived = EOS_INVALID_NOTIFICATIONID;

	//Utility data
	bool bBeingCreated = false;
	bool bSearchResult = false;
	bool bPresenceEnabled = false;
	bool bRTCRoomEnabled = false;
};

//Simple RAII wrapper to make sure LobbyDetails handles are released correctly.
using LobbyDetailsKeeper = std::shared_ptr<struct EOS_LobbyDetailsHandle>;
inline LobbyDetailsKeeper MakeLobbyDetailsKeeper(EOS_HLobbyDetails LobbyDetails)
{
	return LobbyDetailsKeeper(LobbyDetails, EOS_LobbyDetails_Release);
}

using LobbyModificationKeeper = std::shared_ptr<struct EOS_LobbyModificationHandle>;
inline LobbyModificationKeeper MakeLobbyDetailsKeeper(EOS_HLobbyModification LobbyModification)
{
	return LobbyModificationKeeper(LobbyModification, EOS_LobbyModification_Release);
}

/** 
 * Class to perform lobby query and to contain search results.
 */
class FLobbySearch
{
public:
	FLobbySearch() {}
	~FLobbySearch();

	FLobbySearch(const FLobbySearch&) = delete;
	FLobbySearch& operator=(const FLobbySearch&) = delete;

	bool IsValid() const { return SearchHandle; }

	//Release a clear current search
	void Release();

	//Clear previous and prepare for new search results.
	void SetNewSearch(EOS_HLobbySearch);

	//Called when new search data arrives.
	void OnSearchResultsReceived(std::vector<FLobby>&&, std::vector<LobbyDetailsKeeper>&&);

	//Getters to query current search results
	std::vector<FLobby>& GetResults() { return SearchResults; }
	const std::vector<FLobby>& GetResults() const { return SearchResults; }
	const std::vector<LobbyDetailsKeeper> GetDetailsHandles() const { return ResultHandles; }
	EOS_HLobbySearch GetSearchHandle() const { return SearchHandle; }
	LobbyDetailsKeeper GetLobbyDetailsHandleById(EOS_LobbyId LobbyId) const
	{
		for (size_t i = 0; i < SearchResults.size(); ++i)
		{
			if (SearchResults[i].Id == LobbyId)
			{
				if (ResultHandles.size() > i)
				{
					return ResultHandles[i];
				}
				break;
			}
		}
		return nullptr;
	}

private:
	EOS_HLobbySearch SearchHandle = nullptr;
	std::vector<FLobby> SearchResults;
	std::vector<LobbyDetailsKeeper> ResultHandles;
};

struct FLobbyInvite
{
	FLobby Lobby;
	LobbyDetailsKeeper LobbyInfo;
	FProductUserId FriendId;
	FEpicAccountId FriendEpicId;
	std::wstring FriendDisplayName;
	std::string InviteId;

	bool IsValid() const { return Lobby.IsValid(); }
	void Clear()
	{
		Lobby.Clear();
		LobbyInfo.reset();
		FriendId = FProductUserId();
		FriendEpicId = FEpicAccountId();
		FriendDisplayName.clear();
	}
};

struct FLobbyJoinRequest
{
	EOS_LobbyId Id;
	LobbyDetailsKeeper LobbyInfo;
	bool bPresenceEnabled = false;

	bool IsValid() const { return (!!Id) && LobbyInfo; }
	void Clear()
	{
		Id = nullptr;
		LobbyInfo.reset();
		bPresenceEnabled = false;
	}
};

/* Command type using with RTC Data channel*/
enum class ELobbyRTCDataCommand : uint8_t
{
	SkinColor = 0
};

/**
* Manages game lobbies.
*/
class FLobbies
{
public:
	/**
	* Constructor
	*/
	FLobbies() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FLobbies(FLobbies const&) = delete;
	FLobbies& operator=(FLobbies const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FLobbies();

	void OnShutdown();

	void Update();

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/**
	 * Get current local user
	 */
	FProductUserId GetLocalProductUserId() const { return CurrentUserProductId; }

	/**
	 *  Read-only access to current lobby. Sample only allows one lobby at a time.
	 */
	const FLobby& GetCurrentLobby() const { return CurrentLobby; }

	/**
	 *  Read-only access to current lobby we were invited to.
	 */
	const FLobbyInvite* GetCurrentInvite() const
	{
		return CurrentInvite;
	}

	/** 
	 * Get the name of a player who invited us to lobby
	 */
	const std::wstring& GetInviteSenderName() const
	{
		if (CurrentInvite)
		{
			return CurrentInvite->FriendDisplayName;
		}
		else
		{
			static std::wstring EmptyString;
			return EmptyString;
		}
	}

	/** 
	 * Drop current invite and pop the next pending invite
	 */
	void PopLobbyInvite();

	/**
	 * Accessor to search results.
	 */
	const FLobbySearch& GetCurrentSearch() const { return CurrentSearch; }

	bool HasActiveLobby() const { return CurrentLobby.IsValid(); }
	bool CanInviteToCurrentLobby(FProductUserId ProductUserId) const;

	//Lobby management (owner)

	/**
	* Leave current lobby (of any) then
	* create and automatically join lobby. 
	*/
	bool CreateLobby(const FLobby& Lobby);
	bool DestroyCurrentLobby();

	bool IsReadyToShutdown() const;

	/*
	 * Modify existing lobby. Lobby object must have the same id. It should also contain all the properties that need to be updated.
	 * Empty properties are interpret as 'no change'.
	 */
	bool ModifyLobby(const FLobby& LobbyChanges);

	//Pull data about lobby
	void UpdateLobby();

	void KickMember(EOS_ProductUserId MemberId);
	void PromoteMember(EOS_ProductUserId MemberId);

	//Lobby management (member)
	void JoinLobby(EOS_LobbyId Id, LobbyDetailsKeeper LobbyInfo, bool bPresenceEnabled);
	void JoinSearchResult(size_t Index);
	void RejectLobbyInvite(const std::string& InviteId);
	void LeaveLobby();
	void SendInvite(FProductUserId TargetUserId);
	void ShuffleSkin(); //Toggles your own skin (member attribute) between possible options
	void ShuffleColor(); // Toggle your own color between possible options
	void SendSkinColorUpdate(FLobbyMember::SkinColor InColor);
	void MuteAudio(FProductUserId TargetUserId);
	void ToggleHardMuteMember(FProductUserId TargetUserId);
	void HardMuteMember(FProductUserId TargetUserId, bool bIsHardMuted); // mute player for everyone in the lobby
	void SetMemberAttribute(const FLobbyAttribute& MemberAttribute);
	void SetInitialMemberAttribute();

	//Search for lobby
	void Search(const std::vector<FLobbyAttribute>& SearchAttributes, uint32_t MaxNumResults = 10);
	void Search(const std::string& LobbyId, uint32_t MaxNumResults);
	void SearchLobbyByLevel(const std::string& LevelName);
	void SearchLobbyByBucketId(const std::string& BucketId);
	void ClearSearch();

	void SubscribeToLobbyUpdates();
	void UnsubscribeFromLobbyUpdates();

	void SubscribeToLobbyInvites();
	void UnsubscribeFromLobbyInvites();

	void SubscribeToLeaveLobbyUI();
	void UnsubscribeFromLeaveLobbyUI();

	std::string GetRTCRoomName();

	void SubscribeToRTCEvents();
	void UnsubscribeFromRTCEvents();

	void OnLobbyCreated(EOS_LobbyId Id);
	void OnLobbyUpdated(EOS_LobbyId Id);
	void OnLobbyUpdate(EOS_LobbyId Id);
	void OnLobbyJoined(EOS_LobbyId Id);
	void OnLobbyJoinFailed(EOS_LobbyId Id);
	void OnLobbyInvite(const char* InviteId, FProductUserId SenderId);
	void OnLobbyInviteAccepted(const char* InviteId, FProductUserId SenderId);
	void OnJoinLobbyAccepted(FProductUserId LocalUserId, EOS_UI_EventId UiEventId);
	void OnSearchResultsReceived();
	void OnKickedFromLobby(EOS_LobbyId Id);
	void OnLobbyLeftOrDestroyed(EOS_LobbyId Id);
	void OnHardMuteMemberFinished(EOS_LobbyId Id, FProductUserId ParticipantId, EOS_EResult Result);
	void OnSkinColorChanged(FProductUserId ParticipantId, const FLobbyMember::SkinColor InColor);

	void OnRTCRoomConnectionChanged(EOS_LobbyId Id, FProductUserId LocalUserId, bool bIsConnected);
	void OnRTCRoomParticipantJoined(const char* RoomName, FProductUserId ParticipantId);
	void OnRTCRoomParticipantLeft(const char* RoomName, FProductUserId ParticipantId);
	void OnRTCRoomParticipantAudioUpdated(const char* RoomName, FProductUserId ParticipantId, bool bIsTalking, bool bIsMuted, bool bIsHardMuted);
	void OnRTCRoomUpdateSendingComplete(const char* RoomName, FProductUserId ParticipantId, EOS_ERTCAudioStatus NewAudioStatus);
	void OnRTCRoomUpdateReceivingComplete(const char* RoomName, FProductUserId ParticipantId, bool bIsMuted);
	void OnRTCRoomDataReceived(const char* RoomName, FProductUserId ParticipantId, const void* Data, uint32_t DataLengthBytes);

	//Callbacks
	static void EOS_CALL OnCreateLobbyFinished(const EOS_Lobby_CreateLobbyCallbackInfo* Data);
	static void EOS_CALL OnDestroyLobbyFinished(const EOS_Lobby_DestroyLobbyCallbackInfo* Data);
	static void EOS_CALL OnLobbyUpdateFinished(const EOS_Lobby_UpdateLobbyCallbackInfo* Data);
	static void EOS_CALL OnLobbyUpdateReceived(const EOS_Lobby_LobbyUpdateReceivedCallbackInfo* Data);
	static void EOS_CALL OnMemberUpdateReceived(const EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo* Data);
	static void EOS_CALL OnMemberStatusReceived(const EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo* Data);

	static void EOS_CALL OnJoinLobbyFinished(const EOS_Lobby_JoinLobbyCallbackInfo* Data);
	static void EOS_CALL OnLeaveLobbyFinished(const EOS_Lobby_LeaveLobbyCallbackInfo* Data);
	static void EOS_CALL OnLobbyInviteSendFinished(const EOS_Lobby_SendInviteCallbackInfo* Data);
	static void EOS_CALL OnLobbyInviteReceived(const EOS_Lobby_LobbyInviteReceivedCallbackInfo* Data);
	static void EOS_CALL OnLobbyInviteAccepted(const EOS_Lobby_LobbyInviteAcceptedCallbackInfo* Data);
	static void EOS_CALL OnJoinLobbyAccepted(const EOS_Lobby_JoinLobbyAcceptedCallbackInfo* Data);
	static void EOS_CALL OnRejectInviteFinished(const EOS_Lobby_RejectInviteCallbackInfo* Data);

	static void EOS_CALL OnLobbySearchFinished(const EOS_LobbySearch_FindCallbackInfo* Data);
	static void EOS_CALL OnKickMemberFinished(const EOS_Lobby_KickMemberCallbackInfo* Data);
	static void EOS_CALL OnHardMuteMemberFinished(const EOS_Lobby_HardMuteMemberCallbackInfo* Data);
	static void EOS_CALL OnPromoteMemberFinished(const EOS_Lobby_PromoteMemberCallbackInfo* Data);

	static void EOS_CALL OnRTCRoomConnectionChangeReceived(const EOS_Lobby_RTCRoomConnectionChangedCallbackInfo* Data);
	static void EOS_CALL OnRTCRoomParticipantStatusChanged(const EOS_RTC_ParticipantStatusChangedCallbackInfo* Data);
	static void EOS_CALL OnRTCRoomParticipantAudioUpdateRecieved(const EOS_RTCAudio_ParticipantUpdatedCallbackInfo* Data);
	static void EOS_CALL OnRTCRoomUpdateSendingComplete(const EOS_RTCAudio_UpdateSendingCallbackInfo* Data);
	static void EOS_CALL OnRTCRoomUpdateReceivingComplete(const EOS_RTCAudio_UpdateReceivingCallbackInfo* Data);
	static void EOS_CALL OnRTCRoomDataReceived(const EOS_RTCData_DataReceivedCallbackInfo* Data);

	static void EOS_CALL OnLeaveLobbyRequested(const EOS_Lobby_LeaveLobbyRequestedCallbackInfo* Data);

private:

	/**
	* Called when a user has logged in
	*/
	void OnLoggedIn(FEpicAccountId UserId);

	/**
	* Called when a user has logged out
	*/
	void OnLoggedOut(FEpicAccountId UserId);

	/**
	* Called when a user connect has logged in
	*/
	void OnUserConnectLoggedIn(FProductUserId ProductUserId);

	FProductUserId CurrentUserProductId;

	FLobby CurrentLobby;

	FLobbyJoinRequest ActiveJoin;

	//Pending invites (up to one invite per friend)
	std::map<FProductUserId, FLobbyInvite> Invites;

	//Invite that is being shown to the user (or null when nothing is being shown)
	FLobbyInvite* CurrentInvite = nullptr;

	//Search
	FLobbySearch CurrentSearch;

	EOS_NotificationId LobbyUpdateNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId LobbyMemberUpdateNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId LobbyMemberStatusNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId LobbyInviteNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId LobbyInviteAcceptedNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId JoinLobbyAcceptedNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId LeaveLobbyRequestedNotification = EOS_INVALID_NOTIFICATIONID;

	bool bLobbyLeaveInProgress = false;
	bool bDirty = true;
};

```

`EAC_SDK/Samples/Lobbies/Source/LobbiesDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "LobbiesDialog.h"
#include "DebugLog.h"
#include "Checkbox.h"
#include "Users.h"
#include "LobbyMemberTableRowView.h"
#include "DropDownList.h"

#include <algorithm>

#define LOBBY_DIALOG_SEARCH_TYPE_LEVEL L"By Level"
#define LOBBY_DIALOG_SEARCH_TYPE_BUCKET L"By Bucket Id"
#define LOBBY_DIALOG_UPPER_BUTTON_WIDTH 150.0f

static FLobbySearchResultTableRowData BuildTableRowDataFromLobby(const FLobby& Lobby, uint32_t SearchIndex)
{
	FLobbySearchResultTableRowData Result;

	Result.SearchResultIndex = SearchIndex;

	std::wstring OwnerName = L"?";
	if (!Lobby.LobbyOwnerDisplayName.empty())
	{
		OwnerName = Lobby.LobbyOwnerDisplayName;
	}
	Result.Values[FLobbySearchResultTableRowData::EValue::OwnerDisplayName] = OwnerName;

	wchar_t Buffer[32];
	wsprintf(Buffer, L"%d/%d", Lobby.MaxNumLobbyMembers - Lobby.AvailableSlots, Lobby.MaxNumLobbyMembers);

	Result.Values[FLobbySearchResultTableRowData::EValue::NumMembers] = std::wstring(Buffer);

	std::wstring LevelName = L"?";
	if (const FLobbyAttribute* LevelAttr = Lobby.GetAttribute("LEVEL"))
	{
		LevelName = FStringUtils::Widen(LevelAttr->AsString);
	}
	Result.Values[FLobbySearchResultTableRowData::EValue::LevelName] = LevelName;

	Result.bActionsAvailable[FLobbySearchResultTableRowData::EAction::Join] = true;

	return Result;
}

static FLobbyMemberTableRowData BuildMemberRow(const FLobbyMember& Member, const FLobby& CurrentLobby, bool bOwnerMode, bool bIsSelf)
{
	FLobbyMemberTableRowData Result;
	Result.ValueColors.fill(Color::White);

	std::wstring MemberName = Member.DisplayName.empty() ? L"?" : Member.DisplayName;
	Result.DisplayName = MemberName;

	Result.UserId = Member.ProductId;
	Result.Values[FLobbyMemberTableRowData::EValue::DisplayName] = MemberName;
	Result.ValueColors[FLobbyMemberTableRowData::EValue::DisplayName] = bIsSelf ? Color::Cyan : Color::White;
	Result.Values[FLobbyMemberTableRowData::EValue::IsOwner] = CurrentLobby.IsOwner(Result.UserId) ? L"Owner" : L"Member";
	Result.Values[FLobbyMemberTableRowData::EValue::Skin] = FStringUtils::Widen(FLobbyMember::GetSkinString(Member.CurrentSkin));
	Result.ValueColors[FLobbyMemberTableRowData::EValue::Skin] = FLobbyMember::GetSkinColor(Member.CurrentColor);

	// Count how many members we have currently connected to the RTC room
	size_t ConnectedMembers = 0;
	std::for_each(CurrentLobby.Members.begin(), CurrentLobby.Members.end(),
		[&](const FLobbyMember& LobbyMember)
		{
			if (LobbyMember.RTCState.bIsInRTCRoom)
			{
				++ConnectedMembers;
			}
		}
	);

	std::wstring TalkingStatus;
	FColor TextColor;
	if (!CurrentLobby.bRTCRoomConnected)
	{
		TalkingStatus = L"Unknown";
		TextColor = Color::DarkGray;
	}
	else if (!Member.RTCState.bIsInRTCRoom)
	{
		TalkingStatus = L"Disconnected";
		TextColor = Color::DarkGray;
	}
	else if (Member.RTCState.bIsHardMuted)
	{
		TalkingStatus = L"Hard-Muted";
		TextColor = Color::Red;
	}
	else if (Member.RTCState.bIsLocallyMuted)
	{
		TalkingStatus = L"Muted";
		TextColor = Color::Red;
	}
	else if (Member.RTCState.bIsAudioOutputDisabled)
	{
		TalkingStatus = L"Self-Muted";
		TextColor = Color::DarkRed;
	}
	else if (Member.RTCState.bIsTalking)
	{
		TalkingStatus = L"Talking";
		TextColor = Color::Yellow;
	}
	// if we're the only one in the lobby, we don't currently get talking notifications, so we show "Connected" instead of "Not Talking"
	// as to not mislead people into thinking their microphones aren't working.
	else if (ConnectedMembers < 2)
	{
		TalkingStatus = L"Connected";
		TextColor = Color::White;
	}
	else
	{
		TalkingStatus = L"Not Talking";
		TextColor = Color::White;
	}

	Result.Values[FLobbyMemberTableRowData::EValue::TalkingStatus] = std::move(TalkingStatus);
	Result.ValueColors[FLobbyMemberTableRowData::EValue::TalkingStatus] = TextColor;

	Result.bActionsAvailable[FLobbyMemberTableRowData::EAction::Kick] = std::make_pair(bOwnerMode && !bIsSelf, Color::DarkRed);
	Result.bActionsAvailable[FLobbyMemberTableRowData::EAction::Promote] =  std::make_pair(bOwnerMode && !bIsSelf, Color::DarkGreen);
	Result.bActionsAvailable[FLobbyMemberTableRowData::EAction::ShuffleSkin] =  std::make_pair(bIsSelf, Color::DarkBlue);
	Result.bActionsAvailable[FLobbyMemberTableRowData::EAction::ChangeColor] = std::make_pair(bIsSelf && CurrentLobby.bRTCRoomConnected, Color::ForestGreen);

	FColor MuteButtonColor;
	if (bIsSelf)
	{
		MuteButtonColor = Member.RTCState.bIsAudioOutputDisabled ? Color::Red : Color::ForestGreen;
	}
	else
	{
		MuteButtonColor = Member.RTCState.bIsLocallyMuted ? Color::Red : Color::ForestGreen;
	}

	FColor HardMuteButtonColor;
	HardMuteButtonColor = Member.RTCState.bIsHardMuted ? Color::Red : Color::ForestGreen;

	Result.bActionsAvailable[FLobbyMemberTableRowData::EAction::MuteAudio] = std::make_pair(CurrentLobby.bRTCRoomConnected && Member.RTCState.bIsInRTCRoom && !Member.RTCState.bMuteActionInProgress, MuteButtonColor);
	Result.bActionsAvailable[FLobbyMemberTableRowData::EAction::HardMuteAudio] = std::make_pair(bOwnerMode && !bIsSelf && CurrentLobby.bRTCRoomConnected && Member.RTCState.bIsInRTCRoom, HardMuteButtonColor); // only lobby owner can hard-mute someone

	return Result;
}

FLobbiesDialog::FLobbiesDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/friends.dds");

	TitleLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Vector2(DialogSize.x, 30.f),
		DialogLayer - 1,
		L"LOBBIES",
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	TitleLabel->SetBorderColor(Color::UIBorderGrey);
	TitleLabel->SetFont(DialogNormalFont);

	CreateLobbyButton = std::make_shared<FButtonWidget>(
		Vector2(DialogPos.x + 5.0f, DialogPos.y + TitleLabel->GetSize().y + 5.0f),
		Vector2(LOBBY_DIALOG_UPPER_BUTTON_WIDTH, 25.f),
		DialogLayer - 1,
		L"CREATE NEW LOBBY",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		Color::UIButtonBlue
	);
	//CreateLobbyButton->SetBorderColor(Color::UIBorderGrey);
	CreateLobbyButton->SetBackgroundColors(assets::DefaultButtonColors);
	CreateLobbyButton->SetOnPressedCallback([this]()
	{
		//Open New Lobby dialog
		FGameEvent Event(EGameEventType::NewLobby);
		FGame::Get().OnGameEvent(Event);
	}
	);

	LeaveLobbyButton = std::make_shared<FButtonWidget>(
		CreateLobbyButton->GetPosition(),
		CreateLobbyButton->GetSize(),
		DialogLayer - 1,
		L"LEAVE LOBBY",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		Color::UIButtonBlue
		);
	//LeaveLobbyButton->SetBorderColor(Color::UIBorderGrey);
	LeaveLobbyButton->SetBackgroundColors(assets::DefaultButtonColors);
	LeaveLobbyButton->SetOnPressedCallback([this]()
	{
		FGame::Get().GetLobbies()->LeaveLobby();
	}
	);
	LeaveLobbyButton->Hide();

	ModifyLobbyButton = std::make_shared<FButtonWidget>(
		CreateLobbyButton->GetPosition() + Vector2(CreateLobbyButton->GetSize().x, 0.0f),
		CreateLobbyButton->GetSize(),
		DialogLayer - 1,
		L"MODIFY LOBBY",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		Color::UIButtonBlue
		);
	//ModifyLobbyButton->SetBorderColor(Color::UIBorderGrey);
	ModifyLobbyButton->SetBackgroundColors(assets::DefaultButtonColors);
	ModifyLobbyButton->SetOnPressedCallback([this]()
	{
		//Open Modify Lobby dialog
		FGameEvent Event(EGameEventType::ModifyLobby);
		FGame::Get().OnGameEvent(Event);
	}
	);
	ModifyLobbyButton->Hide();

	SearchField = std::make_shared<FTextFieldWidget>(
		CreateLobbyButton->GetPosition() + Vector2(DialogSize.x - 200.0f, 0.0f),
		Vector2(175.0f, 25.0f),
		DialogLayer - 1,
		L"Search...",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
	);
	SearchField->SetOnEnterPressedCallback([this](const std::wstring& SearchString)
	{
		SearchLobby(SearchString);
	});

	SearchTypeDropDown = std::make_shared<FDropDownList>(
		SearchField->GetPosition() - Vector2(175.0f, 0.0f),
		Vector2(175.0f, 25.0f),
		Vector2(175.0f, 25.0f) + Vector2(0.0f, 50.0f),
		DialogLayer - 2,
		L"Search: ",
		std::vector<std::wstring>({ LOBBY_DIALOG_SEARCH_TYPE_LEVEL, LOBBY_DIALOG_SEARCH_TYPE_BUCKET }),
		DialogNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	SearchTypeDropDown->SetBorderColor(Color::UIBorderGrey);

	SearchButton = std::make_shared<FButtonWidget>(
		SearchField->GetPosition() + Vector2(SearchField->GetSize().x, 0.0f),
		Vector2(20.0f, 20.f),
		DialogLayer - 1,
		L"",
		std::vector<std::wstring>({ L"Assets/search.dds" }),
		DialogSmallFont,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
	);
	SearchButton->SetOnPressedCallback([this]()
	{
		SearchLobby(SearchField->GetText());
	}
	);

	CancelSearchButton = std::make_shared<FButtonWidget>(
		SearchButton->GetPosition(),
		SearchButton->GetSize(),
		DialogLayer - 1,
		L"",
		std::vector<std::wstring>({ L"Assets/nobutton.dds" }),
		DialogSmallFont,
		FColor(1.f, 1.f, 1.f, 1.f)
		);
	CancelSearchButton->SetOnPressedCallback([this]()
	{
		StopSearch();
	}
	);
	CancelSearchButton->Hide();

	Vector2 MainPartPosition = CreateLobbyButton->GetPosition() + Vector2(0.0f, CreateLobbyButton->GetSize().y + 5.0f);

	OwnerLabel = std::make_shared<FTextLabelWidget>(
		MainPartPosition,
		Vector2(200.0f, 30.f),
		DialogLayer - 1,
		L"Owner: ?",
		L"Assets/textfield.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	OwnerLabel->SetFont(DialogNormalFont);

	IsPublicLabel = std::make_shared<FTextLabelWidget>(
		MainPartPosition + Vector2(200.0f, 0.0f),
		Vector2(200.0f, 30.f),
		DialogLayer - 1,
		L"Public: ?",
		L"Assets/textfield.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	IsPublicLabel->SetFont(DialogNormalFont);

	LevelNameLabel = std::make_shared<FTextLabelWidget>(
		MainPartPosition + Vector2(400.0f, 0.0f),
		Vector2(200.0f, 30.f),
		DialogLayer - 1,
		L"Level: ?",
		L"Assets/textfield.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	LevelNameLabel->SetFont(DialogNormalFont);

	FLobbyMemberTableRowData Labels;
	Labels.ValueColors.fill(Color::White);
	Labels.Values[FLobbyMemberTableRowData::EValue::DisplayName] = L"Name";
	Labels.Values[FLobbyMemberTableRowData::EValue::IsOwner] = L"Role";
	Labels.Values[FLobbyMemberTableRowData::EValue::Skin] = L"Skin";

	LobbyMembersList = std::make_shared<FLobbyMembersListWidget>(
		MainPartPosition + Vector2(0.0f, 30.0f),
		Vector2(GetSize().x - 10.0f, GetSize().y - (MainPartPosition.y - GetPosition().y) - 35.0f),
		DialogLayer,
		L"Members:", //Title text
		10.0f, //scroller width
		std::vector<FLobbyMemberTableRowData>(),
		Labels
	);
	LobbyMembersList->SetFonts(DialogTinyFont, DialogNormalFont);

	FLobbySearchResultTableRowData SearchLabels;
	SearchLabels.Values[FLobbySearchResultTableRowData::EValue::LevelName] = L"Level";
	SearchLabels.Values[FLobbySearchResultTableRowData::EValue::OwnerDisplayName] = L"Owner";
	SearchLabels.Values[FLobbySearchResultTableRowData::EValue::NumMembers] = L"Members";
	ResultLobbiesTable = std::make_shared<FSearchResultsLobbyTableWidget>(
		MainPartPosition,
		Vector2(GetSize().x - 10.0f, GetSize().y - (MainPartPosition.y - GetPosition().y) - 5.0f),
		DialogLayer,
		L"Search results:", //Title text
		10.0f, //scroller width
		std::vector<FLobbySearchResultTableRowData>(),
		SearchLabels
		);
	ResultLobbiesTable->SetFonts(DialogSmallFont, DialogNormalFont);
	ResultLobbiesTable->Hide();
}

void FLobbiesDialog::Update()
{
	if (!IsShown())
	{
		return;
	}

	const FLobbySearch& CurrentSearch = FGame::Get().GetLobbies()->GetCurrentSearch();
	if (CurrentSearch.IsValid())
	{
		OwnerLabel->Hide();
		IsPublicLabel->Hide();
		LevelNameLabel->Hide();
		LobbyMembersList->Hide();

		ResultLobbiesTable->Show();

		const FLobbySearch& CurrentSearch = FGame::Get().GetLobbies()->GetCurrentSearch();

		//copy data to vector
		const std::vector<FLobby>& LobbiesVector = CurrentSearch.GetResults();

		std::vector<FLobbySearchResultTableRowData> Rows;
		Rows.reserve(LobbiesVector.size());
		for (uint32_t SearchIndex = 0; SearchIndex < LobbiesVector.size(); ++SearchIndex)
		{
			Rows.push_back(BuildTableRowDataFromLobby(LobbiesVector[SearchIndex], SearchIndex));
		}

		ResultLobbiesTable->RefreshData(std::move(Rows));
	}
	else
	{
		OwnerLabel->Show();
		IsPublicLabel->Show();
		LevelNameLabel->Show();
		LobbyMembersList->Show();

		ResultLobbiesTable->Hide();

		const FLobby& CurrentLobby = FGame::Get().GetLobbies()->GetCurrentLobby();

		if (CurrentLobby.IsValid())
		{
			CreateLobbyButton->Hide();
			LeaveLobbyButton->Show();

			std::wstring OwnerName = L"?";
			if (!CurrentLobby.LobbyOwnerDisplayName.empty())
			{
				OwnerName = CurrentLobby.LobbyOwnerDisplayName;
			}

			OwnerLabel->SetText(L"Owner: " + OwnerName);
			IsPublicLabel->SetText(std::wstring(L"Public: ") + ((CurrentLobby.Permission == EOS_ELobbyPermissionLevel::EOS_LPL_PUBLICADVERTISED) ? L"true" : L"false"));

			std::wstring LevelName = L"?";
			if (const FLobbyAttribute* LevelAttributePtr = CurrentLobby.GetAttribute("LEVEL"))
			{
				LevelName = FStringUtils::Widen(LevelAttributePtr->AsString.c_str());
			}
			LevelNameLabel->SetText(L"Level: " + LevelName);


			FProductUserId CurrentUser;
			if (PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()))
			{
				CurrentUser = Player->GetProductUserID();
			}

			const bool bCurrentUserIsLobbyOwner = CurrentLobby.IsOwner(CurrentUser);

			if (bCurrentUserIsLobbyOwner)
			{
				ModifyLobbyButton->Show();
			}
			else
			{
				ModifyLobbyButton->Hide();
			}

			//copy data to vector
			std::vector<FLobbyMemberTableRowData> MemberRows;
			MemberRows.reserve(CurrentLobby.Members.size());
			for (const FLobbyMember& Member : CurrentLobby.Members)
			{
				MemberRows.push_back(BuildMemberRow(Member, CurrentLobby, bCurrentUserIsLobbyOwner, Member.ProductId == CurrentUser));
			}

			LobbyMembersList->RefreshData(std::move(MemberRows));
		}
		else
		{
			LeaveLobbyButton->Hide();
			ModifyLobbyButton->Hide();
			CreateLobbyButton->Show();

			OwnerLabel->SetText(L"Owner: ?");
			IsPublicLabel->SetText(std::wstring(L"Public: ?"));
			LevelNameLabel->SetText(L"Level: ?");

			std::vector<FLobbyMemberTableRowData> MemberRows;
			LobbyMembersList->RefreshData(std::move(MemberRows));
		}
	}

	FDialog::Update();
}

void FLobbiesDialog::Create()
{
	if (BackgroundImage) BackgroundImage->Create();
	if (TitleLabel) TitleLabel->Create();
	if (CreateLobbyButton) CreateLobbyButton->Create();
	if (LeaveLobbyButton) LeaveLobbyButton->Create();
	if (ModifyLobbyButton) ModifyLobbyButton->Create();
	if (SearchField) SearchField->Create();
	if (SearchButton) SearchButton->Create();
	if (OwnerLabel) OwnerLabel->Create();
	if (IsPublicLabel) IsPublicLabel->Create();
	if (LevelNameLabel) LevelNameLabel->Create();
	if (LobbyMembersList) LobbyMembersList->Create();
	if (CancelSearchButton) CancelSearchButton->Create();
	if (ResultLobbiesTable) ResultLobbiesTable->Create();
	if (SearchTypeDropDown)
	{
		SearchTypeDropDown->Create();
		SearchTypeDropDown->SelectEntry(0);
	}

	AddWidget(BackgroundImage);
	AddWidget(TitleLabel);
	AddWidget(CreateLobbyButton);
	AddWidget(LeaveLobbyButton);
	AddWidget(ModifyLobbyButton);
	AddWidget(SearchField);

	AddWidget(SearchButton);
	AddWidget(OwnerLabel);
	AddWidget(IsPublicLabel);
	AddWidget(LevelNameLabel);
	AddWidget(LobbyMembersList);

	AddWidget(CancelSearchButton);
	AddWidget(ResultLobbiesTable);

	AddWidget(SearchTypeDropDown);

	Disable();
}

void FLobbiesDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (BackgroundImage) BackgroundImage->SetPosition(Pos);
	if (TitleLabel) TitleLabel->SetPosition(Pos);
	if (CreateLobbyButton) CreateLobbyButton->SetPosition(Pos + Vector2(5.0f, TitleLabel->GetSize().y + 5.0f));
	if (LeaveLobbyButton) LeaveLobbyButton->SetPosition(CreateLobbyButton->GetPosition());
	if (ModifyLobbyButton) ModifyLobbyButton->SetPosition(CreateLobbyButton->GetPosition() + Vector2(CreateLobbyButton->GetSize().x, 0.0f));
	if (SearchField) SearchField->SetPosition(CreateLobbyButton->GetPosition() + Vector2(GetSize().x - 200.0f, 0.0f));
	if (SearchTypeDropDown) SearchTypeDropDown->SetPosition(SearchField->GetPosition() - Vector2(175.0f, 0.0f));
	if (SearchButton) SearchButton->SetPosition(SearchField->GetPosition() + Vector2(SearchField->GetSize().x, 0.0f));
	if (CancelSearchButton) CancelSearchButton->SetPosition(SearchButton->GetPosition());

	const Vector2 MainPartPosition = CreateLobbyButton->GetPosition() + Vector2(0.0f, CreateLobbyButton->GetSize().y + 5.0f);

	if (OwnerLabel) OwnerLabel->SetPosition(MainPartPosition);
	if (IsPublicLabel) IsPublicLabel->SetPosition(MainPartPosition + Vector2(200.0f, 0.0f));
	if (LevelNameLabel) LevelNameLabel->SetPosition(MainPartPosition + Vector2(400.0f, 0.0f));
	if (LobbyMembersList) LobbyMembersList->SetPosition(MainPartPosition + Vector2(0.0f, 30.0f));

	if (ResultLobbiesTable) ResultLobbiesTable->SetPosition(MainPartPosition);
}

void FLobbiesDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);
	if (BackgroundImage) BackgroundImage->SetSize(Vector2(NewSize.x, NewSize.y - 10.f));
	if (TitleLabel) TitleLabel->SetSize(Vector2(NewSize.x, 30.0f));
	if (CreateLobbyButton) CreateLobbyButton->SetSize(Vector2(LOBBY_DIALOG_UPPER_BUTTON_WIDTH, 25.f));
	if (LeaveLobbyButton) LeaveLobbyButton->SetSize(CreateLobbyButton->GetSize());
	if (ModifyLobbyButton) ModifyLobbyButton->SetSize(CreateLobbyButton->GetSize());
	if (SearchField) SearchField->SetSize(Vector2(175.0f, 25.0f));
	if (SearchTypeDropDown) SearchTypeDropDown->SetSize(Vector2(175.0f, 25.0f));
	if (SearchButton) SearchButton->SetSize(Vector2(20.0f, 20.0f));
	if (CancelSearchButton) CancelSearchButton->SetSize(SearchButton->GetSize());

	const Vector2 MainPartPosition = CreateLobbyButton->GetPosition() + Vector2(0.0f, CreateLobbyButton->GetSize().y + 5.0f);

	if (OwnerLabel) OwnerLabel->SetSize(Vector2(200.0f, 30.f));
	if (IsPublicLabel) IsPublicLabel->SetSize(Vector2(200.0f, 30.f));
	if (LevelNameLabel) LevelNameLabel->SetSize(Vector2(200.0f, 30.f));
	if (LobbyMembersList) LobbyMembersList->SetSize(Vector2(GetSize().x - 10.0f, GetSize().y - (MainPartPosition.y - GetPosition().y) - 35.0f));

	if (ResultLobbiesTable) ResultLobbiesTable->SetSize(Vector2(GetSize().x - 10.0f, GetSize().y - (MainPartPosition.y - GetPosition().y) - 5.0f));
}


void FLobbiesDialog::Clear()
{
	if (LobbyMembersList) LobbyMembersList->Clear();
	if (ResultLobbiesTable) ResultLobbiesTable->Clear();
}

void FLobbiesDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{

	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		Disable();
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		Disable();
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		if (FPlayerManager::Get().GetNumPlayers() == 0)
		{
			Disable();
			Clear();
		}
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		Clear();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		Clear();
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		Disable();
		Clear();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		Disable();
		Clear();
	}
	else if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		Enable();
	}
	else if (Event.GetType() == EGameEventType::InviteFriendToLobby)
	{
		//get current session and invite friend
		FProductUserId FriendProductUserId = Event.GetProductUserId();
		FGame::Get().GetLobbies()->SendInvite(FriendProductUserId);
	}
	else if (Event.GetType() == EGameEventType::LobbyJoined)
	{
		//Clear search
		StopSearch();
	}
}

void FLobbiesDialog::SearchLobbyByLevel(const std::wstring& LevelName)
{
	std::string SearchLevelName =  FStringUtils::Narrow(FStringUtils::ToUpper(LevelName));

	FGame::Get().GetLobbies()->SearchLobbyByLevel(SearchLevelName);
	
	//change icon
	SearchButton->Hide();
	CancelSearchButton->Show();
}

void FLobbiesDialog::SearchLobbyByBucketId(const std::wstring& BucketId)
{
	std::string SearchBucketId = FStringUtils::Narrow(BucketId);

	FGame::Get().GetLobbies()->SearchLobbyByBucketId(SearchBucketId);

	//change icon
	SearchButton->Hide();
	CancelSearchButton->Show();
}


void FLobbiesDialog::SearchLobby(const std::wstring& SearchString)
{
	if (SearchTypeDropDown)
	{
		if (SearchTypeDropDown->GetCurrentSelection() == LOBBY_DIALOG_SEARCH_TYPE_LEVEL)
		{
			SearchLobbyByLevel(SearchString);
		}
		else if (SearchTypeDropDown->GetCurrentSelection() == LOBBY_DIALOG_SEARCH_TYPE_BUCKET)
		{
			SearchLobbyByBucketId(SearchString);
		}
	}
}

void FLobbiesDialog::StopSearch()
{
	//change icon
	SearchButton->Show();
	CancelSearchButton->Hide();
	SearchField->Clear();

	FGame::Get().GetLobbies()->ClearSearch();
}
```

`EAC_SDK/Samples/Lobbies/Source/LobbiesDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "ListView.h"
#include "TableView.h"
#include "Lobbies.h"

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;
class FDropDownList;

/**
 * Lobbies dialog
 */
class FLobbiesDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FLobbiesDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FLobbiesDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	
	virtual void Clear();

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/* Search for lobbies by level name */
	void SearchLobbyByLevel(const std::wstring& LevelName);

	/* Search for lobbies by bucket id */
	void SearchLobbyByBucketId(const std::wstring& BucketId);

	/* Search for lobby depending on UI widget state. */
	void SearchLobby(const std::wstring& SearchString);

	/* Cancel search */
	void StopSearch();

private:
	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Title label */
	std::shared_ptr<FTextLabelWidget> TitleLabel;

	/** Create lobby button */
	std::shared_ptr<FButtonWidget> CreateLobbyButton;

	/** Leave lobby button */
	std::shared_ptr<FButtonWidget> LeaveLobbyButton;

	/** Modify lobby button */
	std::shared_ptr<FButtonWidget> ModifyLobbyButton;

	/** Search type drop-down list */
	std::shared_ptr<FDropDownList> SearchTypeDropDown;

	/** Search by level name input */
	std::shared_ptr<FTextFieldWidget> SearchField;

	/** Small search button within the search input field */
	std::shared_ptr<FButtonWidget> SearchButton;

	/** Small cancel search button within the search input field */
	std::shared_ptr<FButtonWidget> CancelSearchButton;

	//Current lobby info
	/** Name of lobby's owner  */
	std::shared_ptr<FTextLabelWidget> OwnerLabel;
	/** Is public label */
	std::shared_ptr<FTextLabelWidget> IsPublicLabel;
	/** Current level label */
	std::shared_ptr<FTextLabelWidget> LevelNameLabel;
	/** List of members */
	using FLobbyMembersListWidget = FLobbyMemberTableView;
	std::shared_ptr<FLobbyMembersListWidget> LobbyMembersList;

	//Search results
	using FSearchResultsLobbyTableWidget = FLobbySearchResultTableView;
	std::shared_ptr<FSearchResultsLobbyTableWidget> ResultLobbiesTable;
};

```

`EAC_SDK/Samples/Lobbies/Source/LobbyInviteReceivedDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "Sprite.h"
#include "TextLabel.h"
#include "Checkbox.h"
#include "Button.h"
#include "ProgressBar.h"
#include "LobbyInviteReceivedDialog.h"
#include "StringUtils.h"

FLobbyInviteReceivedDialog::FLobbyInviteReceivedDialog(Vector2 InPos,
						 Vector2 InSize,
						 UILayer InLayer,
						 FontPtr InNormalFont,
						 FontPtr InSmallFont) :
	FDialog(InPos, InSize, InLayer)
{
	Background = std::make_shared<FSpriteWidget>(
		Position,
		InSize,
		InLayer,
		L"Assets/textfield.dds",
		Color::Black);
	AddWidget(Background);

	Label = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x + 30.0f, Position.y + 25.0f),
		Vector2(150.f, 30.f),
		InLayer - 1,
		L"Lobby invite received from: ",
		L"");
	Label->SetFont(InNormalFont);
	AddWidget(Label);

	LevelLabel = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x + 30.0f, Position.y + 45.0f),
		Vector2(150.f, 30.f),
		InLayer - 1,
		L"Level: ",
		L"");
	LevelLabel->SetFont(InNormalFont);
	AddWidget(LevelLabel);

	const float CenterX = Position.x + InSize.x / 2.f;
	PresenceCheckbox = std::make_shared<FCheckboxWidget>(
		Vector2(CenterX - 75.f, LevelLabel->GetPosition().y + LevelLabel->GetSize().y + 5.f),
		Vector2(150.0f, 30.0f),
		InLayer - 1,
		L"Presence",
		L"",
		InNormalFont
		);
	AddWidget(PresenceCheckbox);

	AcceptInviteButton = std::make_shared<FButtonWidget>(
		Vector2(CenterX - 105.0f, PresenceCheckbox->GetPosition().y + PresenceCheckbox->GetSize().y + 10.f),
		Vector2(100.f, 30.f),
		InLayer - 1,
		L"Accept",
		assets::DefaultButtonAssets,
		InSmallFont,
		Color::UIButtonBlue);
	AcceptInviteButton->SetOnPressedCallback([this]()
	{
		Hide();
		const FLobby& Lobby = GetLobby();
		if (Lobby.IsValid())
		{
			FGame::Get().GetLobbies()->JoinLobby(Lobby.Id.c_str(), LobbyDetails, PresenceCheckbox->IsTicked());
		}
	});
	AcceptInviteButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(AcceptInviteButton);

	DeclineInviteButton = std::make_shared<FButtonWidget>(
		AcceptInviteButton->GetPosition() + Vector2(AcceptInviteButton->GetSize().x + 10.f, 0.f),
		Vector2(100.f, 30.f),
		InLayer - 1,
		L"Decline",
		assets::DefaultButtonAssets,
		InSmallFont,
		Color::UIButtonBlue);
	DeclineInviteButton->SetOnPressedCallback([this]()
	{
		RejectInvite();
		Hide();
	});
	DeclineInviteButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(DeclineInviteButton);
}

void FLobbyInviteReceivedDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	Background->SetPosition(Position);
	Label->SetPosition(Vector2(Position.x + 30.0f, Position.y + 25.0f));
	LevelLabel->SetPosition(Vector2(Position.x + 30.0f, Position.y + 45.0f));
	PresenceCheckbox->SetPosition(Label->GetPosition() + Vector2(Label->GetSize().x / 2.0f + 5.0f, LevelLabel->GetSize().y + 10.0f));

	const float CenterX = Position.x + GetSize().x / 2.f;
	PresenceCheckbox->SetPosition(Vector2(CenterX - PresenceCheckbox->GetSize().x / 2.f, LevelLabel->GetPosition().y + LevelLabel->GetSize().y + 5.0f));
	const float AcceptSizeX = AcceptInviteButton->GetSize().x;
	AcceptInviteButton->SetPosition(Vector2(CenterX - AcceptSizeX - 5.0f, PresenceCheckbox->GetPosition().y + PresenceCheckbox->GetSize().y + 10.f));
	DeclineInviteButton->SetPosition(AcceptInviteButton->GetPosition() + Vector2(AcceptSizeX + 10.f, 0.f));
}

void FLobbyInviteReceivedDialog::Update()
{
	if (FriendName.empty())
	{
		FriendName = FGame::Get().GetLobbies()->GetInviteSenderName();

		if (!FriendName.empty())
		{
			if (Label)
			{
				Label->ClearText();
				Label->SetText(std::wstring(L"Lobby invite received from: ") + ((FriendName.empty()) ? L"?" : FriendName));
			}
		}
	}

	FDialog::Update();
}

void FLobbyInviteReceivedDialog::SetLobbyInvite(const FLobbyInvite* InCurrentInvite)
{
	FriendName = InCurrentInvite->FriendDisplayName;
	Lobby = InCurrentInvite->Lobby;
	LobbyDetails = InCurrentInvite->LobbyInfo;
	LobbyInviteId = InCurrentInvite->InviteId;

	std::wstring LevelName = L"?";
	for (FLobbyAttribute& Attr : Lobby.Attributes)
	{
		if (Attr.Key == "LEVEL")
		{
			LevelName = FStringUtils::Widen(Lobby.Attributes[0].AsString);
		}
	}

	if (Label)
	{
		Label->ClearText();
		Label->SetText(std::wstring(L"Lobby invite received from: ") + FriendName);
	}

	if (LevelLabel)
	{
		LevelLabel->ClearText();
		LevelLabel->SetText(std::wstring(L"Level: ") + LevelName);
	}
}

void FLobbyInviteReceivedDialog::RejectInvite()
{
	const FLobby& Lobby = GetLobby();
	if (Lobby.IsValid())
	{
		FGame::Get().GetLobbies()->RejectLobbyInvite(GetLobbyInviteId());
	}
}

void FLobbyInviteReceivedDialog::OnEscapePressed()
{
	RejectInvite();
	Hide();
}


```

`EAC_SDK/Samples/Lobbies/Source/LobbyInviteReceivedDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "Lobbies.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FCheckboxWidget;
class FButtonWidget;

/**
 * Lobby Invite Received dialog (simple popup to accept or decline the invitation)
 */
class FLobbyInviteReceivedDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FLobbyInviteReceivedDialog(Vector2 InPos,
		Vector2 InSize,
		UILayer InLayer,
		FontPtr InNormalFont,
		FontPtr InSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FLobbyInviteReceivedDialog() {}

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void Update() override;
	virtual void OnEscapePressed() override;

	const FLobby& GetLobby() const { return Lobby; }
	LobbyDetailsKeeper GetLobbyInfo() const { return LobbyDetails; }
	const std::string& GetLobbyInviteId() const { return LobbyInviteId; }

	void SetLobbyInvite(const FLobbyInvite* InCurrentInvite);

private:
	void RejectInvite();

	/** The name of friend who invited to lobby. */
	std::wstring FriendName;

	/** InviteId for the lobby invite to accept/reject */
	std::string LobbyInviteId;

	/** Lobby to join. Or not. */
	FLobby Lobby;

	/** Lobby details */
	LobbyDetailsKeeper LobbyDetails;

	/** Background */
	WidgetPtr Background;

	/** Main Label */
	std::shared_ptr<FTextLabelWidget> Label;

	/** Level Label */
	std::shared_ptr<FTextLabelWidget> LevelLabel;

	/** Is lobby for presence? */
	std::shared_ptr<FCheckboxWidget> PresenceCheckbox;

	/** Accept invite button */
	std::shared_ptr<FButtonWidget> AcceptInviteButton;

	/** Decline invite button */
	std::shared_ptr<FButtonWidget> DeclineInviteButton;
};

```

`EAC_SDK/Samples/Lobbies/Source/LobbyMemberTableRowView.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "LobbyMemberTableRowView.h"
#include "TextLabel.h"
#include "Button.h"

#include "Lobbies.h"
#include "Game.h"


FLobbyMemberTableRowView::FLobbyMemberTableRowView(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& InAssetFile, const FLobbyMemberTableRowData& InData, FColor InBackgroundColor, FColor InTextColor)
	: FDialog(Pos, Size, Layer), Data(InData), AssetFile(InAssetFile), BackgroundColor(InBackgroundColor), TextColor(InTextColor)
{
	static_assert(std::tuple_size<FLobbyMemberTableRowView::FRowWidgets>::value == std::tuple_size<FLobbyMemberTableRowData::FValues>::value, "FRowWidgets must be the same size as the number of values.");
	static_assert(std::tuple_size<FLobbyMemberTableRowView::FActionButtons>::value == std::tuple_size<FLobbyMemberTableRowData::FActionsAvailable>::value, "FActionButtons must be the same size as the number of actions.");

	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//create labels
	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		std::shared_ptr<FTextLabelWidget> NextLabel = std::make_shared<FTextLabelWidget>(
			Vector2(Pos.x + LabelSize.x * i, Pos.y),
			LabelSize,
			Layer - 1,
			Data.Values[i],
			AssetFile,
			BackgroundColor,
			Data.ValueColors[i]);

		RowWidgets[i] = NextLabel;
		AddWidget(NextLabel);
	}

	//create action buttons
	std::array<std::wstring, FLobbyMemberTableRowData::EAction::Count> actionLabels;
	std::array<FColor, FLobbyMemberTableRowData::EAction::Count> actionColors;

	actionLabels[FLobbyMemberTableRowData::EAction::Kick] = L"KICK";
	actionColors[FLobbyMemberTableRowData::EAction::Kick] = Color::DarkRed;
	actionLabels[FLobbyMemberTableRowData::EAction::Promote] = L"PROMOTE";
	actionColors[FLobbyMemberTableRowData::EAction::Promote] = Color::DarkGreen;
	actionLabels[FLobbyMemberTableRowData::EAction::ShuffleSkin] = L"DRAW SKIN";
	actionColors[FLobbyMemberTableRowData::EAction::ShuffleSkin] = Color::DarkBlue;
	actionLabels[FLobbyMemberTableRowData::EAction::MuteAudio] = L"MUTE";
	actionColors[FLobbyMemberTableRowData::EAction::MuteAudio] = Color::ForestGreen;
	actionLabels[FLobbyMemberTableRowData::EAction::HardMuteAudio] = L"HARD MUTE";
	actionColors[FLobbyMemberTableRowData::EAction::HardMuteAudio] = Color::ForestGreen;
	actionLabels[FLobbyMemberTableRowData::EAction::ChangeColor] = L"COLOR";
	actionColors[FLobbyMemberTableRowData::EAction::ChangeColor] = Color::ForestGreen;

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		std::shared_ptr<FButtonWidget> NextButton = std::make_shared<FButtonWidget>(
			Vector2(Pos.x + Data.Values.size() * LabelSize.x + Ix * ActionSize.x, Pos.y),
			ActionSize,
			Layer - 1,
			actionLabels[Ix],
			assets::DefaultButtonAssets,
			nullptr,
			actionColors[Ix]);
		NextButton->SetOnPressedCallback([this, Ix]() { this->OnPressed(Ix); });
		if (!Data.bActionsAvailable[Ix].first)
		{
			NextButton->Disable();
			NextButton->Hide();
		}
		else
		{
			NextButton->Enable();
			NextButton->SetBackgroundColor(Data.bActionsAvailable[Ix].second);
			NextButton->Show();
		}

		ActionButtons[Ix] = NextButton;
		AddWidget(NextButton);
	}
}

void FLobbyMemberTableRowView::SetFocused(bool bValue)
{
	FDialog::SetFocused(bValue);

	if (bValue)
	{
		SetBorderColor(Color::UIDarkGrey);
	}
	else
	{
		ClearBorderColor();
	}
}

void FLobbyMemberTableRowView::SetPosition(Vector2 Pos)
{
	FDialog::SetPosition(Pos);

	ReadjustLayout();
}

void FLobbyMemberTableRowView::SetSize(Vector2 NewSize)
{
	FDialog::SetSize(NewSize);

	ReadjustLayout();
}

void FLobbyMemberTableRowView::Enable()
{
	FDialog::Enable();

	//Disable action buttons
	for (size_t Ix = 0; Ix < FLobbyMemberTableRowData::EAction::Count; ++Ix)
	{
		if (ActionButtons.size() > Ix)
		{
			if (std::shared_ptr<FButtonWidget>& ActionButton = ActionButtons[Ix])
			{
				if (Data.bActionsAvailable[Ix].first)
				{
					ActionButton->Enable();
					ActionButton->SetBackgroundColor(Data.bActionsAvailable[Ix].second);
					ActionButton->Show();
				}
				else
				{
					ActionButton->Disable();
					ActionButton->Hide();
				}
			}
		}
	}
}

void FLobbyMemberTableRowView::SetOnActionPressedCallback(std::function<void(size_t)> Callback)
{
	ActionPressedCallback = Callback;
}

void FLobbyMemberTableRowView::HideActions()
{
	for (std::shared_ptr<FButtonWidget>& ActionButton : ActionButtons)
	{
		if (ActionButton)
		{
			ActionButton->Disable();
			ActionButton->Hide();
		}
	}
}

void FLobbyMemberTableRowView::SetData(const FLobbyMemberTableRowData& InData)
{
	Data = InData;

	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		RowWidgets[i]->SetText(i < InData.Values.size() ? InData.Values[i] : L"-");
		if (i < InData.ValueColors.size())
		{
			RowWidgets[i]->SetTextColor(InData.ValueColors[i]);
		}
	}

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		if (ActionButtons[Ix])
		{
			if (Data.bActionsAvailable[Ix].first)
			{
				ActionButtons[Ix]->Enable();
				ActionButtons[Ix]->SetBackgroundColor(Data.bActionsAvailable[Ix].second);
				ActionButtons[Ix]->Show();
			}
			else
			{
				ActionButtons[Ix]->Disable();
				ActionButtons[Ix]->Hide();
			}
		}
	}

	ReadjustLayout();
}

void FLobbyMemberTableRowView::SetFont(FontPtr InFont)
{
	Font = InFont;

	for (auto Widget : RowWidgets)
	{
		Widget->SetFont(InFont);
	}

	for (auto Button : ActionButtons)
	{
		Button->SetFont(InFont);
	}
}

void FLobbyMemberTableRowView::CalcSizes(Vector2& LabelSize, Vector2& ActionSize)
{
	// Fit the action buttons into "5" columns.
	float ActionSizeRatio = 5.0f / FLobbyMemberTableRowData::EAction::Count;
	float ColumnRatio = Data.Values.size() + ActionSizeRatio * FLobbyMemberTableRowData::EAction::Count;
	LabelSize = Vector2(Size.x / ColumnRatio, Size.y);
	ActionSize = Vector2(LabelSize.x * ActionSizeRatio, Size.y);
}

void FLobbyMemberTableRowView::ReadjustLayout()
{
	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//resize labels
	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		RowWidgets[i]->SetPosition(Vector2(Position.x + LabelSize.x * i, Position.y));
		RowWidgets[i]->SetSize(LabelSize);
	}

	for (size_t i = 0; i < ActionButtons.size(); ++i)
	{
		ActionButtons[i]->SetPosition(Vector2(Position.x + Data.Values.size() * LabelSize.x + i * ActionSize.x, Position.y));
		ActionButtons[i]->SetSize(ActionSize);
	}
}

void FLobbyMemberTableRowView::OnPressed(size_t ActionIndex)
{
	if (ActionPressedCallback)
	{
		ActionPressedCallback(ActionIndex);
	}

	FProductUserId UserId  = Data.UserId;

	if (ActionIndex == FLobbyMemberTableRowData::EAction::Kick)
	{
		// Kick member
		FGame::Get().GetLobbies()->KickMember(UserId);
	}
	else if (ActionIndex == FLobbyMemberTableRowData::EAction::Promote)
	{
		// End lobby
		FGame::Get().GetLobbies()->PromoteMember(UserId);
	}
	else if (ActionIndex == FLobbyMemberTableRowData::EAction::ShuffleSkin)
	{
		// Leave and destroy lobby
		FGame::Get().GetLobbies()->ShuffleSkin();
	}
	else if (ActionIndex == FLobbyMemberTableRowData::EAction::MuteAudio)
	{
		// Locally mute the selected player, or disable our audio output if the player is ourselves
		FGame::Get().GetLobbies()->MuteAudio(UserId);
	}
	else if (ActionIndex == FLobbyMemberTableRowData::EAction::HardMuteAudio)
	{
		// Toggle hard mute for selected player, noone in the lobby will hear that player's audio
		FGame::Get().GetLobbies()->ToggleHardMuteMember(UserId);
	}
	else if (ActionIndex == FLobbyMemberTableRowData::EAction::ChangeColor)
	{
		// Toggle color the player
		FGame::Get().GetLobbies()->ShuffleColor();
	}
}

template<>
std::shared_ptr<FLobbyMemberTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FLobbyMemberTableRowData& Data)
{
	return std::make_shared<FLobbyMemberTableRowView>(Pos, Size, Layer, L"", Data, Color::DarkGray, Color::White);
}

```

`EAC_SDK/Samples/Lobbies/Source/LobbyMemberTableRowView.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Widget.h"
#include "Font.h"
#include "ListView.h"
#include "Dialog.h"

#include <array>

class FTextLabelWidget;
class FButtonWidget;

struct FLobbyMemberTableRowData
{
	struct EValue final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			DisplayName = 0,
			IsOwner,
			Skin,
			TalkingStatus,
			Count
		};
		EValue() = delete;
	};
	struct EAction final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			Kick = 0,
			Promote,
			ShuffleSkin,
			MuteAudio,
			HardMuteAudio,
			ChangeColor,
			Count
		};
		EAction() = delete;
	};

	std::wstring DisplayName;
	FProductUserId UserId;

	using FValues = std::array<std::wstring, EValue::Count>;
	using FValueColors = std::array<FColor, EValue::Count>;
	using FActionsAvailable = std::array<std::pair<bool, FColor>, EAction::Count>;
	FValues Values;
	FValueColors ValueColors;
	FActionsAvailable bActionsAvailable;

	bool operator!=(const FLobbyMemberTableRowData& Other) const
	{
		return bActionsAvailable != Other.bActionsAvailable || Values != Other.Values;
	}

	FLobbyMemberTableRowData()
	{
		bActionsAvailable.fill(std::make_pair(false, Color::White));
		Values[EValue::DisplayName] = L"Name";
		Values[EValue::IsOwner] = L"Is Owner?";
		Values[EValue::Skin] = L"Skin";
		Values[EValue::TalkingStatus]= L"Talking?";
	}
};

class FLobbyMemberTableRowView : public FDialog
{
public:
	FLobbyMemberTableRowView(Vector2 Pos,
		Vector2 Size,
		UILayer Layer,
		const std::wstring& AssetFile,
		const FLobbyMemberTableRowData& InData,
		FColor BackgroundColor,
		FColor TextColor);

	void SetFocused(bool bValue) override;

	/** Set Position */
	void SetPosition(Vector2 Pos) override;

	/** Set Size */
	void SetSize(Vector2 NewSize) override;

	void Enable() override;

	void SetOnActionPressedCallback(std::function<void(size_t)> Callback);

	void HideActions();

	void SetData(const FLobbyMemberTableRowData& InData);
	void SetFont(FontPtr InFont);

protected:
	void CalcSizes(Vector2& LabelSize, Vector2& ActionSize);
	void ReadjustLayout();
	void OnPressed(size_t ActionIndex);

	FLobbyMemberTableRowData Data;

	using FRowWidgets = std::array<std::shared_ptr<FTextLabelWidget>, FLobbyMemberTableRowData::EValue::Count>;
	FRowWidgets RowWidgets;
	using FActionButtons = std::array<std::shared_ptr<FButtonWidget>, FLobbyMemberTableRowData::EAction::Count>;
	FActionButtons ActionButtons;
	std::wstring AssetFile;
	FColor BackgroundColor;
	FColor TextColor;
	FontPtr Font;

	std::function<void(size_t)> ActionPressedCallback;
};

template<>
std::shared_ptr<FLobbyMemberTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FLobbyMemberTableRowData& Data);
```

`EAC_SDK/Samples/Lobbies/Source/LobbySearchResultTableRowView.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "LobbySearchResultTableRowView.h"
#include "TextLabel.h"
#include "Button.h"

#include "Lobbies.h"
#include "Game.h"


FLobbySearchResultTableRowView::FLobbySearchResultTableRowView(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& InAssetFile, const FLobbySearchResultTableRowData& InData, FColor InBackgroundColor, FColor InTextColor)
	: FDialog(Pos, Size, Layer), Data(InData), AssetFile(InAssetFile), BackgroundColor(InBackgroundColor), TextColor(InTextColor)
{
	static_assert(std::tuple_size<FLobbySearchResultTableRowView::FRowWidgets>::value == std::tuple_size<FLobbySearchResultTableRowData::FValues>::value, "FRowWidgets must be the same size as the number of values.");
	static_assert(std::tuple_size<FLobbySearchResultTableRowView::FActionButtons>::value == std::tuple_size<FLobbySearchResultTableRowData::FActionsAvailable>::value, "FActionButtons must be the same size as the number of actions.");

	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//create labels
	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		std::shared_ptr<FTextLabelWidget> NextLabel = std::make_shared<FTextLabelWidget>(
			Vector2(Pos.x + LabelSize.x * i, Pos.y),
			LabelSize,
			Layer - 1,
			Data.Values[i],
			AssetFile,
			BackgroundColor,
			TextColor);

		RowWidgets[i] = NextLabel;
		AddWidget(NextLabel);
	}

	//create action buttons
	std::array<std::wstring, FLobbySearchResultTableRowData::EAction::Count> actionLabels;
	std::array<FColor, FLobbySearchResultTableRowData::EAction::Count> actionColors;

	actionLabels[FLobbySearchResultTableRowData::EAction::Join] = L"JOIN";
	actionColors[FLobbySearchResultTableRowData::EAction::Join] = Color::Green;

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		std::shared_ptr<FButtonWidget> NextButton = std::make_shared<FButtonWidget>(
			Vector2(Pos.x + Data.Values.size() * LabelSize.x + Ix * ActionSize.x, Pos.y),
			ActionSize,
			Layer - 1,
			actionLabels[Ix],
			assets::DefaultButtonAssets,
			nullptr,
			actionColors[Ix]);
		NextButton->SetOnPressedCallback([this, Ix]() { this->OnPressed(Ix); });
		if (!Data.bActionsAvailable[Ix])
		{
			NextButton->Disable();
		}

		ActionButtons[Ix] = NextButton;
		AddWidget(NextButton);
	}
}

void FLobbySearchResultTableRowView::SetFocused(bool bValue)
{
	FDialog::SetFocused(bValue);

	if (bValue)
	{
		SetBorderColor(Color::UIDarkGrey);
	}
	else
	{
		ClearBorderColor();
	}
}

void FLobbySearchResultTableRowView::SetPosition(Vector2 Pos)
{
	FDialog::SetPosition(Pos);

	ReadjustLayout();
}

void FLobbySearchResultTableRowView::SetSize(Vector2 NewSize)
{
	FDialog::SetSize(NewSize);

	ReadjustLayout();
}

void FLobbySearchResultTableRowView::Enable()
{
	FDialog::Enable();

	//Disable action buttons
	for (size_t Ix = 0; Ix < FLobbySearchResultTableRowData::EAction::Count; ++Ix)
	{
		if (!Data.bActionsAvailable[Ix] && ActionButtons.size() > Ix)
		{
			std::shared_ptr<FButtonWidget> ActionButton = ActionButtons[Ix];
			if (ActionButton)
			{
				ActionButton->Disable();
			}
		}
	}
}

void FLobbySearchResultTableRowView::SetOnActionPressedCallback(std::function<void(size_t)> Callback)
{
	ActionPressedCallback = Callback;
}

void FLobbySearchResultTableRowView::HideActions()
{
	for (auto ActionButton : ActionButtons)
	{
		if (ActionButton)
		{
			ActionButton->Hide();
		}
	}
}

void FLobbySearchResultTableRowView::SetData(const FLobbySearchResultTableRowData& InData)
{
	Data = InData;

	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		std::wstring DataString = (i < InData.Values.size()) ? InData.Values[i] : L"-";
		RowWidgets[i]->SetText(DataString);
	}

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		if (Data.bActionsAvailable[Ix])
		{
			ActionButtons[Ix]->Enable();
		}
		else
		{
			ActionButtons[Ix]->Disable();
		}
	}

	ReadjustLayout();
}

void FLobbySearchResultTableRowView::SetFont(FontPtr InFont)
{
	Font = InFont;

	for (auto Widget : RowWidgets)
	{
		Widget->SetFont(InFont);
	}

	for (auto Button : ActionButtons)
	{
		Button->SetFont(InFont);
	}
}

void FLobbySearchResultTableRowView::CalcSizes(Vector2& LabelSize, Vector2& ActionSize)
{
	// Fit the action buttons into "2" columns.
	float ActionSizeRatio = 2.3f / FLobbySearchResultTableRowData::EAction::Count;
	float ColumnRatio = Data.Values.size() + ActionSizeRatio * FLobbySearchResultTableRowData::EAction::Count;
	LabelSize = Vector2(Size.x / ColumnRatio, Size.y);
	ActionSize = Vector2(LabelSize.x * ActionSizeRatio, Size.y);
}

void FLobbySearchResultTableRowView::ReadjustLayout()
{
	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//resize labels
	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		RowWidgets[i]->SetPosition(Vector2(Position.x + LabelSize.x * i, Position.y));
		RowWidgets[i]->SetSize(LabelSize);
	}

	for (size_t i = 0; i < ActionButtons.size(); ++i)
	{
		ActionButtons[i]->SetPosition(Vector2(Position.x + Data.Values.size() * LabelSize.x + i * ActionSize.x, Position.y));
		ActionButtons[i]->SetSize(ActionSize);
	}
}

void FLobbySearchResultTableRowView::OnPressed(size_t ActionIndex)
{
	if (ActionPressedCallback)
	{
		ActionPressedCallback(ActionIndex);
	}	

	if (ActionIndex == FLobbySearchResultTableRowData::EAction::Join)
	{
		FGame::Get().GetLobbies()->JoinSearchResult(Data.SearchResultIndex);
	}
}

template<>
std::shared_ptr<FLobbySearchResultTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FLobbySearchResultTableRowData& Data)
{
	return std::make_shared<FLobbySearchResultTableRowView>(Pos, Size, Layer, L"", Data, Color::DarkGray, Color::White);
}
```

`EAC_SDK/Samples/Lobbies/Source/LobbySearchResultTableRowView.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Widget.h"
#include "Font.h"
#include "ListView.h"
#include "Dialog.h"

#include <array>

class FTextLabelWidget;
class FButtonWidget;

struct FLobbySearchResultTableRowData
{
	struct EValue final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			OwnerDisplayName = 0,
			NumMembers,
			LevelName,
			Count
		};
		EValue() = delete;
	};
	struct EAction final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			Join = 0,
			Count
		};
		EAction() = delete;
	};

	uint32_t SearchResultIndex = 0;

	using FValues = std::array<std::wstring, EValue::Count>;
	using FActionsAvailable = std::array<bool, EAction::Count>;
	FValues Values;
	FActionsAvailable bActionsAvailable;

	bool operator!=(const FLobbySearchResultTableRowData& Other) const
	{
		return bActionsAvailable != Other.bActionsAvailable || Values != Other.Values;
	}

	FLobbySearchResultTableRowData()
	{
		bActionsAvailable.fill(false);
		Values[EValue::OwnerDisplayName] = L"Owner Name";
		Values[EValue::NumMembers] = L"Members";
		Values[EValue::LevelName] = L"Level";
	}
};

class FLobbySearchResultTableRowView : public FDialog
{
public:
	FLobbySearchResultTableRowView(Vector2 Pos,
		Vector2 Size,
		UILayer Layer,
		const std::wstring& AssetFile,
		const FLobbySearchResultTableRowData& InData,
		FColor BackgroundColor,
		FColor TextColor);

	void SetFocused(bool bValue) override;

	/** Set Position */
	void SetPosition(Vector2 Pos) override;

	/** Set Size */
	void SetSize(Vector2 NewSize) override;

	void Enable() override;

	void SetOnActionPressedCallback(std::function<void(size_t)> Callback);

	void HideActions();

	void SetData(const FLobbySearchResultTableRowData& InData);
	void SetFont(FontPtr InFont);

protected:
	void CalcSizes(Vector2& LabelSize, Vector2& ActionSize);
	void ReadjustLayout();
	void OnPressed(size_t ActionIndex);

	FLobbySearchResultTableRowData Data;

	using FRowWidgets = std::array<std::shared_ptr<FTextLabelWidget>, FLobbySearchResultTableRowData::EValue::Count>;
	FRowWidgets RowWidgets;
	using FActionButtons = std::array<std::shared_ptr<FButtonWidget>, FLobbySearchResultTableRowData::EAction::Count>;
	FActionButtons ActionButtons;
	std::wstring AssetFile;
	FColor BackgroundColor;
	FColor TextColor;
	FontPtr Font;

	std::function<void(size_t)> ActionPressedCallback;
};

template<>
std::shared_ptr<FLobbySearchResultTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FLobbySearchResultTableRowData& Data);
```

`EAC_SDK/Samples/Lobbies/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "FriendsDialog.h"
#include "LobbiesDialog.h"
#include "NewLobbyDialog.h"
#include "LobbyInviteReceivedDialog.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "PopupDialog.h"

const float UpperDialogsVerticalOffset = 130.0f;

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreateFriendsDialog();

	FBaseMenu::Create();

	CreateLobbiesDialog();
	CreateNewLobbyDialog();
	CreateLobbyInviteReceivedDialog();
}

void FMenu::Release()
{
	if (LobbiesDialog)
	{
		LobbiesDialog->Release();
		LobbiesDialog.reset();
	}

	FBaseMenu::Release();
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * 0.68f, WindowSize.y * 0.35f);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (LobbiesDialog)
		{
			LobbiesDialog->SetSize(Vector2(ConsoleWidgetSize.x, ConsoleWidgetPos.y - UpperDialogsVerticalOffset - 10.0f));
			LobbiesDialog->SetPosition(Vector2(ConsoleWidgetPos.x, UpperDialogsVerticalOffset));
		}

		UpdateFriendsDialogTransform(WindowSize);
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y - 200.0f));
	}

	if (NewLobbyDialog)
	{
		NewLobbyDialog->SetPosition(Vector2((WindowSize.x / 2.f) - NewLobbyDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - NewLobbyDialog->GetSize().y + 90.0f));
	}

	if (LobbyInviteReceivedDialog)
	{
		LobbyInviteReceivedDialog->SetPosition(Vector2((WindowSize.x / 2.f) - LobbyInviteReceivedDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - LobbyInviteReceivedDialog->GetSize().y - 2.0f));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::CreateLobbiesDialog()
{
	const float FX = ConsoleDialog->GetPosition().x;
	const float FY = UpperDialogsVerticalOffset;
	const float Width = ConsoleDialog->GetSize().x;
	const float Height = ConsoleDialog->GetSize().y;

	LobbiesDialog = std::make_shared<FLobbiesDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	LobbiesDialog->SetBorderColor(Color::UIBorderGrey);
	
	LobbiesDialog->Create();

	AddDialog(LobbiesDialog);
}

void FMenu::CreateNewLobbyDialog()
{
	NewLobbyDialog = std::make_shared<FNewLobbyDialog>(
		Vector2(200.f, 270.f),
		Vector2(370.0f, 280.0f),
		5,
		NormalFont->GetFont(),
		SmallFont->GetFont()
		);

	NewLobbyDialog->Create();
	NewLobbyDialog->SetBorderColor(Color::UIBorderGrey);

	AddDialog(NewLobbyDialog);
	HideDialog(NewLobbyDialog);
}

void FMenu::CreateLobbyInviteReceivedDialog()
{
	LobbyInviteReceivedDialog = std::make_shared<FLobbyInviteReceivedDialog>(
		Vector2(200.f, 270.f),
		Vector2(370.0f, 200.0f),
		5,
		NormalFont->GetFont(),
		SmallFont->GetFont()
		);

	LobbyInviteReceivedDialog->Create();
	LobbyInviteReceivedDialog->SetBorderColor(Color::UIBorderGrey);

	AddDialog(LobbyInviteReceivedDialog);
	HideDialog(LobbyInviteReceivedDialog);
}

void FMenu::OnUIEvent(const FUIEvent& Event)
{
	if ((!NewLobbyDialog || !NewLobbyDialog->IsShown()) &&
		(!LobbyInviteReceivedDialog || !LobbyInviteReceivedDialog->IsShown()))
	{
		FBaseMenu::OnUIEvent(Event);
	}
	else
	{
		if (NewLobbyDialog && NewLobbyDialog->IsShown())
		{
			NewLobbyDialog->OnUIEvent(Event);
		}
		if (LobbyInviteReceivedDialog && LobbyInviteReceivedDialog->IsShown())
		{
			LobbyInviteReceivedDialog->OnUIEvent(Event);
		}
	}
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::LobbyInviteReceived)
	{
		if (LobbyInviteReceivedDialog)
		{
			LobbyInviteReceivedDialog->SetLobbyInvite(FGame::Get().GetLobbies()->GetCurrentInvite());
			ShowDialog(LobbyInviteReceivedDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::OverlayInviteToLobbyAccepted)
	{
		if (LobbyInviteReceivedDialog)
		{
			HideDialog(LobbyInviteReceivedDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::NewLobby)
	{
		if (NewLobbyDialog)
		{
			LobbiesDialog->Disable();
			NewLobbyDialog->SetEditingMode(false);
			ShowDialog(NewLobbyDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::LobbyCreationFinished)
	{
		if (NewLobbyDialog)
		{
			HideDialog(NewLobbyDialog);
			LobbiesDialog->Enable();
		}
	}
	else if (Event.GetType() == EGameEventType::ModifyLobby)
	{
		if (NewLobbyDialog)
		{
			LobbiesDialog->Disable();
			NewLobbyDialog->SetEditingMode(true);
			ShowDialog(NewLobbyDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::LobbyModificationFinished)
	{
		if (NewLobbyDialog)
		{
			HideDialog(NewLobbyDialog);
			LobbiesDialog->Enable();
		}
	}

	if (LobbiesDialog)
	{
		LobbiesDialog->OnGameEvent(Event);
	}

	FBaseMenu::OnGameEvent(Event);
}

void FMenu::UpdateFriendsDialogTransform(const Vector2 WindowSize)
{
	if (FriendsDialog)
	{
		const float FX = LobbiesDialog->GetPosition().x + LobbiesDialog->GetSize().x + 5.0f;
		const float FY = UpperDialogsVerticalOffset;
		const float FriendsWidth = WindowSize.x - FX - 5.0f;
		const float FriendsHeight = WindowSize.y - FY - 10.0f;

		FriendsDialog->SetSize(Vector2(FriendsWidth, FriendsHeight));
		FriendsDialog->SetPosition(Vector2(FX, FY));
	}
}

```

`EAC_SDK/Samples/Lobbies/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FLobbiesDialog;
class FLobbyInviteReceivedDialog;
class FNewLobbyDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> console) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	virtual void UpdateLayout(int Width, int Height) override;

	/**
	* Event Callback
	*
	* @param Event - UI event
	*/
	virtual void OnUIEvent(const FUIEvent& Event) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

private:
	/**
	 * Creates the lobbies dialog
	 */
	void CreateLobbiesDialog();

	/**
	* Creates and hides the popup dialog for lobby creation.
	*/
	void CreateNewLobbyDialog();

	/**
	* Creates and hides the popup dialog for lobby invite.
	*/
	void CreateLobbyInviteReceivedDialog();

	/**
	 * Updates friends dialog to match lobbies dialog. 
	 */
	void UpdateFriendsDialogTransform(const Vector2 WindowSize);

	/** Lobbies Dialog */
	std::shared_ptr<FLobbiesDialog> LobbiesDialog;

	/** Dialog with lobby settings */
	std::shared_ptr<FNewLobbyDialog> NewLobbyDialog;

	/** Popup dialog when user is being invited to lobby */
	std::shared_ptr<FLobbyInviteReceivedDialog> LobbyInviteReceivedDialog;
};

```

`EAC_SDK/Samples/Lobbies/Source/NewLobbyDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "GameEvent.h"
#include "TextLabel.h"
#include "Button.h"
#include "DropDownList.h"
#include "Checkbox.h"
#include "NewLobbyDialog.h"
#include "StringUtils.h"
#include "Lobbies.h"

static const float NewLobbyDialogUIElementsXOffset = 20.0f;
static const float NewLobbyDialogUIElementsYOffset = 20.0f;
static const int MaxUsersInLobby = 20;

FNewLobbyDialog::FNewLobbyDialog(Vector2 InPos,
	Vector2 InSize,
	UILayer InLayer,
	FontPtr InNormalFont,
	FontPtr InSmallFont) :
	FDialog(InPos, InSize, InLayer)
{
	Background = std::make_shared<FSpriteWidget>(
		Position,
		InSize,
		InLayer,
		L"Assets/textfield.dds",
		Color::Black);
	AddWidget(Background);


	HeaderLabel = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x, Position.y),
		Vector2(InSize.x, 30.f),
		InLayer - 1,
		L"CREATE NEW LOBBY",
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f));
	HeaderLabel->SetFont(InNormalFont);
	HeaderLabel->SetBorderColor(Color::UIBorderGrey);
	AddWidget(HeaderLabel);

	const Vector2 UIPosition = Position + Vector2(NewLobbyDialogUIElementsXOffset, HeaderLabel->GetSize().y + NewLobbyDialogUIElementsYOffset);
	const float UIWidth = InSize.x - 2.0f * NewLobbyDialogUIElementsXOffset;
	const Vector2 DropDownListsSize = Vector2(UIWidth / 2.0f - 5.0f, 30.0f);

	BucketIdField = std::make_shared<FTextFieldWidget>(
		UIPosition,
		Vector2(150.0f, 30.0f),
		Layer - 1,
		L"BucketId",
		L"Assets/textfield.dds",
		InNormalFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
		);
	BucketIdField->SetBorderColor(Color::UIBorderGrey);

	if (bEditingLobby)
	{
		BucketIdField->SetText(FStringUtils::Widen(FGame::Get().GetLobbies()->GetCurrentLobby().BucketId));
	}

	AddWidget(BucketIdField);

	LobbyLevelDropDown = std::make_shared<FDropDownList>(
		UIPosition + Vector2(0.0f, BucketIdField->GetSize().y + 10.0f),
		DropDownListsSize,
		DropDownListsSize + Vector2(0.0f, 85.0),
		Layer - 1,
		L"Level: ",
		std::vector<std::wstring>({ L"FOREST", L"CASTLE", L"DUNGEON", L"VILLAGE", L"VALLEY"}),
		InNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	LobbyLevelDropDown->SetBorderColor(Color::UIBorderGrey);
	//AddWidget(LobbyLevelDropDown);

	MaxPlayersDropDown = std::make_shared<FDropDownList>(
		LobbyLevelDropDown->GetPosition() + Vector2(DropDownListsSize.x  + 10.0f, 0.0f),
		DropDownListsSize,
		DropDownListsSize + Vector2(0.0f, 85.0),
		Layer - 1,
		L"Max Players: ",
		GetUsersOptionsList(2, MaxUsersInLobby),
		InNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	MaxPlayersDropDown->SetBorderColor(Color::UIBorderGrey);
	//AddWidget(MaxPlayersDropDown);

	PublicCheckbox = std::make_shared<FCheckboxWidget>(
		LobbyLevelDropDown->GetPosition() + Vector2(0.0f, DropDownListsSize.y + 10.0f),
		Vector2(75.0f, 30.0f),
		Layer - 1,
		L"Public",
		L"",
		InNormalFont
		);
	AddWidget(PublicCheckbox);

	InvitesAllowedCheckbox = std::make_shared<FCheckboxWidget>(
		PublicCheckbox->GetPosition() + Vector2(PublicCheckbox->GetSize().x + 10.f, 0.f),
		Vector2(75.0f, 30.0f),
		Layer - 1,
		L"Allow Invites",
		L"",
		InNormalFont
		);
	AddWidget(InvitesAllowedCheckbox);

	PresenceCheckbox = std::make_shared<FCheckboxWidget>(
		InvitesAllowedCheckbox->GetPosition() + Vector2(InvitesAllowedCheckbox->GetSize().x + 50.f, 0.f),
		Vector2(75.0f, 30.0f),
		Layer - 1,
		L"Presence",
		L"",
		InNormalFont
		);
	AddWidget(PresenceCheckbox);

	RTCRoomCheckbox = std::make_shared<FCheckboxWidget>(
		PublicCheckbox->GetPosition() + Vector2(0.0f, PublicCheckbox->GetSize().y + 10.f),
		Vector2(75.0f, 30.0f),
		Layer - 1,
		L"RTC Voice Room",
		L"",
		InNormalFont
		);
	AddWidget(RTCRoomCheckbox);

	CreateButton = std::make_shared<FButtonWidget>(
		Vector2(Position.x + InSize.x / 2.0f - 100.0f, Position.y + InSize.y - 60.0f),
		Vector2(200.f, 45.f),
		InLayer - 1,
		L"CREATE",
		assets::DefaultButtonAssets,
		InSmallFont,
		Color::UIButtonBlue
		);
	CreateButton->SetOnPressedCallback([this]()
	{
		if (bEditingLobby)
		{
			OnModifyLobbyPressed();
		}
		else
		{
			OnCreateLobbyPressed();
		}

		FinishLobbyModification();
	});
	CreateButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(CreateButton);

	CloseButton = std::make_shared<FButtonWidget>(
		Vector2(Position.x + InSize.x - 30.0f, Position.y),
		Vector2(30.0f, 30.f),
		InLayer - 1,
		L"",
		std::vector<std::wstring>({ L"Assets/nobutton.dds" }),
		InSmallFont,
		FColor(1.0f, 1.0f, 1.0f, 1.0f)
		);
	CloseButton->SetOnPressedCallback([this]()
	{
		FinishLobbyModification();
	});
	AddWidget(CloseButton);

	//Dropdown lists have to be last widgets in the list otherwise they will overlap with other widgets when expanded on DX platform.
	//This is temporary workaround (hack).
	//TODO: fix DX render to use UI Layer value correctly
	AddWidget(LobbyLevelDropDown);
	AddWidget(MaxPlayersDropDown);
}

FNewLobbyDialog::~FNewLobbyDialog()
{

}

std::vector<std::wstring> FNewLobbyDialog::GetUsersOptionsList(int MinUsers, int MaxUsers)
{
	std::vector<std::wstring> MaxUsersOptions;
	MaxUsersOptions.reserve(MaxUsers);

	for (int Option = MinUsers; Option <= MaxUsers; Option++)
	{
		MaxUsersOptions.push_back(std::to_wstring(Option));
	}

	return std::move(MaxUsersOptions);
}

void FNewLobbyDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	Background->SetPosition(Position);
	HeaderLabel->SetPosition(Position);

	const float UIWidth = GetSize().x - 2.0f * NewLobbyDialogUIElementsXOffset;
	const Vector2 DropDownListsSize = Vector2(UIWidth / 2.0f - 5.0f, 30.0f);
	const Vector2 UIPosition = Position + Vector2(NewLobbyDialogUIElementsXOffset, HeaderLabel->GetSize().y + NewLobbyDialogUIElementsYOffset);

	BucketIdField->SetPosition(UIPosition);

	LobbyLevelDropDown->SetPosition(UIPosition + Vector2(0.0f, BucketIdField->GetSize().y + 10.0f));
	MaxPlayersDropDown->SetPosition(LobbyLevelDropDown->GetPosition() + Vector2(DropDownListsSize.x + 10.0f, 0.0f));

	// Row 1 Check Options
	PublicCheckbox->SetPosition(LobbyLevelDropDown->GetPosition() + Vector2(0.0f, DropDownListsSize.y + 10.f));
	InvitesAllowedCheckbox->SetPosition(PublicCheckbox->GetPosition() + Vector2(PublicCheckbox->GetSize().x + 10.0f, 0.f));
	PresenceCheckbox->SetPosition(InvitesAllowedCheckbox->GetPosition() + Vector2(InvitesAllowedCheckbox->GetSize().x + 50.0f, 0.f));
	// Row 2 Check Options
	RTCRoomCheckbox->SetPosition(PublicCheckbox->GetPosition() + Vector2(0.0f, PublicCheckbox->GetSize().y + 10.f));

	CreateButton->SetPosition(Vector2(Position.x + GetSize().x / 2.0f - 100.0f, Position.y + GetSize().y - 60.0f));
	CloseButton->SetPosition(Vector2(Position.x + GetSize().x - 30.0f, Position.y));
}

void FNewLobbyDialog::Create()
{
	FDialog::Create();

	LobbyLevelDropDown->SetParent(std::weak_ptr<FDialog>(std::static_pointer_cast<FDialog>(shared_from_this())));
	MaxPlayersDropDown->SetParent(std::weak_ptr<FDialog>(std::static_pointer_cast<FDialog>(shared_from_this())));
}

void FNewLobbyDialog::Update()
{
	if (BucketIdField)
	{
		// Update CreateButton state:
		// It is only enabled when user enters a non-empty bucket id.
		std::wstring BucketIdString = BucketIdField->GetText();
		bool BucketIdPresent = !BucketIdString.empty() && BucketIdString != BucketIdField->GetInitialText();
		if (BucketIdPresent)
		{
			CreateButton->Enable();
		}
		else
		{
			CreateButton->Disable();
		}
	}

	FDialog::Update();
}

void FNewLobbyDialog::SetEditingMode(bool bValue)
{
	bEditingLobby = bValue;

	//Change label
	if (HeaderLabel)
	{
		if (bEditingLobby)
		{
			HeaderLabel->SetText(L"MODIFY LOBBY");
		}
		else
		{
			HeaderLabel->SetText(L"CREATE NEW LOBBY");
		}
	}

	//Create button label
	if (CreateButton)
	{
		if (bEditingLobby)
		{
			CreateButton->SetText(L"APPLY");
		}
		else
		{
			CreateButton->SetText(L"CREATE");
		}
	}

	// Change invite enabled accessibility.
	if (InvitesAllowedCheckbox)
	{
		// Assume only lobby owner ever sees this dialog, otherwise need to check ownership
		InvitesAllowedCheckbox->Enable();
		if (bEditingLobby)
		{
			const FLobby& Lobby = FGame::Get().GetLobbies()->GetCurrentLobby();
			InvitesAllowedCheckbox->SetTicked(Lobby.AreInvitesAllowed());
		}
		else
		{
			// Default to invites allowed
			InvitesAllowedCheckbox->SetTicked(true);
		}
	}

	// Change presence enabled accessibility.
	if (PresenceCheckbox)
	{
		if (bEditingLobby)
		{
			PresenceCheckbox->Disable();
			PresenceCheckbox->SetTicked(FGame::Get().GetLobbies()->GetCurrentLobby().IsPresenceEnabled());
			// Grey-out the text to further imply the checkbox is disabled
			PresenceCheckbox->SetTextColor(FColor(0.5, 0.5, 0.5, 1.0));
		}
		else
		{
			PresenceCheckbox->Enable();
			PresenceCheckbox->SetTicked(true);
			// Ensure the text is back to white when enabled
			PresenceCheckbox->SetTextColor(Color::White);
		}
	}

	// Change RTC Room enabled accessibility.
	if (RTCRoomCheckbox)
	{
		if (bEditingLobby)
		{
			RTCRoomCheckbox->Disable();
			RTCRoomCheckbox->SetTicked(FGame::Get().GetLobbies()->GetCurrentLobby().IsRTCRoomEnabled());
			// Grey-out the text to further imply the checkbox is disabled
			RTCRoomCheckbox->SetTextColor(FColor(0.5, 0.5, 0.5, 1.0));
		}
		else
		{
			RTCRoomCheckbox->Enable();
			RTCRoomCheckbox->SetTicked(true);
			// Ensure the text is back to white when enabled
			RTCRoomCheckbox->SetTextColor(Color::White);
		}
	}

	//Lower limit on players number.
	const int CurrentNumPlayers = (int)FGame::Get().GetLobbies()->GetCurrentLobby().Members.size();
	int LowerLimitNumPlayers = (bEditingLobby) ? CurrentNumPlayers : 2;
	if (LowerLimitNumPlayers < 2)
	{
		LowerLimitNumPlayers = 2;
	}

	MaxPlayersDropDown->UpdateOptionsList(GetUsersOptionsList(LowerLimitNumPlayers, MaxUsersInLobby));
}

void FNewLobbyDialog::OnCreateLobbyPressed()
{
	FLobby Lobby;
	const std::wstring& MaxPlayersString = MaxPlayersDropDown->GetCurrentSelection();
	Lobby.MaxNumLobbyMembers = atoi(FStringUtils::Narrow(MaxPlayersString).data());
	Lobby.Permission = (PublicCheckbox->IsTicked()) ? EOS_ELobbyPermissionLevel::EOS_LPL_PUBLICADVERTISED : EOS_ELobbyPermissionLevel::EOS_LPL_INVITEONLY;
	Lobby.bPresenceEnabled = PresenceCheckbox->IsTicked();
	Lobby.bRTCRoomEnabled = RTCRoomCheckbox->IsTicked();
	Lobby.bAllowInvites = InvitesAllowedCheckbox->IsTicked();
	Lobby.BucketId = FStringUtils::Narrow(BucketIdField->GetText());

	FLobbyAttribute Attribute;
	Attribute.Key = "LEVEL";
	Attribute.AsString = FStringUtils::Narrow(LobbyLevelDropDown->GetCurrentSelection());
	Attribute.ValueType = FLobbyAttribute::String;
	Attribute.Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;

	Lobby.Attributes.push_back(Attribute);

	FGame::Get().GetLobbies()->CreateLobby(Lobby);
}

void FNewLobbyDialog::OnModifyLobbyPressed()
{
	FLobby Lobby = FGame::Get().GetLobbies()->GetCurrentLobby();
	const std::wstring& MaxPlayersString = MaxPlayersDropDown->GetCurrentSelection();
	Lobby.MaxNumLobbyMembers = atoi(FStringUtils::Narrow(MaxPlayersString).data());
	Lobby.Permission = (PublicCheckbox->IsTicked()) ? EOS_ELobbyPermissionLevel::EOS_LPL_PUBLICADVERTISED : EOS_ELobbyPermissionLevel::EOS_LPL_INVITEONLY;
	Lobby.bAllowInvites = InvitesAllowedCheckbox->IsTicked();
	Lobby.BucketId = FStringUtils::Narrow(BucketIdField->GetText());

	FLobbyAttribute Attribute;
	Attribute.Key = "LEVEL";
	Attribute.AsString = FStringUtils::Narrow(LobbyLevelDropDown->GetCurrentSelection());
	Attribute.ValueType = FLobbyAttribute::String;
	Attribute.Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;

	Lobby.Attributes.push_back(Attribute);

	FGame::Get().GetLobbies()->ModifyLobby(Lobby);
}


void FNewLobbyDialog::FinishLobbyModification()
{
	FGameEvent Event((bEditingLobby) ? EGameEventType::LobbyModificationFinished : EGameEventType::LobbyCreationFinished);
	FGame::Get().OnGameEvent(Event);
}

void FNewLobbyDialog::OnEscapePressed()
{
	FinishLobbyModification();
}
```

`EAC_SDK/Samples/Lobbies/Source/NewLobbyDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FButtonWidget;
class FDropDownList;
class FCheckboxWidget;
class FTextFieldWidget;

/**
 * Lobby creation dialog. User can pick parameters and create new lobby.
 * Can be used for Lobby modification via SetEditingMode(true).
 */
class FNewLobbyDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FNewLobbyDialog(Vector2 InPos,
		Vector2 InSize,
		UILayer InLayer,
		FontPtr InNormalFont,
		FontPtr InSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FNewLobbyDialog();

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void OnEscapePressed() override;

	virtual void Create() override;
	virtual void Update() override;

	void SetEditingMode(bool bValue);

protected:
	void OnCreateLobbyPressed();
	void OnModifyLobbyPressed();
	void FinishLobbyModification();

	std::vector<std::wstring> GetUsersOptionsList(int MinUsers, int MaxUsers);

private:
	/** Background */
	WidgetPtr Background;

	/** Label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Lobby's bucket id */
	std::shared_ptr<FTextFieldWidget> BucketIdField;

	/** Lobby level */
	std::shared_ptr<FDropDownList> LobbyLevelDropDown;

	/** Lobby max players */
	std::shared_ptr<FDropDownList> MaxPlayersDropDown;

	/** Is Lobby public? */
	std::shared_ptr<FCheckboxWidget> PublicCheckbox;

	/** Is Lobby invite only? */
	std::shared_ptr<FCheckboxWidget> InvitesAllowedCheckbox;

	/** Is Lobby for presence? */
	std::shared_ptr<FCheckboxWidget> PresenceCheckbox;

	/** Is Lobby RTC Room Enabled? */
	std::shared_ptr<FCheckboxWidget> RTCRoomCheckbox;

	/** Is this dialog in editing mode modifying existing lobby (instead of creating a new lobby) */
	bool bEditingLobby = false;

	/** Create Lobby button */
	std::shared_ptr<FButtonWidget> CreateButton;

	/** Close dialog button */
	std::shared_ptr<FButtonWidget> CloseButton;
};

```

`EAC_SDK/Samples/Lobbies/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Lobbies";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/Lobbies/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/Lobbies/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/Mods/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/Mods/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/Mods/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/Mods/Mods.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>Mods</RootNamespace>
    <ProjectGuid>{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Mods</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_MODS;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Mods/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_MODS;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Mods/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_MODS;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Mods/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_MODS;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Mods/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_MODS;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Mods/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_MODS;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Mods/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_MODS;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Mods/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_MODS;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Mods/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableRowView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\ModsTableDialog.h" />
    <ClInclude Include="Source\ModsTableRowView.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\Mods.h" />
    <ClInclude Include="Source\ModsDialog.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TableRowView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\Mods.cpp" />
    <ClCompile Include="Source\ModsDialog.cpp" />
    <ClCompile Include="Source\ModsTableDialog.cpp" />
    <ClCompile Include="Source\ModsTableRowView.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="..\Shared\Source\Graphics\GUI\TableView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/Mods/Mods.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="Source\Mods.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\ModsDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableRowView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="Source\ModsTableRowView.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\ModsTableDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
	<ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Source\Mods.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\ModsDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TableRowView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="Source\ModsTableRowView.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\ModsTableDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\TableView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/Mods/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "Mods.h"
#include "GameEvent.h"
#include "Platform.h"
#include "Game.h"

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	Mods = std::make_unique<FMods>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
}

void FGame::Init()
{
	FBaseGame::Init();

	Mods->Init();
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" SETREMOVEAFTEREXIT VALUE - set's default RemoveAfterExit behavior. VALUE is either true or false",
			L" INSTALL NamespaceId ItemId ArtifactId [RemoveAfterExit] - to install Mod (RemoveAfterExit is optional);",
			L" UNINSTALL NamespaceId ItemId ArtifactId - to install Mod;",
			L" UPDATE NamespaceId ItemId ArtifactId - to install Mod;",
		};

		AppendHelpMessageLines(ExtraHelpMessageLines);

		Console->AddCommand(L"SetRemoveAfterExit", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (args.size() == 1)
				{
					if (FGame::Get().GetMods())
					{
						const bool bRemoveAfterExit = args[0] == L"true";
						FGame::Get().GetMods()->SetRemoveAfterExit(bRemoveAfterExit);
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"SetRemoveAfterExit error: [trur | false] argument is required.");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
		Console->AddCommand(L"INSTALL", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{

				if (args.size() == 3 || args.size() == 4)
				{
					FModId ModId;
					ModId.NamespaceId = FStringUtils::Narrow(args[0]);
					ModId.ItemId = FStringUtils::Narrow(args[1]);
					ModId.ArtifactId = FStringUtils::Narrow(args[2]);

					const bool bRemoveAfterExit = args.size() == 4 && args[3] == L"RemoveAfterExit";

					if (FGame::Get().GetMods())
					{
						FGame::Get().GetMods()->InstallMod(std::move(ModId), bRemoveAfterExit);
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"Install error: {NamespaceId, ItemId, ArtifactId} are required.");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
		Console->AddCommand(L"UNINSTALL", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{

				if (args.size() == 3)
				{
					FModId ModId;
					ModId.NamespaceId = FStringUtils::Narrow(args[0]);
					ModId.ItemId = FStringUtils::Narrow(args[1]);
					ModId.ArtifactId = FStringUtils::Narrow(args[2]);

					if (FGame::Get().GetMods())
					{
						FGame::Get().GetMods()->UnInstallMod(std::move(ModId));
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"UnInstall error: {NamespaceId, ItemId, ArtifactId} are required.");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
		Console->AddCommand(L"UPDATE", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (args.size() == 3)
				{
					FModId ModId;
					ModId.NamespaceId = FStringUtils::Narrow(args[0]);
					ModId.ItemId = FStringUtils::Narrow(args[1]);
					ModId.ArtifactId = FStringUtils::Narrow(args[2]);

					if (FGame::Get().GetMods())
					{
						FGame::Get().GetMods()->UpdateMod(std::move(ModId));
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"Update error: {NamespaceId, ItemId, ArtifactId} are required.");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"ADDTESTDATA", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetMods())
				{
					FGame::Get().GetMods()->AddTestData();
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
	}
}

void FGame::Update()
{
	Mods->Update();

	FBaseGame::Update();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);
	Mods->OnGameEvent(Event);
}

std::unique_ptr<FMods> const& FGame::GetMods()
{
	return Mods;
}
```

`EAC_SDK/Samples/Mods/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FMods;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Init
	*/
	virtual void Init() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	 * Getter for mods component.
	 */
	const std::unique_ptr<FMods>& GetMods();

protected:
	/**
	* Creates all console commands
	*/
	virtual void CreateConsoleCommands() override;

	/** Mods component */
	std::unique_ptr<FMods> Mods;

	/** Timestamp to know when shutdown was triggered */
	double ShutdownTriggeredTimestamp = 0.0;
};


```

`EAC_SDK/Samples/Mods/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/Mods/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "ModsDialog.h"
#include "ModsTableDialog.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "PopupDialog.h"

const Vector2 ConsoleDialogSizeProportion = Vector2(0.68f, 0.35f);

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreateModsDialog();
	CreateModsTableDialog();

	FBaseMenu::Create();
}

void FMenu::Release()
{
	if (ModsDialog)
	{
		ModsDialog->Release();
		ModsDialog.reset();
	}

	if (ModsTableDialog)
	{
		ModsTableDialog->Release();
		ModsTableDialog.reset();
	}

	FBaseMenu::Release();
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * ConsoleDialogSizeProportion.x, WindowSize.y * ConsoleDialogSizeProportion.y);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (ModsDialog)
		{
			ModsDialog->SetWindowSize(WindowSize);

			Vector2 ModsDialogSize = Vector2(WindowSize.x - ConsoleDialog->GetSize().x - 30.f, WindowSize.y - 130.0f);
			ModsDialog->SetSize(ModsDialogSize);

			Vector2 ModsDialogPos = Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
				WindowSize.y - ModsDialogSize.y - 10.f);
			ModsDialog->SetPosition(ModsDialogPos);
		}

		if (ModsTableDialog)
		{
			ModsTableDialog->SetWindowSize(WindowSize);

			Vector2 ModsTableDialogSize = Vector2(ConsoleWidgetSize.x, WindowSize.y - ConsoleDialog->GetSize().y - 130.0f);
			ModsTableDialog->SetSize(ModsTableDialogSize);

			Vector2 ModsTableDialogPos = Vector2(ConsoleDialog->GetPosition().x, WindowSize.y - ConsoleWidgetSize.y - ModsTableDialogSize.y - 10.f);
			ModsTableDialog->SetPosition(ModsTableDialogPos);
		}
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::CreateAuthDialogs()
{
	AuthDialogs = std::make_shared<FAuthDialogs>(
		ModsDialog,
		L"Mods",
		BoldSmallFont->GetFont(),
		SmallFont->GetFont(),
		TinyFont->GetFont());

	AuthDialogs->SetUserLabelOffset(Vector2(-30.0f, -10.0f));
	AuthDialogs->Create();
	AuthDialogs->SetSingleUserOnly(true);
}

void FMenu::CreateModsDialog()
{
	const float FX = 100.0f;
	const float FY = 100.0f;
	const float Width = 300.0f;
	const float Height = 300.0f;

	ModsDialog = std::make_shared<FModsDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	ModsDialog->SetWindowProportion(ConsoleDialogSizeProportion);
	ModsDialog->SetBorderColor(Color::UIBorderGrey);
	
	ModsDialog->Create();

	AddDialog(ModsDialog);
}

void FMenu::CreateModsTableDialog()
{
	const float FX = 20.f;
	const float FY = 170.f;
	const float Width = 300.0f;
	const float Height = 300.f;

	ModsTableDialog = std::make_shared<FModsTableDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	ModsTableDialog->SetWindowProportion(ConsoleDialogSizeProportion);
	ModsTableDialog->SetBorderColor(Color::UIBorderGrey);

	ModsTableDialog->Create();

	AddDialog(ModsTableDialog);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		UpdateMods();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		UpdateMods();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		UpdateMods();
	}

	if (ModsDialog) ModsDialog->OnGameEvent(Event);
	if (ModsTableDialog) ModsTableDialog->OnGameEvent(Event);

	FBaseMenu::OnGameEvent(Event);
}

void FMenu::UpdateMods()
{
	if (ModsDialog)
	{
		ModsDialog->SetPosition(Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
			ModsDialog->GetPosition().y));
	}

	if (ModsTableDialog)
	{
		ModsTableDialog->SetPosition(Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
			ModsTableDialog->GetPosition().y));
	}
}

```

`EAC_SDK/Samples/Mods/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FUIEvent;
class FConsole;
class FGameEvent;
class FFont;
class FConsoleDialog;
class FFriendsDialog;
class FExitDialog;
class FAuthDialogs;
class FSpriteWidget;
class FTextLabelWidget;
class FModsDialog;
class FModsTableDialog;
class FPopupDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> console) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event) override;

protected:
	/** 
	 * Create auth dialogs
	 */
	virtual void CreateAuthDialogs() override;

	/**
	 * Creates the Mods table dialog
	 */
	void CreateModsDialog();

	/**
	 * Creates the Mods dialog
	 */
	void CreateModsTableDialog();

	/**
	* Updates Mods
	*/
	void UpdateMods();

	/** Mods Dialog */
	std::shared_ptr<FModsDialog> ModsDialog;

	/** ModsTable Dialog */
	std::shared_ptr<FModsTableDialog> ModsTableDialog;
};

```

`EAC_SDK/Samples/Mods/Source/Mods.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "Utils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "Mods.h"
#include <eos_mods.h>


FModDetail::FModDetail(FModId Id) : Id(Id)
{
}

FModDetail::FModDetail(EOS_Mods_ModInfo* ModsInfo, int Index)
{
	auto& Mod = ModsInfo->Mods[Index];
	Id.ArtifactId = Mod.ArtifactId;
	Id.ItemId = Mod.ItemId;
	Id.NamespaceId = Mod.NamespaceId;
	Title = Mod.Title;
	Version = Mod.Version;
	State = GetState(ModsInfo);
}

EModState FModDetail::GetState(EOS_Mods_ModInfo* ModsInfo)
{
	switch (ModsInfo->Type)
	{
		case EOS_EModEnumerationType::EOS_MET_INSTALLED:
			return EModState::Installed;
		case EOS_EModEnumerationType::EOS_MET_ALL_AVAILABLE:
			return EModState::Available;
	}
	FDebugLog::LogError(L"Mods: Unknown State.");
	return EModState::Unknown;
}

FMods::FMods()
{
}

FMods::~FMods()
{

}

void FMods::Init()
{
	if (FPlatform::GetPlatformHandle() != nullptr)
	{
		ModsHandle = EOS_Platform_GetModsInterface(FPlatform::GetPlatformHandle());
	}
}

void FMods::Update()
{

}

void FMods::UpdateStateAfterRequestCompletion()
{
	ModDetailsCache.clear();
	FetchMods(EOS_EModEnumerationType::EOS_MET_INSTALLED);
}

void FMods::SetRemoveAfterExit(bool DefaultRemoveAfterExit)
{
	bDefaultRemoveAfterExit = DefaultRemoveAfterExit;
}

void FMods::InstallMod(FModId ModId)
{
	InstallMod(ModId, bDefaultRemoveAfterExit);
}

void FMods::InstallMod(FModId ModId, bool bRemoveAfterExit)
{
	if (ValidatePreconditions() == false)
	{
		return;
	}

	Command = std::make_unique<FRequest>(FRequest{ std::move(ModId), ERequestType::Install });

	EOS_Mods_InstallModOptions Opt = {};
	Opt.ApiVersion = EOS_MODS_INSTALLMOD_API_LATEST;
	Opt.LocalUserId = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser())->GetUserID();
	Opt.Mod = &Command->ModIdentifier();
	Opt.bRemoveAfterExit = bRemoveAfterExit ? EOS_TRUE : EOS_FALSE;

	EOS_Mods_InstallMod(ModsHandle, &Opt, this, OnInstallComplete);
}

void FMods::OnInstallComplete(const EOS_Mods_InstallModCallbackInfo* Data)
{
	if (!Data)
	{
		FDebugLog::LogError(L"Mods: Mod Installation failed.");
		return;
	}

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	FMods& Self = *static_cast<FMods*>(Data->ClientData);
	
	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogWarning(L"Mods: Install operation error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		Self.Complete();
		return;
	}

	FDebugLog::Log(L"Mods: Install operation completed successfully.");

	Self.UpdateStateAfterRequestCompletion();
}

void FMods::UnInstallMod(FModId ModId)
{
	if (ValidatePreconditions() == false)
	{
		return;
	}

	Command = std::make_unique<FRequest>(FRequest{ std::move(ModId), ERequestType::Uninstall });

	EOS_Mods_UninstallModOptions Opt = {};
	Opt.ApiVersion = EOS_MODS_UNINSTALLMOD_API_LATEST;
	Opt.LocalUserId = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser())->GetUserID();
	Opt.Mod = &Command->ModIdentifier();

	EOS_Mods_UninstallMod(ModsHandle, &Opt, this, OnUninstallComplete);
}

void FMods::OnUninstallComplete(const EOS_Mods_UninstallModCallbackInfo* Data)
{
	if (!Data)
	{
		FDebugLog::LogError(L"Mods: Mod Uninstall failed.");
		return;
	}

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	FMods& Self = *static_cast<FMods*>(Data->ClientData);

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogWarning(L"Mods: Uninstall operation error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		Self.Complete();
		return;
	}

	FDebugLog::Log(L"Mods: Uninstall operation completed successfully.");

	Self.UpdateStateAfterRequestCompletion();
}

bool FMods::ValidatePreconditions()
{
	if (FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()) == nullptr)
	{
		FDebugLog::LogError(L"Mods: Validation failed. Current player is invalid, no user logged in.");
		return false;
	}
	if (Command)
	{
		FDebugLog::LogWarning(L"Mods: Validation failed. Previous request is in progress.");
		return false;
	}
	if (bIsQueryInProgress)
	{
		FDebugLog::LogWarning(L"Mods: Validation failed. Mods query is in progress.");
		return false;
	}
	return true;
}

void FMods::UpdateMod(FModId ModId)
{
	if (ValidatePreconditions() == false)
	{
		return;
	}

	Command = std::make_unique<FRequest>(FRequest{ std::move(ModId), ERequestType::Update });

	EOS_Mods_UpdateModOptions Opt = {};
	Opt.ApiVersion = EOS_MODS_UPDATEMOD_API_LATEST;
	Opt.LocalUserId = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser())->GetUserID();
	Opt.Mod = &Command->ModIdentifier();

	EOS_Mods_UpdateMod(ModsHandle, &Opt, this, OnUpdateComplete);
}

void FMods::OnUpdateComplete(const EOS_Mods_UpdateModCallbackInfo* Data)
{
	if (!Data)
	{
		FDebugLog::LogError(L"Mods: Mod Update failed.");
		return;
	}

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	FMods& Self = *static_cast<FMods*>(Data->ClientData);

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogWarning(L"Mods: Update operation error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		Self.Complete();
		return;
	}

	FDebugLog::Log(L"Mods: Update operation completed successfully.");

	Self.UpdateStateAfterRequestCompletion();
}

void FMods::EnumerateMods(EModsQueryType Type)
{
	if (ValidatePreconditions() == false)
	{
		return;
	}
	ModDetailsCache.clear();
	bIsQueryInProgress = true;
	QueryType = Type;
	FetchMods(EOS_EModEnumerationType::EOS_MET_INSTALLED);
}

void FMods::FetchMods(EOS_EModEnumerationType Type)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Mods - FetchMods: Current player is invalid!");
		return;
	}

	EOS_Mods_EnumerateModsOptions Options = {};
	Options.ApiVersion = EOS_MODS_ENUMERATEMODS_API_LATEST;
	Options.LocalUserId = Player->GetUserID();
	Options.Type = Type;

	EOS_Mods_EnumerateMods(ModsHandle, &Options, this, OnEnumerateModsComplete);
}

void EOS_CALL FMods::OnEnumerateModsComplete(const EOS_Mods_EnumerateModsCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		FMods& Mods = *static_cast<FMods*>(Data->ClientData);
		
		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			switch (Data->Type)
			{
				case EOS_EModEnumerationType::EOS_MET_INSTALLED:
					FDebugLog::LogError(L"Mods: Enumerate installed mods error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
					break;
				case EOS_EModEnumerationType::EOS_MET_ALL_AVAILABLE:
					FDebugLog::LogError(L"Mods: Enumerate available mods error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
					break;
				default:
					FDebugLog::LogError(L"Mods: Unknown Type {%d} was specified for mod enumeration.", static_cast<int>(Data->Type));
			}
			Mods.Complete();
			return;
		}

		EOS_Mods_CopyModInfoOptions CopyAsOptions = {};
		CopyAsOptions.ApiVersion = EOS_MODS_COPYMODINFO_API_LATEST;
		CopyAsOptions.LocalUserId = Data->LocalUserId;
		CopyAsOptions.Type = Data->Type;
		EOS_Mods_HModsInfo ModsInfoHandle;

		if (EOS_Mods_CopyModInfo(Mods.ModsHandle, &CopyAsOptions, &ModsInfoHandle) != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Mods: Enumerate Mods failed when copying from ModsInfo with error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
			Mods.Complete();
		}
		else
		{
			FDebugLog::Log(L"Mods: Mod Enumeration succeeded.");
			Mods.UpdateDetailsFromModsInfo(ModsInfoHandle, Data->Type, Data->LocalUserId);
		}
	}
	else
	{
		FDebugLog::LogError(L"Mods: Mod Enumeration failed.");
	}
}

void FMods::OnLoggedOut(FEpicAccountId UserId)
{
	ModDetailsCache.clear();
	SetIsDirty(true);
}

void FMods::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		OnLoggedOut(Event.GetUserId());
	}
}

void FMods::Complete()
{
	SetIsDirty(true);
	bIsQueryInProgress = false;
	Command.reset();
}

void FMods::UpdateDetailsFromModsInfo(EOS_Mods_HModsInfo ModsInfo, EOS_EModEnumerationType Type, EOS_EpicAccountId UserId)
{
	if (FPlayerManager::Get().GetPlayer(UserId) == nullptr)
	{
		// User is no longer logged in
		Complete();
		return;
	}

	if (ModsInfo && ModsInfo->Mods)
	{
		for (auto Index = 0; Index < ModsInfo->ModsCount; ++Index)
		{
			FModDetail ModDetail(ModsInfo, Index);

			switch (Type)
			{
				case EOS_EModEnumerationType::EOS_MET_INSTALLED:
				{
					auto Found = ModDetailsCache.find(ModDetail.Id);
					ModDetail.State = EModState::Installed;

					if (Found != ModDetailsCache.end())
					{
						Found->second = ModDetail;
					}
					else
					{
						ModDetailsCache.emplace(ModDetail.Id, ModDetail);
					}
				}
				break;
				case EOS_EModEnumerationType::EOS_MET_ALL_AVAILABLE:
				{
					auto Found = ModDetailsCache.find(ModDetail.Id);
					if (Found == ModDetailsCache.end())
					{
						ModDetail.State = EModState::Available;
						ModDetailsCache.emplace(ModDetail.Id, ModDetail);
					}
				}
				break;
			}
		}
		if (QueryType == EModsQueryType::All && Type == EOS_EModEnumerationType::EOS_MET_INSTALLED)
		{
			FetchMods(EOS_EModEnumerationType::EOS_MET_ALL_AVAILABLE);
		}
		else
		{
			Complete();
		}
	}
}

void FMods::AddTestData()
{
	const int ModsCount = 20;

	const char* NamespaceIds[ModsCount] =
	{
		"2216ecfe2aac4a7798b07eacea14ed01", "2216ecfe2aac4a7798b07eacea14ed02", "2216ecfe2aac4a7798b07eacea14ed03", "2216ecfe2aac4a7798b07eacea14ed04",
		"2216ecfe2aac4a7798b07eacea14ed05", "2216ecfe2aac4a7798b07eacea14ed06", "2216ecfe2aac4a7798b07eacea14ed07", "2216ecfe2aac4a7798b07eacea14ed08",
		"2216ecfe2aac4a7798b07eacea14ed09", "2216ecfe2aac4a7798b07eacea14ed10", "2216ecfe2aac4a7798b07eacea14ed11", "2216ecfe2aac4a7798b07eacea14ed12",
		"2216ecfe2aac4a7798b07eacea14ed13", "2216ecfe2aac4a7798b07eacea14ed14", "2216ecfe2aac4a7798b07eacea14ed15", "2216ecfe2aac4a7798b07eacea14ed16",
		"2216ecfe2aac4a7798b07eacea14ed17", "2216ecfe2aac4a7798b07eacea14ed18", "2216ecfe2aac4a7798b07eacea14ed19", "2216ecfe2aac4a7798b07eacea14ed20"
	};

	const char* ItemIds[ModsCount] =
	{
		"037d913458f04e2887f8d5a884d5f901", "037d913458f04e2887f8d5a884d5f902", "037d913458f04e2887f8d5a884d5f903", "037d913458f04e2887f8d5a884d5f904",
		"037d913458f04e2887f8d5a884d5f905", "037d913458f04e2887f8d5a884d5f906", "037d913458f04e2887f8d5a884d5f907", "037d913458f04e2887f8d5a884d5f908",
		"037d913458f04e2887f8d5a884d5f909", "037d913458f04e2887f8d5a884d5f910", "037d913458f04e2887f8d5a884d5f911", "037d913458f04e2887f8d5a884d5f912",
		"037d913458f04e2887f8d5a884d5f913", "037d913458f04e2887f8d5a884d5f914", "037d913458f04e2887f8d5a884d5f915", "037d913458f04e2887f8d5a884d5f916",
		"037d913458f04e2887f8d5a884d5f917", "037d913458f04e2887f8d5a884d5f918", "037d913458f04e2887f8d5a884d5f919", "037d913458f04e2887f8d5a884d5f920"
	};

	const char* ArtifactIds[ModsCount] =
	{
		"5bc0de68c52549649ac0a695e1dd6901", "5bc0de68c52549649ac0a695e1dd6902", "5bc0de68c52549649ac0a695e1dd6903", "5bc0de68c52549649ac0a695e1dd6904",
		"5bc0de68c52549649ac0a695e1dd6905", "5bc0de68c52549649ac0a695e1dd6906", "5bc0de68c52549649ac0a695e1dd6907", "5bc0de68c52549649ac0a695e1dd6908",
		"5bc0de68c52549649ac0a695e1dd6909", "5bc0de68c52549649ac0a695e1dd6910", "5bc0de68c52549649ac0a695e1dd6911", "5bc0de68c52549649ac0a695e1dd6912",
		"5bc0de68c52549649ac0a695e1dd6913", "5bc0de68c52549649ac0a695e1dd6914", "5bc0de68c52549649ac0a695e1dd6915", "5bc0de68c52549649ac0a695e1dd6916",
		"5bc0de68c52549649ac0a695e1dd6917", "5bc0de68c52549649ac0a695e1dd6918", "5bc0de68c52549649ac0a695e1dd6919", "5bc0de68c52549649ac0a695e1dd6920"
	};

	const char* Titles[ModsCount] =
	{
		"Mod 1",	"Mod 2",	"Mod 3",	"Mod 4",
		"Mod 5",	"Mod 6",	"Mod 7",	"Mod 8",
		"Mod 9",	"Mod 10",	"Mod 11",	"Mod 12",
		"Mod 13",	"Mod 14",	"Mod 15",	"Mod 16",
		"Mod 17",	"Mod 18",	"Mod 19",	"Mod 20"
	};

	const char* Versions[ModsCount] =
	{
		"1.0.0",	"1.0.0",	"1.0.0",	"1.0.0",
		"1.0.1",	"1.0.0",	"1.0.0",	"1.0.0",
		"1.0.0",	"1.2.0",	"3.1.0",	"1.0.0",
		"1.0.0",	"1.0.0",	"1.0.0",	"1.0.0",
		"1.0.0",	"2.0.0",	"1.0.0",	"1.0.0"
	};

	ModDetailsCache.clear();

	EOS_Mods_ModInfo* ModsInfo = new EOS_Mods_ModInfo{ 0 };
	ModsInfo->ApiVersion = EOS_MODS_MODINFO_API_LATEST;
	ModsInfo->ModsCount = ModsCount;
	EOS_Mod_Identifier* Mods = new EOS_Mod_Identifier[ModsInfo->ModsCount];
	for (int32_t Index = 0; Index < ModsInfo->ModsCount; ++Index)
	{
		EOS_Mod_Identifier& Mod = Mods[Index];
		Mod.ApiVersion = EOS_MOD_IDENTIFIER_API_LATEST;
		Mod.NamespaceId = NamespaceIds[Index];
		Mod.ItemId = ItemIds[Index];
		Mod.ArtifactId = ArtifactIds[Index];
		Mod.Title = Titles[Index];
		Mod.Version = Versions[Index];
	}
	ModsInfo->Mods = Mods;

	for (auto Index = 0; Index < ModsCount; ++Index)
	{
		FModDetail ModDetail(ModsInfo, Index);
		ModDetail.State = Index % 2 == 0 ? EModState::Installed : EModState::Available;
		ModDetailsCache.emplace(ModDetail.Id, ModDetail);
	}

	Complete();
}

```

`EAC_SDK/Samples/Mods/Source/Mods.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_sdk.h>
#include <eos_mods.h>
#include <unordered_set>

using EOS_Mods_HModsInfo = EOS_Mods_ModInfo*;

/**
* Mod Identifier class.
*/
struct FModId
{
	/** Product namespace id in which this mod item exists */
	std::string NamespaceId;
	/* Item id of the Mod */
	std::string ItemId;
	/* Artifact id of the Mod */
	std::string ArtifactId;

	size_t Hash() const
	{
		size_t Seed = 0;
		Seed = std::hash<std::string>{}(NamespaceId);
		Seed ^= std::hash<std::string>{}(ArtifactId);
		return Seed ^ std::hash<std::string>{}(ItemId);
	}

	friend bool operator<(const FModId& Lhs, const FModId& Rhs)
	{
		return Lhs.Hash() < Rhs.Hash();
	}
};

/**
 * States in which the Mod can be in.
*/
enum class EModState
{
	Unknown = 0,
	Installed = 1,
	Available = 2,
};

/**
* Action Types that can be applied to Mods.
*/
enum class ERequestType
{
	Install = 0,
	Uninstall = 1,
	Update = 2,
};

/**
* Query Types that can be applied to Mods.
*/
enum class EModsQueryType
{
	Installed = 0,
	All = 1,
};

/**
* Contains basic details of the Mod.
*/
struct FModDetail
{
	/** Unique Identifier of Mod*/
	FModId Id;
	/** Represents Mod item title. */
	std::string Title;
	/** Represents Mod item version. */
	std::string Version;
	/** Shows Mod is installed or available*/
	EModState State = EModState::Unknown;

	FModDetail() = default;

	FModDetail(FModId Id);

	FModDetail(EOS_Mods_ModInfo* ModsInfo, int Index);
	
	/** Extracts Mod enumeration type from SDK ModsInfo object */
	EModState GetState(EOS_Mods_ModInfo* ModsInfo);
};

/**
* Manages Mods
*/
class FMods
{
public:
	/**
	* Constructor
	*/
	FMods() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMods(FMods const&) = delete;
	FMods& operator=(FMods const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMods();

	/**
	* Initialization
	*/
	void Init();

	/**
	* Update
	*/
	void Update();

	/**
	* Called when User is Loged out. 
	*/
	void OnLoggedOut(FEpicAccountId UserId);

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);
	
	/**
	* Sets RemoveAfterExit flag (When this flag is true then Mods will get uninstalled after the game exits).
	*/
	void SetRemoveAfterExit(bool DefaultRemoveAfterExit);
	
	/**
	* Installs mod.
	*/
	void InstallMod(FModId ModId);
	void InstallMod(FModId ModId, bool bRemoveAfterExit);
	static void EOS_CALL OnInstallComplete(const EOS_Mods_InstallModCallbackInfo* Data);
	
	/**
	* Uninstalls Mod.
	*/
	void UnInstallMod(FModId ModId);
	static void EOS_CALL OnUninstallComplete(const EOS_Mods_UninstallModCallbackInfo* Data);
	
	/**
	* Updates Mod.
	*/
	void UpdateMod(FModId ModId);
	static void EOS_CALL OnUpdateComplete(const EOS_Mods_UpdateModCallbackInfo* Data);

	/**
	* Enumerates Mods.
	* @param Type Shows to enumerate all available or only installed mods.
	*/
	void EnumerateMods(EModsQueryType Type);
	static void EOS_CALL OnEnumerateModsComplete(const EOS_Mods_EnumerateModsCallbackInfo* Data);

	/**
	* Shows whether Mods cached data are stale or not.
	*/
	bool IsDirty() const
	{
		return bIsModDetailsChanged;
	}

	/**
	* Sets whether Mods cached data is dirty or not.
	*/
	void SetIsDirty(bool IsDirty)
	{
		bIsModDetailsChanged = IsDirty;
	}

	/**
	* Returns Mods cached data.
	*/
	const std::map<FModId, FModDetail>& GetModDetails() const
	{
		return ModDetailsCache;
	}

	/** Adds data for testing dialog */
	void AddTestData();

private:
	
	/**
	* Completes current operation.
	*/
	void Complete();

	/**
	* Validates preconditions before each operation.
	*/
	bool ValidatePreconditions();

	/**
	* Extracts data from returned ModsInfo and Updates Mods cache data.
	*/
	void UpdateDetailsFromModsInfo(EOS_Mods_HModsInfo ModsInfo, EOS_EModEnumerationType Type, EOS_EpicAccountId UserId);

	/**
	* Queries Mods info from SDK.
	*/
	void FetchMods(EOS_EModEnumerationType Type);

	/**
	* Updates internal state after successful request.
	*/
	void UpdateStateAfterRequestCompletion();

	/**
	* Contains Request information.
	*/
	struct FRequest
	{
		/** Identity of the Mod. */
		FModId ModId;

		/** Request Type. [ install | uninstall | update ] */
		ERequestType Type;
		
		/** Passed to SDK API as parameter. */
		EOS_Mod_Identifier Identifier;

		const EOS_Mod_Identifier& ModIdentifier()
		{
			Identifier.ApiVersion = EOS_MOD_IDENTIFIER_API_LATEST;
			Identifier.NamespaceId = ModId.NamespaceId.c_str();
			Identifier.ArtifactId = ModId.ArtifactId.c_str();
			Identifier.ItemId = ModId.ItemId.c_str();
			Identifier.Title = nullptr;
			Identifier.Version = nullptr;
			return Identifier;
		}
	};
	
private:
	
	/** Handle to EOS SDK Mods system */
	EOS_HMods ModsHandle;
	
	/** Command to install, uninstall or update Mod. */
	std::unique_ptr<FRequest> Command;
	
	/** Shows whether to eumerate only installed or all Mods. */
	EModsQueryType QueryType;
	
	/** Showes whether the last Query is in progress or not. */
	bool bIsQueryInProgress = false;
	
	/** Stores cached result of last enumeration. */
	std::map<FModId, FModDetail> ModDetailsCache;

	/** True whenever ModDetails cache changes. */
	bool bIsModDetailsChanged = false;

	/** When true Mods will be removed after game is closed. */
	bool bDefaultRemoveAfterExit = false;
};

```

`EAC_SDK/Samples/Mods/Source/ModsDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "ModsDialog.h"

#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "Mods.h"
#include "TextEditor.h"
#include "TableView.h"

const float HeaderLabelHeight = 20.0f;

FModsDialog::FModsDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	HeaderLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Vector2(500.0f, HeaderLabelHeight),
		Layer - 1,
		std::wstring(L"Mods: "),
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	HeaderLabel->SetFont(DialogNormalFont);

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/texteditor.dds");

	EnumerateAllModsBtn = std::make_shared<FButtonWidget>(
		Vector2(Position.x, Position.y),
		Vector2(200.f, 30.f),
		Layer - 1,
		L"Enumerate All Mods",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		assets::DefaultButtonColors[static_cast<size_t>(FButtonWidget::EButtonVisualState::Idle)]);
	EnumerateAllModsBtn->SetBackgroundColors(assets::DefaultButtonColors);

	EnumerateInstalledModsBtn = std::make_shared<FButtonWidget>(
		Vector2(Position.x, Position.y),
		Vector2(200.f, 30.f),
		Layer - 1,
		L"Enumerate Installed Mods",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		assets::DefaultButtonColors[static_cast<size_t>(FButtonWidget::EButtonVisualState::Idle)]);
	EnumerateInstalledModsBtn->SetBackgroundColors(assets::DefaultButtonColors);
}

void FModsDialog::Update()
{
	FDialog::Update();
}

void FModsDialog::Create()
{
	if (HeaderLabel) HeaderLabel->Create();
	if (BackgroundImage) BackgroundImage->Create();
	if (EnumerateAllModsBtn)
	{
		EnumerateAllModsBtn->Create();
		EnumerateAllModsBtn->SetOnPressedCallback([this]()
		{
			FGame::Get().GetMods()->EnumerateMods(EModsQueryType::All);
		});
		EnumerateAllModsBtn->Hide();
	}
	if (EnumerateInstalledModsBtn)
	{
		EnumerateInstalledModsBtn->Create();
		EnumerateInstalledModsBtn->SetOnPressedCallback([this]()
		{
			FGame::Get().GetMods()->EnumerateMods(EModsQueryType::Installed);
		});
		EnumerateInstalledModsBtn->Hide();
	}

	AddWidget(HeaderLabel);
	AddWidget(BackgroundImage);
	AddWidget(EnumerateAllModsBtn);
	AddWidget(EnumerateInstalledModsBtn);
}

void FModsDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (HeaderLabel) HeaderLabel->SetPosition(Pos);
	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y + 20.f));
	if (EnumerateAllModsBtn) EnumerateAllModsBtn->SetPosition(Vector2(Pos.x + Size.x/2.f - 100.f, Pos.y + 50.f));
	if (EnumerateInstalledModsBtn) EnumerateInstalledModsBtn->SetPosition(Vector2(Pos.x + Size.x/2.f - 100.f, Pos.y + 120.f));
}

void FModsDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);
}

void FModsDialog::SetWindowSize(Vector2 WindowSize)
{
	const Vector2 DefListSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 40.0f, WindowSize.y - 200.0f);
	const Vector2 DialogSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 30.0f, WindowSize.y - 90.0f);

	if (BackgroundImage) BackgroundImage->SetSize(DialogSize);
	if (HeaderLabel) HeaderLabel->SetSize(Vector2(DialogSize.x, HeaderLabelHeight));
}

void FModsDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		OnLoggedIn(Event.GetUserId());
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		OnLoggedOut();
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		
	}
}

void FModsDialog::OnLoggedIn(FEpicAccountId UserId)
{
	if (UserId.IsValid())
	{
		CurrentUserId = UserId;
		
		if (EnumerateAllModsBtn) EnumerateAllModsBtn->Show();
		if (EnumerateInstalledModsBtn) EnumerateInstalledModsBtn->Show();
	}
}

void FModsDialog::OnLoggedOut()
{
	if (EnumerateAllModsBtn) EnumerateAllModsBtn->Hide();
	if (EnumerateInstalledModsBtn) EnumerateInstalledModsBtn->Hide();
}
```

`EAC_SDK/Samples/Mods/Source/ModsDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "TableView.h"

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;

/**
 * Mods Dialog
 */
class FModsDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FModsDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FModsDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	void SetWindowSize(Vector2 WindowSize);
	void SetWindowProportion(Vector2 InWindowProportion) { ConsoleWindowProportion = InWindowProportion; }

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/**
	 * Handle user login
	 */
	void OnLoggedIn(FEpicAccountId UserId);

	/**
	 * Handle user logout
	 */
	void OnLoggedOut();

private:
	/** Header label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Part of window that console is taking */
	Vector2 ConsoleWindowProportion;

	/** Enumerate all mods */
	std::shared_ptr<FButtonWidget> EnumerateAllModsBtn;
	/** Enumerate all Installed mods */
	std::shared_ptr<FButtonWidget> EnumerateInstalledModsBtn;

	/** Id for current user. */
	FEpicAccountId CurrentUserId;
};

```

`EAC_SDK/Samples/Mods/Source/ModsTableDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "ModsTableDialog.h"

#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "Mods.h"
#include "TextEditor.h"
#include "TableView.h"

const float HeaderLabelHeight = 20.0f;

FModsTableDialog::FModsTableDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	HeaderLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Size,
		Layer - 1,
		std::wstring(L"Mods: "),
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	HeaderLabel->SetFont(DialogNormalFont);

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/texteditor.dds");

	Vector2 ModsTablePos = Vector2(0.0f, 0.0f);

	ModsTable = std::make_shared<FModsTableView>(
		ModsTablePos + Vector2(0.0f, HeaderLabelHeight + 25.f),
		Vector2(500, 500),
		DialogLayer - 1,
		L"All mods:",
		10.0f, //scroller width
		std::vector<FModsTableRowData>(),
		FModsTableRowData(),
		35.f/*TableViewEntryHeight*/);

	ModsTable->SetFonts(DialogSmallFont, DialogSmallFont);
}

void FModsTableDialog::Update()
{
	if (ModsTable && FGame::Get().GetMods()->IsDirty())
	{
		ModsTable->ScrollToTop();

		std::vector<FModsTableRowData> InstalledRows, OtherRows;
		const std::map<FModId, FModDetail>& Mods = FGame::Get().GetMods()->GetModDetails();

		std::for_each(Mods.begin(), Mods.end(), [&InstalledRows, &OtherRows](std::pair<FModId, FModDetail> Mod) {
			FModsTableRowData RowData = ModsTableRowDataHelpers::FromModDetail(Mod.second);
			if (RowData.bActionsAvailable[FModsTableRowData::EAction::Install])
			{
				InstalledRows.push_back(ModsTableRowDataHelpers::FromModDetail(Mod.second));
			}
			else
			{
				OtherRows.push_back(ModsTableRowDataHelpers::FromModDetail(Mod.second));
			}
		});

		OtherRows.reserve(InstalledRows.size() + OtherRows.size());
		OtherRows.insert(OtherRows.end(), InstalledRows.begin(), InstalledRows.end());
		ModsTable->RefreshData(std::move(OtherRows));

		FGame::Get().GetMods()->SetIsDirty(false);
	}

	FDialog::Update();
}

void FModsTableDialog::Create()
{
	if (HeaderLabel) HeaderLabel->Create();
	if (BackgroundImage) BackgroundImage->Create();
	if (ModsTable) ModsTable->Create();

	AddWidget(HeaderLabel);
	AddWidget(BackgroundImage);
	AddWidget(ModsTable);
}

void FModsTableDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (HeaderLabel) HeaderLabel->SetPosition(Pos);
	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y + 20.f));
	if (ModsTable) ModsTable->SetPosition(Vector2(Position.x, Position.y + 20.f));
}

void FModsTableDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);
}

void FModsTableDialog::SetWindowSize(Vector2 WindowSize)
{
	if (BackgroundImage) BackgroundImage->SetSize(Vector2(WindowSize.x * ConsoleWindowProportion.x, WindowSize.y * 0.455f));
	if (HeaderLabel) HeaderLabel->SetSize(Vector2(WindowSize.x * ConsoleWindowProportion.x, HeaderLabelHeight));
	if (ModsTable) ModsTable->SetSize(Vector2(WindowSize.x * ConsoleWindowProportion.x, WindowSize.y * 0.455f));
}

void FModsTableDialog::OnGameEvent(const FGameEvent& Event)
{
}

```

`EAC_SDK/Samples/Mods/Source/ModsTableDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "TableView.h"

/**
* Forward declarations
*/
class FGameEvent;
class FSpriteWidget;

/**
* Mods Table Dialog
*/
class FModsTableDialog : public FDialog
{
public:
	/**
	* Constructor
	*/
	FModsTableDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	* Destructor
	*/
	virtual ~FModsTableDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	void SetWindowSize(Vector2 WindowSize);
	void SetWindowProportion(Vector2 InWindowProportion) { ConsoleWindowProportion = InWindowProportion; }

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

private:
	/** Header label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Part of window that console is taking */
	Vector2 ConsoleWindowProportion;

	/** Table view with the list of mods. */
	std::shared_ptr<FModsTableView> ModsTable;
};

```

`EAC_SDK/Samples/Mods/Source/ModsTableRowView.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "ModsTableRowView.h"
#include "TextLabel.h"
#include "Button.h"
#include "TableView.h"

#include "Mods.h"
#include "Game.h"

namespace ModsTableRowDataHelpers
{
	std::wstring FormatString(const std::string& InStr)
	{
		std::string Str = InStr;
		if (!Str.size())
		{
			Str = "-";
		}

		std::wstring WStr = FStringUtils::Widen(Str);

#ifdef DXTK
		if (WStr.size() > 16)
		{
			WStr.insert(Str.size() / 2, L"\n");
		}
#endif
		return WStr;
	}

	std::string ToString(const std::wstring& InStr)
	{
		const std::string NewLine("\n");
		std::string Str = FStringUtils::Narrow(InStr);
		size_t StartPos = Str.find(NewLine);
		if (StartPos != std::string::npos)
		{
			Str.replace(StartPos, NewLine.length(), "");
		}
		return Str;
	}

	FModsTableRowData FromModDetail(const FModDetail& ModDetail)
	{
		FModsTableRowData Tmp;
		Tmp.Values[FModsTableRowData::EValue::Title] = FormatString(ModDetail.Title);
		Tmp.Values[FModsTableRowData::EValue::Version] = FormatString(ModDetail.Version);
		Tmp.Values[FModsTableRowData::EValue::NamespaceId] = FormatString(ModDetail.Id.NamespaceId);
		Tmp.Values[FModsTableRowData::EValue::ItemId] = FormatString(ModDetail.Id.ItemId);
		Tmp.Values[FModsTableRowData::EValue::ArtifactId] = FormatString(ModDetail.Id.ArtifactId);
		Tmp.bActionsAvailable[FModsTableRowData::EAction::Install] = ModDetail.State == EModState::Available;
		Tmp.bActionsAvailable[FModsTableRowData::EAction::Update] = ModDetail.State == EModState::Installed;
		Tmp.bActionsAvailable[FModsTableRowData::EAction::Uninstall] = ModDetail.State == EModState::Installed;
		return Tmp;
	}
}

FModsTableRowView::FModsTableRowView(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& InAssetFile, const FModsTableRowData& InData, FColor InBackgroundColor, FColor InTextColor)
	: FDialog(Pos, Size, Layer), Data(InData), AssetFile(InAssetFile), BackgroundColor(InBackgroundColor), TextColor(InTextColor)
{
	static_assert(std::tuple_size<FModsTableRowView::FRowWidgets>::value == std::tuple_size<FModsTableRowData::FValues>::value, "FRowWidgets must be the same size as the number of values.");

	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	// create text view widgets
	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		std::shared_ptr<FTextViewWidget> NextTextView = std::make_shared<FTextViewWidget>(
			Vector2(Pos.x + LabelSize.x * i, Pos.y),
			LabelSize,
			Layer - 1,
			Data.Values[i],
			AssetFile,
			Font,
			BackgroundColor,
			TextColor);

		// No scroller required
		NextTextView->DisableScroller();

		RowWidgets[i] = NextTextView;
		AddWidget(NextTextView);
	}

	// Offset Title a little from LHS
	RowWidgets[0]->SetBorderOffsets(Vector2(5.f, 0.f));

	//create action buttons
	std::array<std::wstring, FModsTableRowData::EAction::Count> actionLabels;
	std::array<FColor, FModsTableRowData::EAction::Count> actionColors;

	actionLabels[FModsTableRowData::EAction::Install] = L"INSTALL";
	actionColors[FModsTableRowData::EAction::Install] = Color::DarkGreen;
	actionLabels[FModsTableRowData::EAction::Update] = L"UPDATE";
	actionColors[FModsTableRowData::EAction::Update ] = Color::DarkBlue;
	actionLabels[FModsTableRowData::EAction::Uninstall] = L"UNINSTALL";
	actionColors[FModsTableRowData::EAction::Uninstall] = Color::DarkRed;

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		std::shared_ptr<FButtonWidget> NextButton = std::make_shared<FButtonWidget>(
			Vector2(Pos.x + Data.Values.size() * LabelSize.x + Ix * ActionSize.x, Pos.y),
			ActionSize,
			Layer - 1,
			actionLabels[Ix],
			assets::DefaultButtonAssets,
			nullptr,
			actionColors[Ix]);
		NextButton->SetOnPressedCallback([this, Ix]() { this->OnPressed(Ix); });
		if (!Data.bActionsAvailable[Ix])
		{
			NextButton->Disable();
		}
		ActionButtons[Ix] = NextButton;
		AddWidget(NextButton);
	}
}

void FModsTableRowView::SetFocused(bool bValue)
{
	FDialog::SetFocused(bValue);

	if (bValue)
	{
		SetBorderColor(Color::UIDarkGrey);
	}
	else
	{
		ClearBorderColor();
	}
}

void FModsTableRowView::SetPosition(Vector2 Pos)
{
	FDialog::SetPosition(Pos);

	ReadjustLayout();
}

void FModsTableRowView::SetSize(Vector2 NewSize)
{
	FDialog::SetSize(NewSize);

	ReadjustLayout();
}

void FModsTableRowView::Enable()
{
	FDialog::Enable();

	//Disable action buttons
	for (size_t Ix = 0; Ix < FModsTableRowData::EAction::Count; ++Ix)
	{
		if (!Data.bActionsAvailable[Ix] && ActionButtons.size() > Ix)
		{
			std::shared_ptr<FButtonWidget> ActionButton = ActionButtons[Ix];
			if (ActionButton)
			{
				ActionButton->Disable();
			}
		}
	}
}

void FModsTableRowView::SetOnActionPressedCallback(std::function<void(size_t)> Callback)
{
	ActionPressedCallback = Callback;
}

void FModsTableRowView::HideActions()
{
	for (auto ActionButton : ActionButtons)
	{
		if (ActionButton)
		{
			ActionButton->Hide();
		}
	}
}

void FModsTableRowView::SetData(const FModsTableRowData& InData)
{
	Data = InData;

	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		std::wstring DataString = (i < InData.Values.size()) ? InData.Values[i] : L"-";
		RowWidgets[i]->Clear();
		RowWidgets[i]->AddLine(DataString);
	}

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		if (Data.bActionsAvailable[Ix])
		{
			ActionButtons[Ix]->Enable();
		}
		else
		{
			ActionButtons[Ix]->Disable();
		}
	}

	ReadjustLayout();
}

void FModsTableRowView::SetFont(FontPtr InFont)
{
	Font = InFont;

	for (auto Widget : RowWidgets)
	{
		Widget->SetFont(InFont);
	}

	for (auto Button : ActionButtons)
	{
		Button->SetFont(InFont);
	}
}

void FModsTableRowView::CalcSizes(Vector2& LabelSize, Vector2& ActionSize)
{
	// Fit the action buttons into "2" columns.
	float ActionSizeRatio = 2.3f / FModsTableRowData::EAction::Count;
	float ColumnRatio = Data.Values.size() + ActionSizeRatio * FModsTableRowData::EAction::Count;
	LabelSize = Vector2(Size.x / ColumnRatio, Size.y);
	ActionSize = Vector2(LabelSize.x * ActionSizeRatio, Size.y);
}

void FModsTableRowView::ReadjustLayout()
{
	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//resize labels
	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		RowWidgets[i]->SetPosition(Vector2(Position.x + LabelSize.x * i, Position.y));
		RowWidgets[i]->SetSize(LabelSize);
	}

	for (size_t i = 0; i < ActionButtons.size(); ++i)
	{
		ActionButtons[i]->SetPosition(Vector2(Position.x + Data.Values.size() * LabelSize.x + i * ActionSize.x, Position.y));
		ActionButtons[i]->SetSize(ActionSize);
	}
}

void FModsTableRowView::OnPressed(size_t ActionIndex)
{
	if (ActionPressedCallback)
	{
		ActionPressedCallback(ActionIndex);
	}

	FModId ModId;
	ModId.NamespaceId = ModsTableRowDataHelpers::ToString(Data.Values[FModsTableRowData::EValue::NamespaceId]);
	ModId.ItemId = ModsTableRowDataHelpers::ToString(Data.Values[FModsTableRowData::EValue::ItemId]);
	ModId.ArtifactId = ModsTableRowDataHelpers::ToString(Data.Values[FModsTableRowData::EValue::ArtifactId]);

	if (ActionIndex == FModsTableRowData::EAction::Install)
	{
		FGame::Get().GetMods()->InstallMod(ModId);
	}
	else if (ActionIndex == FModsTableRowData::EAction::Update)
	{
		FGame::Get().GetMods()->UpdateMod(ModId);
	}
	else if (ActionIndex == FModsTableRowData::EAction::Uninstall)
	{
		FGame::Get().GetMods()->UnInstallMod(ModId);
	}
}

template<>
std::shared_ptr<FModsTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FModsTableRowData& Data)
{
	return std::make_shared<FModsTableRowView>(Pos, Size, Layer, L"", Data, Color::DarkGray, Color::White);
}

template <>
void FTableView<FModsTableRowData, FModsTableRowView>::OnEntrySelected(size_t Index)
{
}
```

`EAC_SDK/Samples/Mods/Source/ModsTableRowView.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Widget.h"
#include "Font.h"
#include "ListView.h"
#include "Dialog.h"

class FTextViewWidget;
class FButtonWidget;
struct FModsTableRowData;
struct FModDetail;

/**
* Helper functions. Converting data to show on the table view.
*/
namespace ModsTableRowDataHelpers
{
	/** Adding newLine to InStr and to be able to show long lines. */
	std::wstring FormatString(const std::string& InStr);
	
	/** Casts back String which might contain newLine character. */
	std::string ToString(const std::wstring& InStr);
	
	/** Converts FModDetail to Show as Table rows. */
	FModsTableRowData FromModDetail(const FModDetail& ModDetail);
}

/** Holds single Mod related data and actions that can be applied to that Mod. */
struct FModsTableRowData
{
	/** Mod Data. */
	struct EValue final
	{
		enum EData : int
		{
			Title = 0,
			Version,
			NamespaceId,
			ItemId,
			ArtifactId,
			Count
		};
		EValue() = delete;
	};

	/** Actions that can be applied to the Mod. */
	struct EAction final
	{
		enum EData : int
		{
			Install = 0,
			Update,
			Uninstall,
			Count
		};
		EAction() = delete;
	};

	using FValues = std::array<std::wstring, EValue::Count>;
	using FActionsAvailable = std::array<bool, EAction::Count>;
	FValues Values;
	FActionsAvailable bActionsAvailable;

	bool operator!=(const FModsTableRowData& Other) const
	{
		return bActionsAvailable != Other.bActionsAvailable || Values != Other.Values;
	}

	/** default ctor */
	FModsTableRowData()
	{
		bActionsAvailable.fill(false);
		Values[EValue::Title] = L"Title";
		Values[EValue::Version] = L"Version";
		Values[EValue::NamespaceId] = L"Namespace Id";
		Values[EValue::ItemId] = L"Item Id";
		Values[EValue::ArtifactId] = L"Artifact Id";
	}
};

/** Class for representing view of the Mods data in a row. */
class FModsTableRowView : public FDialog
{
public:
	FModsTableRowView(Vector2 Pos,
		Vector2 Size,
		UILayer Layer,
		const std::wstring& AssetFile,
		const FModsTableRowData& InData,
		FColor BackgroundColor,
		FColor TextColor);

	void SetFocused(bool bValue) override;

	/** Set Position */
	void SetPosition(Vector2 Pos) override;

	/** Set Size */
	void SetSize(Vector2 NewSize) override;
	
	/* Enables Dialog and Updates Action button states.*/
	void Enable() override;

	void SetOnActionPressedCallback(std::function<void(size_t)> Callback);
	
	/** Hides Actions. */
	void HideActions();

	/** Sets row data to be displayed. */
	void SetData(const FModsTableRowData& InData);
	
	/** Sets Font to all Row elements*/
	void SetFont(FontPtr InFont);

protected:

	/** Calculates Label and Action sizes.*/
	void CalcSizes(Vector2& LabelSize, Vector2& ActionSize);
	
	/** Refreshes Layout */
	void ReadjustLayout();
	
	/** Calls Action Callback */
	void OnPressed(size_t ActionIndex);

	/** Row data that to which action will be applied */
	FModsTableRowData Data;

	using FRowWidgets = std::array<std::shared_ptr<FTextViewWidget>, FModsTableRowData::EValue::Count>;
	/** Row widgets to show data of the Mod. */
	FRowWidgets RowWidgets;
	using FActionButtons = std::array<std::shared_ptr<FButtonWidget>, FModsTableRowData::EAction::Count>;
	/** Actions available for the Mod. */
	FActionButtons ActionButtons;
	std::wstring AssetFile;
	FColor BackgroundColor;
	FColor TextColor;
	FontPtr Font;

	std::function<void(size_t)> ActionPressedCallback;
};

template<>
std::shared_ptr<FModsTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FModsTableRowData& Data);

#include "TableView.h"

template <>
void FTableView<FModsTableRowData, FModsTableRowView>::OnEntrySelected(size_t Index);
```

`EAC_SDK/Samples/Mods/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry (found on the dev portal) */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions (found on the dev portal) */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Mods";

	/** Encryption key. It must match the one you are using on Dev Portal when uploading files. 64 hex characters. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/Mods/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/Mods/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/P2PNAT/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/P2PNAT/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/P2PNAT/P2PNAT.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>P2PNAT</RootNamespace>
    <ProjectGuid>{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>P2PNAT</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_P2P;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/P2PNAT/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_P2P;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/P2PNAT/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_P2P;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/P2PNAT/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_P2P;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/P2PNAT/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_P2P;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/P2PNAT/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_P2P;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/P2PNAT/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_P2P;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/P2PNAT/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_P2P;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/P2PNAT/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\P2PNAT.h" />
    <ClInclude Include="Source\P2PNATDialog.h" />
    <ClInclude Include="Source\SampleConstants.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\P2PNAT.cpp" />
    <ClCompile Include="Source\P2PNATDialog.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/P2PNAT/P2PNAT.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="Source\P2PNAT.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\P2PNATDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
	<ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="Source\P2PNAT.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\P2PNATDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/P2PNAT/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "GameEvent.h"
#include "Game.h"
#include "P2PNAT.h"

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	P2PNATComponent = std::make_unique<FP2PNAT>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
}

void FGame::Update()
{
	P2PNATComponent->Update();

	FBaseGame::Update();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);

	P2PNATComponent->OnGameEvent(Event);
}

const std::unique_ptr<FP2PNAT>& FGame::GetP2PNAT()
{
	return P2PNATComponent;
}

```

`EAC_SDK/Samples/P2PNAT/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FP2PNAT;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	 * Getter for P2PNAT component.
	 */
	const std::unique_ptr<FP2PNAT>& GetP2PNAT();

protected:
	/** Peer to peer NAT component */
	std::unique_ptr<FP2PNAT> P2PNATComponent;

	/** Timestamp to know when shutdown was triggered */
	double ShutdownTriggeredTimestamp = 0.0;
};


```

`EAC_SDK/Samples/P2PNAT/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/P2PNAT/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "FriendsDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "P2PNATDialog.h"
#include "Utils/Utils.h"
#include "GUI/Button.h"
#include "PopupDialog.h"

const char* NATDocsURL = "";

const Vector2 ConsoleDialogSizeProportion = Vector2(0.68f, 0.35f);
const float P2PDialogPositionY = 140.0f;

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreateFriendsDialog();
	CreateP2PNATDialog();
	CreateNATDocsButton();

	FBaseMenu::Create();

	AuthDialogs->SetSingleUserOnly(true);
}

void FMenu::Release()
{
	NATDocsButton->Release();

	FBaseMenu::Release();
}

void FMenu::Update()
{
	NATDocsButton->Update();

	FBaseMenu::Update();
}

void FMenu::Render(FSpriteBatchPtr& Batch)
{
	if (NATDocsButton)
	{
		NATDocsButton->Render(Batch);
	}

	FBaseMenu::Render(Batch);
}

#ifdef _DEBUG
void FMenu::DebugRender()
{
	if (NATDocsButton)
	{
		NATDocsButton->DebugRender();
	}

	FBaseMenu::DebugRender();
}
#endif

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * ConsoleDialogSizeProportion.x, WindowSize.y * ConsoleDialogSizeProportion.y);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (P2PNATDialog)
		{
			Vector2 P2PDialogSize = Vector2(ConsoleWidgetSize.x, WindowSize.y - ConsoleDialog->GetSize().y - P2PDialogPositionY - 10.0f);
			P2PNATDialog->SetSize(P2PDialogSize);

			Vector2 P2PDialogPos = Vector2(ConsoleWidgetPos.x,
				ConsoleWidgetPos.y - P2PDialogSize.y - 10.f);
			P2PNATDialog->SetPosition(P2PDialogPos);
		}

		if (FriendsDialog)
		{
			Vector2 FriendsDialogSize = Vector2(WindowSize.x - ConsoleDialog->GetSize().x - 30.f,
				P2PNATDialog->GetSize().y + ConsoleDialog->GetSize().y + 10.f);
			FriendsDialog->SetSize(FriendsDialogSize);

			Vector2 FriendDialogPos = Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
				P2PDialogPositionY - 10.0f);
			FriendsDialog->SetPosition(FriendDialogPos);
		}
	}

	if (NATDocsButton)
	{
		NATDocsButton->SetSize(Vector2(150.0f, 35.0f));

		if (FriendsDialog)
		{
			NATDocsButton->SetPosition(FriendsDialog->GetPosition() + Vector2(FriendsDialog->GetSize().x - NATDocsButton->GetSize().x, -70.f));
		}
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::CreateP2PNATDialog()
{
	const float FX = 100.0f;
	const float FY = P2PDialogPositionY;
	const float Width = 300.0f;
	const float Height = 300.0f;

	P2PNATDialog = std::make_shared<FP2PNATDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont(),
		LargeFont->GetFont());

	P2PNATDialog->SetBorderColor(Color::UIBorderGrey);

	P2PNATDialog->Create();

	AddDialog(P2PNATDialog);
}

void FMenu::CreateNATDocsButton()
{
	Vector2 NATDocsButtonSize = Vector2(150.0f, 35.0f);

	NATDocsButton = std::make_shared<FButtonWidget>(
		Vector2(800.0f, 100.0f),
		NATDocsButtonSize,
		DefaultLayer - 1,
		L"DOCUMENTATION",
		assets::LargeButtonAssets,
		NormalFont->GetFont());
	NATDocsButton->SetOnPressedCallback([]()
	{
		FUtils::OpenURL(NATDocsURL);
	});
	//NATDocsButton->SetBackgroundColors(assets::DefaultButtonColors);
	NATDocsButton->SetBorderColor(Color::UIBorderGrey);
	NATDocsButton->Create();
	NATDocsButton->Hide();
}

void FMenu::OnUIEvent(const FUIEvent& Event)
{
	if (Event.GetType() == EUIEventType::MousePressed || Event.GetType() == EUIEventType::MouseReleased)
	{
		if (NATDocsButton->CheckCollision(Event.GetVector()))
		{
			NATDocsButton->OnUIEvent(Event);
		}
	}

	FBaseMenu::OnUIEvent(Event);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	FBaseMenu::OnGameEvent(Event);
	if (P2PNATDialog) P2PNATDialog->OnGameEvent(Event);
}
```

`EAC_SDK/Samples/P2PNAT/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FUIEvent;
class FConsole;
class FGameEvent;
class FFont;
class FConsoleDialog;
class FFriendsDialog;
class FExitDialog;
class FAuthDialogs;
class FSpriteWidget;
class FTextLabelWidget;
class FButtonWidget;
class FP2PNATDialog;
class FPopupDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Render(FSpriteBatchPtr& Batch) override;
#ifdef _DEBUG
	virtual void DebugRender() override;
#endif
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	void UpdateLayout(int Width, int Height) override;

	/**
	* Event Callback
	*
	* @param Event - UI event
	*/
	void OnUIEvent(const FUIEvent& Event) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event) override;

	/** 
	 * Get P2P NAT Dialog
	 */
	std::shared_ptr<FP2PNATDialog> GetP2PNATDialog() const { return P2PNATDialog; }

private:
	/**
	 * Creates P2P NAT traversal dialog
	 */
	void CreateP2PNATDialog();

	/** 
	 * Creates docs button 
	 */
	void CreateNATDocsButton();

	/** P2P NAT Traversal dialog */
	std::shared_ptr<FP2PNATDialog> P2PNATDialog;

	/** NAT docs button */
	std::shared_ptr<FButtonWidget> NATDocsButton;
};

```

`EAC_SDK/Samples/P2PNAT/Source/P2PNAT.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "P2PNAT.h"
#include "P2PNATDialog.h"
#include "Menu.h"

#if !defined(_WIN32)
#define strncpy_s strncpy
#endif


FP2PNAT::FP2PNAT()
{
	
}

FP2PNAT::~FP2PNAT()
{

}

void FP2PNAT::Update()
{
	HandleReceivedMessages();
}

void FP2PNAT::RefreshNATType()
{
	EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());

	EOS_P2P_QueryNATTypeOptions Options = {};
	Options.ApiVersion = EOS_P2P_QUERYNATTYPE_API_LATEST;

	EOS_P2P_QueryNATType(P2PHandle, &Options, nullptr, OnRefreshNATTypeFinished);
}

EOS_ENATType FP2PNAT::GetNATType() const
{
	EOS_ENATType NATType = EOS_ENATType::EOS_NAT_Unknown;
	EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());

	EOS_P2P_GetNATTypeOptions Options = {};
	Options.ApiVersion = EOS_P2P_GETNATTYPE_API_LATEST;

	EOS_EResult Result = EOS_P2P_GetNATType(P2PHandle, &Options, &NATType);

	if (Result == EOS_EResult::EOS_NotFound)
	{
		//NAT type has not been queried yet. (Or query is not finished)		
		return EOS_ENATType::EOS_NAT_Unknown;
	}

	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"EOS P2PNAT GetNatType: error while retrieving NAT Type: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return EOS_ENATType::EOS_NAT_Unknown;
	}

	return NATType;
}

void FP2PNAT::OnUserConnectLoggedIn(FProductUserId UserId)
{
	RefreshNATType();

	//subscribe to connection requests
	SubscribeToConnectionRequests();

	//subscribe to connection established
	SubscribeToConnectionEstablished();
}

void FP2PNAT::OnLoggedOut(FEpicAccountId UserId)
{
	UnsubscribeFromConnectionRequests();
	UnsubscribeToConnectionEstablished();
}

void EOS_CALL FP2PNAT::OnRefreshNATTypeFinished(const EOS_P2P_OnQueryNATTypeCompleteInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"EOS P2PNAT QueryNATType callback: error code %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
	}
	else
	{
		FDebugLog::LogError(L"EOS P2PNAT QueryNATType callback: bad data returned");
	}
}

void FP2PNAT::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		FProductUserId UserId = Event.GetProductUserId();
		OnUserConnectLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedOut(UserId);
	}
}

void FP2PNAT::SendMessage(FProductUserId FriendId, const std::wstring& Message)
{
	if (!FriendId.IsValid() || Message.empty())
	{
		FDebugLog::LogError(L"EOS P2PNAT SendMessage: bad input data (account id is wrong or message is empty).");
		return;
	}

	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"EOS P2PNAT SendMessage: error user not logged in.");
		return;
	}

	EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());

	EOS_P2P_SocketId SocketId = {};
	SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
	strncpy_s(SocketId.SocketName, "CHAT", 5);

	EOS_P2P_SendPacketOptions Options = {};
	Options.ApiVersion = EOS_P2P_SENDPACKET_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	Options.RemoteUserId = FriendId;
	Options.SocketId = &SocketId;
	Options.bAllowDelayedDelivery = EOS_TRUE;
	Options.Channel = 0;
	Options.Reliability = EOS_EPacketReliability::EOS_PR_ReliableOrdered;
	Options.bDisableAutoAcceptConnection = EOS_FALSE;

	std::string MessageNarrow = FStringUtils::Narrow(Message);

	Options.DataLengthBytes = static_cast<uint32_t>(MessageNarrow.size());
	Options.Data = MessageNarrow.data();

	EOS_EResult Result = EOS_P2P_SendPacket(P2PHandle, &Options);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"EOS P2PNAT SendMessage: error while sending data, code: %ls.", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
	}
}

void FP2PNAT::HandleReceivedMessages()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		return;
	}

	EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());

	EOS_P2P_ReceivePacketOptions Options = {};
	Options.ApiVersion = EOS_P2P_RECEIVEPACKET_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	Options.MaxDataSizeBytes = 4096;
	Options.RequestedChannel = nullptr;

	//Packet params
	FProductUserId FriendId;

	EOS_P2P_SocketId SocketId = {};
	SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
	uint8_t Channel = 0;

	std::vector<char> MessageData;
	MessageData.resize(Options.MaxDataSizeBytes);
	uint32_t BytesWritten = 0;

	EOS_EResult Result = EOS_P2P_ReceivePacket(P2PHandle, &Options, &FriendId.AccountId, &SocketId, &Channel, MessageData.data(), &BytesWritten);
	if (Result == EOS_EResult::EOS_NotFound)
	{
		//no more packets, just end
		return;
	}
	else if (Result == EOS_EResult::EOS_Success)
	{
		std::shared_ptr<FP2PNATDialog> P2PDialog = static_cast<FMenu&>(*FGame::Get().GetMenu()).GetP2PNATDialog();
		if (P2PDialog)
		{
			std::wstring MessageWide;
			std::string MessageNarrow(MessageData.data(), BytesWritten);
			MessageWide = FStringUtils::Widen(MessageNarrow);
			P2PDialog->OnMessageReceived(MessageWide, FriendId);
		}
	}
	else
	{
		FDebugLog::LogError(L"EOS P2PNAT HandleReceivedMessages: error while reading data, code: %ls.", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
	}
}

void FP2PNAT::SubscribeToConnectionRequests()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		FDebugLog::LogError(L"EOS P2PNAT SubscribeToConnectionRequests: error user not logged in.");
		return;
	}

	if (ConnectionNotificationId == EOS_INVALID_NOTIFICATIONID)
	{
		EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());

		EOS_P2P_SocketId SocketId = {};
		SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
		strncpy_s(SocketId.SocketName, "CHAT", 5);

		EOS_P2P_AddNotifyPeerConnectionRequestOptions Options = {};
		Options.ApiVersion = EOS_P2P_ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST;
		Options.LocalUserId = Player->GetProductUserID();
		Options.SocketId = &SocketId;

		ConnectionNotificationId = EOS_P2P_AddNotifyPeerConnectionRequest(P2PHandle, &Options, nullptr, OnIncomingConnectionRequest);
		if (ConnectionNotificationId == EOS_INVALID_NOTIFICATIONID)
		{
			FDebugLog::LogError(L"EOS P2PNAT SubscribeToConnectionRequests: could not subscribe, bad notification id returned.");
		}
	}
}

void FP2PNAT::UnsubscribeFromConnectionRequests()
{
	EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());
	EOS_P2P_RemoveNotifyPeerConnectionRequest(P2PHandle, ConnectionNotificationId);
	ConnectionNotificationId = EOS_INVALID_NOTIFICATIONID;
}

void FP2PNAT::SubscribeToConnectionEstablished()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		FDebugLog::LogError(L"EOS P2PNAT SubscribeToConnectionEstablished: error user not logged in.");
		return;
	}

	if (ConnectionEstablishedNotificationId == EOS_INVALID_NOTIFICATIONID)
	{
		EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());

		EOS_P2P_SocketId SocketId = {};
		SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
		strncpy_s(SocketId.SocketName, "CHAT", 5);

		EOS_P2P_AddNotifyPeerConnectionEstablishedOptions Options = {};
		Options.ApiVersion = EOS_P2P_ADDNOTIFYPEERCONNECTIONESTABLISHED_API_LATEST;
		Options.LocalUserId = Player->GetProductUserID();
		Options.SocketId = &SocketId;

		ConnectionEstablishedNotificationId = EOS_P2P_AddNotifyPeerConnectionEstablished(P2PHandle, &Options, nullptr, OnIncomingConnectionEstablished);
		if (ConnectionEstablishedNotificationId == EOS_INVALID_NOTIFICATIONID)
		{
			FDebugLog::LogError(L"EOS P2PNAT SubscribeToConnectionEstablished: could not subscribe, bad notification id returned.");
		}
	}
}

void FP2PNAT::UnsubscribeToConnectionEstablished()
{
	EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());
	EOS_P2P_RemoveNotifyPeerConnectionEstablished(P2PHandle, ConnectionEstablishedNotificationId);
	ConnectionEstablishedNotificationId = EOS_INVALID_NOTIFICATIONID;
}

void EOS_CALL FP2PNAT::OnIncomingConnectionRequest(const EOS_P2P_OnIncomingConnectionRequestInfo* Data)
{
	if (Data)
	{
		std::string SocketName = Data->SocketId->SocketName;
		if (SocketName != "CHAT")
		{
			FDebugLog::LogError(L"EOS P2PNAT OnIncomingConnectionRequest: bad socket id.");
			return;
		}

		PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
		if (Player == nullptr || !Player->GetProductUserID().IsValid())
		{
			FDebugLog::LogError(L"EOS P2PNAT OnIncomingConnectionRequest: error user not logged in.");
			return;
		}
		
		EOS_HP2P P2PHandle = EOS_Platform_GetP2PInterface(FPlatform::GetPlatformHandle());
		EOS_P2P_AcceptConnectionOptions Options = {};
		Options.ApiVersion = EOS_P2P_ACCEPTCONNECTION_API_LATEST;
		Options.LocalUserId = Player->GetProductUserID();
		Options.RemoteUserId = Data->RemoteUserId;

		EOS_P2P_SocketId SocketId = {};
		SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
		strncpy_s(SocketId.SocketName, "CHAT", 5);
		Options.SocketId = &SocketId;

		EOS_EResult Result = EOS_P2P_AcceptConnection(P2PHandle, &Options);
		if (Result != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"EOS P2PNAT OnIncomingConnectionRequest: error while accepting connection, code: %ls.", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		}
	}
	else
	{
		FDebugLog::LogError(L"EOS P2PNAT SubscribeToConnectionRequests: EOS_P2P_OnIncomingConnectionRequestInfo is NULL.");
	}
}

void EOS_CALL FP2PNAT::OnIncomingConnectionEstablished(const EOS_P2P_OnPeerConnectionEstablishedInfo* Data)
{
	if (Data)
	{
		std::string SocketName = Data->SocketId->SocketName;
		if (SocketName != "CHAT")
		{
			FDebugLog::LogError(L"EOS P2PNAT OnIncomingConnectionEstablished: bad socket id.");
			return;
		}

		FDebugLog::Log(L"EOS P2PNAT OnIncomingConnectionEstablished: connection established. ConnectionType=[%ls]", Data->ConnectionType == EOS_EConnectionEstablishedType::EOS_CET_NewConnection ? L"NewConnection" : L"Reconnection");
	}
	else
	{
		FDebugLog::LogError(L"EOS P2PNAT SubscribeToConnectionEstablished: EOS_P2P_OnPeerConnectionEstablishedInfo is NULL.");
	}
}

```

`EAC_SDK/Samples/P2PNAT/Source/P2PNAT.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_sdk.h>
#include <eos_p2p.h>

/**
* Manages Peer 2 Peer connections with capabilities of NAT traversal.
*/
class FP2PNAT
{
public:
	/**
	* Constructor
	*/
	FP2PNAT() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FP2PNAT(FP2PNAT const&) = delete;
	FP2PNAT& operator=(FP2PNAT const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FP2PNAT();

	void Update();

	void RefreshNATType();
	EOS_ENATType GetNATType() const;
	
	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/** 
	 * Send chat message to your friend.
	 * @param FriendId - account Id of the receiver
	 * @param Message - chat text message to send
	 */
	void SendMessage(FProductUserId FriendId, const std::wstring& Message);
	void HandleReceivedMessages();

	void SubscribeToConnectionRequests();
	void UnsubscribeFromConnectionRequests();

	void SubscribeToConnectionEstablished();
	void UnsubscribeToConnectionEstablished();

	static void EOS_CALL OnIncomingConnectionRequest(const EOS_P2P_OnIncomingConnectionRequestInfo* Data);
	static void EOS_CALL OnIncomingConnectionEstablished(const EOS_P2P_OnPeerConnectionEstablishedInfo* Data);
	
private:

	/**
	* Called when a user has logged in
	*/
	void OnUserConnectLoggedIn(FProductUserId UserId);

	/**
	* Called when a user has logged out
	*/
	void OnLoggedOut(FEpicAccountId UserId);

	static void EOS_CALL OnRefreshNATTypeFinished(const EOS_P2P_OnQueryNATTypeCompleteInfo* Data);

	EOS_NotificationId ConnectionNotificationId = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId ConnectionEstablishedNotificationId = EOS_INVALID_NOTIFICATIONID;
};

```

`EAC_SDK/Samples/P2PNAT/Source/P2PNATDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "P2PNATDialog.h"
#include "P2PNAT.h"

FP2PNATDialog::FP2PNATDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont,
	FontPtr DialogTitleFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	HeaderLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Vector2(DialogSize.x, 25.0f),
		Layer - 1,
		std::wstring(L"Header"),
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	HeaderLabel->SetFont(DialogNormalFont);

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/texteditor.dds");

	NATStatusLabel = std::make_shared<FTextLabelWidget>(
		DialogPos + Vector2(HeaderLabel->GetSize().x + HeaderLabel->GetSize().x - 170.0f, 0.0f),
		Vector2(170.0f, 25.0f),
		Layer - 1,
		L"NAT Status: Unknown",
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	NATStatusLabel->SetFont(DialogNormalFont);

	Vector2 ChatInputFieldSize = Vector2(DialogSize.x, 30.0f);
	Vector2 ChatInputFieldPos = DialogPos + Vector2(0.0f, DialogSize.y) - Vector2(0.0f, ChatInputFieldSize.y);

	ChatInputField = std::make_shared<FTextFieldWidget>(
		ChatInputFieldPos,
		ChatInputFieldSize,
		Layer - 1,
		L"Chat...",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left);
	ChatInputField->SetBorderColor(Color::UIBorderGrey);

	ChatInputField->SetOnEnterPressedCallback(
		[this](const std::wstring& Value)
	{
		this->OnSendMessage(Value);
	}
	);

	Vector2 ChatTextViewPos = HeaderLabel->GetPosition() + Vector2(0.0f, HeaderLabel->GetSize().y + 5.0f);
	Vector2 ChatTextViewSize = Vector2(DialogSize.x, DialogSize.y - ChatInputFieldSize.y - HeaderLabel->GetSize().y - 10.0f);

	ChatTextView = std::make_shared<FTextViewWidget>(
		ChatTextViewPos,
		ChatTextViewSize,
		Layer - 1,
		L"Choose friend to start chat...",
		L"Assets/textfield.dds",
		DialogNormalFont);

	ChatTextView->SetBorderOffsets(Vector2(10.0f, 10.0f));
	ChatTextView->SetScrollerOffsets(Vector2(5.f, 5.0f));
	ChatTextView->SetFont(DialogNormalFont);

	ChatInfoLabel = std::make_shared<FTextLabelWidget>(
		ChatTextViewPos,
		ChatTextViewSize,
		Layer - 2,
		L"",
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Center
		);
	ChatInfoLabel->SetFont(DialogTitleFont);

	std::vector<std::wstring> EmptyButtonAssets = {};
	Vector2 CloseChatButtonSize = Vector2(150.0f, 35.0f);
	CloseCurrentChatButton = std::make_shared<FButtonWidget>(
		ChatTextViewPos + Vector2(ChatTextViewSize.x - CloseChatButtonSize.x - 10.0f, 10.0f),
		CloseChatButtonSize,
		Layer - 2,
		L"CLOSE CHAT",
		std::vector<std::wstring>({ L"Assets/solid_white.dds" }),
		DialogNormalFont,
		Color::UIHeaderGrey);
	CloseCurrentChatButton->SetFont(DialogNormalFont);
	CloseCurrentChatButton->SetBorderColor(Color::UIBorderGrey);
	CloseCurrentChatButton->SetOnPressedCallback([]()
	{
		static_cast<FMenu&>(*FGame::Get().GetMenu()).GetP2PNATDialog()->CloseCurrentChat();
	});
	CloseCurrentChatButton->Hide();
}

void FP2PNATDialog::Update()
{
	FDialog::Update();

	//Update header label
	if (HeaderLabel)
	{
		HeaderLabel->SetText(L"CHAT");
		if (FPlayerManager::Get().GetCurrentUser().IsValid())
		{
			if (CurrentChat.IsValid())
			{
				HeaderLabel->SetText(std::wstring(L"Chatting with ") + FGame::Get().GetFriends()->GetFriendName(CurrentChat));
			}
		}
	}

	//Update info label
	if (ChatInfoLabel)
	{
		if (!FPlayerManager::Get().GetCurrentUser().IsValid())
		{
			ChatInfoLabel->SetText(L"Log in to proceed");
		}
		else if (!CurrentChat.IsValid())
		{
			ChatInfoLabel->SetText(L"Select a friend to start chatting");
		}
		else
		{
			ChatInfoLabel->SetText(L"");
		}
	}

	//Update NAT Status
	if (NATStatusLabel && FPlayerManager::Get().GetCurrentUser().IsValid())
	{
		EOS_ENATType NATType = FGame::Get().GetP2PNAT()->GetNATType();
		std::wstring NATString = L"?";
		FColor NATColor = Color::White;
		switch (NATType)
		{
		case EOS_ENATType::EOS_NAT_Unknown:
			NATString = L"Unknown";
			NATColor = Color::White;
			break;
		case EOS_ENATType::EOS_NAT_Open:
			NATString = L"Open";
			NATColor = Color::Green;
			break;
		case EOS_ENATType::EOS_NAT_Moderate:
			NATString = L"Moderate";
			NATColor = Color::Yellow;
			break;
		case EOS_ENATType::EOS_NAT_Strict:
			NATString = L"Strict";
			NATColor = Color::Red;
			break;
		}

		NATStatusLabel->SetText(std::wstring(L"NAT Status: ") + NATString);
		NATStatusLabel->SetTextColor(NATColor);
	}

	//Update chat view
	if (ChatTextView && bChatViewDirty)
	{
		bChatViewDirty = false;

		ChatTextView->Clear(true);

		FChatWithFriendData& Chat = GetChat(CurrentChat);
		for (const auto& Entry : Chat.ChatLines)
		{
			bool bSelf = Entry.first;
			ChatTextView->AddLine(Entry.second, (bSelf) ? Color::Gray : Color::White);
		}
		ChatTextView->ScrollToBottom();
	}

	//Update close chat button
	if (CloseCurrentChatButton)
	{
		if (CurrentChat.IsValid() && !CloseCurrentChatButton->IsShown())
		{
			CloseCurrentChatButton->Show();
		}
		else if (!CurrentChat.IsValid() && CloseCurrentChatButton->IsShown())
		{
			CloseCurrentChatButton->Hide();
		}
	}
}

void FP2PNATDialog::Create()
{
	if (HeaderLabel) HeaderLabel->Create();
	if (BackgroundImage) BackgroundImage->Create();
	if (NATStatusLabel) NATStatusLabel->Create();
	if (ChatTextView)	ChatTextView->Create();
	if (ChatInputField)	ChatTextView->Create();
	if (ChatInfoLabel) ChatInfoLabel->Create();
	if (CloseCurrentChatButton) CloseCurrentChatButton->Create();

	AddWidget(HeaderLabel);
	AddWidget(BackgroundImage);
	AddWidget(NATStatusLabel);
	AddWidget(ChatTextView);
	AddWidget(ChatInputField);
	AddWidget(ChatInfoLabel);
	AddWidget(CloseCurrentChatButton);
}

void FP2PNATDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (HeaderLabel) HeaderLabel->SetPosition(Pos);
	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y + 20.f));
	if (NATStatusLabel) NATStatusLabel->SetPosition(HeaderLabel->GetPosition() + Vector2(HeaderLabel->GetSize().x - NATStatusLabel->GetSize().x, 0.0f));
	if (ChatTextView)	ChatTextView->SetPosition(HeaderLabel->GetPosition() + Vector2(0.0f, HeaderLabel->GetSize().y + 5.0f));
	if (ChatInputField)	ChatInputField->SetPosition(Position + Vector2(0.0f, Size.y) - Vector2(0.0f, ChatInputField->GetSize().y));
	if (ChatInfoLabel) ChatInfoLabel->SetPosition(ChatTextView->GetPosition());

	Vector2 CloseChatButtonSize = Vector2(150.0f, 35.0f);
	if (CloseCurrentChatButton) CloseCurrentChatButton->SetPosition(ChatTextView->GetPosition() + Vector2(ChatTextView->GetSize().x - CloseChatButtonSize.x - 10.0f, 10.0f));
}

void FP2PNATDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (HeaderLabel) HeaderLabel->SetSize(Vector2(NewSize.x, 25.0f));
	if (BackgroundImage) BackgroundImage->SetSize(NewSize);
	if (NATStatusLabel) NATStatusLabel->SetSize(Vector2(170.0f, 25.0f));

	Vector2 ChatInputFieldSize = Vector2(NewSize.x, 30.0f);
	Vector2 ChatTextViewSize = Vector2(NewSize.x, NewSize.y - ChatInputFieldSize.y - HeaderLabel->GetSize().y - 10.0f);

	if (ChatTextView)	ChatTextView->SetSize(ChatTextViewSize);
	if (ChatInputField)	ChatInputField->SetSize(ChatInputFieldSize);
	if (ChatInfoLabel) ChatInfoLabel->SetSize(ChatTextViewSize);
	Vector2 CloseChatButtonSize = Vector2(150.0f, 35.0f);
	if (CloseCurrentChatButton) CloseCurrentChatButton->SetSize(CloseChatButtonSize);
}


void FP2PNATDialog::OnUIEvent(const FUIEvent& Event)
{
	FDialog::OnUIEvent(Event);

	//We want to always pass mouse release event to text view to make sure it will never get stuck in "text selection" mode.
	if (ChatTextView && Event.GetType() == EUIEventType::MouseReleased)
	{
		ChatTextView->OnUIEvent(Event);
	}
}

void FP2PNATDialog::UpdateNATStatus()
{
	if (NATStatusLabel)
	{
		FGame::Get().GetP2PNAT()->RefreshNATType();
	}
}

void FP2PNATDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		UpdateNATStatus();
	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		UpdateNATStatus();
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		UpdateNATStatus();
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		UpdateNATStatus();
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		UpdateNATStatus();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		UpdateNATStatus();
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		UpdateNATStatus();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		UpdateNATStatus();
	}
	else if (Event.GetType() == EGameEventType::StartChatWithFriend)
	{
		// Open chat with friend
		CurrentChat = Event.GetProductUserId();

		bChatViewDirty = true;
		ChatTextView->Clear();
	}
}

FChatWithFriendData& FP2PNATDialog::GetChat(FProductUserId FriendId)
{
	auto Iter = std::find_if(ChatData.begin(), ChatData.end(), [FriendId](const FChatWithFriendData& Next) { return Next.FriendId == FriendId; });
	if (Iter != ChatData.end())
	{
		return *Iter;
	}

	ChatData.push_back(FChatWithFriendData(FriendId));
	return ChatData.back();
}

void FP2PNATDialog::CloseCurrentChat()
{
	CurrentChat = FProductUserId();

	if (ChatTextView)
	{
		ChatTextView->Clear();
	}
}

void FP2PNATDialog::OnSendMessage(const std::wstring& Value)
{
	if (CurrentChat.IsValid())
	{
		FChatWithFriendData& Chat = GetChat(CurrentChat);

		std::vector<std::wstring> NewLines;
		SplitMessageIntoLines(Value, NewLines);
		for (const std::wstring& NextLine : NewLines)
		{
			if (!NextLine.empty())
			{
				Chat.ChatLines.push_back(std::make_pair(true, NextLine));
			}
		}
		
		bChatViewDirty = true;

		FGame::Get().GetP2PNAT()->SendMessage(CurrentChat, Value);
	}

	ChatInputField->Clear();
}

void FP2PNATDialog::OnMessageReceived(const std::wstring& Message, FProductUserId FriendId)
{
	if (FriendId.IsValid())
	{
		FChatWithFriendData& Chat = GetChat(FriendId);

		std::vector<std::wstring> NewLines;
		SplitMessageIntoLines(Message, NewLines);
		for (const std::wstring& NextLine : NewLines)
		{
			if (!NextLine.empty())
			{
				Chat.ChatLines.push_back(std::make_pair(false, NextLine));
			}
		}

		if (CurrentChat == FriendId)
		{
			bChatViewDirty = true;
		}

		if (!CurrentChat.IsValid())
		{
			CurrentChat = FriendId;
			bChatViewDirty = true;
		}
	}
}

void FP2PNATDialog::SplitMessageIntoLines(const std::wstring& Message, std::vector<std::wstring>& OutLines)
{
	//In case the message is multi-line (e.g. because of pasting) we want to split it
	std::wstring::size_type TokenizeStartPos = 0;
	std::wstring::size_type TokenizeEndPos = Message.find_first_of(L'\n', TokenizeStartPos);

	while (TokenizeStartPos != std::wstring::npos && TokenizeEndPos != std::wstring::npos)
	{
		OutLines.push_back(Message.substr(TokenizeStartPos, TokenizeEndPos - TokenizeStartPos));
		TokenizeStartPos = Message.find_first_of(L'\n', TokenizeEndPos) + 1;
		TokenizeEndPos = Message.find_first_of(L'\n', TokenizeStartPos);
	}

	OutLines.push_back(Message.substr(TokenizeStartPos));
}

```

`EAC_SDK/Samples/P2PNAT/Source/P2PNATDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "ListView.h"

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;

/**
 * Structure to store all data related to chat with a friend.
 */
struct FChatWithFriendData
{
	//bool defines who's line it was: yours (when true) or someone else's
	std::vector<std::pair<bool, std::wstring> > ChatLines;

	//Who we are chatting with.
	FProductUserId FriendId;

	FChatWithFriendData() = default;
	FChatWithFriendData(FProductUserId InFriendId) : FriendId(InFriendId) {}
};

/**
 * P2P NAT dialog
 */
class FP2PNATDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FP2PNATDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont,
		FontPtr DialogTitleFont);

	/**
	 * Destructor
	 */
	virtual ~FP2PNATDialog() {};

	/**
	 * IGfxComponent Overrides
	 */
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	virtual void OnUIEvent(const FUIEvent& Event) override;

	void UpdateNATStatus();

	/**
	 * Receives game event
	 *
	 * @param Event - Game event to act on
	 */
	void OnGameEvent(const FGameEvent& Event);

	/** Find chat data related to particular friend. Creates and returns empty chat when no chat data found. */
	FChatWithFriendData& GetChat(FProductUserId FriendId);

	/** Who we are chatting with at the moment (returns invalid account id when no chat is active) */
	FProductUserId GetCurrentChat() const { return CurrentChat; }

	/** Close current chat */
	void CloseCurrentChat();

	/** Called when user wants to send text */
	void OnSendMessage(const std::wstring& Value);

	/** Called when a message is received from another user */
	void OnMessageReceived(const std::wstring& Message, FProductUserId FriendId);

private:
	/** Splits a multi-line message (with newline characters) into multiple lines of text */
	void SplitMessageIntoLines(const std::wstring& Message, std::vector<std::wstring>& OutLines);

	/** Header label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Chat text view */
	std::shared_ptr<FTextViewWidget> ChatTextView;

	/** Chat central info label */
	std::shared_ptr<FTextLabelWidget> ChatInfoLabel;

	/** Chat input field */
	std::shared_ptr<FTextFieldWidget> ChatInputField;

	/** NAT Status label */
	std::shared_ptr<FTextLabelWidget> NATStatusLabel;

	/** Close current chat button */
	std::shared_ptr<FButtonWidget> CloseCurrentChatButton;

	/** All active chats */
	std::vector<FChatWithFriendData> ChatData;

	/** Who we are chatting at the moment */
	FProductUserId CurrentChat;

	/** Do we need to refresh text in chat view? */
	bool bChatViewDirty = true;
};

```

`EAC_SDK/Samples/P2PNAT/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "P2P NAT";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/P2PNAT/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/P2PNAT/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/PlayerDataStorage/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/PlayerDataStorage/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/PlayerDataStorage/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/PlayerDataStorage/PlayerDataStorage.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>PlayerDataStorage</RootNamespace>
    <ProjectGuid>{84505A35-14BE-4A4D-9029-BF5AD22897DC}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>PlayerDataStorage</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/PlayerDataStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/PlayerDataStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/PlayerDataStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/PlayerDataStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/PlayerDataStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/PlayerDataStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/PlayerDataStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/PlayerDataStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TransferProgressDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\NewFileDialog.h" />
    <ClInclude Include="Source\PlayerDataStorage.h" />
    <ClInclude Include="Source\PlayerDataStorageDialog.h" />
    <ClInclude Include="Source\SampleConstants.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TransferProgressDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\NewFileDialog.cpp" />
    <ClCompile Include="Source\PlayerDataStorage.cpp" />
    <ClCompile Include="Source\PlayerDataStorageDialog.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/PlayerDataStorage/PlayerDataStorage.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="Source\PlayerDataStorageDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TransferProgressDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="Source\PlayerDataStorage.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="Source\NewFileDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
	<ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="Source\PlayerDataStorageDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TransferProgressDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="Source\PlayerDataStorage.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Source\NewFileDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/PlayerDataStorage/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "PlayerDataStorage.h"
#include "Player.h"
#include "GameEvent.h"
#include "Game.h"

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	PlayerDataStorage = std::make_unique<FPlayerDataStorage>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" ADDFILE FILE_NAME FILE_DATA_PATH (opt) - to create (and upload) empty file for Player Data Storage\n"
			L"                                          or to upload file data from disk (when second parameter is present);",
			L" GETFILE FILE_NAME - to download file data from Player Data Storage;",
			L" DUPFILE SOURCE_FILE_NAME DESTINATION_FILE_NAME - to create a copy of existing file in Player Data Storage;",
			L" TESTFILE FILE_NAME FILE_PATH - to test if data from Player Data Storage matches contents of file on disk;"
		};
		AppendHelpMessageLines(ExtraHelpMessageLines);

		Console->AddCommand(L"ADDFILE", [](const std::vector<std::wstring>& Args)
		{
			if (Args.size() == 1)
			{
				if (FGame::Get().GetPlayerDataStorage() && FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()))
				{
					FGame::Get().GetPlayerDataStorage()->AddFile(Args[0], L"");
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"ADDFILE error: login to be able to interact with Player Data Storage.", Color::Red);
				}
			}
			else if (Args.size() == 2)
			{
				//Simply load the whole file into memory.
				std::wifstream FileStream(FStringUtils::Narrow(Args[1]), std::ios_base::binary | std::ios_base::in);

				if (FileStream.good())
				{
					std::wstring DataString((std::istreambuf_iterator<wchar_t>(FileStream)),
						std::istreambuf_iterator<wchar_t>());

					if (FGame::Get().GetPlayerDataStorage() && FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()))
					{
						FGame::Get().GetPlayerDataStorage()->AddFile(Args[0], DataString);
					}
					else
					{
						FGame::Get().GetConsole()->AddLine(L"ADDFILE error: login to be able to interact with Player Data Storage.", Color::Red);
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(std::wstring(L"ADDFILE error: could not open file: ") + Args[1], Color::Red);
				}
			}
			else
			{
				FGame::Get().GetConsole()->AddLine(L"ADDFILE error: file name is required. Filepath is an optional second parameter.", Color::Red);
			}
		});

		Console->AddCommand(L"GETFILE", [](const std::vector<std::wstring>& Args)
		{
			if (Args.size() == 1)
			{
				if (FGame::Get().GetPlayerDataStorage() && FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()))
				{
					FGame::Get().GetPlayerDataStorage()->StartFileDataDownload(Args[0]);
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"GETFILE error: login to be able to interact with Player Data Storage.", Color::Red);
				}
			}
			else
			{
				FGame::Get().GetConsole()->AddLine(L"GETFILE error: file name is required.", Color::Red);
			}
		});

		Console->AddCommand(L"DUPFILE", [](const std::vector<std::wstring>& Args)
		{
			if (Args.size() == 2)
			{
				if (FGame::Get().GetPlayerDataStorage() && FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()))
				{
					FGame::Get().GetPlayerDataStorage()->CopyFile(Args[0], Args[1]);
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"DUPFILE error: login to be able to interact with Player Data Storage.", Color::Red);
				}
			}
			else
			{
				FGame::Get().GetConsole()->AddLine(L"DUPFILE error: source file name and destination file name are required.", Color::Red);
			}
		});

		Console->AddCommand(L"TESTFILE", [](const std::vector<std::wstring>& Args)
		{
			if (Args.size() == 2)
			{
				if (FGame::Get().GetPlayerDataStorage() && FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()))
				{
					bool NoLocalData = false;
					const std::wstring PDSData = FGame::Get().GetPlayerDataStorage()->GetLocalData(Args[0], NoLocalData);
					if (NoLocalData)
					{
						FGame::Get().GetConsole()->AddLine(L"TESTFILE error: no local data for file specified. File is missing in PDS or data is not downloaded yet (use download button or GETFILE command).", Color::Red);
					}
					else
					{
						//Load file data into memory
						std::wifstream FileStream(FStringUtils::Narrow(Args[1]), std::ios_base::binary | std::ios_base::in);

						if (FileStream.good())
						{
							std::wstring DataString((std::istreambuf_iterator<wchar_t>(FileStream)),
								std::istreambuf_iterator<wchar_t>());

							if (DataString == PDSData)
							{
								FGame::Get().GetConsole()->AddLine(L"TESTFILE: files' data match!", Color::Green);
							}
							else
							{
								FGame::Get().GetConsole()->AddLine(L"TESTFILE: files' data is different!", Color::Red);
							}
						}
						else
						{
							FGame::Get().GetConsole()->AddLine(L"TESTFILE: could not open file specified as second parameter. Please provide full path.", Color::Red);
						}
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"TESTFILE error: login to be able to interact with Player Data Storage.", Color::Red);
				}
			}
			else
			{
				FGame::Get().GetConsole()->AddLine(L"TESTFILE error: data storage file name and full file path are required.", Color::Red);
			}
		});
	}
}

void FGame::Update()
{
	PlayerDataStorage->Update();

	FBaseGame::Update();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);
	PlayerDataStorage->OnGameEvent(Event);
}

std::unique_ptr<FPlayerDataStorage> const& FGame::GetPlayerDataStorage()
{
	return PlayerDataStorage;
}

```

`EAC_SDK/Samples/PlayerDataStorage/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FPlayerDataStorage;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	 * Getter for PDS component.
	 */
	const std::unique_ptr<FPlayerDataStorage>& GetPlayerDataStorage();

protected:
	/**
	* Creates all console commands
	*/
	virtual void CreateConsoleCommands() override;

	/** PDS component */
	std::unique_ptr<FPlayerDataStorage> PlayerDataStorage;
};


```

`EAC_SDK/Samples/PlayerDataStorage/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/PlayerDataStorage/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "PlayerDataStorageDialog.h"
#include "TransferProgressDialog.h"
#include "NewFileDialog.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "PlayerDataStorage.h"
#include "PopupDialog.h"

const Vector2 ConsoleDialogSizeProportion = Vector2(0.68f, 0.35f);

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreatePlayerDataStorageDialog();
	CreateFileTransferDialog();
	CreateNewFileDialog();

	FBaseMenu::Create();
}

void FMenu::Release()
{
	if (PlayerDataStorageDialog)
	{
		PlayerDataStorageDialog->Release();
		PlayerDataStorageDialog.reset();
	}

	FBaseMenu::Release();
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * ConsoleDialogSizeProportion.x, WindowSize.y * ConsoleDialogSizeProportion.y);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (PlayerDataStorageDialog)
		{
			PlayerDataStorageDialog->SetWindowSize(WindowSize);

			Vector2 PlayerDataStorageDialogSize = Vector2(WindowSize.x - ConsoleDialog->GetSize().x - 30.f, WindowSize.y - 130.0f);
			PlayerDataStorageDialog->SetSize(PlayerDataStorageDialogSize);

			Vector2 PlayerDataStorageDialogPos = Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
				WindowSize.y - PlayerDataStorageDialogSize.y - 10.f);
			PlayerDataStorageDialog->SetPosition(PlayerDataStorageDialogPos);
		}
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (TransferDialog)
	{
		TransferDialog->SetPosition(Vector2((WindowSize.x / 2.f) - TransferDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - TransferDialog->GetSize().y));
	}

	if (NewFileDialog)
	{
		NewFileDialog->SetPosition(Vector2((WindowSize.x / 2.f) - NewFileDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - NewFileDialog->GetSize().y));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::CreatePlayerDataStorageDialog()
{
	const float FX = 100.0f;
	const float FY = 100.0f;
	const float Width = 300.0f;
	const float Height = 300.0f;

	PlayerDataStorageDialog = std::make_shared<FPlayerDataStorageDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	PlayerDataStorageDialog->SetWindowProportion(ConsoleDialogSizeProportion);
	PlayerDataStorageDialog->SetBorderColor(Color::UIBorderGrey);
	
	PlayerDataStorageDialog->Create();

	AddDialog(PlayerDataStorageDialog);
}

void FMenu::CreateFileTransferDialog()
{
	class FPlayerDataStorageProgressDelegate : public FTransferProgressDialog::FDelegate
	{
		virtual void CancelTransfer() override
		{
			FGame::Get().GetPlayerDataStorage()->CancelCurrentTransfer();
		}

		virtual const std::wstring& GetCurrentTransferName() override
		{
			return FGame::Get().GetPlayerDataStorage()->GetCurrentTransferName();
		}

		virtual float GetCurrentTransferProgress() override
		{
			return FGame::Get().GetPlayerDataStorage()->GetCurrentTransferProgress();
		}
	};

	std::shared_ptr<FTransferProgressDialog::FDelegate> TitleStorageProgressDelegate = std::make_shared<FPlayerDataStorageProgressDelegate>();

	TransferDialog = std::make_shared<FTransferProgressDialog>(
		Vector2(200.f, 200.f),
		Vector2(330.f, 160.f),
		5,
		L"",
		NormalFont->GetFont(),
		SmallFont->GetFont(),
		TitleStorageProgressDelegate);

	TransferDialog->SetBorderColor(Color::UIBorderGrey);
	TransferDialog->Create();

	AddDialog(TransferDialog);

	HideDialog(TransferDialog);
}


void FMenu::CreateNewFileDialog()
{
	NewFileDialog = std::make_shared<FNewFileDialog>(
		Vector2(200.f, 200.f),
		Vector2(330.f, 200.0f),
		5,
		NormalFont->GetFont(),
		SmallFont->GetFont());

	NewFileDialog->SetBorderColor(Color::UIBorderGrey);
	NewFileDialog->Create();

	AddDialog(NewFileDialog);

	HideDialog(NewFileDialog);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	FBaseMenu::OnGameEvent(Event);

	if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		UpdatePlayerDataStorage();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		UpdatePlayerDataStorage();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		UpdatePlayerDataStorage();
	}
	else if (Event.GetType() == EGameEventType::FileTransferStarted)
	{
		const std::wstring& TransferName = Event.GetFirstStr();
		if (TransferDialog)
		{
			TransferDialog->SetTransferName(TransferName);
			ShowDialog(TransferDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::FileTransferFinished)
	{
		const std::wstring& TransferName = Event.GetFirstStr();
		if (TransferDialog)
		{
			if (TransferDialog->GetTransferName() == TransferName)
			{
				HideDialog(TransferDialog);
			}
		}
	}
	else if (Event.GetType() == EGameEventType::NewFileCreationStarted)
	{
		if (NewFileDialog)
		{
			ShowDialog(NewFileDialog);
		}
	}

	if (PlayerDataStorageDialog) PlayerDataStorageDialog->OnGameEvent(Event);
}

void FMenu::CreateAuthDialogs()
{
	AuthDialogs = std::make_shared<FAuthDialogs>(
		PlayerDataStorageDialog,
		L"Player Data Storage",
		BoldSmallFont->GetFont(),
		SmallFont->GetFont(),
		TinyFont->GetFont());

	AuthDialogs->SetUserLabelOffset(Vector2(-30.0f, -10.0f));
	AuthDialogs->Create();
	AuthDialogs->SetSingleUserOnly(true);
}

void FMenu::UpdatePlayerDataStorage()
{
	if (PlayerDataStorageDialog)
	{
		PlayerDataStorageDialog->SetPosition(Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
			PlayerDataStorageDialog->GetPosition().y));
	}
}
```

`EAC_SDK/Samples/PlayerDataStorage/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FUIEvent;
class FConsole;
class FGameEvent;
class FFont;
class FConsoleDialog;
class FFriendsDialog;
class FExitDialog;
class FAuthDialogs;
class FSpriteWidget;
class FTextLabelWidget;
class FPlayerDataStorageDialog;
class FTransferProgressDialog;
class FNewFileDialog;
class FPopupDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> console) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event) override;

protected:
	/** 
	 * Create Auth dialogs
	 */
	virtual void CreateAuthDialogs() override;

	/**
	 * Creates the player data storage dialog
	 */
	void CreatePlayerDataStorageDialog();

	/** 
	 * Creates the file transfer dialog
	 */
	void CreateFileTransferDialog();

	/** 
	 * Creates the create new file dialog
	 */
	void CreateNewFileDialog();

	/**
	* Updates player data storage
	*/
	void UpdatePlayerDataStorage();

	/** Player Data Storage Dialog */
	std::shared_ptr<FPlayerDataStorageDialog> PlayerDataStorageDialog;

	/** File transfer progress dialog */
	std::shared_ptr<FTransferProgressDialog> TransferDialog;

	/** New file dialog */
	std::shared_ptr<FNewFileDialog> NewFileDialog;
};

```

`EAC_SDK/Samples/PlayerDataStorage/Source/NewFileDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "Sprite.h"
#include "TextLabel.h"
#include "Button.h"
#include "TextField.h"
#include "NewFileDialog.h"
#include "PlayerDataStorage.h"

FNewFileDialog::FNewFileDialog(Vector2 DialogPos,
						 Vector2 DialogSize,
						 UILayer DialogLayer,
						 FontPtr DialogNormalFont,
						 FontPtr DialogSmallFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	Background = std::make_shared<FSpriteWidget>(
		Position,
		Size,
		DialogLayer - 1,
		L"Assets/textfield.dds");
	AddWidget(Background);

	Label = std::make_shared<FTextLabelWidget>(
		Position,
		Vector2(150.f, 30.f),
		DialogLayer - 1,
		L"New file name:",
		L"");
	Label->SetFont(DialogNormalFont);
	AddWidget(Label);

	TextField = std::make_shared<FTextFieldWidget>(
		Vector2(Position + Vector2(0.0f, 30.0f)),
		Vector2(150.f, 30.0f),
		DialogLayer - 1,
		L"new_file",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Center
		);
	AddWidget(TextField);

	FColor ButtonCol = FColor(0.f, 0.47f, 0.95f, 1.f);

	OkButton = std::make_shared<FButtonWidget>(
		Vector2(Position.x + 30.f, Position.y + 70.f),
		Vector2(100.f, 30.f),
		DialogLayer - 1,
		L"OK",
		assets::DefaultButtonAssets,
		DialogSmallFont,
		ButtonCol);
	OkButton->SetOnPressedCallback([this]()
	{
		FGame::Get().GetPlayerDataStorage()->AddFile(this->GetFileName(), L"");
		Hide();
	});
	OkButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(OkButton);

	CancelButton = std::make_shared<FButtonWidget>(
		Vector2(Position.x + 150.f, Position.y + 70.f),
		Vector2(100.f, 30.f),
		DialogLayer - 1,
		L"CANCEL",
		assets::DefaultButtonAssets,
		DialogSmallFont,
		ButtonCol);
	CancelButton->SetOnPressedCallback([this]()
	{
		Hide();
	});
	CancelButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(CancelButton);
}

void FNewFileDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	Background->SetPosition(Position);
	Label->SetPosition(Vector2(Position.x + 30.f, Position.y + 40.f));
	TextField->SetPosition(Vector2(Position.x + 30.f, Position.y + 70.f));
	OkButton->SetPosition(Vector2(Position.x + 50.f, Position.y + 100.f));
	CancelButton->SetPosition(Vector2(Position.x + 170.f, Position.y + 100.f));
}


void FNewFileDialog::OnEscapePressed()
{
	Hide();
}

std::wstring FNewFileDialog::GetFileName() const
{
	if (TextField)
	{
		return TextField->GetText();
	}

	return std::wstring();
}

```

`EAC_SDK/Samples/PlayerDataStorage/Source/NewFileDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FButtonWidget;

/**
 * Exit dialog
 */
class FNewFileDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FNewFileDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FNewFileDialog() {};

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;

	virtual void OnEscapePressed() override;

	std::wstring GetFileName() const;

private:
	/** Dialog Background */
	WidgetPtr Background;

	/** Main Dialog Label */
	std::shared_ptr<FTextLabelWidget> Label;

	/** Text field to input new file name */
	std::shared_ptr<FTextFieldWidget> TextField;

	/** Ok Button */
	std::shared_ptr<FButtonWidget> OkButton;

	/** Cancel Button */
	std::shared_ptr<FButtonWidget> CancelButton;
};

```

`EAC_SDK/Samples/PlayerDataStorage/Source/PlayerDataStorage.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "Utils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "PlayerDataStorage.h"

const size_t MaxChunkSize = 4096;

FPlayerDataStorage::FPlayerDataStorage()
{
}

FPlayerDataStorage::~FPlayerDataStorage()
{

}

void FPlayerDataStorage::QueryList()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		return;
	}

	EOS_HPlayerDataStorage PlayerStorageHandle = EOS_Platform_GetPlayerDataStorageInterface(FPlatform::GetPlatformHandle());
	EOS_PlayerDataStorage_QueryFileListOptions Options = {};
	Options.ApiVersion = EOS_PLAYERDATASTORAGE_QUERYFILELIST_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	EOS_PlayerDataStorage_QueryFileList(PlayerStorageHandle, &Options, nullptr, OnFileListRetrieved);
}

void FPlayerDataStorage::StartFileDataDownload(const std::wstring& FileName)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		return;
	}

	//TODO: make sure we are not transferring the same file atm
	EOS_HPlayerDataStorage PlayerStorageHandle = EOS_Platform_GetPlayerDataStorageInterface(FPlatform::GetPlatformHandle());
	EOS_PlayerDataStorage_ReadFileOptions Options = {};
	Options.ApiVersion = EOS_PLAYERDATASTORAGE_READFILE_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	std::string NarrowFileName = FStringUtils::Narrow(FileName);
	Options.Filename = NarrowFileName.c_str();
	Options.ReadChunkLengthBytes = MaxChunkSize;

	Options.ReadFileDataCallback = OnFileDataReceived;
	Options.FileTransferProgressCallback = OnFileTransferProgressUpdated;

	EOS_HPlayerDataStorageFileTransferRequest Handle = EOS_PlayerDataStorage_ReadFile(PlayerStorageHandle, &Options, nullptr, OnFileReceived);
	if (!Handle)
	{
		FDebugLog::LogError(L"[EOS SDK] Player data storage: can't start file download, bad handle returned '%ls'", FileName.c_str());
		return;
	}

	CancelCurrentTransfer();
	CurrentTransferHandle = Handle;

	FTransferInProgress NewTransfer;
	NewTransfer.bDownload = true;
	
	//Total file size will be set on first update

	TransfersInProgress[FileName] = NewTransfer;

	CurrentTransferProgress = 0.0f;
	CurrentTransferName = FileName;

	//Show dialog
	FGameEvent GameEvent(EGameEventType::FileTransferStarted, CurrentTransferName);
	FGame::Get().OnGameEvent(GameEvent);
}

bool FPlayerDataStorage::StartFileDataUpload(const std::wstring& FileName)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		return false;
	}

	//TODO: make sure we are not transferring the same file atm

	auto Iter = StorageData.find(FileName);
	const std::wstring& FileData = Iter->second.second;
	
	EOS_HPlayerDataStorage PlayerStorageHandle = EOS_Platform_GetPlayerDataStorageInterface(FPlatform::GetPlatformHandle());
	EOS_PlayerDataStorage_WriteFileOptions Options = {};
	Options.ApiVersion = EOS_PLAYERDATASTORAGE_WRITEFILE_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	std::string NarrowFileName = FStringUtils::Narrow(FileName);
	Options.Filename = NarrowFileName.c_str();
	Options.ChunkLengthBytes = MaxChunkSize;
	Options.WriteFileDataCallback = OnFileDataSend;
	Options.FileTransferProgressCallback = OnFileTransferProgressUpdated;

	EOS_HPlayerDataStorageFileTransferRequest Handle = EOS_PlayerDataStorage_WriteFile(PlayerStorageHandle, &Options, nullptr, OnFileSent);
	if(!Handle)
	{
		FDebugLog::LogError(L"[EOS SDK] Player data storage: can't start file upload, bad handle returned '%ls'", FileName.c_str());
		return false;
	}

	CancelCurrentTransfer();
	CurrentTransferHandle = Handle;

	FTransferInProgress NewTransfer;
	NewTransfer.bDownload = false;

	std::string NarrowFileData = FStringUtils::Narrow(FileData);
	NewTransfer.TotalSize = NarrowFileData.size();
	NewTransfer.Data.resize(NarrowFileData.size());
	if (NewTransfer.TotalSize > 0)
	{
		memcpy(static_cast<void*>(&NewTransfer.Data[0]), static_cast<const void*>(&NarrowFileData[0]), NarrowFileData.size());
	}
	NewTransfer.CurrentIndex = 0;

	TransfersInProgress[FileName] = NewTransfer;

	CurrentTransferProgress = 0.0f;
	CurrentTransferName = FileName;

	//Show dialog
	FGameEvent GameEvent(EGameEventType::FileTransferStarted, CurrentTransferName);
	FGame::Get().OnGameEvent(GameEvent);

	return true;
}

std::vector<std::wstring> FPlayerDataStorage::GetFileList() const
{
	std::vector<std::wstring> Names;
	Names.reserve(StorageData.size());

	for (auto& Entry : StorageData)
	{
		Names.push_back(Entry.first);
	}

	return Names;
}

void FPlayerDataStorage::SetFileList(const std::vector<std::wstring>& FileNames)
{

	for (const std::wstring& NextName : FileNames)
	{
		auto Iter = StorageData.find(NextName);
		if (Iter == StorageData.end())
		{
			//data will be retrieved when requested explicitly
			StorageData[NextName] = std::make_pair<bool, std::wstring>(false, L"");
		}
	}

	//we need to remove files that are gone
	if (StorageData.size() != FileNames.size())
	{
		std::unordered_map<std::wstring, std::pair<bool, std::wstring>> NewStorageData;

		for (const std::wstring& NextName : FileNames)
		{
			NewStorageData[NextName] = StorageData[NextName];
		}

		StorageData.swap(NewStorageData);
	}
}

void FPlayerDataStorage::AddFile(const std::wstring& EntryName, const std::wstring& Data)
{
	SetLocalData(EntryName, Data);
	if (!StartFileDataUpload(EntryName))
	{
		EraseLocalData(EntryName);
	}
}

void FPlayerDataStorage::CopyFile(const std::wstring& SourceFileName, const std::wstring& DestinationFileName)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		return;
	}

	EOS_HPlayerDataStorage PlayerStorageHandle = EOS_Platform_GetPlayerDataStorageInterface(FPlatform::GetPlatformHandle());
	EOS_PlayerDataStorage_DuplicateFileOptions Options = {};
	Options.ApiVersion = EOS_PLAYERDATASTORAGE_DUPLICATEFILE_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	std::string NarrowSourceFileName = FStringUtils::Narrow(SourceFileName);
	Options.SourceFilename = NarrowSourceFileName.c_str();

	std::string NarrowDestinationFileName = FStringUtils::Narrow(DestinationFileName);
	Options.DestinationFilename = NarrowDestinationFileName.c_str();

	EOS_PlayerDataStorage_DuplicateFile(PlayerStorageHandle, &Options, nullptr, OnFileCopied);
}

void FPlayerDataStorage::RemoveFile(const std::wstring& FileName)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		return;
	}

	//remove local data (if any)
	EraseLocalData(FileName);

	EOS_HPlayerDataStorage PlayerStorageHandle = EOS_Platform_GetPlayerDataStorageInterface(FPlatform::GetPlatformHandle());
	EOS_PlayerDataStorage_DeleteFileOptions Options = {};
	Options.ApiVersion = EOS_PLAYERDATASTORAGE_DELETEFILE_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	std::string NarrowFileName = FStringUtils::Narrow(FileName);
	Options.Filename = NarrowFileName.c_str();

	EOS_PlayerDataStorage_DeleteFile(PlayerStorageHandle, &Options, nullptr, OnFileRemoved);
}

std::wstring FPlayerDataStorage::GetLocalData(const std::wstring& EntryName, bool& NoData) const
{
	auto Iter = StorageData.find(EntryName);
	if (Iter != StorageData.end())
	{
		NoData = !Iter->second.first;
		return Iter->second.second;
	}

	NoData = true;
	return L"";
}

void FPlayerDataStorage::SetLocalData(const std::wstring& EntryName, const std::wstring& Data)
{
	StorageData[EntryName] = std::make_pair<bool, std::wstring>(true, std::wstring(Data));
}

void FPlayerDataStorage::EraseLocalData(const std::wstring& EntryName)
{
	auto iter = StorageData.find(EntryName);
	if (iter != StorageData.end())
	{
		StorageData.erase(iter);
	}
}

void FPlayerDataStorage::CancelCurrentTransfer()
{
	if (CurrentTransferHandle)
	{
		auto Result = EOS_PlayerDataStorageFileTransferRequest_CancelRequest(CurrentTransferHandle);
		EOS_PlayerDataStorageFileTransferRequest_Release(CurrentTransferHandle);
		CurrentTransferHandle = nullptr;

		if (Result == EOS_EResult::EOS_Success)
		{
			//canceled with success
			auto Iter = TransfersInProgress.find(CurrentTransferName);
			if (Iter != TransfersInProgress.end())
			{
				FTransferInProgress& Transfer = Iter->second;
				if (Transfer.bDownload)
				{
					//Download is canceled - do nothing
				}
				else
				{
					//Upload is canceled - do nothing
				}

				TransfersInProgress.erase(Iter);
			}

			//Hide dialog
			FGameEvent GameEvent(EGameEventType::FileTransferFinished, CurrentTransferName);
			FGame::Get().OnGameEvent(GameEvent);
		}
	}

	ClearCurrentTransfer();
}


EOS_PlayerDataStorage_EReadResult FPlayerDataStorage::ReceiveData(const std::wstring& FileName, const void* Data, size_t NumBytes, size_t TotalSize)
{
	if (!Data)
	{
		FDebugLog::LogError(L"[EOS SDK] Player data storage: could not receive data: Data pointer is null.");
		return EOS_PlayerDataStorage_EReadResult::EOS_RR_FailRequest;
	}

	auto Iter = TransfersInProgress.find(FileName);
	if (Iter != TransfersInProgress.end())
	{
		FTransferInProgress& Transfer = Iter->second;

		if (!Transfer.bDownload)
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: can't load file data: download/upload mismatch.");
			return EOS_PlayerDataStorage_EReadResult::EOS_RR_FailRequest;
		}

		//First update
		if (Transfer.CurrentIndex == 0 && Transfer.TotalSize == 0)
		{
			Transfer.TotalSize = TotalSize;

			if (Transfer.TotalSize == 0)
			{
				return EOS_PlayerDataStorage_EReadResult::EOS_RR_ContinueReading;
			}

			Transfer.Data.resize(TotalSize);
		}

		//Make sure we have enough space
		if (Transfer.TotalSize - Transfer.CurrentIndex >= NumBytes)
		{
			memcpy(static_cast<void*>(&Transfer.Data[Transfer.CurrentIndex]), Data, NumBytes);
			Transfer.CurrentIndex += NumBytes;

			return EOS_PlayerDataStorage_EReadResult::EOS_RR_ContinueReading;
		}
		else
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: could not receive data: too much of it.");
			return EOS_PlayerDataStorage_EReadResult::EOS_RR_FailRequest;
		}
	}

	return EOS_PlayerDataStorage_EReadResult::EOS_RR_CancelRequest;
}

EOS_PlayerDataStorage_EWriteResult FPlayerDataStorage::SendData(const std::wstring& FileName, void* Data, uint32_t* BytesWritten)
{
	if (!Data || !BytesWritten)
	{
		FDebugLog::LogError(L"[EOS SDK] Player data storage: could not send data: pointer is null.");
		return EOS_PlayerDataStorage_EWriteResult::EOS_WR_FailRequest;
	}

	auto Iter = TransfersInProgress.find(FileName);
	if (Iter != TransfersInProgress.end())
	{
		FTransferInProgress& Transfer = Iter->second;

		if (Transfer.bDownload)
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: can't send file data: download/upload mismatch.");
			return EOS_PlayerDataStorage_EWriteResult::EOS_WR_FailRequest;
		}

		if (Transfer.Done())
		{
			*BytesWritten = 0;
			return EOS_PlayerDataStorage_EWriteResult::EOS_WR_CompleteRequest;
		}

		size_t BytesToWrite = std::min(MaxChunkSize, Transfer.TotalSize - Transfer.CurrentIndex);
		
		if (BytesToWrite > 0)
		{
			memcpy(Data, static_cast<const void*>(&Transfer.Data[Transfer.CurrentIndex]), BytesToWrite);
		}
		*BytesWritten = static_cast<uint32_t>(BytesToWrite);

		Transfer.CurrentIndex += BytesToWrite;

		if (Transfer.Done())
		{
			return EOS_PlayerDataStorage_EWriteResult::EOS_WR_CompleteRequest;
		}
		else
		{
			return EOS_PlayerDataStorage_EWriteResult::EOS_WR_ContinueWriting;
		}
	}
	else
	{
		FDebugLog::LogError(L"[EOS SDK] Player data storage: could not send data as this file is not being uploaded at the moment.");
		*BytesWritten = 0;
		return EOS_PlayerDataStorage_EWriteResult::EOS_WR_CancelRequest;
	}
}


void FPlayerDataStorage::UpdateProgress(const std::wstring& FileName, float Progress)
{
	// Make sure the update is for our primary (current) transfer.
	if (FileName == CurrentTransferName)
	{
		CurrentTransferProgress = Progress;
	}
}

void FPlayerDataStorage::FinishFileDownload(const std::wstring& FileName, bool bSuccess)
{
	auto Iter = TransfersInProgress.find(FileName);
	if (Iter != TransfersInProgress.end())
	{
		FTransferInProgress& Transfer = Iter->second;

		if (!Transfer.bDownload)
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: error while file read operation: can't finish because of download/upload mismatch.");
			return;
		}

		if (!Transfer.Done() || !bSuccess)
		{
			if (!Transfer.Done())
			{
				FDebugLog::LogError(L"[EOS SDK] Player data storage: error while file read operation: expecting more data. File can be corrupted.");
			}
			TransfersInProgress.erase(Iter);
			if (FileName == CurrentTransferName)
			{
				ClearCurrentTransfer();
			}
			return;
		}

		std::string NarrowFileData;
		//Don't try to show files larger than 5 megs (it will cause UI performance issues)
		if (Transfer.TotalSize > 5 * 1024 * 1024)
		{
			NarrowFileData = "*** File is too large to be viewed in this sample. ***";
		}
		else
		{
			NarrowFileData = (Transfer.TotalSize > 0) ? std::string(&Transfer.Data[0], Transfer.TotalSize) : std::string();
		}

		std::wstring WideFileData;
		//Data can be binary or corrupted.
		try
		{
			WideFileData = FStringUtils::Widen(NarrowFileData);
		}
		catch (...)
		{
			WideFileData = L"*** File data contains binary data that can't be viewed. ***";
		}
		StorageData[FileName] = std::make_pair<bool, std::wstring>(true, std::move(WideFileData));

		FDebugLog::Log(L"[EOS SDK] Player data storage: file read finished: '%ls' Size: %d.", FileName.c_str(), NarrowFileData.size());

		TransfersInProgress.erase(Iter);

		FGameEvent GameEvent(EGameEventType::FileTransferFinished, CurrentTransferName);
		FGame::Get().OnGameEvent(GameEvent);

		if (FileName == CurrentTransferName)
		{
			ClearCurrentTransfer();
		}
	}
}

void FPlayerDataStorage::FinishFileUpload(const std::wstring& FileName)
{
	auto Iter = TransfersInProgress.find(FileName);
	if (Iter != TransfersInProgress.end())
	{
		FTransferInProgress& Transfer = Iter->second;

		if (Transfer.bDownload)
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: error while file write operation: can't finish because of download/upload mismatch.");
			return;
		}

		if (!Transfer.Done())
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: error while file write operation: unexpected end of transfer.");
		}

		TransfersInProgress.erase(Iter);

		FGameEvent GameEvent(EGameEventType::FileTransferFinished, CurrentTransferName);
		FGame::Get().OnGameEvent(GameEvent);

		if (FileName == CurrentTransferName)
		{
			ClearCurrentTransfer();
		}
	}
}

void FPlayerDataStorage::Update()
{

}

void FPlayerDataStorage::OnLoggedIn(FProductUserId UserId)
{
	QueryList();
}

void FPlayerDataStorage::OnLoggedOut(FProductUserId UserId)
{
	StorageData.clear();
	ClearCurrentTransfer();
}

void FPlayerDataStorage::ClearCurrentTransfer()
{
	CurrentTransferName.clear();
	CurrentTransferProgress = 0.0f;

	if (CurrentTransferHandle)
	{
		EOS_PlayerDataStorageFileTransferRequest_Release(CurrentTransferHandle);
		CurrentTransferHandle = nullptr;
	}
}

void FPlayerDataStorage::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		FProductUserId UserId = Event.GetProductUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserConnectAuthExpiration)
	{
		FProductUserId UserId = Event.GetProductUserId();
		OnLoggedOut(UserId);
	}
}


void EOS_CALL FPlayerDataStorage::OnFileListRetrieved(const EOS_PlayerDataStorage_QueryFileListCallbackInfo* Data)
{
	if (Data)
	{
		if (Data->ResultCode == EOS_EResult::EOS_Success)
		{
			PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
			if (Player == nullptr || !Player->GetProductUserID().IsValid())
			{
				return;
			}

			FDebugLog::Log(L"[EOS SDK] Player data storage file list is successfully retrieved.");

			const size_t FileCount = Data->FileCount;
			std::vector<std::wstring> FileNames;
			EOS_HPlayerDataStorage PlayerStorageHandle = EOS_Platform_GetPlayerDataStorageInterface(FPlatform::GetPlatformHandle());
			for (size_t FileIndex = 0; FileIndex < FileCount; ++FileIndex)
			{
				EOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions Options = {};
				Options.ApiVersion = EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEX_API_LATEST;

				Options.LocalUserId = Player->GetProductUserID();
				Options.Index = static_cast<uint32_t>(FileIndex);

				EOS_PlayerDataStorage_FileMetadata* FileMetadata = nullptr;

				EOS_PlayerDataStorage_CopyFileMetadataAtIndex(PlayerStorageHandle, &Options, &FileMetadata);

				if (FileMetadata)
				{
					if (FileMetadata->Filename)
					{
						std::wstring FileName = FStringUtils::Widen(FileMetadata->Filename);

						FileNames.push_back(FileName);

						if (FileMetadata->MD5Hash)
						{
							std::wstring MD5Hash = FStringUtils::Widen(FileMetadata->MD5Hash);

							std::wstring LastModifiedTimeStrW = L"Undefined";
							if (FileMetadata->LastModifiedTime != EOS_PLAYERDATASTORAGE_TIME_UNDEFINED)
							{
								LastModifiedTimeStrW = FUtils::ConvertUnixTimestampToUTCString(FileMetadata->LastModifiedTime);
							}

							FDebugLog::Log(L"[EOS SDK] File List Retrieved - Filename: %ls, FileSizeBytes: %u, UnencryptedDataSizeBytes: %u, MD5Hash: %ls, LastModifiedTime: %ls",
								FileName.c_str(), FileMetadata->FileSizeBytes, FileMetadata->UnencryptedDataSizeBytes, MD5Hash.c_str(), LastModifiedTimeStrW.c_str());
						}
					}

					EOS_PlayerDataStorage_FileMetadata_Release(FileMetadata);
				}
			}

			FGame::Get().GetPlayerDataStorage()->SetFileList(FileNames);
		}
		else
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: file list retrieval error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
	}
}



EOS_PlayerDataStorage_EReadResult EOS_CALL FPlayerDataStorage::OnFileDataReceived(const EOS_PlayerDataStorage_ReadFileDataCallbackInfo* Data)
{
	if (Data)
	{
		return FGame::Get().GetPlayerDataStorage()->ReceiveData(FStringUtils::Widen(Data->Filename), Data->DataChunk, Data->DataChunkLengthBytes, Data->TotalFileSizeBytes);
	}
	return EOS_PlayerDataStorage_EReadResult::EOS_RR_FailRequest;
}

void EOS_CALL FPlayerDataStorage::OnFileReceived(const EOS_PlayerDataStorage_ReadFileCallbackInfo* Data)
{
	if (Data)
	{
		if (Data->ResultCode == EOS_EResult::EOS_Success)
		{
			FGame::Get().GetPlayerDataStorage()->FinishFileDownload(FStringUtils::Widen(Data->Filename), true);
		}
		else
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: could not download file: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
			FGame::Get().GetPlayerDataStorage()->FinishFileDownload(FStringUtils::Widen(Data->Filename), false);
		}
	}
}

EOS_PlayerDataStorage_EWriteResult EOS_CALL FPlayerDataStorage::OnFileDataSend(const EOS_PlayerDataStorage_WriteFileDataCallbackInfo* Data, void* OutDataBuffer, uint32_t* OutDataWritten)
{
	if (Data)
	{
		return FGame::Get().GetPlayerDataStorage()->SendData(FStringUtils::Widen(Data->Filename), OutDataBuffer, OutDataWritten);
	}
	return EOS_PlayerDataStorage_EWriteResult::EOS_WR_FailRequest;
}

void EOS_CALL FPlayerDataStorage::OnFileSent(const EOS_PlayerDataStorage_WriteFileCallbackInfo* Data)
{
	if (Data)
	{
		if (Data->ResultCode == EOS_EResult::EOS_Success)
		{
			PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
			if (Player == nullptr || !Player->GetProductUserID().IsValid())
			{
				return;
			}

			EOS_HPlayerDataStorage PlayerStorageHandle = EOS_Platform_GetPlayerDataStorageInterface(FPlatform::GetPlatformHandle());
			EOS_PlayerDataStorage_CopyFileMetadataByFilenameOptions Options = {};
			Options.ApiVersion = EOS_PLAYERDATASTORAGE_COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST;
			Options.LocalUserId = Player->GetProductUserID();
			Options.Filename = Data->Filename;

			EOS_PlayerDataStorage_FileMetadata* FileMetadata = nullptr;
			EOS_PlayerDataStorage_CopyFileMetadataByFilename(PlayerStorageHandle, &Options, &FileMetadata);

			if (FileMetadata)
			{
				if (FileMetadata->Filename && FileMetadata->MD5Hash)
				{
					std::wstring FileName = FStringUtils::Widen(FileMetadata->Filename);
					std::wstring MD5Hash = FStringUtils::Widen(FileMetadata->MD5Hash);

					std::wstring LastModifiedTimeStrW = L"Undefined";
					if (FileMetadata->LastModifiedTime != EOS_PLAYERDATASTORAGE_TIME_UNDEFINED)
					{
						LastModifiedTimeStrW = FUtils::ConvertUnixTimestampToUTCString(FileMetadata->LastModifiedTime);
					}

					FDebugLog::Log(L"[EOS SDK] File Sent - Filename: %ls, FileSizeBytes: %u, UnencryptedDataSizeBytes: %u, MD5Hash: %ls, LastModifiedTime: %ls",
						FileName.c_str(), FileMetadata->FileSizeBytes, FileMetadata->UnencryptedDataSizeBytes, MD5Hash.c_str(), LastModifiedTimeStrW.c_str());
				}

				EOS_PlayerDataStorage_FileMetadata_Release(FileMetadata);
			}
		}
		else
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: could not upload file: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		FGame::Get().GetPlayerDataStorage()->FinishFileUpload(FStringUtils::Widen(Data->Filename));
	}
}

void EOS_CALL FPlayerDataStorage::OnFileTransferProgressUpdated(const EOS_PlayerDataStorage_FileTransferProgressCallbackInfo* Data)
{
	if (Data)
	{
		if (Data->TotalFileSizeBytes > 0)
		{
			FGame::Get().GetPlayerDataStorage()->UpdateProgress(FStringUtils::Widen(Data->Filename), float(Data->BytesTransferred) / Data->TotalFileSizeBytes);
			FDebugLog::Log(L"[EOS SDK] Player data storage: transfer progress %d / %d.", Data->BytesTransferred, Data->TotalFileSizeBytes);
		}
	}
}

void EOS_CALL FPlayerDataStorage::OnFileCopied(const EOS_PlayerDataStorage_DuplicateFileCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: error while copying the file: %ls.", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FGame::Get().GetPlayerDataStorage()->QueryList();
		}
	}
}

void EOS_CALL FPlayerDataStorage::OnFileRemoved(const EOS_PlayerDataStorage_DeleteFileCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"[EOS SDK] Player data storage: error while removing file: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FGame::Get().GetPlayerDataStorage()->QueryList();
		}
	}
}

```

`EAC_SDK/Samples/PlayerDataStorage/Source/PlayerDataStorage.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_sdk.h>
#include <eos_playerdatastorage_types.h>
#include <eos_playerdatastorage.h>

/**
* Manages player data storage for local user
*/
class FPlayerDataStorage
{
public:
	/**
	* Constructor
	*/
	FPlayerDataStorage() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FPlayerDataStorage(FPlayerDataStorage const&) = delete;
	FPlayerDataStorage& operator=(FPlayerDataStorage const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FPlayerDataStorage();

	void Update();

	/** 
	* Remote operations follow. They trigger online requests to the backend services.
	*/

	/**
	* Refresh list of player data entries. Asynchronous operation.
	*/
	void QueryList();

	/**
	* Retrieve contents of specific file
	*/
	void StartFileDataDownload(const std::wstring& FileName);

	/**
	* Transmit contents of specific file to cloud
	*/
	bool StartFileDataUpload(const std::wstring& FileName);

	/** 
	* Add new file or overwrite existing one.
	*/
	void AddFile(const std::wstring& EntryName, const std::wstring& Data);

	/** 
	* Create a copy of existing file's data.
	*/
	void CopyFile(const std::wstring& FileSourceName, const std::wstring& FileDestName);

	/** 
	* Remove existing file and any cached data related to it.
	*/
	void RemoveFile(const std::wstring& EntryName);

	/** 
	* Cancel current file transfer (if any).
	*/
	void CancelCurrentTransfer();


	/** 
	* Functions that work with local data follow. These functions do not trigger any online queries but work with local data instead.
	*/

	/** 
	* Returns locally cached list of files.
	*/
	std::vector<std::wstring> GetFileList() const;

	/** 
	* Sets local list of files.
	*/
	void SetFileList(const std::vector<std::wstring>& FileNames);

	/** 
	* Returns locally cached data for file specified. NoData flag is set to true when there is no data available locally.
	*/
	std::wstring GetLocalData(const std::wstring& EntryName, bool& NoData) const;

	/** 
	* Sets local data for file specified.
	*/
	void SetLocalData(const std::wstring& EntryName, const std::wstring& Data);

	/** 
	* Erases local data for specified file (if any).
	*/
	void EraseLocalData(const std::wstring& EntryName);

	/** 
	* Gets the name of file that is being transferred at the moment.
	*/
	const std::wstring& GetCurrentTransferName() const { return CurrentTransferName; }

	/** 
	* Gets current progress of the file transfer (in the range [0.0f, 1.0f]).
	*/
	float GetCurrentTransferProgress() const { return CurrentTransferProgress; }

	//Called on async operations progress
	EOS_PlayerDataStorage_EReadResult ReceiveData(const std::wstring& FileName, const void* Data, size_t NumBytes, size_t TotalSize);
	EOS_PlayerDataStorage_EWriteResult SendData(const std::wstring& FileName, void* Data, uint32_t* BytesWritten);
	void UpdateProgress(const std::wstring& FileName, float Progress);
	void FinishFileDownload(const std::wstring& FileName, bool bSuccess);
	void FinishFileUpload(const std::wstring& FileName);

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/**
	* Callback that is fired when the query file list async operation completes, either successfully or in error
	*
	* @param Data - Output parameters for the EOS_PlayerDataStorage_QueryFileList Function
	*/
	static void EOS_CALL OnFileListRetrieved(const EOS_PlayerDataStorage_QueryFileListCallbackInfo* Data);

	/**
	* Callback that is fired when file data is received.
	*
	* @param Data - Output parameters for the  Function
	*/
	static EOS_PlayerDataStorage_EReadResult EOS_CALL OnFileDataReceived(const EOS_PlayerDataStorage_ReadFileDataCallbackInfo* Data);

	/**
	* Callback that is fired when file transfer from cloud is completed.
	*
	* @param Data - Output parameters
	*/
	static void EOS_CALL OnFileReceived(const EOS_PlayerDataStorage_ReadFileCallbackInfo* Data);

	/**
	* Callback that is fired when file data is to be sent to cloud.
	*
	* @param Data - Output parameters for the  Function
	*/
	static EOS_PlayerDataStorage_EWriteResult EOS_CALL OnFileDataSend(const EOS_PlayerDataStorage_WriteFileDataCallbackInfo* Data, void* OutDataBuffer, uint32_t* OutDataWritten);

	/**
	* Callback that is fired when file transfer to cloud is completed.
	*
	* @param Data - Output parameters
	*/
	static void EOS_CALL OnFileSent(const EOS_PlayerDataStorage_WriteFileCallbackInfo* Data);

	/**
	* Callback that is fired when we get information about transfer progress
	*
	* @param Data - file transfer progress
	*/
	static void EOS_CALL OnFileTransferProgressUpdated(const EOS_PlayerDataStorage_FileTransferProgressCallbackInfo* Data);

	/**
	* Callback that is fired when we get confirmation that the file has been copied on the cloud (or error occurred).
	*
	* @param Data - out parameter
	*/
	static void EOS_CALL OnFileCopied(const EOS_PlayerDataStorage_DuplicateFileCallbackInfo* Data);
	

	/**
	* Callback that is fired when we get confirmation that the file has been removed from cloud (or error occurred).
	*
	* @param Data - out parameter
	*/
	static void EOS_CALL OnFileRemoved(const EOS_PlayerDataStorage_DeleteFileCallbackInfo* Data);

private:

	/**
	* Called when a user has logged in
	*/
	void OnLoggedIn(FProductUserId UserId);

	/**
	* Called when a user has logged out
	*/
	void OnLoggedOut(FProductUserId UserId);

	void ClearCurrentTransfer();

	// The name of file we are currently downloading or uploading
	std::wstring CurrentTransferName;

	//Current primary active transfer (upload or download).
	EOS_HPlayerDataStorageFileTransferRequest CurrentTransferHandle = nullptr;

	// The progress we made so far while transmitting file.
	float CurrentTransferProgress;

	/** Map of player data entries. Key - entry name, Value - pair (bool: is data present locally ; string: entry data). */
	std::unordered_map<std::wstring, std::pair<bool, std::wstring>> StorageData;

	struct FTransferInProgress
	{
		bool bDownload = true;
		size_t TotalSize = 0;
		size_t CurrentIndex = 0;
		std::vector<char> Data;

		bool Done() const { return TotalSize == CurrentIndex; }
	};

	std::unordered_map <std::wstring, FTransferInProgress> TransfersInProgress;
};

```

`EAC_SDK/Samples/PlayerDataStorage/Source/PlayerDataStorageDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "PlayerDataStorageDialog.h"
#include "TextEditor.h"
#include "PlayerDataStorage.h"

template<>
std::shared_ptr<FPlayerDataStorageInfo> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& Data)
{
	return std::make_shared<FPlayerDataStorageInfo>(Pos, Size, Layer, Data, L"Assets/black_grey_button.dds");
}

const Vector2 FileEditorPosition = Vector2(10.0f, 120.0f);

FPlayerDataStorageDialog::FPlayerDataStorageDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	HeaderLabel = std::make_shared<FTextLabelWidget>(
		FileEditorPosition,
		Vector2(500.0f, 20.0f),
		Layer - 1,
		std::wstring(L"Player Data: "),
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	HeaderLabel->SetFont(DialogNormalFont);

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/texteditor.dds");

	PlayerDataList = std::make_shared<FPlayerDataList>(
		DialogPos,
		DialogSize,
		DialogLayer - 1,
		20.0f, //entry height
		20.0f, //label height
		15.0f, //scroller width
		L"", //background
		L"",
		DialogNormalFont,
		DialogNormalFont,
		DialogSmallFont,
		DialogTinyFont);

	TextEditorLabel = std::make_shared<FTextLabelWidget>(
		FileEditorPosition,
		Vector2(500.0f, 20.0f),
		Layer - 1,
		L"FILE",
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	TextEditorLabel->SetFont(DialogSmallFont);
	TextEditorLabel->SetBorderColor(Color::UIBorderGrey);

	TextEditor = std::make_shared<FTextEditorWidget>(
		FileEditorPosition + Vector2(0.0f, 20.0f),
		Vector2(500.0f, 500.0f),
		DialogLayer - 1,
		L"",
		L"Assets/texteditor.dds",
		DialogNormalFont
		);
	TextEditor->SetBorderOffsets(Vector2(10.0f, 10.0f));
	TextEditor->SetBorderColor(Color::UIBorderGrey);

	Vector2 RefreshButtonSize(20.0f, 20.0f);
	Vector2 ButtonSize((DialogSize.x - 15.0f) / 4.0f, 35.0f);
	Vector2 ButtonVerticalOffset(0.0f, 25.0f);
	Vector2 ButtonHorizontalOffset(ButtonSize.x + 4.0f, 0.0f);

	RefreshListButton = std::make_shared<FButtonWidget>(
		DialogPos + Vector2(HeaderLabel->GetSize().x - 20.0f, 0.0f),
		RefreshButtonSize,
		DialogLayer - 1,
		L"",
		std::vector<std::wstring>({ L"Assets/refresh.dds" }),
		DialogSmallFont,
		Color::White,
		Color::White
		);
	RefreshListButton->SetOnPressedCallback([]()
	{
		//send refresh request
		FGame::Get().GetPlayerDataStorage()->QueryList();
	});
	RefreshListButton->SetBackgroundColors(assets::DefaultButtonColors);

	DownloadFileButton = std::make_shared<FButtonWidget>(
		DialogPos - ButtonVerticalOffset + ButtonHorizontalOffset,
		ButtonSize,
		DialogLayer - 1,
		L"DOWNLOAD",
		assets::LargeButtonAssets,
		DialogTinyFont,
		Color::White,
		Color::White
		);
	DownloadFileButton->SetOnPressedCallback([this]()
	{
		//get selected file name
		const std::wstring& CurrentSelectionFileName = this->GetCurrentSelection();

		if (!CurrentSelectionFileName.empty())
		{
			//send download request
			FGame::Get().GetPlayerDataStorage()->StartFileDataDownload(CurrentSelectionFileName);
		}
	});
	DownloadFileButton->SetBackgroundColors(assets::DefaultButtonColors);

	SaveFileButton = std::make_shared<FButtonWidget>(
		DialogPos - ButtonVerticalOffset + ButtonHorizontalOffset * 2,
		ButtonSize,
		DialogLayer - 1,
		L"SAVE",
		assets::LargeButtonAssets,
		DialogTinyFont,
		Color::White,
		Color::White
		);
	SaveFileButton->SetOnPressedCallback([this]()
	{
		//get selected file name
		const std::wstring& CurrentSelectionFileName = this->GetCurrentSelection();

		if (!CurrentSelectionFileName.empty())
		{
			//set local data and upload it
			FGame::Get().GetPlayerDataStorage()->AddFile(CurrentSelectionFileName, this->GetEditorContents());
		}
	});
	SaveFileButton->SetBackgroundColors(assets::DefaultButtonColors);

	DuplicateFileButton = std::make_shared<FButtonWidget>(
		DialogPos - ButtonVerticalOffset + ButtonHorizontalOffset * 3,
		ButtonSize,
		DialogLayer - 1,
		L"DUPLICATE",
		assets::LargeButtonAssets,
		DialogTinyFont,
		Color::White,
		Color::White
		);
	DuplicateFileButton->SetOnPressedCallback([this]()
	{
		//get selected file name
		const std::wstring& CurrentSelectionFileName = this->GetCurrentSelection();

		if (!CurrentSelectionFileName.empty())
		{
			//send copy request
			//TODO: add text field to enter new name
			FGame::Get().GetPlayerDataStorage()->CopyFile(CurrentSelectionFileName, CurrentSelectionFileName + L"_Copy");
		}
	});
	DuplicateFileButton->SetBackgroundColors(assets::DefaultButtonColors);

	DeleteFileButton = std::make_shared<FButtonWidget>(
		DialogPos - ButtonVerticalOffset + ButtonHorizontalOffset * 4,
		ButtonSize,
		DialogLayer - 1,
		L"DELETE",
		assets::LargeButtonAssets,
		DialogTinyFont,
		Color::White,
		Color::White
		);
	DeleteFileButton->SetOnPressedCallback([this]()
	{
		//get selected file name
		const std::wstring& CurrentSelectionFileName = this->GetCurrentSelection();

		if (!CurrentSelectionFileName.empty())
		{
			//send removal request
			FGame::Get().GetPlayerDataStorage()->RemoveFile(CurrentSelectionFileName);
			this->ClearCurrentSelection();
		}
	});
	DeleteFileButton->SetBackgroundColors(assets::DefaultButtonColors);
}

void FPlayerDataStorageDialog::Update()
{
	NameList = FGame::Get().GetPlayerDataStorage()->GetFileList();
	NameList.push_back(L"New File");

	if (PlayerDataList)
	{
		PlayerDataList->RefreshData(NameList);
	}

	FDialog::Update();

	if (PlayerDataList)
	{
		PlayerDataList->Update();
	}
}

void FPlayerDataStorageDialog::Create()
{
	if (HeaderLabel) HeaderLabel->Create();
	if (BackgroundImage) BackgroundImage->Create();
	if (PlayerDataList) PlayerDataList->Create();
	if (TextEditorLabel) TextEditorLabel->Create();
	if (TextEditor)	TextEditor->Create();

	//make entries invisible until player logs in
	if (PlayerDataList)
	{
		PlayerDataList->SetEntriesVisible(false);
		PlayerDataList->SetOnEntrySelectedCallback([this](size_t Index) { this->OnDataStorageEntrySelected(Index); });
	}

	if (RefreshListButton) RefreshListButton->Create();
	if (DownloadFileButton) DownloadFileButton->Create();
	if (SaveFileButton) SaveFileButton->Create();
	if (DuplicateFileButton) DuplicateFileButton->Create();
	if (DeleteFileButton) DeleteFileButton->Create();

	AddWidget(HeaderLabel);
	AddWidget(BackgroundImage);
	AddWidget(PlayerDataList);
	AddWidget(TextEditorLabel);
	AddWidget(TextEditor);

	AddWidget(RefreshListButton);
	AddWidget(DownloadFileButton);
	AddWidget(SaveFileButton);
	AddWidget(DuplicateFileButton);
	AddWidget(DeleteFileButton);
}

void FPlayerDataStorageDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (HeaderLabel) HeaderLabel->SetPosition(Pos);
	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y + 20.f));
	if (TextEditorLabel) TextEditorLabel->SetPosition(Vector2(FileEditorPosition.x, FileEditorPosition.y));
	if (TextEditor) TextEditor->SetPosition(Vector2(FileEditorPosition.x, FileEditorPosition.y + TextEditorLabel->GetSize().y));

	const Vector2 RefreshButtonSize(20.0f, 20.0f);

	if (RefreshListButton) RefreshListButton->SetPosition(Pos + Vector2(HeaderLabel->GetSize().x - RefreshButtonSize.x, 0.0f));

	Vector2 ButtonSize((GetSize().x - 12) / 4.0f, 35.0f);
	Vector2 ButtonVerticalOffset(0.0f, 25.0f);
	Vector2 InitialButtonHorizOffset(2.0f, 0.0f);
	Vector2 ButtonHorizontalOffset(ButtonSize.x + 3.0f, 0.0f);

	Vector2 CurrentButtonPos = Pos + ButtonVerticalOffset + InitialButtonHorizOffset;

	if (SaveFileButton) SaveFileButton->SetPosition(CurrentButtonPos);
	CurrentButtonPos = CurrentButtonPos + ButtonHorizontalOffset;
	if (DownloadFileButton) DownloadFileButton->SetPosition(CurrentButtonPos);
	CurrentButtonPos = CurrentButtonPos + ButtonHorizontalOffset;
	if (DuplicateFileButton) DuplicateFileButton->SetPosition(CurrentButtonPos);
	CurrentButtonPos = CurrentButtonPos + ButtonHorizontalOffset;
	if (DeleteFileButton) DeleteFileButton->SetPosition(CurrentButtonPos);

	if (PlayerDataList) PlayerDataList->SetPosition(Position + Vector2(3.0f, HeaderLabel->GetSize().y + 4.0f));
}

void FPlayerDataStorageDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	Vector2 ButtonSize((GetSize().x - 12) / 4.0f, 35.0f);
	if (SaveFileButton) SaveFileButton->SetSize(ButtonSize);
	if (DownloadFileButton) DownloadFileButton->SetSize(ButtonSize);
	if (DuplicateFileButton) DuplicateFileButton->SetSize(ButtonSize);
	if (DeleteFileButton) DeleteFileButton->SetSize(ButtonSize);
}

void FPlayerDataStorageDialog::SetWindowSize(Vector2 WindowSize)
{
	const Vector2 PlayerListSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 40.0f, WindowSize.y - 200.0f - FileEditorPosition.y);
	const Vector2 DialogSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 30.0f, WindowSize.y - 90.0f);

	if (TextEditorLabel) TextEditorLabel->SetSize(Vector2(ConsoleWindowProportion.x * WindowSize.x, 20.0f));
	if (TextEditor) TextEditor->SetSize(Vector2(ConsoleWindowProportion.x * WindowSize.x, (1.0f - ConsoleWindowProportion.y) * WindowSize.y - FileEditorPosition.y - 50.0f));
	if (BackgroundImage) BackgroundImage->SetSize(DialogSize);
	if (PlayerDataList) PlayerDataList->SetSize(PlayerListSize);
	if (HeaderLabel) HeaderLabel->SetSize(Vector2(DialogSize.x, 20.0f));
}

void FPlayerDataStorageDialog::UpdateUserInfo()
{
	if (HeaderLabel)
	{
		HeaderLabel->SetText(L"Player Data: log in to proceed.");
		if (FPlayerManager::Get().GetCurrentUser().IsValid())
		{
			std::wstring DisplayName = FPlayerManager::Get().GetDisplayName(FPlayerManager::Get().GetCurrentUser());
			HeaderLabel->SetText(std::wstring(L"Player Data: ") + DisplayName);
		}
	}
}

void FPlayerDataStorageDialog::ClearDataList()
{
	PlayerDataList->Reset();
	TextEditor->Clear();
}

void FPlayerDataStorageDialog::ShowDataList()
{
	PlayerDataList->SetEntriesVisible(true);
}

void FPlayerDataStorageDialog::HideDataList()
{
	PlayerDataList->SetEntriesVisible(false);
	SetFocused(false);
}

void FPlayerDataStorageDialog::OnDataStorageEntrySelected(size_t Index)
{
	if (Index >= NameList.size())
		return;

	//New file selected?
	bool bNewFileSelected = (Index == NameList.size() - 1);

	std::wstring Name = NameList[Index];

	if (!CurrentSelection.empty())
	{
		FGame::Get().GetPlayerDataStorage()->SetLocalData(CurrentSelection, TextEditor->GetText());
		CurrentSelection.clear();
	}

	TextEditor->Clear();

	if (!bNewFileSelected)
	{
		CurrentSelection = Name;

		bool bNoData = false;
		std::wstring Data = FGame::Get().GetPlayerDataStorage()->GetLocalData(Name, bNoData);

		if (!bNoData)
		{
			TextEditor->SetText(Data);
			TextEditor->SetEditingEnabled(true);
		}
		else
		{
			TextEditor->SetText(L"* No local data available for the file selected.\n   Please press 'DOWNLOAD' to get data from the cloud. *");
			TextEditor->SetEditingEnabled(false);
		}
	}
	else
	{
		//New File
		FGameEvent NewFileEvent(EGameEventType::NewFileCreationStarted);
		FGame::Get().OnGameEvent(NewFileEvent);
	}
}

std::wstring FPlayerDataStorageDialog::GetEditorContents() const
{
	if (TextEditor)
	{
		return TextEditor->GetText();
	}

	return std::wstring();
}

void FPlayerDataStorageDialog::ClearCurrentSelection()
{
	CurrentSelection.clear();
	if (PlayerDataList)
	{
		PlayerDataList->SetFocused(false);
	}
	if (TextEditor)
	{
		TextEditor->Clear();
	}
}

void FPlayerDataStorageDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		UpdateUserInfo();
		ShowDataList();
	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		UpdateUserInfo();
		PlayerDataList->SetEntriesVisible(false);
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		UpdateUserInfo();
		PlayerDataList->SetEntriesVisible(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		UpdateUserInfo();
		if (FPlayerManager::Get().GetNumPlayers() == 0)
		{
			ClearDataList();
			HideDataList();
		}
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		ClearDataList();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		ClearDataList();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		UpdateUserInfo();
		ClearDataList();
		HideDataList();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		ShowDataList();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::FileTransferFinished)
	{
		const std::wstring& FileName = Event.GetFirstStr();
		if (FileName == CurrentSelection && TextEditor)
		{
			bool NoData = false;
			std::wstring Data = FGame::Get().GetPlayerDataStorage()->GetLocalData(FileName, NoData);
			TextEditor->Clear();
			TextEditor->SetText(Data);
			TextEditor->SetEditingEnabled(true);
		}
	}
}

void FPlayerDataStorageInfo::SetFocused(bool bValue)
{
	if (BackgroundImage && bValue != IsFocused())
	{
		FColor CurrentColor = BackgroundImage->GetBackgroundColor();

		const float Diff = 0.3f;
		FColor Adjustment = (bValue) ? FColor(Diff, Diff, Diff, Diff) : FColor(-Diff, -Diff, -Diff, 0.0f);

		CurrentColor.A += Adjustment.A;
		CurrentColor.R += Adjustment.R;
		CurrentColor.G += Adjustment.G;
		CurrentColor.B += Adjustment.B;

		BackgroundImage->SetBackgroundColor(CurrentColor);
	}

	FTextLabelWidget::SetFocused(bValue);
}

```

`EAC_SDK/Samples/PlayerDataStorage/Source/PlayerDataStorageDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "ListView.h"

class FPlayerDataStorageInfo : public FTextLabelWidget
{
public:
	FPlayerDataStorageInfo(Vector2 LabelPos,
		Vector2 LabelSize,
		UILayer LabelLayer,
		const std::wstring& LabelText,
		const std::wstring& LabelAssetFile) : FTextLabelWidget(LabelPos, LabelSize, LabelLayer, LabelText, LabelAssetFile, Color::White)
	{}

	void SetFocused(bool bValue) override;
};

template<>
std::shared_ptr<FPlayerDataStorageInfo> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& Data);



using FPlayerDataList = FListViewWidget<std::wstring, FPlayerDataStorageInfo>;

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;
class FTextEditorWidget;

/**
 * Player Data Storage dialog
 */
class FPlayerDataStorageDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FPlayerDataStorageDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FPlayerDataStorageDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	void SetWindowSize(Vector2 WindowSize);
	void SetWindowProportion(Vector2 InWindowProportion) { ConsoleWindowProportion = InWindowProportion; }
	void UpdateUserInfo();
	void ClearDataList();
	void ShowDataList();
	void HideDataList();

	void OnDataStorageEntrySelected(size_t Index);
	const std::wstring& GetCurrentSelection() const { return CurrentSelection; }
	std::wstring GetEditorContents() const;
	void ClearCurrentSelection();

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

private:
	/** Header label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** List of player data entries */
	std::shared_ptr<FPlayerDataList> PlayerDataList;

	/** File editor label */
	std::shared_ptr<FTextLabelWidget> TextEditorLabel;

	/** Text Editor to make changes in player data */
	std::shared_ptr<FTextEditorWidget> TextEditor;

	/** List of entries */
	std::vector<std::wstring> NameList;

	/** Button to refresh list */
	std::shared_ptr<FButtonWidget> RefreshListButton;

	/** Button to download file */
	std::shared_ptr<FButtonWidget> DownloadFileButton;

	/** Button to upload file */
	std::shared_ptr<FButtonWidget> SaveFileButton;

	/** Button to duplicate file */
	std::shared_ptr<FButtonWidget> DuplicateFileButton;

	/** Button to delete file */
	std::shared_ptr<FButtonWidget> DeleteFileButton;

	/** Currently selected entry */
	std::wstring CurrentSelection;

	/** Part of window that console is taking */
	Vector2 ConsoleWindowProportion;
};

```

`EAC_SDK/Samples/PlayerDataStorage/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Player Data Storage";

	/** Encryption key. Not used by this sample. 64 hex characters */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/PlayerDataStorage/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/PlayerDataStorage/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/Samples.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <EOSSDKIncludes>..\..\SDK\Include\</EOSSDKIncludes>
    <EOSSDKLibs>..\..\SDK\Lib\</EOSSDKLibs>
    <EOSSDKDLLs>..\..\SDK\Bin\</EOSSDKDLLs>
    <EOSSDKSamplesRoot>..</EOSSDKSamplesRoot>
    <SteamSDK>..\Shared\External\SteamSDK</SteamSDK>
    <XAudio2_9Bin>..\..\SDK\Bin\</XAudio2_9Bin>
  </PropertyGroup>
  <PropertyGroup />
  <ItemDefinitionGroup />
  <ItemGroup>
    <BuildMacro Include="EOSSDKIncludes">
      <Value>$(EOSSDKIncludes)</Value>
    </BuildMacro>
    <BuildMacro Include="EOSSDKLibs">
      <Value>$(EOSSDKLibs)</Value>
    </BuildMacro>
    <BuildMacro Include="EOSSDKDLLs">
      <Value>$(EOSSDKDLLs)</Value>
    </BuildMacro>
    <BuildMacro Include="EOSSDKSamplesRoot">
      <Value>$(EOSSDKSamplesRoot)</Value>
    </BuildMacro>
	<BuildMacro Include="SteamSDK">
      <Value>$(SteamSDK)</Value>
    </BuildMacro>
	<BuildMacro Include="XAudio2_9Bin">
      <Value>$(XAudio2_9Bin)</Value>
    </BuildMacro>
  </ItemGroup>
  <PropertyGroup Label="Debugging Properties" Condition="'$(Platform)'=='Win32'">
    <LocalDebuggerWorkingDirectory>$(ProjectDir)Bin\Win32\$(Configuration)</LocalDebuggerWorkingDirectory>
	<DisableFastUpToDateCheck>true</DisableFastUpToDateCheck>
  </PropertyGroup>
  <PropertyGroup Label="Debugging Properties" Condition="'$(Platform)'=='x64'">
    <LocalDebuggerWorkingDirectory>$(ProjectDir)Bin\Win64\$(Configuration)</LocalDebuggerWorkingDirectory>
	<DisableFastUpToDateCheck>true</DisableFastUpToDateCheck>
  </PropertyGroup>
</Project>
```

`EAC_SDK/Samples/Samples.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.421
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AuthAndFriends", "AuthAndFriends\AuthAndFriends.vcxproj", "{4C365618-2FAB-4A1D-8574-AEBA7CF96907}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "P2PNAT", "P2PNAT\P2PNAT.vcxproj", "{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SessionMatchmaking", "SessionMatchmaking\SessionMatchmaking.vcxproj", "{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Store", "Store\Store.vcxproj", "{323C59E5-555F-4DE4-86F2-D9572C00EC25}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PlayerDataStorage", "PlayerDataStorage\PlayerDataStorage.vcxproj", "{84505A35-14BE-4A4D-9029-BF5AD22897DC}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Achievements", "Achievements\Achievements.vcxproj", "{DE49D417-147B-4684-9FE1-3B733AF02889}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Leaderboard", "Leaderboard\Leaderboard.vcxproj", "{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Lobbies", "Lobbies\Lobbies.vcxproj", "{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Mods", "Mods\Mods.vcxproj", "{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TitleStorage", "TitleStorage\TitleStorage.vcxproj", "{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Voice", "Voice\Client\Voice.vcxproj", "{62B2385D-FB11-4768-AC67-FEC93481FB03}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VoiceServer", "Voice\Server\VoiceServer.vcxproj", "{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AntiCheat", "AntiCheat\Client\AntiCheat.vcxproj", "{60F44F5F-335C-4080-B282-0CB14249BD5B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AntiCheatServer", "AntiCheat\Server\AntiCheatServer.vcxproj", "{66E419CA-A396-4A05-BE97-300BFAE97825}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug_DX|x64 = Debug_DX|x64
		Debug_DX|x86 = Debug_DX|x86
		Debug_SDL|x64 = Debug_SDL|x64
		Debug_SDL|x86 = Debug_SDL|x86
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release_DX|x64 = Release_DX|x64
		Release_DX|x86 = Release_DX|x86
		Release_SDL|x64 = Release_SDL|x64
		Release_SDL|x86 = Release_SDL|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
		Steam_Debug_DX|x64 = Steam_Debug_DX|x64
		Steam_Debug_DX|x86 = Steam_Debug_DX|x86
		Steam_Debug_SDL|x64 = Steam_Debug_SDL|x64
		Steam_Debug_SDL|x86 = Steam_Debug_SDL|x86
		Steam_Release_DX|x64 = Steam_Release_DX|x64
		Steam_Release_DX|x86 = Steam_Release_DX|x86
		Steam_Release_SDL|x64 = Steam_Release_SDL|x64
		Steam_Release_SDL|x86 = Steam_Release_SDL|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug|x64.Build.0 = Debug_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Debug|x86.Build.0 = Debug_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release_DX|x64.Build.0 = Release_DX|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release_DX|x86.Build.0 = Release_DX|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release|x64.ActiveCfg = Release_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release|x64.Build.0 = Release_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release|x86.ActiveCfg = Release_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Release|x86.Build.0 = Release_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Debug_DX|x64.ActiveCfg = Steam_Debug_DX|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Debug_DX|x64.Build.0 = Steam_Debug_DX|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Debug_DX|x86.ActiveCfg = Steam_Debug_DX|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Debug_DX|x86.Build.0 = Steam_Debug_DX|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Debug_SDL|x64.ActiveCfg = Steam_Debug_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Debug_SDL|x64.Build.0 = Steam_Debug_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Debug_SDL|x86.ActiveCfg = Steam_Debug_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Debug_SDL|x86.Build.0 = Steam_Debug_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Release_DX|x64.ActiveCfg = Steam_Release_DX|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Release_DX|x64.Build.0 = Steam_Release_DX|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Release_DX|x86.ActiveCfg = Steam_Release_DX|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Release_DX|x86.Build.0 = Steam_Release_DX|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Release_SDL|x64.ActiveCfg = Steam_Release_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Release_SDL|x64.Build.0 = Steam_Release_SDL|x64
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Release_SDL|x86.ActiveCfg = Steam_Release_SDL|Win32
		{4C365618-2FAB-4A1D-8574-AEBA7CF96907}.Steam_Release_SDL|x86.Build.0 = Steam_Release_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug|x64.Build.0 = Debug_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Debug|x86.Build.0 = Debug_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release_DX|x64.Build.0 = Release_DX|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release_DX|x86.Build.0 = Release_DX|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release|x64.ActiveCfg = Release_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release|x64.Build.0 = Release_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release|x86.ActiveCfg = Release_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Release|x86.Build.0 = Release_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{9868A4F8-8E78-4377-BEA9-E13DA4485AB2}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug|x64.Build.0 = Debug_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Debug|x86.Build.0 = Debug_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release_DX|x64.Build.0 = Release_DX|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release_DX|x86.Build.0 = Release_DX|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release|x64.ActiveCfg = Release_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release|x64.Build.0 = Release_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release|x86.ActiveCfg = Release_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Release|x86.Build.0 = Release_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug|x64.Build.0 = Debug_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Debug|x86.Build.0 = Debug_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release_DX|x64.Build.0 = Release_DX|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release_DX|x86.Build.0 = Release_DX|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release|x64.ActiveCfg = Release_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release|x64.Build.0 = Release_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release|x86.ActiveCfg = Release_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Release|x86.Build.0 = Release_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{323C59E5-555F-4DE4-86F2-D9572C00EC25}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug|x64.Build.0 = Debug_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Debug|x86.Build.0 = Debug_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release_DX|x64.Build.0 = Release_DX|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release_DX|x86.Build.0 = Release_DX|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release|x64.ActiveCfg = Release_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release|x64.Build.0 = Release_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release|x86.ActiveCfg = Release_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Release|x86.Build.0 = Release_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{84505A35-14BE-4A4D-9029-BF5AD22897DC}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug|x64.Build.0 = Debug_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Debug|x86.Build.0 = Debug_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release_DX|x64.Build.0 = Release_DX|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release_DX|x86.Build.0 = Release_DX|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release|x64.ActiveCfg = Release_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release|x64.Build.0 = Release_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release|x86.ActiveCfg = Release_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Release|x86.Build.0 = Release_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{DE49D417-147B-4684-9FE1-3B733AF02889}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug|x64.Build.0 = Debug_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Debug|x86.Build.0 = Debug_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release_DX|x64.Build.0 = Release_DX|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release_DX|x86.Build.0 = Release_DX|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release|x64.ActiveCfg = Release_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release|x64.Build.0 = Release_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release|x86.ActiveCfg = Release_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Release|x86.Build.0 = Release_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{D3DBE872-5BF5-4E32-8F41-53903A4A41D8}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug|x64.Build.0 = Debug_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Debug|x86.Build.0 = Debug_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release_DX|x64.Build.0 = Release_DX|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release_DX|x86.Build.0 = Release_DX|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release|x64.ActiveCfg = Release_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release|x64.Build.0 = Release_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release|x86.ActiveCfg = Release_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Release|x86.Build.0 = Release_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{FDAC4B9B-57A9-4FDF-B779-BE04A88BF0CB}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug|x64.Build.0 = Debug_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Debug|x86.Build.0 = Debug_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release_DX|x64.Build.0 = Release_DX|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release_DX|x86.Build.0 = Release_DX|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release|x64.ActiveCfg = Release_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release|x64.Build.0 = Release_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release|x86.ActiveCfg = Release_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Release|x86.Build.0 = Release_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{23EA3FB3-DFE4-4D4B-BD66-6D06533D8719}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug|x64.Build.0 = Debug_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Debug|x86.Build.0 = Debug_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release_DX|x64.Build.0 = Release_DX|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release_DX|x86.Build.0 = Release_DX|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release|x64.ActiveCfg = Release_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release|x64.Build.0 = Release_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release|x86.ActiveCfg = Release_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Release|x86.Build.0 = Release_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug|x64.Build.0 = Debug_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Debug|x86.Build.0 = Debug_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release_DX|x64.Build.0 = Release_DX|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release_DX|x86.Build.0 = Release_DX|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release|x64.ActiveCfg = Release_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release|x64.Build.0 = Release_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release|x86.ActiveCfg = Release_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Release|x86.Build.0 = Release_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{62B2385D-FB11-4768-AC67-FEC93481FB03}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug_DX|x64.ActiveCfg = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug_DX|x64.Build.0 = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug_DX|x86.ActiveCfg = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug_DX|x86.Build.0 = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug_SDL|x64.ActiveCfg = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug_SDL|x64.Build.0 = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug_SDL|x86.ActiveCfg = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug_SDL|x86.Build.0 = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug|x64.ActiveCfg = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug|x64.Build.0 = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug|x86.ActiveCfg = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Debug|x86.Build.0 = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release_DX|x64.ActiveCfg = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release_DX|x64.Build.0 = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release_DX|x86.ActiveCfg = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release_DX|x86.Build.0 = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release_SDL|x64.ActiveCfg = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release_SDL|x64.Build.0 = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release_SDL|x86.ActiveCfg = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release_SDL|x86.Build.0 = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release|x64.ActiveCfg = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release|x64.Build.0 = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release|x86.ActiveCfg = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Release|x86.Build.0 = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Debug_DX|x64.ActiveCfg = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Debug_DX|x64.Build.0 = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Debug_DX|x86.ActiveCfg = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Debug_DX|x86.Build.0 = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Debug_SDL|x64.ActiveCfg = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Debug_SDL|x64.Build.0 = Debug|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Debug_SDL|x86.ActiveCfg = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Debug_SDL|x86.Build.0 = Debug|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Release_DX|x64.ActiveCfg = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Release_DX|x64.Build.0 = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Release_DX|x86.ActiveCfg = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Release_DX|x86.Build.0 = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Release_SDL|x64.ActiveCfg = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Release_SDL|x64.Build.0 = Release|x64
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Release_SDL|x86.ActiveCfg = Release|Win32
		{9DE5622E-0212-43FF-BF9F-BF81CFD6D4D4}.Steam_Release_SDL|x86.Build.0 = Release|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug_DX|x64.Build.0 = Debug_DX|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug_DX|x86.Build.0 = Debug_DX|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug|x64.ActiveCfg = Debug_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug|x64.Build.0 = Debug_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug|x86.ActiveCfg = Debug_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Debug|x86.Build.0 = Debug_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release_DX|x64.ActiveCfg = Release_DX|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release_DX|x64.Build.0 = Release_DX|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release_DX|x86.ActiveCfg = Release_DX|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release_DX|x86.Build.0 = Release_DX|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release_SDL|x64.Build.0 = Release_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release_SDL|x86.Build.0 = Release_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release|x64.ActiveCfg = Release_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release|x64.Build.0 = Release_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release|x86.ActiveCfg = Release_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Release|x86.Build.0 = Release_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Debug_DX|x64.ActiveCfg = Debug_DX|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Debug_DX|x64.Build.0 = Debug_DX|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Debug_DX|x86.ActiveCfg = Debug_DX|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Debug_DX|x86.Build.0 = Debug_DX|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Debug_SDL|x64.ActiveCfg = Debug_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Debug_SDL|x64.Build.0 = Debug_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Debug_SDL|x86.ActiveCfg = Debug_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Debug_SDL|x86.Build.0 = Debug_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Release_DX|x64.ActiveCfg = Release_DX|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Release_DX|x64.Build.0 = Release_DX|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Release_DX|x86.ActiveCfg = Release_DX|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Release_DX|x86.Build.0 = Release_DX|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Release_SDL|x64.ActiveCfg = Release_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Release_SDL|x64.Build.0 = Release_SDL|x64
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Release_SDL|x86.ActiveCfg = Release_SDL|Win32
		{60F44F5F-335C-4080-B282-0CB14249BD5B}.Steam_Release_SDL|x86.Build.0 = Release_SDL|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug_DX|x64.ActiveCfg = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug_DX|x64.Build.0 = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug_DX|x86.ActiveCfg = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug_DX|x86.Build.0 = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug_SDL|x64.ActiveCfg = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug_SDL|x64.Build.0 = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug_SDL|x86.ActiveCfg = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug_SDL|x86.Build.0 = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug|x64.ActiveCfg = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug|x64.Build.0 = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug|x86.ActiveCfg = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Debug|x86.Build.0 = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release_DX|x64.ActiveCfg = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release_DX|x64.Build.0 = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release_DX|x86.ActiveCfg = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release_DX|x86.Build.0 = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release_SDL|x64.ActiveCfg = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release_SDL|x64.Build.0 = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release_SDL|x86.ActiveCfg = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release_SDL|x86.Build.0 = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release|x64.ActiveCfg = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release|x64.Build.0 = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release|x86.ActiveCfg = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Release|x86.Build.0 = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Debug_DX|x64.ActiveCfg = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Debug_DX|x64.Build.0 = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Debug_DX|x86.ActiveCfg = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Debug_DX|x86.Build.0 = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Debug_SDL|x64.ActiveCfg = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Debug_SDL|x64.Build.0 = Debug|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Debug_SDL|x86.ActiveCfg = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Debug_SDL|x86.Build.0 = Debug|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Release_DX|x64.ActiveCfg = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Release_DX|x64.Build.0 = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Release_DX|x86.ActiveCfg = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Release_DX|x86.Build.0 = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Release_SDL|x64.ActiveCfg = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Release_SDL|x64.Build.0 = Release|x64
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Release_SDL|x86.ActiveCfg = Release|Win32
		{66E419CA-A396-4A05-BE97-300BFAE97825}.Steam_Release_SDL|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {AA8E4FAE-1958-4358-A59F-68FC7A7C094F}
	EndGlobalSection
EndGlobal

```

`EAC_SDK/Samples/SessionMatchmaking/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/SessionMatchmaking/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/SessionMatchmaking/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/SessionMatchmaking/SessionMatchmaking.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>SimpleFramework</RootNamespace>
    <ProjectGuid>{669041A1-B499-4BDD-9A7A-94C9BC9F6E14}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>SessionMatchmaking</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_SESSIONS;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/SessionMatchmaking/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_SESSIONS;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/SessionMatchmaking/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_SESSIONS;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/SessionMatchmaking/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_SESSIONS;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/SessionMatchmaking/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_SESSIONS;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/SessionMatchmaking/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_SESSIONS;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/SessionMatchmaking/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_SESSIONS;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/SessionMatchmaking/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_SESSIONS;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/SessionMatchmaking/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\DropDownList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableRowView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\NewSessionDialog.h" />
    <ClInclude Include="Source\RequestToJoinSessionReceivedDialog.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\SessionInviteReceivedDialog.h" />
    <ClInclude Include="Source\SessionMatchmaking.h" />
    <ClInclude Include="Source\SessionMatchmakingDialog.h" />
    <ClInclude Include="Source\SessionsTableRowView.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\DropDownList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TableRowView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\NewSessionDialog.cpp" />
    <ClCompile Include="Source\RequestToJoinSessionReceivedDialog.cpp" />
    <ClCompile Include="Source\SessionInviteReceivedDialog.cpp" />
    <ClCompile Include="Source\SessionMatchmaking.cpp" />
    <ClCompile Include="Source\SessionMatchmakingDialog.cpp" />
    <ClCompile Include="Source\SessionsTableRowView.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="..\Shared\Source\Graphics\GUI\TableView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/SessionMatchmaking/SessionMatchmaking.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="Source\SessionMatchmakingDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SessionInviteReceivedDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SessionMatchmaking.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="Source\NewSessionDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\DropDownList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableRowView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TableView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="Source\SessionsTableRowView.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="Source\RequestToJoinSessionReceivedDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="Source\SessionMatchmakingDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\SessionInviteReceivedDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\SessionMatchmaking.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Source\NewSessionDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\DropDownList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TableRowView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="Source\SessionsTableRowView.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="Source\RequestToJoinSessionReceivedDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\TableView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/SessionMatchmaking/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "GameEvent.h"
#include "Player.h"
#include "Main.h"
#include "Game.h"
#include "SessionMatchmaking.h"
#include "Platform.h"

const double MaxTimeToShutdown = 7.0; //7 seconds

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	SessionMatchmaking = std::make_unique<FSessionMatchmaking>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" REGISTERPLAYER - register a player with a given product id with the presence session;",
			L" UNREGISTERPLAYER - unregister a player with a given product id with the presence session;"
		};
		AppendHelpMessageLines(ExtraHelpMessageLines);

		Console->AddCommand(L"REGISTERPLAYER", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetSessions())
				{
					if (const FSession* PresenceSession = FGame::Get().GetSessions()->GetPresenceSession())
					{
						if (args.size() == 1)
						{
							std::string NarrowUserIdStr = FStringUtils::Narrow(args[0]);
							EOS_ProductUserId ProductUserId = FAccountHelpers::ProductUserIDFromString(NarrowUserIdStr.c_str());
							if (ProductUserId != nullptr)
							{
								FGame::Get().GetSessions()->Register(PresenceSession->Name, ProductUserId);
							}
							else
							{
								FGame::Get().GetConsole()->AddLine(L"Register command requires a valid product user id");
							}

						}
						else
						{
							FDebugLog::LogError(L"Player product ID is required");
						}
					}
					else
					{
						FDebugLog::LogError(L"No presence session exists");
					}
				}
				else
				{
					FDebugLog::LogError(L"EOS SDK Sessions are not initialized!");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
		Console->AddCommand(L"UNREGISTERPLAYER", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (FGame::Get().GetSessions())
				{
					if (const FSession* PresenceSession = FGame::Get().GetSessions()->GetPresenceSession())
					{
						if (args.size() == 1)
						{
							std::string NarrowUserIdStr = FStringUtils::Narrow(args[0]);
							EOS_ProductUserId ProductUserId = FAccountHelpers::ProductUserIDFromString(NarrowUserIdStr.c_str());
							if (ProductUserId != nullptr)
							{
								FGame::Get().GetSessions()->Unregister(PresenceSession->Name, ProductUserId);
							}
							else
							{
								FGame::Get().GetConsole()->AddLine(L"Unregister command requires a valid product user id");
							}

						}
						else
						{
							FDebugLog::LogError(L"Player product ID is required");
						}
					}
					else
					{
						FDebugLog::LogError(L"No presence session exists");
					}
				}
				else
				{
					FDebugLog::LogError(L"EOS SDK Sessions are not initialized!");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
	}
}

void FGame::Update()
{
	SessionMatchmaking->Update();
	FBaseGame::Update();
}

void FGame::Create()
{
	FBaseGame::Create();

	SessionMatchmaking->SubscribeToGameInvites();
	SessionMatchmaking->SubscribeToLeaveSessionUI();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);

	SessionMatchmaking->OnGameEvent(Event);
}

void FGame::OnShutdown()
{
	//SessionMatchmaking must be cleared before we destroy SDK platform.
	if (SessionMatchmaking)
	{
		SessionMatchmaking->OnShutdown();
	}

	FBaseGame::OnShutdown();

	ShutdownTriggeredTimestamp = Main->GetTimer().GetTotalSeconds();
}

bool FGame::IsShutdownDelayed()
{
	if (SessionMatchmaking && (Main->GetTimer().GetTotalSeconds() - ShutdownTriggeredTimestamp) < MaxTimeToShutdown)
	{
		return SessionMatchmaking->HasActiveLocalSessions();
	}

	return false;
}

const std::unique_ptr<FSessionMatchmaking>& FGame::GetSessions()
{
	return SessionMatchmaking;
}

```

`EAC_SDK/Samples/SessionMatchmaking/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FSessionMatchmaking;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/** 
	 * Creation
	 */
	virtual void Create() override;

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/** 
	 * Called before application shutdown
	 */
	virtual void OnShutdown() override;

	/** 
	 * Called to check if shutdown needs to be delayed
	 */
	virtual bool IsShutdownDelayed() override;

	/**
	 * Getter for sessions component.
	 */
	const std::unique_ptr<FSessionMatchmaking>& GetSessions();

protected:
	virtual void CreateConsoleCommands() override;

	/** Leaderboard component */
	std::unique_ptr<FSessionMatchmaking> SessionMatchmaking;

	/** Timestamp to know when shutdown was triggered */
	double ShutdownTriggeredTimestamp = 0.0;
};


```

`EAC_SDK/Samples/SessionMatchmaking/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/SessionMatchmaking/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "SessionMatchmakingDialog.h"
#include "FriendsDialog.h"
#include "SessionInviteReceivedDialog.h"
#include "RequestToJoinSessionReceivedDialog.h"
#include "NewSessionDialog.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "PopupDialog.h"

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreateSessionMatchmakingDialog();
	CreateFriendsDialog();
	CreateSessionInviteDialog();
	CreateNewSessionDialog();
	CreateRequestToJoinSessionDialog();

	FBaseMenu::Create();
}

void FMenu::Release()
{
	if (SessionMatchmakingDialog)
	{
		SessionMatchmakingDialog->Release();
		SessionMatchmakingDialog.reset();
	}

	if (RequestToJoinSessionDialog)
	{
		RequestToJoinSessionDialog->Release();
		RequestToJoinSessionDialog.reset();
	}

	FBaseMenu::Release();
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * 0.68f, WindowSize.y * 0.35f);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (SessionMatchmakingDialog)
		{
			SessionMatchmakingDialog->SetSize(Vector2(ConsoleWidgetSize.x, ConsoleWidgetPos.y - 100.0f - 10.0f));
			SessionMatchmakingDialog->SetPosition(Vector2(ConsoleWidgetPos.x, 100.0f));
		}

		UpdateFriendsDialogTransform(WindowSize);
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (SessionInviteDialog)
	{
		SessionInviteDialog->SetPosition(Vector2((WindowSize.x / 2.f) - SessionInviteDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - SessionInviteDialog->GetSize().y - 2.0f));
	}

	if (NewSessionDialog)
	{
		NewSessionDialog->SetPosition(Vector2((WindowSize.x / 2.f) - NewSessionDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - NewSessionDialog->GetSize().y + 20.0f));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();

	if (RequestToJoinSessionDialog)
	{
		RequestToJoinSessionDialog->SetPosition(Vector2((WindowSize.x / 2.f) - SessionInviteDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - SessionInviteDialog->GetSize().y - 2.0f));
	}
}

void FMenu::CreateSessionMatchmakingDialog()
{
	const float FX = 100.0f;
	const float FY = 100.0f;
	const float Width = 300.0f;
	const float Height = 300.0f;

	SessionMatchmakingDialog = std::make_shared<FSessionMatchmakingDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	SessionMatchmakingDialog->SetBorderColor(Color::UIBorderGrey);
	
	SessionMatchmakingDialog->Create();

	AddDialog(SessionMatchmakingDialog);
}

void FMenu::CreateAuthDialogs()
{
	AuthDialogs = std::make_shared<FAuthDialogs>(
		FriendsDialog,
		L"Session Matchmaking",
		BoldSmallFont->GetFont(),
		SmallFont->GetFont(),
		TinyFont->GetFont());
	
	AuthDialogs->Create();
	AuthDialogs->SetSingleUserOnly(true);
}

void FMenu::CreateSessionInviteDialog()
{
	SessionInviteDialog = std::make_shared<FSessionInviteReceivedDialog>(
		Vector2(200.f, 200.f),
		Vector2(370.0f, 210.f),
		5,
		NormalFont->GetFont(),
		SmallFont->GetFont());

	SessionInviteDialog->Create();
	SessionInviteDialog->SetBorderColor(Color::UIBorderGrey);

	AddDialog(SessionInviteDialog);
	HideDialog(SessionInviteDialog);
}

void FMenu::CreateNewSessionDialog()
{
	NewSessionDialog = std::make_shared<FNewSessionDialog>(
		Vector2(200.f, 410.f),
		Vector2(370.0f, 300.0f),
		5,
		NormalFont->GetFont(),
		SmallFont->GetFont()
		);

	NewSessionDialog->Create();
	NewSessionDialog->SetBorderColor(Color::UIBorderGrey);

	AddDialog(NewSessionDialog);
	HideDialog(NewSessionDialog);
}

void FMenu::CreateRequestToJoinSessionDialog()
{
	RequestToJoinSessionDialog = std::make_shared<FRequestToJoinSessionReceivedDialog>(
		Vector2(200.f, 200.f),
		Vector2(370.0f, 210.f),
		5,
		NormalFont->GetFont(),
		SmallFont->GetFont()
		);

	RequestToJoinSessionDialog->Create();
	RequestToJoinSessionDialog->SetBorderColor(Color::UIBorderGrey);

	AddDialog(RequestToJoinSessionDialog);
	HideDialog(RequestToJoinSessionDialog);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::InviteToSessionReceived)
	{
		if (SessionInviteDialog)
		{
			SessionInviteDialog->SetSessionInfo(FGame::Get().GetFriends()->GetFriendName(Event.GetProductUserId()), FGame::Get().GetSessions()->GetInviteSession());
			ShowDialog(SessionInviteDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::OverlayInviteToSessionAccepted
			|| Event.GetType() == EGameEventType::OverlayInviteToSessionRejected)
	{
		if (SessionInviteDialog)
		{
			HideDialog(SessionInviteDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::NewSession)
	{
		if (NewSessionDialog)
		{
			SessionMatchmakingDialog->Disable();
			ShowDialog(NewSessionDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::SessionCreationFinished)
	{
		if (NewSessionDialog)
		{
			HideDialog(NewSessionDialog);
			SessionMatchmakingDialog->Enable();
		}
	}
	else if (Event.GetType() == EGameEventType::RequestToJoinSessionReceived)
	{
		// Note that there is only one Request to Join session dialog available so if a new Request to Join
		// arrives before an existing Request To Join has been dispositioned, the incoming Request To Join
		// will stomp the existing.
		if (RequestToJoinSessionDialog)
		{
			RequestToJoinSessionDialog->SetFriendInfo(FGame::Get().GetFriends()->GetFriendName(Event.GetProductUserId()), Event.GetProductUserId());
			ShowDialog(RequestToJoinSessionDialog);
		}
	}

	if (SessionMatchmakingDialog) SessionMatchmakingDialog->OnGameEvent(Event);

	FBaseMenu::OnGameEvent(Event);
}

void FMenu::UpdateFriendsDialogTransform(const Vector2 WindowSize)
{
	if (FriendsDialog)
	{
		const float FX = SessionMatchmakingDialog->GetPosition().x + SessionMatchmakingDialog->GetSize().x + 5.0f;
		const float FY = 100.0f;
		const float FriendsWidth = WindowSize.x - FX - 5.0f;
		const float FriendsHeight = WindowSize.y - FY - 10.0f;

		FriendsDialog->SetSize(Vector2(FriendsWidth, FriendsHeight));
		FriendsDialog->SetPosition(Vector2(FX, FY));
	}
}
```

`EAC_SDK/Samples/SessionMatchmaking/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"


/**
* Forward declarations
*/
class FUIEvent;
class FConsole;
class FGameEvent;
class FFont;
class FConsoleDialog;
class FFriendsDialog;
class FExitDialog;
class FAuthDialogs;
class FSpriteWidget;
class FTextLabelWidget;
class FSessionMatchmakingDialog;
class FSessionInviteReceivedDialog;
class FNewSessionDialog;
class FPopupDialog;
class FRequestToJoinSessionReceivedDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event) override;

private:
	/**
	 * Creates the session matchmaking dialog
	 */
	void CreateSessionMatchmakingDialog();

	/**
	 * Creates the auth dialogs
	 */
	virtual void CreateAuthDialogs() override;

	/** 
	* Creates and hides the popup dialog with session invite info.
	*/
	void CreateSessionInviteDialog();

	/**
	* Creates and hides the popup dialog for session creation.
	*/
	void CreateNewSessionDialog();

	/**
	* Creates and hides the popup dialog for request to join session
	*/
	void CreateRequestToJoinSessionDialog();

	/**
	 * Updates friends dialog to match session matchmaking dialog. 
	 */
	void UpdateFriendsDialogTransform(const Vector2 WindowSize);

	/** Session Matchmaking Dialog */
	std::shared_ptr<FSessionMatchmakingDialog> SessionMatchmakingDialog;

	/** Session invite received dialog */
	std::shared_ptr<FSessionInviteReceivedDialog> SessionInviteDialog;

	/** Dialog with session settings */
	std::shared_ptr<FNewSessionDialog> NewSessionDialog;

	/** Request to Join Session received dialog */
	std::shared_ptr<FRequestToJoinSessionReceivedDialog> RequestToJoinSessionDialog;
};

```

`EAC_SDK/Samples/SessionMatchmaking/Source/NewSessionDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "GameEvent.h"
#include "TextLabel.h"
#include "Button.h"
#include "DropDownList.h"
#include "Checkbox.h"
#include "NewSessionDialog.h"
#include "StringUtils.h"
#include "SessionMatchmaking.h"

static const float NewSessionDialogUIElementsXOffset = 20.0f;
static const float NewSessionDialogUIElementsYOffset = 20.0f;

const std::wstring PSNRestrictedPlatformString = L"PSN";
const std::wstring SwitchRestrictedPlatformString = L"Switch";
const std::wstring XboxLiveRestrictedPlatformString = L"XboxLive";

static ERestrictedPlatformType RestrictedPlatformTypeForString(const std::wstring& RestrictedPlatformString)
{
	if (RestrictedPlatformString == PSNRestrictedPlatformString)
	{
		return ERestrictedPlatformType::PSN;
	}
	else if (RestrictedPlatformString == SwitchRestrictedPlatformString)
	{
		return ERestrictedPlatformType::Switch;
	}
	else if (RestrictedPlatformString == XboxLiveRestrictedPlatformString)
	{
		return ERestrictedPlatformType::XboxLive;
	}

	return ERestrictedPlatformType::Unrestricted;
}

FNewSessionDialog::FNewSessionDialog(Vector2 InPos,
	Vector2 InSize,
	UILayer InLayer,
	FontPtr InNormalFont,
	FontPtr InSmallFont) :
	FDialog(InPos, InSize, InLayer)
{
	Background = std::make_shared<FSpriteWidget>(
		Position,
		InSize,
		InLayer,
		L"Assets/textfield.dds",
		Color::Black);
	AddWidget(Background);


	HeaderLabel = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x, Position.y),
		Vector2(InSize.x, 30.f),
		InLayer - 1,
		L"CREATE NEW SESSION",
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f));
	HeaderLabel->SetFont(InNormalFont);
	HeaderLabel->SetBorderColor(Color::UIBorderGrey);
	AddWidget(HeaderLabel);

	SessionNameField = std::make_shared<FTextFieldWidget>(
		Position + Vector2(NewSessionDialogUIElementsXOffset, HeaderLabel->GetSize().y + NewSessionDialogUIElementsYOffset),
		Vector2(InSize.x - 2.0f * NewSessionDialogUIElementsXOffset, 30.0f),
		Layer - 1,
		L"New session name...",
		L"Assets/textfield.dds",
		InNormalFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
		);
	SessionNameField->SetBorderColor(Color::UIBorderGrey);
	AddWidget(SessionNameField);

	const Vector2 DropDownListsSize = Vector2(SessionNameField->GetSize().x / 2.0f - 5.0f, 30.0f);

	SessionLevelDropDown = std::make_shared<FDropDownList>(
		SessionNameField->GetPosition() + Vector2(0.0f, SessionNameField->GetSize().y + 10.0f),
		DropDownListsSize,
		DropDownListsSize + Vector2(0.0f, 85.0),
		Layer - 1,
		L"Level: ",
		std::vector<std::wstring>({ L"Forest", L"Castle", L"Dungeon", L"Village", L"Valley"}),
		InNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	SessionLevelDropDown->SetBorderColor(Color::UIBorderGrey);
	SessionLevelDropDown->SetOnSelectionCallback([this](const std::wstring& Selection)
	{
		OnSessionLevelSelected(Selection);
	});
	//AddWidget(SessionLevelDropDown);

	RestrictedPlatformsDropDown = std::make_shared<FDropDownList>(
		SessionLevelDropDown->GetPosition() + Vector2(DropDownListsSize.x  + 10.0f, 0.0f),
		DropDownListsSize + Vector2(65.0f, 0.0f),
		DropDownListsSize + Vector2(65.0f, 85.0),
		Layer - 1,
		L"Allowed Platform: ",
		std::vector<std::wstring>({ L"Unrestricted", PSNRestrictedPlatformString, SwitchRestrictedPlatformString, XboxLiveRestrictedPlatformString }),
		InNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	RestrictedPlatformsDropDown->SetBorderColor(Color::UIBorderGrey);
	RestrictedPlatformsDropDown->SetOnSelectionCallback([this](const std::wstring& Selection)
	{
		OnSessionRestrictedPlatformSelected(Selection);
	});

	MaxPlayersDropDown = std::make_shared<FDropDownList>(
		SessionLevelDropDown->GetPosition() + Vector2(DropDownListsSize.x  + 10.0f, 0.0f),
		DropDownListsSize,
		DropDownListsSize + Vector2(0.0f, 85.0),
		Layer - 1,
		L"Max Players: ",
		std::vector<std::wstring>({ L"2", L"3", L"4", L"5", L"6" }),
		InNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	MaxPlayersDropDown->SetBorderColor(Color::UIBorderGrey);
	MaxPlayersDropDown->SetOnSelectionCallback([this](const std::wstring& Selection)
	{
		OnSessionMaxPlayersNumSelected(Selection);
	});

	JoinInProgressCheckbox = std::make_shared<FCheckboxWidget>(
		SessionLevelDropDown->GetPosition() + Vector2(0.0f, SessionLevelDropDown->GetSize().y + 5.0f),
		Vector2(150.0f, 30.0f),
		Layer - 1,
		L"Join In Progress",
		L"",
		InNormalFont
		);
	AddWidget(JoinInProgressCheckbox);

	PublicCheckbox = std::make_shared<FCheckboxWidget>(
		JoinInProgressCheckbox->GetPosition() + Vector2(JoinInProgressCheckbox->GetSize().x + 10.f, 0.0f),
		Vector2(150.0f, 30.0f),
		Layer - 1,
		L"Public",
		L"",
		InNormalFont
		);
	AddWidget(PublicCheckbox);

	PresenceSessionCheckbox = std::make_shared<FCheckboxWidget>(
		JoinInProgressCheckbox->GetPosition() + Vector2(0.0f, JoinInProgressCheckbox->GetSize().y + 10.0f),
		Vector2(150.0f, 30.0f),
		Layer - 1,
		L"Presence?",
		L"",
		InNormalFont
		);

	AddWidget(PresenceSessionCheckbox);

	InvitesAllowedCheckbox = std::make_shared<FCheckboxWidget>(
		PresenceSessionCheckbox->GetPosition() + Vector2(PresenceSessionCheckbox->GetSize().x + 10.f, 0.0f),
		Vector2(150.0f, 30.0f),
		Layer - 1,
		L"Invites allowed?",
		L"",
		InNormalFont
		);
	InvitesAllowedCheckbox->SetTicked(true);
	AddWidget(InvitesAllowedCheckbox);

	CreateButton = std::make_shared<FButtonWidget>(
		Vector2(Position.x + InSize.x / 2.0f - 100.0f, Position.y + InSize.y - 60.0f),
		Vector2(200.f, 45.f),
		InLayer - 1,
		L"CREATE",
		assets::DefaultButtonAssets,
		InSmallFont,
		Color::UIButtonBlue
		);
	CreateButton->SetOnPressedCallback([this]()
	{
		CreateSessionPressed();

		FinishSessionModification();
	});
	CreateButton->SetBackgroundColors(assets::DefaultButtonColors);
	CreateButton->Disable();
	AddWidget(CreateButton);

	CloseButton = std::make_shared<FButtonWidget>(
		Vector2(Position.x + InSize.x - 30.0f, Position.y),
		Vector2(30.0f, 30.f),
		InLayer - 1,
		L"",
		std::vector<std::wstring>({ L"Assets/nobutton.dds" }),
		InSmallFont,
		FColor(1.0f, 1.0f, 1.0f, 1.0f)
		);
	CloseButton->SetOnPressedCallback([this]()
	{
		FinishSessionModification();
	});
	AddWidget(CloseButton);

	//Dropdown lists have to be last widgets in the list otherwise they will overlap with other widgets when expanded on DX platform.
	//This is temporary workaround (hack).
	//TODO: fix DX render to use UI Layer value correctly
	AddWidget(RestrictedPlatformsDropDown);
	AddWidget(SessionLevelDropDown);
	AddWidget(MaxPlayersDropDown);
}

FNewSessionDialog::~FNewSessionDialog()
{

}

void FNewSessionDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	Background->SetPosition(Position);
	HeaderLabel->SetPosition(Position);
	SessionNameField->SetPosition(Position + Vector2(NewSessionDialogUIElementsXOffset, HeaderLabel->GetSize().y + NewSessionDialogUIElementsYOffset));

	const Vector2 DropDownListsSize = Vector2(SessionNameField->GetSize().x / 2.0f - 5.0f, 30.0f);

	SessionLevelDropDown->SetPosition(SessionNameField->GetPosition() + Vector2(0.0f, SessionNameField->GetSize().y + 10.0f));
	MaxPlayersDropDown->SetPosition(SessionLevelDropDown->GetPosition() + Vector2(DropDownListsSize.x + 10.0f, 0.0f));
	RestrictedPlatformsDropDown->SetPosition(SessionLevelDropDown->GetPosition() + Vector2(0.0f, SessionLevelDropDown->GetSize().y + 5.0f));

	JoinInProgressCheckbox->SetPosition(RestrictedPlatformsDropDown->GetPosition() + Vector2(0.0f, SessionLevelDropDown->GetSize().y + 5.0f));
	PublicCheckbox->SetPosition(JoinInProgressCheckbox->GetPosition() + Vector2(JoinInProgressCheckbox->GetSize().x + 10.f, 0.0f));
	PresenceSessionCheckbox->SetPosition(JoinInProgressCheckbox->GetPosition() + Vector2(0.0f, JoinInProgressCheckbox->GetSize().y + 10.0f));
	InvitesAllowedCheckbox->SetPosition(PresenceSessionCheckbox->GetPosition() + Vector2(PresenceSessionCheckbox->GetSize().x + 10.0f, 0.0f));

	CreateButton->SetPosition(Vector2(Position.x + GetSize().x / 2.0f - 100.0f, Position.y + GetSize().y - 60.0f));
	CloseButton->SetPosition(Vector2(Position.x + GetSize().x - 30.0f, Position.y));
}

void FNewSessionDialog::Create()
{
	FDialog::Create();

	SessionLevelDropDown->SetParent(std::weak_ptr<FDialog>(std::static_pointer_cast<FDialog>(shared_from_this())));
	MaxPlayersDropDown->SetParent(std::weak_ptr<FDialog>(std::static_pointer_cast<FDialog>(shared_from_this())));
	RestrictedPlatformsDropDown->SetParent(std::weak_ptr<FDialog>(std::static_pointer_cast<FDialog>(shared_from_this())));
}

void FNewSessionDialog::Show()
{
	FDialog::Show();
	UpdateValuesOnShow();
}

void FNewSessionDialog::Toggle()
{
	FDialog::Toggle();
	UpdateValuesOnShow();
}

void FNewSessionDialog::Update()
{
	FDialog::Update();

	bool bEnableCreateButton = bSessionLevelSelected && bSessionMaxPlayersSelected &&
		SessionNameField && SessionNameField->GetInitialText() != SessionNameField->GetText();
	
	if (CreateButton)
	{
		if (bEnableCreateButton)
		{
			CreateButton->Enable();
		}
		else
		{
			CreateButton->Disable();
		}
	}
}

void FNewSessionDialog::UpdateValuesOnShow()
{
	if (FGame::Get().GetSessions()->HasPresenceSession())
	{
		PresenceSessionCheckbox->Disable();
		PresenceSessionCheckbox->SetTicked(false);
		InvitesAllowedCheckbox->Disable();
		InvitesAllowedCheckbox->SetTicked(false);
	}
	else
	{
		PresenceSessionCheckbox->Enable();
		PresenceSessionCheckbox->SetTicked(true);
		InvitesAllowedCheckbox->Enable();
		InvitesAllowedCheckbox->SetTicked(true);
	}
}

void FNewSessionDialog::CreateSessionPressed()
{
	std::wstring SessionName = SessionNameField->GetText();

	FSession Session;
	Session.bAllowJoinInProgress = JoinInProgressCheckbox->IsTicked();
	Session.bPresenceSession = PresenceSessionCheckbox->IsTicked();
	Session.bInvitesAllowed = InvitesAllowedCheckbox->IsTicked();
	const std::wstring& MaxPlayersString = MaxPlayersDropDown->GetCurrentSelection();
	Session.MaxPlayers = atoi(FStringUtils::Narrow(MaxPlayersString).data());
	Session.Name = FStringUtils::Narrow(SessionName);
	Session.PermissionLevel = (PublicCheckbox->IsTicked()) ? EOS_EOnlineSessionPermissionLevel::EOS_OSPF_PublicAdvertised : EOS_EOnlineSessionPermissionLevel::EOS_OSPF_InviteOnly;

	if (bSessionRestrictedPlatformSelected)
	{
		Session.RestrictedPlatform = RestrictedPlatformTypeForString(RestrictedPlatformsDropDown->GetCurrentSelection());
	}

	FSession::Attribute Attribute;
	Attribute.Key = SESSION_KEY_LEVEL;
	Attribute.AsString = FStringUtils::Narrow(SessionLevelDropDown->GetCurrentSelection());
	Attribute.ValueType = FSession::Attribute::String;
	Attribute.Advertisement = EOS_ESessionAttributeAdvertisementType::EOS_SAAT_Advertise;

	Session.Attributes.push_back(Attribute);

	FGame::Get().GetSessions()->CreateSession(Session);
}

void FNewSessionDialog::FinishSessionModification()
{
	FGameEvent Event(EGameEventType::SessionCreationFinished);
	FGame::Get().OnGameEvent(Event);
}

void FNewSessionDialog::OnEscapePressed()
{
	FinishSessionModification();
}
```

`EAC_SDK/Samples/SessionMatchmaking/Source/NewSessionDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "SessionMatchmaking.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FButtonWidget;
class FDropDownList;
class FCheckboxWidget;

/**
 * Session creation dialog. User can pick parameters and create new session.
 */
class FNewSessionDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FNewSessionDialog(Vector2 InPos,
		Vector2 InSize,
		UILayer InLayer,
		FontPtr InNormalFont,
		FontPtr InSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FNewSessionDialog();

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;

	virtual void Create() override;

	virtual void Show() override;

	virtual void Toggle() override;

	virtual void Update() override;

	virtual void OnEscapePressed() override;

protected:
	void CreateSessionPressed();
	void UpdateValuesOnShow();
	void FinishSessionModification();

	void OnSessionLevelSelected(const std::wstring& Selection)
	{
		bSessionLevelSelected = true;
	}

	void OnSessionMaxPlayersNumSelected(const std::wstring& Selection)
	{
		bSessionMaxPlayersSelected = true;
	}

	void OnSessionRestrictedPlatformSelected(const std::wstring& Selection)
	{
		bSessionRestrictedPlatformSelected = true;
	}

private:
	/** Background */
	WidgetPtr Background;

	/** Label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Session name text input field */
	std::shared_ptr<FTextFieldWidget> SessionNameField;

	/** Session level */
	std::shared_ptr<FDropDownList> SessionLevelDropDown;

	/** Session max players */
	std::shared_ptr<FDropDownList> MaxPlayersDropDown;

	/** Restricted Platforms */
	std::shared_ptr<FDropDownList> RestrictedPlatformsDropDown;

	/** Session join in progress flag */
	std::shared_ptr<FCheckboxWidget> JoinInProgressCheckbox;

	/** Is session for presence? */
	std::shared_ptr<FCheckboxWidget> PresenceSessionCheckbox;

	/** Is session public? */
	std::shared_ptr<FCheckboxWidget> PublicCheckbox;

	/** Are invites allowed? */
	std::shared_ptr<FCheckboxWidget> InvitesAllowedCheckbox;

	/** Create session button */
	std::shared_ptr<FButtonWidget> CreateButton;

	/** Close dialog button */
	std::shared_ptr<FButtonWidget> CloseButton;
	
	/** Has user selected a value for session Level? */
	bool bSessionLevelSelected = false;

	/** Has user selected a value for max players num? */
	bool bSessionMaxPlayersSelected = false;

	/** Has user selected a value for restricted platform? */
	bool bSessionRestrictedPlatformSelected = false;
};

```

`EAC_SDK/Samples/SessionMatchmaking/Source/RequestToJoinSessionReceivedDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "Sprite.h"
#include "TextLabel.h"
#include "Button.h"
#include "Checkbox.h"
#include "ProgressBar.h"
#include "RequestToJoinSessionReceivedDialog.h"
#include "StringUtils.h"

FRequestToJoinSessionReceivedDialog::FRequestToJoinSessionReceivedDialog(Vector2 InPos,
						 Vector2 InSize,
						 UILayer InLayer,
						 FontPtr InNormalFont,
						 FontPtr InSmallFont) :
	FDialog(InPos, InSize, InLayer)
{
	Background = std::make_shared<FSpriteWidget>(
		Position,
		InSize,
		InLayer - 1,
		L"Assets/textfield.dds",
		Color::Black);
	AddWidget(Background);

	MessageLabel = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x + 30.0f, Position.y + 25.0f),
		Vector2(150.f, 30.f),
		InLayer - 1,
		L"",
		L"");
	MessageLabel->SetFont(InNormalFont);
	AddWidget(MessageLabel);

	FriendNameLabel = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x + 30.0f, Position.y + 25.0f),
		Vector2(150.f, 30.f),
		InLayer - 1,
		L"",
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	FriendNameLabel->SetFont(InNormalFont);
	AddWidget(FriendNameLabel);

	FColor AcceptButtonCol = FColor(0.f, 0.47f, 0.95f, 1.f);
	AcceptRequestToJoinButton = std::make_shared<FButtonWidget>(
		Position + Vector2(InSize.x / 2.0f - 105.0f, InSize.y - 45.f),
		Vector2(100.f, 30.f),
		InLayer - 1,
		L"Accept",
		assets::DefaultButtonAssets,
		InSmallFont,
		AcceptButtonCol);
	AcceptRequestToJoinButton->SetOnPressedCallback([this]()
	{
		FGame::Get().GetSessions()->AcceptRequestToJoin(FriendId);
		Hide();
	});
	AcceptRequestToJoinButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(AcceptRequestToJoinButton);

	FColor DeclineButtonCol = FColor(0.f, 0.47f, 0.95f, 1.f);
	DeclineRequestToJoinButton = std::make_shared<FButtonWidget>(
		Vector2(Position.x + InSize.x / 2.0f + 5.0f, AcceptRequestToJoinButton->GetPosition().y),
		Vector2(100.f, 30.f),
		InLayer - 1,
		L"Decline",
		assets::DefaultButtonAssets,
		InSmallFont,
		DeclineButtonCol);
	DeclineRequestToJoinButton->SetOnPressedCallback([this]()
	{
		FGame::Get().GetSessions()->RejectRequestToJoin(FriendId);
		Hide();
	});
	DeclineRequestToJoinButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(DeclineRequestToJoinButton);
}

void FRequestToJoinSessionReceivedDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	Background->SetPosition(Position);
	MessageLabel->SetPosition(Position + Vector2(30.0f, 25.0f));
	FriendNameLabel->SetPosition(MessageLabel->GetPosition() + Vector2(0.0f, MessageLabel->GetSize().y + 5.0f));
	AcceptRequestToJoinButton->SetPosition(Position + Vector2(GetSize().x / 2.0f - AcceptRequestToJoinButton->GetSize().x - 5.0f, GetSize().y - 45.0f));
	DeclineRequestToJoinButton->SetPosition(Position + Vector2(GetSize().x / 2.0f + 5.0f, GetSize().y - 45.0f));
}

void FRequestToJoinSessionReceivedDialog::SetFriendInfo(const std::wstring& InFriendName, const FProductUserId& InFriendId)
{
	FriendName = InFriendName;
	FriendId = InFriendId;

	if (MessageLabel)
	{
		MessageLabel->ClearText();
		MessageLabel->SetText(std::wstring(L"Request to Join Session Received"));
	}

	if (FriendNameLabel)
	{
		FriendNameLabel->ClearText();
		if (!InFriendName.empty())
		{
			FriendNameLabel->SetText(std::wstring(L"Friend: ") + InFriendName);
		}
	}
}

void FRequestToJoinSessionReceivedDialog::OnEscapePressed()
{
	Hide();
}
```

`EAC_SDK/Samples/SessionMatchmaking/Source/RequestToJoinSessionReceivedDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "SessionMatchmaking.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FButtonWidget;
class FCheckboxWidget;

/**
 * Request To Join Session Received dialog (simple popup to accept or decline the request to join)
 */
class FRequestToJoinSessionReceivedDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FRequestToJoinSessionReceivedDialog(Vector2 InPos,
		Vector2 InSize,
		UILayer InLayer,
		FontPtr InNormalFont,
		FontPtr InSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FRequestToJoinSessionReceivedDialog() {}

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	void OnEscapePressed() override;

	void SetFriendInfo(const std::wstring& InFriendName, const FProductUserId& InFriendId);

private:
	/** The name of the friend who requested to join a session. */
	std::wstring FriendName;

	/** The ID of the friend who requested to join a session. */
	FProductUserId FriendId;

	/** Background */
	WidgetPtr Background;

	/** Message label */
	std::shared_ptr<FTextLabelWidget> MessageLabel;

	/** Friend name label */
	std::shared_ptr<FTextLabelWidget> FriendNameLabel;

	/** Accept Request To Join button */
	std::shared_ptr<FButtonWidget> AcceptRequestToJoinButton;

	/** Decline Request to Join button */
	std::shared_ptr<FButtonWidget> DeclineRequestToJoinButton;
};

```

`EAC_SDK/Samples/SessionMatchmaking/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Session Matchmaking";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/SessionMatchmaking/Source/SessionInviteReceivedDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "Sprite.h"
#include "TextLabel.h"
#include "Button.h"
#include "Checkbox.h"
#include "ProgressBar.h"
#include "SessionInviteReceivedDialog.h"
#include "StringUtils.h"

FSessionInviteReceivedDialog::FSessionInviteReceivedDialog(Vector2 InPos,
						 Vector2 InSize,
						 UILayer InLayer,
						 FontPtr InNormalFont,
						 FontPtr InSmallFont) :
	FDialog(InPos, InSize, InLayer)
{
	Background = std::make_shared<FSpriteWidget>(
		Position,
		InSize,
		InLayer - 1,
		L"Assets/textfield.dds",
		Color::Black);
	AddWidget(Background);

	MessageLabel = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x + 30.0f, Position.y + 25.0f),
		Vector2(150.f, 30.f),
		InLayer - 1,
		L"",
		L"");
	MessageLabel->SetFont(InNormalFont);
	AddWidget(MessageLabel);

	FriendNameLabel = std::make_shared<FTextLabelWidget>(
		MessageLabel->GetPosition() + Vector2(0.0f, MessageLabel->GetSize().y + 5.0f),
		Vector2(150.f, 30.f),
		InLayer - 1,
		L"",
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	FriendNameLabel->SetFont(InNormalFont);
	AddWidget(FriendNameLabel);

	LevelNameLabel = std::make_shared<FTextLabelWidget>(
		FriendNameLabel->GetPosition() + Vector2(0.0f, FriendNameLabel->GetSize().y + 5.0f),
		Vector2(150.f, 30.f),
		InLayer - 1,
		L"",
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	LevelNameLabel->SetFont(InNormalFont);
	AddWidget(LevelNameLabel);

	PresenceSessionCheckbox = std::make_shared<FCheckboxWidget>(
		LevelNameLabel->GetPosition() + Vector2(MessageLabel->GetSize().x / 2.f + 5.f, MessageLabel->GetSize().y + 5.0f),
		Vector2(150.0f, 30.0f),
		Layer - 1,
		L"Presence?",
		L"",
		InNormalFont
		);
	AddWidget(PresenceSessionCheckbox);

	FColor AcceptButtonCol = FColor(0.f, 0.47f, 0.95f, 1.f);
	AcceptInviteButton = std::make_shared<FButtonWidget>(
		Position + Vector2(InSize.x / 2.0f - 105.0f, InSize.y - 45.f),
		Vector2(100.f, 30.f),
		InLayer - 1,
		L"Accept",
		assets::DefaultButtonAssets,
		InSmallFont,
		AcceptButtonCol);
	AcceptInviteButton->SetOnPressedCallback([this]()
	{
		const FSession& Session = GetSession();
		if (Session.IsValid())
		{
			FGame::Get().GetSessions()->JoinSession(FGame::Get().GetSessions()->GetInviteSessionHandle(), PresenceSessionCheckbox->IsTicked());
		}
		Hide();
	});
	AcceptInviteButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(AcceptInviteButton);

	FColor DeclineButtonCol = FColor(0.f, 0.47f, 0.95f, 1.f);
	DeclineInviteButton = std::make_shared<FButtonWidget>(
		Vector2(Position.x + InSize.x / 2.0f + 5.0f, AcceptInviteButton->GetPosition().y),
		Vector2(100.f, 30.f),
		InLayer - 1,
		L"Decline",
		assets::DefaultButtonAssets,
		InSmallFont,
		DeclineButtonCol);
	DeclineInviteButton->SetOnPressedCallback([this]()
	{
		Hide();
	});
	DeclineInviteButton->SetBackgroundColors(assets::DefaultButtonColors);
	AddWidget(DeclineInviteButton);
}

void FSessionInviteReceivedDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	Background->SetPosition(Position);
	MessageLabel->SetPosition(Position + Vector2(30.0f, 25.0f));
	FriendNameLabel->SetPosition(MessageLabel->GetPosition() + Vector2(5.0f, MessageLabel->GetSize().y + 5.0f));
	LevelNameLabel->SetPosition(FriendNameLabel->GetPosition() + Vector2(0.0f, FriendNameLabel->GetSize().y + 2.0f));
	PresenceSessionCheckbox->SetPosition(LevelNameLabel->GetPosition() + Vector2(MessageLabel->GetSize().x / 2.0f + 5.0f, MessageLabel->GetSize().y + 2.0f));
	AcceptInviteButton->SetPosition(Position + Vector2(GetSize().x / 2.0f - AcceptInviteButton->GetSize().x - 5.0f, GetSize().y - 45.0f));
	DeclineInviteButton->SetPosition(Position + Vector2(GetSize().x / 2.0f + 5.0f, GetSize().y - 45.0f));
}

void FSessionInviteReceivedDialog::SetSessionInfo(const std::wstring& InFriendName, const FSession& InSession)
{
	FriendName = InFriendName;
	Session = InSession;

	std::wstring LevelName;
	for (FSession::Attribute& Attr : Session.Attributes)
	{
		if (Attr.Key == SESSION_KEY_LEVEL)
		{
			LevelName = FStringUtils::Widen(Session.Attributes[0].AsString);
		}
	}

	if (MessageLabel)
	{
		MessageLabel->ClearText();
		MessageLabel->SetText(std::wstring(L"Session Invite Received"));
	}

	if (FriendNameLabel)
	{
		FriendNameLabel->ClearText();
		if (!InFriendName.empty())
		{
			FriendNameLabel->SetText(std::wstring(L"Friend: ") + InFriendName);
		}
	}

	if (LevelNameLabel)
	{
		LevelNameLabel->ClearText();
		if (!LevelName.empty())
		{
			LevelNameLabel->SetText(std::wstring(L"Level: ") + LevelName);
		}
	}

	if (FGame::Get().GetSessions()->HasPresenceSession())
	{
		PresenceSessionCheckbox->Disable();
		PresenceSessionCheckbox->SetTicked(false);
	}
	else
	{
		PresenceSessionCheckbox->Enable();
		PresenceSessionCheckbox->SetTicked(true);
	}
}

void FSessionInviteReceivedDialog::OnEscapePressed()
{
	Hide();
}
```

`EAC_SDK/Samples/SessionMatchmaking/Source/SessionInviteReceivedDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "SessionMatchmaking.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FButtonWidget;
class FCheckboxWidget;

/**
 * Session Invite Received dialog (simple popup to accept or decline the invitation)
 */
class FSessionInviteReceivedDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FSessionInviteReceivedDialog(Vector2 InPos,
		Vector2 InSize,
		UILayer InLayer,
		FontPtr InNormalFont,
		FontPtr InSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FSessionInviteReceivedDialog() {}

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	const FSession& GetSession() const { return Session; }
	void OnEscapePressed() override;

	void SetSessionInfo(const std::wstring& InFriendName, const FSession& InSession);

private:
	/** The name of friend who invited to session. */
	std::wstring FriendName;

	/** Session to join. Or not. */
	FSession Session;

	/** Background */
	WidgetPtr Background;

	/** Message label */
	std::shared_ptr<FTextLabelWidget> MessageLabel;

	/** Friend name label */
	std::shared_ptr<FTextLabelWidget> FriendNameLabel;

	/** Level name label */
	std::shared_ptr<FTextLabelWidget> LevelNameLabel;

	/** Accept invite button */
	std::shared_ptr<FButtonWidget> AcceptInviteButton;

	/** Decline invite button */
	std::shared_ptr<FButtonWidget> DeclineInviteButton;

	/** Is session for presence? */
	std::shared_ptr<FCheckboxWidget> PresenceSessionCheckbox;
};

```

`EAC_SDK/Samples/SessionMatchmaking/Source/SessionMatchmaking.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "SessionMatchmaking.h"
#include <eos_sdk.h>
#include <eos_sessions.h>
#include <eos_presence.h>
#include <eos_ui.h>
#include <eos_custominvites.h>

#include <regex>

//////////////////////////////////////////////////////////////////////////
// When set to 0 then the overlay will use the EOS Sessions Matchmaking service
// provided by the SDK for managing the game associated with presence and the overlay.
//
// Set to 1 to make the sample use the JoinInfo string with the overlay.
// This will demonstrate how to use a custom matchmaking service.  
// In this case the "custom matchmaking service" would be EOS Sessions Matchmaking.
//////////////////////////////////////////////////////////////////////////
#define USE_JOIN_INFO_WITH_OVERLAY 0

constexpr const char* SampleJoinInfoFormat = R"({"SessionId": "%s"})";
constexpr const char* SampleJoinInfoRegex = R"(\{\"SessionId\"\s*:\s*\"(.*)\"\})";
constexpr const char* JoinedSessionName = "Session#";
constexpr const size_t JoinedSessionNameRotationNum = 9;
constexpr const char* BucketId = "SessionSample:Region";

bool FSession::InitFromInfoOfSessionDetails(SessionDetailsKeeper SessionDetails)
{
	//retrieve info about session
	EOS_SessionDetails_Info* SessionInfo;

	EOS_SessionDetails_CopyInfoOptions CopyOptions = {};
	CopyOptions.ApiVersion = EOS_SESSIONDETAILS_COPYINFO_API_LATEST;
	EOS_EResult CopyResult = EOS_SessionDetails_CopyInfo(SessionDetails.get(), &CopyOptions, &SessionInfo);
	if (CopyResult != EOS_EResult::EOS_Success)
	{
		return false;
	}

	InitFromSessionInfo(SessionDetails.get(), SessionInfo);
	EOS_SessionDetails_Info_Release(SessionInfo);
	return true;
}

void FSession::InitFromSessionInfo(EOS_HSessionDetails SessionDetails, EOS_SessionDetails_Info* SessionInfo)
{
	if (SessionInfo && SessionInfo->Settings)
	{
		//copy session info
		bAllowJoinInProgress = SessionInfo->Settings->bAllowJoinInProgress;
		BucketId = SessionInfo->Settings->BucketId;
		PermissionLevel = SessionInfo->Settings->PermissionLevel;
		MaxPlayers = SessionInfo->Settings->NumPublicConnections;
		NumConnections = MaxPlayers - SessionInfo->NumOpenPublicConnections;
		Id = SessionInfo->SessionId;
		bPresenceSession = FGame::Get().GetSessions()->IsPresenceSession(Id);
	}

	//get attributes
	Attributes.clear();
	EOS_SessionDetails_GetSessionAttributeCountOptions CountOptions = {};
	CountOptions.ApiVersion = EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST;
	uint32_t AttrCount = EOS_SessionDetails_GetSessionAttributeCount(SessionDetails, &CountOptions);

	for (uint32_t AttrIndex = 0; AttrIndex < AttrCount; ++AttrIndex)
	{
		EOS_SessionDetails_CopySessionAttributeByIndexOptions AttrOptions = {};
		AttrOptions.ApiVersion = EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST;
		AttrOptions.AttrIndex = AttrIndex;

		EOS_SessionDetails_Attribute* Attr = NULL;
		EOS_EResult AttrCopyResult = EOS_SessionDetails_CopySessionAttributeByIndex(SessionDetails, &AttrOptions, &Attr);
		if (AttrCopyResult == EOS_EResult::EOS_Success && Attr && Attr->Data)
		{
			FSession::Attribute NextAttribute;
			NextAttribute.Advertisement = Attr->AdvertisementType;
			NextAttribute.Key = Attr->Data->Key;
			switch (Attr->Data->ValueType)
			{
			case EOS_ESessionAttributeType::EOS_SAT_Boolean:
				NextAttribute.ValueType = FSession::Attribute::Bool;
				NextAttribute.AsBool = Attr->Data->Value.AsBool;
				break;
			case EOS_ESessionAttributeType::EOS_SAT_Int64:
				NextAttribute.ValueType = FSession::Attribute::Int64;
				NextAttribute.AsInt64 = Attr->Data->Value.AsInt64;
				break;
			case EOS_ESessionAttributeType::EOS_SAT_Double:
				NextAttribute.ValueType = FSession::Attribute::Double;
				NextAttribute.AsDouble = Attr->Data->Value.AsDouble;
				break;
			case EOS_ESessionAttributeType::EOS_AT_STRING:
				NextAttribute.ValueType = FSession::Attribute::String;
				NextAttribute.AsString = Attr->Data->Value.AsUtf8;
				break;
			}

			Attributes.push_back(NextAttribute);
		}

		EOS_SessionDetails_Attribute_Release(Attr);
	}

	InitActiveSession();

	bUpdateInProgress = false;
}

void FSession::InitActiveSession()
{
	if (!ActiveSession)
	{
		if (!Name.empty())
		{
			EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());
			EOS_Sessions_CopyActiveSessionHandleOptions CopyASOptions = {};
			CopyASOptions.ApiVersion = EOS_SESSIONS_COPYACTIVESESSIONHANDLE_API_LATEST;
			CopyASOptions.SessionName = Name.c_str();
			EOS_HActiveSession ActiveSessionHandle;
			if (EOS_Sessions_CopyActiveSessionHandle(SessionsHandle, &CopyASOptions, &ActiveSessionHandle) != EOS_EResult::EOS_Success)
			{
				FDebugLog::LogError(L"Session Matchmaking: could not get ActiveSession for name: %ls.", FStringUtils::Widen(Name).c_str());
			}
			else
			{
				ActiveSession = MakeActiveSessionKeeper(ActiveSessionHandle);
			}
		}
	}
}

FSession FSession::InvalidSession = FSession();

FSessionSearch::~FSessionSearch()
{
	Release();
}

void FSessionSearch::Release()
{
	SearchResults.clear();

	if (SearchHandle)
	{
		EOS_SessionSearch_Release(SearchHandle);
		SearchHandle = nullptr;
	}

	ResultHandles.clear();
}

void FSessionSearch::SetNewSearch(EOS_HSessionSearch Handle)
{
	Release();
	SearchHandle = Handle;
}

void FSessionSearch::OnSearchResultsReceived(std::vector<FSession>&& Results, std::vector<SessionDetailsKeeper>&& Handles)
{
	SearchResults.swap(Results);
	ResultHandles.swap(Handles);
}


FSessionMatchmaking::FSessionMatchmaking()
{
	
}

FSessionMatchmaking::~FSessionMatchmaking()
{

}

void FSessionMatchmaking::OnShutdown()
{
	DestroyAllSessions();
	UnsubscribeFromGameInvites();
	UnsubscribeFromLeaveSessionUI();
}

void FSessionMatchmaking::Update()
{
	//Update active session from time to time
	for (std::pair<const std::string, FSession>& NextSession : CurrentSessions)
	{
		if (!NextSession.first.empty() &&
			NextSession.second.IsValid())
		{
			FSession& Session = NextSession.second;
			if (Session.bUpdateInProgress)
			{
				continue;
			}

			if (Session.ActiveSession != nullptr)
			{
				EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());
				EOS_ActiveSession_CopyInfoOptions CopyInfoOptions = {};
				CopyInfoOptions.ApiVersion = EOS_ACTIVESESSION_COPYINFO_API_LATEST;
				EOS_ActiveSession_Info* ActiveSessionInfo = nullptr;
				EOS_EResult Result = EOS_ActiveSession_CopyInfo(Session.ActiveSession.get(), &CopyInfoOptions, &ActiveSessionInfo);
				if (Result == EOS_EResult::EOS_Success)
				{
					if (ActiveSessionInfo)
					{
						Session.SessionState = ActiveSessionInfo->State;

						EOS_ActiveSession_Info_Release(ActiveSessionInfo);
					}
				}
				else
				{
					FDebugLog::LogError(L"Session Matchmaking: EOS_ActiveSession_CopyInfo failed. Errors code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
				}
			}

		}
	}
}

void FSessionMatchmaking::OnLoggedIn(FEpicAccountId UserId)
{
	SetJoinInfo("");
}

void FSessionMatchmaking::OnLoggedOut(FEpicAccountId UserId)
{
	SetJoinInfo("");
	CurrentSearch.Release();
	CurrentSessions.clear();
	CurrentInviteSessionHandle.reset();
	JoiningSessionDetails.reset();
}

void FSessionMatchmaking::OnUserConnectLoggedIn(FProductUserId ProductUserId)
{

}

void FSessionMatchmaking::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedOut(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		FProductUserId ProductUserId = Event.GetProductUserId();
		OnUserConnectLoggedIn(ProductUserId);
	}
	else if (Event.GetType() == EGameEventType::UserLogOutTriggered)
	{
		DestroyAllSessions();
	}
}

bool FSessionMatchmaking::CreateSession(const FSession& Session)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Session Matchmaking - CreateSession: Current player is invalid!");
		return false;
	}

	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());
	if (!SessionsHandle)
	{
		FDebugLog::LogError(L"Session Matchmaking: can't get sessions interface.");
		return false;
	}

	EOS_Sessions_CreateSessionModificationOptions CreateOptions = {};
	CreateOptions.ApiVersion = EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST;

	// The top - level, game - specific filtering information for session searches. This criteria should be set with mostly static, coarse settings, often formatted like "GameMode:Region:MapName".
	CreateOptions.BucketId = BucketId; 

	CreateOptions.MaxPlayers = Session.MaxPlayers;
	CreateOptions.SessionName = Session.Name.c_str();
	CreateOptions.LocalUserId = Player->GetProductUserID();
	CreateOptions.bPresenceEnabled = Session.bPresenceSession;
	CreateOptions.bSanctionsEnabled = EOS_FALSE;
	if (Session.RestrictedPlatform != ERestrictedPlatformType::Unrestricted)
	{
		RestrictedPlatform = static_cast<uint32_t>(Session.RestrictedPlatform);
		CreateOptions.AllowedPlatformIds = &RestrictedPlatform;
		CreateOptions.AllowedPlatformIdsCount = 1;
	}

	EOS_HSessionModification ModificationHandle = NULL;
	EOS_EResult CreateResult = EOS_Sessions_CreateSessionModification(SessionsHandle, &CreateOptions, &ModificationHandle);
	if (CreateResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking: could not create session modification. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(CreateResult)).c_str());
		return false;
	}


	EOS_SessionModification_SetPermissionLevelOptions PermOptions = {};
	PermOptions.ApiVersion = EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST;
	PermOptions.PermissionLevel = Session.PermissionLevel;
	EOS_EResult SetPermsResult = EOS_SessionModification_SetPermissionLevel(ModificationHandle, &PermOptions);
	if (SetPermsResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking: failed to set permissions. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(SetPermsResult)).c_str());
		EOS_SessionModification_Release(ModificationHandle);
		return false;
	}

	EOS_SessionModification_SetJoinInProgressAllowedOptions JIPOptions = {};
	JIPOptions.ApiVersion = EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST;
	JIPOptions.bAllowJoinInProgress = (Session.bAllowJoinInProgress) ? EOS_TRUE : EOS_FALSE;
	EOS_EResult SetJIPResult = EOS_SessionModification_SetJoinInProgressAllowed(ModificationHandle, &JIPOptions);
	if (SetJIPResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking: failed to set 'join in progress allowed' flag. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(SetJIPResult)).c_str());
		EOS_SessionModification_Release(ModificationHandle);
		return false;
	}

	EOS_SessionModification_SetInvitesAllowedOptions IAOptions = {};
	IAOptions.ApiVersion = EOS_SESSIONMODIFICATION_SETINVITESALLOWED_API_LATEST;
	IAOptions.bInvitesAllowed = (Session.bInvitesAllowed) ? EOS_TRUE : EOS_FALSE;
	EOS_EResult SetIAResult = EOS_SessionModification_SetInvitesAllowed(ModificationHandle, &IAOptions);
	if (SetIAResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking: failed to set invites allowed. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(SetIAResult)).c_str());
		EOS_SessionModification_Release(ModificationHandle);
		return false;
	}


	EOS_Sessions_AttributeData AttrData;
	AttrData.ApiVersion = EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST;

	EOS_SessionModification_AddAttributeOptions AttrOptions = {};
	AttrOptions.ApiVersion = EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST;
	AttrOptions.SessionAttribute = &AttrData;

	//Set bucket id
	AttrData.Key = EOS_SESSIONS_SEARCH_BUCKET_ID;
	AttrData.Value.AsUtf8 = BucketId;
	AttrData.ValueType = EOS_EAttributeType::EOS_AT_STRING;
	EOS_EResult SetAttrResult = EOS_SessionModification_AddAttribute(ModificationHandle, &AttrOptions);
	if (SetAttrResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking: failed to set a bucket id attribute. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(SetAttrResult)).c_str());
		EOS_SessionModification_Release(ModificationHandle);
		return false;
	}

	//Set other attributes
	for (const FSession::Attribute& NextAttribute : Session.Attributes)
	{
		AttrData.Key = NextAttribute.Key.c_str();

		switch (NextAttribute.ValueType)
		{
		case FSession::Attribute::Bool:
			AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Boolean;
			AttrData.Value.AsBool = NextAttribute.AsBool;
			break;
		case FSession::Attribute::Double:
			AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Double;
			AttrData.Value.AsDouble = NextAttribute.AsDouble;
			break;
		case FSession::Attribute::Int64:
			AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Int64;
			AttrData.Value.AsInt64 = NextAttribute.AsInt64;
			break;
		case FSession::Attribute::String:
			AttrData.ValueType = EOS_ESessionAttributeType::EOS_AT_STRING;
			AttrData.Value.AsUtf8 = NextAttribute.AsString.c_str();
			break;
		}

		AttrOptions.AdvertisementType = NextAttribute.Advertisement;
		EOS_EResult SetAttrResult = EOS_SessionModification_AddAttribute(ModificationHandle, &AttrOptions);
		if (SetAttrResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking: failed to set an attribute: %ls. Error code: %ls", NextAttribute.Key.c_str(), FStringUtils::Widen(EOS_EResult_ToString(SetAttrResult)).c_str());
			EOS_SessionModification_Release(ModificationHandle);
			return false;
		}
	}


	EOS_Sessions_UpdateSessionOptions UpdateOptions = {};
	UpdateOptions.ApiVersion = EOS_SESSIONS_UPDATESESSION_API_LATEST;
	UpdateOptions.SessionModificationHandle = ModificationHandle;
	EOS_Sessions_UpdateSession(SessionsHandle, &UpdateOptions, nullptr, OnUpdateSessionCompleteCallback_ForCreate);

	EOS_SessionModification_Release(ModificationHandle);

	CurrentSessions[Session.Name] = Session;
	CurrentSessions[Session.Name].bUpdateInProgress = true;

	return true;
}

bool FSessionMatchmaking::DestroySession(const std::string& Name)
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

	EOS_Sessions_DestroySessionOptions DestroyOptions = {};
	DestroyOptions.ApiVersion = EOS_SESSIONS_DESTROYSESSION_API_LATEST;
	DestroyOptions.SessionName = Name.c_str();

	EOS_Sessions_DestroySession(SessionsHandle, &DestroyOptions, new std::string(Name), OnDestroySessionCompleteCallback);

	return true;
}

void FSessionMatchmaking::DestroyAllSessions()
{
	SetJoinInfo("");
	for (const std::pair<std::string, FSession>& NextSession : CurrentSessions)
	{
		//We can't remove joined session
		if (NextSession.first.find(JoinedSessionName) == std::string::npos)
		{
			DestroySession(NextSession.first);
		}
	}
}

bool FSessionMatchmaking::HasActiveLocalSessions() const
{
	for (const std::pair<std::string, FSession>& NextSession : CurrentSessions)
	{
		if (NextSession.first.find(JoinedSessionName) == std::string::npos)
		{
			return true;
		}
	}
	return false;
}

bool FSessionMatchmaking::HasPresenceSession() const
{
	if (KnownPresenceSessionId.length() > 0)
	{
		if (CurrentSessions.find(KnownPresenceSessionId) != CurrentSessions.end())
		{
			return true;
		}
		KnownPresenceSessionId = std::string();
	}

	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		FProductUserId CurrentProductUserId = Player->GetProductUserID();
		if (!CurrentProductUserId.IsValid())
		{
			return false;
		}
	}

	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

	EOS_HSessionDetails SessionDetails = nullptr;

	EOS_Sessions_CopySessionHandleForPresenceOptions CopyOptions = {};
	CopyOptions.ApiVersion = EOS_SESSIONS_COPYSESSIONHANDLEFORPRESENCE_API_LATEST;
	CopyOptions.LocalUserId = Player->GetProductUserID();

	EOS_EResult CopyResult = EOS_Sessions_CopySessionHandleForPresence(SessionsHandle, &CopyOptions, &SessionDetails);
	if (CopyResult != EOS_EResult::EOS_Success)
	{
		return false;
	}

	if (!SessionDetails)
	{
		return false;
	}
	SessionDetailsKeeper  LocalSessionKeeper = MakeSessionDetailsKeeper(SessionDetails);

	EOS_SessionDetails_Info* SessionInfo = nullptr;
	EOS_SessionDetails_CopyInfoOptions CopyInfoOptions = {};
	CopyInfoOptions.ApiVersion = EOS_SESSIONDETAILS_COPYINFO_API_LATEST;
	CopyResult = EOS_SessionDetails_CopyInfo(SessionDetails, &CopyInfoOptions, &SessionInfo);
	if (CopyResult != EOS_EResult::EOS_Success)
	{
		return false;
	}

	KnownPresenceSessionId = SessionInfo->SessionId;
	return true;
}

bool FSessionMatchmaking::IsPresenceSession(const std::string& Id) const
{
	return HasPresenceSession() && Id == KnownPresenceSessionId;
}

const FSession* FSessionMatchmaking::GetPresenceSession() const
{
	if (!HasPresenceSession())
	{
		return nullptr;
	}

	for (const std::pair<const std::string, FSession>& CurrentSessionEntry : CurrentSessions)
	{
		if (CurrentSessionEntry.second.Id == KnownPresenceSessionId)
		{
			return &CurrentSessionEntry.second;
		}
	}

	return nullptr;
}

const FSession& FSessionMatchmaking::GetSession(const std::string& Name)
{
	auto iter = CurrentSessions.find(Name);
	if (iter != CurrentSessions.end())
	{
		return iter->second;
	}

	return FSession::InvalidSession;
}

void FSessionMatchmaking::StartSession(const std::string& Name)
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

	//search for current session by name
	auto iter = CurrentSessions.find(Name);
	if (iter == CurrentSessions.end())
	{
		FDebugLog::LogError(L"Session Matchmaking: can't start session: no active session with specified name.");
		return;
	}

	EOS_Sessions_StartSessionOptions StartSessionOptions = {};
	StartSessionOptions.ApiVersion = EOS_SESSIONS_STARTSESSION_API_LATEST;
	StartSessionOptions.SessionName = Name.c_str();

	std::string* SessionNamePtr = new std::string(Name);
	EOS_Sessions_StartSession(SessionsHandle, &StartSessionOptions, SessionNamePtr, OnStartSessionCompleteCallback);
}

void FSessionMatchmaking::EndSession(const std::string& Name)
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

	//search for current session by name
	auto iter = CurrentSessions.find(Name);
	if (iter == CurrentSessions.end())
	{
		FDebugLog::LogError(L"Session Matchmaking: can't end session: no active session with specified name.");
		return;
	}

	EOS_Sessions_EndSessionOptions EndSessionOptions = {};
	EndSessionOptions.ApiVersion = EOS_SESSIONS_ENDSESSION_API_LATEST;
	EndSessionOptions.SessionName = Name.c_str();

	std::string* SessionNamePtr = new std::string(Name);
	EOS_Sessions_EndSession(SessionsHandle, &EndSessionOptions, SessionNamePtr, OnEndSessionCompleteCallback);
}

void FSessionMatchmaking::Register(const std::string& SessionName, EOS_ProductUserId FriendId)
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

	EOS_Sessions_RegisterPlayersOptions RegisterPlayersOptions = {};
	RegisterPlayersOptions.ApiVersion = EOS_SESSIONS_REGISTERPLAYERS_API_LATEST;
	RegisterPlayersOptions.SessionName = SessionName.c_str();
	RegisterPlayersOptions.PlayersToRegisterCount = 1;
	RegisterPlayersOptions.PlayersToRegister = &FriendId;

	EOS_Sessions_RegisterPlayers(SessionsHandle, &RegisterPlayersOptions, nullptr, OnRegisterCompleteCallback);
}

void FSessionMatchmaking::Unregister(const std::string& SessionName, EOS_ProductUserId FriendId)
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

	EOS_Sessions_UnregisterPlayersOptions UnregisterPlayersOptions = {};
	UnregisterPlayersOptions.ApiVersion = EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST;
	UnregisterPlayersOptions.SessionName = SessionName.c_str();
	UnregisterPlayersOptions.PlayersToUnregisterCount = 1;
	UnregisterPlayersOptions.PlayersToUnregister = &FriendId;

	EOS_Sessions_UnregisterPlayers(SessionsHandle, &UnregisterPlayersOptions, nullptr, OnUnregisterCompleteCallback);
}

void FSessionMatchmaking::InviteToSession(const std::string& Name, FProductUserId FriendProductUserId)
{
	if (!FriendProductUserId.IsValid())
	{
		FDebugLog::LogError(L"Session Matchmaking - InviteToSession: friend's product user id is invalid!");
		return;
	}

	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		FProductUserId CurrentProductUserId = Player->GetProductUserID();
		if (!CurrentProductUserId.IsValid())
		{
			FDebugLog::LogError(L"Session Matchmaking - InviteToSession: current user's product user id is invalid!");
			return;
		}

		EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

		EOS_Sessions_SendInviteOptions SendInviteOptions = {};
		SendInviteOptions.ApiVersion = EOS_SESSIONS_SENDINVITE_API_LATEST;
		SendInviteOptions.LocalUserId = Player->GetProductUserID();
		SendInviteOptions.TargetUserId = FriendProductUserId;
		SendInviteOptions.SessionName = Name.c_str();
		EOS_Sessions_SendInvite(SessionsHandle, &SendInviteOptions, nullptr, OnSendInviteCompleteCallback);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking - InviteToSession: Current player is invalid!");
	}
}

void FSessionMatchmaking::RequestToJoinSession(const FProductUserId& FriendProductUserId)
{
	if (!FriendProductUserId.IsValid())
	{
		FDebugLog::LogError(L"Session Matchmaking - RequestToJoinSession: friend's product user id is invalid!");
		return;
	}

	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		FProductUserId CurrentProductUserId = Player->GetProductUserID();
		if (!CurrentProductUserId.IsValid())
		{
			FDebugLog::LogError(L"Session Matchmaking - RequestToJoinSession: current user's product user id is invalid!");
			return;
		}

		EOS_HCustomInvites CustomInvitesHandle = EOS_Platform_GetCustomInvitesInterface(FPlatform::GetPlatformHandle());
		EOS_CustomInvites_SendRequestToJoinOptions Options = {};
		Options.ApiVersion = EOS_CUSTOMINVITES_SENDREQUESTTOJOIN_API_LATEST;
		Options.LocalUserId = Player->GetProductUserID();
		Options.TargetUserId = FriendProductUserId;

		EOS_CustomInvites_SendRequestToJoin(CustomInvitesHandle, &Options, nullptr, OnSendRequestToJoinCompleteCallback);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking - RequestToJoinSession: Current player is invalid!");
	}
}

void FSessionMatchmaking::AcceptRequestToJoin(const FProductUserId& FriendProductUserId)
{
	if (!FriendProductUserId.IsValid())
	{
		FDebugLog::LogError(L"Session Matchmaking - AcceptRequestToJoin: friend's product user id is invalid!");
		return;
	}

	const FSession* PresenceSession = GetPresenceSession();
	if (PresenceSession == nullptr)
	{
		FDebugLog::LogError(L"Session Matchmaking - AcceptRequestToJoin: attempted to accept a request to join but there is no presence session available from which to send an invite. This request to join will not be deleted.");
		return;
	}

	std::string PresenceSessionName = PresenceSession->Name;

	if (PresenceSessionName.empty())
	{
		FDebugLog::LogError(L"Session Matchmaking - AcceptRequestToJoin: attempted to accept a request to join but there is no presence session available from which to send an invite. This request to join will not be deleted.");
		return;
	}

	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		FProductUserId CurrentProductUserId = Player->GetProductUserID();
		if (!CurrentProductUserId.IsValid())
		{
			FDebugLog::LogError(L"Session Matchmaking - AcceptRequestToJoin: current user's product user id is invalid!");
			return;
		}

		EOS_HCustomInvites CustomInvitesHandle = EOS_Platform_GetCustomInvitesInterface(FPlatform::GetPlatformHandle());
		EOS_CustomInvites_AcceptRequestToJoinOptions Options = {};
		Options.ApiVersion = EOS_CUSTOMINVITES_ACCEPTREQUESTTOJOIN_API_LATEST;
		Options.LocalUserId = Player->GetProductUserID();
		Options.TargetUserId = FriendProductUserId;

		EOS_CustomInvites_AcceptRequestToJoin(CustomInvitesHandle, &Options, nullptr, OnSendRequestToJoinAcceptedCallback);

		InviteToSession(PresenceSessionName, FriendProductUserId);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking - RequestToJoinSession: Current player is invalid!");
	}
}

void FSessionMatchmaking::RejectRequestToJoin(const FProductUserId& FriendProductUserId)
{
	if (!FriendProductUserId.IsValid())
	{
		FDebugLog::LogError(L"Session Matchmaking - RejectRequestToJoin: friend's product user id is invalid!");
		return;
	}

	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		FProductUserId CurrentProductUserId = Player->GetProductUserID();
		if (!CurrentProductUserId.IsValid())
		{
			FDebugLog::LogError(L"Session Matchmaking - RejectRequestToJoin: current user's product user id is invalid!");
			return;
		}

		EOS_HCustomInvites CustomInvitesHandle = EOS_Platform_GetCustomInvitesInterface(FPlatform::GetPlatformHandle());
		EOS_CustomInvites_RejectRequestToJoinOptions Options = {};
		Options.ApiVersion = EOS_CUSTOMINVITES_REJECTREQUESTTOJOIN_API_LATEST;
		Options.LocalUserId = Player->GetProductUserID();
		Options.TargetUserId = FriendProductUserId;

		EOS_CustomInvites_RejectRequestToJoin(CustomInvitesHandle, &Options, nullptr, OnSendRequestToJoinRejectedCallback);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking - RejectRequestToJoin: Current player is invalid!");
	}
}

void FSessionMatchmaking::SetInviteSession(const FSession& Session, SessionDetailsKeeper SessionHandle)
{
	CurrentInviteSession = Session;
	CurrentInviteSessionHandle = SessionHandle;
}

void FSessionMatchmaking::SubscribeToGameInvites()
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());
	EOS_HPresence PresenceHandle = EOS_Platform_GetPresenceInterface(FPlatform::GetPlatformHandle());
	EOS_HCustomInvites CustomInvitesHandle = EOS_Platform_GetCustomInvitesInterface(FPlatform::GetPlatformHandle());

	EOS_Sessions_AddNotifySessionInviteReceivedOptions InviteNotifyOptions = {};
	InviteNotifyOptions.ApiVersion = EOS_SESSIONS_ADDNOTIFYSESSIONINVITERECEIVED_API_LATEST;
	SessionInviteNotificationHandle = EOS_Sessions_AddNotifySessionInviteReceived(SessionsHandle, &InviteNotifyOptions, nullptr, OnSessionInviteReceivedCallback);

	EOS_Sessions_AddNotifySessionInviteAcceptedOptions InviteAcceptOptions = {};
	InviteAcceptOptions.ApiVersion = EOS_SESSIONS_ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST;
	SessionInviteAcceptedNotificationHandle = EOS_Sessions_AddNotifySessionInviteAccepted(SessionsHandle, &InviteAcceptOptions, nullptr, OnSessionInviteAcceptedCallback);

	EOS_Sessions_AddNotifySessionInviteRejectedOptions InviteRejectOptions = {};
	InviteRejectOptions.ApiVersion = EOS_SESSIONS_ADDNOTIFYSESSIONINVITEREJECTED_API_LATEST;
	SessionInviteRejectedNotificationHandle = EOS_Sessions_AddNotifySessionInviteRejected(SessionsHandle, &InviteRejectOptions, nullptr, OnSessionInviteRejectedCallback);

	EOS_Presence_AddNotifyJoinGameAcceptedOptions JoinGameAcceptedOptions = {};
	JoinGameAcceptedOptions.ApiVersion = EOS_PRESENCE_ADDNOTIFYJOINGAMEACCEPTED_API_LATEST;
	JoinGameNotificationHandle = EOS_Presence_AddNotifyJoinGameAccepted(PresenceHandle, &JoinGameAcceptedOptions, nullptr, OnPresenceJoinGameAcceptedCallback);

	EOS_Sessions_AddNotifyJoinSessionAcceptedOptions SessionJoinSessionAcceptedOptions = {};
	SessionJoinSessionAcceptedOptions.ApiVersion = EOS_SESSIONS_ADDNOTIFYJOINSESSIONACCEPTED_API_LATEST;
	SessionJoinGameNotificationHandle = EOS_Sessions_AddNotifyJoinSessionAccepted(SessionsHandle, &SessionJoinSessionAcceptedOptions, nullptr, OnSessionsJoinSessionAcceptedCallback);

	EOS_CustomInvites_AddNotifyRequestToJoinReceivedOptions RequestToJoinSessionReceivedOptions = {};
	RequestToJoinSessionReceivedOptions.ApiVersion = EOS_CUSTOMINVITES_ADDNOTIFYREQUESTTOJOINRECEIVED_API_LATEST;
	RequestToJoinSessionReceivedNotificationHandle = EOS_CustomInvites_AddNotifyRequestToJoinReceived(CustomInvitesHandle, &RequestToJoinSessionReceivedOptions, nullptr, OnRequestToJoinSessionReceivedCallback);
}

void FSessionMatchmaking::UnsubscribeFromGameInvites()
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());
	EOS_HPresence PresenceHandle = EOS_Platform_GetPresenceInterface(FPlatform::GetPlatformHandle());

	if (SessionInviteNotificationHandle != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Sessions_RemoveNotifySessionInviteReceived(SessionsHandle, SessionInviteNotificationHandle);
		SessionInviteNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	}	
	if (SessionInviteAcceptedNotificationHandle != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Sessions_RemoveNotifySessionInviteAccepted(SessionsHandle, SessionInviteAcceptedNotificationHandle);
		SessionInviteAcceptedNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	}
	if (SessionInviteRejectedNotificationHandle != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Sessions_RemoveNotifySessionInviteRejected(SessionsHandle, SessionInviteRejectedNotificationHandle);
		SessionInviteRejectedNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	}
	if (JoinGameNotificationHandle != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Presence_RemoveNotifyJoinGameAccepted(PresenceHandle, JoinGameNotificationHandle);
		JoinGameNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	}
	if (SessionJoinGameNotificationHandle != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Sessions_RemoveNotifyJoinSessionAccepted(SessionsHandle, SessionJoinGameNotificationHandle);
		SessionJoinGameNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	}
}

void FSessionMatchmaking::SubscribeToLeaveSessionUI()
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

	EOS_Sessions_AddNotifyLeaveSessionRequestedOptions LeaveSessionRequestedOptions = { };
	LeaveSessionRequestedOptions.ApiVersion = EOS_SESSIONS_ADDNOTIFYLEAVESESSIONREQUESTED_API_LATEST;
	LeaveSessionRequestedNotificationHandle = EOS_Sessions_AddNotifyLeaveSessionRequested(SessionsHandle, &LeaveSessionRequestedOptions, nullptr, OnLeaveSessionRequestedCallback);
}

void FSessionMatchmaking::UnsubscribeFromLeaveSessionUI()
{
	if (LeaveSessionRequestedNotificationHandle != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_Sessions_RemoveNotifyLeaveSessionRequested(EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle()), LeaveSessionRequestedNotificationHandle);
		LeaveSessionRequestedNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	}
}

void FSessionMatchmaking::Search(const std::vector<FSession::Attribute>& Attributes)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		//Clear previous search
		CurrentSearch.Release();

		EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

		EOS_HSessionSearch SearchHandle;
		EOS_Sessions_CreateSessionSearchOptions SearchOptions = {};
		SearchOptions.ApiVersion = EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST;
		SearchOptions.MaxSearchResults = 10;

		EOS_EResult Result = EOS_Sessions_CreateSessionSearch(SessionsHandle, &SearchOptions, &SearchHandle);
		if (Result != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking: failed to create session search. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
			return;
		}

		CurrentSearch.SetNewSearch(SearchHandle);

		EOS_SessionSearch_SetParameterOptions ParamOptions = {};
		ParamOptions.ApiVersion = EOS_SESSIONSEARCH_SETPARAMETER_API_LATEST;
		ParamOptions.ComparisonOp = EOS_EOnlineComparisonOp::EOS_CO_EQUAL;

		EOS_Sessions_AttributeData AttrData;
		AttrData.ApiVersion = EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST;
		ParamOptions.Parameter = &AttrData;

		//Set bucket id first. Sample uses the same bucket ids for all its sessions.
		//This is why we are using the same bucket id to search for sessions. See documentation for more info about bucket id usage.
		AttrData.Key = EOS_SESSIONS_SEARCH_BUCKET_ID;
		AttrData.ValueType = EOS_EAttributeType::EOS_AT_STRING;
		AttrData.Value.AsUtf8 = BucketId;
		Result = EOS_SessionSearch_SetParameter(SearchHandle, &ParamOptions);
		if (Result != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking: failed to update session search with bucket id parameter. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
			return;
		}

		//Set other attributes
		for (const FSession::Attribute& NextAttr : Attributes)
		{
			AttrData.Key = NextAttr.Key.c_str();

			switch (NextAttr.ValueType)
			{
			case FSession::Attribute::Bool:
				AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Boolean;
				AttrData.Value.AsBool = NextAttr.AsBool;
				break;
			case FSession::Attribute::Int64:
				AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Int64;
				AttrData.Value.AsInt64 = NextAttr.AsInt64;
				break;
			case FSession::Attribute::Double:
				AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Double;
				AttrData.Value.AsDouble = NextAttr.AsDouble;
				break;
			case FSession::Attribute::String:
				AttrData.ValueType = EOS_ESessionAttributeType::EOS_AT_STRING;
				AttrData.Value.AsUtf8 = NextAttr.AsString.c_str();
				break;
			}

			Result = EOS_SessionSearch_SetParameter(SearchHandle, &ParamOptions);
			if (Result != EOS_EResult::EOS_Success)
			{
				FDebugLog::LogError(L"Session Matchmaking: failed to update session search with parameter. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
				return;
			}
		}

		EOS_SessionSearch_FindOptions FindOptions = {};
		FindOptions.ApiVersion = EOS_SESSIONSEARCH_FIND_API_LATEST;
		FindOptions.LocalUserId = Player->GetProductUserID();
		EOS_SessionSearch_Find(SearchHandle, &FindOptions, nullptr, OnFindSessionsCompleteCallback);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking - Search: Current player is invalid!");
	}
}

void FSessionMatchmaking::SearchById(const std::string& SessionId)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		//Clear previous search
		CurrentSearch.Release();

		EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

		EOS_HSessionSearch SearchHandle;
		EOS_Sessions_CreateSessionSearchOptions SearchOptions = {};
		SearchOptions.ApiVersion = EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST;
		SearchOptions.MaxSearchResults = 10;

		EOS_EResult Result = EOS_Sessions_CreateSessionSearch(SessionsHandle, &SearchOptions, &SearchHandle);
		if (Result != EOS_EResult::EOS_Success)
		{
			// Sample currently doesn't retry after any errors; inform the UI that the Join Game attempt is complete. 
			AcknowledgeEventId(Result);
			FDebugLog::LogError(L"Session Matchmaking: failed create session search. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
			return;
		}

		CurrentSearch.SetNewSearch(SearchHandle);

		EOS_SessionSearch_SetSessionIdOptions SessionIdOptions = {};
		SessionIdOptions.ApiVersion = EOS_SESSIONSEARCH_SETSESSIONID_API_LATEST;
		SessionIdOptions.SessionId = SessionId.c_str();

		Result = EOS_SessionSearch_SetSessionId(SearchHandle, &SessionIdOptions);
		if (Result != EOS_EResult::EOS_Success)
		{
			// Sample currently doesn't retry after any errors; inform the UI that the Join Game attempt is complete. 
			AcknowledgeEventId(Result);
			FDebugLog::LogError(L"Session Matchmaking: failed to update session search with session ID. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
			return;
		}

		EOS_SessionSearch_FindOptions FindOptions = {};
		FindOptions.ApiVersion = EOS_SESSIONSEARCH_FIND_API_LATEST;
		FindOptions.LocalUserId = Player->GetProductUserID();
		EOS_SessionSearch_Find(SearchHandle, &FindOptions, nullptr, OnFindSessionsCompleteCallback);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking - SearchById: Current player is invalid!");
	}
}

SessionDetailsKeeper FSessionMatchmaking::MakeSessionHandleByInviteId(const std::string& InviteId)
{
	// retrieve handle to session details.
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());
	EOS_Sessions_CopySessionHandleByInviteIdOptions Options = {};
	Options.ApiVersion = EOS_SESSIONS_COPYSESSIONHANDLEBYINVITEID_API_LATEST;
	Options.InviteId = InviteId.c_str();
	EOS_HSessionDetails SessionDetails = nullptr;
	if (EOS_Sessions_CopySessionHandleByInviteId(SessionsHandle, &Options, &SessionDetails) == EOS_EResult::EOS_Success)
	{
		return MakeSessionDetailsKeeper(SessionDetails);
	}

	return nullptr;
}

SessionDetailsKeeper FSessionMatchmaking::MakeSessionHandleByEventId(const EOS_UI_EventId UiEventId)
{
	// retrieve handle to session details.
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());
	EOS_Sessions_CopySessionHandleByUiEventIdOptions Options = {};
	Options.ApiVersion = EOS_SESSIONS_COPYSESSIONHANDLEBYUIEVENTID_API_LATEST;
	Options.UiEventId = UiEventId;
	EOS_HSessionDetails SessionDetails = nullptr;
	if (EOS_Sessions_CopySessionHandleByUiEventId(SessionsHandle, &Options, &SessionDetails) == EOS_EResult::EOS_Success)
	{
		return MakeSessionDetailsKeeper(SessionDetails);
	}

	return nullptr;
}

SessionDetailsKeeper FSessionMatchmaking::GetSessionHandleFromSearch(const std::string& SessionId) const
{
	return CurrentSearch.GetSessionHandleById(SessionId);
}

void FSessionMatchmaking::JoinSession(SessionDetailsKeeper SessionHandle, bool bPresenceSession)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player != nullptr)
	{
		EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());

		std::string NewJoinedSessionName = GenerateJoinedSessionName();

		EOS_Sessions_JoinSessionOptions JoinOptions = {};
		JoinOptions.ApiVersion = EOS_SESSIONS_JOINSESSION_API_LATEST;
		JoinOptions.SessionHandle = SessionHandle.get();
		JoinOptions.SessionName = NewJoinedSessionName.c_str();
		JoinOptions.LocalUserId = Player->GetProductUserID();
		JoinOptions.bPresenceEnabled = bPresenceSession;
		
		EOS_Sessions_JoinSession(SessionsHandle, &JoinOptions, nullptr, OnJoinSessionCallback);

		SetJoiningSessionDetails(SessionHandle);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking - JoinSession: Current player is invalid!");
	}
}


bool FSessionMatchmaking::ModifySession(const FSession& Session)
{
	EOS_HSessions SessionsHandle = EOS_Platform_GetSessionsInterface(FPlatform::GetPlatformHandle());
	if (!SessionsHandle)
	{
		FDebugLog::LogError(L"Session Matchmaking: can't get sessions interface.");
		return false;
	}

	//search for current session by name
	auto iter = CurrentSessions.find(Session.Name);
	if (iter == CurrentSessions.end())
	{
		FDebugLog::LogError(L"Session Matchmaking: can't modify session: no active session with specified name.");
		return false;
	}

	FSession& CurrentSession = iter->second;

	EOS_Sessions_UpdateSessionModificationOptions UpdateModOptions = {};
	UpdateModOptions.ApiVersion = EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST;
	UpdateModOptions.SessionName = Session.Name.c_str();

	EOS_HSessionModification ModificationHandle = NULL;
	EOS_EResult UpdateResult = EOS_Sessions_UpdateSessionModification(SessionsHandle, &UpdateModOptions, &ModificationHandle);
	if (UpdateResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking: failed create session modification. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(UpdateResult)).c_str());
		return false;
	}

	//bucket id
	if (Session.BucketId != CurrentSession.BucketId)
	{
		EOS_SessionModification_SetBucketIdOptions BucketOptions = {};
		BucketOptions.ApiVersion = EOS_SESSIONMODIFICATION_SETBUCKETID_API_LATEST;
		BucketOptions.BucketId = Session.BucketId.c_str();
		EOS_EResult SetBucketIdResult = EOS_SessionModification_SetBucketId(ModificationHandle, &BucketOptions);
		if (SetBucketIdResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking: failed to set bucket id. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(SetBucketIdResult)).c_str());
			EOS_SessionModification_Release(ModificationHandle);
			return false;
		}
	}

	//max players
	if (Session.MaxPlayers != CurrentSession.MaxPlayers)
	{
		EOS_SessionModification_SetMaxPlayersOptions MaxPlayerOptions = {};
		MaxPlayerOptions.ApiVersion = EOS_SESSIONMODIFICATION_SETMAXPLAYERS_API_LATEST;
		MaxPlayerOptions.MaxPlayers = Session.MaxPlayers;
		EOS_EResult SetMaxPlayersResult = EOS_SessionModification_SetMaxPlayers(ModificationHandle, &MaxPlayerOptions);
		if (SetMaxPlayersResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking: failed to set maxp layers. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(SetMaxPlayersResult)).c_str());
			EOS_SessionModification_Release(ModificationHandle);
			return false;
		}
	}

	// modify permissions
	if (Session.PermissionLevel != CurrentSession.PermissionLevel)
	{
		EOS_SessionModification_SetPermissionLevelOptions PermOptions = {};
		PermOptions.ApiVersion = EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST;
		PermOptions.PermissionLevel = Session.PermissionLevel;
		EOS_EResult SetPermsResult = EOS_SessionModification_SetPermissionLevel(ModificationHandle, &PermOptions);
		if (SetPermsResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking: failed to set permissions. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(SetPermsResult)).c_str());
			EOS_SessionModification_Release(ModificationHandle);
			return false;
		}
	}

	// join in progress
	if (Session.bAllowJoinInProgress != CurrentSession.bAllowJoinInProgress)
	{
		EOS_SessionModification_SetJoinInProgressAllowedOptions JIPOptions = {};
		JIPOptions.ApiVersion = EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST;
		JIPOptions.bAllowJoinInProgress = (Session.bAllowJoinInProgress) ? EOS_TRUE : EOS_FALSE;
		EOS_EResult SetJIPResult = EOS_SessionModification_SetJoinInProgressAllowed(ModificationHandle, &JIPOptions);
		if (SetJIPResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking: failed to set 'join in progress allowed' flag. Error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(SetJIPResult)).c_str());
			EOS_SessionModification_Release(ModificationHandle);
			return false;
		}
	}

	EOS_Sessions_AttributeData AttrData;
	AttrData.ApiVersion = EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST;

	EOS_SessionModification_AddAttributeOptions AttrOptions = {};
	AttrOptions.ApiVersion = EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST;
	AttrOptions.SessionAttribute = &AttrData;

	for (const FSession::Attribute& NextAttribute : Session.Attributes)
	{
		//check if the attribute changed
		auto AttribFound = std::find_if(CurrentSession.Attributes.begin(), CurrentSession.Attributes.end(), [NextAttribute](const FSession::Attribute& Attrib) { return NextAttribute.Key == Attrib.Key; });
		if (AttribFound != CurrentSession.Attributes.end())
		{
			if (*AttribFound == NextAttribute)
			{
				//Attributes are equal, no need to change
				continue;
			}
		}

		AttrData.Key = NextAttribute.Key.c_str();

		switch (NextAttribute.ValueType)
		{
		case FSession::Attribute::Bool:
			AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Boolean;
			AttrData.Value.AsBool = NextAttribute.AsBool;
			break;
		case FSession::Attribute::Double:
			AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Double;
			AttrData.Value.AsDouble = NextAttribute.AsDouble;
			break;
		case FSession::Attribute::Int64:
			AttrData.ValueType = EOS_ESessionAttributeType::EOS_SAT_Int64;
			AttrData.Value.AsInt64 = NextAttribute.AsInt64;
			break;
		case FSession::Attribute::String:
			AttrData.ValueType = EOS_ESessionAttributeType::EOS_AT_STRING;
			AttrData.Value.AsUtf8 = NextAttribute.AsString.c_str();
			break;
		}

		AttrOptions.AdvertisementType = NextAttribute.Advertisement;
		EOS_EResult SetAttrResult = EOS_SessionModification_AddAttribute(ModificationHandle, &AttrOptions);
		if (SetAttrResult != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking: failed to set an attribute: %ls. Error code: %ls", NextAttribute.Key.c_str(), FStringUtils::Widen(EOS_EResult_ToString(SetAttrResult)).c_str());
			EOS_SessionModification_Release(ModificationHandle);
			return false;
		}
	}

	EOS_Sessions_UpdateSessionOptions UpdateOptions = {};
	UpdateOptions.ApiVersion = EOS_SESSIONS_UPDATESESSION_API_LATEST;
	UpdateOptions.SessionModificationHandle = ModificationHandle;
	EOS_Sessions_UpdateSession(SessionsHandle, &UpdateOptions, nullptr, OnUpdateSessionCompleteCallback);

	CurrentSession = Session;
	CurrentSession.bUpdateInProgress = true;

	EOS_SessionModification_Release(ModificationHandle);

	return true;
}

void FSessionMatchmaking::OnSessionDestroyed(const std::string& SessionName)
{
	if (!SessionName.empty())
	{
		auto iter = CurrentSessions.find(SessionName);
		if (iter != CurrentSessions.end())
		{
			if (iter->second.bPresenceSession)
			{
				SetJoinInfo("");
			}
			CurrentSessions.erase(iter);
		}
	}
}

void FSessionMatchmaking::OnSessionUpdateFinished(bool bSuccess, const std::string& Name, const std::string& SessionId, bool bRemoveSessionOnFailure /* = false */)
{
	auto Iter = CurrentSessions.find(Name);
	if (Iter != CurrentSessions.end())
	{
		FSession& Session = Iter->second;
		Session.Name = Name;
		Session.InitActiveSession();
		Session.bUpdateInProgress = false;

		if (bSuccess)
		{
			Session.Id = SessionId;
			if (Session.bPresenceSession)
			{
				SetJoinInfo(SessionId);
			}
		}
		else
		{
			if (bRemoveSessionOnFailure)
			{
				CurrentSessions.erase(Iter);
			}
		}
	}
}

void FSessionMatchmaking::OnSearchResultsReceived()
{
	EOS_SessionSearch_GetSearchResultCountOptions SearchResultOptions = {};
	SearchResultOptions.ApiVersion = EOS_SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST;
	uint32_t NumSearchResults = EOS_SessionSearch_GetSearchResultCount(CurrentSearch.GetSearchHandle(), &SearchResultOptions);

	std::vector<FSession> SearchResults;
	std::vector<SessionDetailsKeeper> ResultHandles;

	EOS_SessionSearch_CopySearchResultByIndexOptions IndexOptions = {};
	IndexOptions.ApiVersion = EOS_SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST;
	for (uint32_t i = 0; i < NumSearchResults; ++i)
	{
		FSession NextSession;

		EOS_HSessionDetails NextSessionHandle = nullptr;

		IndexOptions.SessionIndex = i;
		EOS_EResult Result = EOS_SessionSearch_CopySearchResultByIndex(CurrentSearch.GetSearchHandle(), &IndexOptions, &NextSessionHandle);
		if (Result == EOS_EResult::EOS_Success && NextSessionHandle)
		{
			EOS_SessionDetails_Info* SessionInfo = NULL;
			EOS_SessionDetails_CopyInfoOptions CopyOptions = {};
			CopyOptions.ApiVersion = EOS_SESSIONDETAILS_COPYINFO_API_LATEST;
			EOS_EResult CopyResult = EOS_SessionDetails_CopyInfo(NextSessionHandle, &CopyOptions, &SessionInfo);
			if (CopyResult == EOS_EResult::EOS_Success)
			{
				NextSession.InitFromSessionInfo(NextSessionHandle, SessionInfo);
				EOS_SessionDetails_Info_Release(SessionInfo);
			}
			NextSession.bSearchResult = true;
			SearchResults.push_back(NextSession);
			ResultHandles.push_back(MakeSessionDetailsKeeper(NextSessionHandle));

			//Check is we have a local session with same ID (we can retrieve the name this way).
			for (auto SessionPair : CurrentSessions)
			{
				if (SessionPair.second.Id == SearchResults.back().Id)
				{
					SearchResults.back().Name = SessionPair.first;
					break;
				}
			}
		}
	}

	CurrentSearch.OnSearchResultsReceived(std::move(SearchResults), std::move(ResultHandles));
	if (JoinPresenceSessionId.size() > 0)
	{
		if (SessionDetailsKeeper Handle = CurrentSearch.GetSessionHandleById(JoinPresenceSessionId))
		{
			// clear the session ID.
			JoinPresenceSessionId = std::string();
			const bool bPresenceEnabled = true;
			JoinSession(Handle, bPresenceEnabled);
		}
		else
		{
			// Sample currently doesn't retry after any errors; inform the UI that the Join Game attempt is complete. 
			AcknowledgeEventId(EOS_EResult::EOS_NotFound);
		}
	}
	else
	{
		// Sample currently doesn't retry after any errors; inform the UI that the Join Game attempt is complete. 
		AcknowledgeEventId(EOS_EResult::EOS_NotFound);
	}
}

void FSessionMatchmaking::SetJoiningSessionDetails(SessionDetailsKeeper NewDetails)
{
	JoiningSessionDetails = NewDetails;
}

void FSessionMatchmaking::OnJoinSessionFinished()
{
	if (JoiningSessionDetails)
	{
		EOS_SessionDetails_Info* SessionInfo = NULL;
		EOS_SessionDetails_CopyInfoOptions CopyOptions = {};
		CopyOptions.ApiVersion = EOS_SESSIONDETAILS_COPYINFO_API_LATEST;
		EOS_EResult CopyResult = EOS_SessionDetails_CopyInfo(JoiningSessionDetails.get(), &CopyOptions, &SessionInfo);
		if (CopyResult == EOS_EResult::EOS_Success)
		{
			FSession Session;
			Session.Name = GenerateJoinedSessionName(true);
			Session.InitFromSessionInfo(JoiningSessionDetails.get(), SessionInfo);
			// local user is joining this session
			// Without p2p, the sample is incapable of communicating to host to call EOS_Sessions_RegisterPlayer and update this globally
			Session.NumConnections += 1; 
			EOS_SessionDetails_Info_Release(SessionInfo);

			// Check if we have a local session with same ID (no need to add an extra one in this case).
			bool bLocalSessionFound = false;
			for (auto SessionPair : CurrentSessions)
			{
				if (SessionPair.second.Id == Session.Id)
				{
					bLocalSessionFound = true;
					if (Session.bPresenceSession)
					{
						SetJoinInfo(Session.Id);
					}
					break;
				}
			}

			if (!bLocalSessionFound)
			{
				CurrentSessions[Session.Name] = Session;
				if (Session.bPresenceSession)
				{
					SetJoinInfo(Session.Id);
				}
			}
		}
	}

	//Trigger UI event to clear search (if started)
	FGameEvent Event(EGameEventType::SessionJoined);
	FGame::Get().OnGameEvent(Event);
}

void FSessionMatchmaking::OnSessionStarted(const std::string& Name)
{
	auto iter = CurrentSessions.find(Name);
	if (iter != CurrentSessions.end())
	{
		iter->second.SessionState = EOS_EOnlineSessionState::EOS_OSS_InProgress;
	}
}

void FSessionMatchmaking::OnSessionEnded(const std::string& Name)
{
	auto iter = CurrentSessions.find(Name);
	if (iter != CurrentSessions.end())
	{
		iter->second.SessionState = EOS_EOnlineSessionState::EOS_OSS_Ended;
	}
}

void FSessionMatchmaking::SetJoinInfo(const std::string& SessionId)
{
#if USE_JOIN_INFO_WITH_OVERLAY
	// Local buffer to hold the `JoinInfo` string if its used.
	char JoinInfoBuffer[EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH + 1];

	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr)
	{
		FDebugLog::LogError(L"Session Matchmaking - SetJoinInfo: Current player is invalid!");
		return;
	}

	EOS_HPresence PresenceHandle = EOS_Platform_GetPresenceInterface(FPlatform::GetPlatformHandle());

	EOS_Presence_CreatePresenceModificationOptions CreateModOpt = {};
	CreateModOpt.ApiVersion = EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST;
	CreateModOpt.LocalUserId = Player->GetUserID();

	EOS_HPresenceModification PresenceModification;
	EOS_EResult Result = EOS_Presence_CreatePresenceModification(PresenceHandle, &CreateModOpt, &PresenceModification);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Create presence modification failed: %ls.", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	EOS_PresenceModification_SetJoinInfoOptions JoinOptions = {};
	JoinOptions.ApiVersion = EOS_PRESENCEMODIFICATION_SETJOININFO_API_LATEST;
	if (SessionId.length() == 0)
	{
		// Clear the JoinInfo string if there is no local sessionId.
		JoinOptions.JoinInfo = nullptr;
	}
	else
	{
		// Use the local sessionId to build a JoinInfo string to share with friends.
		snprintf(JoinInfoBuffer, EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH, SampleJoinInfoFormat, SessionId.c_str());
		JoinOptions.JoinInfo = JoinInfoBuffer;
	}
	EOS_PresenceModification_SetJoinInfo(PresenceModification, &JoinOptions);

	EOS_Presence_SetPresenceOptions SetOpt = {};
	SetOpt.ApiVersion = EOS_PRESENCE_SETPRESENCE_API_LATEST;
	SetOpt.LocalUserId = Player->GetUserID();
	SetOpt.PresenceModificationHandle = PresenceModification;
	EOS_Presence_SetPresence(PresenceHandle, &SetOpt, nullptr, FSessionMatchmaking::OnSetPresenceCallback);

	EOS_PresenceModification_Release(PresenceModification);
#endif
}

void FSessionMatchmaking::OnJoinGameAcceptedByJoinInfo(const std::string& JoinInfo, EOS_UI_EventId UiEventId)
{
	JoinUiEvent = UiEventId;

	std::regex JoinInfoRegex(SampleJoinInfoRegex);
	std::smatch JoinInfoMatch;
	if (std::regex_match(JoinInfo, JoinInfoMatch, JoinInfoRegex))
	{
		if (JoinInfoMatch.size() == 2)
		{
			JoinPresenceSessionById(JoinInfoMatch[1].str());
			return;
		}
	}

	// This should be impossible since the JoinInfo string was generated by the sample; inform the UI of the completed join game attempt.
	AcknowledgeEventId(EOS_EResult::EOS_UnexpectedError);
	FDebugLog::LogError(L"Session Matchmaking - OnJoinGameAccepted: unable to parse location string: %ls", FStringUtils::Widen(JoinInfo).c_str());
}

void FSessionMatchmaking::OnJoinGameAcceptedByEventId(EOS_UI_EventId UiEventId)
{
	SessionDetailsKeeper EventSession = MakeSessionHandleByEventId(UiEventId);
	if (EventSession)
	{
		const bool bPresenceEnabled = true;
		JoinSession(EventSession, bPresenceEnabled);
	}
	else
	{
		// This should be impossible since the fact that the callback was received means that the session handle exists.
		JoinUiEvent = UiEventId;
		AcknowledgeEventId(EOS_EResult::EOS_UnexpectedError);
		FDebugLog::LogError(L"Session Matchmaking - OnJoinGameAccepted: unable to get details for event ID: %d", UiEventId);
	}
}

void FSessionMatchmaking::JoinPresenceSessionById(const std::string& SessionId)
{
	JoinPresenceSessionId = SessionId;
	FDebugLog::Log(L"Session Matchmaking - JoinPresenceSessionById: looking for session ID: %ls", FStringUtils::Widen(JoinPresenceSessionId).c_str());
	SearchById(JoinPresenceSessionId);
}

void FSessionMatchmaking::AcknowledgeEventId(EOS_EResult Result)
{
	if (JoinUiEvent != EOS_UI_EVENTID_INVALID)
	{
		EOS_HUI UIHandle = EOS_Platform_GetUIInterface(FPlatform::GetPlatformHandle());

		EOS_UI_AcknowledgeEventIdOptions Options = {};
		Options.ApiVersion = EOS_UI_ACKNOWLEDGECORRELATIONID_API_LATEST;
		Options.UiEventId = JoinUiEvent;
		Options.Result = Result;
		EOS_UI_AcknowledgeEventId(UIHandle, &Options);
		JoinUiEvent = EOS_UI_EVENTID_INVALID;
	}
}

std::string FSessionMatchmaking::GenerateJoinedSessionName(bool bNoIncrement /* = false */)
{
	if (!bNoIncrement)
	{
		JoinedSessionIndex = (JoinedSessionIndex + 1) % JoinedSessionNameRotationNum;
	}

	static char Buffer[32];
	sprintf_s(Buffer, sizeof(Buffer), "%s%d", JoinedSessionName, (int)JoinedSessionIndex);

	return std::string(Buffer);
}

void EOS_CALL FSessionMatchmaking::OnUpdateSessionCompleteCallback(const EOS_Sessions_UpdateSessionCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FGame::Get().GetSessions()->OnSessionUpdateFinished(false, Data->SessionName, Data->SessionId);
			FDebugLog::LogError(L"Session Matchmaking (OnUpdateSessionCompleteCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FGame::Get().GetSessions()->OnSessionUpdateFinished(true, Data->SessionName, Data->SessionId);
			FDebugLog::Log(L"Session Matchmaking: game session updated successfully.");
		}
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnUpdateSessionCompleteCallback): EOS_Sessions_UpdateSessionCallbackInfo is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnUpdateSessionCompleteCallback_ForCreate(const EOS_Sessions_UpdateSessionCallbackInfo* Data)
{
	if (!Data)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnUpdateSessionCompleteCallback): EOS_Sessions_UpdateSessionCallbackInfo is null");
		return;
	}

	bool bRemoveSession = true;
	const bool bSuccess = Data->ResultCode == EOS_EResult::EOS_Success;
	if (bSuccess)
	{
		PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
		if (Player != nullptr)
		{
			//Register session owner
			FGame::Get().GetSessions()->Register(Data->SessionName, Player->GetProductUserID());
			bRemoveSession = false;
		}
		else
		{
			//Failing to register is not considered a critical error, that's why we don't remove created session here
			FDebugLog::LogError(L"Session Matchmaking (OnUpdateSessionCompleteCallback_ForCreate): player is null, can't register yourself in created session.");
		}

		//We don't wait for register to finish
		FDebugLog::Log(L"Session Matchmaking: game session created successfully.");
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnUpdateSessionCompleteCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}

	FGame::Get().GetSessions()->OnSessionUpdateFinished(bSuccess, Data->SessionName, Data->SessionId, bRemoveSession);
}

void EOS_CALL FSessionMatchmaking::OnStartSessionCompleteCallback(const EOS_Sessions_StartSessionCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		std::string* SessionNamePtr = static_cast<std::string*>(Data->ClientData);

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking (OnStartSessionCompleteCallback): session name: '%ls' error code: %ls", FStringUtils::Widen(*SessionNamePtr).c_str(), FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FGame::Get().GetSessions()->OnSessionStarted(*SessionNamePtr);
		}
		delete SessionNamePtr;
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnStartSessionCompleteCallback): EOS_Sessions_StartSessionCallbackInfo is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnEndSessionCompleteCallback(const EOS_Sessions_EndSessionCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		std::string* SessionNamePtr = static_cast<std::string*>(Data->ClientData);

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking (OnEndSessionCompleteCallback): session name: '%ls' error code: %ls", FStringUtils::Widen(*SessionNamePtr).c_str(), FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FGame::Get().GetSessions()->OnSessionEnded(*SessionNamePtr);
		}
		delete SessionNamePtr;
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnEndSessionCompleteCallback): EOS_Sessions_EndSessionCallbackInfo is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnDestroySessionCompleteCallback(const EOS_Sessions_DestroySessionCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		std::string* SessionNameStringPtr = static_cast<std::string*>(Data->ClientData);
		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking (OnDestroySessionCompleteCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			if (SessionNameStringPtr)
			{
				FGame::Get().GetSessions()->OnSessionDestroyed(*SessionNameStringPtr);
			}
		}
		delete SessionNameStringPtr;
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnDestroySessionCompleteCallback): OnDestroySessionCompleteCallback is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnRegisterCompleteCallback(const EOS_Sessions_RegisterPlayersCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking (OnRegisterCompleteCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnRegisterCompleteCallback): OnRegisterCompleteCallback is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnUnregisterCompleteCallback(const EOS_Sessions_UnregisterPlayersCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking (OnUnregisterCompleteCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnUnregisterCompleteCallback): OnUnregisterCompleteCallback is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnFindSessionsCompleteCallback(const EOS_SessionSearch_FindCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			// Session no longer exists to join; inform the UI of the completed join game attempt.
			FGame::Get().GetSessions()->AcknowledgeEventId(Data->ResultCode);
			FDebugLog::LogError(L"Session Matchmaking (OnFindSessionsCompleteCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FGame::Get().GetSessions()->OnSearchResultsReceived();
		}
	}
	else
	{
		// Should be impossible; inform the UI of the completed join game attempt.
		FGame::Get().GetSessions()->AcknowledgeEventId(EOS_EResult::EOS_UnexpectedError);
		FDebugLog::LogError(L"Session Matchmaking (OnUnregisterCompleteCallback): OnUnregisterCompleteCallback is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnSendInviteCompleteCallback(const EOS_Sessions_SendInviteCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking (OnSendInviteCompleteCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Session Matchmaking: invite to session sent successfully.");
		}
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSendInviteCompleteCallback): OnUnregisterCompleteCallback is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnSessionInviteReceivedCallback(const EOS_Sessions_SessionInviteReceivedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Session Matchmaking: invite to session received. Invite id: %ls", FStringUtils::Widen(Data->InviteId).c_str());

		if (SessionDetailsKeeper SessionDetails = MakeSessionHandleByInviteId(Data->InviteId))
		{
			FSession InviteSession;
			if (InviteSession.InitFromInfoOfSessionDetails(SessionDetails))
			{

				FGame::Get().GetSessions()->SetInviteSession(InviteSession, SessionDetails);

				//Show popup
				FGameEvent Event(EGameEventType::InviteToSessionReceived, Data->TargetUserId, FStringUtils::Widen(Data->InviteId));
				FGame::Get().OnGameEvent(Event);
			}
			else
			{
				FDebugLog::LogError(L"Session Matchmaking (OnSessionInviteReceivedCallback): Could not copy session information for invite id %ls.", FStringUtils::Widen(Data->InviteId).c_str());
			}
		}
		else
		{
			FDebugLog::LogError(L"Session Matchmaking (OnSessionInviteReceivedCallback): Could not get session details for invite id %ls.", FStringUtils::Widen(Data->InviteId).c_str());
		}
	}
}

void EOS_CALL FSessionMatchmaking::OnSessionInviteAcceptedCallback(const EOS_Sessions_SessionInviteAcceptedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Session Matchmaking: invite to session accepted. Session id: %ls; Invite id: %ls", FStringUtils::Widen(Data->SessionId).c_str(), FStringUtils::Widen(Data->InviteId).c_str());

		//Hide popup
		FGameEvent Event(EGameEventType::OverlayInviteToSessionAccepted);
		FGame::Get().OnGameEvent(Event);

		if (SessionDetailsKeeper InviteSessionKeeper = MakeSessionHandleByInviteId(Data->InviteId))
		{
			const bool bPresenceEnabled = true;
			FGame::Get().GetSessions()->JoinSession(InviteSessionKeeper, bPresenceEnabled);
		}
		else
		{
			FDebugLog::LogError(L"Session Matchmaking (OnSessionInviteReceivedCallback): Could not get session details by invite id %ls.", FStringUtils::Widen(Data->InviteId).c_str());
		}
	}
}

void EOS_CALL FSessionMatchmaking::OnSessionInviteRejectedCallback(const EOS_Sessions_SessionInviteRejectedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Session Matchmaking: invite to session rejected. Session id: %ls; Invite id: %ls", FStringUtils::Widen(Data->SessionId).c_str(), FStringUtils::Widen(Data->InviteId).c_str());

		//Hide popup
		FGameEvent Event(EGameEventType::OverlayInviteToSessionAccepted);
		FGame::Get().OnGameEvent(Event);
	}
}

void EOS_CALL FSessionMatchmaking::OnSendRequestToJoinCompleteCallback(const EOS_CustomInvites_SendRequestToJoinCallbackInfo* Data)
{
	if (Data == nullptr)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSendRequestToJoinCompleteCallback): EOS_CustomInvites_SendRequestToJoinCallbackInfo is null");
	}

	if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
	{
		FDebugLog::Log(L"Session Matchmaking (OnSendRequestToJoinCompleteCallback): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}
	else if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSendRequestToJoinCompleteCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}
	else
	{
		FDebugLog::Log(L"Session Matchmaking: request to join session sent successfully.");
	}
}

void EOS_CALL FSessionMatchmaking::OnSendRequestToJoinAcceptedCallback(const EOS_CustomInvites_AcceptRequestToJoinCallbackInfo* Data)
{
	if (Data == nullptr)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSendRequestToJoinAcceptedCallback): EOS_CustomInvites_SendRequestToJoinCallbackInfo is null");
		return;
	}

	if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
	{
		FDebugLog::Log(L"Session Matchmaking (OnSendRequestToJoinAcceptedCallback): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}
	else if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSendRequestToJoinAcceptedCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}
	else
	{
		FDebugLog::Log(L"Session Matchmaking: request to join session accepted successfully.");
	}
}

void EOS_CALL FSessionMatchmaking::OnSendRequestToJoinRejectedCallback(const EOS_CustomInvites_RejectRequestToJoinCallbackInfo* Data)
{
	if (Data == nullptr)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSendRequestToJoinRejectedCallback): EOS_CustomInvites_RejectRequestToJoinCallbackInfo is null");
		return;
	}

	if (!EOS_EResult_IsOperationComplete(Data->ResultCode))
	{
		FDebugLog::Log(L"Session Matchmaking (OnSendRequestToJoinRejectedCallback): operation not complete: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}
	else if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSendRequestToJoinRejectedCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}
	else
	{
		FDebugLog::Log(L"Session Matchmaking: request to join session rejected successfully.");
	}
}

void EOS_CALL FSessionMatchmaking::OnRequestToJoinSessionReceivedCallback(const EOS_CustomInvites_RequestToJoinReceivedCallbackInfo* Data)
{
	if (Data == nullptr)
	{
		FDebugLog::Log(L"Session Matchmaking: request to join received callback invoked but the callback data was not set.");
		return;
	}

	FDebugLog::Log(L"Session Matchmaking: request to join received.");

	const FSession* PresenceSession = FGame::Get().GetSessions()->GetPresenceSession();

	if (PresenceSession == nullptr)
	{
		FDebugLog::LogError(L"Session Matchmaking: request to join received but there is no presence session.");
		FGame::Get().GetSessions()->RejectRequestToJoin(Data->FromUserId);
		return;
	}

	//Show popup
	FGameEvent Event(EGameEventType::RequestToJoinSessionReceived, Data->FromUserId);
	FGame::Get().OnGameEvent(Event);
}

void EOS_CALL FSessionMatchmaking::OnJoinSessionCallback(const EOS_Sessions_JoinSessionCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}

		if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Session Matchmaking (OnJoinSessionCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Session Matchmaking: joined session successfully.");

			//add joined session to the list of current sessions
			FGame::Get().GetSessions()->OnJoinSessionFinished();
		}

		// Always inform the UI of the completed join game attempt.
		FGame::Get().GetSessions()->AcknowledgeEventId(Data->ResultCode);
	}
	else
	{
		// Should be impossible; inform the UI of the completed join game attempt.
		FGame::Get().GetSessions()->AcknowledgeEventId(EOS_EResult::EOS_UnexpectedError);
		FDebugLog::LogError(L"Session Matchmaking (OnJoinSessionCallback): EOS_Sessions_JoinSessionCallbackInfo is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnPresenceJoinGameAcceptedCallback(const EOS_Presence_JoinGameAcceptedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Session Matchmaking: join game accepted successfully.");

		//add joined session to the list of current sessions
		FGame::Get().GetSessions()->OnJoinGameAcceptedByJoinInfo(Data->JoinInfo, Data->UiEventId);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnPresenceJoinGameAcceptedCallback): EOS_Presence_JoinGameAcceptedCallbackInfo is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnSessionsJoinSessionAcceptedCallback(const EOS_Sessions_JoinSessionAcceptedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Session Matchmaking: join game accepted successfully.");

		//add joined session to the list of current sessions
		FGame::Get().GetSessions()->OnJoinGameAcceptedByEventId(Data->UiEventId);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSessionsJoinGameAcceptedCallback): EOS_Sessions_JoinGameAcceptedCallbackInfo is null");
	}
}

void EOS_CALL FSessionMatchmaking::OnSetPresenceCallback(const EOS_Presence_SetPresenceCallbackInfo* Data)
{
	if (!Data)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSetPresenceCallback): EOS_Presence_SetPresenceCallbackInfo is null");
	}
	else if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}
	else if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Session Matchmaking (OnSetPresenceCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}
	else
	{
		FDebugLog::Log(L"Session Matchmaking: set presence successfully.");
	}

}

void EOS_CALL FSessionMatchmaking::OnLeaveSessionRequestedCallback(const EOS_Sessions_LeaveSessionRequestedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Session Matchmaking: leave session requested for session = %ls", FStringUtils::Widen(Data->SessionName).c_str());
		FGame::Get().GetSessions()->DestroySession(Data->SessionName);
	}
	else
	{
		FDebugLog::LogError(L"Session Matchmaking (OnLeaveSessionRequestedCallback): EOS_Sessions_LeaveSessionRequestedCallbackInfo is null");
	}
}

```

`EAC_SDK/Samples/SessionMatchmaking/Source/SessionMatchmaking.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_sdk.h>
#include <eos_sessions.h>

constexpr char* SESSION_KEY_LEVEL = "LEVEL";

/**
 * These values are defined within the SDK in platform specific headers. In this example,
 * Sessions are created from PC so the values are all redefined here. This is indicative of what
 * game developers would need to employ for Windows or Linux based dedicated servers that
 * employ platform restrictions for console clients. There is an NDA concern regarding platform names
 * but the assumption is that a game developer creating a dedicated server to play with a console 
 * platform has an NDA in place for that platform.
 */
enum class ERestrictedPlatformType
{
	Unrestricted = 0,	// Unrestricted - all platforms allowed 
	PSN = 1000,			// Any Sony platform (PS4 or PS5)
	Switch = 2000,		// Nintendo (Switch only)
	XboxLive = 3000		// XSX and XboxOneGDK 
};

//Simple RAII wrapper to make sure SessionDetails handles are released correctly.
using SessionDetailsKeeper = std::shared_ptr<struct EOS_SessionDetailsHandle>;
inline SessionDetailsKeeper MakeSessionDetailsKeeper(EOS_HSessionDetails SessionDetails)
{
	return SessionDetailsKeeper(SessionDetails, EOS_SessionDetails_Release);
}

//Simple RAII wrapper to make sure ActiveSession handles are released correctly.
using ActiveSessionKeeper = std::shared_ptr<struct EOS_ActiveSessionHandle>;
inline ActiveSessionKeeper MakeActiveSessionKeeper(EOS_HActiveSession ActiveSession)
{
	return ActiveSessionKeeper(ActiveSession, EOS_ActiveSession_Release);
}

/** 
 * Game session class. Contains all the session information. Some properties can be unavailable (and left empty) at times.
 */
struct FSession
{
	/**
	 * Simple Attribute struct to contain session's attribute information. It can have a value from one of the available types.
	 */
	struct Attribute
	{
		enum Type
		{
			String,
			Int64,
			Double,
			Bool
		};
		Type ValueType = Type::String;

		//Only one of the following properties will have valid data (depending on 'ValueType')
		int64_t AsInt64 = 0;
		double AsDouble = 0.0;
		bool AsBool = false;
		std::string AsString;

		//Attribute key
		std::string Key;

		//Publicity of the attribute
		EOS_ESessionAttributeAdvertisementType Advertisement = EOS_ESessionAttributeAdvertisementType::EOS_SAAT_DontAdvertise;

		bool operator==(const Attribute& Other) const
		{
			return ValueType == Other.ValueType &&
				AsInt64 == Other.AsInt64 &&
				AsDouble == Other.AsDouble &&
				AsBool == Other.AsBool &&
				Key == Other.Key &&
				Advertisement == Other.Advertisement &&
				AsString == Other.AsString;
		}

		bool operator !=(const Attribute& Other) const
		{
			return !(operator==(Other));
		}
	};

	//Session is considered valid when either name or session id is valid.
	bool IsValid() const { return !Name.empty() || !Id.empty(); }

	bool operator==(const FSession& Other) const
	{
		return Name == Other.Name &&
			Id == Other.Id &&
			BucketId == Other.BucketId &&
			MaxPlayers == Other.MaxPlayers &&
			NumConnections == Other.NumConnections &&
			bAllowJoinInProgress == Other.bAllowJoinInProgress &&
			bPresenceSession == Other.bPresenceSession &&
			bInvitesAllowed == Other.bInvitesAllowed &&
			PermissionLevel == Other.PermissionLevel &&
			Attributes == Other.Attributes;
	}

	bool operator !=(const FSession& Other) const
	{
		return !(operator==(Other));
	}

	const Attribute* GetAttribute(std::string AttrKey) const
	{
		for (const auto& NextAttr : Attributes)
		{
			if (NextAttr.Key == AttrKey)
			{
				return &NextAttr;
			}
		}

		return nullptr;
	}

	//Initialize our structure based on SessionInfo of a SessionDetails from EOS_SDK
	bool InitFromInfoOfSessionDetails(SessionDetailsKeeper SessionDetails);
	//Initialize our structure based on SessionInfo from EOS_SDK
	void InitFromSessionInfo(EOS_HSessionDetails SessionHandle, EOS_SessionDetails_Info* SessionInfo);
	void InitActiveSession();

	std::string Name;
	std::string Id;
	std::string BucketId; // The top - level, game - specific filtering information for session searches. This criteria should be set with mostly static, coarse settings, often formatted like "GameMode:Region:MapName".
	uint32_t MaxPlayers;
	uint32_t NumConnections = 1; //optional ('1' because we will register the owner with the session right after create)
	bool bAllowJoinInProgress;
	bool bPresenceSession = false;
	bool bInvitesAllowed = true;
	ERestrictedPlatformType RestrictedPlatform = ERestrictedPlatformType::Unrestricted;
	EOS_EOnlineSessionPermissionLevel PermissionLevel;
	ActiveSessionKeeper ActiveSession;

	std::vector<Attribute> Attributes;

	//UI-related. Is this session coming from search query?
	bool bSearchResult = false;

	//Are we updating session at the moment?
	bool bUpdateInProgress = true;

	//What's current state of the session?
	EOS_EOnlineSessionState SessionState = EOS_EOnlineSessionState::EOS_OSS_NoSession;

	//Special value for an invalid session. Used as a sign of error.
	static FSession InvalidSession;
};

/** 
 * Class to perform session queries and to contain search results.
 */
class FSessionSearch
{
public:
	FSessionSearch() {}
	~FSessionSearch();

	FSessionSearch(const FSessionSearch&) = delete;
	FSessionSearch& operator=(const FSessionSearch&) = delete;

	//Release a clear current search
	void Release();

	//Clear previous and prepare for new search results.
	void SetNewSearch(EOS_HSessionSearch);

	//Called when new search data arrives.
	void OnSearchResultsReceived(std::vector<FSession>&&, std::vector<SessionDetailsKeeper>&&);

	//Getters to query current search results
	const std::vector<FSession>& GetResults() const { return SearchResults; }
	const std::vector<SessionDetailsKeeper> GetHandles() const { return ResultHandles; }
	EOS_HSessionSearch GetSearchHandle() const { return SearchHandle; }
	SessionDetailsKeeper GetSessionHandleById(const std::string& SessionId) const
	{
		for (size_t i = 0; i < SearchResults.size(); ++i)
		{
			if (SearchResults[i].Id == SessionId)
			{
				if (ResultHandles.size() > i)
				{
					return ResultHandles[i];
				}
				break;
			}
		}
		return nullptr;
	}

private:
	EOS_HSessionSearch SearchHandle = nullptr;
	std::vector<FSession> SearchResults;
	std::vector<SessionDetailsKeeper> ResultHandles;
};

/**
 * Manages game sessions and matchmaking.
 */
class FSessionMatchmaking
{
public:
	/**
	 * Constructor
	 */
	FSessionMatchmaking() noexcept(false);

	/**
	 * No copying or copy assignment allowed for this class.
	 */
	FSessionMatchmaking(FSessionMatchmaking const&) = delete;
	FSessionMatchmaking& operator=(FSessionMatchmaking const&) = delete;

	/**
	 * Destructor
	 */
	virtual ~FSessionMatchmaking();

	void OnShutdown();

	void Update();

	/**
	 * Receives game event
	 *
	 * @param Event - Game event to act on
	 */
	void OnGameEvent(const FGameEvent& Event);

	/**
	 *  Read-only access to current sessions.
	 */
	const std::unordered_map<std::string, FSession>& GetCurrentSessions() const { return CurrentSessions; }

	/**
	 * Accessor to search results.
	 */
	const FSessionSearch& GetCurrentSearch() const { return CurrentSearch; }

	//Session management
	bool CreateSession(const FSession& Session);
	bool DestroySession(const std::string& Name);
	void DestroyAllSessions();
	bool HasActiveLocalSessions() const;
	bool HasPresenceSession() const;
	bool IsPresenceSession(const std::string& Id) const;
	/**
	 * Returns the PresenceSession if available; otherwise returns nullptr
	 */
	const FSession* GetPresenceSession() const;

	//Get current local session by name (if exists). Returns invalid session on error/missing.
	const FSession& GetSession(const std::string& Name);
	void StartSession(const std::string& Name);
	void EndSession(const std::string& Name);
	void JoinSession(SessionDetailsKeeper SessionHandle, bool bPresenceSession);
	
	void Register(const std::string& SessionName, EOS_ProductUserId FriendId);
	void Unregister(const std::string& SessionName, EOS_ProductUserId FriendId);

	void InviteToSession(const std::string& Name, FProductUserId FriendProductUserId);
	void RequestToJoinSession(const FProductUserId& FriendProductUserId);
	void AcceptRequestToJoin(const FProductUserId& FriendProductUserId);
	void RejectRequestToJoin(const FProductUserId& FriendProductUserId);

	//Saves session as the current one player is invited to.
	void SetInviteSession(const FSession& Session, SessionDetailsKeeper SessionHandle);
	const FSession& GetInviteSession() const { return CurrentInviteSession; }
	SessionDetailsKeeper GetInviteSessionHandle() const { return CurrentInviteSessionHandle; }

	void SubscribeToGameInvites();
	void UnsubscribeFromGameInvites();

	void SubscribeToLeaveSessionUI();
	void UnsubscribeFromLeaveSessionUI();
		
	//Search by attributes
	void Search(const std::vector<FSession::Attribute>& Attributes);
	//Search by session ID
	void SearchById(const std::string& SessionId);

	SessionDetailsKeeper GetSessionHandleFromSearch(const std::string& SessionId) const;

	// Find the session associated with the invite and create a handle for it.
	static SessionDetailsKeeper MakeSessionHandleByInviteId(const std::string& InviteId);

	static SessionDetailsKeeper MakeSessionHandleByEventId(const EOS_UI_EventId UiEventId);

	/*
	 * Modify existing session by name. Session object must contain the name of the session. It should also contain all the properties that need to be updated.
	 * Empty properties are interpret as 'no change'.
	 */
	bool ModifySession(const FSession& Session);

	void OnSessionDestroyed(const std::string& SessionName);

	/**
	 * Callback that is fired when we get response regarding session update request.
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnUpdateSessionCompleteCallback(const EOS_Sessions_UpdateSessionCallbackInfo* Data);

	/**
	 * Callback that is fired when we get response regarding session create request.
	 * The signature is the same as that used when performing a session update but this
	 * version is used only for a session create.
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnUpdateSessionCompleteCallback_ForCreate(const EOS_Sessions_UpdateSessionCallbackInfo* Data);

	/**
	 * Callback that is fired when we get response regarding session start request.
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnStartSessionCompleteCallback(const EOS_Sessions_StartSessionCallbackInfo* Data);

	/**
	 * Callback that is fired when we get response regarding session end request.
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnEndSessionCompleteCallback(const EOS_Sessions_EndSessionCallbackInfo* Data);
	
	/**
	 * Callback that is fired when we get response regarding session destroy request.
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnDestroySessionCompleteCallback(const EOS_Sessions_DestroySessionCallbackInfo* Data);

	/**
	 * Callback that is fired when we get response regarding session register request.
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnRegisterCompleteCallback(const EOS_Sessions_RegisterPlayersCallbackInfo* Data);

	/**
	 * Callback that is fired when we get response regarding session unregister request.
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnUnregisterCompleteCallback(const EOS_Sessions_UnregisterPlayersCallbackInfo* Data);

	/**
	 * Callback that is fired on search finish
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnFindSessionsCompleteCallback(const EOS_SessionSearch_FindCallbackInfo* Data);

	/**
	 * Callback that is fired on invite to session sent
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSendInviteCompleteCallback(const EOS_Sessions_SendInviteCallbackInfo* Data);

	/**
	 * Callback that is fired on invite to session received
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSessionInviteReceivedCallback(const EOS_Sessions_SessionInviteReceivedCallbackInfo* Data);

	/**
	 * Callback that is fired on invite to session accepted 
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSessionInviteAcceptedCallback(const EOS_Sessions_SessionInviteAcceptedCallbackInfo* Data);

	/**
	 * Callback that is fired on invite to session rejected
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSessionInviteRejectedCallback(const EOS_Sessions_SessionInviteRejectedCallbackInfo* Data);

	/**
	 * Callback that is fired on request to join session sent
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSendRequestToJoinCompleteCallback(const EOS_CustomInvites_SendRequestToJoinCallbackInfo* Data);

	/**
	 * Callback that is fired after a request to join session is accepted
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSendRequestToJoinAcceptedCallback(const EOS_CustomInvites_AcceptRequestToJoinCallbackInfo* Data);

	/**
	 * Callback that is fired after a request to join session is rejected 
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSendRequestToJoinRejectedCallback(const EOS_CustomInvites_RejectRequestToJoinCallbackInfo* Data);

	/**
	 * Callback that is fired when a request to join session is received
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnRequestToJoinSessionReceivedCallback(const EOS_CustomInvites_RequestToJoinReceivedCallbackInfo* Data);

	/**
	 * Callback that is fired on join session
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnJoinSessionCallback(const EOS_Sessions_JoinSessionCallbackInfo* Data);

	/**
	 * Callback that is fired on join game accepted
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnPresenceJoinGameAcceptedCallback(const EOS_Presence_JoinGameAcceptedCallbackInfo* Data);

	/**
	 * Callback that is fired on join game accepted
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSessionsJoinSessionAcceptedCallback(const EOS_Sessions_JoinSessionAcceptedCallbackInfo* Data);

	/**
	 * Callback that is fired when set presence is completed
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSetPresenceCallback(const EOS_Presence_SetPresenceCallbackInfo* Data);

	/**
	 * Callback that is fired when leave session is requested from UI.
	 * 
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnLeaveSessionRequestedCallback(const EOS_Sessions_LeaveSessionRequestedCallbackInfo* Data);
private:

	/**
	 * Called when a user has logged in
	 */
	void OnLoggedIn(FEpicAccountId UserId);

	/**
	 * Called when a user has logged out
	 */
	void OnLoggedOut(FEpicAccountId UserId);

	/**
	 * Called when a user connect has logged in
	 */
	void OnUserConnectLoggedIn(FProductUserId ProductUserId);

	void OnSessionUpdateFinished(bool bSuccess, const std::string& Name, const std::string& SessionId, bool bRemoveSessionOnFailure = false);
	void OnSearchResultsReceived();
	void SetJoiningSessionDetails(SessionDetailsKeeper NewDetails);
	void OnJoinSessionFinished();
	void OnSessionStarted(const std::string& Name);
	void OnSessionEnded(const std::string& Name);
	void SetJoinInfo(const std::string& SessionId);
	void OnJoinGameAcceptedByJoinInfo(const std::string& LocationString, EOS_UI_EventId UiEventId);
	void OnJoinGameAcceptedByEventId(EOS_UI_EventId UiEventId);
	void JoinPresenceSessionById(const std::string& SessionId);
	void AcknowledgeEventId(EOS_EResult Result);

	std::string GenerateJoinedSessionName(bool bNoIncrement = false);

	std::unordered_map<std::string, FSession> CurrentSessions;

	FSessionSearch CurrentSearch;
	// The ID which is being joined as a presence session.  Set as a reaction to Social Overlay buttons.
	std::string JoinPresenceSessionId;
	// The Correlation ID which was provided by the UI.
	EOS_UI_EventId JoinUiEvent;
	// The known presence session ID found during a `HasPresenceSession` check.
	mutable std::string KnownPresenceSessionId;

	//The session current user is invited to. Only one invite session at a time is supported.
	FSession CurrentInviteSession = FSession::InvalidSession;
	SessionDetailsKeeper CurrentInviteSessionHandle = nullptr;

	EOS_NotificationId SessionInviteNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId SessionInviteAcceptedNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId SessionInviteRejectedNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId JoinGameNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId SessionJoinGameNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId RequestToJoinSessionReceivedNotificationHandle = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId LeaveSessionRequestedNotificationHandle = EOS_INVALID_NOTIFICATIONID;

	SessionDetailsKeeper JoiningSessionDetails = nullptr;
	size_t JoinedSessionIndex = 0;

	uint32_t RestrictedPlatform;
};

```

`EAC_SDK/Samples/SessionMatchmaking/Source/SessionMatchmakingDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "SessionMatchmakingDialog.h"
#include "DebugLog.h"
#include "Checkbox.h"
#include "TableView.h"
#include "NewSessionDialog.h"
#include "SessionsTableRowView.h"

namespace
{
	FSessionsTableRowData BuildTableRowDataFromSession(const FSession& Session, bool bSearchResult)
	{
		FSessionsTableRowData Result;
		Result.Values[FSessionsTableRowData::EValue::SessionName] = FStringUtils::Widen(Session.Name);

		std::wstring SessionStateString = L"None";
		if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_Creating)
			SessionStateString = L"Creating";
		else if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_Starting)
			SessionStateString = L"Starting";
		else if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_Pending)
			SessionStateString = L"Pending";
		else if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_InProgress)
			SessionStateString = L"InProgress";
		else if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_Ending)
			SessionStateString = L"Ending";
		else if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_Ended)
			SessionStateString = L"Ended";
		else if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_NoSession)
			SessionStateString = L"NoSession";
		else if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_Destroying)
			SessionStateString = L"Destroying";

		if (Session.bUpdateInProgress)
		{
			SessionStateString = L"*Updating*";
		}

		Result.Values[FSessionsTableRowData::EValue::Status] = SessionStateString;
		static wchar_t Buffer[20] = {};
		wsprintf(Buffer, L"%d/%d", Session.NumConnections, Session.MaxPlayers);
		Result.Values[FSessionsTableRowData::EValue::Players] = Buffer;

		const FSession::Attribute* LevelAttribute = Session.GetAttribute(SESSION_KEY_LEVEL);
		Result.Values[FSessionsTableRowData::EValue::Level] = FStringUtils::Widen((LevelAttribute) ? LevelAttribute->AsString : "None");

		Result.Values[FSessionsTableRowData::EValue::PresenceSession] = Session.bPresenceSession ? L"Yes" : L"No";
		Result.Values[FSessionsTableRowData::EValue::JoinInProgress] = Session.bAllowJoinInProgress ? L"Yes" : L"No";
		Result.Values[FSessionsTableRowData::EValue::Public] = (Session.PermissionLevel == EOS_EOnlineSessionPermissionLevel::EOS_OSPF_PublicAdvertised) ? 
			L"Public" : 
			(Session.PermissionLevel == EOS_EOnlineSessionPermissionLevel::EOS_OSPF_JoinViaPresence) ? L"Presence" : L"Invite Only";
		Result.Values[FSessionsTableRowData::EValue::AllowInvites] = Session.bInvitesAllowed ? L"On" : L"Off";

		Result.SessionId = Session.Id;

		Result.bActionsAvailable.fill(!bSearchResult);

		if (!bSearchResult)
		{
			if (Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_InProgress || Session.SessionState == EOS_EOnlineSessionState::EOS_OSS_Starting)
			{
				Result.bActionsAvailable[FSessionsTableRowData::EAction::Start] = false;
			}
			else
			{
				Result.bActionsAvailable[FSessionsTableRowData::EAction::End] = false;
			}
		}

		return Result;
	}
}


FSessionMatchmakingDialog::FSessionMatchmakingDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/friends.dds");

	TitleLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Vector2(DialogSize.x, 30.f),
		DialogLayer - 1,
		L"SESSIONS",
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	TitleLabel->SetBorderColor(Color::UIBorderGrey);
	TitleLabel->SetFont(DialogNormalFont);

	CreateSessionButton = std::make_shared<FButtonWidget>(
		Vector2(DialogPos.x + 5.0f, DialogPos.y + TitleLabel->GetSize().y + 5.0f),
		Vector2(200.0f, 25.f),
		Layer - 1,
		L"CREATE NEW SESSION",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
	);
	//CreateSessionButton->SetBorderColor(Color::UIBorderGrey);
	CreateSessionButton->SetBackgroundColors(assets::DefaultButtonColors);
	CreateSessionButton->SetOnPressedCallback([this]()
	{
		//Open New Session dialog
		FGameEvent Event(EGameEventType::NewSession);
		FGame::Get().OnGameEvent(Event);
	}
	);

	SearchByLevelNameField = std::make_shared<FTextFieldWidget>(
		CreateSessionButton->GetPosition() + Vector2(DialogSize.x - 200.0f, 0.0f),
		Vector2(175.0f, 25.0f),
		Layer - 1,
		L"Search by Level name...",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
	);
	SearchByLevelNameField->SetOnEnterPressedCallback([this](const std::wstring& SearchString)
	{
		SearchSession(SearchString);
	});

	SearchButton = std::make_shared<FButtonWidget>(
		SearchByLevelNameField->GetPosition() + Vector2(SearchByLevelNameField->GetSize().x, 0.0f),
		Vector2(20.0f, 20.f),
		Layer - 1,
		L"",
		std::vector<std::wstring>({ L"Assets/search.dds" }),
		DialogSmallFont,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
	);
	SearchButton->SetOnPressedCallback([this]()
	{
		SearchSession(SearchByLevelNameField->GetText());
	}
	);

	CancelSearchButton = std::make_shared<FButtonWidget>(
		SearchButton->GetPosition(),
		SearchButton->GetSize(),
		Layer - 1,
		L"",
		std::vector<std::wstring>({ L"Assets/nobutton.dds" }),
		DialogSmallFont,
		FColor(1.f, 1.f, 1.f, 1.f)
		);
	CancelSearchButton->SetOnPressedCallback([this]()
	{
		StopSearch();
	}
	);
	CancelSearchButton->Hide();

	Vector2 SessionTablePos = CreateSessionButton->GetPosition() + Vector2(0.0f, CreateSessionButton->GetSize().y + 5.0f);

	SessionsTable = std::make_shared<FSessionsTableView>(
		SessionTablePos,
		Vector2(GetSize().x - 10.0f, GetSize().y - (SessionTablePos.y - GetPosition().y) - 5.0f),
		DialogLayer - 1,
		L"Current sessions:",
		10.0f, //scroller width
		std::vector<FSessionsTableRowData>(),
		FSessionsTableRowData());

	SessionsTable->SetFonts(DialogSmallFont, DialogSmallFont);
	SessionsTable->SetOnSelectionCallback([this](const std::wstring& SelectedSessionName, const std::string& SessionId)
	{
		const bool bPresenceSession = false;
		SetSelectedSession(SelectedSessionName, SessionId, bPresenceSession);
	});
}

void FSessionMatchmakingDialog::Update()
{
	if (SessionsTable)
	{
		if (bShowingSearchResults)
		{
			const FSessionSearch& CurrentSearch = FGame::Get().GetSessions()->GetCurrentSearch();

			//copy data to vector
			std::vector<FSession> SessionsVector = CurrentSearch.GetResults();
			std::vector<FSessionsTableRowData> TableRows;
			TableRows.reserve(SessionsVector.size());
			for (const auto& NextSession : SessionsVector)
			{
				TableRows.push_back(BuildTableRowDataFromSession(NextSession, true));
			}

			SessionsTable->RefreshData(std::move(TableRows));
		}
		else
		{
			const auto& CurrentSessions = FGame::Get().GetSessions()->GetCurrentSessions();

			//copy data to vector
			std::vector<FSessionsTableRowData> TableRows;
			TableRows.reserve(CurrentSessions.size());
			for (const auto& Pair : CurrentSessions)
			{
				TableRows.push_back(BuildTableRowDataFromSession(Pair.second, false));
			}

			SessionsTable->RefreshData(std::move(TableRows));
		}
	}

	FDialog::Update();
}

void FSessionMatchmakingDialog::Create()
{
	if (BackgroundImage) BackgroundImage->Create();
	if (TitleLabel) TitleLabel->Create();
	if (CreateSessionButton) CreateSessionButton->Create();
	if (SearchByLevelNameField) SearchByLevelNameField->Create();
	if (SearchButton) SearchButton->Create();
	if (SessionsTable) SessionsTable->Create();
	if (CancelSearchButton) CancelSearchButton->Create();

	AddWidget(BackgroundImage);
	AddWidget(TitleLabel);
	AddWidget(CreateSessionButton);
	AddWidget(SearchByLevelNameField);
	AddWidget(SearchButton);
	AddWidget(SessionsTable);
	AddWidget(CancelSearchButton);

	Disable();
}

void FSessionMatchmakingDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (BackgroundImage) BackgroundImage->SetPosition(Pos);
	if (TitleLabel) TitleLabel->SetPosition(Pos);
	if (CreateSessionButton) CreateSessionButton->SetPosition(Pos + Vector2(5.0f, TitleLabel->GetSize().y + 5.0f));
	if (SearchByLevelNameField) SearchByLevelNameField->SetPosition(CreateSessionButton->GetPosition() + Vector2(GetSize().x - 200.0f, 0.0f));
	if (SearchButton) SearchButton->SetPosition(SearchByLevelNameField->GetPosition() + Vector2(SearchByLevelNameField->GetSize().x, 0.0f));
	if (CancelSearchButton) CancelSearchButton->SetPosition(SearchButton->GetPosition());
	Vector2 SessionTablePos = CreateSessionButton->GetPosition() + Vector2(0.0f, CreateSessionButton->GetSize().y + 5.0f);
	if (SessionsTable) SessionsTable->SetPosition(SessionTablePos);
}

void FSessionMatchmakingDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);
	if (BackgroundImage) BackgroundImage->SetSize(Vector2(NewSize.x, NewSize.y - 10.f));
	if (TitleLabel) TitleLabel->SetSize(Vector2(NewSize.x, 30.0f));
	if (CreateSessionButton) CreateSessionButton->SetSize(Vector2(200.0f, 25.f));
	if (SearchByLevelNameField) SearchByLevelNameField->SetSize(Vector2(175.0f, 25.0f));
	if (SearchButton) SearchButton->SetSize(Vector2(20.0f, 20.0f));
	if (CancelSearchButton) CancelSearchButton->SetSize(SearchButton->GetSize());
	if (SessionsTable) SessionsTable->SetSize(Vector2(GetSize().x - 10.0f, GetSize().y - (SessionsTable->GetPosition().y - GetPosition().y) - 5.0f));
}


void FSessionMatchmakingDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{

	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		Disable();
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		Disable();
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		if (FPlayerManager::Get().GetNumPlayers() == 0)
		{
			Disable();
			SessionsTable->Clear();
		}
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		SessionsTable->Clear();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		SessionsTable->Clear();
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		Disable();
		SessionsTable->Clear();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		Disable();
		SessionsTable->Clear();
	}
	else if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		Enable();
	}
	else if (Event.GetType() == EGameEventType::InviteFriendToSession)
	{
		//get selected session and invite friend
		if (!SelectedSessionName.empty())
		{
			FGame::Get().GetSessions()->InviteToSession(FStringUtils::Narrow(SelectedSessionName), Event.GetProductUserId());
		}
		else
		{
			FDebugLog::LogError(L"Sessions: can't invite to selected session. Selected session is invalid.");
		}
		
	}
	else if (Event.GetType() == EGameEventType::RegisterFriendWithSession)
	{
		//get selected session and invite friend
		if (!SelectedSessionName.empty())
		{
			FProductUserId FriendProductUserId = Event.GetProductUserId();

			FGame::Get().GetSessions()->Register(FStringUtils::Narrow(SelectedSessionName), FriendProductUserId);
		}
		else
		{
			FDebugLog::LogError(L"Sessions: can't invite to selected session. Selected session is invalid.");
		}

	}
	else if (Event.GetType() == EGameEventType::SessionJoined)
	{
		StopSearch();
	}
	else if (Event.GetType() == EGameEventType::RequestToJoinFriendSession)
	{
		FGame::Get().GetSessions()->RequestToJoinSession(Event.GetProductUserId());
	}
}

void FSessionMatchmakingDialog::SetSelectedSession(const std::wstring& InSessionName, const std::string& SessionId, bool bPresenceSession)
{
	SelectedSessionName = InSessionName;

	if (bShowingSearchResults && !SessionId.empty())
	{
		auto Handle = FGame::Get().GetSessions()->GetSessionHandleFromSearch(SessionId);
		FGame::Get().GetSessions()->JoinSession(Handle, bPresenceSession);
	}
}

void FSessionMatchmakingDialog::SearchSession(const std::wstring& Pattern)
{
	std::string SearchLevelName = FStringUtils::Narrow(Pattern);

	std::vector<FSession::Attribute> Attributes;

	FSession::Attribute LevelAttribute;
	LevelAttribute.Key = SESSION_KEY_LEVEL;
	LevelAttribute.ValueType = FSession::Attribute::String;
	LevelAttribute.AsString = SearchLevelName;
	LevelAttribute.Advertisement = EOS_ESessionAttributeAdvertisementType::EOS_SAAT_Advertise;

	Attributes.push_back(LevelAttribute);

	FGame::Get().GetSessions()->Search(Attributes);

	bShowingSearchResults = true;
	
	//change icon
	SearchButton->Hide();
	CancelSearchButton->Show();
}

void FSessionMatchmakingDialog::StopSearch()
{
	//change icon
	SearchButton->Show();
	CancelSearchButton->Hide();
	SearchByLevelNameField->Clear();

	bShowingSearchResults = false;
}
```

`EAC_SDK/Samples/SessionMatchmaking/Source/SessionMatchmakingDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "ListView.h"
#include "SessionMatchmaking.h"
#include "TableView.h"

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;
class FCheckboxWidget;
class FNewSessionDialog;

/**
 * Session Matchmaking dialog
 */
class FSessionMatchmakingDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FSessionMatchmakingDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FSessionMatchmakingDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/** 
	 * Called when session is selected.
	 */
	void SetSelectedSession(const std::wstring& SessionName, const std::string& SessionId, bool bPresenceSession);
	const std::wstring& GetSelectedSession() const { return SelectedSessionName; }

private:
	void SearchSession(const std::wstring& Pattern);
	void StopSearch();

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Title label */
	std::shared_ptr<FTextLabelWidget> TitleLabel;

	/** Create session button */
	std::shared_ptr<FButtonWidget> CreateSessionButton;

	/** Search by level name input */
	std::shared_ptr<FTextFieldWidget> SearchByLevelNameField;

	/** Small search button within the search input field */
	std::shared_ptr<FButtonWidget> SearchButton;

	/** Small cancel search button within the search input field */
	std::shared_ptr<FButtonWidget> CancelSearchButton;

	/** Table view with the list of sessions. */
	std::shared_ptr<FSessionsTableView> SessionsTable;

	/** Name of session that is currently selected */
	std::wstring SelectedSessionName;

	bool bShowingSearchResults = false;
};

```

`EAC_SDK/Samples/SessionMatchmaking/Source/SessionsTableRowView.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "SessionsTableRowView.h"
#include "TextLabel.h"
#include "Button.h"
#include "TableView.h"

#include "SessionMatchmaking.h"
#include "Game.h"


FSessionsTableRowView::FSessionsTableRowView(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& InAssetFile, const FSessionsTableRowData& InData, FColor InBackgroundColor, FColor InTextColor)
	: FDialog(Pos, Size, Layer), Data(InData), AssetFile(InAssetFile), BackgroundColor(InBackgroundColor), TextColor(InTextColor)
{
	static_assert(std::tuple_size<FSessionsTableRowView::FRowWidgets>::value == std::tuple_size<FSessionsTableRowData::FValues>::value, "FRowWidgets must be the same size as the number of values.");
	static_assert(std::tuple_size<FSessionsTableRowView::FActionButtons>::value == std::tuple_size<FSessionsTableRowData::FActionsAvailable>::value, "FActionButtons must be the same size as the number of actions.");

	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//create labels
	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		std::shared_ptr<FTextLabelWidget> NextLabel = std::make_shared<FTextLabelWidget>(
			Vector2(Pos.x + LabelSize.x * i, Pos.y),
			LabelSize,
			Layer - 1,
			Data.Values[i],
			AssetFile,
			BackgroundColor,
			TextColor);

		RowWidgets[i] = NextLabel;
		AddWidget(NextLabel);
	}

	//create action buttons
	std::array<std::wstring, FSessionsTableRowData::EAction::Count> actionLabels;
	std::array<FColor, FSessionsTableRowData::EAction::Count> actionColors;

	actionLabels[FSessionsTableRowData::EAction::Start] = L"START";
	actionColors[FSessionsTableRowData::EAction::Start] = Color::DarkGreen;
	actionLabels[FSessionsTableRowData::EAction::End] = L"END";
	actionColors[FSessionsTableRowData::EAction::End] = Color::DarkGoldenrod;
	actionLabels[FSessionsTableRowData::EAction::Mod] = L"MOD";
	actionColors[FSessionsTableRowData::EAction::Mod] = Color::DarkBlue;
	actionLabels[FSessionsTableRowData::EAction::Leave] = L"LEAVE";
	actionColors[FSessionsTableRowData::EAction::Leave] = Color::DarkRed;

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		std::shared_ptr<FButtonWidget> NextButton = std::make_shared<FButtonWidget>(
			Vector2(Pos.x + Data.Values.size() * LabelSize.x + Ix * ActionSize.x, Pos.y),
			ActionSize,
			Layer - 1,
			actionLabels[Ix],
			assets::DefaultButtonAssets,
			nullptr,
			actionColors[Ix]);
		NextButton->SetOnPressedCallback([this, Ix]() { this->OnPressed(Ix); });
		if (!Data.bActionsAvailable[Ix])
		{
			NextButton->Disable();
		}

		ActionButtons[Ix] = NextButton;
		AddWidget(NextButton);
	}
}

void FSessionsTableRowView::SetFocused(bool bValue)
{
	FDialog::SetFocused(bValue);

	if (bValue)
	{
		SetBorderColor(Color::UIDarkGrey);
	}
	else
	{
		ClearBorderColor();
	}
}

void FSessionsTableRowView::SetPosition(Vector2 Pos)
{
	FDialog::SetPosition(Pos);

	ReadjustLayout();
}

void FSessionsTableRowView::SetSize(Vector2 NewSize)
{
	FDialog::SetSize(NewSize);

	ReadjustLayout();
}

void FSessionsTableRowView::Enable()
{
	FDialog::Enable();

	//Disable action buttons
	for (size_t Ix = 0; Ix < FSessionsTableRowData::EAction::Count; ++Ix)
	{
		if (!Data.bActionsAvailable[Ix] && ActionButtons.size() > Ix)
		{
			std::shared_ptr<FButtonWidget> ActionButton = ActionButtons[Ix];
			if (ActionButton)
			{
				ActionButton->Disable();
			}
		}
	}
}

void FSessionsTableRowView::SetOnActionPressedCallback(std::function<void(size_t)> Callback)
{
	ActionPressedCallback = Callback;
}

void FSessionsTableRowView::HideActions()
{
	for (auto ActionButton : ActionButtons)
	{
		if (ActionButton)
		{
			ActionButton->Hide();
		}
	}
}

void FSessionsTableRowView::SetData(const FSessionsTableRowData& InData)
{
	Data = InData;

	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		std::wstring DataString = (i < InData.Values.size()) ? InData.Values[i] : L"-";
		RowWidgets[i]->SetText(DataString);
	}

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		if (Data.bActionsAvailable[Ix])
		{
			ActionButtons[Ix]->Enable();
		}
		else
		{
			ActionButtons[Ix]->Disable();
		}
	}

	ReadjustLayout();
}

void FSessionsTableRowView::SetFont(FontPtr InFont)
{
	Font = InFont;

	for (auto Widget : RowWidgets)
	{
		Widget->SetFont(InFont);
	}

	for (auto Button : ActionButtons)
	{
		Button->SetFont(InFont);
	}
}

void FSessionsTableRowView::CalcSizes(Vector2& LabelSize, Vector2& ActionSize)
{
	// Fit the action buttons into "2" columns.
	float ActionSizeRatio = 2.3f / FSessionsTableRowData::EAction::Count;
	float ColumnRatio = Data.Values.size() + ActionSizeRatio * FSessionsTableRowData::EAction::Count;
	LabelSize = Vector2(Size.x / ColumnRatio, Size.y);
	ActionSize = Vector2(LabelSize.x * ActionSizeRatio, Size.y);
}

void FSessionsTableRowView::ReadjustLayout()
{
	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//resize labels
	for (size_t i = 0; i < RowWidgets.size(); ++i)
	{
		RowWidgets[i]->SetPosition(Vector2(Position.x + LabelSize.x * i, Position.y));
		RowWidgets[i]->SetSize(LabelSize);
	}

	for (size_t i = 0; i < ActionButtons.size(); ++i)
	{
		ActionButtons[i]->SetPosition(Vector2(Position.x + Data.Values.size() * LabelSize.x + i * ActionSize.x, Position.y));
		ActionButtons[i]->SetSize(ActionSize);
	}
}

void FSessionsTableRowView::OnPressed(size_t ActionIndex)
{
	if (ActionPressedCallback)
	{
		ActionPressedCallback(ActionIndex);
	}

	std::string SessionName = FStringUtils::Narrow(Data.Values[FSessionsTableRowData::EValue::SessionName]);

	if (ActionIndex == FSessionsTableRowData::EAction::Start)
	{
		//Start session
		FGame::Get().GetSessions()->StartSession(SessionName);
	}
	else if (ActionIndex == FSessionsTableRowData::EAction::End)
	{
		//End session
		FGame::Get().GetSessions()->EndSession(SessionName);
	}
	else if (ActionIndex == FSessionsTableRowData::EAction::Leave)
	{ 
		// Leave and destroy session
		FGame::Get().GetSessions()->DestroySession(SessionName);
	}
	else if (ActionIndex == FSessionsTableRowData::EAction::Mod)
	{
		//Modify session
		FSession CurrentSession = FGame::Get().GetSessions()->GetSession(SessionName);
		if (CurrentSession.IsValid())
		{
			CurrentSession.MaxPlayers = 10;

			for (FSession::Attribute& Attr : CurrentSession.Attributes)
			{
				if (Attr.Key == SESSION_KEY_LEVEL)
				{
					CurrentSession.Attributes[0].AsString = "Forest";
				}
			}

			FGame::Get().GetSessions()->ModifySession(CurrentSession);
		}
	}
}

template<>
std::shared_ptr<FSessionsTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FSessionsTableRowData& Data)
{
	return std::make_shared<FSessionsTableRowView>(Pos, Size, Layer, L"", Data, Color::DarkGray, Color::White);
}

template <>
void FTableView<FSessionsTableRowData, FSessionsTableRowView>::OnEntrySelected(size_t Index)
{
	if (Index < Data.size())
	{
		//save selection
		if (!Data[Index].Values.empty())
		{
			CurrentlySelectedOption = Data[Index].Values[0];
		}
		else
		{
			CurrentlySelectedOption.clear();
		}

		if (OnSelectionCallback)
		{
			OnSelectionCallback(CurrentlySelectedOption, Data[Index].SessionId);
		}
	}
}
```

`EAC_SDK/Samples/SessionMatchmaking/Source/SessionsTableRowView.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Widget.h"
#include "Font.h"
#include "ListView.h"
#include "Dialog.h"

#include <array>

class FTextLabelWidget;
class FButtonWidget;

struct FSessionsTableRowData
{
	struct EValue final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			SessionName = 0,
			Status,
			Players,
			Level,
			PresenceSession,
			JoinInProgress,
			Public,
			AllowInvites,
			Count
		};
		EValue() = delete;
	};
	struct EAction final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			Start = 0,
			End,
			Mod,
			Leave,
			Count
		};
		EAction() = delete;
	};

	std::string SessionId;

	using FValues = std::array<std::wstring, EValue::Count>;
	using FActionsAvailable = std::array<bool, EAction::Count>;
	FValues Values;
	FActionsAvailable bActionsAvailable;

	bool operator!=(const FSessionsTableRowData& Other) const
	{
		return bActionsAvailable != Other.bActionsAvailable || Values != Other.Values;
	}

	FSessionsTableRowData()
	{
		bActionsAvailable.fill(false);
		Values[EValue::SessionName] = L"Name";
		Values[EValue::Status] = L"Status";
		Values[EValue::Players] = L"Players";
		Values[EValue::Level] = L"Level";
		Values[EValue::PresenceSession] = L"Presence?";
		Values[EValue::JoinInProgress] = L"JIP";
		Values[EValue::Public] = L"Public";
		Values[EValue::AllowInvites] = L"Invites";
	}
};

class FSessionsTableRowView : public FDialog
{
public:
	FSessionsTableRowView(Vector2 Pos,
		Vector2 Size,
		UILayer Layer,
		const std::wstring& AssetFile,
		const FSessionsTableRowData& InData,
		FColor BackgroundColor,
		FColor TextColor);

	void SetFocused(bool bValue) override;

	/** Set Position */
	void SetPosition(Vector2 Pos) override;

	/** Set Size */
	void SetSize(Vector2 NewSize) override;

	void Enable() override;

	void SetOnActionPressedCallback(std::function<void(size_t)> Callback);

	void HideActions();

	void SetData(const FSessionsTableRowData& InData);
	void SetFont(FontPtr InFont);

protected:
	void CalcSizes(Vector2& LabelSize, Vector2& ActionSize);
	void ReadjustLayout();
	void OnPressed(size_t ActionIndex);

	FSessionsTableRowData Data;

	using FRowWidgets = std::array<std::shared_ptr<FTextLabelWidget>, FSessionsTableRowData::EValue::Count>;
	FRowWidgets RowWidgets;
	using FActionButtons = std::array<std::shared_ptr<FButtonWidget>, FSessionsTableRowData::EAction::Count>;
	FActionButtons ActionButtons;
	std::wstring AssetFile;
	FColor BackgroundColor;
	FColor TextColor;
	FontPtr Font;

	std::function<void(size_t)> ActionPressedCallback;
};

template<>
std::shared_ptr<FSessionsTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FSessionsTableRowData& Data);

#include "TableView.h"

template <>
void FTableView<FSessionsTableRowData, FSessionsTableRowView>::OnEntrySelected(size_t Index);
```

`EAC_SDK/Samples/SessionMatchmaking/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/SessionMatchmaking/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/Store/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/Store/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/Store/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/Store/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "Store.h"
#include "GameEvent.h"
#include "Game.h"

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	Store = std::make_unique<FStore>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" OFFERS - to refresh the catalog;",
		};
		AppendHelpMessageLines(ExtraHelpMessageLines);

		Console->AddCommand(L"OFFERS", [](const std::vector<std::wstring>&)
		{
			FGameEvent Event(EGameEventType::RefreshOffers);
			FGame::Get().OnGameEvent(Event);
		});

		Console->AddCommand(L"LOCALE", [](const std::vector<std::wstring>& args)
		{
			if (args.size() == 1)
			{
				FGameEvent Event(EGameEventType::SetLocale, args[0]);
				FGame::Get().OnGameEvent(Event);
			}
			else
			{
				FGame::Get().GetConsole()->AddLine(L"error: locale required.");
			}
		});
	}
}

void FGame::Update()
{
	Store->Update();

	FBaseGame::Update();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);
	Store->OnGameEvent(Event);
}

std::unique_ptr<FStore> const& FGame::GetStore()
{
	return Store;
}
```

`EAC_SDK/Samples/Store/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FStore;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	 * Getter for sessions component.
	 */
	const std::unique_ptr<FStore>& GetStore();

protected:
	/** 
	 * Initialize and store console commands
	 */
	virtual void CreateConsoleCommands() override;

	/** Store component */
	std::unique_ptr<FStore> Store;
};


```

`EAC_SDK/Samples/Store/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/Store/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "StoreDialog.h"
#include "ExitDialog.h"
#include "NotificationDialog.h"
#include "AuthDialogs.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "PopupDialog.h"
#include "GUI/Sprite.h"

namespace
{
	const Vector2 ConsoleDialogScale = Vector2(0.68f, 0.35f);
	constexpr float UpperDialogVerticalOffset = 100.f;
	constexpr float Padding = 10.f;
}

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{
}

void FMenu::Create()
{
	CreateStoreDialog();
	CreateNotificationDialog();
	
	FBaseMenu::Create();
}

void FMenu::Release()
{
	if (StoreDialog)
	{
		StoreDialog->Release();
		StoreDialog.reset();
	}

	FBaseMenu::Release();
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleDialogSize = Vector2(WindowSize.x * ConsoleDialogScale.x, WindowSize.y * ConsoleDialogScale.y);
		ConsoleDialog->SetSize(ConsoleDialogSize);

		Vector2 ConsoleDialogPos = Vector2(Padding, WindowSize.y - ConsoleDialogSize.y - Padding);
		ConsoleDialog->SetPosition(ConsoleDialogPos);

		if (StoreDialog)
		{
			float ConsoleDialogRight = ConsoleDialogPos.x + ConsoleDialogSize.x;
			float ConsoleDialogBottom = ConsoleDialogPos.y + ConsoleDialogSize.y;

			StoreDialog->SetConsoleDialogSizeAndPosition(ConsoleDialogSize, ConsoleDialogPos);

			Vector2 StoreDialogSize = Vector2(WindowSize.x - ConsoleDialog->GetSize().x - 3 * Padding,	ConsoleDialogBottom - UpperDialogVerticalOffset);
			StoreDialog->SetSize(StoreDialogSize);

			Vector2 StoreDialogPos = Vector2(ConsoleDialogRight + Padding, UpperDialogVerticalOffset);
			StoreDialog->SetPosition(StoreDialogPos);
		}
	}

	if (NotificationDialog)
	{
		NotificationDialog->SetPosition(Vector2(WindowSize.x - NotificationDialog->GetSize().x - 30.f, 30.f));
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::CreateStoreDialog()
{
	const float FX = 100.0f;
	const float FY = 100.0f;
	const float StoreWidth = 300.0f;
	const float StoreHeight = 300.0f;

	StoreDialog = std::make_shared<FStoreDialog>(
		Vector2(FX, FY),
		Vector2(StoreWidth, StoreHeight),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	StoreDialog->SetBorderColor(Color::UIBorderGrey);
	StoreDialog->Create();
	
	AddDialog(StoreDialog);
}

void FMenu::CreateAuthDialogs()
{
	AuthDialogs = std::make_shared<FAuthDialogs>(
		StoreDialog,
		L"Catalog",
		BoldSmallFont->GetFont(),
		SmallFont->GetFont(),
		TinyFont->GetFont());
	
	AuthDialogs->Create();
	AuthDialogs->SetSingleUserOnly(true);
}

void FMenu::CreateNotificationDialog()
{
	NotificationDialog = std::make_shared<FNotificationDialog>(
		Vector2(200.f, 200.f),
		Vector2(330.f, 60.f),
		5,
		NormalFont->GetFont(),
		SmallFont->GetFont());

	NotificationDialog->SetBorderColor(Color::UIBorderGrey);
	NotificationDialog->Create();

	AddDialog(NotificationDialog);

	HideDialog(NotificationDialog);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		UpdateStore();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		UpdateStore();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		UpdateStore();
	}
	else if (Event.GetType() == EGameEventType::ToggleNotification)
	{
		if (NotificationDialog->IsShown())
		{
			HideDialog(NotificationDialog);
		}
		else
		{
			ShowDialog(NotificationDialog);
		}
	}

	if (StoreDialog) StoreDialog->OnGameEvent(Event);

	if (NotificationDialog) NotificationDialog->OnGameEvent(Event);

	FBaseMenu::OnGameEvent(Event);
}

void FMenu::UpdateStore()
{
	if (StoreDialog)
	{
		StoreDialog->SetPosition(Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
										 StoreDialog->GetPosition().y));
	}
}
```

`EAC_SDK/Samples/Store/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FUIEvent;
class FConsole;
class FGameEvent;
class FFont;
class FConsoleDialog;
class FStoreDialog;
class FExitDialog;
class FNotificationDialog;
class FAuthDialogs;
class FSpriteWidget;
class FTextLabelWidget;
class FPopupDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> console) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event) override;

protected:
	/**
	 * Creates the store dialog
	 */
	void CreateStoreDialog();

	/**
	 * Creates the auth dialogs
	 */
	virtual void CreateAuthDialogs() override;

	/**
	 * Creates the notification dialog
	 */
	void CreateNotificationDialog();

	/**
	* Updates store info
	*/
	void UpdateStore();

	/** Store Dialog */
	std::shared_ptr<FStoreDialog> StoreDialog;

	/** Notification Dialog */
	std::shared_ptr<FNotificationDialog> NotificationDialog;
};

```

`EAC_SDK/Samples/Store/Source/OfferInfo.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "Main.h"
#include "TextLabel.h"
#include "TextView.h"
#include "Button.h"
#include "UIEvent.h"
#include "OfferList.h"
#include "Sprite.h"
#include "OfferInfo.h"
#include "Store.h"
#include "GameEvent.h"
#include "StringUtils.h"

static const float PurchaseButtonSizeX = 100.0f;

FOfferInfoWidget::FOfferInfoWidget(Vector2 InfoPos,
									 Vector2 InfoSize,
									 UILayer InfoLayer,
									 FOfferData InOfferData,
									 FontPtr InfoLargeFont,
									 FontPtr InfoSmallFont,
									 const FOfferInfoButtonParams& InfoButtonParams) :
	IWidget(InfoPos, InfoSize, InfoLayer),
	OfferData(InOfferData),
	LargeFont(InfoLargeFont),
	SmallFont(InfoSmallFont),
	ButtonParams(InfoButtonParams)
{
	BackgroundImage = std::make_shared<FSpriteWidget>(Vector2(0.f, 0.f), Vector2(200.f, 100.f), InfoLayer, L"Assets/friendback.dds");
}

void FOfferInfoWidget::Create()
{
	if (ButtonParams.ButtonName.empty() || !ButtonParams.OnButtonClicked)
		return;

	if (BackgroundImage)
	{
		BackgroundImage->Create();
	}

	Button.reset();

	bool bHasPrice = true; //  OfferData.bPriceValid;

	Vector2 NameOffset = Vector2(1.f, Size.y * 0.25f);

	Vector2 NameSize = (bHasPrice) ?
		Vector2(Size.x, Size.y / 2.f) :
		Size;

	NameLabel = std::make_shared<FTextLabelWidget>(
		Position + NameOffset,
		NameSize,
		Layer - 1,
		OfferData.Title,
		L"",
		FColor(0.5f, 0.5f, 0.5f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);

	NameLabel->Create();
	NameLabel->SetFont(LargeFont);
	NameLabel->SetText(OfferData.Title);

	if (bHasPrice)
	{
		const Vector2 ButtonSize = Vector2(PurchaseButtonSizeX, Size.y / 2.0f);
		const Vector2 LeftButtonOffset((Size.x - ButtonSize.x - 5.0f) , Size.y * 0.25f);

		Button = std::make_shared<FButtonWidget>(
			Position + LeftButtonOffset,
			ButtonSize,
			Layer - 1,
			ButtonParams.ButtonName,
			assets::DefaultButtonAssets,
			SmallFont,
			assets::DefaultButtonColors[0]);
		Button->SetBackgroundColors(assets::DefaultButtonColors);
		Button->Create();
		Button->SetOnPressedCallback([this]() { ButtonParams.OnButtonClicked(OfferData); });
	}
}

void FOfferInfoWidget::Release()
{
	if (BackgroundImage)
	{
		BackgroundImage->Release();
		// Do not need to reset the pointer because we can reuse the same object.
	}

	if (NameLabel)
	{
		NameLabel->Release();
		NameLabel.reset();
	}

	if (Button)
	{
		Button->Release();
		Button.reset();
	}
}

void FOfferInfoWidget::Update()
{
	if (!bShown)
		return;

	if (BackgroundImage)
	{
		BackgroundImage->Update();
	}

	if (NameLabel)
	{
		NameLabel->Update();
	}

	if (Button)
	{
		Button->Update();
	}
}

void FOfferInfoWidget::Render(FSpriteBatchPtr& Batch)
{
	if (!bShown)
		return;

	IWidget::Render(Batch);

	if (BackgroundImage)
	{
		BackgroundImage->Render(Batch);
	}

	if (NameLabel)
	{
		NameLabel->Render(Batch);
	}

	if (Button)
	{
		Button->Render(Batch);
	}
}

#ifdef _DEBUG
void FOfferInfoWidget::DebugRender()
{
	IWidget::DebugRender();

	if (BackgroundImage) BackgroundImage->DebugRender();
	if (NameLabel) NameLabel->DebugRender();
	if (Button) Button->DebugRender();
}
#endif

void FOfferInfoWidget::OnUIEvent(const FUIEvent& event)
{
	if (!bShown)
		return;

	if (event.GetType() == EUIEventType::MousePressed || event.GetType() == EUIEventType::MouseReleased)
	{
		if (Button && Button->CheckCollision(event.GetVector()))
		{
			Button->OnUIEvent(event);
		}
	}
}

void FOfferInfoWidget::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (BackgroundImage)
	{
		BackgroundImage->SetPosition(Pos);
	}

	if (NameLabel)
	{
		Vector2 NameOffset = Vector2(1.f, Size.y * 0.25f);
		NameLabel->SetPosition(Pos + NameOffset);
	}

	const Vector2 ButtonSize = Vector2(PurchaseButtonSizeX, Size.y / 2.0f);
	const Vector2 LeftButtonOffset((Size.x - ButtonSize.x - 5.0f), Size.y * 0.25f);

	if (Button)
	{
		Button->SetPosition(Position + LeftButtonOffset);
	}
}

void FOfferInfoWidget::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (BackgroundImage) BackgroundImage->SetSize(NewSize);

	if (NameLabel) NameLabel->SetSize(Vector2(NewSize.x, NameLabel->GetSize().y));

	if (Button)
	{
		const Vector2 ButtonSize = Vector2(PurchaseButtonSizeX, Size.y / 2.0f);
		Button->SetSize(ButtonSize);
	}
}

void FOfferInfoWidget::SetOfferData(const FOfferData& Data)
{
	bool bNeedReset = false;
	bool bPriceChanged = (Data.bPriceValid != OfferData.bPriceValid);
	bool bDifferentOffer = (Data.UserId != OfferData.UserId) || (Data.Title != OfferData.Title);
	
	bNeedReset = (bPriceChanged || bDifferentOffer);

	OfferData = Data;

	if (bNeedReset)
	{
		Release();
		Create();
	}
}

void FOfferInfoWidget::SetFocused(bool bFocused)
{
	IWidget::SetFocused(bFocused);

	FColor Col = NameLabel->GetBackgroundColor();
	if (bFocused)
	{
		Col.R += 0.3f;
		if (Col.R > 1.0f)
		{
			Col.R = 1.0f;
		}
	}
	else
	{
		Col.R -= 0.3f;
		if (Col.R < 0.0f)
		{
			Col.R = 0.0f;
		}
	}
	NameLabel->SetBackgroundColor(Col);
}

```

`EAC_SDK/Samples/Store/Source/OfferInfo.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Widget.h"
#include "Font.h"

/**
* Forward declarations
*/
class FUIEvent;
class FButtonWidget;
class FTextLabelWidget;
class FSpriteWidget;
struct FOfferData;

/**
 * A struct to hold the offer info button related parameters.
 */
struct FOfferInfoButtonParams
{
	std::wstring ButtonName;
	std::function<void(const FOfferData&)> OnButtonClicked;
};

/**
* A reusable widget used to display an individual offer in both the Catalog and the Cart.
*/
class FOfferInfoWidget : public IWidget
{
public:
	/**
	 * Constructor
	 */
	FOfferInfoWidget(Vector2 InfoPos,
		Vector2 InfoSize,
		UILayer InfoLayer,
		FOfferData OfferData,
		FontPtr InfoLargeFont,
		FontPtr InfoSmallFont,
		const FOfferInfoButtonParams& InfoButtonParams);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FOfferInfoWidget(const FOfferInfoWidget&) = delete;
	FOfferInfoWidget& operator=(const FOfferInfoWidget&) = delete;

	/**
	 * Destructor
	 */
	virtual ~FOfferInfoWidget() {};

	/** IGfxComponent */
	virtual void Create() override;
	virtual void Release() override;
	virtual void Update() override;
	virtual void Render(FSpriteBatchPtr& Batch) override;
#ifdef _DEBUG
	virtual void DebugRender() override;
#endif

	/** IWidget */
	virtual void OnUIEvent(const FUIEvent& Event) override;
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	virtual void SetFocused(bool bFocused) override;

	/**
	 * Sets Offer data
	 *
	 * @param Data - Offer data to copy
	 */
	void SetOfferData(const FOfferData& Data);

private:
	/** Offer Data */
	FOfferData OfferData;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Name Label */
	std::shared_ptr<FTextLabelWidget> NameLabel;

	/** Button */
	std::shared_ptr<FButtonWidget> Button;

	/** Button params */
	FOfferInfoButtonParams ButtonParams;

	/** Large Font */
	FontPtr LargeFont;

	/** Small Font */
	FontPtr SmallFont;
};

```

`EAC_SDK/Samples/Store/Source/OfferList.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "StringUtils.h"
#include "AccountHelpers.h"
#include "Input.h"
#include "Game.h"
#include "Main.h"
#include "Console.h"
#include "Store.h"
#include "TextLabel.h"
#include "TextField.h"
#include "TextView.h"
#include "Button.h"
#include "UIEvent.h"
#include "OfferInfo.h"
#include "OfferList.h"

namespace
{
	constexpr float LabelHeight = 25.f;
	constexpr float InputFieldHeight = LabelHeight;
	constexpr float OfferInfoHeight = 1.8f * InputFieldHeight;
	constexpr float ScrollerWidth = 10.f;
}

constexpr FColor FOfferListWidget::EnabledCol;
constexpr FColor FOfferListWidget::DisabledCol;

FOfferListWidget::FOfferListWidget(Vector2 OfferListPos,
									 Vector2 OfferLisSize,
									 UILayer OfferListLayer,
									 FontPtr OfferListNormalFont,
									 FontPtr OfferListTitleFont,
									 FontPtr OfferListSmallFont,
									 FontPtr OfferListTinyFont,
									 const std::wstring& Title,
									 const FOfferInfoButtonParams& InOfferInfoButtonParams) :
	IWidget(OfferListPos, OfferLisSize, OfferListLayer),
	OfferInfoButtonParams(InOfferInfoButtonParams),
	NormalFont(OfferListNormalFont),
	TitleFont(OfferListTitleFont),
	SmallFont(OfferListSmallFont),
	TinyFont(OfferListTinyFont)
{
	BackgroundImage = std::make_shared<FSpriteWidget>(Vector2(0.f, 0.f), Vector2(200.f, 100.f), OfferListLayer, L"Assets/friends.dds");

	TitleLabel = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x, Position.y),
		Vector2(OfferLisSize.x, 30.f),
		OfferListLayer - 1,
		Title,
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	TitleLabel->SetBorderColor(Color::UIBorderGrey);
}

void FOfferListWidget::Create()
{
	if (OfferInfoButtonParams.ButtonName.empty() || !OfferInfoButtonParams.OnButtonClicked)
	{
		return;
	}

	BackgroundImage->Create();

	// Title
	TitleLabel->Create();
	TitleLabel->SetFont(TitleFont);

	// Scroller
	Vector2 scrollerPosition = Vector2(Position.x + Size.x - ScrollerWidth - 4.f, Position.y + LabelHeight + InputFieldHeight + 20.f);
	Scroller = std::make_unique<FScroller>(std::static_pointer_cast<FOfferListWidget>(shared_from_this()),
		scrollerPosition,
		Vector2(ScrollerWidth, Size.y - InputFieldHeight - LabelHeight - BottomOffset - 50.0f),
		Layer - 1,
		L"Assets/scrollbar.dds");
	if (Scroller)
	{
		Scroller->Create();
		Scroller->Hide();
	}

	// Input Field
	SearchOfferWidget = std::make_shared<FTextFieldWidget>(
		Vector2(Position.x + 5.f, Position.y + LabelHeight + 15.f),
		Vector2(Size.x - 10.f, InputFieldHeight),
		Layer - 1,
		L"Search Offers...",
		L"Assets/textfield.dds",
		TitleFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left);
	if (SearchOfferWidget)
	{
		SearchOfferWidget->Create();
		SearchOfferWidget->SetOnEnterPressedCallback([this](const std::wstring& value)
		{
			if (SearchOfferWidget->IsFocused())
			{
				this->SetFilter(value);
			}
		});
		SearchOfferWidget->SetBorderColor(Color::UIBorderGrey);
	}

	Vector2 SearchPosition = Vector2(Position.x + Size.x - 20.f, Position.y + 48.f);
	Vector2 SearchSize = Vector2(10.f, 10.f);

	SearchButtonWidget = std::make_shared<FButtonWidget>(SearchPosition, SearchSize, Layer - 1, L"", std::vector<std::wstring>({ L"Assets/search.dds" }), nullptr);
	if (SearchButtonWidget)
	{
		SearchButtonWidget->Create();
		SearchButtonWidget->SetOnPressedCallback([this]()
		{
			if (IsFocused() && this->SearchOfferWidget)
			{
				this->SetFilter(this->SearchOfferWidget->GetText());
			}
		});
	}

	CancelSearchButtonWidget = std::make_shared<FButtonWidget>(SearchPosition, SearchSize, Layer - 1, L"", std::vector<std::wstring>({ L"Assets/nobutton.dds" }), nullptr);
	if (CancelSearchButtonWidget)
	{
		CancelSearchButtonWidget->Create();
		CancelSearchButtonWidget->SetOnPressedCallback([this]()
		{
			if (IsFocused() && this->SearchOfferWidget)
			{
				ClearFilter();
				this->SearchOfferWidget->Clear();
			}
		});
		CancelSearchButtonWidget->Hide();
	}

	CreateOffers();
}

void FOfferListWidget::Release()
{
	if (BackgroundImage) BackgroundImage->Release();

	NormalFont.reset();
	TitleFont.reset();
	SmallFont.reset();
	TinyFont.reset();

	if (TitleLabel)
	{
		TitleLabel->Release();
		TitleLabel.reset();
	}

	if (Scroller)
	{
		Scroller->Release();
		Scroller.reset();
	}

	for (auto& OfferInfo : OfferWidgets)
	{
		if (OfferInfo)
		{
			OfferInfo->Release();
			OfferInfo.reset();
		}
	}

	if (SearchOfferWidget)
	{
		SearchOfferWidget->Release();
		SearchOfferWidget.reset();
	}

	if (SearchButtonWidget)
	{
		SearchButtonWidget->Release();
		SearchButtonWidget.reset();
	}

	if (CancelSearchButtonWidget)
	{
		CancelSearchButtonWidget->Release();
		CancelSearchButtonWidget.reset();
	}
}

void FOfferListWidget::Update()
{
	if (bEnabled)
	{
		if (!bOfferInfoVisible)
			return;

		if (!FGame::Get().GetStore()->GetCurrentUser().IsValid())
		{
			return;
		}

		if (BackgroundImage) BackgroundImage->Update();

		FilteredData = OfferData;
		if (SearchOfferWidget && SearchButtonWidget && CancelSearchButtonWidget)
		{
			if (bIsFilterSet)
			{
				FilteredData.resize(0);
				std::wstring NameFilterUpper = FStringUtils::ToUpper(NameFilter);
				for (size_t i = 0; i < OfferData.size(); ++i)
				{
					std::wstring NameUpper = FStringUtils::ToUpper(OfferData[i].Title);
					if (NameUpper.find(NameFilterUpper) != std::wstring::npos)
					{
						FilteredData.push_back(OfferData[i]);
					}
				}

				if (FStringUtils::ToUpper(SearchOfferWidget->GetText()) == NameFilterUpper)
				{
					//show cancel search icon
					CancelSearchButtonWidget->Show();
					SearchButtonWidget->Hide();
				}
				else
				{
					//text is different, we can perform a different search, show search icon
					CancelSearchButtonWidget->Hide();
					SearchButtonWidget->Show();
				}
			}
			else
			{
				//filter is unset, we can perform search
				CancelSearchButtonWidget->Hide();
				SearchButtonWidget->Show();
			}
		}

		if (bCanPerformSearch && FilteredData.empty())
		{
			bCanPerformSearch = false;
		}

		if (TitleLabel) TitleLabel->Update();

		if (FirstOfferToView > (FilteredData.size() - OfferWidgets.size()))
		{
			FirstOfferToView = (FilteredData.size() - OfferWidgets.size());
		}

		for (size_t i = 0; i < OfferWidgets.size(); ++i)
		{
			auto& Widget = OfferWidgets[i];
			if (Widget)
			{
				if (FirstOfferToView + i < FilteredData.size())
				{
					Widget->Show();
					Widget->SetOfferData(FilteredData[FirstOfferToView + i]);
				}
				else
				{
					Widget->SetOfferData(FOfferData());
					Widget->Hide();
				}
				Widget->Update();
			}
		}

		if (SearchOfferWidget) SearchOfferWidget->Update();

		if (Scroller)
		{
			if (FilteredData.size() <= OfferWidgets.size())
			{
				Scroller->Hide();
			}
			else
			{
				Scroller->Show();
			}
			Scroller->Update();
		}
	}
}

void FOfferListWidget::Render(FSpriteBatchPtr& Batch)
{
	if (!bShown)
		return;

	IWidget::Render(Batch);

	if (BackgroundImage) BackgroundImage->Render(Batch);

	if (TitleLabel) TitleLabel->Render(Batch);

	if (bOfferInfoVisible && FGame::Get().GetStore()->GetCurrentUser().IsValid())
	{
		for (auto& widget : OfferWidgets)
		{
			widget->Render(Batch);
		}

		if (Scroller) Scroller->Render(Batch);

		if (SearchOfferWidget) SearchOfferWidget->SetTextColor(EnabledCol);

		if (SearchButtonWidget) SearchButtonWidget->SetBackgroundColor(EnabledCol);
		if (CancelSearchButtonWidget) CancelSearchButtonWidget->SetBackgroundColor(EnabledCol);
	}
	else
	{
		if (SearchOfferWidget) SearchOfferWidget->SetTextColor(DisabledCol);

		if (SearchButtonWidget) SearchButtonWidget->SetBackgroundColor(DisabledCol);
		if (CancelSearchButtonWidget) CancelSearchButtonWidget->SetBackgroundColor(EnabledCol);
	}

	if (SearchOfferWidget) SearchOfferWidget->Render(Batch);

	if (SearchButtonWidget) SearchButtonWidget->Render(Batch);
	if (CancelSearchButtonWidget) CancelSearchButtonWidget->Render(Batch);
}

#ifdef _DEBUG
void FOfferListWidget::DebugRender()
{
	IWidget::DebugRender();

	if (BackgroundImage) BackgroundImage->DebugRender();
	if (TitleLabel) TitleLabel->DebugRender();

	if (bOfferInfoVisible && FGame::Get().GetStore()->GetCurrentUser().IsValid())
	{
		for (auto& widget : OfferWidgets)
		{
			widget->DebugRender();
		}

		Scroller->DebugRender();
	}

	if (SearchOfferWidget) SearchOfferWidget->DebugRender();
	if (SearchButtonWidget) SearchButtonWidget->DebugRender();
	if (CancelSearchButtonWidget) CancelSearchButtonWidget->DebugRender();
}
#endif

void FOfferListWidget::SetPosition(Vector2 Pos)
{
	Vector2 OldPos = GetPosition();

	IWidget::SetPosition(Pos);

	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y));

	// Title Label
	if (TitleLabel) TitleLabel->SetPosition(Pos);

	if (Scroller && SearchOfferWidget && TitleLabel)
	{
		// Scroller
		Vector2 ScrollerPos = Vector2(Pos.x + Size.x - Scroller->GetSize().x - 5.f,
			Pos.y + TitleLabel->GetSize().y + SearchOfferWidget->GetSize().y + 15.f);
		Scroller->SetPosition(ScrollerPos);
	}

	// Offers
	for (auto& OfferInfo : OfferWidgets)
	{
		Vector2 OfferOldOffset = OfferInfo->GetPosition() - OldPos;
		OfferInfo->SetPosition(Pos + OfferOldOffset);
	}

	// Search Input Field
	if (SearchOfferWidget && TitleLabel)
	{
		Vector2 SearchFieldPos = Vector2(Pos.x + 5.f, Pos.y + TitleLabel->GetSize().y + (SearchOfferWidget->GetSize().y * 0.35f));
		SearchOfferWidget->SetPosition(SearchFieldPos);
	}

	Vector2 SearchPosition = Vector2(Position.x + Size.x - 20.f, Position.y + 48.f);
	if (SearchButtonWidget) SearchButtonWidget->SetPosition(SearchPosition);
	if (CancelSearchButtonWidget) CancelSearchButtonWidget->SetPosition(SearchPosition);
}

void FOfferListWidget::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (TitleLabel) TitleLabel->SetSize(Vector2(NewSize.x, 30.0f));

	if (BackgroundImage) BackgroundImage->SetSize(Vector2(NewSize.x, NewSize.y));

	if (SearchOfferWidget) SearchOfferWidget->SetSize(Vector2(NewSize.x - 8.f, 30.f));

	if (Scroller) Scroller->SetSize(Vector2(Scroller->GetSize().x, Size.y - InputFieldHeight - LabelHeight - BottomOffset - 50.0f));

	// Reset to add or remove Offers
	Reset();
}

void FOfferListWidget::OnUIEvent(const FUIEvent& Event)
{
	if (!bEnabled)
		return;

	if (!bOfferInfoVisible)
		return;

	if (!FGame::Get().GetStore()->GetCurrentUser().IsValid())
		return;

	if (Event.GetType() == EUIEventType::MousePressed || Event.GetType() == EUIEventType::MouseReleased)
	{
		for (auto& OfferInfo : OfferWidgets)
		{
			if (OfferInfo && OfferInfo->CheckCollision(Event.GetVector()))
			{
				OfferInfo->OnUIEvent(Event);
			}
		}

		if (Scroller && Scroller->CheckCollision(Event.GetVector()))
		{
			Scroller->OnUIEvent(Event);
		}

		bool bSearchButtonClicked = false;
		if (SearchButtonWidget && SearchButtonWidget->CheckCollision(Event.GetVector()))
		{
			SearchButtonWidget->OnUIEvent(Event);
			bSearchButtonClicked = true;
		}

		if (CancelSearchButtonWidget && CancelSearchButtonWidget->CheckCollision(Event.GetVector()))
		{
			CancelSearchButtonWidget->OnUIEvent(Event);
			bSearchButtonClicked = true;
		}

		if (!bSearchButtonClicked && SearchOfferWidget && SearchOfferWidget->CheckCollision(Event.GetVector()))
		{
			SearchOfferWidget->Clear();
			SearchOfferWidget->OnUIEvent(Event);
		}
	}
	else if (Event.GetType() == EUIEventType::KeyPressed ||
		Event.GetType() == EUIEventType::MouseWheelScrolled ||
		Event.GetType() == EUIEventType::TextInput)
	{
		if (SearchOfferWidget) SearchOfferWidget->OnUIEvent(Event);
		if (Scroller) Scroller->OnUIEvent(Event);
	}
	else if (Event.GetType() == EUIEventType::Last)
	{
		ClearFilter();
		if (SearchOfferWidget) SearchOfferWidget->Clear();
	}
	else
	{
		for (auto& OfferInfo : OfferWidgets)
		{
			OfferInfo->OnUIEvent(Event);
		}
	}
}

void FOfferListWidget::SetFocused(bool bValue)
{
	IWidget::SetFocused(bValue);

	if (!bValue)
	{
		if (TitleLabel) TitleLabel->SetFocused(false);
		if (SearchOfferWidget) SearchOfferWidget->SetFocused(false);
		for (auto NextOfferWidget : OfferWidgets)
		{
			if (NextOfferWidget)
			{
				NextOfferWidget->SetFocused(false);
			}
		}
	}
}

void FOfferListWidget::ScrollUp(size_t length)
{
	if (FirstOfferToView < length)
	{
		FirstOfferToView = 0;
	}
	else
	{
		FirstOfferToView -= length;
	}
}

void FOfferListWidget::ScrollDown(size_t length)
{
	FirstOfferToView += length;
	if (OfferWidgets.size() > FilteredData.size())
	{
		FirstOfferToView = 0;
		return;
	}

	if (FirstOfferToView > (FilteredData.size() - OfferWidgets.size()))
	{
		FirstOfferToView = (FilteredData.size() - OfferWidgets.size());
	}
}

void FOfferListWidget::ScrollToTop() 
{
	ScrollUp(FilteredData.size());
}

void FOfferListWidget::ScrollToBottom()
{
	ScrollDown(FilteredData.size());
}

size_t FOfferListWidget::NumEntries() const
{
	return FilteredData.size();
}


size_t FOfferListWidget::GetNumLinesPerPage() const
{
	return OfferWidgets.size();
}

size_t FOfferListWidget::FirstViewedEntry() const
{
	return FirstOfferToView;
}

size_t FOfferListWidget::LastViewedEntry() const
{
	return FirstOfferToView + OfferWidgets.size() - 1;
}

void FOfferListWidget::RefreshOfferData(const std::vector<FOfferData>& Offers)
{
	OfferData = Offers;

	if (Offers.empty())
	{
		for (auto& NextWidget : OfferWidgets)
		{
			NextWidget->SetOfferData(FOfferData());
		}
	}
}

void FOfferListWidget::Clear()
{
	for (auto& OfferInfo : OfferWidgets)
	{
		if (OfferInfo)
		{
			OfferInfo->Release();
			OfferInfo.reset();
		}
	}

	OfferWidgets.clear();
}

void FOfferListWidget::Reset()
{
	ClearFilter();
	Clear();
	CreateOffers();
}

void FOfferListWidget::CreateOffers()
{
	// Offers
	const size_t NumOffersOnScreen = size_t((Size.y - LabelHeight - InputFieldHeight - BottomOffset) / OfferInfoHeight);

	OfferWidgets.resize(NumOffersOnScreen);
	for (size_t i = 0; i < NumOffersOnScreen; ++i)
	{
		OfferWidgets[i] = std::make_shared<FOfferInfoWidget>(
			Vector2(Position.x, Position.y + LabelHeight + InputFieldHeight + (OfferInfoHeight * i) + 20.f),
			Vector2(Size.x - ScrollerWidth - 2.f, OfferInfoHeight),
			Layer - 1,
			FOfferData(),
			SmallFont,
			TinyFont,
			OfferInfoButtonParams);

		if (OfferWidgets[i])
		{
			OfferWidgets[i]->Create();
			OfferWidgets[i]->Hide();

			if (Scroller)
			{
				Vector2 OfferSize = Vector2(Size.x - Scroller->GetSize().x - 5.f, OfferWidgets[i]->GetSize().y);
				OfferWidgets[i]->SetSize(OfferSize);
			}
		}
	}
}

```

`EAC_SDK/Samples/Store/Source/OfferList.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Widget.h"
#include "Scroller.h"
#include "Font.h"
#include "Store.h"
#include "OfferInfo.h"


/** Forward declarations */
class FTextFieldWidget;
class FTextViewWidget;
class FTextLabelWidget;
class FUIEvent;
class FScroller;

/**
* A reusable widget used to display a list of offers in both the Catalog and the Cart.
*/
class FOfferListWidget : public IWidget, public IScrollable
{
public:
	/**
	 * Constructor
	 */
	FOfferListWidget(Vector2 OfferListPos,
		Vector2 OfferLisSize,
		UILayer OfferListLayer,
		FontPtr OfferListNormalFont,
		FontPtr OfferListTitleFont,
		FontPtr OfferListSmallFont,
		FontPtr OfferListTinyFont,
		const std::wstring& Title,
		const FOfferInfoButtonParams& OfferInfoButtonParams);

	FOfferListWidget(const FOfferListWidget&) = delete;
	FOfferListWidget& operator=(const FOfferListWidget&) = delete;

	/**
	 * Destructor
	 */
	virtual ~FOfferListWidget() {};

	/** IGfxComponent */
	virtual void Create() override;
	virtual void Release() override;
	virtual void Update() override;
	virtual void Render(FSpriteBatchPtr& Batch) override;
#ifdef _DEBUG
	virtual void DebugRender() override;
#endif

	/** IWidget */
	virtual void OnUIEvent(const FUIEvent& event) override;
	virtual void SetFocused(bool) override;
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;

	/** IScrollable */
	virtual void ScrollUp(size_t length) override;
	virtual void ScrollDown(size_t length) override;
	virtual void ScrollToTop() override;
	virtual void ScrollToBottom() override;
	virtual size_t NumEntries() const override;
	virtual size_t GetNumLinesPerPage() const override;
	virtual size_t FirstViewedEntry() const override;
	virtual size_t LastViewedEntry() const override;

	/** Refreshes Offer data with given collection of Offers */
	void RefreshOfferData(const std::vector<FOfferData>& Offers);

	/** Sets visibility of Offer info */
	void SetOfferInfoVisible(bool bVisible) { bOfferInfoVisible = bVisible; }

	/** Sets filter to display a subset of available Offers */
	void SetFilter(const std::wstring& filter)
	{
		NameFilter = filter; 
		bIsFilterSet = !NameFilter.empty();
		if (bIsFilterSet)
		{
			bCanPerformSearch = true;
			FirstOfferToView = 0;
		}
	}

	/** Clears filter */
	void ClearFilter()
	{
		NameFilter.clear();
		bIsFilterSet	= false;
		bCanPerformSearch = false;
		FirstOfferToView = 0;
	}

	/** Clears Offer list */
	void Clear();

	/** Resets Offer list */
	void Reset();

	/** Sets offset from bottom. */
	void SetBottomOffset(float Value) { BottomOffset = Value; }

private:
	/** Creates widgets for Offers info */
	void CreateOffers();

	/** Offer data */
	std::vector<FOfferData> OfferData;

	/** Offer data once filter has been applied */
	std::vector<FOfferData> FilteredData;

	/** Value for filter */
	std::wstring NameFilter;

	/** True if filter has been set to a non-default value */
	bool bIsFilterSet = false;

	/** True if there's not a search active already */
	bool bCanPerformSearch = false;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;
	
	/** Title Label */
	std::shared_ptr<FTextLabelWidget> TitleLabel;

	/** Collection of all Offer info widgets */
	std::vector<std::shared_ptr<FOfferInfoWidget>> OfferWidgets;

	/** Widget controlling Offer search */
	std::shared_ptr<FTextFieldWidget> SearchOfferWidget;

	/** Search button */
	std::shared_ptr<FButtonWidget> SearchButtonWidget;

	/** Cancel search button */
	std::shared_ptr<FButtonWidget> CancelSearchButtonWidget;

	/** Offer Info button name used when creating new offer info widgets. */
	FOfferInfoButtonParams OfferInfoButtonParams;

	/** Shared font */
	FontPtr NormalFont;

	/** Title font */
	FontPtr TitleFont;

	/** Small font */
	FontPtr SmallFont;

	/** Tiny font */
	FontPtr TinyFont;

	/** Scroller */
	std::shared_ptr<FScroller> Scroller;

	/** Index of first Offers to view */
	size_t FirstOfferToView = 0;

	/** Flag used to hide / show Offer info */
	bool bOfferInfoVisible = true;

	/** Offset from the bottom of widget that is not used. */
	float BottomOffset = 0.0f;

	/** Colors */
	static constexpr FColor EnabledCol = FColor(1.f, 1.f, 1.f, 1.f);
	static constexpr FColor DisabledCol = FColor(0.2f, 0.2f, 0.2f, 1.f);
};

```

`EAC_SDK/Samples/Store/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Store";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};

```

`EAC_SDK/Samples/Store/Source/Store.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"

#include "Store.h"
#include "eos_ecom.h"

FStore::FStore()
{
}

FStore::~FStore()
{
}


void FStore::Update()
{
	if (FPlayerManager::Get().GetNumPlayers() == 0)
	{
		return;
	}

	UpdateStoreTimer -= float(Main->GetTimer().GetElapsedSeconds());
	if (UpdateStoreTimer < 0.f)
	{
		if (CurrentUserId.IsValid())
		{
			QueryStore(CurrentUserId);
		}
		UpdateStoreTimer = UpdateStoreTimeoutSeconds;
	}
}

void FStore::Checkout()
{
	if (!FPlatform::IsInitialized())
	{
		FDebugLog::LogWarning(L"[EOS SDK] Can't Checkout - Platform Not Initialized");
		return;
	}

	if (GetCart().empty())
	{
		FDebugLog::LogWarning(L"Cart Empty!");
		return;
	}

	UpdateStoreTimer = UpdateStoreTimeoutSeconds;

	FDebugLog::Log(L"[EOS SDK] Checkout start");

	EOS_HEcom EcomHandle = EOS_Platform_GetEcomInterface(FPlatform::GetPlatformHandle());

	std::vector<EOS_Ecom_CheckoutEntry> CheckoutEntries;
	for (const auto& CartItem : GetCart())
	{
		EOS_Ecom_CheckoutEntry Entry;
		Entry.ApiVersion = EOS_ECOM_CHECKOUTENTRY_API_LATEST;
		Entry.OfferId = CartItem.Id.c_str();
		CheckoutEntries.push_back(Entry);
	}

	EOS_Ecom_CheckoutOptions CheckoutOptions{ 0 };
	CheckoutOptions.ApiVersion = EOS_ECOM_CHECKOUT_API_LATEST;
	CheckoutOptions.LocalUserId = CurrentUserId;
	CheckoutOptions.OverrideCatalogNamespace = nullptr;
	CheckoutOptions.EntryCount = static_cast<uint32_t>(CheckoutEntries.size());
	CheckoutOptions.Entries = &CheckoutEntries[0];

	EOS_Ecom_Checkout(EcomHandle, &CheckoutOptions, NULL, CheckoutCompleteCallbackFn);
}

void FStore::AddToCart(const FOfferData& OfferData)
{
	if (UserCart.Add(OfferData))
	{
		SetCartDirty(true);
	}
}

void FStore::RemoveFromCart(const FOfferData& OfferData)
{
	if (UserCart.Remove(OfferData))
	{
		SetCartDirty(true);
	}
}

const std::list<FOfferData>& FStore::GetCart() const
{
	return UserCart.CartItems;
}

void FStore::QueryStore(EOS_EpicAccountId LocalUserId)
{
	if (!FPlatform::IsInitialized())
	{
		FDebugLog::LogWarning(L"[EOS SDK] Can't Query Store - Platform Not Initialized");
		return;
	}

	UpdateStoreTimer = UpdateStoreTimeoutSeconds;

	FDebugLog::Log(L"[EOS SDK] Querying Store");

	EOS_HEcom EcomHandle = EOS_Platform_GetEcomInterface(FPlatform::GetPlatformHandle());

	EOS_Ecom_QueryOffersOptions QueryOptions{ 0 };
	QueryOptions.ApiVersion = EOS_ECOM_QUERYOFFERS_API_LATEST;
	QueryOptions.LocalUserId = LocalUserId;
	QueryOptions.OverrideCatalogNamespace = nullptr;

	EOS_Ecom_QueryOffers(EcomHandle, &QueryOptions, NULL, QueryStoreCompleteCallbackFn);
}

void FStore::QueryEntitlements(EOS_EpicAccountId LocalUserId)
{
	if (!FPlatform::IsInitialized())
	{
		FDebugLog::LogWarning(L"[EOS SDK] Can't Query Entitlements - Platform Not Initialized");
		return;
	}

	UpdateStoreTimer = UpdateStoreTimeoutSeconds;

	FDebugLog::Log(L"[EOS SDK] Querying Entitlements");

	EOS_HEcom EcomHandle = EOS_Platform_GetEcomInterface(FPlatform::GetPlatformHandle());

	EOS_Ecom_QueryEntitlementsOptions QueryOptions{ 0 };
	QueryOptions.ApiVersion = EOS_ECOM_QUERYENTITLEMENTS_API_LATEST;
	QueryOptions.LocalUserId = LocalUserId;
	QueryOptions.bIncludeRedeemed = true;

	EOS_Ecom_QueryEntitlements(EcomHandle, &QueryOptions, NULL, QueryEntitlementsCompleteCallbackFn);
}

void FStore::SetCatalog(FEpicAccountId InUserId, std::vector<FOfferData>&& InCatalog)
{
	Catalog.swap(InCatalog);
	bDirty = true;
}

void FStore::SetEntitlements(FEpicAccountId InUserId, std::vector<FEntitlementData>&& InEntitlements)
{
	Entitlements.swap(InEntitlements);
	bDirty = true;
}

void FStore::OnLoggedIn(FEpicAccountId UserId)
{
	if (!CurrentUserId.IsValid())
	{
		SetCurrentUser(UserId);
	}
}

void FStore::OnLoggedOut(FEpicAccountId UserId)
{
	Catalog.clear();
	Entitlements.clear();
	UserCart.Clear();
	UpdateStoreTimer = 0.f;

	if (FPlayerManager::Get().GetNumPlayers() > 0)
	{
		if (GetCurrentUser() == UserId)
		{
			FGameEvent Event(EGameEventType::ShowNextUser);
			OnGameEvent(Event);
		}
	}
	else
	{
		SetCurrentUser(FEpicAccountId());
	}
}

void FStore::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedOut(UserId);
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		if (FPlayerManager::Get().GetNumPlayers() > 0)
		{
			FEpicAccountId PrevPlayerId = FPlayerManager::Get().GetPrevPlayerId(GetCurrentUser());
			if (PrevPlayerId.IsValid())
			{
				SetCurrentUser(PrevPlayerId);
				SetDirty(true);
				QueryStore(PrevPlayerId);

				UserCart.Clear();
				SetCartDirty(true);
			}
			else
			{
				SetCurrentUser(FEpicAccountId());
			}
		}
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		if (FPlayerManager::Get().GetNumPlayers() > 0)
		{
			FEpicAccountId NextPlayerId = FPlayerManager::Get().GetNextPlayerId(GetCurrentUser());
			if (NextPlayerId.IsValid())
			{
				SetCurrentUser(NextPlayerId);
				SetDirty(true);
				QueryStore(NextPlayerId);

				UserCart.Clear();
				SetCartDirty(true);
			}
			else
			{
				SetCurrentUser(FEpicAccountId());
			}
		}
	}
	else if (Event.GetType() == EGameEventType::RefreshOffers)
	{
		FEpicAccountId CurrPlayerId = GetCurrentUser();
		if (CurrPlayerId.IsValid())
		{
			SetDirty(true);
			QueryStore(CurrPlayerId);
		}
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		SetDirty(true);
		SetCartDirty(true);
	}
}

void FStore::OnCheckoutSuccessful()
{
	UserCart.Clear();
	SetCartDirty(true);
}

void EOS_CALL FStore::QueryStoreCompleteCallbackFn(const EOS_Ecom_QueryOffersCallbackInfo* OfferData)
{
	assert(OfferData != NULL);

	if (OfferData->ResultCode != EOS_EResult::EOS_Success)
	{
		if (OfferData->ResultCode == EOS_EResult::EOS_Ecom_CatalogOfferPriceInvalid)
		{
			FDebugLog::LogWarning(L"[EOS SDK] Query offer warning: %ls", FStringUtils::Widen(EOS_EResult_ToString(OfferData->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::LogError(L"[EOS SDK] Query offer error: %ls", FStringUtils::Widen(EOS_EResult_ToString(OfferData->ResultCode)).c_str());
			return;
		}
	}

	FDebugLog::Log(L"[EOS SDK] Query offer complete - User ID: %ls", FEpicAccountId(OfferData->LocalUserId).ToString().c_str());

	EOS_HEcom EcomHandle = EOS_Platform_GetEcomInterface(FPlatform::GetPlatformHandle());

	EOS_Ecom_GetOfferCountOptions CountOptions{ 0 };
	CountOptions.ApiVersion = EOS_ECOM_GETOFFERCOUNT_API_LATEST;
	CountOptions.LocalUserId = OfferData->LocalUserId;
	uint32_t OfferCount = EOS_Ecom_GetOfferCount(EcomHandle, &CountOptions);

	FDebugLog::Log(L"[EOS SDK] NumOffers: %d", OfferCount);

	std::vector<FOfferData> NewOffers;
	NewOffers.reserve(OfferCount);

	EOS_Ecom_CopyOfferByIndexOptions IndexOptions{ 0 };
	IndexOptions.ApiVersion = EOS_ECOM_COPYOFFERBYINDEX_API_LATEST;
	IndexOptions.LocalUserId = OfferData->LocalUserId;
	for (IndexOptions.OfferIndex = 0; IndexOptions.OfferIndex < OfferCount; ++IndexOptions.OfferIndex)
	{
		EOS_Ecom_CatalogOffer* Offer;
		EOS_EResult CopyResult = EOS_Ecom_CopyOfferByIndex(EcomHandle, &IndexOptions, &Offer);
		switch (CopyResult)
		{
		case EOS_EResult::EOS_Success:
		case EOS_EResult::EOS_Ecom_CatalogOfferPriceInvalid:
		case EOS_EResult::EOS_Ecom_CatalogOfferStale:
			FDebugLog::Log(L"[EOS SDK] Offer[%d] id(%ls) title(%ls) Price[Result(%d) Curr(%ull) Original(%ull) DecimalPoint(%ud)] Available?(%ls) Limit[%d]",
				IndexOptions.OfferIndex,
				FStringUtils::Widen(Offer->Id).c_str(),
				FStringUtils::Widen(Offer->TitleText).c_str(),
				Offer->PriceResult, Offer->CurrentPrice64, Offer->OriginalPrice64, Offer->DecimalPoint,
				Offer->bAvailableForPurchase ? L"true" : L"false",
				Offer->PurchaseLimit);

			NewOffers.push_back(FOfferData{
				OfferData->LocalUserId,
				std::string(Offer->Id),
				FStringUtils::Widen(Offer->TitleText),
				Offer->PriceResult == EOS_EResult::EOS_Success,
				Offer->CurrentPrice64,
				Offer->OriginalPrice64,
				Offer->DecimalPoint
			});

			EOS_Ecom_CatalogOffer_Release(Offer);
			break;
		default:
			FDebugLog::Log(L"[EOS SDK] Offer[%d] invalid : %d", IndexOptions.OfferIndex, CopyResult);
			break;
		}
	}

	if (FGame::Get().GetStore())
	{
		FGame::Get().GetStore()->SetCatalog(OfferData->LocalUserId, std::move(NewOffers));
	}

	FGame::Get().GetStore()->QueryEntitlements(OfferData->LocalUserId);
}

void EOS_CALL FStore::QueryEntitlementsCompleteCallbackFn(const EOS_Ecom_QueryEntitlementsCallbackInfo* EntitlementData)
{
	assert(EntitlementData != NULL);

	if (EntitlementData->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Query entitlement error: %ls", FStringUtils::Widen(EOS_EResult_ToString(EntitlementData->ResultCode)).c_str());
		return;
	}

	FDebugLog::Log(L"[EOS SDK] Query entitlement complete - User ID: %ls", FEpicAccountId(EntitlementData->LocalUserId).ToString().c_str());

	EOS_HEcom EcomHandle = EOS_Platform_GetEcomInterface(FPlatform::GetPlatformHandle());

	EOS_Ecom_GetEntitlementsCountOptions CountOptions{ 0 };
	CountOptions.ApiVersion = EOS_ECOM_GETENTITLEMENTSCOUNT_API_LATEST;
	CountOptions.LocalUserId = EntitlementData->LocalUserId;
	uint32_t EntitlementCount = EOS_Ecom_GetEntitlementsCount(EcomHandle, &CountOptions);

	FDebugLog::Log(L"[EOS SDK] NumEntitlements: %d", EntitlementCount);

	std::vector<FEntitlementData> NewEntitlements;
	NewEntitlements.reserve(EntitlementCount);

	EOS_Ecom_CopyEntitlementByIndexOptions IndexOptions{ 0 };
	IndexOptions.ApiVersion = EOS_ECOM_COPYENTITLEMENTBYINDEX_API_LATEST;
	IndexOptions.LocalUserId = EntitlementData->LocalUserId;
	for (IndexOptions.EntitlementIndex = 0; IndexOptions.EntitlementIndex < EntitlementCount; ++IndexOptions.EntitlementIndex)
	{
		EOS_Ecom_Entitlement* Entitlement;
		EOS_EResult CopyResult = EOS_Ecom_CopyEntitlementByIndex(EcomHandle, &IndexOptions, &Entitlement);
		switch (CopyResult)
		{
		case EOS_EResult::EOS_Success:
		case EOS_EResult::EOS_Ecom_EntitlementStale:
			FDebugLog::Log(L"[EOS SDK] Entitlement[%d] : %ls : %ls : %ls",
				IndexOptions.EntitlementIndex,
				FStringUtils::Widen(Entitlement->EntitlementName).c_str(),
				FStringUtils::Widen(Entitlement->EntitlementId).c_str(),
				Entitlement->bRedeemed ? L"TRUE" : L"FALSE");

			NewEntitlements.push_back(FEntitlementData{
				EntitlementData->LocalUserId,
				std::string(Entitlement->EntitlementName),
				std::string(Entitlement->EntitlementId),
				Entitlement->bRedeemed == EOS_TRUE
			});

			EOS_Ecom_Entitlement_Release(Entitlement);
			break;
		default:
			FDebugLog::Log(L"[EOS SDK] Entitlement[%d] invalid : %d", IndexOptions.EntitlementIndex, CopyResult);
			break;
		}
	}

	if (FGame::Get().GetStore())
	{
		FGame::Get().GetStore()->SetEntitlements(EntitlementData->LocalUserId, std::move(NewEntitlements));
	}
}

void EOS_CALL FStore::CheckoutCompleteCallbackFn(const EOS_Ecom_CheckoutCallbackInfo* CheckoutData)
{
	assert(CheckoutData != NULL);

	if (CheckoutData->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Checkout error: %ls", FStringUtils::Widen(EOS_EResult_ToString(CheckoutData->ResultCode)).c_str());

		std::wstring Msg = L"Checkout Failed";
		FGameEvent Event(EGameEventType::AddNotification, Msg);
		FGame::Get().OnGameEvent(Event);

		return;
	}

	FDebugLog::Log(L"[EOS SDK] Checkout complete - User ID: %ls", FEpicAccountId(CheckoutData->LocalUserId).ToString().c_str());
	if (CheckoutData->TransactionId)
	{
		EOS_Ecom_HTransaction TransactionHandle;

		EOS_Ecom_CopyTransactionByIdOptions CopyTransactionOptions{ 0 };
		CopyTransactionOptions.ApiVersion = EOS_ECOM_COPYTRANSACTIONBYID_API_LATEST;
		CopyTransactionOptions.LocalUserId = CheckoutData->LocalUserId;
		CopyTransactionOptions.TransactionId = CheckoutData->TransactionId;

		EOS_HEcom EcomHandle = EOS_Platform_GetEcomInterface(FPlatform::GetPlatformHandle());
		if (EOS_Ecom_CopyTransactionById(EcomHandle, &CopyTransactionOptions, &TransactionHandle) == EOS_EResult::EOS_Success)
		{
			EOS_Ecom_Transaction_GetEntitlementsCountOptions CountOptions{ 0 };
			CountOptions.ApiVersion = EOS_ECOM_TRANSACTION_GETENTITLEMENTSCOUNT_API_LATEST;
			uint32_t EntitlementCount = EOS_Ecom_Transaction_GetEntitlementsCount(TransactionHandle, &CountOptions);

			FDebugLog::Log(L"[EOS SDK] New Entitlements: %d", EntitlementCount);

			std::vector<FEntitlementData> NewEntitlements;
			NewEntitlements.reserve(EntitlementCount);

			EOS_Ecom_Transaction_CopyEntitlementByIndexOptions IndexOptions{ 0 };
			IndexOptions.ApiVersion = EOS_ECOM_TRANSACTION_COPYENTITLEMENTBYINDEX_API_LATEST;
			for (IndexOptions.EntitlementIndex = 0; IndexOptions.EntitlementIndex < EntitlementCount; ++IndexOptions.EntitlementIndex)
			{
				EOS_Ecom_Entitlement* Entitlement;
				EOS_EResult CopyResult = EOS_Ecom_Transaction_CopyEntitlementByIndex(TransactionHandle, &IndexOptions, &Entitlement);
				switch (CopyResult)
				{
				case EOS_EResult::EOS_Success:
				case EOS_EResult::EOS_Ecom_EntitlementStale:
					FDebugLog::Log(L"[EOS SDK] New Entitlement[%d] : %ls : %ls : %ls",
						IndexOptions.EntitlementIndex,
						FStringUtils::Widen(Entitlement->EntitlementName).c_str(),
						FStringUtils::Widen(Entitlement->EntitlementId).c_str(),
						Entitlement->bRedeemed ? L"TRUE" : L"FALSE");

					NewEntitlements.push_back(FEntitlementData{
						CheckoutData->LocalUserId,
						std::string(Entitlement->EntitlementName),
						std::string(Entitlement->EntitlementId),
						Entitlement->bRedeemed == EOS_TRUE
						});

					EOS_Ecom_Entitlement_Release(Entitlement);
					break;
				default:
					FDebugLog::Log(L"[EOS SDK] New Entitlement[%d] invalid : %d", IndexOptions.EntitlementIndex, CopyResult);
					break;
				}
			}

			if (FGame::Get().GetStore())
			{
				FGame::Get().GetStore()->SetEntitlements(CheckoutData->LocalUserId, std::move(NewEntitlements));
			}

			EOS_Ecom_Transaction_Release(TransactionHandle);
		}
	}

	std::wstring Msg = L"Checkout Successful";
	FGameEvent Event(EGameEventType::AddNotification, Msg);
	FGame::Get().OnGameEvent(Event);
	FGame::Get().GetStore()->OnCheckoutSuccessful();
}

```

`EAC_SDK/Samples/Store/Source/Store.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_sdk.h"

struct FEntitlementData
{
	/** User associated with this entitlement */
	FEpicAccountId UserId;
	/** The EOS_Ecom_EntitlementName */
	std::string Name;
	/** The EOS_Ecom_EntitlementInstanceId */
	std::string InstanceId;
	/** If true then this entitlement has been retrieved */
	bool bRedeemed;
};

struct FOfferData
{
	/** User associated with this offer */
	FEpicAccountId UserId;
	/** The EOS_Ecom_CatalogOfferId */
	std::string Id;
	/** The title of the offer */
	std::wstring Title;
	/** True if the price was properly retrieved */
	bool bPriceValid;
	/** The current price of the offer (includes discounts) */
	uint64_t CurrentPrice;
	/** The original price of the offer */
	uint64_t OriginalPrice;
	/** The decimal point for given price. */
	uint32_t DecimalPoint;
};

/** Provides access to EOS_Ecom with an emphasis on the Catalog */
class FStore
{
public:
	FStore() noexcept(false);
	FStore(FStore const&) = delete;
	FStore& operator=(FStore const&) = delete;

	virtual ~FStore();

	/** Query the store for offer info and entitlement info */
	void Update();

	/** Buy current offers in the cart. */
	void Checkout();

	/** Adds an offer to the cart. */
	void AddToCart(const FOfferData& OfferData);

	/** Removes an offer from the cart. */
	void RemoveFromCart(const FOfferData& OfferData);

	/** Redeem an entitlement */
	// void RedeemEntitlement(const FEntitlementData& Entitlement);

	/** Retrieves the catalog cache */
	const std::vector<FOfferData>& GetCatalog() const { return Catalog; }
	/** Retrieves the entitlements cache */
	const std::vector<FEntitlementData>& GetEntitlements() const { return Entitlements; }
	/** Retrieves the cart cache for the current user. */
	const std::list<FOfferData>& GetCart() const;

	/** Has the catalog data updated? */
	bool IsDirty() { return bDirty; };
	/** Change the dirty flag directly */
	void SetDirty(bool bNewIsDirty) { bDirty = bNewIsDirty; };

	/** Has the cart data updated? */
	bool IsCartDirty() { return bIsCartDirty; }
	/** Change the cart dirty flag directly */
	void SetCartDirty(bool bNewIsCartDirty) { bIsCartDirty = bNewIsCartDirty; }

	/** Set the user currently associated with the store */
	void SetCurrentUser(FEpicAccountId UserId) { CurrentUserId = UserId; };
	/** Get the user currently associated with the store */
	FEpicAccountId GetCurrentUser() { return CurrentUserId; };

	/** Notify the store of game events. */
	void OnGameEvent(const FGameEvent& Event);

	/** Called on the completion of a successful checkout. */
	void OnCheckoutSuccessful();
private:
	struct FCart
	{
		/** Cart related Aliases. */
		using CartItemIter = std::list<FOfferData>::iterator;
		using CartItemToIterMap = std::map<std::string, CartItemIter>;

		/** The current cart cache */
		std::list<FOfferData> CartItems;
		/** A map that helps in O(1) removal of items from the cart */
		CartItemToIterMap CartItemMap;

		FCart() = default;
		~FCart()
		{
			CartItems.clear();
			CartItemMap.clear();
		}

		bool Add(const FOfferData& OfferData)
		{
			CartItemToIterMap::iterator It = CartItemMap.find(OfferData.Id);
			// Do not allow duplicates.
			if (It == CartItemMap.end())
			{
				CartItemIter ItemIter = CartItems.insert(CartItems.end(), OfferData);
				CartItemMap.insert({ OfferData.Id, ItemIter });

				return true;
			}

			return false;
		}

		bool Remove(const FOfferData& OfferData)
		{
			CartItemToIterMap::iterator It = CartItemMap.find(OfferData.Id);
			if (It != CartItemMap.end())
			{
				CartItems.erase(It->second);
				CartItemMap.erase(OfferData.Id);
				
				return true;
			}

			return false;
		}

		void Clear()
		{
			CartItems.clear();
			CartItemMap.clear();
		}
	};

	/** Respond to the logged in game event */
	void OnLoggedIn(FEpicAccountId UserId);
	/** Respond to the logged out game event */
	void OnLoggedOut(FEpicAccountId UserId);

	/** Start a store query for the user */
	void QueryStore(EOS_EpicAccountId LocalUserId);
	/** Start a entitlement query for the user */
	void QueryEntitlements(EOS_EpicAccountId LocalUser);

	/** Set the catalog data */
	void SetCatalog(FEpicAccountId InUserId, std::vector<FOfferData>&& InCatalog);
	/** Set the entitlement data */
	void SetEntitlements(FEpicAccountId InUserId, std::vector<FEntitlementData>&& InEntitlements);

	/** The cached data dirty flag */
	bool bDirty = false;
	/** The cached cart data dirty flag */
	bool bIsCartDirty = false;
	/** How long until the next update */
	float UpdateStoreTimer = 0.f;
	/** The current user associated with the store */
	FEpicAccountId CurrentUserId;

	/** The current catalog cache */
	std::vector<FOfferData> Catalog;
	/** The current entitlement cache */
	std::vector<FEntitlementData> Entitlements;
	/** The user's cart */
	FCart UserCart;

	/** The desired store update time */
	static constexpr float UpdateStoreTimeoutSeconds = 300.f;

	/** Static callback handler for Checkout complete */
	static void EOS_CALL CheckoutCompleteCallbackFn(const EOS_Ecom_CheckoutCallbackInfo* CheckoutData);

	/** Static callback handler for Query Offer complete */
	static void EOS_CALL QueryStoreCompleteCallbackFn(const EOS_Ecom_QueryOffersCallbackInfo* OfferData);

	/** Static callback handler for Query Entitlement complete */
	static void EOS_CALL QueryEntitlementsCompleteCallbackFn(const EOS_Ecom_QueryEntitlementsCallbackInfo* EntitlementData);
};

```

`EAC_SDK/Samples/Store/Source/StoreDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "OfferList.h"
#include "StoreDialog.h"

namespace
{
	constexpr float CheckoutButtonSizeY = 30.0f;
	constexpr float CheckoutButtonHorizontalOffset = 15.0f;
}

FStoreDialog::FStoreDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer),
	NormalFont(DialogNormalFont),
	SmallFont(DialogSmallFont),
	TinyFont(DialogTinyFont)
{
	CreateCatalogWidget();
	CreateCartWidget();
	CreateCheckoutButtonWidget();
}

void FStoreDialog::CreateCatalogWidget()
{
	FOfferInfoButtonParams CatalogOfferButtonParams;
	CatalogOfferButtonParams.ButtonName = L"Add To Cart";
	CatalogOfferButtonParams.OnButtonClicked = std::move([](const FOfferData& Offer)
	{
		FGame::Get().GetStore()->AddToCart(Offer);
	});
	CatalogWidget = CreateOfferListWidget(L"Catalog", CatalogOfferButtonParams, CatalogWidgetBottomOffset);
}

void FStoreDialog::CreateCartWidget()
{
	FOfferInfoButtonParams CartOfferButtonParams;
	CartOfferButtonParams.ButtonName = L"Remove";
	CartOfferButtonParams.OnButtonClicked = std::move([](const FOfferData& Offer)
	{
		FGame::Get().GetStore()->RemoveFromCart(Offer);
	});
	CartWidget = CreateOfferListWidget(L"Cart", CartOfferButtonParams, CartWidgetBottomOffset);
}

std::shared_ptr<FOfferListWidget> FStoreDialog::CreateOfferListWidget(const std::wstring& Title, const FOfferInfoButtonParams& OfferInfoButtonParams, float BottomOffset)
{
	std::shared_ptr<FOfferListWidget> OfferListWidget = std::make_shared<FOfferListWidget>(
		Position,
		Size,
		Layer,
		NormalFont,
		SmallFont,
		SmallFont,
		TinyFont,
		Title,
		OfferInfoButtonParams);

	OfferListWidget->SetBottomOffset(BottomOffset);
	OfferListWidget->SetBorderColor(Color::UIBorderGrey);

	OfferListWidget->Create();
	AddWidget(OfferListWidget);

	return OfferListWidget;
}

void FStoreDialog::CreateCheckoutButtonWidget()
{
	CheckoutButton = std::make_shared<FButtonWidget>(
		Position,
		Vector2(Size.x - CheckoutButtonHorizontalOffset, CheckoutButtonSizeY),
		Layer - 1,
		L"Checkout",
		assets::DefaultButtonAssets,
		SmallFont,
		assets::DefaultButtonColors[0]);

	CheckoutButton->SetBackgroundColors(assets::DefaultButtonColors);
	CheckoutButton->Create();
	CheckoutButton->SetOnPressedCallback([]()
	{
		if (FGame::Get().GetStore())
		{
			FGame::Get().GetStore()->Checkout();
		}
	});			

	CheckoutButton->Create();
	CheckoutButton->Disable();
	CheckoutButton->Hide();
	AddWidget(CheckoutButton);
}

void FStoreDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (CatalogWidget)
	{
		CatalogWidget->SetPosition(Vector2(ConsoleDialogPosition.x, Pos.y));
	}

	if (CartWidget)
	{
		CartWidget->SetPosition(Pos);

		if (CheckoutButton)
		{
			const float CheckoutButtonX = CartWidget->GetPosition().x + CheckoutButtonHorizontalOffset;
			const float CheckoutButtonY = CartWidget->GetPosition().y + CartWidget->GetSize().y - CartWidgetBottomOffset;
			CheckoutButton->SetPosition(Vector2(CheckoutButtonX, CheckoutButtonY));
		}
	}
}

void FStoreDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (CatalogWidget)
	{
		CatalogWidget->SetSize(Vector2(ConsoleDialogSize.x, ConsoleDialogPosition.y - Position.y - 10.0f));
	}

	if (CartWidget)
	{
		CartWidget->SetSize(NewSize);

		if (CheckoutButton)
		{
			CheckoutButton->SetSize(Vector2(CartWidget->GetSize().x - 2 * CheckoutButtonHorizontalOffset, CheckoutButtonSizeY));
		}
	}
}

void FStoreDialog::Update()
{
	FDialog::Update();

	FStore* StorePtr = FGame::Get().GetStore().get();
	if (StorePtr && StorePtr->GetCurrentUser().IsValid())
	{
		if (StorePtr->IsDirty())
		{
			if (CatalogWidget)
			{
				CatalogWidget->RefreshOfferData(StorePtr->GetCatalog());
			}
			StorePtr->SetDirty(false);
		}

		if (StorePtr->IsCartDirty())
		{
			if (CartWidget)
			{
				const std::list<FOfferData>& CartList = StorePtr->GetCart();
				CartWidget->RefreshOfferData(std::vector<FOfferData>(CartList.begin(), CartList.end()));

				if (CheckoutButton)
				{
					if (CartList.empty())
					{
						CheckoutButton->Disable();
					}
					else
					{
						CheckoutButton->Enable();
					}
				}
			}
			StorePtr->SetCartDirty(false);
		}
	}
}

void FStoreDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		SetOfferInfoVisible(true);
	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		SetOfferInfoVisible(false);
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		SetOfferInfoVisible(true);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		if (FPlayerManager::Get().GetNumPlayers() == 0)
		{
			Clear();
			SetOfferInfoVisible(false);
		}
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		Clear();
		Reset();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		Clear();
		Reset();
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		SetOfferInfoVisible(false);
		Clear();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		Clear();
		Reset();
	}
}

void FStoreDialog::SetOfferInfoVisible(bool bVisible)
{
	if (CatalogWidget)
	{
		CatalogWidget->SetOfferInfoVisible(bVisible);
	}

	if (CartWidget)
	{
		CartWidget->SetOfferInfoVisible(bVisible);
	}

	if (CheckoutButton)
	{
		if (bVisible)
			CheckoutButton->Show();
		else
			CheckoutButton->Hide();
	}
}

void FStoreDialog::Reset()
{
	if (CatalogWidget)
	{
		CatalogWidget->SetOfferInfoVisible(true);
		CatalogWidget->Reset();
	}

	if (CartWidget)
	{
		CartWidget->SetOfferInfoVisible(true);
		CartWidget->Reset();
	}

	if (CheckoutButton)
	{
		CheckoutButton->Disable();
	}
}

void FStoreDialog::Clear()
{
	if (CatalogWidget)
	{
		CatalogWidget->RefreshOfferData(std::vector<FOfferData>());
		CatalogWidget->Reset();
	}

	if (CartWidget)
	{
		CartWidget->RefreshOfferData(std::vector<FOfferData>());
		CartWidget->Reset();
	}

	if (CheckoutButton)
	{
		CheckoutButton->Disable();
	}
}

```

`EAC_SDK/Samples/Store/Source/StoreDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"

/**
 * Forward declarations
 */
struct FOfferInfoButtonParams;
class FOfferListWidget;
class FGameEvent;

/**
 * Store dialog
 */
class FStoreDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FStoreDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FStoreDialog() {};

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	virtual void Update() override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/** Sets visibility of offer info */
	void SetOfferInfoVisible(bool bVisible);

	/** Reset */
	void Reset();

	/** Clear */
	void Clear();

	/** Set Console Dialog Size and Position */
	void SetConsoleDialogSizeAndPosition(Vector2 InConsoleDialogSize, Vector2 InConsoleDialogPosition)
	{
		ConsoleDialogSize = InConsoleDialogSize;
		ConsoleDialogPosition = InConsoleDialogPosition;
	}
	
private:
	
	/** Creates the store catalog widget to display available offers. */
	void CreateCatalogWidget();

	/** Creates the store cart widget to display the current offers added to cart */
	void CreateCartWidget();

	/** Creates a offer list widget using the given parameters. */
	std::shared_ptr<FOfferListWidget> CreateOfferListWidget(const std::wstring& Title, const FOfferInfoButtonParams& OfferInfoButtonParams, float BottomOffset);

	/** Creates the checkout widget */
	void CreateCheckoutButtonWidget();

	/** The Catalog widget */
	std::shared_ptr<FOfferListWidget> CatalogWidget;

	/** The Cart widget */
	std::shared_ptr<FOfferListWidget> CartWidget;

	/** The Checkout button */
	std::shared_ptr<FButtonWidget> CheckoutButton;

	/** Console Dialog Size*/
	Vector2 ConsoleDialogSize;

	/** Console Dialog Position */
	Vector2 ConsoleDialogPosition;

	/** Bottom offset for the catalog widget */
	float CatalogWidgetBottomOffset = 50.0f;

	/** Bottom offset for the cart widget */
	float CartWidgetBottomOffset = 100.0f;

	/** Normal Font */
	FontPtr NormalFont;

	/** Small Font */
	FontPtr SmallFont;

	/** TinyFont */
	FontPtr TinyFont;
};

```

`EAC_SDK/Samples/Store/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/Store/Store.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>Store</RootNamespace>
    <ProjectGuid>{323C59E5-555F-4DE4-86F2-D9572C00EC25}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Store</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Store/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Store/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Store/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Store/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Store/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Store/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Store/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/Store/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\NotificationDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\OfferInfo.h" />
    <ClInclude Include="Source\OfferList.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\Store.h" />
    <ClInclude Include="Source\StoreDialog.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\NotificationDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\OfferInfo.cpp" />
    <ClCompile Include="Source\OfferList.cpp" />
    <ClCompile Include="Source\Store.cpp" />
    <ClCompile Include="Source\StoreDialog.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/Store/Store.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Source\OfferInfo.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\OfferList.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Store.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\StoreDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\NotificationDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
	<ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Source\OfferInfo.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\OfferList.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Store.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\StoreDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\NotificationDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/Store/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/TitleStorage/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
pause
```

`EAC_SDK/Samples/TitleStorage/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/TitleStorage/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/TitleStorage/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "TitleStorage.h"
#include "GameEvent.h"
#include "Player.h"
#include "Game.h"

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	TitleStorage = std::make_unique<FTitleStorage>();

	CreateConsoleCommands();
}

FGame::~FGame()
{

}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" GETFILE FILE_NAME - to download file data from Title Storage;"
			L" TESTFILE FILE_NAME FILE_PATH - to test if data from Title Storage matches contents of file on disk;"
		};
		AppendHelpMessageLines(ExtraHelpMessageLines);

		Console->AddCommand(L"GETFILE", [](const std::vector<std::wstring>& Args)
		{
			if (Args.size() == 1)
			{
				if (FGame::Get().GetTitleStorage() && FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()))
				{
					FGame::Get().GetTitleStorage()->StartFileDataDownload(Args[0]);
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"GETFILE error: login to be able to interact with Title Storage.", Color::Red);
				}
			}
			else
			{
				FGame::Get().GetConsole()->AddLine(L"GETFILE error: file name is required.", Color::Red);
			}
		});

		Console->AddCommand(L"TESTFILE", [](const std::vector<std::wstring>& Args)
		{
			if (Args.size() == 2)
			{
				if (FGame::Get().GetTitleStorage() && FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser()))
				{
					bool NoLocalData = false;
					const std::wstring TSData = FGame::Get().GetTitleStorage()->GetLocalData(Args[0], NoLocalData);
					if (NoLocalData)
					{
						FGame::Get().GetConsole()->AddLine(L"TESTFILE error: no local data for file specified. File is missing in Title Storage or data is not downloaded yet (use download button or GETFILE command).", Color::Red);
					}
					else
					{
						//Load file data into memory
						std::wifstream FileStream(FStringUtils::Narrow(Args[1]), std::ios_base::binary | std::ios_base::in);

						if (FileStream.good())
						{
							std::wstring DataString((std::istreambuf_iterator<wchar_t>(FileStream)),
								std::istreambuf_iterator<wchar_t>());

							if (DataString == TSData)
							{
								FGame::Get().GetConsole()->AddLine(L"TESTFILE: files' data match!", Color::Green);
							}
							else
							{
								FGame::Get().GetConsole()->AddLine(L"TESTFILE: files' data is different!", Color::Red);
							}
						}
						else
						{
							FGame::Get().GetConsole()->AddLine(L"TESTFILE: could not open file specified as second parameter. Please provide full path.", Color::Red);
						}
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"TESTFILE error: login to be able to interact with Title Storage.", Color::Red);
				}
			}
			else
			{
				FGame::Get().GetConsole()->AddLine(L"TESTFILE error: data storage file name and full file path are required.", Color::Red);
			}
		});
	}
}

void FGame::Update()
{
	TitleStorage->Update();

	FBaseGame::Update();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	FBaseGame::OnGameEvent(Event);
	TitleStorage->OnGameEvent(Event);
}

std::unique_ptr<FTitleStorage> const& FGame::GetTitleStorage()
{
	return TitleStorage;
}
```

`EAC_SDK/Samples/TitleStorage/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FTitleStorage;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	 * Getter Title Storage component.
	 */
	const std::unique_ptr<FTitleStorage>& GetTitleStorage();

protected:
	/**
	 * Initialize and store console commands
	 */
	virtual void CreateConsoleCommands() override;

	/** Store component */
	std::unique_ptr<FTitleStorage> TitleStorage;
};


```

`EAC_SDK/Samples/TitleStorage/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/TitleStorage/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "TitleStorageDialog.h"
#include "TransferProgressDialog.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "TitleStorage.h"
#include "PopupDialog.h"

const Vector2 ConsoleDialogSizeProportion = Vector2(0.68f, 0.35f);

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	CreateTitleStorageDialog();
	CreateFileTransferDialog();
	
	FBaseMenu::Create();
}

void FMenu::Release()
{
	if (TitleStorageDialog)
	{
		TitleStorageDialog->Release();
		TitleStorageDialog.reset();
	}

	FBaseMenu::Release();
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * ConsoleDialogSizeProportion.x, WindowSize.y * ConsoleDialogSizeProportion.y);
		ConsoleDialog->SetSize(ConsoleWidgetSize);

		Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
		ConsoleDialog->SetPosition(ConsoleWidgetPos);

		if (TitleStorageDialog)
		{
			TitleStorageDialog->SetWindowSize(WindowSize);

			Vector2 TitleStorageDialogSize = Vector2(WindowSize.x - ConsoleDialog->GetSize().x - 30.f, WindowSize.y - 130.0f);
			TitleStorageDialog->SetSize(TitleStorageDialogSize);

			Vector2 TitleStorageDialogPos = Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
				WindowSize.y - TitleStorageDialogSize.y - 10.f);
			TitleStorageDialog->SetPosition(TitleStorageDialogPos);
		}
	}

	if (TransferDialog)
	{
		TransferDialog->SetPosition(Vector2((WindowSize.x / 2.f) - TransferDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - TransferDialog->GetSize().y));
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::CreateTitleStorageDialog()
{
	const float FX = 100.0f;
	const float FY = 100.0f;
	const float Width = 300.0f;
	const float Height = 300.0f;

	TitleStorageDialog = std::make_shared<FTitleStorageDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	TitleStorageDialog->SetWindowProportion(ConsoleDialogSizeProportion);
	TitleStorageDialog->SetBorderColor(Color::UIBorderGrey);
	
	TitleStorageDialog->Create();

	AddDialog(TitleStorageDialog);
}

void FMenu::CreateAuthDialogs()
{
	AuthDialogs = std::make_shared<FAuthDialogs>(
		TitleStorageDialog,
		L"Title Storage",
		BoldSmallFont->GetFont(),
		SmallFont->GetFont(),
		TinyFont->GetFont());

	AuthDialogs->SetUserLabelOffset(Vector2(-30.0f, -10.0f));
	AuthDialogs->Create();
	AuthDialogs->SetSingleUserOnly(true);
}

void FMenu::CreateFileTransferDialog()
{
	class FTitleStorageProgressDelegate : public FTransferProgressDialog::FDelegate
	{
		virtual void CancelTransfer() override
		{
			FGame::Get().GetTitleStorage()->CancelCurrentTransfer();
		}

		virtual const std::wstring& GetCurrentTransferName() override
		{
			return FGame::Get().GetTitleStorage()->GetCurrentTransferName();
		}

		virtual float GetCurrentTransferProgress() override
		{
			return FGame::Get().GetTitleStorage()->GetCurrentTransferProgress();
		}
	};

	std::shared_ptr<FTransferProgressDialog::FDelegate> TitleStorageProgressDelegate = std::make_shared<FTitleStorageProgressDelegate>();

	TransferDialog = std::make_shared<FTransferProgressDialog>(
		Vector2(200.f, 200.f),
		Vector2(330.f, 160.f),
		5,
		L"",
		NormalFont->GetFont(),
		SmallFont->GetFont(),
		TitleStorageProgressDelegate);

	TransferDialog->SetBorderColor(Color::UIBorderGrey);
	TransferDialog->Create();

	AddDialog(TransferDialog);

	HideDialog(TransferDialog);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		UpdateTitleStorage();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		UpdateTitleStorage();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		UpdateTitleStorage();
	}
	else if (Event.GetType() == EGameEventType::FileTransferStarted)
	{
		const std::wstring& TransferName = Event.GetFirstStr();
		if (TransferDialog)
		{
			TransferDialog->SetTransferName(TransferName);
			ShowDialog(TransferDialog);
		}
	}
	else if (Event.GetType() == EGameEventType::FileTransferFinished)
	{
		const std::wstring& TransferName = Event.GetFirstStr();
		if (TransferDialog)
		{
			if (TransferDialog->GetTransferName() == TransferName)
			{
				HideDialog(TransferDialog);
			}
		}
	}

	if (TitleStorageDialog) TitleStorageDialog->OnGameEvent(Event);

	FBaseMenu::OnGameEvent(Event);
}

void FMenu::UpdateTitleStorage()
{
	if (TitleStorageDialog)
	{
		TitleStorageDialog->SetPosition(Vector2(ConsoleDialog->GetPosition().x + ConsoleDialog->GetSize().x + 10.f,
			TitleStorageDialog->GetPosition().y));
	}
}
```

`EAC_SDK/Samples/TitleStorage/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FUIEvent;
class FConsole;
class FGameEvent;
class FFont;
class FConsoleDialog;
class FFriendsDialog;
class FExitDialog;
class FAuthDialogs;
class FSpriteWidget;
class FTextLabelWidget;
class FTitleStorageDialog;
class FTransferProgressDialog;
class FPopupDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> console) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMenu() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event) override;

private:

	/**
	 * Creates the player data storage dialog
	 */
	void CreateTitleStorageDialog();

	/**
	 * Creates the auth dialogs
	 */
	virtual void CreateAuthDialogs() override;

	/** 
	 * Creates the file transfer dialog
	 */
	void CreateFileTransferDialog();

	/**
	* Updates player data storage
	*/
	void UpdateTitleStorage();

	/** Player Data Storage Dialog */
	std::shared_ptr<FTitleStorageDialog> TitleStorageDialog;

	/** File transfer progress dialog */
	std::shared_ptr<FTransferProgressDialog> TransferDialog;
};

```

`EAC_SDK/Samples/TitleStorage/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry (Available for Epic Games Store) */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions (Available for Epic Games Store) */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Title Storage";

	/** Encryption key. It must match the one you are using on Dev Portal when uploading files. 64 hex characters. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";
};
```

`EAC_SDK/Samples/TitleStorage/Source/TitleStorage.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "AccountHelpers.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "TitleStorage.h"

const size_t MaxChunkSize = 4 * 4 * 4096;

FTitleStorage::FTitleStorage()
{
}

FTitleStorage::~FTitleStorage()
{

}

void FTitleStorage::QueryList()
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		return;
	}

	if (CurrentTags.empty())
	{
		FGameEvent PopupEvent(EGameEventType::ShowPopupDialog, L"Please enter at least one tag and press 'Add tag'.");
		FGame::Get().OnGameEvent(PopupEvent);
		return;
	}

	EOS_HTitleStorage TitleStorageHandle = EOS_Platform_GetTitleStorageInterface(FPlatform::GetPlatformHandle());
	EOS_TitleStorage_QueryFileListOptions Options = {};
	Options.ApiVersion = EOS_TITLESTORAGE_QUERYFILELIST_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	
	Options.ListOfTagsCount = int32_t(CurrentTags.size());
	std::vector<const char*> Tags;
	for (const std::string& NextTag : CurrentTags)
	{
		Tags.push_back(NextTag.c_str());
	}
	Options.ListOfTags = Tags.data();

	EOS_TitleStorage_QueryFileList(TitleStorageHandle, &Options, nullptr, OnFileListRetrieved);
}

void FTitleStorage::StartFileDataDownload(const std::wstring& FileName)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
	if (Player == nullptr || !Player->GetProductUserID().IsValid())
	{
		return;
	}

	//TODO: make sure we are not transferring the same file atm
	EOS_HTitleStorage TitleStorageHandle = EOS_Platform_GetTitleStorageInterface(FPlatform::GetPlatformHandle());
	EOS_TitleStorage_ReadFileOptions Options = {};
	Options.ApiVersion = EOS_TITLESTORAGE_READFILE_API_LATEST;
	Options.LocalUserId = Player->GetProductUserID();
	std::string NarrowFileName = FStringUtils::Narrow(FileName);
	Options.Filename = NarrowFileName.c_str();
	Options.ReadChunkLengthBytes = MaxChunkSize;

	Options.ReadFileDataCallback = OnFileDataReceived;
	Options.FileTransferProgressCallback = OnFileTransferProgressUpdated;

	EOS_HTitleStorageFileTransferRequest Handle = EOS_TitleStorage_ReadFile(TitleStorageHandle, &Options, nullptr, OnFileReceived);
	if (!Handle)
	{
		FDebugLog::LogError(L"[EOS SDK] Title storage: can't start file download, bad handle returned '%ls'", FileName.c_str());
		return;
	}

	CancelCurrentTransfer();
	CurrentTransferHandle = Handle;

	FTransferInProgress NewTransfer;
	NewTransfer.bDownload = true;
	
	//Total file size will be set on first update

	TransfersInProgress[FileName] = NewTransfer;

	CurrentTransferProgress = 0.0f;
	CurrentTransferName = FileName;

	//Show dialog
	FGameEvent GameEvent(EGameEventType::FileTransferStarted, CurrentTransferName);
	FGame::Get().OnGameEvent(GameEvent);
}

std::vector<std::wstring> FTitleStorage::GetFileList() const
{
	std::vector<std::wstring> Names;
	Names.reserve(StorageData.size());

	for (auto& Entry : StorageData)
	{
		Names.push_back(Entry.first);
	}

	return Names;
}

void FTitleStorage::SetFileList(const std::vector<std::wstring>& FileNames)
{

	for (const std::wstring& NextName : FileNames)
	{
		auto Iter = StorageData.find(NextName);
		if (Iter == StorageData.end())
		{
			//data will be retrieved when requested explicitly
			StorageData[NextName] = std::make_pair<bool, std::wstring>(false, L"");
		}
	}

	//we need to remove files that are gone
	if (StorageData.size() != FileNames.size())
	{
		std::unordered_map<std::wstring, std::pair<bool, std::wstring>> NewStorageData;

		for (const std::wstring& NextName : FileNames)
		{
			NewStorageData[NextName] = StorageData[NextName];
		}

		StorageData.swap(NewStorageData);
	}
}

std::wstring FTitleStorage::GetLocalData(const std::wstring& EntryName, bool& NoData) const
{
	auto Iter = StorageData.find(EntryName);
	if (Iter != StorageData.end())
	{
		NoData = !Iter->second.first;
		return Iter->second.second;
	}

	NoData = true;
	return L"";
}

void FTitleStorage::CancelCurrentTransfer()
{
	if (CurrentTransferHandle)
	{
		auto Result = EOS_TitleStorageFileTransferRequest_CancelRequest(CurrentTransferHandle);
		EOS_TitleStorageFileTransferRequest_Release(CurrentTransferHandle);
		CurrentTransferHandle = nullptr;

		if (Result == EOS_EResult::EOS_Success)
		{
			//canceled with success
			auto Iter = TransfersInProgress.find(CurrentTransferName);
			if (Iter != TransfersInProgress.end())
			{
				FTransferInProgress& Transfer = Iter->second;
				if (Transfer.bDownload)
				{
					//Download is canceled - do nothing
				}
				else
				{
					//Upload is canceled - do nothing
				}

				TransfersInProgress.erase(Iter);
			}

			//Hide dialog
			FGameEvent GameEvent(EGameEventType::FileTransferFinished, CurrentTransferName);
			FGame::Get().OnGameEvent(GameEvent);
		}
	}

	ClearCurrentTransfer();
}


EOS_TitleStorage_EReadResult FTitleStorage::ReceiveData(const std::wstring& FileName, const void* Data, size_t NumBytes, size_t TotalSize)
{
	if (!Data)
	{
		FDebugLog::LogError(L"[EOS SDK] Title storage: could not receive data: Data pointer is null.");
		return EOS_TitleStorage_EReadResult::EOS_TS_RR_FailRequest;
	}

	auto Iter = TransfersInProgress.find(FileName);
	if (Iter != TransfersInProgress.end())
	{
		FTransferInProgress& Transfer = Iter->second;

		if (!Transfer.bDownload)
		{
			FDebugLog::LogError(L"[EOS SDK] Title storage: can't load file data: download/upload mismatch.");
			return EOS_TitleStorage_EReadResult::EOS_TS_RR_FailRequest;
		}

		//First update
		if (Transfer.CurrentIndex == 0 && Transfer.TotalSize == 0)
		{
			Transfer.TotalSize = TotalSize;

			if (Transfer.TotalSize == 0)
			{
				return EOS_TitleStorage_EReadResult::EOS_TS_RR_ContinueReading;
			}

			Transfer.Data.resize(TotalSize);
		}

		//Make sure we have enough space
		if (Transfer.TotalSize - Transfer.CurrentIndex >= NumBytes)
		{
			memcpy(static_cast<void*>(&Transfer.Data[Transfer.CurrentIndex]), Data, NumBytes);
			Transfer.CurrentIndex += NumBytes;

			return EOS_TitleStorage_EReadResult::EOS_TS_RR_ContinueReading;
		}
		else
		{
			FDebugLog::LogError(L"[EOS SDK] Title storage: could not receive data: too much of it.");
			return EOS_TitleStorage_EReadResult::EOS_TS_RR_FailRequest;
		}
	}

	return EOS_TitleStorage_EReadResult::EOS_TS_RR_CancelRequest;
}

void FTitleStorage::UpdateProgress(const std::wstring& FileName, float Progress)
{
	// Make sure the update is for our primary (current) transfer.
	if (FileName == CurrentTransferName)
	{
		CurrentTransferProgress = Progress;
	}
}

void FTitleStorage::FinishFileDownload(const std::wstring& FileName, bool bSuccess)
{
	auto Iter = TransfersInProgress.find(FileName);
	if (Iter != TransfersInProgress.end())
	{
		FTransferInProgress& Transfer = Iter->second;

		if (!Transfer.bDownload)
		{
			FDebugLog::LogError(L"[EOS SDK] Title storage: error while file read operation: can't finish because of download/upload mismatch.");
			return;
		}

		if (!Transfer.Done() || !bSuccess)
		{
			if (!Transfer.Done())
			{
				FDebugLog::LogError(L"[EOS SDK] Title storage: error while file read operation: expecting more data. File can be corrupted.");
			}
			TransfersInProgress.erase(Iter);
			if (FileName == CurrentTransferName)
			{
				ClearCurrentTransfer();
			}
			return;
		}

		std::string NarrowFileData;
		//Don't try to show files larger than 5 Mb (it will cause UI performance issues)
		if (Transfer.TotalSize > 5 * 1024 * 1024)
		{
			NarrowFileData = "*** File is too large to be viewed in this sample. ***";
		}
		else
		{
			NarrowFileData = (Transfer.TotalSize > 0) ? std::string(&Transfer.Data[0], Transfer.TotalSize) : std::string();
		}

		std::wstring WideFileData;
		//Data can be binary or corrupted.
		try
		{
			WideFileData = FStringUtils::Widen(NarrowFileData);
		}
		catch (...)
		{
			WideFileData = L"*** File data contains binary data that can't be viewed. ***";
		}
		StorageData[FileName] = std::make_pair<bool, std::wstring>(true, std::move(WideFileData));

		FDebugLog::Log(L"[EOS SDK] Title storage: file read finished: '%ls' Size: %d.", FileName.c_str(), NarrowFileData.size());

		TransfersInProgress.erase(Iter);

		FGameEvent GameEvent(EGameEventType::FileTransferFinished, CurrentTransferName);
		FGame::Get().OnGameEvent(GameEvent);

		if (FileName == CurrentTransferName)
		{
			ClearCurrentTransfer();
		}
	}
}

void FTitleStorage::Update()
{

}

void FTitleStorage::OnLoggedIn(FProductUserId UserId)
{

}

void FTitleStorage::OnLoggedOut(FProductUserId UserId)
{
	StorageData.clear();
	ClearCurrentTransfer();
}

void FTitleStorage::ClearCurrentTransfer()
{
	CurrentTransferName.clear();
	CurrentTransferProgress = 0.0f;

	if (CurrentTransferHandle)
	{
		EOS_TitleStorageFileTransferRequest_Release(CurrentTransferHandle);
		CurrentTransferHandle = nullptr;
	}
}

void FTitleStorage::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		FProductUserId UserId = Event.GetProductUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserConnectAuthExpiration)
	{
		FProductUserId UserId = Event.GetProductUserId();
		OnLoggedOut(UserId);
	}
}


void EOS_CALL FTitleStorage::OnFileListRetrieved(const EOS_TitleStorage_QueryFileListCallbackInfo* Data)
{
	if (Data)
	{
		if (Data->ResultCode == EOS_EResult::EOS_Success)
		{
			PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
			if (Player == nullptr || !Player->GetProductUserID().IsValid())
			{
				return;
			}

			FDebugLog::Log(L"[EOS SDK] Title storage file list is successfully retrieved.");

			const size_t FileCount = Data->FileCount;
			std::vector<std::wstring> FileNames;
			EOS_HTitleStorage TitleStorageHandle = EOS_Platform_GetTitleStorageInterface(FPlatform::GetPlatformHandle());
			for (size_t FileIndex = 0; FileIndex < FileCount; ++FileIndex)
			{
				EOS_TitleStorage_CopyFileMetadataAtIndexOptions Options = {};
				Options.ApiVersion = EOS_TITLESTORAGE_COPYFILEMETADATAATINDEX_API_LATEST;

				Options.LocalUserId = Player->GetProductUserID();
				Options.Index = static_cast<uint32_t>(FileIndex);

				EOS_TitleStorage_FileMetadata* FileMetadata = nullptr;

				EOS_TitleStorage_CopyFileMetadataAtIndex(TitleStorageHandle, &Options, &FileMetadata);

				if (FileMetadata)
				{
					if (FileMetadata->Filename)
					{
						std::wstring FileName = FStringUtils::Widen(FileMetadata->Filename);

						FileNames.push_back(FileName);
					}

					EOS_TitleStorage_FileMetadata_Release(FileMetadata);
				}
			}

			FGame::Get().GetTitleStorage()->SetFileList(FileNames);
		}
		else
		{
			FDebugLog::LogError(L"[EOS SDK] Title storage: file list retrieval error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
	}
}



EOS_TitleStorage_EReadResult EOS_CALL FTitleStorage::OnFileDataReceived(const EOS_TitleStorage_ReadFileDataCallbackInfo* Data)
{
	if (Data)
	{
		return FGame::Get().GetTitleStorage()->ReceiveData(FStringUtils::Widen(Data->Filename), Data->DataChunk, Data->DataChunkLengthBytes, Data->TotalFileSizeBytes);
	}
	return EOS_TitleStorage_EReadResult::EOS_TS_RR_FailRequest;
}

void EOS_CALL FTitleStorage::OnFileReceived(const EOS_TitleStorage_ReadFileCallbackInfo* Data)
{
	if (Data)
	{
		if (Data->ResultCode == EOS_EResult::EOS_Success)
		{
			FGame::Get().GetTitleStorage()->FinishFileDownload(FStringUtils::Widen(Data->Filename), true);
		}
		else
		{
			FDebugLog::LogError(L"[EOS SDK] Title storage: could not download file: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
			FGame::Get().GetTitleStorage()->FinishFileDownload(FStringUtils::Widen(Data->Filename), false);
		}
	}
}


void EOS_CALL FTitleStorage::OnFileTransferProgressUpdated(const EOS_TitleStorage_FileTransferProgressCallbackInfo* Data)
{
	if (Data)
	{
		if (Data->TotalFileSizeBytes > 0)
		{
			FGame::Get().GetTitleStorage()->UpdateProgress(FStringUtils::Widen(Data->Filename), float(Data->BytesTransferred) / Data->TotalFileSizeBytes);
			FDebugLog::Log(L"[EOS SDK] Title storage: transfer progress %d / %d.", Data->BytesTransferred, Data->TotalFileSizeBytes);
		}
	}
}

```

`EAC_SDK/Samples/TitleStorage/Source/TitleStorage.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <eos_sdk.h>
#include <eos_titlestorage_types.h>
#include <eos_titlestorage.h>

/**
* Manages player data storage for local user
*/
class FTitleStorage
{
public:
	/**
	* Constructor
	*/
	FTitleStorage() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FTitleStorage(FTitleStorage const&) = delete;
	FTitleStorage& operator=(FTitleStorage const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FTitleStorage();

	void Update();

	/** 
	* Remote operations follow. They trigger online requests to the backend services.
	*/

	/**
	* Refresh list of player data entries. Asynchronous operation. Takes currently selected tags into account.
	*/
	void QueryList();

	/**
	* Retrieve contents of specific file
	*/
	void StartFileDataDownload(const std::wstring& FileName);

	/** 
	* Cancel current file transfer (if any).
	*/
	void CancelCurrentTransfer();


	/** 
	* Functions that work with local data follow. These functions do not trigger any online queries but work with local data instead.
	*/

	/** 
	* Returns locally cached list of files.
	*/
	std::vector<std::wstring> GetFileList() const;

	/**
	* Sets local list of files.
	*/
	void SetFileList(const std::vector<std::wstring>& FileNames);

	/** 
	* Returns locally cached data for file specified. NoData flag is set to true when there is no data available locally.
	*/
	std::wstring GetLocalData(const std::wstring& EntryName, bool& NoData) const;

	/** 
	* Gets the name of file that is being transferred at the moment.
	*/
	const std::wstring& GetCurrentTransferName() const { return CurrentTransferName; }

	/** 
	* Gets current progress of the file transfer (in the range [0.0f, 1.0f]).
	*/
	float GetCurrentTransferProgress() const { return CurrentTransferProgress; }

	/**
	* Add one more tag to currently selected tags.
	*/
	void AddTag(const std::string& NewTag) { CurrentTags.insert(NewTag); }

	/** 
	* Clear all currently selected tags
	*/
	void ClearTags() { CurrentTags.clear(); }

	/** 
	* Get the list of currently selected tags.
	*/
	const std::set<std::string>& GetCurrentTags() const { return CurrentTags; }

	//Called on async operations progress
	EOS_TitleStorage_EReadResult ReceiveData(const std::wstring& FileName, const void* Data, size_t NumBytes, size_t TotalSize);
	void UpdateProgress(const std::wstring& FileName, float Progress);
	void FinishFileDownload(const std::wstring& FileName, bool bSuccess);

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/**
	* Callback that is fired when the query file list async operation completes, either successfully or in error
	*
	* @param Data - Output parameters for the EOS_TitleStorage_QueryFileList Function
	*/
	static void EOS_CALL OnFileListRetrieved(const EOS_TitleStorage_QueryFileListCallbackInfo* Data);

	/**
	* Callback that is fired when file data is received.
	*
	* @param Data - Output parameters for the  Function
	*/
	static EOS_TitleStorage_EReadResult EOS_CALL OnFileDataReceived(const EOS_TitleStorage_ReadFileDataCallbackInfo* Data);

	/**
	* Callback that is fired when file transfer from cloud is completed.
	*
	* @param Data - Output parameters
	*/
	static void EOS_CALL OnFileReceived(const EOS_TitleStorage_ReadFileCallbackInfo* Data);

	/**
	* Callback that is fired when we get information about transfer progress
	*
	* @param Data - file transfer progress
	*/
	static void EOS_CALL OnFileTransferProgressUpdated(const EOS_TitleStorage_FileTransferProgressCallbackInfo* Data);

private:

	/**
	* Called when a user has logged in
	*/
	void OnLoggedIn(FProductUserId UserId);

	/**
	* Called when a user has logged out
	*/
	void OnLoggedOut(FProductUserId UserId);

	void ClearCurrentTransfer();

	// The name of file we are currently downloading or uploading
	std::wstring CurrentTransferName;

	//Current primary active transfer (upload or download).
	EOS_HTitleStorageFileTransferRequest CurrentTransferHandle = nullptr;

	// The progress we made so far while transmitting file.
	float CurrentTransferProgress;

	/** Map of player data entries. Key - entry name, Value - pair (bool: is data present locally ; string: entry data). */
	std::unordered_map<std::wstring, std::pair<bool, std::wstring>> StorageData;

	struct FTransferInProgress
	{
		bool bDownload = true;
		size_t TotalSize = 0;
		size_t CurrentIndex = 0;
		std::vector<char> Data;

		bool Done() const { return TotalSize == CurrentIndex; }
	};

	std::unordered_map <std::wstring, FTransferInProgress> TransfersInProgress;
	std::set<std::string> CurrentTags;
};

```

`EAC_SDK/Samples/TitleStorage/Source/TitleStorageDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "TitleStorageDialog.h"
#include "TextEditor.h"
#include "TextField.h"
#include "TitleStorage.h"

template<>
std::shared_ptr<FTitleStorageInfo> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& Data)
{
	return std::make_shared<FTitleStorageInfo>(Pos, Size, Layer, Data, L"Assets/black_grey_button.dds");
}

const Vector2 FileEditorPosition = Vector2(10.0f, 120.0f);

FTitleStorageDialog::FTitleStorageDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	HeaderLabel = std::make_shared<FTextLabelWidget>(
		FileEditorPosition,
		Vector2(500.0f, 20.0f),
		Layer - 1,
		std::wstring(L"Title Storage: "),
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	HeaderLabel->SetFont(DialogNormalFont);

	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/texteditor.dds");

	TextEditorLabel = std::make_shared<FTextLabelWidget>(
		FileEditorPosition,
		Vector2(500.0f, 20.0f),
		Layer - 1,
		L"FILE",
		L"Assets/wide_label.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left
		);
	TextEditorLabel->SetFont(DialogSmallFont);
	TextEditorLabel->SetBorderColor(Color::UIBorderGrey);

	TextEditor = std::make_shared<FTextEditorWidget>(
		FileEditorPosition + Vector2(0.0f, 20.0f),
		Vector2(500.0f, 500.0f),
		DialogLayer - 1,
		L"",
		L"Assets/texteditor.dds",
		DialogNormalFont
		);
	TextEditor->SetBorderOffsets(Vector2(10.0f, 10.0f));
	TextEditor->SetBorderColor(Color::UIBorderGrey);
	TextEditor->SetEditingEnabled(false);
	TextEditor->SetCanSelectText(true);

	Vector2 ButtonSize((DialogSize.x - 15.0f) / 4.0f, 35.0f);
	Vector2 ButtonVerticalOffset(0.0f, 37.0f);
	Vector2 ButtonHorizontalOffset(ButtonSize.x + 4.0f, 0.0f);

	FileNameTextField = std::make_shared<FTextFieldWidget>(
		DialogPos - ButtonVerticalOffset,
		Vector2(ButtonSize.x * 3.0f, ButtonSize.y),
		DialogLayer - 1,
		L"Enter file name...",
		L"Assets/textfield.dds",
		DialogSmallFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
		);
	FileNameTextField->SetOnEnterPressedCallback([this](const std::wstring& SearchString)
	{
		if (!SearchString.empty())
		{
			CurrentSelection = SearchString;
			FGame::Get().GetTitleStorage()->StartFileDataDownload(SearchString);
		}
		FileNameTextField->Clear();
	});

	DownloadFileButton = std::make_shared<FButtonWidget>(
		DialogPos - ButtonVerticalOffset + ButtonHorizontalOffset * 3.0f,
		ButtonSize,
		DialogLayer - 1,
		L"DOWNLOAD",
		assets::LargeButtonAssets,
		DialogTinyFont,
		Color::White,
		Color::White
		);
	DownloadFileButton->SetOnPressedCallback([this]()
	{
		//get selected file name
		std::wstring CurrentSelectionFileName = GetCurrentSelection();

		//check if text field has a value
		if (FileNameTextField)
		{
			const std::wstring& TextFieldValue = FileNameTextField->GetText();
			if (!TextFieldValue.empty() && TextFieldValue != FileNameTextField->GetInitialText())
			{
				CurrentSelectionFileName = TextFieldValue;
				FileNameTextField->Clear();
			}
		}

		if (!CurrentSelectionFileName.empty())
		{
			//send download request
			FGame::Get().GetTitleStorage()->StartFileDataDownload(CurrentSelectionFileName);
		}
	});
	DownloadFileButton->SetBackgroundColors(assets::DefaultButtonColors);

	TitleDataList = std::make_shared<FTitleDataList>(
		DialogPos,
		DialogSize,
		DialogLayer - 1,
		20.0f, //entry height
		15.0f, //label height
		15.0f, //scroller width
		L"", //background
		L"Files:",
		DialogNormalFont,
		DialogNormalFont,
		DialogSmallFont,
		DialogTinyFont);

	TagNameTextField = std::make_shared<FTextFieldWidget>(
		FileNameTextField->GetPosition() + ButtonVerticalOffset,
		Vector2(ButtonSize.x * 3.0f, ButtonSize.y),
		DialogLayer - 1,
		L"Enter tag name...",
		L"Assets/textfield.dds",
		DialogSmallFont,
		FTextFieldWidget::EInputType::Normal,
		EAlignmentType::Left,
		FColor(0.5f, 0.5f, 0.5f, 1.f)
		);
	TagNameTextField->SetOnEnterPressedCallback([this](const std::wstring& TagString)
	{
		if (!TagString.empty())
		{
			FGame::Get().GetTitleStorage()->AddTag(FStringUtils::Narrow(TagString));
		}
		TagNameTextField->Clear();
	});

	AddTagButton = std::make_shared<FButtonWidget>(
		DownloadFileButton->GetPosition() + ButtonVerticalOffset + ButtonHorizontalOffset * 3.0f,
		ButtonSize,
		DialogLayer - 1,
		L"ADD TAG",
		assets::LargeButtonAssets,
		DialogTinyFont,
		Color::White,
		Color::White
		);
	AddTagButton->SetOnPressedCallback([this]()
	{
		//check if text field has a value
		if (TagNameTextField)
		{
			const std::wstring& TextFieldValue = TagNameTextField->GetText();
			if (!TextFieldValue.empty() && TextFieldValue != TagNameTextField->GetInitialText())
			{
				TagNameTextField->Clear();

				FGame::Get().GetTitleStorage()->AddTag(FStringUtils::Narrow(TextFieldValue));
			}
		}
	});
	AddTagButton->SetBackgroundColors(assets::DefaultButtonColors);

	TagList = std::make_shared<FTitleTagList>(
		TagNameTextField->GetPosition() + ButtonVerticalOffset,
		DialogSize,
		DialogLayer - 1,
		20.0f, //entry height
		15.0f, //label height
		15.0f, //scroller width
		L"", //background
		L"Tags:",
		DialogNormalFont,
		DialogNormalFont,
		DialogSmallFont,
		DialogTinyFont);

	QueryListButton = std::make_shared<FButtonWidget>(
		TagList->GetPosition() + Vector2(0.0f, TagList->GetSize().y),
		ButtonSize,
		DialogLayer - 1,
		L"QUERY LIST",
		assets::LargeButtonAssets,
		DialogTinyFont,
		Color::White,
		Color::White
		);
	QueryListButton->SetOnPressedCallback([]()
	{
		//send refresh request
		FGame::Get().GetTitleStorage()->QueryList();
	});
	QueryListButton->SetBackgroundColors(assets::DefaultButtonColors);

	ClearTagsButton = std::make_shared<FButtonWidget>(
		QueryListButton->GetPosition() + ButtonHorizontalOffset,
		ButtonSize,
		DialogLayer - 1,
		L"CLEAR TAGS",
		assets::LargeButtonAssets,
		DialogTinyFont,
		Color::White,
		Color::White
		);
	ClearTagsButton->SetOnPressedCallback([this]()
	{
		FGame::Get().GetTitleStorage()->ClearTags();
		TagList->Reset();
	});
	ClearTagsButton->SetBackgroundColors(assets::DefaultButtonColors);
}

void FTitleStorageDialog::Update()
{
	NameList = FGame::Get().GetTitleStorage()->GetFileList();
	std::set<std::string> TagSet = FGame::Get().GetTitleStorage()->GetCurrentTags();
	Tags.clear();
	for (const std::string& Tag : TagSet)
	{
		Tags.push_back(FStringUtils::Widen(Tag));
	}

	if (TitleDataList)
	{
		TitleDataList->RefreshData(NameList);
	}

	if (TagList)
	{
		TagList->RefreshData(Tags);
	}

	FDialog::Update();

	if (TitleDataList)
	{
		TitleDataList->Update();
	}

	if (TagList)
	{
		TagList->Update();
	}
}

void FTitleStorageDialog::Create()
{
	if (HeaderLabel) HeaderLabel->Create();
	if (BackgroundImage) BackgroundImage->Create();
	if (TitleDataList) TitleDataList->Create();
	if (TextEditorLabel) TextEditorLabel->Create();
	if (TextEditor)	TextEditor->Create();

	//make entries invisible until player logs in
	if (TitleDataList)
	{
		TitleDataList->SetEntriesVisible(false);
		TitleDataList->SetOnEntrySelectedCallback([this](size_t Index) { this->OnDataStorageEntrySelected(Index); });
	}

	if (QueryListButton) QueryListButton->Create();
	if (DownloadFileButton) DownloadFileButton->Create();
	if (FileNameTextField) FileNameTextField->Create();

	if (AddTagButton) AddTagButton->Create();
	if (TagNameTextField) TagNameTextField->Create();
	if (ClearTagsButton) ClearTagsButton->Create();

	if (TagList) TagList->Create();

	if (TagList)
	{
		TagList->SetEntriesVisible(false);
	}

	AddWidget(HeaderLabel);
	AddWidget(BackgroundImage);
	AddWidget(TitleDataList);
	AddWidget(TextEditorLabel);
	AddWidget(TextEditor);

	AddWidget(QueryListButton);
	AddWidget(FileNameTextField);
	AddWidget(DownloadFileButton);

	AddWidget(AddTagButton);
	AddWidget(TagNameTextField);
	AddWidget(ClearTagsButton);
	AddWidget(TagList);

	HideWidgets();
}

void FTitleStorageDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (HeaderLabel) HeaderLabel->SetPosition(Pos);
	if (BackgroundImage) BackgroundImage->SetPosition(Vector2(Position.x, Position.y + 20.f));
	if (TextEditorLabel) TextEditorLabel->SetPosition(Vector2(FileEditorPosition.x, FileEditorPosition.y));
	if (TextEditor) TextEditor->SetPosition(Vector2(FileEditorPosition.x, FileEditorPosition.y + TextEditorLabel->GetSize().y));

	Vector2 ButtonSize((GetSize().x - 12) / 4.0f, 35.0f);
	Vector2 ButtonVerticalOffset(0.0f, 37.0f);
	Vector2 InitialButtonHorizOffset(2.0f, 0.0f);
	Vector2 ButtonHorizontalOffset(ButtonSize.x + 1.0f, 0.0f);

	Vector2 CurrentButtonPos = Pos + ButtonVerticalOffset + InitialButtonHorizOffset;

	if (FileNameTextField) FileNameTextField->SetPosition(CurrentButtonPos);
	CurrentButtonPos += (ButtonHorizontalOffset * 3.0f);
	if (DownloadFileButton) DownloadFileButton->SetPosition(CurrentButtonPos);
	CurrentButtonPos -= (ButtonHorizontalOffset * 3.0f);
	CurrentButtonPos += ButtonVerticalOffset;
	if (TagNameTextField) TagNameTextField->SetPosition(CurrentButtonPos);
	
	CurrentButtonPos += (ButtonHorizontalOffset * 3.0f);
	if (AddTagButton) AddTagButton->SetPosition(CurrentButtonPos);

	CurrentButtonPos -= (ButtonHorizontalOffset * 3.0f);
	CurrentButtonPos += ButtonVerticalOffset;
	if (TagList) TagList->SetPosition(CurrentButtonPos);
	CurrentButtonPos += Vector2(0.0f, TagList->GetSize().y + 30.0f);

	if (QueryListButton) QueryListButton->SetPosition(CurrentButtonPos);

	CurrentButtonPos += ButtonHorizontalOffset;
	if (ClearTagsButton) ClearTagsButton->SetPosition(CurrentButtonPos);

	CurrentButtonPos -= ButtonHorizontalOffset;
	CurrentButtonPos += ButtonVerticalOffset;

	if (TitleDataList) TitleDataList->SetPosition(CurrentButtonPos);
}

void FTitleStorageDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	Vector2 ButtonSize((GetSize().x - 12) / 4.0f, 35.0f);
	if (DownloadFileButton) DownloadFileButton->SetSize(ButtonSize);
	if (FileNameTextField) FileNameTextField->SetSize(Vector2(ButtonSize.x * 3.0f, ButtonSize.y));
	if (TagNameTextField) TagNameTextField->SetSize(Vector2(ButtonSize.x * 3.0f, ButtonSize.y));
	if (AddTagButton) AddTagButton->SetSize(ButtonSize);
	if (TagList) TagList->SetSize(Vector2(GetSize().x, 100.f));
	if (QueryListButton) QueryListButton->SetSize(ButtonSize);
	if (ClearTagsButton) ClearTagsButton->SetSize(ButtonSize);
	if (TitleDataList)TitleDataList->SetSize(Vector2(NewSize.x, NewSize.y - (TitleDataList->GetPosition().y - Position.y) - 100.0f));
}

void FTitleStorageDialog::SetWindowSize(Vector2 WindowSize)
{
	const Vector2 DialogSize = Vector2(WindowSize.x * (1.0f - ConsoleWindowProportion.x) - 30.0f, WindowSize.y - 90.0f);

	if (TextEditorLabel) TextEditorLabel->SetSize(Vector2(ConsoleWindowProportion.x * WindowSize.x, 20.0f));
	if (TextEditor) TextEditor->SetSize(Vector2(ConsoleWindowProportion.x * WindowSize.x, (1.0f - ConsoleWindowProportion.y) * WindowSize.y - FileEditorPosition.y - 50.0f));
	if (BackgroundImage) BackgroundImage->SetSize(DialogSize);
	if (HeaderLabel) HeaderLabel->SetSize(Vector2(DialogSize.x, 20.0f));
}

void FTitleStorageDialog::UpdateUserInfo()
{
	if (HeaderLabel)
	{
		HeaderLabel->SetText(L"Title Storage: log in to proceed.");
		if (FPlayerManager::Get().GetCurrentUser().IsValid())
		{
			std::wstring DisplayName = FPlayerManager::Get().GetDisplayName(FPlayerManager::Get().GetCurrentUser());
			HeaderLabel->SetText(std::wstring(L"Title Storage: ") + DisplayName);
		}
	}
}

void FTitleStorageDialog::ClearDataLists()
{
	TitleDataList->Reset();
	TextEditor->Clear();

	TagList->Reset();
}

void FTitleStorageDialog::ShowDataLists()
{
	TitleDataList->SetEntriesVisible(true);
	TagList->SetEntriesVisible(true);
}

void FTitleStorageDialog::HideDataLists()
{
	TitleDataList->SetEntriesVisible(false);
	TagList->SetEntriesVisible(false);
	SetFocused(false);
}

void FTitleStorageDialog::ShowWidgets()
{
	ShowDataLists();

	TitleDataList->Show();
	TagList->Show();

	FileNameTextField->Show();
	QueryListButton->Show();
	DownloadFileButton->Show();
	TagNameTextField->Show();
	AddTagButton->Show();
	ClearTagsButton->Show();
}

void FTitleStorageDialog::HideWidgets()
{
	HideDataLists();

	TitleDataList->Hide();
	TagList->Hide();

	FileNameTextField->Hide();
	QueryListButton->Hide();
	DownloadFileButton->Hide();
	TagNameTextField->Hide();
	AddTagButton->Hide();
	ClearTagsButton->Hide();
}

void FTitleStorageDialog::OnDataStorageEntrySelected(size_t Index)
{
	if (Index >= NameList.size())
		return;

	std::wstring Name = NameList[Index];

	TextEditor->Clear();

	CurrentSelection = Name;

	bool NoData = false;
	std::wstring Data = FGame::Get().GetTitleStorage()->GetLocalData(Name, NoData);

	if (!NoData)
	{
		TextEditor->SetText(Data);
	}
	else
	{
		TextEditor->SetText(L"* No local data available for the file selected.\n   Please press 'DOWNLOAD' to get data from the cloud. *");
	}
	TextEditor->SetEditingEnabled(false);

	FileNameTextField->SetText(CurrentSelection);
}

std::wstring FTitleStorageDialog::GetEditorContents() const
{
	if (TextEditor)
	{
		return TextEditor->GetText();
	}

	return std::wstring();
}

void FTitleStorageDialog::ClearCurrentSelection()
{
	CurrentSelection.clear();
	if (TitleDataList)
	{
		TitleDataList->SetFocused(false);
	}
	if (TextEditor)
	{
		TextEditor->Clear();
	}
}

void FTitleStorageDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		UpdateUserInfo();
		ShowWidgets();
	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		UpdateUserInfo();
		HideWidgets();
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		UpdateUserInfo();
		HideWidgets();
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		UpdateUserInfo();
		if (FPlayerManager::Get().GetNumPlayers() == 0)
		{
			ClearDataLists();
			HideWidgets();
		}
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		ClearDataLists();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		ClearDataLists();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		UpdateUserInfo();
		ClearDataLists();
		HideWidgets();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		ShowDataLists();
		UpdateUserInfo();
	}
	else if (Event.GetType() == EGameEventType::FileTransferFinished)
	{
		const std::wstring& FileName = Event.GetFirstStr();
		if (FileName == CurrentSelection && TextEditor)
		{
			bool NoData = false;
			std::wstring Data = FGame::Get().GetTitleStorage()->GetLocalData(FileName, NoData);
			TextEditor->Clear();
			TextEditor->SetText(Data);
		}
	}
}

void FTitleStorageInfo::SetFocused(bool bValue)
{
	if (BackgroundImage && bValue != IsFocused())
	{
		FColor CurrentColor = BackgroundImage->GetBackgroundColor();

		const float Diff = 0.3f;
		FColor Adjustment = (bValue) ? FColor(Diff, Diff, Diff, Diff) : FColor(-Diff, -Diff, -Diff, 0.0f);

		CurrentColor.A += Adjustment.A;
		CurrentColor.R += Adjustment.R;
		CurrentColor.G += Adjustment.G;
		CurrentColor.B += Adjustment.B;

		BackgroundImage->SetBackgroundColor(CurrentColor);
	}

	FTextLabelWidget::SetFocused(bValue);
}

```

`EAC_SDK/Samples/TitleStorage/Source/TitleStorageDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "ListView.h"
#include  "StringViewListEntry.h"

class FTitleStorageInfo : public FTextLabelWidget
{
public:
	FTitleStorageInfo(Vector2 LabelPos,
		Vector2 LabelSize,
		UILayer LabelLayer,
		const std::wstring& LabelText,
		const std::wstring& LabelAssetFile) : FTextLabelWidget(LabelPos, LabelSize, LabelLayer, LabelText, LabelAssetFile, Color::White)
	{}

	void SetFocused(bool bValue) override;
};

template<>
std::shared_ptr<FTitleStorageInfo> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& Data);

using FTitleDataList = FListViewWidget<std::wstring, FTitleStorageInfo>;
using FTitleTagList = FListViewWidget<std::wstring, FStringViewListEntry>;

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;
class FTextEditorWidget;
class FTextField;

/**
 * Title Storage dialog
 */
class FTitleStorageDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FTitleStorageDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FTitleStorageDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	void SetWindowSize(Vector2 WindowSize);
	void SetWindowProportion(Vector2 InWindowProportion) { ConsoleWindowProportion = InWindowProportion; }
	void UpdateUserInfo();
	void ClearDataLists();
	void ShowDataLists();
	void HideDataLists();
	void ShowWidgets();
	void HideWidgets();

	void OnDataStorageEntrySelected(size_t Index);
	const std::wstring& GetCurrentSelection() const { return CurrentSelection; }
	std::wstring GetEditorContents() const;
	void ClearCurrentSelection();

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

private:
	/** Header label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** List of title storage data entries */
	std::shared_ptr<FTitleDataList> TitleDataList;

	/** File editor label */
	std::shared_ptr<FTextLabelWidget> TextEditorLabel;

	/** Text Editor to view data in title storage */
	std::shared_ptr<FTextEditorWidget> TextEditor;

	/** List of entries */
	std::vector<std::wstring> NameList;

	/** List of currently selected tags */
	std::vector<std::wstring> Tags;

	/** Text field to enter file name */
	std::shared_ptr<FTextFieldWidget> FileNameTextField;

	/** Button to query list of file using tags */
	std::shared_ptr<FButtonWidget> QueryListButton;

	/** Button to download file */
	std::shared_ptr<FButtonWidget> DownloadFileButton;

	/** Text field to enter tag name */
	std::shared_ptr<FTextFieldWidget> TagNameTextField;

	/** Button to add tag */
	std::shared_ptr<FButtonWidget> AddTagButton;

	/** Button to clear tag list */
	std::shared_ptr<FButtonWidget> ClearTagsButton;

	/** List of title storage tags that are currently selected. */
	std::shared_ptr<FTitleTagList> TagList;

	/** Currently selected entry */
	std::wstring CurrentSelection;

	/** Part of window that console is taking */
	Vector2 ConsoleWindowProportion;
};

```

`EAC_SDK/Samples/TitleStorage/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/TitleStorage/TitleStorage.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>TitleStorage</RootNamespace>
    <ProjectGuid>{A895A0FB-3F92-4C2A-9ED7-A2C27DB9028F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>TitleStorage</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/TitleStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/TitleStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/TitleStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/TitleStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/TitleStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/TitleStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/TitleStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>$(EOSSDKSamplesRoot)/TitleStorage/Source;$(EOSSDKSamplesRoot)/Shared/Source;$(EOSSDKSamplesRoot)/Shared/Source/Main;$(EOSSDKSamplesRoot)/Shared/Source/Core;$(EOSSDKSamplesRoot)/Shared/Source/Graphics;$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;$(EOSSDKSamplesRoot)/Shared/Source/Input;$(EOSSDKSamplesRoot)/Shared/Source/Utils;$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(EOSSDKLibs);$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q $(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q $(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_TitleStorage.h" />
    <ClInclude Include="..\..\SDK\Include\eos_TitleStorage_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TransferProgressDialog.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\Shared\Source\pch.h" />
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\TitleStorage.h" />
    <ClInclude Include="Source\TitleStorageDialog.h" />
    <ClInclude Include="Source\SampleConstants.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TransferProgressDialog.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\TitleStorage.cpp" />
    <ClCompile Include="Source\TitleStorageDialog.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\Shared\Assets\addbutton.dds" />
    <Image Include="..\Shared\Assets\button.dds" />
    <Image Include="..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\Shared\Assets\console.dds" />
    <Image Include="..\Shared\Assets\friendback.dds" />
    <Image Include="..\Shared\Assets\friends.dds" />
    <Image Include="..\Shared\Assets\Logo.dds" />
    <Image Include="..\Shared\Assets\menu_background.dds" />
    <Image Include="..\Shared\Assets\nobutton.dds" />
    <Image Include="..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\Shared\Assets\search.dds" />
    <Image Include="..\Shared\Assets\solid_white.dds" />
    <Image Include="..\Shared\Assets\textfield.dds" />
    <Image Include="..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/TitleStorage/TitleStorage.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_titlestorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_titlestorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
	<ClInclude Include="..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="Source\TitleStorageDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\TransferProgressDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="Source\TitleStorage.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
	<ClCompile Include="..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="Source\TitleStorageDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\TransferProgressDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="Source\TitleStorage.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/TitleStorage/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/Voice/Client/CopyAssetsToBuilds.bat`:

```bat
xcopy /D /Y /R ..\..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R ..\..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_DX\
xcopy /D /Y /R ..\..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R ..\..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_DX\
xcopy /D /Y /R /Q ..\..\Shared\External\curl\Lib\Win32\Release\libcurl.dll .\Bin\Win32\Debug_DX\
xcopy /D /Y /R /Q ..\..\Shared\External\curl\Lib\Win32\Release\libcurl.dll .\Bin\Win32\Release_DX\
xcopy /D /Y /R /Q ..\..\Shared\External\curl\Lib\Win64\Release\libcurl.dll .\Bin\Win64\Debug_DX\
xcopy /D /Y /R /Q ..\..\Shared\External\curl\Lib\Win64\Release\libcurl.dll .\Bin\Win64\Release_DX\
pause
```

`EAC_SDK/Samples/Voice/Client/CopyAssetsToBuilds.sh`:

```sh
#!/bin/sh
mkdir Build/
mkdir Build/Assets/
cp ../../Shared/Assets/*.* Build/Assets/
```

`EAC_SDK/Samples/Voice/Client/CopyAssetsToBuildsSDL.bat`:

```bat
xcopy /D /Y /R /Q ..\..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\..\SDK\Bin\EOSSDK-Win64-Shipping.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\..\SDK\Bin\EOSSDK-Win32-Shipping.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x86\Release\SDL2.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x64\Release\SDL2.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll .\Bin\Win64\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\curl\Lib\Win32\Release\libcurl.dll .\Bin\Win32\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\curl\Lib\Win32\Release\libcurl.dll .\Bin\Win32\Release_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\curl\Lib\Win64\Release\libcurl.dll .\Bin\Win64\Debug_SDL\
xcopy /D /Y /R /Q ..\..\Shared\External\curl\Lib\Win64\Release\libcurl.dll .\Bin\Win64\Release_SDL\
pause
```

`EAC_SDK/Samples/Voice/Client/Source/Game.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "Console.h"
#include "Menu.h"
#include "Level.h"
#include "GameEvent.h"
#include "Platform.h"
#include "Main.h"
#include "Game.h"
#include "Voice.h"
#include "HTTPClient.h"

FGame::FGame() noexcept(false)
{
	Menu = std::make_unique<FMenu>(Console);
	Level = std::make_unique<FLevel>();
	Voice = std::make_unique<FVoice>();

	CreateConsoleCommands();
}

FGame::~FGame()
{
	
}

void FGame::Init()
{
	FBaseGame::Init();

	Voice->Init();
}

void FGame::CreateConsoleCommands()
{
	FBaseGame::CreateConsoleCommands();

	if (Console)
	{
		const std::vector<const wchar_t*> ExtraHelpMessageLines =
		{
			L" JOIN ROOM_NAME - to join a room, if ROOM_NAME is not supplied a new room will be created and joined;",
			L" LEAVE - to leave current room;",
			L" KICK USER_ID - to kick a user, will do nothing if you are not the room owner. USER_ID = ProductUserId;",
			L" REMOTEMUTE USER_ID MUTE - to remote mute a user, will do nothing if you are not the room owner.  USER_ID = ProductUserId, MUTE = 1 or 0;"
		};
		AppendHelpMessageLines(ExtraHelpMessageLines);

		Console->AddCommand(L"JOIN", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
				if (Player)
				{
					if (args.size() == 1)
					{
						// Join room
						FGameEvent Event(EGameEventType::JoinRoom, Player->GetProductUserID(), args[0]);
						FGame::Get().OnGameEvent(Event);
					}
					else
					{
						// Create and join room
						FGameEvent Event(EGameEventType::JoinRoom, Player->GetProductUserID(), std::wstring());
						FGame::Get().OnGameEvent(Event);
					}
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"LEAVE", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
				if (Player)
				{
					FGameEvent Event(EGameEventType::LeaveRoom, Player->GetProductUserID());
					FGame::Get().OnGameEvent(Event);
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"KICK", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (args.size() == 1)
				{
					std::string NarrowUserIdStr = FStringUtils::Narrow(args[0]);
					EOS_ProductUserId ProductUserId = FAccountHelpers::ProductUserIDFromString(NarrowUserIdStr.c_str());
					if (ProductUserId != nullptr)
					{
						FGameEvent Event(EGameEventType::Kick, ProductUserId);
						FGame::Get().OnGameEvent(Event);
					}
					else
					{
						FGame::Get().GetConsole()->AddLine(L"Kick command requires a valid user id");
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"Kick command requires a room name and user id parameter");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});

		Console->AddCommand(L"REMOTEMUTE", [](const std::vector<std::wstring>& args)
		{
			if (FPlatform::IsInitialized())
			{
				if (args.size() == 2)
				{
					std::string NarrowUserIdStr = FStringUtils::Narrow(args[0]);
					EOS_ProductUserId ProductUserId = FAccountHelpers::ProductUserIDFromString(NarrowUserIdStr.c_str());
					if (ProductUserId != nullptr)
					{
						try
						{
							FGameEvent Event(EGameEventType::RemoteMute, std::stoi(args[1]), ProductUserId);
							FGame::Get().OnGameEvent(Event);
						}
						catch (const std::invalid_argument&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't remote mute - invalid argument");
						}
						catch (const std::out_of_range&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't remote mute - out of range.");
						}
						catch (const std::exception&)
						{
							FGame::Get().GetConsole()->AddLine(L"Error: Can't remote mute, undefined error.");
						}
					}
					else
					{
						FGame::Get().GetConsole()->AddLine(L"Remote mute command requires a valid user id");
					}
				}
				else
				{
					FGame::Get().GetConsole()->AddLine(L"Remote mute command requires a user id parameter");
				}
			}
			else
			{
				FDebugLog::LogError(L"EOS SDK is not initialized!");
			}
		});
	}
}

void FGame::Update()
{
	FBaseGame::Update();

	Voice->Update();
	FHTTPClient::GetInstance().Update();
}

void FGame::OnGameEvent(const FGameEvent& Event)
{
	Voice->OnGameEvent(Event);

	FBaseGame::OnGameEvent(Event);
}

void FGame::OnShutdown()
{
	if (Voice)
	{
		Voice->OnShutdown();
	}

	FBaseGame::OnShutdown();

	FHTTPClient::ClearInstance();
}

const std::unique_ptr<FVoice>& FGame::GetVoice()
{
	return Voice;
}

```

`EAC_SDK/Samples/Voice/Client/Source/Game.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseGame.h"

class FVoice;

/**
* Main game class
*/
class FGame : public FBaseGame
{
public:
	/**
	 * Constructor
	 */
	FGame() noexcept(false);

	/**
	 * Destructor
	 */
	virtual ~FGame() override;

	/**
	* Singleton's getter
	*/
	static FGame& Get()
	{
		return static_cast<FGame&>(GetBase());
	}

	/**
	* Initialization
	*/
	virtual void Init() override;

	/**
	* Main update game loop
	*/
	virtual void Update() override;

	/**
	* Game event dispatcher
	*
	* @param Event - Game event to be dispatched
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

	/**
	* Called just before shutting down the game. Allows to finish current operations.
	*/
	virtual void OnShutdown() override;

	/**
	 * Getter for FVoice component.
	 */
	const std::unique_ptr<FVoice>& GetVoice();

protected:
	/**
	* Creates all console commands
	*/
	virtual void CreateConsoleCommands() override;

	/** Voice component */
	std::unique_ptr<FVoice> Voice;
};


```

`EAC_SDK/Samples/Voice/Client/Source/Level.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseLevel.h"

/**
* In-Game Level (Sample-specific level stuff goes here)
*/
class FLevel : public FBaseLevel
{

};
```

`EAC_SDK/Samples/Voice/Client/Source/Menu.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Console.h"
#include "GameEvent.h"
#include "Authentication.h"
#include "ConsoleDialog.h"
#include "ExitDialog.h"
#include "AuthDialogs.h"
#include "FriendsDialog.h"
#include "VoiceDialog.h"
#include "VoiceSetupDialog.h"
#include "SampleConstants.h"
#include "Menu.h"
#include "PopupDialog.h"
#include "CommandLine.h"

const float UpperDialogsVerticalOffset = 130.0f;
const Vector2 ConsoleDialogSizeProportion = Vector2(0.68f, 0.35f);

FMenu::FMenu(std::weak_ptr<FConsole> InConsole) noexcept(false):
	FBaseMenu(InConsole)
{

}

void FMenu::Create()
{
	if (!FCommandLine::Get().HasFlagParam(CommandLineConstants::Server))
	{
		CreateFriendsDialog();
	}

	if (!FCommandLine::Get().HasFlagParam(CommandLineConstants::Server))
	{
		CreateVoiceDialog();
		CreateVoiceSetupDialog();
	}
	else
	{
		TitleLabel->SetText(L"EOS SDK " + FStringUtils::Widen(SampleConstants::GameName) + L" SERVER");
	}

	FBaseMenu::Create();

	if (AuthDialogs)
	{
		AuthDialogs->SetSingleUserOnly(true);
	}
}

void FMenu::Release()
{
	if (VoiceDialog)
	{
		VoiceDialog->Release();
		VoiceDialog.reset();
	}

	FBaseMenu::Release();
}

void FMenu::UpdateLayout(int Width, int Height)
{
	Vector2 WindowSize = Vector2((float)Width, (float)Height);

	BackgroundImage->SetPosition(Vector2(0.f, 0.f));
	BackgroundImage->SetSize(Vector2((float)Width, ((float)Height) / 2.f));

	if (ConsoleDialog)
	{
		if (!FCommandLine::Get().HasFlagParam(CommandLineConstants::Server))
		{
			Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * ConsoleDialogSizeProportion.x, WindowSize.y * ConsoleDialogSizeProportion.y);
			ConsoleDialog->SetSize(ConsoleWidgetSize);

			Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
			ConsoleDialog->SetPosition(ConsoleWidgetPos);

			if (VoiceDialog)
			{
				VoiceDialog->SetSize(Vector2(ConsoleWidgetSize.x, ConsoleWidgetPos.y - UpperDialogsVerticalOffset - 10.0f));
				VoiceDialog->SetPosition(Vector2(ConsoleWidgetPos.x, UpperDialogsVerticalOffset));
			}

			UpdateFriendsDialogTransform(WindowSize);
		}
		else
		{
			Vector2 ConsoleWidgetSize = Vector2(WindowSize.x * 0.95f, WindowSize.y * 0.8f);
			ConsoleDialog->SetSize(ConsoleWidgetSize);

			Vector2 ConsoleWidgetPos = Vector2(10.f, WindowSize.y - ConsoleWidgetSize.y - 10.f);
			ConsoleDialog->SetPosition(ConsoleWidgetPos);
		}
	}

	if (PopupDialog)
	{
		PopupDialog->SetPosition(Vector2((WindowSize.x / 2.f) - PopupDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - PopupDialog->GetSize().y));
	}

	if (ExitDialog)
	{
		ExitDialog->SetPosition(Vector2((WindowSize.x / 2.f) - ExitDialog->GetSize().x / 2.0f, (WindowSize.y / 2.f) - ExitDialog->GetSize().y));
	}

	if (VoiceSetupDialog && FriendsDialog)
	{
		VoiceSetupDialog->SetSize(Vector2(FriendsDialog->GetSize().x, Height - (FriendsDialog->GetPosition().y + FriendsDialog->GetSize().y + 16.f)));
		VoiceSetupDialog->SetPosition(Vector2(FriendsDialog->GetPosition().x, FriendsDialog->GetPosition().y + FriendsDialog->GetSize().y + 6.0f));
	}

	if (AuthDialogs) AuthDialogs->UpdateLayout();
}

void FMenu::CreateVoiceDialog()
{
	const float FX = 100.0f;
	const float FY = 100.0f;
	const float Width = 300.0f;
	const float Height = 300.0f;

	VoiceDialog = std::make_shared<FVoiceDialog>(
		Vector2(FX, FY),
		Vector2(Width, Height),
		DefaultLayer - 2,
		NormalFont->GetFont(),
		BoldSmallFont->GetFont(),
		TinyFont->GetFont());

	VoiceDialog->SetBorderColor(Color::UIBorderGrey);

	VoiceDialog->Create();

	AddDialog(VoiceDialog);
}

void FMenu::CreateVoiceSetupDialog()
{
	VoiceSetupDialog = std::make_shared<FVoiceSetupDialog>(
		Vector2(200.f, 270.f),
		Vector2(370.0f, 220.0f),
		DefaultLayer - 2,
		SmallFont->GetFont(),
		SmallFont->GetFont());

	VoiceSetupDialog->Create();
	VoiceSetupDialog->SetBorderColor(Color::UIBorderGrey);

	AddDialog(VoiceSetupDialog);
}

void FMenu::OnGameEvent(const FGameEvent& Event)
{
	if (VoiceDialog)
	{
		VoiceDialog->OnGameEvent(Event);
	}

	if (VoiceSetupDialog)
	{
		VoiceSetupDialog->OnGameEvent(Event);
	}

	FBaseMenu::OnGameEvent(Event);
}

void FMenu::UpdateFriendsDialogTransform(const Vector2 WindowSize)
{
	if (FriendsDialog)
	{
		const float FX = VoiceDialog->GetPosition().x + VoiceDialog->GetSize().x + 5.0f;
		const float FY = UpperDialogsVerticalOffset;
		const float FriendsWidth = WindowSize.x - FX - 5.0f;
		const float FriendsHeight = WindowSize.y - FY - 200.0f;

		FriendsDialog->SetSize(Vector2(FriendsWidth, FriendsHeight));
		FriendsDialog->SetPosition(Vector2(FX, FY));
	}
}

```

`EAC_SDK/Samples/Voice/Client/Source/Menu.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "BaseMenu.h"

/**
* Forward declarations
*/
class FVoiceDialog;
class FVoiceSetupDialog;

/**
* In-Game Menu
*/
class FMenu : public FBaseMenu
{
public:
	/**
	* Constructor
	*/
	FMenu(std::weak_ptr<FConsole> console) noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMenu(FMenu const&) = delete;
	FMenu& operator=(FMenu const&) = delete;

	/**
	* IGfxComponent Overrides
	*/
	virtual void Create() override;
	virtual void Release() override;

	/**
	* Updates layout of elements
	*/
	virtual void UpdateLayout(int Width, int Height) override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	virtual void OnGameEvent(const FGameEvent& Event) override;

private:
	/**
	 * Creates the voice dialog
	 */
	void CreateVoiceDialog();

	/**
	 * Creates the voice setup dialog
	 */
	void CreateVoiceSetupDialog();

	/**
	 * Updates friends dialog to match Voice dialog. 
	 */
	void UpdateFriendsDialogTransform(const Vector2 WindowSize);

	/** Voice Dialog */
	std::shared_ptr<FVoiceDialog> VoiceDialog;

	/** Voice Setup Dialog */
	std::shared_ptr<FVoiceSetupDialog> VoiceSetupDialog;
};

```

`EAC_SDK/Samples/Voice/Client/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Voice";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";

	/** Trusted Server URL */
	static constexpr char ServerURL[] = "http://127.0.0.1";

	/** Trusted Server Port */
	static constexpr int ServerPort = 1234;
};
```

`EAC_SDK/Samples/Voice/Client/Source/Voice.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "GameEvent.h"
#include "Main.h"
#include "Platform.h"
#include "Users.h"
#include "Player.h"
#include "Voice.h"

#include "HTTPClient.h"
#include "DebugLog.h"
#include "StringUtils.h"
#include "AccountHelpers.h"
#include "SampleConstants.h"
#include "CommandLine.h"
#include "Utils.h"

#define RAPIDJSON_HAS_STDSTRING 1
#include "rapidjson/document.h"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include "rapidjson/error/en.h"

#include <eos_presence.h>
#include <eos_ui.h>
#include <eos_rtc.h>

#include <regex>

constexpr const char* SampleJoinInfoFormat = R"({"RoomName": "%s"})";
constexpr const char* SampleJoinInfoRegex = R"(\{\"RoomName\"\s*:\s*\"(.*)\"\})";

/** Password used to create and join a room session, set to nullptr to disable requirement for password */
constexpr const char* SessionPassword = "a682473a335a4449ac235d86eb961526";

constexpr char SampleConstants::ServerURL[];
constexpr int SampleConstants::ServerPort;

namespace
{
	std::string JsonDocToString(const rapidjson::Document& Document)
	{
		rapidjson::StringBuffer Buffer;
		Buffer.Clear();

		rapidjson::Writer<rapidjson::StringBuffer> Writer(Buffer);
		Document.Accept(Writer);

		return std::string(Buffer.GetString());
	}
}

FVoice::FVoice()
{
	
}

FVoice::~FVoice()
{

}

void FVoice::Init()
{
	if (!FPlatform::IsInitialized())
	{
		return;
	}

	if (FPlatform::GetPlatformHandle() != nullptr)
	{
		RTCHandle = EOS_Platform_GetRTCInterface(FPlatform::GetPlatformHandle());
		RTCAdminHandle = EOS_Platform_GetRTCAdminInterface(FPlatform::GetPlatformHandle());
		RTCAudioHandle = EOS_RTC_GetAudioInterface(RTCHandle);
	}

	std::string ServerURLStr = SampleConstants::ServerURL;
	TrustedServerURL = FStringUtils::Widen(ServerURLStr);
	if (FCommandLine::Get().HasParam(CommandLineConstants::ServerURL))
	{
		TrustedServerURL = FCommandLine::Get().GetParamValue(CommandLineConstants::ServerURL);
	}

	TrustedServerPort = std::to_wstring(SampleConstants::ServerPort);
	if (FCommandLine::Get().HasParam(CommandLineConstants::ServerPort))
	{
		TrustedServerPort = FCommandLine::Get().GetParamValue(CommandLineConstants::ServerPort);
	}

	FullTrustedServerURL = TrustedServerURL + L":" + TrustedServerPort;

	SubscribeToNotifications();
	
	UpdateAudioInputDevices();
	UpdateAudioOutputDevices();
}

void FVoice::OnShutdown()
{
	ClearRoomMembers();

	UnsubscribeFromNotifications();
}

void FVoice::Update()
{
	// heartbeat the session
	if (!CurrentRoomName.empty() && !OwnerLock.empty())
	{
		if (std::chrono::steady_clock::now() > NextHeartbeat)
		{
			if (LocalProductUserId.IsValid())
			{
				HeartbeatVoiceSession(LocalProductUserId, OwnerLock);
			}
		}
	}
}

void FVoice::OnLoggedIn(FEpicAccountId UserId)
{
	LocalEpicUserId = UserId;

	SetJoinInfo("");
}

void FVoice::OnLoggedOut(FEpicAccountId UserId)
{
	PlayerPtr Player = FPlayerManager::Get().GetPlayer(UserId);
	if (Player)
	{
		QueryLeaveRoom(Player->GetProductUserID(), CurrentRoomName);
	}

	SetJoinInfo("");

	UnsubscribeFromRoomNotifications();

	ClearRoomMembers();

	ClearOwnerLock();

	CachedUserRoomTokenInfo.clear();

	if (LocalEpicUserId == UserId)
	{
		LocalEpicUserId = FEpicAccountId();
		LocalProductUserId = FProductUserId();
	}

	FGameEvent Event(EGameEventType::NoUserLoggedIn);
	FGame::Get().OnGameEvent(Event);
}

void FVoice::OnUserConnectLoggedIn(FProductUserId ProductUserId)
{
	LocalProductUserId = ProductUserId;

	// After login cache devices is empty
	UpdateAudioInputDevices();
	UpdateAudioOutputDevices();
}

void FVoice::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedIn(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		FEpicAccountId UserId = Event.GetUserId();
		OnLoggedOut(UserId);
	}
	else if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		FProductUserId ProductUserId = Event.GetProductUserId();
		OnUserConnectLoggedIn(ProductUserId);
	}
	else if (Event.GetType() == EGameEventType::JoinRoom)
	{
		RequestJoinRoom(Event.GetProductUserId(), Event.GetFirstStr());
	}
	else if (Event.GetType() == EGameEventType::LeaveRoom)
	{
		QueryLeaveRoom(Event.GetProductUserId(), CurrentRoomName);
	}
	else if (Event.GetType() == EGameEventType::StartChatWithFriend)
	{
		JoinRoomWithFriend(Event.GetUserId(), Event.GetProductUserId(), Event.GetFirstStr());
	}
	else if (Event.GetType() == EGameEventType::EpicAccountsMappingRetrieved)
	{
		OnEpicAccountsMappingRetrieved();
	}
	else if (Event.GetType() == EGameEventType::EpicAccountDisplayNameRetrieved)
	{
		OnEpicAccountDisplayNameRetrieved(Event.GetUserId(), Event.GetFirstStr());
	}
	else if (Event.GetType() == EGameEventType::Kick)
	{
		KickMember(Event.GetProductUserId());
	}
	else if (Event.GetType() == EGameEventType::RemoteMute)
	{
		RemoteMuteMember(Event.GetProductUserId(), Event.GetFirstExtendedType() == 1);
	}
	else if (Event.GetType() == EGameEventType::UpdateReceivingVolume)
	{
		UpdateReceivingVolume(Event.GetFirstStr());
	}
	else if (Event.GetType() == EGameEventType::UpdateParticipantVolume)
	{
		UpdateParticipantVolume(Event.GetProductUserId(), Event.GetFirstStr());
	}
}

bool FVoice::IsMember(FProductUserId ProductUserId)
{
	auto Itr = RoomMembers.find(ProductUserId);
	if (Itr != RoomMembers.end())
	{
		return true;
	}
	return false;
}

void FVoice::ClearRoomMembers()
{
	for (std::map<EOS_ProductUserId, FVoiceRoomMember>::iterator Itr = RoomMembers.begin(); Itr != RoomMembers.end(); ++Itr)
	{
		if (Itr->second.Player != nullptr)
		{
			FPlayerManager::Get().Remove(Itr->second.Player->GetUserID());
		}
	}

	RoomMembers.clear();
}

void FVoice::SubscribeToRoomNotifications(std::wstring InRoomName)
{
	FDebugLog::Log(L"Voice (SubscribeToRoomNotifications)");

	if (LocalProductUserId.IsValid())
	{
		std::string RoomNameStr = FStringUtils::Narrow(InRoomName);

		// Local user is disconnected
		if (DisconnectedNotification == EOS_INVALID_NOTIFICATIONID)
		{
			EOS_RTC_AddNotifyDisconnectedOptions DisconnectedOptions = {};
			DisconnectedOptions.ApiVersion = EOS_RTC_ADDNOTIFYDISCONNECTED_API_LATEST;
			DisconnectedOptions.LocalUserId = LocalProductUserId;
			DisconnectedOptions.RoomName = RoomNameStr.c_str();
			DisconnectedNotification = EOS_RTC_AddNotifyDisconnected(RTCHandle, &DisconnectedOptions, nullptr, OnDisconnectedCb);
		}

		// Participant Status Changed
		if (ParticipantStatusChangedNotification == EOS_INVALID_NOTIFICATIONID)
		{
			EOS_RTC_AddNotifyParticipantStatusChangedOptions ParticipantStatusChangedOptions = {};
			ParticipantStatusChangedOptions.ApiVersion = EOS_RTC_ADDNOTIFYPARTICIPANTSTATUSCHANGED_API_LATEST;
			ParticipantStatusChangedOptions.LocalUserId = LocalProductUserId;
			ParticipantStatusChangedOptions.RoomName = RoomNameStr.c_str();
			ParticipantStatusChangedNotification = EOS_RTC_AddNotifyParticipantStatusChanged(RTCHandle, &ParticipantStatusChangedOptions, nullptr, OnParticipantStatusChangedCb);
		}

		// Participant Updated
		if (ParticipantAudioUpdatedNotification == EOS_INVALID_NOTIFICATIONID)
		{
			EOS_RTCAudio_AddNotifyParticipantUpdatedOptions ParticipantAudioUpdatedOptions = {};
			ParticipantAudioUpdatedOptions.ApiVersion = EOS_RTCAUDIO_ADDNOTIFYPARTICIPANTUPDATED_API_LATEST;
			ParticipantAudioUpdatedOptions.LocalUserId = LocalProductUserId;
			ParticipantAudioUpdatedOptions.RoomName = RoomNameStr.c_str();
			ParticipantAudioUpdatedNotification = EOS_RTCAudio_AddNotifyParticipantUpdated(RTCAudioHandle, &ParticipantAudioUpdatedOptions, nullptr, OnParticipantAudioUpdatedCb);
		}
	}
}

void FVoice::UnsubscribeFromRoomNotifications()
{
	FDebugLog::Log(L"Voice (UnsubscribeFromRoomNotifications)");

	if (DisconnectedNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_RTC_RemoveNotifyDisconnected(RTCHandle, DisconnectedNotification);
		DisconnectedNotification = EOS_INVALID_NOTIFICATIONID;
	}
	if (ParticipantStatusChangedNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_RTC_RemoveNotifyParticipantStatusChanged(RTCHandle, ParticipantStatusChangedNotification);
		ParticipantStatusChangedNotification = EOS_INVALID_NOTIFICATIONID;
	}
	if (ParticipantAudioUpdatedNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_RTCAudio_RemoveNotifyParticipantUpdated(RTCAudioHandle, ParticipantAudioUpdatedNotification);
		ParticipantAudioUpdatedNotification = EOS_INVALID_NOTIFICATIONID;
	}
}

void FVoice::SubscribeToNotifications()
{
	// Audio devices changed
	if (AudioDevicesChangedNotification == EOS_INVALID_NOTIFICATIONID)
	{
		EOS_RTCAudio_AddNotifyAudioDevicesChangedOptions AudioDevicesChangedOptions = {};
		AudioDevicesChangedOptions.ApiVersion = EOS_RTCAUDIO_ADDNOTIFYAUDIODEVICESCHANGED_API_LATEST;
		AudioDevicesChangedNotification = EOS_RTCAudio_AddNotifyAudioDevicesChanged(RTCAudioHandle, &AudioDevicesChangedOptions, nullptr, OnAudioDevicesChangedCb);
	}
}

void FVoice::UnsubscribeFromNotifications()
{
	if (AudioDevicesChangedNotification != EOS_INVALID_NOTIFICATIONID)
	{
		EOS_RTCAudio_RemoveNotifyAudioDevicesChanged(RTCAudioHandle, AudioDevicesChangedNotification);
		AudioDevicesChangedNotification = EOS_INVALID_NOTIFICATIONID;
	}
}

void FVoice::LocalToggleMuteMember(FProductUserId ProductUserId)
{
	if (ProductUserId.IsValid())
	{
		auto Itr = RoomMembers.find(ProductUserId);
		if (Itr != RoomMembers.end())
		{
			// Don't toggle mute if we're muted remotely
			if (!Itr->second.bIsRemoteMuted)
			{
				Itr->second.bIsMuted = !Itr->second.bIsMuted;

				FDebugLog::Log(L"Local Muting - Id: %ls - %ls", ProductUserId.ToString().c_str(), Itr->second.bIsMuted ? L"Muted" : L"Unmuted");

				FGameEvent Event(EGameEventType::RoomDataUpdated);
				FGame::Get().OnGameEvent(Event);

				std::string RoomNameStr = FStringUtils::Narrow(CurrentRoomName);

				if (LocalProductUserId == ProductUserId)
				{
					EOS_RTCAudio_UpdateSendingOptions UpdateSendingOptions = { 0 };
					UpdateSendingOptions.ApiVersion = EOS_RTCAUDIO_UPDATESENDING_API_LATEST;
					UpdateSendingOptions.LocalUserId = LocalProductUserId;
					UpdateSendingOptions.RoomName = RoomNameStr.c_str();
					UpdateSendingOptions.AudioStatus = Itr->second.bIsMuted ? EOS_ERTCAudioStatus::EOS_RTCAS_Disabled : EOS_ERTCAudioStatus::EOS_RTCAS_Enabled;
					EOS_RTCAudio_UpdateSending(RTCAudioHandle, &UpdateSendingOptions, nullptr, OnAudioUpdateSendingCb);
				}
				else
				{
					EOS_RTCAudio_UpdateReceivingOptions UpdateReceivingOptions = { 0 };
					UpdateReceivingOptions.ApiVersion = EOS_RTCAUDIO_UPDATERECEIVING_API_LATEST;
					UpdateReceivingOptions.LocalUserId = LocalProductUserId;
					UpdateReceivingOptions.RoomName = RoomNameStr.c_str();
					UpdateReceivingOptions.ParticipantId = ProductUserId;
					UpdateReceivingOptions.bAudioEnabled = Itr->second.bIsMuted ? EOS_FALSE : EOS_TRUE;
					EOS_RTCAudio_UpdateReceiving(RTCAudioHandle, &UpdateReceivingOptions, nullptr, OnAudioUpdateReceivingCb);
				}
			}
		}
	}
}

void FVoice::QueryJoinRoomToken(FProductUserId ProductUserId, std::wstring InRoomName)
{
	// [Trusted Server]
	// Send message to trusted server with join room info

	std::wstring URL = FullTrustedServerURL;
	URL.append(L"/session");

	if (InRoomName.empty())
	{
		// Create and join session (with json request body)
		rapidjson::Document Doc;
		Doc.SetObject();
		Doc.AddMember("puid", FStringUtils::Narrow(ProductUserId.ToString()), Doc.GetAllocator());
		if (SessionPassword != nullptr)
		{
			// Add optional password
			const std::string Password = SessionPassword;
			Doc.AddMember("password", Password, Doc.GetAllocator());
		}
		QueryJoinRoomTokenRequestBody = JsonDocToString(Doc);
		FDebugLog::Log(L"Query join token Body: %ls", FStringUtils::Widen(QueryJoinRoomTokenRequestBody).c_str());
	}
	else
	{
		// Join session
		URL.append(L"/");
		URL.append(InRoomName);
		URL.append(L"/join/");
		URL.append(ProductUserId.ToString());
		if (SessionPassword != nullptr)
		{
			// Add optional password
			const std::string Password = SessionPassword;
			URL.append(L"?password=");
			URL.append(FStringUtils::Widen(Password));
		}
		// No body required
		QueryJoinRoomTokenRequestBody = std::string();
	}
	FDebugLog::Log(L"Query join token URL: %ls", URL.c_str());

	FHTTPClient::GetInstance().PerformHTTPRequest(FStringUtils::Narrow(URL), FHTTPClient::EHttpRequestMethod::POST, QueryJoinRoomTokenRequestBody,
		[ProductUserId, InRoomName](FHTTPClient::HTTPErrorCode ErrorCode, const std::vector<char>& Data)
	{
		if (ErrorCode == 200)
		{
			std::string ResponseString(Data.data(), Data.size());

			if (ResponseString.find("error") != std::string::npos)
			{
				FDebugLog::LogError(L"Query join token failed, Response: %ls", FStringUtils::Widen(ResponseString).c_str());
			}
			else
			{
				FDebugLog::Log(L"Query join token success, Response: %ls", FStringUtils::Widen(ResponseString).c_str());

				// Parse Json data from response
				rapidjson::Document ResponseDoc;
				ResponseDoc.Parse(ResponseString.c_str());
				if (ResponseDoc.HasParseError())
				{
					const rapidjson::ParseErrorCode ParseErr = ResponseDoc.GetParseError();
					std::string ParseErrorStr = rapidjson::GetParseError_En(ParseErr);
					FDebugLog::LogError(L"Query join token failed, Json response parse error: %ls", FStringUtils::Widen(ParseErrorStr).c_str());
					return;
				}

				// SessionId (Room Name)
				if (!ResponseDoc.HasMember("sessionId") || !ResponseDoc["sessionId"].IsString())
				{
					FDebugLog::LogError(L"Query join token failed, Json response missing sessionId");
					return;
				}
				std::string SessionIdStr = ResponseDoc["sessionId"].GetString();

				// Owner Lock
				std::string OwnerLockStr;
				if (ResponseDoc.HasMember("ownerLock") && ResponseDoc["ownerLock"].IsString())
				{
					OwnerLockStr = ResponseDoc["ownerLock"].GetString();
				}

				// Client Base URL
				std::string ClientBaseUrlStr;
				if (!ResponseDoc.HasMember("clientBaseUrl") || !ResponseDoc["clientBaseUrl"].IsString())
				{
					FDebugLog::LogError(L"Query join token failed, Json response missing clientBaseUrl");
					return;
				}
				ClientBaseUrlStr = ResponseDoc["clientBaseUrl"].GetString();

				// Join Tokens
				if (ResponseDoc.HasMember("joinTokens") && ResponseDoc["joinTokens"].IsArray())
				{
					FDebugLog::LogError(L"Query join token failed, Json response missing joinTokens");
					return;
				}
				const rapidjson::Value& JoinTokens = ResponseDoc["joinTokens"];
				if (JoinTokens.MemberCount() != 1)
				{
					FDebugLog::LogError(L"Query join token failed, joinTokens array should have one member - count: %d", JoinTokens.MemberCount());
					return;
				}
				std::string PuidStr;
				std::string TokenStr;
				for (rapidjson::Value::ConstMemberIterator JoinTokensItr = JoinTokens.MemberBegin(); JoinTokensItr != JoinTokens.MemberEnd(); ++JoinTokensItr)
				{
					PuidStr = JoinTokensItr->name.GetString();
					TokenStr = JoinTokensItr->value.GetString();
				}
				EOS_ProductUserId JoinTokenProductUserId = EOS_ProductUserId_FromString(PuidStr.c_str());
				if (JoinTokenProductUserId != ProductUserId)
				{
					FDebugLog::LogError(L"Query join token failed, joinTokens ProductUserId mismatch - Request ID: %ls, Response ID: %ls",
						ProductUserId.ToString().c_str(),
						FStringUtils::Widen(PuidStr).c_str());
					return;
				}

				// Cache room token
				std::shared_ptr<FVoiceUserRoomTokenData> UserRoomToken = std::make_shared<FVoiceUserRoomTokenData>();
				UserRoomToken->ProductUserId = JoinTokenProductUserId;
				UserRoomToken->Token = TokenStr;
				FGame::Get().GetVoice()->AddLocalUserRoomTokenData(UserRoomToken);

				// Join Room
				std::wstring WideRoomName = FStringUtils::Widen(SessionIdStr);
				std::wstring WideClientBaseUrl = FStringUtils::Widen(ClientBaseUrlStr);
				FGame::Get().GetVoice()->JoinFromCachedRoomTokenData(WideRoomName, WideClientBaseUrl);

				// Set owner lock (empty if we are not the owner)
				FGame::Get().GetVoice()->SetOwnerLock(OwnerLockStr);
			}
		}
		else
		{
			std::string ErrorString(Data.data(), Data.size());
			FDebugLog::LogError(L"Query join token failed, HTTP Request failed, Code: %d, Error %ls", ErrorCode, FStringUtils::Widen(ErrorString).c_str());
		}
	});
}

void FVoice::RemoteToggleMuteMember(FProductUserId ProductUserId)
{
	FDebugLog::Log(L"Remote Mute Member - Id: %ls", ProductUserId.ToString().c_str());

	// [Trusted Server]
	// Ask trusted server to remote mute user

	auto Itr = RoomMembers.find(ProductUserId);
	if (Itr != RoomMembers.end())
	{
		FDebugLog::Log(L"Remote Muting - Id: %ls - %ls", ProductUserId.ToString().c_str(), !Itr->second.bIsRemoteMuted ? L"Mute" : L"Unmute");

		RemoteMuteMember(ProductUserId, !Itr->second.bIsRemoteMuted);
	}
}

void FVoice::RemoteMuteMember(FProductUserId ProductUserId, bool bIsMuted)
{
	FDebugLog::Log(L"Remote Mute Member - Id: %ls", ProductUserId.ToString().c_str());

	// [Trusted Server]
	// Ask trusted server to remote mute user

	if (OwnerLock.empty())
	{
		FDebugLog::LogError(L"Mute failed, Owner lock is invalid");
		return;
	}

	std::wstring URL = FullTrustedServerURL;
	URL.append(L"/session/");
	URL.append(CurrentRoomName);
	URL.append(L"/mute/");
	URL.append(ProductUserId.ToString());
	FDebugLog::Log(L"Mute URL: %ls", URL.c_str());

	// Add owner lock and mute to json request body
	rapidjson::Document Doc;
	Doc.SetObject();
	Doc.AddMember("lock", OwnerLock, Doc.GetAllocator());
	Doc.AddMember("mute", bIsMuted, Doc.GetAllocator());
	MuteRequestBody = JsonDocToString(Doc);
	FDebugLog::Log(L"Mute Body: %ls", FStringUtils::Widen(MuteRequestBody).c_str());

	FHTTPClient::GetInstance().PerformHTTPRequest(FStringUtils::Narrow(URL), FHTTPClient::EHttpRequestMethod::POST, MuteRequestBody,
		[ProductUserId, bIsMuted](FHTTPClient::HTTPErrorCode ErrorCode, const std::vector<char>& Data)
		{
			if (ErrorCode == 200)
			{
				std::string ResponseString(Data.data(), Data.size());

				if (ResponseString.find("error") != std::string::npos)
				{
					FDebugLog::LogError(L"Mute failed, Response: %ls", FStringUtils::Widen(ResponseString).c_str());
				}
				else
				{
					FDebugLog::Log(L"Mute success, User Id: %ls", ProductUserId.ToString().c_str());

					FGame::Get().GetVoice()->SetMemberRemoteMuteState(ProductUserId, bIsMuted);
				}
			}
			else
			{
				std::string ErrorString(Data.data(), Data.size());
				FDebugLog::LogError(L"Mute failed, HTTP Request failed, Code: %d, Error %ls", ErrorCode, FStringUtils::Widen(ErrorString).c_str());
			}
		});
}

void FVoice::KickMember(FProductUserId ProductUserId)
{
	FDebugLog::Log(L"Kick Member - Id: %ls", ProductUserId.ToString().c_str());

	// [Trusted Server]
	// Ask trusted server to kick user

	if (OwnerLock.empty())
	{
		FDebugLog::LogError(L"Kick failed, Owner lock is invalid");
		return;
	}

	std::wstring URL = FullTrustedServerURL;
	URL.append(L"/session/");
	URL.append(CurrentRoomName);
	URL.append(L"/kick/");
	URL.append(ProductUserId.ToString());
	FDebugLog::Log(L"Kick URL: %ls", URL.c_str());

	// Add owner lock to json request body
	rapidjson::Document Doc;
	Doc.SetObject();
	Doc.AddMember("lock", OwnerLock, Doc.GetAllocator());
	KickRequestBody = JsonDocToString(Doc);
	FDebugLog::Log(L"Kick Body: %ls", FStringUtils::Widen(KickRequestBody).c_str());

	FHTTPClient::GetInstance().PerformHTTPRequest(FStringUtils::Narrow(URL), FHTTPClient::EHttpRequestMethod::POST, KickRequestBody,
		[ProductUserId](FHTTPClient::HTTPErrorCode ErrorCode, const std::vector<char>& Data)
	{
		if (ErrorCode == 200)
		{
			std::string ResponseString(Data.data(), Data.size());

			if (ResponseString.find("error") != std::string::npos)
			{
				FDebugLog::LogError(L"Kick failed, Response: %ls", FStringUtils::Widen(ResponseString).c_str());
			}
			else
			{
				FDebugLog::Log(L"Kick success, User Id: %ls", ProductUserId.ToString().c_str());
			}
		}
		else
		{
			std::string ErrorString(Data.data(), Data.size());
			FDebugLog::LogError(L"Kick failed, HTTP Request failed, Code: %d, Error %ls", ErrorCode, FStringUtils::Widen(ErrorString).c_str());
		}
	});
}

void FVoice::HeartbeatVoiceSession(FProductUserId ProductUserId, const std::string& OwnerLock)
{
	FDebugLog::Log(L"Heartbeat VoiceSession - Id: %ls", ProductUserId.ToString().c_str());

	if (OwnerLock.empty())
	{
		FDebugLog::LogError(L"HeartbeatVoiceSession failed, Owner lock is invalid");
		return;
	}

	std::wstring URL = FullTrustedServerURL;
	URL.append(L"/session/");
	URL.append(CurrentRoomName);
	URL.append(L"/heartbeat");
	FDebugLog::Log(L"Heartbeat URL: %ls", URL.c_str());

	// Add owner lock to json request body
	rapidjson::Document Doc;
	Doc.SetObject();
	Doc.AddMember("lock", OwnerLock, Doc.GetAllocator());
	HeartbeatRequestBody = JsonDocToString(Doc);
	FDebugLog::Log(L"Heartbeat Body: %ls", FStringUtils::Widen(HeartbeatRequestBody).c_str());

	// Immediately push out timer, but may get corrected down in case of request failure to prevent multiple attempts in case of timeouts
	NextHeartbeat = std::chrono::steady_clock::now() + std::chrono::seconds(30);

	FHTTPClient::GetInstance().PerformHTTPRequest(FStringUtils::Narrow(URL), FHTTPClient::EHttpRequestMethod::POST, HeartbeatRequestBody,
		[ProductUserId, this](FHTTPClient::HTTPErrorCode ErrorCode, const std::vector<char>& Data)
	{
		if (ErrorCode == 200)
		{
			std::string ResponseString(Data.data(), Data.size());

			if (ResponseString.find("error") != std::string::npos)
			{
				// A failing heartbeat could mean either an invalid lock (403) or the session has disappeared on the backend (404).
				// The sample application doesn't handle this any further, but applications should handle these cases by recreating a new session.
				FDebugLog::LogError(L"Heartbeat failed, Response: %ls", FStringUtils::Widen(ResponseString).c_str());
			}
			else
			{
				FDebugLog::Log(L"Heartbeat success, User Id: %ls", ProductUserId.ToString().c_str());
			}
		}
		else
		{
			std::string ErrorString(Data.data(), Data.size());
			FDebugLog::LogError(L"Heartbeat failed, HTTP Request failed, Code: %d, Error %ls", ErrorCode, FStringUtils::Widen(ErrorString).c_str());

			// Try heartbeat again in a few seconds
			NextHeartbeat = std::chrono::steady_clock::now() + std::chrono::seconds(5);
		}
	});
}

void FVoice::UpdateAudioInputDevices()
{
	EOS_RTCAudio_QueryInputDevicesInformationOptions Options = {};
	Options.ApiVersion = EOS_RTCAUDIO_QUERYINPUTDEVICESINFORMATION_API_LATEST;
	EOS_RTCAudio_QueryInputDevicesInformation(RTCAudioHandle, &Options, NULL, OnInputDevicesInformationCb);
}

void FVoice::GetAudioInputDevices()
{
	AudioInputDeviceNames.clear();
	AudioInputDeviceIds.clear();

	EOS_RTCAudio_GetInputDevicesCountOptions Options = {};
	Options.ApiVersion = EOS_RTCAUDIO_GETINPUTDEVICESCOUNT_API_LATEST;
	uint32_t Count = EOS_RTCAudio_GetInputDevicesCount(RTCAudioHandle, &Options);

	std::wstring DefaultDeviceName;
	for (uint32_t Index = 0; Index < Count; Index++)
	{
		EOS_RTCAudio_InputDeviceInformation* AudioDeviceInfo;
		EOS_RTCAudio_CopyInputDeviceInformationByIndexOptions CopyByIndexOptions = {};
		CopyByIndexOptions.ApiVersion = EOS_RTCAUDIO_COPYINPUTDEVICEINFORMATIONBYINDEX_API_LATEST;
		CopyByIndexOptions.DeviceIndex = Index;

		if (EOS_RTCAudio_CopyInputDeviceInformationByIndex(RTCAudioHandle, &CopyByIndexOptions, &AudioDeviceInfo) == EOS_EResult::EOS_Success)
		{
			std::string DeviceName = AudioDeviceInfo->DeviceName;
			AudioInputDeviceNames.emplace_back(FStringUtils::Widen(DeviceName));

			std::string DeviceId = AudioDeviceInfo->DeviceId;
			AudioInputDeviceIds.emplace_back(FStringUtils::Widen(DeviceId));

			if (AudioDeviceInfo->bDefaultDevice == EOS_TRUE)
			{
				DefaultDeviceName = FStringUtils::Widen(DeviceName);
			}

			EOS_RTCAudio_InputDeviceInformation_Release(AudioDeviceInfo);
		}
	}

	FGameEvent Event(EGameEventType::AudioInputDevicesUpdated, DefaultDeviceName);
	FGame::Get().OnGameEvent(Event);
}

void FVoice::UpdateAudioOutputDevices()
{
	EOS_RTCAudio_QueryOutputDevicesInformationOptions Options = {};
	Options.ApiVersion = EOS_RTCAUDIO_QUERYOUTPUTDEVICESINFORMATION_API_LATEST;
	EOS_RTCAudio_QueryOutputDevicesInformation(RTCAudioHandle, &Options, NULL, OnOutputDevicesInformationCb);
}

void FVoice::GetAudioOutputDevices()
{
	AudioOutputDeviceNames.clear();
	AudioOutputDeviceIds.clear();

	EOS_RTCAudio_GetOutputDevicesCountOptions Options = {};
	Options.ApiVersion = EOS_RTCAUDIO_GETOUTPUTDEVICESCOUNT_API_LATEST;
	uint32_t Count = EOS_RTCAudio_GetOutputDevicesCount(RTCAudioHandle, &Options);

	std::wstring DefaultDeviceName;
	for (uint32_t Index = 0; Index < Count; Index++)
	{
		EOS_RTCAudio_CopyOutputDeviceInformationByIndexOptions CopyByIndexOptions = {};
		CopyByIndexOptions.ApiVersion = EOS_RTCAUDIO_COPYOUTPUTDEVICEINFORMATIONBYINDEX_API_LATEST;
		CopyByIndexOptions.DeviceIndex = Index;
		EOS_RTCAudio_OutputDeviceInformation* AudioDeviceInfo;
		if (EOS_RTCAudio_CopyOutputDeviceInformationByIndex(RTCAudioHandle, &CopyByIndexOptions, &AudioDeviceInfo) == EOS_EResult::EOS_Success)
		{
			std::string DeviceName = AudioDeviceInfo->DeviceName;
			AudioOutputDeviceNames.emplace_back(FStringUtils::Widen(DeviceName));

			std::string DeviceId = AudioDeviceInfo->DeviceId;
			AudioOutputDeviceIds.emplace_back(FStringUtils::Widen(DeviceId));

			if (AudioDeviceInfo->bDefaultDevice == EOS_TRUE)
			{
				DefaultDeviceName = FStringUtils::Widen(DeviceName);
			}

			EOS_RTCAudio_OutputDeviceInformation_Release(AudioDeviceInfo);
		}
	}

	FGameEvent Event(EGameEventType::AudioOutputDevicesUpdated, DefaultDeviceName);
	FGame::Get().OnGameEvent(Event);
}

void FVoice::QueryJoinRoom(FProductUserId ProductUserId, std::wstring InRoomName, std::wstring InClientBaseUrl, std::string InToken)
{
	std::string RoomNameStr = FStringUtils::Narrow(InRoomName);
	std::string ClientBaseUrlStr = FStringUtils::Narrow(InClientBaseUrl);

	EOS_RTC_JoinRoomOptions Options = {};
	Options.ApiVersion = EOS_RTC_JOINROOM_API_LATEST;
	Options.LocalUserId = ProductUserId;
	Options.RoomName = RoomNameStr.c_str();
	Options.ClientBaseUrl = ClientBaseUrlStr.c_str();
	Options.ParticipantToken = InToken.c_str();

	EOS_RTC_JoinRoom(RTCHandle, &Options, nullptr, OnJoinRoomCb);
}

void FVoice::QueryLeaveRoom(FProductUserId ProductUserId, std::wstring InRoomName)
{
	std::string RoomNameStr = FStringUtils::Narrow(InRoomName);

	EOS_RTC_LeaveRoomOptions Options = {};
	Options.ApiVersion = EOS_RTC_LEAVEROOM_API_LATEST;
	Options.LocalUserId = ProductUserId;
	Options.RoomName = RoomNameStr.c_str();

	EOS_RTC_LeaveRoom(RTCHandle, &Options, nullptr, OnLeaveRoomCb);
}

void FVoice::RequestJoinRoom(FProductUserId ProductUserId, std::wstring InRoomName)
{
	QueryJoinRoomToken(ProductUserId, InRoomName);
}

void FVoice::StartJoinRoom(FProductUserId ProductUserId, std::wstring InRoomName, std::wstring InClientBaseUrl, std::string InToken)
{
	QueryJoinRoom(ProductUserId, InRoomName, InClientBaseUrl, InToken);
}

void FVoice::JoinRoom(FProductUserId ProductUserId, std::wstring InRoomName)
{
	if (LocalProductUserId.IsValid())
	{
		auto Itr = RoomMembers.find(ProductUserId);
		if (Itr == RoomMembers.end())
		{
			PlayerPtr OtherPlayer = FPlayerManager::Get().GetPlayer(ProductUserId);
			if (OtherPlayer != nullptr)
			{
				FinalizeJoinRoom(OtherPlayer, ProductUserId, InRoomName);
			}
			else
			{
				// We need to get FEpicAccountId and DisplayName for new player before adding
				// them to the list of players in this room
				QueryPlayerInfo(LocalProductUserId, ProductUserId);
			}
		}
		else
		{
			FDebugLog::LogError(L"Trying to add duplicate player to room - Id: %ls", ProductUserId.ToString().c_str());
		}
	}
}

void FVoice::FinalizeJoinRoom(PlayerPtr Player, FProductUserId ProductUserId, std::wstring InRoomName)
{
	if (LocalProductUserId.IsValid())
	{
		FVoiceRoomMember VoiceRoomMember;
		VoiceRoomMember.Player = Player;
		VoiceRoomMember.bIsOwner = !OwnerLock.empty(); // Local client is the owner if they have the owner lock
		VoiceRoomMember.bIsLocal = LocalProductUserId == ProductUserId;
		VoiceRoomMember.Volume = 50.0f;
		RoomMembers.insert({ ProductUserId, VoiceRoomMember });

		FGameEvent Event(EGameEventType::RoomJoined, ProductUserId, InRoomName);
		FGame::Get().OnGameEvent(Event);

		if (VoiceRoomMember.bIsLocal)
		{
			CurrentRoomName = InRoomName;

			// Update Presence for local user
			std::string RoomNameStr = FStringUtils::Narrow(InRoomName);
			SetJoinInfo(RoomNameStr);

			SubscribeToRoomNotifications(InRoomName);

			NextHeartbeat = std::chrono::steady_clock::now();
		}

		FDebugLog::Log(L"Player joined room - Id: %ls, Room: %ls", ProductUserId.ToString().c_str(), InRoomName.c_str());
	}
}

void FVoice::QueryPlayerInfo(FProductUserId LocalUserId, FProductUserId OtherUserId)
{
	// Check to see if we already have info for the other player
	FEpicAccountId EpicUserId = FGame::Get().GetUsers()->GetAccountMapping(OtherUserId);
	if (EpicUserId.IsValid())
	{
		// Use latest display name we have for other player
		std::wstring DisplayName = FGame::Get().GetUsers()->GetDisplayName(EpicUserId);
		if (!DisplayName.empty())
		{
			FDebugLog::Log(L"QueryPlayerInfo - Display name: %ls, Id: %ls", DisplayName.c_str(), OtherUserId.ToString().c_str());

			PlayerPtr OtherPlayer = FPlayerManager::Get().GetPlayer(EpicUserId);
			if (OtherPlayer == nullptr)
			{
				// Add new player
				FPlayerManager::Get().Add(EpicUserId);
				FPlayerManager::Get().SetProductUserID(EpicUserId, OtherUserId);
			}

			// Join Room
			OtherPlayer = FPlayerManager::Get().GetPlayer(EpicUserId);
			FPlayerManager::Get().SetDisplayName(EpicUserId, DisplayName);
			FinalizeJoinRoom(OtherPlayer, OtherUserId, CurrentRoomName);
			return;
		}
	}

	FDebugLog::Log(L"QueryPlayerInfo - Querying for display name - Id: %ls", OtherUserId.ToString().c_str());

	// Query for display name since we don't have it yet
	ProductUserIdsToQuery.emplace_back(OtherUserId);
	FGame::Get().GetUsers()->QueryAccountMappings(LocalUserId, ProductUserIdsToQuery);
}

void FVoice::OnEpicAccountsMappingRetrieved()
{
	for (FProductUserId ProductUserId : ProductUserIdsToQuery)
	{
		FEpicAccountId EpicUserId = FGame::Get().GetUsers()->GetAccountMapping(ProductUserId);
		if (EpicUserId.IsValid())
		{
			PlayerPtr OtherPlayer = FPlayerManager::Get().GetPlayer(EpicUserId);
			if (OtherPlayer == nullptr)
			{
				// Add new player
				FPlayerManager::Get().Add(EpicUserId);
				FPlayerManager::Get().SetProductUserID(EpicUserId, ProductUserId);
			}

			// Join Room
			OtherPlayer = FPlayerManager::Get().GetPlayer(EpicUserId);
			FinalizeJoinRoom(OtherPlayer, ProductUserId, CurrentRoomName);

			// Query for display name which will get set after query
			FGame::Get().GetUsers()->QueryDisplayName(EpicUserId);

			auto Itr = std::find(ProductUserIdsToQuery.begin(), ProductUserIdsToQuery.end(), ProductUserId);
			if (Itr != ProductUserIdsToQuery.end())
			{
				ProductUserIdsToQuery.erase(Itr);
			}
		}
	}
}

void FVoice::OnEpicAccountDisplayNameRetrieved(FEpicAccountId EpicUserId, std::wstring DisplayName)
{
	FPlayerManager::Get().SetDisplayName(EpicUserId, DisplayName);

	FGameEvent Event(EGameEventType::RoomDataUpdated);
	FGame::Get().OnGameEvent(Event);
}

void FVoice::AddLocalUserRoomTokenData(std::shared_ptr<FVoiceUserRoomTokenData> UserRoomToken)
{
	CachedUserRoomTokenInfo.emplace_back(UserRoomToken);
}

void FVoice::JoinFromCachedRoomTokenData(std::wstring InRoomName, std::wstring ClientBaseUrl)
{
	for (std::shared_ptr<FVoiceUserRoomTokenData>& NextUserToken : CachedUserRoomTokenInfo)
	{
		StartJoinRoom(NextUserToken->ProductUserId, InRoomName, ClientBaseUrl, NextUserToken->Token);
	}
}

void FVoice::JoinRoomWithFriend(FEpicAccountId EpicUserId, FProductUserId ProductUserId, std::wstring DisplayName)
{
	if (LocalEpicUserId.IsValid() && LocalProductUserId.IsValid())
	{
		if (EpicUserId.IsValid() && ProductUserId.IsValid() && !DisplayName.empty())
		{
			PlayerPtr OtherPlayer = FPlayerManager::Get().GetPlayer(EpicUserId);
			if (OtherPlayer == nullptr)
			{
				// Add new player
				FPlayerManager::Get().Add(EpicUserId);
				FPlayerManager::Get().SetProductUserID(EpicUserId, ProductUserId);
				FPlayerManager::Get().SetDisplayName(EpicUserId, DisplayName);
				OtherPlayer = FPlayerManager::Get().GetPlayer(EpicUserId);
			}

			EOS_Presence_GetJoinInfoOptions GetJoinInfoOptions = {};
			GetJoinInfoOptions.ApiVersion = EOS_PRESENCE_GETJOININFO_API_LATEST;
			GetJoinInfoOptions.LocalUserId = LocalEpicUserId;
			GetJoinInfoOptions.TargetUserId = EpicUserId;

			char JoinInfoBuffer[EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH + 1];
			int32_t BufferLength = EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH;

			EOS_HPresence PresenceHandle = EOS_Platform_GetPresenceInterface(FPlatform::GetPlatformHandle());

			EOS_EResult GetJoinInfoResult = EOS_Presence_GetJoinInfo(PresenceHandle, &GetJoinInfoOptions, JoinInfoBuffer, &BufferLength);
			if (GetJoinInfoResult == EOS_EResult::EOS_Success)
			{
				std::string JoinInfoStr = JoinInfoBuffer;

				std::regex JoinInfoRegex(SampleJoinInfoRegex);
				std::smatch JoinInfoMatch;
				if (std::regex_match(JoinInfoStr, JoinInfoMatch, JoinInfoRegex))
				{
					if (JoinInfoMatch.size() == 2)
					{
						std::string RoomNameStr = JoinInfoMatch[1].str();
						if (!RoomNameStr.empty())
						{
							RequestJoinRoom(LocalProductUserId, FStringUtils::Widen(RoomNameStr));
						}
						else
						{
							FDebugLog::LogError(L"Voice (JoinRoomWithFriend): Invalid Room Id!");
						}
					}
				}
			}
			else
			{
				FDebugLog::LogError(L"Voice (JoinRoomWithFriend): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(GetJoinInfoResult)).c_str());
			}
		}
	}
}

void FVoice::SetJoinInfo(const std::string& InRoomName)
{
	// Local buffer to hold the `JoinInfo` string if its used.
	char JoinInfoBuffer[EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH + 1];

	if (!LocalEpicUserId.IsValid())
	{
		FDebugLog::LogError(L"Voice - SetJoinInfo: Local user is invalid!");
		return;
	}

	EOS_HPresence PresenceHandle = EOS_Platform_GetPresenceInterface(FPlatform::GetPlatformHandle());

	EOS_Presence_CreatePresenceModificationOptions CreateModOpt = {};
	CreateModOpt.ApiVersion = EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST;
	CreateModOpt.LocalUserId = LocalEpicUserId;

	EOS_HPresenceModification PresenceModification;
	EOS_EResult Result = EOS_Presence_CreatePresenceModification(PresenceHandle, &CreateModOpt, &PresenceModification);
	if (Result != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Create presence modification failed: %ls.", FStringUtils::Widen(EOS_EResult_ToString(Result)).c_str());
		return;
	}

	EOS_PresenceModification_SetJoinInfoOptions JoinOptions = {};
	JoinOptions.ApiVersion = EOS_PRESENCEMODIFICATION_SETJOININFO_API_LATEST;
	if (InRoomName.length() == 0)
	{
		// Clear the JoinInfo string if there is no local InRoomName.
		JoinOptions.JoinInfo = nullptr;
	}
	else
	{
		// Use the local InRoomName to build a JoinInfo string to share with friends.
		snprintf(JoinInfoBuffer, EOS_PRESENCEMODIFICATION_JOININFO_MAX_LENGTH, SampleJoinInfoFormat, InRoomName.c_str());
		JoinOptions.JoinInfo = JoinInfoBuffer;
	}
	EOS_PresenceModification_SetJoinInfo(PresenceModification, &JoinOptions);

	EOS_Presence_SetPresenceOptions SetOpt = {};
	SetOpt.ApiVersion = EOS_PRESENCE_SETPRESENCE_API_LATEST;
	SetOpt.LocalUserId = LocalEpicUserId;
	SetOpt.PresenceModificationHandle = PresenceModification;
	EOS_Presence_SetPresence(PresenceHandle, &SetOpt, nullptr, FVoice::OnSetPresenceCb);

	EOS_PresenceModification_Release(PresenceModification);
}

void FVoice::LeaveRoom(FProductUserId ProductUserId, std::wstring InRoomName)
{
	if (InRoomName == CurrentRoomName)
	{
		auto Itr = RoomMembers.find(ProductUserId);
		if (Itr != RoomMembers.end())
		{
			RoomMembers.erase(ProductUserId);

			if (LocalProductUserId == ProductUserId)
			{
				// Local player has left so clear out room
				UnsubscribeFromRoomNotifications();

				ClearRoomMembers();

				// Reset name & lock
				CurrentRoomName = L"";
				OwnerLock = "";

				CachedUserRoomTokenInfo.clear();
			}

			FGameEvent Event(EGameEventType::RoomLeft, ProductUserId);
			FGame::Get().OnGameEvent(Event);

			FDebugLog::Log(L"LeaveRoom - Player removed from room - Id: %ls", ProductUserId.ToString().c_str());
		}
	}
	else
	{
		FDebugLog::LogError(L"LeaveRoom - Room name not recognized: %ls", InRoomName.c_str());
	}
}

void FVoice::SetMemberSpeakingState(FProductUserId ProductUserId, bool bIsSpeaking)
{
	auto Itr = RoomMembers.find(ProductUserId);
	if (Itr != RoomMembers.end())
	{
		FDebugLog::Log(L"SetMemberSpeakingState - User: %ls, Speaking: %ld", ProductUserId.ToString().c_str(), bIsSpeaking ? 1 : 0);

		Itr->second.bIsSpeaking = bIsSpeaking;

		FGameEvent Event(EGameEventType::RoomDataUpdated);
		FGame::Get().OnGameEvent(Event);
	}
}

void FVoice::SetMemberMuteState(FProductUserId ProductUserId, bool bIsMuted)
{
	auto Itr = RoomMembers.find(ProductUserId);
	if (Itr != RoomMembers.end())
	{
		FDebugLog::Log(L"SetMemberMuteState - User: %ls, Mute: %ld", ProductUserId.ToString().c_str(), bIsMuted ? 1 : 0);

		Itr->second.bIsMuted = bIsMuted;

		FGameEvent Event(EGameEventType::RoomDataUpdated);
		FGame::Get().OnGameEvent(Event);
	}
}

void FVoice::SetMemberRemoteMuteState(FProductUserId ProductUserId, bool bIsMuted)
{
	auto Itr = RoomMembers.find(ProductUserId);
	if (Itr != RoomMembers.end())
	{
		FDebugLog::Log(L"SetMemberRemoteMuteState - User: %ls, Mute: %ld", ProductUserId.ToString().c_str(), bIsMuted ? 1 : 0);

		Itr->second.bIsRemoteMuted = bIsMuted;

		FGameEvent Event(EGameEventType::RoomDataUpdated);
		FGame::Get().OnGameEvent(Event);
	}
}

void FVoice::SetMemberVolume(FProductUserId ProductUserId, float Volume)
{
	auto Itr = RoomMembers.find(ProductUserId);
	if (Itr != RoomMembers.end())
	{
		FDebugLog::Log(L"SetMemberVolume - User: %ls, Volume: %f", ProductUserId.ToString().c_str(), Volume);

		Itr->second.Volume = Volume;

		FGameEvent Event(EGameEventType::RoomDataUpdated);
		FGame::Get().OnGameEvent(Event);
	}
}

void FVoice::SetAudioInputDeviceFromName(std::wstring DeviceName)
{
	for (uint32_t Index = 0; Index < static_cast<uint32_t>(AudioInputDeviceNames.size()); Index++)
	{
		if (AudioInputDeviceNames[Index] == DeviceName)
		{
			const std::wstring DeviceId = AudioInputDeviceIds[Index];
			FDebugLog::Log(L"Voice: setting input device to %ls : %ls", DeviceName.c_str(), DeviceId.c_str());
			SetAudioInputDevice(DeviceId);
			return;
		}
	}
}

void FVoice::SetAudioOutputDeviceFromName(std::wstring DeviceName)
{
	for (uint32_t Index = 0; Index < static_cast<uint32_t>(AudioOutputDeviceNames.size()); Index++)
	{
		if (AudioOutputDeviceNames[Index] == DeviceName)
		{
			const std::wstring DeviceId = AudioOutputDeviceIds[Index];
			FDebugLog::Log(L"Voice: setting output device to %ls : %ls", DeviceName.c_str(), DeviceId.c_str());
			SetAudioOutputDevice(DeviceId);
			return;
		}
	}
}

void FVoice::SetAudioInputDevice(const std::wstring& DeviceId)
{
	if (LocalProductUserId.IsValid())
	{
		std::string NarrowDeviceId = FStringUtils::Narrow(DeviceId);

		EOS_RTCAudio_SetInputDeviceSettingsOptions InputDeviceSettingsOptions = {};
		InputDeviceSettingsOptions.ApiVersion = EOS_RTCAUDIO_SETINPUTDEVICESETTINGS_API_LATEST;
		InputDeviceSettingsOptions.LocalUserId = LocalProductUserId;
		InputDeviceSettingsOptions.RealDeviceId = NarrowDeviceId.c_str();
		InputDeviceSettingsOptions.bPlatformAEC = EOS_FALSE;

		EOS_RTCAudio_SetInputDeviceSettings(RTCAudioHandle, &InputDeviceSettingsOptions, NULL, OnSetAudioInputDeviceCb);
	}
}

void FVoice::SetAudioOutputDevice(const std::wstring& DeviceId)
{
	if (LocalProductUserId.IsValid())
	{
		std::string NarrowDeviceId = FStringUtils::Narrow(DeviceId);

		EOS_RTCAudio_SetOutputDeviceSettingsOptions AudioOutputSettingsOptions = {};
		AudioOutputSettingsOptions.ApiVersion = EOS_RTCAUDIO_SETOUTPUTDEVICESETTINGS_API_LATEST;
		AudioOutputSettingsOptions.LocalUserId = LocalProductUserId;
		AudioOutputSettingsOptions.RealDeviceId = NarrowDeviceId.c_str();

		EOS_RTCAudio_SetOutputDeviceSettings(RTCAudioHandle, &AudioOutputSettingsOptions, NULL, OnSetAudioOutputDeviceCb);
	}
}

void FVoice::UpdateReceivingVolume(const std::wstring& InVolume)
{
	float Volume = 50;
	try
	{
		Volume = std::stof(InVolume);
	}
	catch (...)
	{
		return; // wrong format, out of range, etc
	}
	
	std::string NarrowRoomName = FStringUtils::Narrow(CurrentRoomName);

	EOS_RTCAudio_UpdateReceivingVolumeOptions ReceivingVolumeOptions{};

	ReceivingVolumeOptions.ApiVersion = EOS_RTCAUDIO_UPDATERECEIVINGVOLUME_API_LATEST;
	ReceivingVolumeOptions.LocalUserId = LocalProductUserId;
	ReceivingVolumeOptions.RoomName = NarrowRoomName.c_str();
	ReceivingVolumeOptions.Volume = Volume;

	EOS_RTCAudio_UpdateReceivingVolume(RTCAudioHandle, &ReceivingVolumeOptions, nullptr, OnUpdateReceivingVolumeCb);
}

void FVoice::UpdateParticipantVolume(FProductUserId ProductUserId, const std::wstring& InVolume)
{
	float Volume = 50;
	try
	{
		Volume = std::stof(InVolume);
	}
	catch (...)
	{
		return; // wrong format, out of range, etc
	}

	std::string NarrowRoomName = FStringUtils::Narrow(CurrentRoomName);

	EOS_RTCAudio_UpdateParticipantVolumeOptions ParticipantVolumeOptions{};

	ParticipantVolumeOptions.ApiVersion = EOS_RTCAUDIO_UPDATEPARTICIPANTVOLUME_API_LATEST;
	ParticipantVolumeOptions.LocalUserId = LocalProductUserId;
	ParticipantVolumeOptions.ParticipantId = ProductUserId;
	ParticipantVolumeOptions.RoomName = NarrowRoomName.c_str();
	ParticipantVolumeOptions.Volume = Volume;

	EOS_RTCAudio_UpdateParticipantVolume(RTCAudioHandle, &ParticipantVolumeOptions, nullptr, OnUpdateParticipantVolumeCb);
}


void FVoice::OnDisconnected(FProductUserId LocalProductUserId, std::wstring InRoomName)
{
	LeaveRoom(LocalProductUserId, InRoomName);
}

void FVoice::OnParticipantJoined(FProductUserId ProductUserId, std::wstring InRoomName)
{
	JoinRoom(ProductUserId, InRoomName);
}

void FVoice::OnParticipantLeft(FProductUserId ProductUserId, std::wstring InRoomName)
{
	LeaveRoom(ProductUserId, InRoomName);
}

void FVoice::OnParticipantAudioUpdated(FProductUserId ProductUserId, std::wstring InRoomName, EOS_ERTCAudioStatus InAudioStatus, bool bIsSpeaking)
{
	if (InRoomName == CurrentRoomName)
	{
		SetMemberSpeakingState(ProductUserId, bIsSpeaking);
		SetMemberMuteState(ProductUserId, InAudioStatus != EOS_ERTCAudioStatus::EOS_RTCAS_Enabled);
		SetMemberRemoteMuteState(ProductUserId, InAudioStatus == EOS_ERTCAudioStatus::EOS_RTCAS_AdminDisabled);
	}
}

void FVoice::OnAudioDevicesChanged()
{
	UpdateAudioInputDevices();
	UpdateAudioOutputDevices();
}

void EOS_CALL FVoice::OnJoinRoomCb(const EOS_RTC_JoinRoomCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Voice - Join Room Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	std::string RoomNameStr = Data->RoomName;
	std::wstring WideRoomName = FStringUtils::Widen(RoomNameStr);

	FGame::Get().GetVoice()->JoinRoom(Data->LocalUserId, WideRoomName);
}

void EOS_CALL FVoice::OnLeaveRoomCb(const EOS_RTC_LeaveRoomCallbackInfo* Data)
{
	assert(Data != NULL);

	if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}

	if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"[EOS SDK] Voice - Leave Room Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		return;
	}

	std::string RoomNameStr = Data->RoomName;
	std::wstring WideRoomName = FStringUtils::Widen(RoomNameStr);

	FGame::Get().GetVoice()->LeaveRoom(Data->LocalUserId, WideRoomName);
}

void EOS_CALL FVoice::OnSetPresenceCb(const EOS_Presence_SetPresenceCallbackInfo* Data)
{
	if (!Data)
	{
		FDebugLog::LogError(L"Voice (OnSetPresenceCallback): EOS_Presence_SetPresenceCallbackInfo is null");
	}
	else if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
	{
		// Operation is retrying so it is not complete yet
		return;
	}
	else if (Data->ResultCode != EOS_EResult::EOS_Success)
	{
		FDebugLog::LogError(L"Voice (OnSetPresenceCallback): error code: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
	}
	else
	{
		FDebugLog::Log(L"Voice: set presence successfully.");
	}
}

void EOS_CALL FVoice::OnDisconnectedCb(const EOS_RTC_DisconnectedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Voice (OnDisconnectedCallback)");

		std::string RoomNameStr = Data->RoomName;

		FGame::Get().GetVoice()->OnDisconnected(Data->LocalUserId, FStringUtils::Widen(RoomNameStr));
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnDisconnected): EOS_RTC_DisconnectedCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnParticipantStatusChangedCb(const EOS_RTC_ParticipantStatusChangedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Voice (OnParticipantStatusChangedCb)");

		std::string RoomNameStr = Data->RoomName;

		if (Data->ParticipantStatus == EOS_ERTCParticipantStatus::EOS_RTCPS_Joined)
		{
			FGame::Get().GetVoice()->OnParticipantJoined(Data->ParticipantId, FStringUtils::Widen(RoomNameStr));
		}
		else if (Data->ParticipantStatus == EOS_ERTCParticipantStatus::EOS_RTCPS_Left)
		{
			FGame::Get().GetVoice()->OnParticipantLeft(Data->ParticipantId, FStringUtils::Widen(RoomNameStr));
		}
		else
		{
			FDebugLog::LogError(L"Voice (OnParticipantStatusChangedCb): ParticipantStatus is invalid");
			assert(false);
		}
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnParticipantStatusChangedCb): EOS_RTC_ParticipantStatusChangedCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnParticipantAudioUpdatedCb(const EOS_RTCAudio_ParticipantUpdatedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Voice (OnParticipantAudioUpdatedCb)");

		std::string RoomNameStr = Data->RoomName;

		FGame::Get().GetVoice()->OnParticipantAudioUpdated(Data->ParticipantId,
			FStringUtils::Widen(RoomNameStr),
			Data->AudioStatus,
			Data->bSpeaking == EOS_TRUE);
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnParticipantAudioUpdatedCb): EOS_RTCAudio_ParticipantUpdatedCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnAudioDevicesChangedCb(const EOS_RTCAudio_AudioDevicesChangedCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Voice (OnAudioDevicesChangedCb)");

		FGame::Get().GetVoice()->OnAudioDevicesChanged();
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnAudioDevicesChangedCb): EOS_RTCAudio_AudioDevicesChangedCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnAudioUpdateSendingCb(const EOS_RTCAudio_UpdateSendingCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Voice (OnAudioUpdateSendingCb)");
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnAudioUpdateSendingCb): EOS_RTCAudio_UpdateSendingCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnAudioUpdateReceivingCb(const EOS_RTCAudio_UpdateReceivingCallbackInfo* Data)
{
	if (Data)
	{
		FDebugLog::Log(L"Voice (OnAudioUpdateReceivingCb)");
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnAudioUpdateReceivingCb): EOS_RTCAudio_UpdateReceivingCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnUpdateReceivingVolumeCb(const EOS_RTCAudio_UpdateReceivingVolumeCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Voice (OnUpdateReceivingVolumeCb) - Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Voice (OnUpdateReceivingVolumeCb) Volume: %f", Data->Volume);
		}
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnUpdateReceivingVolumeCb): EOS_RTCAudio_UpdateReceivingVolumeCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnUpdateParticipantVolumeCb(const EOS_RTCAudio_UpdateParticipantVolumeCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Voice (OnUpdateParticipantVolumeCb) - Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Voice (OnUpdateParticipantVolumeCb) Volume: %f", Data->Volume);
			FGame::Get().GetVoice()->SetMemberVolume(Data->ParticipantId, Data->Volume);
		}
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnUpdateParticipantVolumeCb): EOS_RTCAudio_UpdateParticipantVolumeCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnInputDevicesInformationCb(const EOS_RTCAudio_OnQueryInputDevicesInformationCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Voice (OnInputDevicesInformationCb) - Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FGame::Get().GetVoice()->GetAudioInputDevices();
		}
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnInputDevicesInformationCb): EOS_RTCAudio_OnQueryInputDevicesInformationCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnOutputDevicesInformationCb(const EOS_RTCAudio_OnQueryOutputDevicesInformationCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"Voice (OnOutputDevicesInformationCb) - Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FGame::Get().GetVoice()->GetAudioOutputDevices();
		}
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnOutputDevicesInformationCb): EOS_RTCAudio_OnQueryOutputDevicesInformationCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnSetAudioInputDeviceCb(const EOS_RTCAudio_OnSetInputDeviceSettingsCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"[EOS SDK] Voice - Failed to update audio input - Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Voice (OnSetAudioInputDeviceCb) - RealDeviceId: %ls", FStringUtils::Widen(Data->RealDeviceId).c_str());
		}
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnSetAudioInputDeviceCb): EOS_RTCAudio_OnSetInputDeviceSettingsCallbackInfo is null");
	}
}

void EOS_CALL FVoice::OnSetAudioOutputDeviceCb(const EOS_RTCAudio_OnSetOutputDeviceSettingsCallbackInfo* Data)
{
	if (Data)
	{
		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
		{
			// Operation is retrying so it is not complete yet
			return;
		}
		else if (Data->ResultCode != EOS_EResult::EOS_Success)
		{
			FDebugLog::LogError(L"[EOS SDK] Voice - Failed to update audio output - Error: %ls", FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
		}
		else
		{
			FDebugLog::Log(L"Voice (OnSetAudioOutputDeviceCb) - RealDeviceId: %ls", FStringUtils::Widen(Data->RealDeviceId).c_str());
		}
	}
	else
	{
		FDebugLog::LogError(L"Voice (OnSetAudioOutputDeviceCb): EOS_RTCAudio_OnSetOutputDeviceSettingsCallbackInfo is null");
	}
}


```

`EAC_SDK/Samples/Voice/Client/Source/Voice.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Player.h"

#include <eos_sdk.h>
#include <eos_rtc_admin.h>
#include <eos_rtc_audio.h>

/**
 * Attributes for each member of a room
 */
struct FVoiceRoomMember
{
	FVoiceRoomMember() = default;

	PlayerPtr Player = nullptr;
	float Volume = 50.0f;
	bool bIsOwner = false;
	bool bIsLocal = false;
	bool bIsSpeaking = false;
	bool bIsMuted = false;
	bool bIsRemoteMuted = false;
};

/**
 * Structure to store cached data for joining rooms via a room token
 */
struct FVoiceUserRoomTokenData
{
	FVoiceUserRoomTokenData() = default;

	EOS_ProductUserId ProductUserId;
	std::string Token;
};

/**
* Manages voice.
*/
class FVoice
{
public:
	/**
	* Constructor
	*/
	FVoice() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FVoice(FVoice const&) = delete;
	FVoice& operator=(FVoice const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FVoice();

	void Init();

	void OnShutdown();

	void Update();

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

	/** Collection of members in a room */
	std::map<EOS_ProductUserId, FVoiceRoomMember> GetRoomMembers() { return RoomMembers; }

	/** True if user is a member of the room */
	bool IsMember(FProductUserId ProductUserId);

	/** Clears saves collection of room members */
	void ClearRoomMembers();

	/** Mutes / unmutes a member in room toggling previous state */
	void LocalToggleMuteMember(FProductUserId ProductUserId);

	/**
	 * Starts room joining process by querying for a room token
	 */
	void QueryJoinRoomToken(FProductUserId ProductUserId, std::wstring InRoomName);

	/**
	 * Mutes / unmutes a member remotely in room toggling previous state
	 */
	void RemoteToggleMuteMember(FProductUserId ProductUserId);

	/**
	 * Mutes / unmutes a member remotely in room
	 */
	void RemoteMuteMember(FProductUserId ProductUserId, bool bIsMuted);

	/**
	 * Kick a member from room
	 */
	void KickMember(FProductUserId ProductUserId);

	/**
	 * Heartbeats the active voice session
	 */
	void HeartbeatVoiceSession(FProductUserId ProductUserId, const std::string& OwnerLock);

	/** Sets speaking state for a member */
	void SetMemberSpeakingState(FProductUserId ProductUserId, bool bIsMuted);

	/** Sets mute state for a member */
	void SetMemberMuteState(FProductUserId ProductUserId, bool bIsMuted);

	/** Sets remote mute status for member */
	void SetMemberRemoteMuteState(FProductUserId ProductUserId, bool bIsMuted);

	/** Sets volume for member */
	void SetMemberVolume(FProductUserId ProductUserId, float Volume);

	/** Get collection of audio input devices */
	std::vector<std::wstring> GetAudioInputDeviceNames() { return AudioInputDeviceNames; }

	/** Get collection of audio output devices */
	std::vector<std::wstring> GetAudioOutputDeviceNames() { return AudioOutputDeviceNames; }

	/** Sets the active audio input device */
	void SetAudioInputDeviceFromName(std::wstring DeviceName);

	/** Sets the active audio output device */
	void SetAudioOutputDeviceFromName(std::wstring DeviceName);

	/** Sets owner lock string */
	void SetOwnerLock(std::string InOwnerLock) { OwnerLock = InOwnerLock; }

	/** Set the output room's volume */
	void UpdateReceivingVolume(const std::wstring& InVolume);
	
	/** Set participant output volume */
	void UpdateParticipantVolume(FProductUserId ProductUserId, const std::wstring& InVolume);

private:
	/**
	 * Called when a user has logged in
	 */
	void OnLoggedIn(FEpicAccountId UserId);

	/**
	 * Called when a user has logged out
	 */
	void OnLoggedOut(FEpicAccountId UserId);

	/**
	 * Called when a user connect has logged in
	 */
	void OnUserConnectLoggedIn(FProductUserId ProductUserId);

	/**
	 * Subscribe to room-based notifications
	 */
	void SubscribeToRoomNotifications(std::wstring InRoomName);

	/**
	 * Unsubscribe from room-based notifications
	 */
	void UnsubscribeFromRoomNotifications();

	/**
	 * Subscribe to room-independent notifications
	 */
	void SubscribeToNotifications();

	/**
	 * Unsubscribe from room-based notifications
	 */
	void UnsubscribeFromNotifications();

	/**
	 * Get available audio input devices
	 */
	void GetAudioInputDevices();

	/**
	 * Update list available audio input devices
	 */
	void UpdateAudioInputDevices();

	/**
	 * Get available audio output devices
	 */
	void GetAudioOutputDevices();

	/**
	 * Update list available audio output devices
	 */
	void UpdateAudioOutputDevices();

	/**
	 * Requests joining a room via trusted server
	 */
	void RequestJoinRoom(FProductUserId ProductUserId, std::wstring InRoomName);

	/**
	 * Starts room joining process by querying to join a room
	 */
	void QueryJoinRoom(FProductUserId ProductUserId, std::wstring InRoomName, std::wstring InClientBaseUrl, std::string InToken);

	/**
	 * Starts room leaving process by querying to leave a room
	 */
	void QueryLeaveRoom(FProductUserId ProductUserId, std::wstring InRoomName);

	/**
	 * Starts joining a given room by name via trusted server
	 */
	void StartJoinRoom(FProductUserId ProductUserId, std::wstring InRoomName, std::wstring InClientBaseUrl, std::string InToken);

	/**
	 * Joins a given room by name
	 */
	void JoinRoom(FProductUserId ProductUserId, std::wstring InRoomName);

	/** Finalizes room joining process where player is ready to be added to room members */
	void FinalizeJoinRoom(PlayerPtr Player, FProductUserId ProductUserId, std::wstring InRoomName);

	/** Queries for a new player's information before they can be added to room members */
	void QueryPlayerInfo(FProductUserId LocalUserId, FProductUserId OtherUserId);

	/** EpicAccountId data has been retrieved for a new player */
	void OnEpicAccountsMappingRetrieved();

	/** Display name has been retrieved for a new player */
	void OnEpicAccountDisplayNameRetrieved(FEpicAccountId EpicUserId, std::wstring DisplayName);

	/**
	 * Add user room token data to locally cached data
	 */
	void AddLocalUserRoomTokenData(std::shared_ptr<FVoiceUserRoomTokenData> UserRoomToken);

	/**
	 * Join each participant in cached data to room
	 */
	void JoinFromCachedRoomTokenData(std::wstring InRoomName, std::wstring ClientBaseUrl);

	/**
	 * Leaves current room
	 */
	void LeaveRoom(FProductUserId ProductUserId, std::wstring InRoomName);

	/** Starts the join room process based on the room the friend with given account IDs is in using their presence join info */
	void JoinRoomWithFriend(FEpicAccountId EpicUserId, FProductUserId ProductUserId, std::wstring DisplayName);

	/** Clear saved owner lock */
	void ClearOwnerLock() { OwnerLock = std::string(); }

	/** Sets the presence join info to include the room id */
	void SetJoinInfo(const std::string& InRoomName);

	/** Sets audio input device based on select audio input device */
	void SetAudioInputDevice(const std::wstring& DeviceId);

	/** Sets audio output device based on select audio output device */
	void SetAudioOutputDevice(const std::wstring& DeviceId);

	/** Called when local user is disconnected */
	void OnDisconnected(FProductUserId LocalProductUserId, std::wstring InRoomName);

	/** Called when a user joins a room */
	void OnParticipantJoined(FProductUserId ProductUserId, std::wstring InRoomName);

	/** Called when a user leaves a room */
	void OnParticipantLeft(FProductUserId ProductUserId, std::wstring InRoomName);

	/** Called when a user in a room has their audio status updated */
	void OnParticipantAudioUpdated(FProductUserId ProductUserId, std::wstring InRoomName, EOS_ERTCAudioStatus InAudioStatus, bool bIsSpeaking);

	/** Called when audio devices have been updated */
	void OnAudioDevicesChanged();

	//Callbacks
	/**
	 * Callback that is fired on join room token query
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnQueryJoinRoomTokenCb(const EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo* Data);

	/**
	 * Callback that is fired on join room query
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnJoinRoomCb(const EOS_RTC_JoinRoomCallbackInfo* Data);

	/**
	 * Callback that is fired on leave room query
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnLeaveRoomCb(const EOS_RTC_LeaveRoomCallbackInfo* Data);

	/**
	 * Callback that is fired on setting presence with join info
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnSetPresenceCb(const EOS_Presence_SetPresenceCallbackInfo* Data);

	/**
	 * Callback that is fired when local user is disconnected from room
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnDisconnectedCb(const EOS_RTC_DisconnectedCallbackInfo* Data);

	/**
	 * Callback that is fired when a user's status changes (user joins or leaves a room)
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnParticipantStatusChangedCb(const EOS_RTC_ParticipantStatusChangedCallbackInfo* Data);

	/**
	 * Callback that is fired when a user's audio state is updated
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnParticipantAudioUpdatedCb(const EOS_RTCAudio_ParticipantUpdatedCallbackInfo* Data);

	/**
	 * Callback that is fired when audio devices have been changed
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnAudioDevicesChangedCb(const EOS_RTCAudio_AudioDevicesChangedCallbackInfo* Data);

	/**
	 * Callback that is fired when sending audio state has been updated
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnAudioUpdateSendingCb(const EOS_RTCAudio_UpdateSendingCallbackInfo* Data);

	/**
	 * Callback that is fired when receiving audio state has been updated
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnAudioUpdateReceivingCb(const EOS_RTCAudio_UpdateReceivingCallbackInfo* Data);

	/**
	 * Callback that is fired on update receiving room volume
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnUpdateReceivingVolumeCb(const EOS_RTCAudio_UpdateReceivingVolumeCallbackInfo* Data);

	/**
	 * Callback that is fired on update participant's room volume
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnUpdateParticipantVolumeCb(const EOS_RTCAudio_UpdateParticipantVolumeCallbackInfo* Data);

	/**
	 * Callback that is fired on update list of input audio devices
	 *
	 * @param Data - out parameter
	 */
	static void EOS_CALL OnInputDevicesInformationCb(const EOS_RTCAudio_OnQueryInputDevicesInformationCallbackInfo* Data);

	/**
	 * Callback that is fired on update list of output audio devices
	*
	* @param Data - out parameter
	*/
	static void EOS_CALL OnOutputDevicesInformationCb(const EOS_RTCAudio_OnQueryOutputDevicesInformationCallbackInfo* Data);

	/**
	 * Callback that is fired on finish setting audio input device
	*
	* @param Data - out parameter
	*/
	static void EOS_CALL OnSetAudioInputDeviceCb(const EOS_RTCAudio_OnSetInputDeviceSettingsCallbackInfo* Data);

	/**
	 * Callback that is fired on finish setting audio output device
	*
	* @param Data - out parameter
	*/
	static void EOS_CALL OnSetAudioOutputDeviceCb(const EOS_RTCAudio_OnSetOutputDeviceSettingsCallbackInfo* Data);

	/** Handle to EOS SDK RTC system */
	EOS_HRTC RTCHandle;

	/** Handle to EOS SDK RTC Admin system */
	EOS_HRTCAdmin RTCAdminHandle;

	/** Handle to EOS SDK RTC Audio system */
	EOS_HRTCAudio RTCAudioHandle;

	/** URL for trusted server */
	std::wstring TrustedServerURL;

	/** Port for trusted server */
	std::wstring TrustedServerPort;

	/** Full URL for trusted server */
	std::wstring FullTrustedServerURL;

	/** Current room name local player has joined */
	std::wstring CurrentRoomName;

	/** Members of the current room */
	std::map<EOS_ProductUserId, FVoiceRoomMember> RoomMembers;

	/** Cached room token info */
	std::vector<std::shared_ptr<FVoiceUserRoomTokenData>> CachedUserRoomTokenInfo;

	/** Epic User Id of local user */
	FEpicAccountId LocalEpicUserId;

	/** Product User Id of local user */
	FProductUserId LocalProductUserId;

	/** Product User Ids that are currently being queried to get EpicAccountId and Display Name */
	std::vector<FProductUserId> ProductUserIdsToQuery;

	/** Names of audio input devices available */
	std::vector<std::wstring> AudioInputDeviceNames;

	/** Names of audio input devices available */
	std::vector<std::wstring> AudioOutputDeviceNames;

	/** IDs of audio input devices available */
	std::vector<std::wstring> AudioInputDeviceIds;

	/** IDs of audio output devices available */
	std::vector<std::wstring> AudioOutputDeviceIds;

	/** Body param for QueryJoinRoomToken request */
	std::string QueryJoinRoomTokenRequestBody;

	/** Body param for Kick request */
	std::string KickRequestBody;

	/** Body param for Mute request */
	std::string MuteRequestBody;

	/** Body param for Mute request */
	std::string HeartbeatRequestBody;

	/** If non-empty the local client is the owner of the current room */
	std::string OwnerLock;

	// Notifications
	EOS_NotificationId DisconnectedNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId ParticipantStatusChangedNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId ParticipantAudioUpdatedNotification = EOS_INVALID_NOTIFICATIONID;
	EOS_NotificationId AudioDevicesChangedNotification = EOS_INVALID_NOTIFICATIONID;

	std::chrono::steady_clock::time_point NextHeartbeat;
};

```

`EAC_SDK/Samples/Voice/Client/Source/VoiceDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "TextLabel.h"
#include "Button.h"
#include "UIEvent.h"
#include "GameEvent.h"
#include "AccountHelpers.h"
#include "Player.h"
#include "Sprite.h"
#include "DebugLog.h"
#include "Checkbox.h"
#include "Users.h"
#include "VoiceRoomMemberTableRowView.h"
#include "VoiceDialog.h"

static FVoiceRoomMemberTableRowData BuildMemberRow(const FVoiceRoomMember& Member)
{
	FVoiceRoomMemberTableRowData Result;

	std::wstring MemberName = Member.Player->GetDisplayName().empty() ? L"?" : Member.Player->GetDisplayName();
	Result.DisplayName = MemberName;

	Result.UserId = Member.Player->GetProductUserID();
	Result.Values[FVoiceRoomMemberTableRowData::EValue::DisplayName] = MemberName;
	Result.Volume = Member.Volume;

	Result.bEditablesAvailable[FVoiceRoomMemberTableRowData::EEditableValue::Volume] = !Member.bIsLocal;

	Result.bActionsAvailable[FVoiceRoomMemberTableRowData::EAction::Status] = false;
	Result.bActionsAvailable[FVoiceRoomMemberTableRowData::EAction::Mute] = !Member.bIsRemoteMuted;
	Result.bActionsAvailable[FVoiceRoomMemberTableRowData::EAction::RemoteMute] = Member.bIsOwner && !Member.bIsLocal;
	Result.bActionsAvailable[FVoiceRoomMemberTableRowData::EAction::Kick] = Member.bIsOwner && !Member.bIsLocal;

	Result.bIsSpeaking = Member.bIsSpeaking;
	Result.bIsMuted = Member.bIsMuted;
	Result.bIsRemoteMuted = Member.bIsRemoteMuted;

	return Result;
}

FVoiceDialog::FVoiceDialog(
	Vector2 DialogPos,
	Vector2 DialogSize,
	UILayer DialogLayer,
	FontPtr DialogNormalFont,
	FontPtr DialogSmallFont,
	FontPtr DialogTinyFont) :
	FDialog(DialogPos, DialogSize, DialogLayer)
{
	BackgroundImage = std::make_shared<FSpriteWidget>(
		DialogPos,
		DialogSize,
		DialogLayer,
		L"Assets/friends.dds");

	TitleLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Vector2(DialogSize.x, 30.f),
		DialogLayer - 1,
		L"ROOM MEMBERS",
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	TitleLabel->SetBorderColor(Color::UIBorderGrey);
	TitleLabel->SetFont(DialogNormalFont);

	RoomNameText = std::make_shared<FTextViewWidget>(
		TitleLabel->GetPosition() + Vector2(410.0f, 0.0f),
		Vector2(100, 30),
		Layer - 1,
		L"",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FColor(0.03f, 0.03f, 0.03f, 1.f));
	RoomNameText->SetBorderColor(Color::UIBorderGrey);
	RoomNameText->SetCanSelectText(true);
	RoomNameText->SetBorderOffsets(Vector2(1.0f, 1.0f));
	AddWidget(RoomNameText);

	JoinRoomButton = std::make_shared<FButtonWidget>(
		Vector2(DialogPos.x + 5.0f, DialogPos.y + TitleLabel->GetSize().y + 5.0f),
		Vector2(100.0f, 20.f),
		Layer - 1,
		L"JOIN",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		Color::UIButtonBlue
		);
	JoinRoomButton->SetBackgroundColors(assets::DefaultButtonColors);
	JoinRoomButton->SetOnPressedCallback([this]()
	{
		if (VoiceRoomMembersList)
		{
			PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
			if (Player)
			{
				if (RoomNameText)
				{
					FGameEvent Event(EGameEventType::JoinRoom, Player->GetProductUserID(), RoomNameText->GetLine(0));
					FGame::Get().OnGameEvent(Event);
				}
				else
				{
					FGameEvent Event(EGameEventType::JoinRoom, Player->GetProductUserID(), std::wstring());
					FGame::Get().OnGameEvent(Event);
				}
			}
		}
	});
	JoinRoomButton->Disable();

	LeaveRoomButton = std::make_shared<FButtonWidget>(
		Vector2(DialogPos.x + 5.0f, DialogPos.y + TitleLabel->GetSize().y + 5.0f),
		Vector2(100.0f, 20.f),
		Layer - 1,
		L"LEAVE",
		assets::DefaultButtonAssets,
		DialogNormalFont,
		Color::UIButtonBlue
		);
	//LeaveRoomButton->SetBorderColor(Color::UIBorderGrey);
	LeaveRoomButton->SetBackgroundColors(assets::DefaultButtonColors);
	LeaveRoomButton->SetOnPressedCallback([this]()
	{
		PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
		if (Player)
		{
			FGameEvent Event(EGameEventType::LeaveRoom, Player->GetProductUserID());
			FGame::Get().OnGameEvent(Event);
		}
	});
	LeaveRoomButton->Disable();

	OutputVolumeLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Vector2(DialogSize.x, 30.f),
		DialogLayer - 1,
		L"Volume",
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	OutputVolumeLabel->SetFont(DialogNormalFont);

	OutputVolumeText = std::make_shared<FTextFieldWidget>(
		Vector2(DialogPos.x + 5.0f, DialogPos.y + TitleLabel->GetSize().y + 5.0f),
		Vector2(100.0f, 20.f),
		Layer - 1,
		L"50",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FTextFieldWidget::EInputType::Normal
		);

	OutputVolumeText->SetBorderColor(Color::UIBorderGrey);
	OutputVolumeText->SetOnEnterPressedCallback([](const std::wstring& Text) {
		if (!Text.empty())
		{
			PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
			if (Player)
			{
				FGameEvent Event(EGameEventType::UpdateReceivingVolume, Text);
				FGame::Get().OnGameEvent(Event);
			}
		}
	});

	OutputParticipantVolumeLabel = std::make_shared<FTextLabelWidget>(
		DialogPos,
		Vector2(DialogSize.x, 30.f),
		DialogLayer - 1,
		L"Part. vol.",
		L"",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	OutputParticipantVolumeLabel->SetFont(DialogNormalFont);

	OutputParticipantVolumeText = std::make_shared<FTextFieldWidget>(
		Vector2(DialogPos.x + 5.0f, DialogPos.y + TitleLabel->GetSize().y + 5.0f),
		Vector2(100.0f, 20.f),
		Layer - 1,
		L"50",
		L"Assets/textfield.dds",
		DialogNormalFont,
		FTextFieldWidget::EInputType::Normal
		);

	OutputParticipantVolumeText->SetBorderColor(Color::UIBorderGrey);
	OutputParticipantVolumeText->SetOnEnterPressedCallback([](const std::wstring& Text) {
		if (!Text.empty())
		{
			PlayerPtr Player = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
			if (Player)
			{
				FGameEvent Event(EGameEventType::UpdateParticipantVolume, FProductUserId(), Text);
				FGame::Get().OnGameEvent(Event);
			}
		}
	});

	Vector2 MainPartPosition = Vector2(DialogPos.x + 5.0f, DialogPos.y + TitleLabel->GetSize().y + 5.0f);

	FVoiceRoomMemberTableRowData Labels;
	Labels.Values[FVoiceRoomMemberTableRowData::EValue::DisplayName] = L"Member Name";
	Labels.Edits[FVoiceRoomMemberTableRowData::EEditableValue::Volume] = L"Volume";

	VoiceRoomMembersList = std::make_shared<FVoiceRoomMembersListWidget>(
		MainPartPosition + Vector2(0.0f, 30.0f),
		Vector2(GetSize().x - 10.0f, GetSize().y - (MainPartPosition.y - GetPosition().y) - 35.0f),
		Layer,
		L"Room:", //Title text
		10.0f, //scroller width
		std::vector<FVoiceRoomMemberTableRowData>(),
		Labels
		);
	VoiceRoomMembersList->SetFonts(DialogSmallFont, DialogNormalFont);
}

void FVoiceDialog::Update()
{
	if (!IsShown())
	{
		return;
	}

	VoiceRoomMembersList->Show();

	FDialog::Update();
}

void FVoiceDialog::Create()
{
	if (BackgroundImage) BackgroundImage->Create();
	if (TitleLabel) TitleLabel->Create();
	if (VoiceRoomMembersList) VoiceRoomMembersList->Create();
	if (RoomNameText) RoomNameText->Create();
	if (JoinRoomButton) JoinRoomButton->Create();
	if (LeaveRoomButton) LeaveRoomButton->Create();
	if (OutputVolumeLabel) OutputVolumeLabel->Create();
	if (OutputVolumeText) OutputVolumeText->Create();
	if (OutputParticipantVolumeLabel) OutputParticipantVolumeLabel->Create();
	if (OutputParticipantVolumeText) OutputParticipantVolumeText->Create();

	AddWidget(BackgroundImage);
	AddWidget(TitleLabel);
	AddWidget(VoiceRoomMembersList);
	AddWidget(RoomNameText);
	AddWidget(JoinRoomButton);
	AddWidget(LeaveRoomButton);
	AddWidget(OutputVolumeLabel);
	AddWidget(OutputVolumeText);
	AddWidget(OutputParticipantVolumeLabel);
	AddWidget(OutputParticipantVolumeText);

	Disable();
}

void FVoiceDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (BackgroundImage) BackgroundImage->SetPosition(Pos);
	if (TitleLabel) TitleLabel->SetPosition(Pos);
	if (RoomNameText) RoomNameText->SetPosition(Pos + Vector2(65.f, 38.f));
	if (JoinRoomButton) JoinRoomButton->SetPosition(RoomNameText->GetPosition() + Vector2(RoomNameText->GetSize().x + 5.f, 0.f));
	if (LeaveRoomButton) LeaveRoomButton->SetPosition(JoinRoomButton->GetPosition() + Vector2(JoinRoomButton->GetSize().x + 2.f, 0.f));
	if (OutputVolumeLabel) OutputVolumeLabel->SetPosition(LeaveRoomButton->GetPosition() + Vector2(LeaveRoomButton->GetSize().x + 2.f, 0.f));
	if (OutputVolumeText) OutputVolumeText->SetPosition(OutputVolumeLabel->GetPosition() + Vector2(OutputVolumeLabel->GetSize().x + 2.f, 0.f));
	if (OutputParticipantVolumeLabel) OutputParticipantVolumeLabel->SetPosition(OutputVolumeText->GetPosition() + Vector2(OutputVolumeText->GetSize().x + 2.f, 0.f));
	if (OutputParticipantVolumeText) OutputParticipantVolumeText->SetPosition(OutputParticipantVolumeLabel->GetPosition() + Vector2(OutputParticipantVolumeLabel->GetSize().x + 2.f, 0.f));

	const Vector2 MainPartPosition = GetPosition() + Vector2(0.0f, 5.0f);

	if (VoiceRoomMembersList) VoiceRoomMembersList->SetPosition(MainPartPosition + Vector2(0.0f, 30.0f));
}

void FVoiceDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (BackgroundImage) BackgroundImage->SetSize(Vector2(NewSize.x, NewSize.y - 10.f));
	if (TitleLabel) TitleLabel->SetSize(Vector2(NewSize.x, 30.0f));
	if (RoomNameText) RoomNameText->SetSize(Vector2(180.0f, 25.0f));
	if (JoinRoomButton) JoinRoomButton->SetSize(Vector2(80.0f, 20.f));
	if (LeaveRoomButton) LeaveRoomButton->SetSize(Vector2(80.0f, 20.f));
	if (OutputVolumeLabel) OutputVolumeLabel->SetSize(Vector2(60.0f, 20.0f));
	if (OutputVolumeText) OutputVolumeText->SetSize(Vector2(50.0f, 20.0f));
	if (OutputParticipantVolumeLabel) OutputParticipantVolumeLabel->SetSize(Vector2(60.0f, 20.0f));
	if (OutputParticipantVolumeText) OutputParticipantVolumeText->SetSize(Vector2(50.0f, 20.0f));

	const Vector2 MainPartPosition = GetPosition() + Vector2(0.0f, 5.0f);

	if (VoiceRoomMembersList) VoiceRoomMembersList->SetSize(Vector2(GetSize().x - 10.0f, GetSize().y - (MainPartPosition.y - GetPosition().y) - 35.0f));
}


void FVoiceDialog::Clear()
{
	if (VoiceRoomMembersList) VoiceRoomMembersList->Clear();
}

void FVoiceDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::UserLoggedIn)
	{

	}
	else if (Event.GetType() == EGameEventType::UserLoginRequiresMFA)
	{
		Disable();
		SetFocused(false);
	}
	else if (Event.GetType() == EGameEventType::UserLoginEnteredMFA)
	{
		Disable();
	}
	else if (Event.GetType() == EGameEventType::UserLoggedOut)
	{
		if (FPlayerManager::Get().GetNumPlayers() == 0)
		{
			Disable();
			Clear();
		}
	}
	else if (Event.GetType() == EGameEventType::ShowPrevUser)
	{
		Clear();
	}
	else if (Event.GetType() == EGameEventType::ShowNextUser)
	{
		Clear();
	}
	else if (Event.GetType() == EGameEventType::NewUserLogin)
	{
		Disable();
		Clear();
	}
	else if (Event.GetType() == EGameEventType::CancelLogin)
	{
		Disable();
		Clear();
	}
	else if (Event.GetType() == EGameEventType::UserConnectLoggedIn)
	{
		Enable();
		if (LeaveRoomButton) LeaveRoomButton->Disable();
	}
	else if (Event.GetType() == EGameEventType::RoomJoined)
	{
		PlayerPtr LocalPlayer = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
		if (LocalPlayer)
		{
			if (Event.GetProductUserId() == LocalPlayer->GetProductUserID())
			{
				if (JoinRoomButton) JoinRoomButton->Disable();
				if (LeaveRoomButton) LeaveRoomButton->Enable();
			}
			UpdateMemberListTable();
			if (!Event.GetFirstStr().empty())
			{
				if (RoomNameText)
				{
					RoomNameText->Clear();
					RoomNameText->AddLine(Event.GetFirstStr());
				}
			}
		}
	}
	else if (Event.GetType() == EGameEventType::RoomLeft)
	{
		PlayerPtr LocalPlayer = FPlayerManager::Get().GetPlayer(FPlayerManager::Get().GetCurrentUser());
		if (LocalPlayer)
		{
			if (Event.GetProductUserId() == LocalPlayer->GetProductUserID())
			{
				if (JoinRoomButton) JoinRoomButton->Enable();
				if (LeaveRoomButton) LeaveRoomButton->Disable();
				if (RoomNameText)
				{
					RoomNameText->Clear();
				}
			}
		}
		UpdateMemberListTable();
	}
	else if (Event.GetType() == EGameEventType::RoomDataUpdated)
	{
		UpdateMemberListTable();
	}
	else if (Event.GetType() == EGameEventType::NoUserLoggedIn)
	{
		UpdateMemberListTable();
	}
}

void FVoiceDialog::UpdateMemberListTable()
{
	std::map<EOS_ProductUserId, FVoiceRoomMember> RoomMembers = FGame::Get().GetVoice()->GetRoomMembers();

	// Copy data to vector to populate table
	std::vector<FVoiceRoomMemberTableRowData> MemberRows;
	MemberRows.reserve(RoomMembers.size());
	for (std::map<EOS_ProductUserId, FVoiceRoomMember>::iterator Itr = RoomMembers.begin(); Itr != RoomMembers.end(); ++Itr)
	{
		MemberRows.push_back(BuildMemberRow(Itr->second));
	}
	VoiceRoomMembersList->RefreshData(std::move(MemberRows));
}

```

`EAC_SDK/Samples/Voice/Client/Source/VoiceDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"
#include "ListView.h"
#include "TableView.h"
#include "Voice.h"

/**
 * Forward declarations
 */
class FGameEvent;
class FSpriteWidget;

/**
 * Voice dialog
 */
class FVoiceDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FVoiceDialog(Vector2 DialogPos,
		Vector2 DialogSize,
		UILayer DialogLayer,
		FontPtr DialogNormalFont,
		FontPtr DialogSmallFont,
		FontPtr DialogTinyFont);

	/**
	 * Destructor
	 */
	virtual ~FVoiceDialog() {};

	/**
	* IGfxComponent Overrides
	*/
	virtual void Update() override;
	virtual void Create() override;

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	
	virtual void Clear();

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

private:
	/** Updates table with list of members in the room */
	void UpdateMemberListTable();

	/** Background Image */
	std::shared_ptr<FSpriteWidget> BackgroundImage;

	/** Title label */
	std::shared_ptr<FTextLabelWidget> TitleLabel;

	/** Room name text */
	std::shared_ptr<FTextViewWidget> RoomNameText;

	/** Join room button */
	std::shared_ptr<FButtonWidget> JoinRoomButton;

	/** Leave room button */
	std::shared_ptr<FButtonWidget> LeaveRoomButton;

	/** Room output volume label */
	std::shared_ptr<FTextLabelWidget> OutputVolumeLabel;

	/** Room output volume*/
	std::shared_ptr<FTextFieldWidget> OutputVolumeText;

	/** Room participant's output volume label */
	std::shared_ptr<FTextLabelWidget> OutputParticipantVolumeLabel;

	/** Room participant's output volume*/
	std::shared_ptr<FTextFieldWidget> OutputParticipantVolumeText;

	/** List of members */
	using FVoiceRoomMembersListWidget = FVoiceRoomMemberTableView;
	std::shared_ptr<FVoiceRoomMembersListWidget> VoiceRoomMembersList;
};

```

`EAC_SDK/Samples/Voice/Client/Source/VoiceRoomMemberTableRowView.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "VoiceRoomMemberTableRowView.h"
#include "TextLabel.h"
#include "Button.h"
#include "Checkbox.h"
#include "Voice.h"
#include "Game.h"
#include "GameEvent.h"

FVoiceRoomMemberTableRowView::FVoiceRoomMemberTableRowView(Vector2 Pos, Vector2 Size, UILayer Layer, const std::wstring& InAssetFile, const FVoiceRoomMemberTableRowData& InData, FColor InBackgroundColor, FColor InTextColor)
	: FDialog(Pos, Size, Layer), Data(InData), AssetFile(InAssetFile), BackgroundColor(InBackgroundColor), TextColor(InTextColor)
{
	static_assert(std::tuple_size<FVoiceRoomMemberTableRowView::FRowWidgets>::value == std::tuple_size<FVoiceRoomMemberTableRowData::FValues>::value, "FRowWidgets must be the same size as the number of values.");
	static_assert(std::tuple_size<FVoiceRoomMemberTableRowView::FActionButtons>::value == std::tuple_size<FVoiceRoomMemberTableRowData::FActionsAvailable>::value, "FActionButtons must be the same size as the number of actions.");
	static_assert(std::tuple_size<FVoiceRoomMemberTableRowView::FActionIcons>::value == std::tuple_size<FVoiceRoomMemberTableRowData::FActionsAvailable>::value, "FActionIcons must be the same size as the number of actions.");
	static_assert(std::tuple_size<FVoiceRoomMemberTableRowView::FEditWidgets>::value == std::tuple_size<FVoiceRoomMemberTableRowData::FEditableValues>::value, "FEditWidgets must be the same size as the number of editable values.");

	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//create labels
	for (size_t Ix = 0; Ix < RowWidgets.size(); ++Ix)
	{
		std::shared_ptr<FTextLabelWidget> NextLabel = std::make_shared<FTextLabelWidget>(
			Vector2(Pos.x + LabelSize.x * Ix, Pos.y),
			LabelSize,
			Layer - 1,
			Data.Values[Ix],
			AssetFile,
			BackgroundColor,
			TextColor);

		RowWidgets[Ix] = NextLabel;
		AddWidget(NextLabel);
	}

	// create edits
	for (size_t Ix = 0; Ix < Edits.size(); ++Ix)
	{
		std::shared_ptr<FTextFieldWidget> NextEdit = std::make_shared<FTextFieldWidget>(
			Vector2(Pos.x + LabelSize.x * Ix, Pos.y),
			LabelSize,
			Layer - 1,
			Data.Edits[Ix],
			L"Assets/textfield.dds",
			Font,
			FTextFieldWidget::EInputType::Normal
			);
		NextEdit->SetOnEnterPressedCallback([this, Ix](const std::wstring& FieldValue)
		{
			this->OnEditEnterPressed(Ix, FieldValue);
		});

		Edits[Ix] = NextEdit;
		NextEdit->Enable();
		AddWidget(NextEdit);
	}

	//create action buttons
	std::array<std::wstring, FVoiceRoomMemberTableRowData::EAction::Count> actionLabels;
	std::array<FColor, FVoiceRoomMemberTableRowData::EAction::Count> actionColors;
	std::array<std::wstring, FVoiceRoomMemberTableRowData::EAction::Count> actionIconEnabled;
	std::array<std::wstring, FVoiceRoomMemberTableRowData::EAction::Count> actionIconDisabled;

	actionLabels[FVoiceRoomMemberTableRowData::EAction::Status] = L"";
	actionColors[FVoiceRoomMemberTableRowData::EAction::Status] = Color::Black;
	actionIconEnabled[FVoiceRoomMemberTableRowData::EAction::Status] = L"Assets/audio_on.dds";
	actionIconDisabled[FVoiceRoomMemberTableRowData::EAction::Status] = L"Assets/audio_off.dds";

	actionLabels[FVoiceRoomMemberTableRowData::EAction::Mute] = L"MUTE";
	actionColors[FVoiceRoomMemberTableRowData::EAction::Mute] = Color::DarkGreen;

	actionLabels[FVoiceRoomMemberTableRowData::EAction::RemoteMute] = L"REMOTE MUTE";
	actionColors[FVoiceRoomMemberTableRowData::EAction::RemoteMute] = Color::DarkBlue;

	actionLabels[FVoiceRoomMemberTableRowData::EAction::Kick] = L"KICK";
	actionColors[FVoiceRoomMemberTableRowData::EAction::Kick] = Color::DarkRed;

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		if (Ix != FVoiceRoomMemberTableRowData::EAction::Status)
		{
			std::shared_ptr<FButtonWidget> NextButton = std::make_shared<FButtonWidget>(
				Vector2(Pos.x + Data.Values.size() * LabelSize.x + Ix * ActionSize.x, Pos.y),
				ActionSize,
				Layer - 1,
				actionLabels[Ix],
				assets::DefaultButtonAssets,
				Font,
				actionColors[Ix]);
			NextButton->SetOnPressedCallback([this, Ix]() { this->OnPressed(Ix); });
			if (!Data.bActionsAvailable[Ix])
			{
				NextButton->Disable();
			}

			ActionButtons[Ix] = NextButton;
			AddWidget(NextButton);
		}
	}

	for (size_t Ix = 0; Ix < ActionIcons.size(); ++Ix)
	{
		if (Ix == FVoiceRoomMemberTableRowData::EAction::Status)
		{
			std::shared_ptr<FCheckboxWidget> NextCheckbox = std::make_shared<FCheckboxWidget>(
				Vector2(Pos.x + Data.Values.size() * LabelSize.x + Ix * ActionSize.x, Pos.y),
				ActionSize,
				Layer - 1,
				actionLabels[Ix],
				L"",
				nullptr,
				actionIconDisabled[Ix],
				actionIconEnabled[Ix]);
			NextCheckbox->SetOnTickedCallback([this, Ix](bool bIsPressed) { this->OnPressed(Ix); });
			NextCheckbox->Disable();
			NextCheckbox->Show();
			ActionIcons[Ix] = NextCheckbox;
			AddWidget(NextCheckbox);
		}
	}
}

void FVoiceRoomMemberTableRowView::SetFocused(bool bValue)
{
	FDialog::SetFocused(bValue);

	if (bValue)
	{
		SetBorderColor(Color::UIDarkGrey);
	}
	else
	{
		ClearBorderColor();
	}
}

void FVoiceRoomMemberTableRowView::SetPosition(Vector2 Pos)
{
	FDialog::SetPosition(Pos);

	ReadjustLayout();
}

void FVoiceRoomMemberTableRowView::SetSize(Vector2 NewSize)
{
	FDialog::SetSize(NewSize);

	ReadjustLayout();
}

void FVoiceRoomMemberTableRowView::Enable()
{
	FDialog::Enable();

	//Disable action buttons
	for (size_t Ix = 0; Ix < FVoiceRoomMemberTableRowData::EAction::Count; ++Ix)
	{
		if (!Data.bActionsAvailable[Ix] && ActionButtons.size() > Ix)
		{
			std::shared_ptr<FButtonWidget> ActionButton = ActionButtons[Ix];
			if (ActionButton)
			{
				ActionButton->Disable();
			}
		}
		if (!Data.bActionsAvailable[Ix] && ActionIcons.size() > Ix)
		{
			std::shared_ptr<FCheckboxWidget> ActionIcon = ActionIcons[Ix];
			if (ActionIcon)
			{
				ActionIcon->Disable();
			}
		}
	}

	for (size_t Ix = 0; Ix < FVoiceRoomMemberTableRowData::EEditableValue::Count; ++Ix)
	{
		if (!Data.bEditablesAvailable[Ix] && Edits.size() > Ix)
		{
			std::shared_ptr<FTextFieldWidget> Edit = Edits[Ix];
			if (Edit)
			{
				Edit->Disable();
			}
		}
	}
}

void FVoiceRoomMemberTableRowView::SetOnActionPressedCallback(std::function<void(size_t)> Callback)
{
	ActionPressedCallback = Callback;
}

void FVoiceRoomMemberTableRowView::HideActions()
{
	for (std::shared_ptr<FButtonWidget> ActionButton : ActionButtons)
	{
		if (ActionButton)
		{
			ActionButton->Hide();
		}
	}
	for (std::shared_ptr<FCheckboxWidget> ActionIcon : ActionIcons)
	{
		if (ActionIcon)
		{
			ActionIcon->Hide();
		}
	}
}

void FVoiceRoomMemberTableRowView::SetData(const FVoiceRoomMemberTableRowData& InData)
{
	Data = InData;
	if (!InData.UserId)  // empty data
	{
		return;
	}

	for (size_t Ix = 0; Ix < RowWidgets.size(); ++Ix)
	{
		std::wstring DataString = (Ix < InData.Values.size()) ? InData.Values[Ix] : L"-";
		RowWidgets[Ix]->SetText(DataString);
	}

	for (size_t Ix = 0; Ix < Edits.size(); ++Ix)
	{
		if (Ix == FVoiceRoomMemberTableRowData::EEditableValue::Volume)
		{
			if (Edits[Ix])
			{
				if (!Edits[Ix]->IsFocused())
				{
					std::wstringstream StreamBuffer;
					StreamBuffer << InData.Volume;
					Edits[Ix]->SetText(StreamBuffer.str());
				}

				if (Data.bEditablesAvailable[Ix])
				{
					Edits[Ix]->Enable();
				}
				else
				{
					Edits[Ix]->Disable();
				}
			}
		}
	}

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		if (ActionButtons[Ix])
		{
			if (Data.bActionsAvailable[Ix])
			{
				ActionButtons[Ix]->Enable();
			}
			else
			{
				ActionButtons[Ix]->Disable();
			}
		}
	}

	for (size_t Ix = 0; Ix < ActionIcons.size(); ++Ix)
	{
		if (ActionIcons[Ix])
		{
			if (Ix == FVoiceRoomMemberTableRowData::EAction::Status)
			{
				bool bTicked = Data.bIsMuted || !Data.bIsSpeaking;
				ActionIcons[Ix]->SetTicked(bTicked);
				if (bTicked)
				{
					ActionIcons[Ix]->SetTickedColor(Data.bIsMuted ? Color::Red : Color::White);
				}
				else
				{
					ActionIcons[Ix]->SetUntickedColor(Data.bIsSpeaking ? Color::Green : Color::White);
				}
			}
		}
	}

	ReadjustLayout();
}

void FVoiceRoomMemberTableRowView::SetFont(FontPtr InFont)
{
	Font = InFont;

	for (std::shared_ptr<FTextLabelWidget> Widget : RowWidgets)
	{
		if (Widget)
		{
			Widget->SetFont(InFont);
		}
	}

	for (std::shared_ptr<FTextFieldWidget> Edit : Edits)
	{
		if (Edit)
		{
			Edit->SetFont(InFont);
		}
	}

	for (std::shared_ptr<FButtonWidget> Button : ActionButtons)
	{
		if (Button)
		{
			Button->SetFont(InFont);
		}
	}

	for (std::shared_ptr<FCheckboxWidget> Icon : ActionIcons)
	{
		if (Icon)
		{
			Icon->SetFont(InFont);
		}
	}
}

void FVoiceRoomMemberTableRowView::CalcSizes(Vector2& LabelSize, Vector2& ActionSize)
{
	// Fit the action buttons into "2" columns.
	float ActionSizeRatio = 2.3f / FVoiceRoomMemberTableRowData::EAction::Count;
	float ColumnRatio = Data.Values.size() + Data.Edits.size() + ActionSizeRatio * FVoiceRoomMemberTableRowData::EAction::Count;
	LabelSize = Vector2(Size.x / ColumnRatio, Size.y);
	ActionSize = Vector2(LabelSize.x * ActionSizeRatio, Size.y);
}

void FVoiceRoomMemberTableRowView::ReadjustLayout()
{
	Vector2 LabelSize;
	Vector2 ActionSize;
	CalcSizes(LabelSize, ActionSize);

	//resize labels
	for (size_t Ix = 0; Ix < RowWidgets.size(); ++Ix)
	{
		if (RowWidgets[Ix])
		{
			RowWidgets[Ix]->SetPosition(Vector2(Position.x + LabelSize.x * Ix, Position.y));
			RowWidgets[Ix]->SetSize(LabelSize);
		}
	}

	for (size_t Ix = 0; Ix < Edits.size(); ++Ix)
	{
		if (Edits[Ix])
		{
			Edits[Ix]->SetPosition(Vector2(Position.x + Data.Values.size() * LabelSize.x + ActionSize.x * Ix, Position.y));
			Edits[Ix]->SetSize(ActionSize);
		}
	}

	for (size_t Ix = 0; Ix < ActionButtons.size(); ++Ix)
	{
		if (ActionButtons[Ix])
		{
			ActionButtons[Ix]->SetPosition(Vector2(Position.x + Data.Edits.size() * ActionSize.x + Data.Values.size() * LabelSize.x + ActionSize.x * Ix, Position.y));
			ActionButtons[Ix]->SetSize(ActionSize);
		}
	}

	for (size_t Ix = 0; Ix < ActionIcons.size(); ++Ix)
	{
		if (ActionIcons[Ix])
		{
			ActionIcons[Ix]->SetPosition(Vector2(Position.x + Data.Values.size() * LabelSize.x + (Ix + 1) * ActionSize.x, Position.y)); // after edits
			ActionIcons[Ix]->SetSize(ActionSize);
		}
	}
}

void FVoiceRoomMemberTableRowView::OnPressed(size_t ActionIndex)
{
	if (ActionPressedCallback)
	{
		ActionPressedCallback(ActionIndex);
	}

	FProductUserId UserId  = Data.UserId;

	if (ActionIndex == FVoiceRoomMemberTableRowData::EAction::Mute)
	{
		FGame::Get().GetVoice()->LocalToggleMuteMember(UserId);
	}
	else if (ActionIndex == FVoiceRoomMemberTableRowData::EAction::RemoteMute)
	{
		FGame::Get().GetVoice()->RemoteToggleMuteMember(UserId);
	}
	else if (ActionIndex == FVoiceRoomMemberTableRowData::EAction::Kick)
	{
		FGame::Get().GetVoice()->KickMember(UserId);
	}
}

void FVoiceRoomMemberTableRowView::OnEditEnterPressed(size_t EditIndex, const std::wstring& FieldValue)
{
	if (EditIndex == FVoiceRoomMemberTableRowData::EEditableValue::Volume)
	{
		if (FieldValue.size() <= 0)
		{
			Edits[EditIndex]->SetText(L"0");
		}
		else
		{
			float Volume;
			try
			{
				Volume = std::stof(FieldValue);
			}
			catch (...)
			{
				return; // wrong format, range, etc.
			}

			if (Volume < 0.f)
			{
				Edits[EditIndex]->SetText(L"0");
			}
			else if (Volume > 100.f)
			{
				Edits[EditIndex]->SetText(L"100");
			}
		}

		FGameEvent Event(EGameEventType::UpdateParticipantVolume, Data.UserId, FieldValue);
		FGame::Get().OnGameEvent(Event);
	}
}

template<>
std::shared_ptr<FVoiceRoomMemberTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FVoiceRoomMemberTableRowData& Data)
{
	return std::make_shared<FVoiceRoomMemberTableRowView>(Pos, Size, Layer, L"", Data, Color::DarkGray, Color::White);
}
```

`EAC_SDK/Samples/Voice/Client/Source/VoiceRoomMemberTableRowView.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Widget.h"
#include "Font.h"
#include "ListView.h"
#include "Dialog.h"

#include <array>

class FTextLabelWidget;
class FButtonWidget;
class FCheckboxWidget;

struct FVoiceRoomMemberTableRowData
{
	struct EValue final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			DisplayName = 0,
			Count
		};
		EValue() = delete;
	};
	struct EAction final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			Status = 0,
			Mute,
			RemoteMute,
			Kick,
			Count
		};
		EAction() = delete;
	};
	struct EEditableValue final
	{
		// Not an `enum class` to allow easy `int` conversion.
		enum EData : int
		{
			Volume = 0,
			Count
		};
		EEditableValue() = delete;
	};


	std::wstring DisplayName;
	FProductUserId UserId;
	float Volume;
	bool bIsSpeaking = false;
	bool bIsMuted = false;
	bool bIsRemoteMuted = false;

	using FValues = std::array<std::wstring, EValue::Count>;
	using FEditableValues = std::array<std::wstring, EEditableValue::Count>;
	using FActionsAvailable = std::array<bool, EAction::Count>;
	using FEditableAvailable = std::array<bool, EEditableValue::Count>;
	FValues Values;
	FEditableValues Edits;
	FActionsAvailable bActionsAvailable;
	FEditableAvailable bEditablesAvailable;

	bool operator!=(const FVoiceRoomMemberTableRowData& Other) const
	{
		return bActionsAvailable != Other.bActionsAvailable || Values != Other.Values;
	}

	FVoiceRoomMemberTableRowData()
	{
		bActionsAvailable.fill(false);
		bEditablesAvailable.fill(false);
		Values[EValue::DisplayName] = L"Name";
	}
};

class FVoiceRoomMemberTableRowView : public FDialog
{
public:
	FVoiceRoomMemberTableRowView(Vector2 Pos,
		Vector2 Size,
		UILayer Layer,
		const std::wstring& AssetFile,
		const FVoiceRoomMemberTableRowData& InData,
		FColor BackgroundColor,
		FColor TextColor);

	void SetFocused(bool bValue) override;

	/** Set Position */
	void SetPosition(Vector2 Pos) override;

	/** Set Size */
	void SetSize(Vector2 NewSize) override;

	void Enable() override;

	void SetOnActionPressedCallback(std::function<void(size_t)> Callback);

	void SetOnActionTickedCallback(std::function<void()> Callback);

	void HideActions();

	void SetData(const FVoiceRoomMemberTableRowData& InData);
	void SetFont(FontPtr InFont);

protected:
	void CalcSizes(Vector2& LabelSize, Vector2& ActionSize);
	void ReadjustLayout();
	void OnPressed(size_t ActionIndex);
	void OnTicked(bool bIsChecked);
	void OnEditEnterPressed(size_t EditIndex, const std::wstring& FieldValue);

	FVoiceRoomMemberTableRowData Data;

	using FRowWidgets = std::array<std::shared_ptr<FTextLabelWidget>, FVoiceRoomMemberTableRowData::EValue::Count>;
	FRowWidgets RowWidgets;
	using FActionButtons = std::array<std::shared_ptr<FButtonWidget>, FVoiceRoomMemberTableRowData::EAction::Count>;
	FActionButtons ActionButtons;
	using FActionIcons = std::array<std::shared_ptr<FCheckboxWidget>, FVoiceRoomMemberTableRowData::EAction::Count>;
	FActionIcons ActionIcons;
	using FEditWidgets = std::array<std::shared_ptr<FTextFieldWidget>, FVoiceRoomMemberTableRowData::EValue::Count>;
	FEditWidgets Edits;

	std::wstring AssetFile;
	FColor BackgroundColor;
	FColor TextColor;
	FontPtr Font;

	std::function<void(size_t)> ActionPressedCallback;
};

template<>
std::shared_ptr<FVoiceRoomMemberTableRowView> CreateListEntry(Vector2 Pos, Vector2 Size, UILayer Layer, const FVoiceRoomMemberTableRowData& Data);
```

`EAC_SDK/Samples/Voice/Client/Source/VoiceSetupDialog.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"
#include "Game.h"
#include "Menu.h"
#include "GameEvent.h"
#include "TextLabel.h"
#include "Button.h"
#include "DropDownList.h"
#include "StringUtils.h"
#include "Voice.h"
#include "VoiceSetupDialog.h"

FVoiceSetupDialog::FVoiceSetupDialog(Vector2 InPos,
	Vector2 InSize,
	UILayer InLayer,
	FontPtr InNormalFont,
	FontPtr InSmallFont) :
	FDialog(InPos, InSize, InLayer)
{
	Background = std::make_shared<FSpriteWidget>(
		Position,
		InSize,
		InLayer,
		L"Assets/textfield.dds");
	AddWidget(Background);

	HeaderLabel = std::make_shared<FTextLabelWidget>(
		Vector2(Position.x, Position.y),
		Vector2(InSize.x, 30.f),
		InLayer - 1,
		L"SETUP",
		L"Assets/dialog_title.dds",
		FColor(1.f, 1.f, 1.f, 1.f),
		FColor(1.f, 1.f, 1.f, 1.f),
		EAlignmentType::Left);
	HeaderLabel->SetFont(InNormalFont);
	HeaderLabel->SetBorderColor(Color::UIBorderGrey);
	AddWidget(HeaderLabel);

	const Vector2 UIPosition = Position + Vector2(0.0f, HeaderLabel->GetSize().y);
	const float UIWidth = InSize.x - 2.0f;
	const Vector2 DropDownListsSize = Vector2(UIWidth - 100.0f, 30.0f);

	OutputDeviceDropDown = std::make_shared<FDropDownList>(
		UIPosition,
		DropDownListsSize,
		DropDownListsSize + Vector2(0.0f, 80.0),
		Layer - 1,
		L"OUTPUT DEVICE: ",
		std::vector<std::wstring>({ L"No Device",}),
		InNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	OutputDeviceDropDown->SetBorderColor(Color::UIBorderGrey);
	OutputDeviceDropDown->SetOnSelectionCallback([this](const std::wstring& Selection)
	{
		OnOutputDeviceSelected(Selection);
	});
	OutputDeviceDropDown->SetOnExpandedCallback([this]()
	{
		OnOutputDeviceDropdownExpanded();
	});
	OutputDeviceDropDown->SetOnCollapsedCallback([this]()
	{
		OnOutputDeviceDropdownCollapsed();
	});
	//AddWidget(OutputDeviceDropDown);

	InputDeviceDropDown = std::make_shared<FDropDownList>(
		OutputDeviceDropDown->GetPosition() + Vector2(DropDownListsSize.x  + 10.0f, 0.0f),
		DropDownListsSize,
		DropDownListsSize + Vector2(0.0f, 60.0),
		Layer - 1,
		L"INPUT DEVICE: ",
		std::vector<std::wstring>({ L"No Device" }),
		InNormalFont,
		EAlignmentType::Left,
		Color::UIBackgroundGrey
		);
	InputDeviceDropDown->SetBorderColor(Color::UIBorderGrey);
	InputDeviceDropDown->SetOnSelectionCallback([this](const std::wstring& Selection)
	{
		OnInputDeviceSelected(Selection);
	});
	InputDeviceDropDown->SetOnExpandedCallback([this]()
	{
		OnInputDeviceDropdownExpanded();
	});
	InputDeviceDropDown->SetOnCollapsedCallback([this]()
	{
		OnInputDeviceDropdownCollapsed();
	});
	//AddWidget(InputDeviceDropDown);

	//Dropdown lists have to be last widgets in the list otherwise they will overlap with other widgets when expanded on DX platform.
	//This is temporary workaround (hack).
	//TODO: fix DX render to use UI Layer value correctly
	AddWidget(OutputDeviceDropDown);
	AddWidget(InputDeviceDropDown);
}

FVoiceSetupDialog::~FVoiceSetupDialog()
{

}

void FVoiceSetupDialog::SetPosition(Vector2 Pos)
{
	IWidget::SetPosition(Pos);

	if (Background) Background->SetPosition(Position);
	if (HeaderLabel) HeaderLabel->SetPosition(Position);

	const float UIWidth = GetSize().x - 2.0f;
	const float UIHeight = GetSize().y - 2.0f;
	const Vector2 UIPosition = Position + Vector2(5.0f, HeaderLabel->GetSize().y + 10.f);

	if (OutputDeviceDropDown) OutputDeviceDropDown->SetPosition(UIPosition);
	if (InputDeviceDropDown) InputDeviceDropDown->SetPosition(Vector2(UIPosition.x, OutputDeviceDropDown->GetPosition().y + 50.f));
}

void FVoiceSetupDialog::SetSize(Vector2 NewSize)
{
	IWidget::SetSize(NewSize);

	if (Background) Background->SetSize(Vector2(NewSize.x, NewSize.y));
	if (HeaderLabel) HeaderLabel->SetSize(Vector2(NewSize.x, 30.0f));
	if (OutputDeviceDropDown) OutputDeviceDropDown->SetSize(Vector2(NewSize.x - 10.f, 30.0f));
	if (InputDeviceDropDown) InputDeviceDropDown->SetSize(Vector2(NewSize.x - 10.f, 30.0f));
}

void FVoiceSetupDialog::Create()
{
	FDialog::Create();

	if (OutputDeviceDropDown) OutputDeviceDropDown->SetParent(std::weak_ptr<FDialog>(std::static_pointer_cast<FDialog>(shared_from_this())));
	if (InputDeviceDropDown) InputDeviceDropDown->SetParent(std::weak_ptr<FDialog>(std::static_pointer_cast<FDialog>(shared_from_this())));
}

void FVoiceSetupDialog::OnEscapePressed()
{

}

void FVoiceSetupDialog::OnGameEvent(const FGameEvent& Event)
{
	if (Event.GetType() == EGameEventType::AudioInputDevicesUpdated)
	{
		UpdateInputDevices(Event.GetFirstStr());
	}
	else if (Event.GetType() == EGameEventType::AudioOutputDevicesUpdated)
	{
		UpdateOutputDevices(Event.GetFirstStr());
	}
}

/**
 * We want to keep the currently selected device if possible when the list of available devices changes (e.g: The user plugged/unplugged a device)
 */
static int PickDeviceIndex(const std::vector<std::wstring>& DeviceNames, const std::wstring& DefaultDeviceName, const std::wstring& CurrentlySelected)
{
	// If the currently selected device still exists, we pick that
	for (int Index = 0; Index < static_cast<int>(DeviceNames.size()); Index++)
	{
		if (DeviceNames[Index] == CurrentlySelected)
		{
			return Index;
		}
	}

	// Find the address of the Default device
	for (int Index = 0; Index < static_cast<int>(DeviceNames.size()); Index++)
	{
		if (DeviceNames[Index] == DefaultDeviceName)
		{
			return Index;
		}
	}

	return 0;
}

void FVoiceSetupDialog::UpdateInputDevices(const std::wstring& DefaultDeviceName)
{
	if (InputDeviceDropDown)
	{
		const std::vector<std::wstring>& DeviceNames = FGame::Get().GetVoice()->GetAudioInputDeviceNames();
		int SelectedIndex = PickDeviceIndex(DeviceNames, DefaultDeviceName, InputDeviceDropDown->GetCurrentSelection());
		InputDeviceDropDown->UpdateOptionsList(DeviceNames, SelectedIndex);
	}
}

void FVoiceSetupDialog::UpdateOutputDevices(const std::wstring& DefaultDeviceName)
{
	if (OutputDeviceDropDown)
	{
		const std::vector<std::wstring>& DeviceNames = FGame::Get().GetVoice()->GetAudioOutputDeviceNames();
		int SelectedIndex = PickDeviceIndex(DeviceNames, DefaultDeviceName, OutputDeviceDropDown->GetCurrentSelection());
		OutputDeviceDropDown->UpdateOptionsList(DeviceNames, SelectedIndex);
	}
}

void FVoiceSetupDialog::OnOutputDeviceSelected(const std::wstring& Selection)
{
	FGame::Get().GetVoice()->SetAudioOutputDeviceFromName(Selection);
}

void FVoiceSetupDialog::OnInputDeviceSelected(const std::wstring& Selection)
{
	FGame::Get().GetVoice()->SetAudioInputDeviceFromName(Selection);
}

void FVoiceSetupDialog::OnOutputDeviceDropdownExpanded()
{
	if (InputDeviceDropDown)
	{
		InputDeviceDropDown->Hide();
	}
}

void FVoiceSetupDialog::OnOutputDeviceDropdownCollapsed()
{
	if (InputDeviceDropDown)
	{
		InputDeviceDropDown->Show();
	}
}

void FVoiceSetupDialog::OnInputDeviceDropdownExpanded()
{
	/*if (OutputDeviceDropDown)
	{
		OutputDeviceDropDown->Hide();
	}*/
}

void FVoiceSetupDialog::OnInputDeviceDropdownCollapsed()
{
	/*if (OutputDeviceDropDown)
	{
		OutputDeviceDropDown->Show();
	}*/
}
```

`EAC_SDK/Samples/Voice/Client/Source/VoiceSetupDialog.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Dialog.h"
#include "Font.h"

/**
 * Forward declarations
 */
class FTextLabelWidget;
class FButtonWidget;
class FDropDownList;

/**
 * Voice setup dialog
 */
class FVoiceSetupDialog : public FDialog
{
public:
	/**
	 * Constructor
	 */
	FVoiceSetupDialog(Vector2 InPos,
		Vector2 InSize,
		UILayer InLayer,
		FontPtr InNormalFont,
		FontPtr InSmallFont);

	/**
	 * Destructor
	 */
	virtual ~FVoiceSetupDialog();

	/** IWidget */
	virtual void SetPosition(Vector2 Pos) override;
	virtual void SetSize(Vector2 NewSize) override;
	virtual void OnEscapePressed() override;

	virtual void Create() override;

	/**
	* Receives game event
	*
	* @param Event - Game event to act on
	*/
	void OnGameEvent(const FGameEvent& Event);

private:
	/** Update input devices */
	void UpdateInputDevices(const std::wstring& DefaultDeviceName);

	/** Update output devices */
	void UpdateOutputDevices(const std::wstring& DefaultDeviceName);

	/** A device option from output devices dropdown has been selected */
	void OnOutputDeviceSelected(const std::wstring& Selection);

	/** A device option from input devices dropdown has been selected */
	void OnInputDeviceSelected(const std::wstring& Selection);

	/** Output devices dropdown has been expanded */
	void OnOutputDeviceDropdownExpanded();

	/** Output devices dropdown has been collapsed */
	void OnOutputDeviceDropdownCollapsed();

	/** Input devices dropdown has been expanded */
	void OnInputDeviceDropdownExpanded();

	/** Input devices dropdown has been collapsed */
	void OnInputDeviceDropdownCollapsed();

	/** Background */
	WidgetPtr Background;

	/** Header Label */
	std::shared_ptr<FTextLabelWidget> HeaderLabel;

	/** Output Device Dropdown */
	std::shared_ptr<FDropDownList> OutputDeviceDropDown;

	/** Input Device Dropdown */
	std::shared_ptr<FDropDownList> InputDeviceDropDown;
};

```

`EAC_SDK/Samples/Voice/Client/Source/resource.rc`:

```rc
IDI_ICON               ICON         "game.ico"

```

`EAC_SDK/Samples/Voice/Client/Voice.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_SDL|Win32">
      <Configuration>Debug_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_SDL|x64">
      <Configuration>Debug_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|Win32">
      <Configuration>Debug_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_DX|x64">
      <Configuration>Debug_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|Win32">
      <Configuration>Release_SDL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_SDL|x64">
      <Configuration>Release_SDL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|Win32">
      <Configuration>Release_DX</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_DX|x64">
      <Configuration>Release_DX</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <RootNamespace>SimpleFramework</RootNamespace>
    <ProjectGuid>{62B2385D-FB11-4768-AC67-FEC93481FB03}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Voice</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_VOICE;EOS_LIBCURL_ENABLED;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/Voice/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/External/curl/Include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;libcurl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Debug;..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release;../$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_VOICE;EOS_LIBCURL_ENABLED;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/Voice/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;../$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/External/curl/Include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;libcurl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;..\$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_VOICE;EOS_LIBCURL_ENABLED;DXTK;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/Voice/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/External/curl/Include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;libcurl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Debug;..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release;../$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release\libcurl.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>EOS_SAMPLE_VOICE;EOS_LIBCURL_ENABLED;EOS_DEMO_SDL;WIN32;_DEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/Voice/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;../$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/External/curl/Include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;libcurl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;..\$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt;msvcrt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release\libcurl.dll $(OutDir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_VOICE;EOS_LIBCURL_ENABLED;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/Voice/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/External/curl/Include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;libcurl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\Win32\Release;..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release;../$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_VOICE;EOS_LIBCURL_ENABLED;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/Voice/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;../$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/External/curl/Include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;libcurl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release;..\$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x86;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86;..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x86\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x86\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win32\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_VOICE;EOS_LIBCURL_ENABLED;DXTK;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/Voice/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Main/Windows;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/DirectXTK/Include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/External/curl/Include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;DirectXTK.lib;d3d11.lib;dxgi.lib;dxguid.lib;uuid.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;odbc32.lib;odbccp32.lib;libcurl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>..\$(EOSSDKSamplesRoot)\Shared\External\DirectXTK\Lib\x64\Release;..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release;../$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>EOS_SAMPLE_VOICE;EOS_LIBCURL_ENABLED;EOS_DEMO_SDL;WIN32;NDEBUG;_WINDOWS;EOS_ASSETS_PATH_PREFIX=L"../../../../../Shared/";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FloatingPointModel>Fast</FloatingPointModel>
      <AdditionalIncludeDirectories>../$(EOSSDKSamplesRoot)/Voice/Client/Source;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source/Core;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics;../$(EOSSDKSamplesRoot)/Shared/Source/Graphics/GUI;../$(EOSSDKSamplesRoot)/Shared/Source/Input;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/include;../$(EOSSDKSamplesRoot)/Shared/External/GLEW/include;../$(EOSSDKSamplesRoot)/Shared/External/SDL2/SDL2_ttf/include;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/External/curl/Include;../$(EOSSDKIncludes)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;SDL2.lib;SDL2main.lib;GlU32.Lib;OpenGL32.Lib;glew32s.lib;SDL2_ttf.lib;libcurl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release;..\$(EOSSDKSamplesRoot)\Shared\External\GLEW\lib\Release\x64;..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64;..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>libcmt</IgnoreSpecificDefaultLibraries>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\Lib\x64\Release\SDL2.pdb $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\SDL2_ttf.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\libfreetype-6.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\SDL2\SDL2_ttf\lib\x64\zlib1.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul
xcopy /D /Y /R /Q ..\$(EOSSDKSamplesRoot)\Shared\External\curl\Lib\Win64\Release\libcurl.dll $(OutDir) &gt;nul</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\..\..\SDK\Include\eos_auth.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_auth_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_base.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_common.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_friends.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_friends_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_init.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_logging.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_metrics.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_metrics_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_playerdatastorage.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_playerdatastorage_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_presence.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_presence_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_sdk.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_userinfo.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_userinfo_types.h" />
    <ClInclude Include="..\..\..\SDK\Include\eos_version.h" />
    <ClInclude Include="..\..\Shared\Source\BaseGame.h" />
    <ClInclude Include="..\..\Shared\Source\BaseLevel.h" />
    <ClInclude Include="..\..\Shared\Source\BaseMenu.h" />
    <ClInclude Include="..\..\Shared\Source\Core\AccountHelpers.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Authentication.h" />
    <ClInclude Include="..\..\Shared\Source\Core\EosUI.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Friends.h" />
    <ClInclude Include="..\..\Shared\Source\Core\GameEvent.h" />
    <ClInclude Include="..\..\Shared\Source\Core\HTTPClient.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Metrics.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Platform.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Player.h" />
    <ClInclude Include="..\..\Shared\Source\Core\Users.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\Console.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GfxComponent.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AnimatedTexture.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AssetUtils.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AuthDialogs.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Button.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Checkbox.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ConsoleDialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Dialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\DropDownList.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ExitDialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Font.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendInfo.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendList.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendsDialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ListView.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\PopupDialog.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ProgressBar.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Scroller.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\SDLTTF.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Sprite.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\StringViewListEntry.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TableRowView.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TableView.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextEditor.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextField.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextLabel.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Texture.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextureManager.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextView.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\UIEvent.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Widget.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\Model.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\SDLSpriteBatch.h" />
    <ClInclude Include="..\..\Shared\Source\Graphics\VectorRender.h" />
    <ClInclude Include="..\..\Shared\Source\Input\Input.h" />
    <ClInclude Include="..\..\Shared\Source\Input\SDLInput.h" />
    <ClInclude Include="..\..\Shared\Source\Main\Main.h" />
    <ClInclude Include="..\..\Shared\Source\Main\Windows\DeviceResources.h" />
    <ClInclude Include="..\..\Shared\Source\Math\Color.h" />
    <ClInclude Include="..\..\Shared\Source\Math\Matrix.h" />
    <ClInclude Include="..\..\Shared\Source\Math\Vector2.h" />
    <ClInclude Include="..\..\Shared\Source\Math\Vector3.h" />
    <ClInclude Include="..\..\Shared\Source\pch.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\StepTimer.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\CircularBuffer.h" />
    <ClInclude Include="Source\Game.h" />
    <ClInclude Include="Source\Level.h" />
    <ClInclude Include="Source\Menu.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\Voice.h" />
    <ClInclude Include="Source\VoiceDialog.h" />
    <ClInclude Include="Source\VoiceRoomMemberTableRowView.h" />
    <ClInclude Include="Source\VoiceSetupDialog.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\Source\BaseGame.cpp" />
    <ClCompile Include="..\..\Shared\Source\BaseLevel.cpp" />
    <ClCompile Include="..\..\Shared\Source\BaseMenu.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\AccountHelpers.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Authentication.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\EosUI.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Friends.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\HTTPClient.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Metrics.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Platform.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Player.cpp" />
    <ClCompile Include="..\..\Shared\Source\Core\Users.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\Console.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AssetUtils.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AuthDialogs.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Button.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Checkbox.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Dialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\DropDownList.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ExitDialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Font.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendInfo.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendList.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendsDialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\PopupDialog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ProgressBar.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Scroller.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\SDLTTF.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Sprite.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TableRowView.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextEditor.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextField.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextLabel.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Texture.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextureManager.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextView.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Widget.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\Model.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\SDLSpriteBatch.cpp" />
    <ClCompile Include="..\..\Shared\Source\Graphics\VectorRender.cpp" />
    <ClCompile Include="..\..\Shared\Source\Input\Input.cpp" />
    <ClCompile Include="..\..\Shared\Source\Input\SDLInput.cpp" />
    <ClCompile Include="..\..\Shared\Source\Main\Main.cpp" />
    <ClCompile Include="..\..\Shared\Source\Main\SDL\SDLMain.cpp" />
    <ClCompile Include="..\..\Shared\Source\Main\Windows\DeviceResources.cpp" />
    <ClCompile Include="..\..\Shared\Source\Main\Windows\WinMain.cpp" />
    <ClCompile Include="..\..\Shared\Source\Math\Vector2.cpp" />
    <ClCompile Include="..\..\Shared\Source\Math\Vector3.cpp" />
    <ClCompile Include="..\..\Shared\Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_SDL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_DX|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_SDL|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\Game.cpp" />
    <ClCompile Include="Source\Menu.cpp" />
    <ClCompile Include="Source\Voice.cpp" />
    <ClCompile Include="Source\VoiceDialog.cpp" />
    <ClCompile Include="Source\VoiceRoomMemberTableRowView.cpp" />
    <ClCompile Include="Source\VoiceSetupDialog.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="..\..\Shared\Assets\addbutton.dds" />
    <Image Include="..\..\Shared\Assets\button.dds" />
    <Image Include="..\..\Shared\Assets\button_pressed.dds" />
    <Image Include="..\..\Shared\Assets\checkbox_ticked.dds" />
    <Image Include="..\..\Shared\Assets\checkbox_unticked.dds" />
    <Image Include="..\..\Shared\Assets\console.dds" />
    <Image Include="..\..\Shared\Assets\friendback.dds" />
    <Image Include="..\..\Shared\Assets\friends.dds" />
    <Image Include="..\..\Shared\Assets\Logo.dds" />
    <Image Include="..\..\Shared\Assets\menu_background.dds" />
    <Image Include="..\..\Shared\Assets\nobutton.dds" />
    <Image Include="..\..\Shared\Assets\scrollbar.dds" />
    <Image Include="..\..\Shared\Assets\scroll_down_button.dds" />
    <Image Include="..\..\Shared\Assets\scroll_up_button.dds" />
    <Image Include="..\..\Shared\Assets\search.dds" />
    <Image Include="..\..\Shared\Assets\solid_white.dds" />
    <Image Include="..\..\Shared\Assets\textfield.dds" />
    <Image Include="..\..\Shared\Assets\yesbutton.dds" />
    <Image Include="Source\game.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\..\Shared\Assets\Roboto10.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto12.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto14.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto16.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto18.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto24.spritefont" />
    <None Include="..\..\Shared\Assets\Roboto8.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold10.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold12.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold14.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold16.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold18.spritefont" />
    <None Include="..\..\Shared\Assets\RobotoBold24.spritefont" />
    <None Include="..\..\Shared\Source\Graphics\GUI\ListView.inl" />
    <None Include="..\..\Shared\Source\Graphics\GUI\TableView.inl" />
    <None Include="Source\resource.aps" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`EAC_SDK/Samples/Voice/Client/Voice.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="..\..\..\SDK\Include\eos_auth.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_auth_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_base.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_common.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_friends.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_friends_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_init.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_logging.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_metrics.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_metrics_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_playerdatastorage.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_playerdatastorage_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_presence.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_presence_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sdk.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_userinfo.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_userinfo_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_version.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="Source\Game.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Level.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Menu.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\pch.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\AccountHelpers.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Authentication.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\EosUI.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Friends.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Metrics.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Platform.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Player.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\Users.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\Console.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GfxComponent.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\Model.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AuthDialogs.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ConsoleDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Dialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ExitDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendsDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Button.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Checkbox.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendInfo.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\FriendList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Scroller.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Sprite.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextField.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextLabel.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Widget.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Font.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\Texture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\UIEvent.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Input\Input.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Main\Main.h">
      <Filter>SharedSource\Main</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Main\Windows\DeviceResources.h">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Math\Color.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Math\Matrix.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Math\Vector2.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Math\Vector3.h">
      <Filter>SharedSource\Math</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\StepTimer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AnimatedTexture.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextureManager.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\SDLSpriteBatch.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\SDLTTF.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TextEditor.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ListView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\ProgressBar.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Input\SDLInput.h">
      <Filter>SharedSource\Input</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_ecom_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_p2p_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\..\SDK\Include\eos_sessions_types.h">
      <Filter>EOSSDK</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\VectorRender.h">
      <Filter>SharedSource\Graphics</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\GameEvent.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\DropDownList.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\StringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TableRowView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\TableView.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.h">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\PopupDialog.h">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\BaseGame.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\BaseLevel.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\BaseMenu.h">
      <Filter>SharedSource</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\Voice.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceRoomMemberTableRowView.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceSetupDialog.h">
      <Filter>Source</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Core\HTTPClient.h">
      <Filter>SharedSource\Core</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Graphics\GUI\AssetUtils.h">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="EOSSDK">
      <UniqueIdentifier>{fcf9b49b-2f09-4232-814e-1d08d8bab009}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedAssets">
      <UniqueIdentifier>{d95191aa-0506-42ad-8d00-8c808f5cef2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{e803a3d6-c2c1-4e01-80b5-9cf7adae0ab5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Core">
      <UniqueIdentifier>{9a536066-64d8-4ba3-bc98-a634303e72f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{562eeed2-1f92-4d57-ab9b-918941fadc1f}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics">
      <UniqueIdentifier>{6cdd3c94-d88b-4472-b83c-a3f33852b01e}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI">
      <UniqueIdentifier>{89f97cfd-bcd5-435e-821d-5c28c73d76d8}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Dialogs">
      <UniqueIdentifier>{6a534e1a-d47f-4e33-9e3e-6507b8d20ada}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Graphics\GUI\Widgets">
      <UniqueIdentifier>{1c22c36a-c104-49c2-8fd6-49fa0783d374}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main">
      <UniqueIdentifier>{4596e2fc-c213-4d86-ab0e-151726755c5d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\Windows">
      <UniqueIdentifier>{8beac9f5-77d8-48d1-8f15-b8a8defbfc7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Input">
      <UniqueIdentifier>{6411e1cf-d1af-4bf9-809b-13b838018802}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Math">
      <UniqueIdentifier>{f516f058-b322-4fde-b264-0e9de83cc2e8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source">
      <UniqueIdentifier>{686bd395-b1ec-4d2b-91d1-2b4a2ed7d490}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Main\SDL">
      <UniqueIdentifier>{a2a870b3-ac35-4588-8ace-1806d63fc865}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Game.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\Menu.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\pch.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\AccountHelpers.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Authentication.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Friends.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Metrics.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Platform.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Player.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\Users.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\Console.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\Model.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AuthDialogs.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ConsoleDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ExitDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendsDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Button.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Checkbox.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendInfo.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\FriendList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Scroller.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Sprite.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextField.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextLabel.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Widget.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Font.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Texture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Input\Input.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Main\Main.cpp">
      <Filter>SharedSource\Main</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Main\Windows\DeviceResources.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Main\Windows\WinMain.cpp">
      <Filter>SharedSource\Main\Windows</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Math\Vector2.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Math\Vector3.cpp">
      <Filter>SharedSource\Math</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AnimatedTexture.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextureManager.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\SDLSpriteBatch.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\SDLTTF.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TextEditor.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\ProgressBar.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Input\SDLInput.cpp">
      <Filter>SharedSource\Input</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Main\SDL\SDLMain.cpp">
      <Filter>SharedSource\Main\SDL</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\VectorRender.cpp">
      <Filter>SharedSource\Graphics</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\Dialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\DropDownList.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\StringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\TableRowView.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\SelectableStringViewListEntry.cpp">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\PopupDialog.cpp">
      <Filter>SharedSource\Graphics\GUI\Dialogs</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClInclude Include="..\..\Shared\Source\Utils\CircularBuffer.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClCompile Include="..\..\Shared\Source\Core\EosUI.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\BaseGame.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\BaseLevel.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\BaseMenu.cpp">
      <Filter>SharedSource</Filter>
    </ClCompile>
    <ClCompile Include="Source\Voice.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceRoomMemberTableRowView.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceSetupDialog.cpp">
      <Filter>Source</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Core\HTTPClient.cpp">
      <Filter>SharedSource\Core</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Graphics\GUI\AssetUtils.cpp">
      <Filter>SharedSource\Graphics\GUI</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Source\game.ico">
      <Filter>Source</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\addbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\checkbox_ticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\checkbox_unticked.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\console.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\friendback.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\friends.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\Logo.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\menu_background.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\nobutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\scroll_down_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\scroll_up_button.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\scrollbar.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\search.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\solid_white.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\textfield.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\yesbutton.dds">
      <Filter>SharedAssets</Filter>
    </Image>
    <Image Include="..\..\Shared\Assets\button_pressed.dds">
      <Filter>SharedAssets</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <None Include="Source\resource.aps">
      <Filter>Source</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto8.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\Roboto24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold10.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold12.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold14.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold16.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold18.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Assets\RobotoBold24.spritefont">
      <Filter>SharedAssets</Filter>
    </None>
    <None Include="..\..\Shared\Source\Graphics\GUI\ListView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
    <None Include="..\..\Shared\Source\Graphics\GUI\TableView.inl">
      <Filter>SharedSource\Graphics\GUI\Widgets</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Source\resource.rc">
      <Filter>Source</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`EAC_SDK/Samples/Voice/Client/settings.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3" >
  <asmv3:application>
    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
      <dpiAware>True/PM</dpiAware>
    </asmv3:windowsSettings>
  </asmv3:application>
   <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
       <application> 
           <!-- Windows Vista -->
           <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
           <!-- Windows 7 -->
           <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
           <!-- Windows 8 -->
           <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
           <!-- Windows 8.1 -->
           <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
           <!-- Windows 10 -->
           <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
       </application> 
   </compatibility>
</assembly>

```

`EAC_SDK/Samples/Voice/Server/Source/ApiParams.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "ApiParams.h"

#include "rapidjson/document.h"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include "rapidjson/error/en.h"

FParseResult FCreateSessionParams::FromRequestBody(const std::string& Body, FCreateSessionParams& Out)
{	
	rapidjson::Document ReqDoc;	
	ReqDoc.Parse(Body.c_str());
	if (ReqDoc.HasParseError())
	{
		const rapidjson::ParseErrorCode ParseErr = ReqDoc.GetParseError();
		return RESULT_FAILED(rapidjson::GetParseError_En(ParseErr));
	}

	if (!ReqDoc.HasMember("puid") || !ReqDoc["puid"].IsString())
	{
		return RESULT_FAILED("Missing string parameter: puid");
	}

	// optional password
	if (ReqDoc.HasMember("password"))
	{
		if (!ReqDoc["password"].IsString())
		{
			return RESULT_FAILED("Invalid password, expected string");
		}
		Out.Password = ReqDoc["password"].GetString();
	}
	
	Out.Puid = ReqDoc["puid"].GetString();
	return RESULT_OK();
}

FParseResult FKickUserParams::FromRequestBody(const std::string& Body, FKickUserParams& Out)
{
	rapidjson::Document ReqDoc;
	ReqDoc.Parse(Body.c_str());
	if (ReqDoc.HasParseError())
	{
		const rapidjson::ParseErrorCode ParseErr = ReqDoc.GetParseError();
		return RESULT_FAILED(rapidjson::GetParseError_En(ParseErr));
	}

	if (!ReqDoc.HasMember("lock") || !ReqDoc["lock"].IsString())
	{
		return RESULT_FAILED("Missing string parameter: lock");
	}
	
	Out.Lock= ReqDoc["lock"].GetString();
	return RESULT_OK();
}


FParseResult FMuteUserParams::FromRequestBody(const std::string& Body, FMuteUserParams& Out)
{
	rapidjson::Document ReqDoc;
	ReqDoc.Parse(Body.c_str());
	if (ReqDoc.HasParseError())
	{
		const rapidjson::ParseErrorCode ParseErr = ReqDoc.GetParseError();
		return RESULT_FAILED(rapidjson::GetParseError_En(ParseErr));
	}

	if (!ReqDoc.HasMember("lock") || !ReqDoc["lock"].IsString())
	{
		return RESULT_FAILED("Missing string parameter: lock");
	}

	if (!ReqDoc.HasMember("mute") || !ReqDoc["mute"].IsBool())
	{
		return RESULT_FAILED("Missing bool parameter: mute");
	}
	
	Out.Lock = ReqDoc["lock"].GetString();
	Out.bMute = ReqDoc["mute"].GetBool();

	return RESULT_OK();
}

FParseResult FHeartbeatParams::FromRequestBody(const std::string& Body, FHeartbeatParams& Out)
{
	rapidjson::Document ReqDoc;
	ReqDoc.Parse(Body.c_str());

	if (ReqDoc.HasParseError())
	{
		const rapidjson::ParseErrorCode ParseErr = ReqDoc.GetParseError();
		return RESULT_FAILED(rapidjson::GetParseError_En(ParseErr));
	}

	if (!ReqDoc.HasMember("lock") || !ReqDoc["lock"].IsString())
	{
		return RESULT_FAILED("Missing string parameter: lock");
	}

	Out.Lock = ReqDoc["lock"].GetString();

	return RESULT_OK();
}
```

`EAC_SDK/Samples/Voice/Server/Source/ApiParams.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "VoiceUser.h"

class FParseResult
{
public:
	FParseResult() : bIsSuccess(true) {}
	explicit FParseResult(const std::string& Error) : bIsSuccess(false), ErrorMsg(Error) {}

	bool IsOk() const { return bIsSuccess; }
	const std::string& GetError() const { return ErrorMsg; }

private:
	bool bIsSuccess = false;
	std::string ErrorMsg;
};

#define RESULT_OK() FParseResult();
#define RESULT_FAILED(x) FParseResult(x);

class FCreateSessionParams final
{
public:
	FCreateSessionParams() {}
	static FParseResult FromRequestBody(const std::string& Body, FCreateSessionParams& Out);

	const std::string& GetPuid() const { return Puid; }
	const std::string& GetPassword() const { return Password; }
	const bool RequiresPassword() const { return Password != ""; }

private:	
	std::string Puid;
	std::string Password;
};

class FKickUserParams final
{
public:
	FKickUserParams() {}
	static FParseResult FromRequestBody(const std::string& Body, FKickUserParams& Out);
	const std::string& GetLock() const { return Lock; }

private:
	std::string Lock;
};

class FMuteUserParams final
{
public:
	FMuteUserParams() {}
	static FParseResult FromRequestBody(const std::string& Body, FMuteUserParams& Out);
	
	const std::string& GetLock() const { return Lock; }
	bool ShouldMute() const { return bMute; }

private:	
	std::string Lock;
	bool bMute = false;
};

class FHeartbeatParams final
{
public:
	FHeartbeatParams() {}
	static FParseResult FromRequestBody(const std::string& Body, FHeartbeatParams& Out);
	const std::string& GetLock() const { return Lock; }	

private:
	std::string Lock;
};



```

`EAC_SDK/Samples/Voice/Server/Source/Main/MacMain.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

int MainDriverMac(int argc, const char* argv[], int (*Driver)(int, const char*[]));


```

`EAC_SDK/Samples/Voice/Server/Source/Main/MacMain.mm`:

```mm
// Copyright Epic Games, Inc. All Rights Reserved.

#include "MacMain.h"

#if __APPLE__

#import <CoreFoundation/CoreFoundation.h>
#import <AppKit/AppKit.h>

@interface AppDelegate : NSObject <NSApplicationDelegate>
@property (nonatomic, assign) int argc;
@property (nonatomic, assign) const char** argv;
@property (atomic, retain) NSThread* logicThread;
@property (nonatomic, assign) int exitCode;
@property (nonatomic, assign) int (*Driver)(int, const char* []);

- (id)initWithCommandLineParams:(int)argc argv:(const char* [])argv driver:(int (*)(int, const char* []))Driver;
@end

@implementation AppDelegate
- (id)initWithCommandLineParams:(int)argc argv:(const char* [])argv driver:(int (*)(int, const char* []))Driver
{
	if (!Driver) {
		return nil;
	}
	
	if (self = [super init]) {
		_argc = argc;
		_argv = argv;
		_Driver = Driver;
		_logicThread = NULL;
		_exitCode = -1;
	}
	return self;
}

- (void)dealloc
{
	[_logicThread release];
	[super dealloc];
}

- (void)handleQuitEvent:(NSAppleEventDescriptor*)event withReplyEvent:(NSAppleEventDescriptor*)replyEvent
{
	self.exitCode = -1;
	[self terminate];
}

- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
{
	self.exitCode = -1;
	[self terminate];
	return NSTerminateCancel;
}

- (void)applicationDidFinishLaunching:(NSNotification *)notification
{
	NSAppleEventManager* eventManager = [NSAppleEventManager sharedAppleEventManager];
	[eventManager setEventHandler:self andSelector:@selector(handleQuitEvent:withReplyEvent:) forEventClass:kCoreEventClass andEventID:kAEQuitApplication];
	
	self.logicThread = [[NSThread alloc] initWithBlock:^{
		self.exitCode = (*self.Driver)(self.argc, self.argv);
		[self terminate];
	}];
	[self.logicThread start];
}

- (void)terminate
{
	NSEvent* dummyEvent = [NSEvent otherEventWithType:NSEventTypeApplicationDefined location:{0, 0} modifierFlags:0 timestamp:0 windowNumber:0 context:nil subtype:0 data1:0 data2:0];
	[NSApp stop:self];
	[NSApp postEvent:dummyEvent atStart:TRUE];
}

@end

void DisableAppNap(void)
{
	if ([[NSProcessInfo processInfo] respondsToSelector:@selector(beginActivityWithOptions:reason:)])
	{
		[[NSProcessInfo processInfo] beginActivityWithOptions:0x00FFFFFF reason:@"Not sleepy and don't want to nap"];
	}
}

#endif

int MainDriverMac(int argc, const char* argv[], int (*Driver)(int, const char*[]))
{
#if __APPLE__
	DisableAppNap();
	NSAutoreleasePool* AutoreleasePool = [NSAutoreleasePool new];
	NSApplication* app = [NSApplication sharedApplication];
	AppDelegate* delegate = [[AppDelegate alloc] initWithCommandLineParams:argc argv:argv driver:Driver];
	app.delegate = delegate;
	[app run];
	app.delegate = NULL;
	
	int returnValue = [delegate exitCode];
	[delegate release];
	[AutoreleasePool release];
	return returnValue;
#else
	(void)Driver;
	return 0;
#endif
}


```

`EAC_SDK/Samples/Voice/Server/Source/Main/Main.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "Main.h"

#include "DebugLog.h"
#include "StringUtils.h"
#include "CommandLine.h"
#include "Settings.h"

#define CONSOLE_COL_WHITE "\033[1m\033[37m"		// White
#define CONSOLE_COL_RED "\033[1m\033[31m"		// Red
#define CONSOLE_COL_YELLOW "\033[1m\033[33m"	// Yellow
#define CONSOLE_COL_RESET "\033[0m"				// Reset

std::unique_ptr<FMain> Main;

FMain::FMain() noexcept(false)
{
	FDebugLog::Init();
#ifdef _WIN32
	FDebugLog::AddTarget(FDebugLog::ELogTarget::DebugOutput);
#endif // _WIN32
	FDebugLog::AddTarget(FDebugLog::ELogTarget::Console);
	FDebugLog::AddTarget(FDebugLog::ELogTarget::File);
}

FMain::~FMain()
{
	FDebugLog::Close();
}

void FMain::InitCommandLine()
{

}

void FMain::PrintToConsole(const std::wstring& Message)
{
	const std::string Msg = CONSOLE_COL_WHITE + FStringUtils::Narrow(Message) + CONSOLE_COL_RESET;
	puts(Msg.c_str());
}

void FMain::PrintWarningToConsole(const std::wstring& Message)
{
	const std::string Msg = CONSOLE_COL_YELLOW + FStringUtils::Narrow(Message) + CONSOLE_COL_RESET;
	puts(Msg.c_str());
}

void FMain::PrintErrorToConsole(const std::wstring& Message)
{
	const std::string Msg = CONSOLE_COL_RED + FStringUtils::Narrow(Message) + CONSOLE_COL_RESET;
	puts(Msg.c_str());
}
```

`EAC_SDK/Samples/Voice/Server/Source/Main/Main.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

/**
* Main class for Windows project
*/
class FMain
{
public:
	/**
	* Constructor
	*/
	FMain() noexcept(false);

	/**
	* No copying or copy assignment allowed for this class.
	*/
	FMain(FMain const&) = delete;
	FMain& operator=(FMain const&) = delete;

	/**
	* Destructor
	*/
	virtual ~FMain();

	/**
	* Initializes command line
	*/
	void InitCommandLine();

	/**
	* Utility function for printing a message to in-game console
	*
	* @param Message - Message to print to console
	*/
	void PrintToConsole(const std::wstring& Message);

	/**
	* Utility function for printing a warning message to in-game console
	*
	* @param Message - Message to print to console
	*/
	void PrintWarningToConsole(const std::wstring& Message);

	/**
	* Utility function for printing an error message to in-game console
	*
	* @param Message - Message to print to console
	*/
	void PrintErrorToConsole(const std::wstring& Message);
};

/** Global accessor for main */
extern std::unique_ptr<FMain> Main;
```

`EAC_SDK/Samples/Voice/Server/Source/Main/ServerMain.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "VoiceApi.h"
#include "VoiceHost.h"
#include "VoiceSdk.h"

#include "Main.h"

#ifdef __APPLE__
#include "MacMain.h"
#endif

#include "DebugLog.h"
#include "StringUtils.h"
#include "CommandLine.h"
#include "Settings.h"
#include "SampleConstants.h"

using namespace std;

constexpr uint16 SampleConstants::ServerPort;

bool bIsRunning = true;

#ifdef _WIN32
BOOL WINAPI ConsoleHandler(DWORD CtrlType)
{
	static const WCHAR* EventNames[7] = {
		L"CTRL_C_EVENT",
		L"CTRL_BREAK_EVENT",
		L"CTRL_CLOSE_EVENT",
		L"", // Reserved
		L"", // Reserved
		L"CTRL_LOGOFF_EVENT",
		L"CTRL_SHUTDOWN_EVENT"
	};

	switch (CtrlType)
	{
		case CTRL_C_EVENT:
		case CTRL_BREAK_EVENT:
		case CTRL_CLOSE_EVENT:
		case CTRL_LOGOFF_EVENT:
		case CTRL_SHUTDOWN_EVENT:
			FDebugLog::Log(L"Exiting due to %ls...", EventNames[CtrlType]);
			bIsRunning = false;		
			return TRUE;

		default:
			return FALSE;
	}
}
#endif // _WIN32

int MasterMain(int Argc, const char* Args[])
{
	std::wstring CommandLine;
	for (int i = 0; i < Argc; ++i)
	{
		CommandLine += (FStringUtils::Widen(Args[i]) + L" ");
	}

	FCommandLine::Get().Init(const_cast<LPWSTR>(CommandLine.c_str()));
	FSettings::Get().Init();

	Main = std::make_unique<FMain>();
	Main->InitCommandLine();

	FDebugLog::Log(L"EOS Voice Server Sample");

	bIsRunning = true;

#ifdef _WIN32
	if (!SetConsoleCtrlHandler(ConsoleHandler, TRUE))
	{
		FDebugLog::LogError(L"Could not set control handler!");
		return 1;
	}
#endif // _WIN32

	// parse listen port
	uint16 Port = SampleConstants::ServerPort;
	if (FCommandLine::Get().HasParam(CommandLineConstants::ServerPort))
	{
		try
		{
			Port = static_cast<uint16>(std::stoi(FCommandLine::Get().GetParamValue(CommandLineConstants::ServerPort)));
		}
		catch (const std::invalid_argument&)
		{
			FDebugLog::LogError(L"Error: Can't parse port - invalid argument");
		}
		catch (const std::out_of_range&)
		{
			FDebugLog::LogError(L"Error: Can't parse port - out of range.");
		}
		catch (const std::exception&)
		{
			FDebugLog::LogError(L"Error: Can't parse port, undefined error.");
		}
	}

	// create and load sdk
	FVoiceSdkPtr EosVoiceSdk = FVoiceSdkPtr(new FVoiceSdk());
	if (!EosVoiceSdk->LoadAndInitSdk())
	{
		FDebugLog::LogError(L"Unable to initialize sdk!");
		return 1;
	}

	// start voice host on its own thread
	FVoiceHostPtr VoiceHost = FVoiceHostPtr(new FVoiceHost());
	FVoiceApi Api(VoiceHost, EosVoiceSdk);
	if (Api.Listen(Port) == false)
	{
		FDebugLog::LogError(L"Unable to listen on port %d", Port);
		FDebugLog::Log(L"Exiting...");
		return 1;
	}

	FDebugLog::Log(L"Listening on port %d", Port);
	FDebugLog::Log(L"(ctrl - c) to exit");

	// main loop
	while (bIsRunning)
	{
		// update the sdk on the mainthread
		EosVoiceSdk->Tick();

		// remove any sessions that haven't received a heartbeat within the given timeout
		size_t NumRemoved = VoiceHost->RemoveExpiredSessions();
		if (NumRemoved > 0)
		{
			FDebugLog::Log(L"Removed %d expired sessions", NumRemoved);
		}
		
		// simulate other server activity
		std::this_thread::sleep_for(std::chrono::milliseconds(30));
	}

	// stop accepting requests
	Api.Stop();

	// then shutdown the sdk
	EosVoiceSdk->Shutdown();

	return 0;
}

int main(int argc, const char *argv[])
{

#if __APPLE__
	int returnValue = MainDriverMac(argc, argv, &MasterMain);
#else
	int returnValue = MasterMain(argc, argv);
#endif
	
	return returnValue;
}

```

`EAC_SDK/Samples/Voice/Server/Source/NonCopyable.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

class FNonCopyable
{
public:
	FNonCopyable() {}

	FNonCopyable(const FNonCopyable&) = delete;
	FNonCopyable& operator=(const FNonCopyable&) = delete;
};

```

`EAC_SDK/Samples/Voice/Server/Source/SampleConstants.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

struct SampleConstants
{
	/** The product id for the running application, found on the dev portal */
	static constexpr char ProductId[] = "";

	/** The sandbox id for the running application, found on the dev portal */
	static constexpr char SandboxId[] = "";

	/** The deployment id for the running application, found on the dev portal */
	static constexpr char DeploymentId[] = "";

	/** Client id of the service permissions entry, found on the dev portal */
	static constexpr char ClientCredentialsId[] = "";

	/** Client secret for accessing the set of permissions, found on the dev portal */
	static constexpr char ClientCredentialsSecret[] = "";

	/** Game name */
	static constexpr char GameName[] = "Voice Server";

	/** Encryption key. Not used by this sample. */
	static constexpr char EncryptionKey[] = "1111111111111111111111111111111111111111111111111111111111111111";

	/** Server Port */
	static constexpr uint16 ServerPort = 1234;
};

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceApi.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#define RAPIDJSON_HAS_STDSTRING 1
#include "rapidjson/document.h"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"
#include "rapidjson/error/en.h"

#include "ApiParams.h"
#include "VoiceApi.h"
#include "VoiceHost.h"
#include "VoiceUser.h"
#include "VoiceRequestKickUser.h"
#include "VoiceRequestMuteUser.h"

#include "DebugLog.h"
#include "StringUtils.h"
#include "Utils.h"

#include "eos_common.h"

namespace
{
	std::string JsonDocToString(const rapidjson::Document& Document)
	{
		rapidjson::StringBuffer Buffer;
		Buffer.Clear();

		rapidjson::Writer<rapidjson::StringBuffer> Writer(Buffer);
		Document.Accept(Writer);

		return std::string(Buffer.GetString());
	}

	std::string FormatBadRequest(const std::string& Message)
	{
		rapidjson::Document Doc;
		Doc.SetObject();
		Doc.AddMember("error", "bad request", Doc.GetAllocator());
		Doc.AddMember("description", Message, Doc.GetAllocator());
		return JsonDocToString(Doc);
	}
}


const std::string FVoiceApi::ErrorSessionNotFound = "{\"error\" : \"session not found\" }";
const std::string FVoiceApi::ErrorUserNotFound = "{\"error\" : \"user not found\" }";
const std::string FVoiceApi::ErrorForbidden = "{\"error\" : \"invalid lock\" }";
const std::string FVoiceApi::ErrorUnauthorized = "{\"error\" : \"unauthorized\" }";
const std::string FVoiceApi::ErrorTimedOut = "{\"error\" : \"timed out\" }";

const char* FVoiceApi::ContentTypeJson = "application/json";

FVoiceApi::FVoiceApi(const FVoiceHostPtr& InVoiceHost, const FVoiceSdkPtr& InVoiceSDK) :
	VoiceHost(InVoiceHost),
	VoiceSdk(InVoiceSDK)
{
	assert(VoiceHost != nullptr);
	assert(VoiceSdk != nullptr);

	// setup logging
	Api.set_logger([](const Request& Req, const Response& Res) {
		FDebugLog::Log(L"%d | %ls | %ls (%ls)",
			Res.status,
			FStringUtils::Widen(Req.method).c_str(),
			FStringUtils::Widen(Req.path).c_str(),
			FStringUtils::Widen(Req.remote_addr).c_str());
	});

	// create voice session
	Api.Post("/session", [&](const Request& Req, Response &Res) {
		FCreateSessionParams Params;
		FParseResult ParseResult = FCreateSessionParams::FromRequestBody(Req.body, Params);
		if (ParseResult.IsOk())
		{
			// create a random roomId and request a roomToken
			const std::string RoomId = FUtils::GenerateRandomId(16);

			// This http request callback is called on one of the http threadpool threads.
			// All EOS SDK calls must originate from the same thread.
			// To handle this we enqueue a request in the VoiceSdk and wait for its promised result on this thread
			// The main loop will process all EOS SDK requests on the main thread.
			FJoinRoomReceiptPtr Receipt = VoiceSdk->CreateJoinRoomTokens(RoomId.c_str(), { FVoiceUser(Params.GetPuid(), Req.remote_addr) });

			// blocks until the request has been completed
			Receipt->WaitForResult();
			
			const FJoinRoomResult TokenResult = Receipt->GetResult();
			if (TokenResult.Result == EOS_EResult::EOS_Success)
			{
				// generate a lock key that is required for owner-level operations, such as kick or mute.
				const std::string OwnerLock = FUtils::GenerateRandomId(8);

				// add the session and create the json response
				FVoiceSessionPtr Session = FVoiceSessionPtr(new FVoiceSession(RoomId, OwnerLock, Params.GetPassword(), { FVoiceUser(Params.GetPuid(), Req.remote_addr) }));
				VoiceHost->AddSession(Session);

				rapidjson::Document Doc;
				Doc.SetObject();

				Doc.AddMember("sessionId", RoomId, Doc.GetAllocator());
				Doc.AddMember("ownerLock", OwnerLock, Doc.GetAllocator());
				Doc.AddMember("clientBaseUrl", TokenResult.ClientBaseUrl, Doc.GetAllocator());

				rapidjson::Document TokenObj;
				TokenObj.SetObject();
				for (const auto& TokenPair : TokenResult.Tokens)
				{
					TokenObj.AddMember(rapidjson::StringRef(TokenPair.ProductUserId), TokenPair.Token, TokenObj.GetAllocator());
				}
				Doc.AddMember("joinTokens", TokenObj, Doc.GetAllocator());

				Res.status = 200;
				Res.set_content(JsonDocToString(Doc).c_str(), FVoiceApi::ContentTypeJson);

				FDebugLog::Log(L"Created session %ls", FStringUtils::Widen(RoomId).c_str());
			}
			else if (TokenResult.Result == EOS_EResult::EOS_TimedOut)
			{
				Res.status = 408;
				Res.set_content(FVoiceApi::ErrorTimedOut, FVoiceApi::ContentTypeJson);
			}
			else
			{
				Res.status = 500;
			}
		}
		else
		{
			Res.status = 400;
			Res.set_content(FormatBadRequest(ParseResult.GetError()).c_str(), FVoiceApi::ContentTypeJson);
		}
	});

	// join session
	Api.Post(R"(/session/([a-zA-Z0-9\-]+)/join/([a-zA-Z0-9\-]+))", [&](const Request& Req, Response& Res) {
		const std::string& SessionId = Req.matches[1];
		const std::string& Puid = Req.matches[2];

		FVoiceSessionPtr Session = VoiceHost->FindSession(SessionId);
		if (Session.get() != nullptr)
		{
			const FVoiceUser NewUser(Puid, Req.remote_addr);

			// authenticate optional password and check banned list
			const std::string Password = Req.has_param("password") ? Req.get_param_value("password") : "";
			if (!Session->MatchesPassword(Password) || Session->IsUserBanned(NewUser))
			{
				Res.status = 403;
				Res.set_content(FVoiceApi::ErrorUnauthorized, FVoiceApi::ContentTypeJson);
			}
			else
			{
				// request token to join the session
				FJoinRoomReceiptPtr Receipt = VoiceSdk->CreateJoinRoomTokens(SessionId.c_str(), { NewUser });

				// blocks until the request has been completed
				Receipt->WaitForResult();
				
				const FJoinRoomResult Result = Receipt->GetResult();
				if (Result.Result == EOS_EResult::EOS_TimedOut)
				{
					Res.status = 408;
					Res.set_content(FVoiceApi::ErrorTimedOut, FVoiceApi::ContentTypeJson);
				}
				else
				{
					Session->AddUser(FVoiceUser{ Puid, Req.remote_addr });

					rapidjson::Document Doc;
					Doc.SetObject();
					Doc.AddMember("sessionId", SessionId, Doc.GetAllocator());
					Doc.AddMember("clientBaseUrl", Result.ClientBaseUrl, Doc.GetAllocator());

					rapidjson::Document TokenObj;
					TokenObj.SetObject();
					for (const auto& TokenPair : Result.Tokens)
					{
						TokenObj.AddMember(rapidjson::StringRef(TokenPair.ProductUserId), TokenPair.Token, TokenObj.GetAllocator());
					}
					Doc.AddMember("joinTokens", TokenObj, Doc.GetAllocator());

					Res.status = 200;
					Res.set_content(JsonDocToString(Doc).c_str(), FVoiceApi::ContentTypeJson);
				}
			}
		}
		else
		{
			Res.status = 404;
			Res.set_content(FVoiceApi::ErrorSessionNotFound, FVoiceApi::ContentTypeJson);
		}
	});

	// kickUser
	Api.Post(R"(/session/([a-zA-Z0-9\-]+)/kick/([a-zA-Z0-9\-]+))", [&](const Request& Req, Response& Res) {
		const std::string RoomId = Req.matches[1];
		const std::string UserId = Req.matches[2];

		FVoiceSessionPtr Session = VoiceHost->FindSession(RoomId);
		if (Session.get() != nullptr)
		{
			FKickUserParams Params;
			FParseResult Result = FKickUserParams::FromRequestBody(Req.body, Params);
			if (Result.IsOk())
			{
				// check lock
				if (Session->GetLock() != Params.GetLock())
				{
					Res.status = 403;
					Res.set_content(FVoiceApi::ErrorForbidden, FVoiceApi::ContentTypeJson);
				}
				else
				{
					FVoiceUser User{ UserId, std::string() };

					// kick user
					FVoiceRequestReceiptPtr Receipt = VoiceSdk->KickUser(RoomId.c_str(), EOS_ProductUserId_FromString(UserId.c_str()));

					// blocks until the request has been completed
					Receipt->WaitForResult();
					EOS_EResult KickResult = Receipt->GetResult();

					if (KickResult == EOS_EResult::EOS_Success)
					{
						// remove user and ban from rejoining
						Session->RemoveUser(User);
						Session->BanUser(User);
						Res.status = 204;
					}
					else if (KickResult == EOS_EResult::EOS_TimedOut)
					{
						Res.status = 408;
						Res.set_content(FVoiceApi::ErrorTimedOut, FVoiceApi::ContentTypeJson);
					}					
					else
					{
						Res.status = 500;
					}
				}
			}
			else
			{
				Res.status = 400;
				Res.set_content(FormatBadRequest(Result.GetError()).c_str(), FVoiceApi::ContentTypeJson);
			}
		}
		else
		{
			Res.status = 404;
			Res.set_content(FVoiceApi::ErrorSessionNotFound, FVoiceApi::ContentTypeJson);
		}
	});

	// muteUser
	Api.Post(R"(/session/([a-zA-Z0-9\-]+)/mute/([a-zA-Z0-9\-]+))", [&](const Request& Req, Response& Res) {
		const std::string RoomId = Req.matches[1];
		const std::string UserId = Req.matches[2];

		FVoiceSessionPtr Session = VoiceHost->FindSession(RoomId);
		if (Session.get() != nullptr)
		{
			FMuteUserParams Params;
			FParseResult Result = FMuteUserParams::FromRequestBody(Req.body, Params);
			if (Result.IsOk())
			{
				// check lock
				if (Session->GetLock() != Params.GetLock())
				{
					Res.status = 403;
					Res.set_content(FVoiceApi::ErrorForbidden, FVoiceApi::ContentTypeJson);
				}
				else
				{
					// hard mute/unmute user
					FVoiceRequestReceiptPtr Receipt = VoiceSdk->MuteUser(RoomId.c_str(), EOS_ProductUserId_FromString(UserId.c_str()) , Params.ShouldMute());

					// blocks until the request has been completed
					Receipt->WaitForResult();
					EOS_EResult MuteResult = Receipt->GetResult();

					if (MuteResult == EOS_EResult::EOS_Success)
					{
						Res.status = 204;
					}
					else if (MuteResult == EOS_EResult::EOS_TimedOut)
					{
						Res.status = 408;
						Res.set_content("Request Timeout", FVoiceApi::ContentTypeJson);
					}
					else
					{
						Res.status = 500;
					}
					
				}
			}
			else
			{
				Res.status = 400;
				Res.set_content(FormatBadRequest(Result.GetError()).c_str(), FVoiceApi::ContentTypeJson);
			}
		}
		else
		{
			Res.status = 404;
			Res.set_content(FVoiceApi::ErrorSessionNotFound, FVoiceApi::ContentTypeJson);
		}
	});

	// heartbeat session
	Api.Post(R"(/session/([a-zA-Z0-9\-]+)/heartbeat)", [&](const Request& Req, Response& Res) {
		const std::string RoomId = Req.matches[1];

		FVoiceSessionPtr Session = VoiceHost->FindSession(RoomId);
		if (Session.get() != nullptr)
		{
			FHeartbeatParams Params;
			FParseResult Result = FHeartbeatParams::FromRequestBody(Req.body, Params);
			if (Result.IsOk())
			{
				// Heartbeating requires the session lock from the session owner
				// This sample only uses the heartbeat to expire old session from the VoiceHost.
				// A real world application may want to include heartbeats from all participants to remove players from sessions in a similar fashion.
				if (Params.GetLock() == Session->GetLock())
				{
					Session->ResetHeartbeat();
					Res.status = 204;
				}
				else
				{
					Res.status = 403;
					Res.set_content(FVoiceApi::ErrorForbidden, FVoiceApi::ContentTypeJson);
				}
			}
		}
		else
		{
			Res.status = 404;
			Res.set_content(FVoiceApi::ErrorSessionNotFound, FVoiceApi::ContentTypeJson);
		}
	});
}

bool FVoiceApi::Listen(unsigned short Port)
{	
	// start api on a new thread to not block main thread
	ApiThread = std::thread{ [this, Port]() { Api.listen("0.0.0.0", Port); } };
	return true;
}

void FVoiceApi::Stop()
{
	// stop the Api thread and wait for it to complete
	if (ApiThread.joinable())
	{
		Api.stop();
		ApiThread.join();
	}
}

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceApi.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NonCopyable.h"
#include "VoiceSdk.h"

#include "httplib/httplib.h"

using namespace httplib;

class UserActionParams;

/** Api hosting http endpoints and threadpool */
class FVoiceApi : public FNonCopyable
{
public:
	FVoiceApi(const FVoiceHostPtr& InVoiceHost, const FVoiceSdkPtr& InVoiceSDK);
	
	bool Listen(unsigned short Port);
	void Stop();

	/** Errors & constants */
	static const std::string ErrorSessionNotFound;
	static const std::string ErrorUnauthorized;
	static const std::string ErrorUserNotFound;
	static const std::string ErrorForbidden;
	static const std::string ErrorTimedOut;
	static const char* ContentTypeJson;

private:
	
	/** Note: The VoiceServer sample uses a simple http api to demonstrate communication between clients and the trusted server application.
	  * The http framework used here was chosen for its simplicity, not scalability. 
	  * Real-world applications should consider high-performance asynchronous frameworks or utilize their existing client-server network messaging (e.g. when using dedicated servers).
	*/
	Server Api;
	std::thread ApiThread;

	FVoiceHostPtr VoiceHost;
	FVoiceSdkPtr VoiceSdk;

	EOS_HRTCAdmin RTCAdminHandle = 0;
};

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceHost.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "VoiceHost.h"

bool FVoiceHost::AddSession(const FVoiceSessionPtr& Session)
{
	FScopedLock Lock(SessionMutex);

	Sessions.push_back(Session);
	return true;
}

bool FVoiceHost::RemoveSession(const std::string& Id)
{
	FScopedLock Lock(SessionMutex);
	return erase_if(Sessions, [&Id](const FVoiceSessionPtr& VoiceSession) { return VoiceSession->GetId() == Id; }) != 0;
}

FVoiceSessionPtr FVoiceHost::FindSession(const std::string& Id)
{
	for (std::vector<FVoiceSessionPtr>::iterator Itr = Sessions.begin(); Itr != Sessions.end(); ++Itr)
	{
		if ((*Itr)->GetId() == Id)
		{
			return *Itr;
		}
	}

	return FVoiceSessionPtr(nullptr);
}

size_t FVoiceHost::RemoveExpiredSessions()
{	
	// Removes all sessions that have expired due to lack of heartbeat.
	// The sample leaves at that and future calls to e.g. join the session will result in Http 404 once expired and removed.
	// Applications may want to include a notification pushed from the server to all room participants or have the client deal with it accordingly.

	const auto Now = std::chrono::steady_clock::now();
	FScopedLock Lock(SessionMutex);
	return erase_if(Sessions, [&Now](const FVoiceSessionPtr& VoiceSession) { return VoiceSession->IsExpired(Now); });
}

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceHost.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "VoiceSession.h"

/** Container for multiple voice sessions, managing synchronization */
class FVoiceHost
{
public:
	FVoiceHost() {}

	bool AddSession(const FVoiceSessionPtr& Session);	
	bool RemoveSession(const std::string& Id);
	
	FVoiceSessionPtr FindSession(const std::string& Id);

	/** Compares expiration timestamps of sessions and removes expired ones, clients heartbeat to keep sessions alive. */
	size_t RemoveExpiredSessions();


private:
	std::mutex SessionMutex;
	std::vector<FVoiceSessionPtr> Sessions;
};
```

`EAC_SDK/Samples/Voice/Server/Source/VoiceRequest.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "VoiceRequest.h"
#include "VoiceSdk.h"

#include "Utils.h"

FVoiceRequestReceipt::~FVoiceRequestReceipt()
{
	if (VoiceSdk && VoiceRequestHandle)
	{
		VoiceSdk->ReleaseRequest(VoiceRequestHandle);
	}
}

void FVoiceRequestReceipt::WaitForResult()
{
	ResultFuture.wait();
}
```

`EAC_SDK/Samples/Voice/Server/Source/VoiceRequest.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NonCopyable.h"

#include <eos_rtc_admin.h>

class FVoiceRequest
{
public:
	virtual ~FVoiceRequest() { }
	virtual EOS_EResult MakeRequest(EOS_HRTCAdmin RTCAdminHandle) = 0;
};

using FVoiceRequestPtr = std::unique_ptr<FVoiceRequest>;
using FVoiceRequestHandle = FVoiceRequest*;

class FVoiceRequestReceipt : public FNonCopyable
{
public:
	FVoiceRequestReceipt(std::future<EOS_EResult>&& InResultFuture, FVoiceRequestHandle InRequestHandle, FVoiceSdk* InVoiceSdk) :
		ResultFuture(std::move(InResultFuture)),
		VoiceRequestHandle(InRequestHandle),
		VoiceSdk(InVoiceSdk)
	{
	}

	virtual ~FVoiceRequestReceipt();

	void WaitForResult();
	EOS_EResult GetResult() { return ResultFuture.get(); }

private:
	std::future<EOS_EResult> ResultFuture;
	FVoiceRequestHandle VoiceRequestHandle = nullptr;
	FVoiceSdk* VoiceSdk = nullptr;
};
using FVoiceRequestReceiptPtr = std::unique_ptr<FVoiceRequestReceipt>;
```

`EAC_SDK/Samples/Voice/Server/Source/VoiceRequestJoin.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "VoiceRequestJoin.h"
#include "VoiceSdk.h"
#include "VoiceUser.h"

#include "DebugLog.h"
#include "Utils.h"
#include "StringUtils.h"

FJoinRoomReceipt::~FJoinRoomReceipt()
{
	if (VoiceSdk && VoiceRequestHandle)
	{
		VoiceSdk->ReleaseRequest(VoiceRequestHandle);
	}
}

void FJoinRoomReceipt::WaitForResult()
{
	ResultFuture.wait();
}

FVoiceRequestJoin::FVoiceRequestJoin(EOS_HRTCAdmin InRTCAdminHandle, const std::string& InRoomName, const std::vector<FVoiceUser>& InVoiceUsers) :
	RTCAdminHandle(InRTCAdminHandle),
	RoomName(InRoomName),
	VoiceUsers(InVoiceUsers)
{
}

std::future<FJoinRoomResult> FVoiceRequestJoin::GetFuture()
{
	return ResultPromise.get_future();
}

EOS_EResult FVoiceRequestJoin::MakeRequest(EOS_HRTCAdmin RTCAdminHandle)
{
	FDebugLog::Log(L"FVoiceRequestJoin::MakeRequest (%x)", this);

	EOS_RTCAdmin_QueryJoinRoomTokenOptions Options = {};
	Options.ApiVersion = EOS_RTCADMIN_QUERYJOINROOMTOKEN_API_LATEST;
	Options.RoomName = RoomName.c_str();

	std::vector<EOS_ProductUserId> TargetUserIds;
	std::vector<const char*> TargetUserIpAddresses;
	for (const FVoiceUser& VoiceUser : VoiceUsers)
	{
		TargetUserIds.emplace_back(VoiceUser.GetPuid());
		TargetUserIpAddresses.emplace_back(VoiceUser.GetIPAddress().c_str());
	}
	Options.TargetUserIds = TargetUserIds.data();
	Options.TargetUserIdsCount = static_cast<uint32_t>(TargetUserIds.size());
	Options.TargetUserIpAddresses = TargetUserIpAddresses.data();

	EOS_RTCAdmin_QueryJoinRoomToken(RTCAdminHandle, &Options, this, [](const EOS_RTCAdmin_QueryJoinRoomTokenCompleteCallbackInfo* Data) {
		FVoiceRequestJoin* Request = reinterpret_cast<FVoiceRequestJoin*>(Data->ClientData);

		// Wait for completion, SDK may retry
		// The lifetime of this callback and its request must be guaranteed until EOS_EResult_IsOperationComplete is true.
		// In this case, we fulfill the ResultPromise which unblocks the wait in VoiceApi. 
		// As the receipt is destructed it releases the request from ActiveRequests in VoiceSdk.
		if (EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			if (Data->ResultCode == EOS_EResult::EOS_Success)
			{
				FDebugLog::Log(L"FVoiceRequestJoin (%x) - Completed successfully for room %ls", Request, FStringUtils::Widen(Data->RoomName).c_str());

				FJoinRoomResult Result{ };
				Result.Result = Data->ResultCode;
				Result.RoomName = Data->RoomName;
				Result.ClientBaseUrl = Data->ClientBaseUrl;

				EOS_RTCAdmin_CopyUserTokenByIndexOptions CopyOptions = {};
				CopyOptions.ApiVersion = EOS_RTCADMIN_COPYUSERTOKENBYINDEX_API_LATEST;
				CopyOptions.QueryId = Data->QueryId;

				for (CopyOptions.UserTokenIndex = 0; CopyOptions.UserTokenIndex < Data->TokenCount; ++CopyOptions.UserTokenIndex)
				{
					EOS_RTCAdmin_UserToken* UserToken = NULL;
					EOS_EResult CopyResult = EOS_RTCAdmin_CopyUserTokenByIndex(Request->RTCAdminHandle, &CopyOptions, &UserToken);
					if (CopyResult == EOS_EResult::EOS_Success)
					{
						// only return tokens for puids that were requested
						if (Request->ContainsPuid(UserToken->ProductUserId))
						{
							static char PuidBuffer[EOS_PRODUCTUSERID_MAX_LENGTH + 1] = { 0 };
							int32_t PuidBufferSize = sizeof(PuidBuffer);
							EOS_EResult ToStringResult = EOS_ProductUserId_ToString(UserToken->ProductUserId, PuidBuffer, &PuidBufferSize);

							if (ToStringResult == EOS_EResult::EOS_Success)
							{
								Result.Tokens.push_back(FPuidToken(PuidBuffer, UserToken->Token));
							}
							else
							{
								FDebugLog::LogError(L"EOS_ProductUserId_ToString Failure!");
							}
						}

						EOS_RTCAdmin_UserToken_Release(UserToken);
					}
					else
					{
						FDebugLog::LogError(L"EOS_RTCAdmin_CopyUserTokenByIndex Failure!");
					}
				}

				// setting the promise value readies the future in the receipt.
				Request->ResultPromise.set_value(Result);
			}
			else
			{
				FDebugLog::LogError(L"FVoiceRequestJoin (%x) failed: %ls", Request, FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
				FJoinRoomResult Result{ };
				Result.Result = Data->ResultCode;
				Request->ResultPromise.set_value(Result);
			}
		}
		else if (Data->ResultCode == EOS_EResult::EOS_OperationWillRetry)
		{
			FDebugLog::Log(L"FVoiceRequestJoin (%x) will retry", Request);
		}
	});

	return EOS_EResult::EOS_Success;
}

bool FVoiceRequestJoin::ContainsPuid(const EOS_ProductUserId& ProductUserId)
{	
	for (const FVoiceUser& VoiceUser : VoiceUsers)
	{
		if (VoiceUser.GetPuid() == ProductUserId)
		{
			return true;
		}
	}
	return false;
}

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceRequestJoin.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NonCopyable.h"
#include "VoiceRequest.h"
#include "VoiceUser.h"

/** A (ProductUserId, JoinRoomToken) pair */
class FPuidToken final
{
public:
	FPuidToken(const std::string& InProductUserId, const std::string& InToken) : ProductUserId(InProductUserId), Token(InToken) {}
	FPuidToken() = delete;

	std::string ProductUserId;
	std::string Token;
};

/** Result of a JoinRoom request, contains result, roomName, url to connect to and tokens for all requested ProductUserIds */
class FJoinRoomResult final
{
public:
	EOS_EResult Result;
	std::string RoomName;
	std::string ClientBaseUrl;
	std::vector<FPuidToken> Tokens;
};

/** Receipt for FVoiceRequestJoin */
class FJoinRoomReceipt : public FNonCopyable
{
public:
	FJoinRoomReceipt(std::future<FJoinRoomResult>&& InResultFuture, FVoiceRequestHandle InRequestHandle, FVoiceSdk* InVoiceSdk) :
		ResultFuture(std::move(InResultFuture)),
		VoiceRequestHandle(InRequestHandle),
		VoiceSdk(InVoiceSdk)
	{
	}

	~FJoinRoomReceipt();	
	
	void WaitForResult();
	FJoinRoomResult GetResult() { return ResultFuture.get(); }

private:
	std::future<FJoinRoomResult> ResultFuture;
	FVoiceRequestHandle VoiceRequestHandle = nullptr;
	FVoiceSdk* VoiceSdk = nullptr;
};
using FJoinRoomReceiptPtr = std::unique_ptr<FJoinRoomReceipt>;

/** A request for joinRoom tokens for a RoomId and a set of VoiceUsers */
class FVoiceRequestJoin : public FVoiceRequest, public FNonCopyable
{
public:
	FVoiceRequestJoin() = delete;	
	FVoiceRequestJoin(EOS_HRTCAdmin InRTCAdminHandle, const std::string& InRoomName, const std::vector<FVoiceUser>& InVoiceUsers);

	~FVoiceRequestJoin() {}

	virtual EOS_EResult MakeRequest(EOS_HRTCAdmin RTCAdminHandle) override;

	bool ContainsPuid(const EOS_ProductUserId& ProductUserId);
	std::future<FJoinRoomResult> GetFuture();

private:
	EOS_HRTCAdmin RTCAdminHandle = 0;
	std::string RoomName;
	std::vector<FVoiceUser> VoiceUsers;
	std::promise<FJoinRoomResult> ResultPromise;
};


```

`EAC_SDK/Samples/Voice/Server/Source/VoiceRequestKickUser.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "VoiceRequestKickUser.h"
#include "VoiceSdk.h"

#include "DebugLog.h"
#include "StringUtils.h"

FVoiceRequestKickUser::FVoiceRequestKickUser(EOS_HRTCAdmin InRTCAdminHandle, const std::string& InRoomName, const EOS_ProductUserId& InProductUserId) :
	RTCAdminHandle(InRTCAdminHandle),
	RoomName(InRoomName),
	ProductUserId(InProductUserId)
{
}

EOS_EResult FVoiceRequestKickUser::MakeRequest(EOS_HRTCAdmin RTCAdminHandle)
{
	FDebugLog::Log(L"FVoiceRequestKickUser::MakeRequest (%x)", this);

	EOS_RTCAdmin_KickOptions Options = {};
	Options.ApiVersion = EOS_RTCADMIN_KICK_API_LATEST;
	Options.RoomName = RoomName.c_str();
	Options.TargetUserId = ProductUserId;

	EOS_RTCAdmin_Kick(RTCAdminHandle, &Options, this, [](const EOS_RTCAdmin_KickCompleteCallbackInfo* Data) {
		FVoiceRequestKickUser* Request = reinterpret_cast<FVoiceRequestKickUser*>(Data->ClientData);
		
		// Wait for completion, SDK may retry
		// The lifetime of this callback and its request must be guaranteed until EOS_EResult_IsOperationComplete is true.
		// In this case, we fulfill the ResultPromise which unblocks the wait in VoiceApi. 
		// As the receipt is destructed it releases the request from ActiveRequests in VoiceSdk.
		if (EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			if (Data->ResultCode == EOS_EResult::EOS_Success)
			{
				FDebugLog::Log(L"FVoiceRequestKickUser (%x) - Completed successfully", Request);				
			}
			else
			{
				FDebugLog::LogError(L"FVoiceRequestKickUser (%x) failed: %ls", Request, FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
			}

			Request->ResultPromise.set_value(Data->ResultCode);
		}
		else if (Data->ResultCode == EOS_EResult::EOS_OperationWillRetry)
		{
			FDebugLog::LogWarning(L"FVoiceRequestKickUser (%x) will retry", Request);
		}
	});

	return EOS_EResult::EOS_Success;
}

std::future<EOS_EResult> FVoiceRequestKickUser::GetFuture()
{
	return ResultPromise.get_future();
}

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceRequestKickUser.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NonCopyable.h"
#include "VoiceRequest.h"

/** Request to kick a ProductUserId from a session */
class FVoiceRequestKickUser : public FVoiceRequest, public FNonCopyable
{
public:
	FVoiceRequestKickUser() = delete;
	FVoiceRequestKickUser(EOS_HRTCAdmin InRTCAdminHandle, const std::string& InRoomName, const EOS_ProductUserId& InProductUserId);

	virtual EOS_EResult MakeRequest(EOS_HRTCAdmin RTCAdminHandle) override;	
	std::future<EOS_EResult> GetFuture();

private:
	EOS_HRTCAdmin RTCAdminHandle = 0;
	std::string RoomName;
	EOS_ProductUserId ProductUserId;
	std::promise<EOS_EResult> ResultPromise;
};
```

`EAC_SDK/Samples/Voice/Server/Source/VoiceRequestMuteUser.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "VoiceRequestMuteUser.h"

#include "DebugLog.h"
#include "StringUtils.h"

FVoiceRequestMuteUser::FVoiceRequestMuteUser(EOS_HRTCAdmin InRTCAdminHandle, const std::string& InRoomName, const EOS_ProductUserId& InProductUserId, bool bInMute) :
	RTCAdminHandle(InRTCAdminHandle),
	RoomName(InRoomName),
	ProductUserId(InProductUserId),
	bMute(bInMute)
{
}

EOS_EResult FVoiceRequestMuteUser::MakeRequest(EOS_HRTCAdmin RTCAdminHandle)
{
	EOS_RTCAdmin_SetParticipantHardMuteOptions Options = {};
	Options.ApiVersion = EOS_RTCADMIN_SETPARTICIPANTHARDMUTE_API_LATEST;
	Options.RoomName = RoomName.c_str();
	Options.TargetUserId = ProductUserId;
	Options.bMute = bMute;

	EOS_RTCAdmin_SetParticipantHardMute(RTCAdminHandle, &Options, this, [](const EOS_RTCAdmin_SetParticipantHardMuteCompleteCallbackInfo* Data) {
		FVoiceRequestMuteUser* Request = reinterpret_cast<FVoiceRequestMuteUser*>(Data->ClientData);

		// Wait for completion, SDK may retry
		// The lifetime of this callback and its request must be guaranteed until EOS_EResult_IsOperationComplete is true.
		// In this case, we fulfill the ResultPromise which unblocks the wait in VoiceApi. 
		// As the receipt is destructed it releases the request from ActiveRequests in VoiceSdk.
		if (EOS_EResult_IsOperationComplete(Data->ResultCode))
		{
			if (Data->ResultCode == EOS_EResult::EOS_Success)
			{
				FDebugLog::Log(L"FVoiceRequestMuteUser (%x) - Completed successfully", Request);
			}
			else
			{
				FDebugLog::LogError(L"FVoiceRequestMuteUser (%x) failed: %ls", Request, FStringUtils::Widen(EOS_EResult_ToString(Data->ResultCode)).c_str());
			}

			Request->ResultPromise.set_value(Data->ResultCode);
		}
		else if (Data->ResultCode == EOS_EResult::EOS_OperationWillRetry)
		{
			FDebugLog::LogWarning(L"FVoiceRequestMuteUser (%x) will retry", Request);
		}
	});

	return EOS_EResult::EOS_Success;
}

std::future<EOS_EResult> FVoiceRequestMuteUser::GetFuture()
{
	return ResultPromise.get_future();
}
```

`EAC_SDK/Samples/Voice/Server/Source/VoiceRequestMuteUser.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NonCopyable.h"
#include "VoiceRequest.h"

/** Request to remote mute a user in a voice session */
class FVoiceRequestMuteUser : public FVoiceRequest, public FNonCopyable
{
public:
	FVoiceRequestMuteUser() = delete;
	FVoiceRequestMuteUser(EOS_HRTCAdmin InRTCAdminHandle, const std::string& InRoomName, const EOS_ProductUserId& InProductUserId, bool bMute);

	virtual EOS_EResult MakeRequest(EOS_HRTCAdmin RTCAdminHandle) override;
	std::future<EOS_EResult> GetFuture();

private:
	EOS_HRTCAdmin RTCAdminHandle = 0;
	std::string RoomName;
	EOS_ProductUserId ProductUserId;
	bool bMute = false;
	std::promise<EOS_EResult> ResultPromise;
};

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceSdk.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "VoiceSdk.h"
#include "VoiceUser.h"
#include "VoiceRequestKickUser.h"
#include "VoiceRequestMuteUser.h"

#include "SampleConstants.h"

#include "DebugLog.h"
#include "Utils.h"
#include "StringUtils.h"
#include "CommandLine.h"

#if ALLOW_RESERVED_OPTIONS
#include "ReservedPlatformOptions.h"
#endif

#ifdef _WIN32
#include "Windows/eos_Windows.h"
#endif

#include <eos_logging.h>

constexpr char SampleConstants::ProductId[];
constexpr char SampleConstants::SandboxId[];
constexpr char SampleConstants::DeploymentId[];
constexpr char SampleConstants::ClientCredentialsId[];
constexpr char SampleConstants::ClientCredentialsSecret[];
constexpr char SampleConstants::EncryptionKey[];
constexpr char SampleConstants::GameName[];

FVoiceSdk::~FVoiceSdk()
{
}

void FVoiceSdk::ReleaseRequest(FVoiceRequestHandle VoiceRequestHandle)
{
	FScopedLock Lock(RequestsMutex);

	size_t NumErased = erase_if(ActiveRequests, [=](const FVoiceRequestPtr& VoiceRequest) { return VoiceRequest.get() == VoiceRequestHandle; });
	assert(NumErased == 1);
}


EOS_Bool FVoiceSdk::LoadAndInitSdk()
{
	FDebugLog::Log(L"EOS SDK] Initializing ...");

	// Init EOS SDK
	EOS_InitializeOptions SDKOptions = {};
	SDKOptions.ApiVersion = EOS_INITIALIZE_API_LATEST;
	SDKOptions.AllocateMemoryFunction = nullptr;
	SDKOptions.ReallocateMemoryFunction = nullptr;
	SDKOptions.ReleaseMemoryFunction = nullptr;
	SDKOptions.ProductName = SampleConstants::GameName;
	SDKOptions.ProductVersion = "1.0";
	SDKOptions.Reserved = nullptr;
	SDKOptions.SystemInitializeOptions = nullptr;
	SDKOptions.OverrideThreadAffinity = nullptr;

	EOS_EResult InitResult = EOS_Initialize(&SDKOptions);
	if (InitResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::Log(L"EOS SDK] Init Failed!");
		return EOS_FALSE;
	}

	FDebugLog::Log(L"EOS SDK] Initialized. Setting Logging Callback ...");

	EOS_EResult SetLogCallbackResult = EOS_Logging_SetCallback([](const EOS_LogMessage* InMsg) {
		if (InMsg != nullptr && InMsg->Level != EOS_ELogLevel::EOS_LOG_Off)
		{
			if (InMsg->Level == EOS_ELogLevel::EOS_LOG_Error || InMsg->Level == EOS_ELogLevel::EOS_LOG_Fatal)
			{
				FDebugLog::Log(L"EOS SDK] ERROR %ls: %ls", FStringUtils::Widen(InMsg->Category).c_str(), FStringUtils::Widen(InMsg->Message).c_str());
			}
			else if (InMsg->Level == EOS_ELogLevel::EOS_LOG_Warning)
			{
				FDebugLog::Log(L"EOS SDK] WARNING %ls: %ls", FStringUtils::Widen(InMsg->Category).c_str(), FStringUtils::Widen(InMsg->Message).c_str());
			}
			else
			{
				FDebugLog::Log(L"EOS SDK] %ls: %ls", FStringUtils::Widen(InMsg->Category).c_str(), FStringUtils::Widen(InMsg->Message).c_str());
			}
		}
	});

	if (SetLogCallbackResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::Log(L"EOS SDK] Set Logging Callback Failed!");
	}
	else
	{
		FDebugLog::Log(L"EOS SDK] Logging Callback Set");
		EOS_Logging_SetLogLevel(EOS_ELogCategory::EOS_LC_ALL_CATEGORIES, EOS_ELogLevel::EOS_LOG_Verbose);
	}

	// Create platform instance
	EOS_Platform_Options PlatformOptions = {};
	PlatformOptions.ApiVersion = EOS_PLATFORM_OPTIONS_API_LATEST;
	PlatformOptions.bIsServer = EOS_TRUE;
	PlatformOptions.EncryptionKey = SampleConstants::EncryptionKey;
	PlatformOptions.OverrideCountryCode = nullptr;
	PlatformOptions.OverrideLocaleCode = nullptr;
	PlatformOptions.Flags = EOS_PF_DISABLE_OVERLAY; // no overlay needed for the server app
	PlatformOptions.CacheDirectory = FUtils::GetTempDirectory();

	bool bHasInvalidParamProductId = false;
	bool bHasInvalidParamSandboxId = false;
	bool bHasInvalidParamDeploymentId = false;
	bool bHasInvalidParamClientCreds = false;

	std::string ProductId = SampleConstants::ProductId;
	std::string SandboxId = SampleConstants::SandboxId;
	std::string DeploymentId = SampleConstants::DeploymentId;

	// Use Command Line vars to populate vars if they exist
	std::wstring CmdProductID = FCommandLine::Get().GetParamValue(CommandLineConstants::ProductId);
	if (!CmdProductID.empty())
	{
		ProductId = FStringUtils::Narrow(CmdProductID).c_str();
	}
	bHasInvalidParamProductId = ProductId.empty() ? true : false;

	bHasInvalidParamSandboxId = false;
	std::wstring CmdSandboxID = FCommandLine::Get().GetParamValue(CommandLineConstants::SandboxId);
	if (!CmdSandboxID.empty())
	{
		SandboxId = FStringUtils::Narrow(CmdSandboxID).c_str();
	}
	bHasInvalidParamSandboxId = SandboxId.empty() ? true : false;

	std::wstring CmdDeploymentID = FCommandLine::Get().GetParamValue(CommandLineConstants::DeploymentId);
	if (!CmdDeploymentID.empty())
	{
		DeploymentId = FStringUtils::Narrow(CmdDeploymentID).c_str();
	}
	bHasInvalidParamDeploymentId = DeploymentId.empty() ? true : false;

	PlatformOptions.ProductId = ProductId.c_str();
	PlatformOptions.SandboxId = SandboxId.c_str();
	PlatformOptions.DeploymentId = DeploymentId.c_str();

	std::string ClientId = SampleConstants::ClientCredentialsId;
	std::string ClientSecret = SampleConstants::ClientCredentialsSecret;

	// Use Command Line vars to populate vars if they exist
	std::wstring CmdClientID = FCommandLine::Get().GetParamValue(CommandLineConstants::ClientId);
	if (!CmdClientID.empty())
	{
		ClientId = FStringUtils::Narrow(CmdClientID).c_str();
	}
	std::wstring CmdClientSecret = FCommandLine::Get().GetParamValue(CommandLineConstants::ClientSecret);
	if (!CmdClientSecret.empty())
	{
		ClientSecret = FStringUtils::Narrow(CmdClientSecret).c_str();
	}

	bHasInvalidParamClientCreds = false;
	if (!ClientId.empty() && !ClientSecret.empty())
	{
		PlatformOptions.ClientCredentials.ClientId = ClientId.c_str();
		PlatformOptions.ClientCredentials.ClientSecret = ClientSecret.c_str();
	}
	else if (!ClientId.empty() || !ClientSecret.empty())
	{
		bHasInvalidParamClientCreds = true;
	}
	else
	{
		PlatformOptions.ClientCredentials.ClientId = nullptr;
		PlatformOptions.ClientCredentials.ClientSecret = nullptr;
	}

	if (bHasInvalidParamProductId ||
		bHasInvalidParamSandboxId ||
		bHasInvalidParamDeploymentId ||
		bHasInvalidParamClientCreds)
	{
		return false;
	}

	EOS_Platform_RTCOptions RtcOptions = { 0 };
	RtcOptions.ApiVersion = EOS_PLATFORM_RTCOPTIONS_API_LATEST;
	RtcOptions.BackgroundMode = EOS_ERTCBackgroundMode::EOS_RTCBM_LeaveRooms;

#ifdef _WIN32
	// Get absolute path for xaudio2_9redist.dll file
	wchar_t CurDir[MAX_PATH + 1] = {};
	::GetCurrentDirectoryW(MAX_PATH + 1u, CurDir);
	std::wstring BasePath = std::wstring(CurDir);
	std::string XAudio29DllPath = FStringUtils::Narrow(BasePath);
	XAudio29DllPath.append("/xaudio2_9redist.dll");

	EOS_Windows_RTCOptions WindowsRtcOptions = { 0 };
	WindowsRtcOptions.ApiVersion = EOS_WINDOWS_RTCOPTIONS_API_LATEST;
	WindowsRtcOptions.XAudio29DllPath = XAudio29DllPath.c_str();
	RtcOptions.PlatformSpecificOptions = &WindowsRtcOptions;
#else
	RtcOptions.PlatformSpecificOptions = NULL;
#endif // _WIN32

	PlatformOptions.RTCOptions = &RtcOptions;

#if ALLOW_RESERVED_OPTIONS
	SetReservedPlatformOptions(PlatformOptions);
#else
	PlatformOptions.Reserved = NULL;
#endif // ALLOW_RESERVED_OPTIONS

	PlatformHandle = EOS_Platform_Create(&PlatformOptions);

	if (PlatformHandle == nullptr)
	{
		return false;
	}

	RTCAdminHandle = EOS_Platform_GetRTCAdminInterface(PlatformHandle);

	return EOS_TRUE;
}

EOS_Bool FVoiceSdk::Shutdown()
{
	EOS_EResult ShutdownResult = EOS_Shutdown();

	// wipe the queues
	{
		FScopedLock lock(RequestsMutex);

		std::queue<FVoiceRequestPtr> empty;
		std::swap(NewRequests, empty);
		ActiveRequests.clear();
	}

	if (ShutdownResult != EOS_EResult::EOS_Success)
	{
		FDebugLog::Log(L"SDK Failed to shutdown Err:%d\n", (int32_t)ShutdownResult);
		return EOS_FALSE;
	}

	FDebugLog::Log(L"Attempting to unload the SDK...");

	return EOS_TRUE;
}

FJoinRoomReceiptPtr FVoiceSdk::CreateJoinRoomTokens(const char* RoomId, const std::vector<FVoiceUser>& Users)
{
	FVoiceRequestJoin* QueryToken = new FVoiceRequestJoin(RTCAdminHandle, RoomId, Users);
	FVoiceRequestPtr Request(QueryToken);

	FScopedLock Lock(RequestsMutex);
	NewRequests.push(std::move(Request));	
	
	return FJoinRoomReceiptPtr(new FJoinRoomReceipt(QueryToken->GetFuture(), QueryToken, this));
}

FVoiceRequestReceiptPtr FVoiceSdk::KickUser(const char* RoomId, const EOS_ProductUserId& ProductUserId)
{
	FVoiceRequestKickUser* Kick = new FVoiceRequestKickUser(RTCAdminHandle, RoomId, ProductUserId);
	FVoiceRequestPtr Request(Kick);

	FScopedLock Lock(RequestsMutex);
	NewRequests.push(std::move(Request));

	return FVoiceRequestReceiptPtr(new FVoiceRequestReceipt(Kick->GetFuture(), Kick, this));
}

FVoiceRequestReceiptPtr FVoiceSdk::MuteUser(const char* RoomId, const EOS_ProductUserId& ProductUserId, bool bMute)
{
	FVoiceRequestMuteUser* Mute = new FVoiceRequestMuteUser(RTCAdminHandle, RoomId, ProductUserId, bMute);
	FVoiceRequestPtr Request(Mute);

	FScopedLock Lock(RequestsMutex);
	NewRequests.push(std::move(Request));

	return FVoiceRequestReceiptPtr(new FVoiceRequestReceipt(Mute->GetFuture(), Mute, this));
}


void FVoiceSdk::Tick()
{
	/** VoiceReqeusts come in from the http api threadpool, but EOS SDK calls must all originate from the same thread.
	  * Therefore the VoiceRequests are queued up by FVoiceSdk, which processes them on its main thread, right here as part of Tick.
	  */
	if (!NewRequests.empty())
	{	
		FScopedLock Lock(RequestsMutex);

		/** Currently just processing 1 request per Tick */
		FDebugLog::Log(L"Processing voice request (%d more queued)", NewRequests.size() - 1);

		FVoiceRequestPtr Request = std::move(NewRequests.back());
		NewRequests.pop();

		Request->MakeRequest(RTCAdminHandle);
		ActiveRequests.push_back(std::move(Request));
	}

	EOS_Platform_Tick(PlatformHandle);
}

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceSdk.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NonCopyable.h"
#include "VoiceRequestJoin.h"

#include <eos_sdk.h>

/** Server VoiceSdk Wrapper to manage multiple requests originating from different threads. */
class FVoiceSdk : public FNonCopyable
{
	friend class FJoinRoomReceipt;
	friend class FVoiceRequestReceipt;

public:
	FVoiceSdk() noexcept(false) { }
	virtual ~FVoiceSdk();

	EOS_Bool LoadAndInitSdk();
	EOS_Bool Shutdown();
	
	/** Queues up a request for a joinRoom token for each of the provided users */
	FJoinRoomReceiptPtr CreateJoinRoomTokens(const char* RoomId, const std::vector<FVoiceUser>& Users);

	/** Queues up a request to kick a user from the session */
	FVoiceRequestReceiptPtr KickUser(const char* RoomId, const EOS_ProductUserId& ProductUserId);

	/** Queues up a request to remote mute a user in the session */
	FVoiceRequestReceiptPtr MuteUser(const char* RoomId, const EOS_ProductUserId& ProductUserId, bool bMute);

	/** Processes queued requests */
	void Tick();

private:
	/** called by Receipt friend classes */
	void ReleaseRequest(FVoiceRequestHandle VoiceRequestHandle);

	/** Handle to EOS SDK Platform */
	EOS_HPlatform PlatformHandle = 0;

	/** Handle to EOS SDK RTC Admin system */
	EOS_HRTCAdmin RTCAdminHandle = 0;

	/** mutex for accessing NewRequests & ActiveRequests */
	std::mutex RequestsMutex;
	
	/** new requests that need to be kicked off */
	std::queue<FVoiceRequestPtr> NewRequests;

	/** active requests that are in flight */
	std::vector<FVoiceRequestPtr> ActiveRequests;
};

```

`EAC_SDK/Samples/Voice/Server/Source/VoiceSession.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

#include "VoiceSession.h"
#include "VoiceUser.h"

const uint32_t FVoiceSession::kSessionHeartbeatTimeout = 70;

FVoiceSession::FVoiceSession(const std::string& InSessionId, const std::string& InSessionLock, const std::string& InSessionPassword, const std::initializer_list<FVoiceUser>& InSessionMembers) :
	Expiration(std::chrono::steady_clock::now()),
	SessionId(InSessionId),
	SessionLock(InSessionLock),
	SessionPassword(InSessionPassword),
	SessionMembers(InSessionMembers)
{
	ResetHeartbeat();
}

const std::string& FVoiceSession::GetId() const
{
	return SessionId;
}

const std::string& FVoiceSession::GetLock() const
{
	return SessionLock;
}

bool FVoiceSession::AddUser(const FVoiceUser& InUser)
{	
	ResetHeartbeat();

	FScopedLock Lock(SessionMemberMutex);

	const auto& ExistingUserItr = std::find_if(
		SessionMembers.begin(),
		SessionMembers.end(),
		[&](const FVoiceUser& VoiceUser) { return VoiceUser.GetPuid() == InUser.GetPuid(); }
	);

	if (ExistingUserItr != SessionMembers.end())
	{
		return false;
	}

	SessionMembers.push_back(InUser);
	return true;
}

bool FVoiceSession::RemoveUser(const FVoiceUser& InUser)
{
	ResetHeartbeat();

	FScopedLock Lock(SessionMemberMutex);
	return erase_if(SessionMembers, [&](const FVoiceUser& VoiceUser) { return VoiceUser == InUser; }) != 0;
}

bool FVoiceSession::MatchesPassword(const std::string& InPassword) const
{
	return (SessionPassword.empty() || SessionPassword == InPassword);
}

bool FVoiceSession::BanUser(const FVoiceUser& InUser)
{
	ResetHeartbeat();

	FScopedLock Lock(BanListMutex);
	return PuidBanList.emplace(InUser.GetPuid()).second;
}

bool FVoiceSession::IsUserBanned(const FVoiceUser& User) const
{	
	return PuidBanList.find(User.GetPuid()) != PuidBanList.end();
}

void FVoiceSession::ResetHeartbeat()
{
	Expiration = std::chrono::steady_clock::now() + std::chrono::seconds(FVoiceSession::kSessionHeartbeatTimeout);
}

bool FVoiceSession::IsExpired(const ServerTimePoint& Now) const
{
	return Now > Expiration;
}
```

`EAC_SDK/Samples/Voice/Server/Source/VoiceSession.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.
#pragma once

#include "eos_common.h"

/** A session with an optional password, private owner lock and list of members. */
class FVoiceSession
{
public:	
	FVoiceSession(const std::string& InSessionId, const std::string& InSessionLock, const std::string& InSessionPassword, const std::initializer_list<FVoiceUser>& InSessionMembers);
	
	const std::string& GetId() const;
	const std::string& GetLock() const;
	bool MatchesPassword(const std::string& InPassword) const;

	bool AddUser(const FVoiceUser& InUser);
	bool RemoveUser(const FVoiceUser& InUser);

	bool BanUser(const FVoiceUser& InUser);
	bool IsUserBanned(const FVoiceUser& InUser) const;

	void ResetHeartbeat();
	bool IsExpired(const ServerTimePoint& Now) const;

private:
	/** The unique identifier of the session, generated by the voiceServer. */
	std::string SessionId;

	/** Expiration time of the session, heartbeat the session to keep it alive. Used to remove unused sessions */	  
	ServerTimePoint Expiration;

	/** The Lock represents a private key, initially only shared with the creator of the session to perform owner-level operations such as kick or remoteMute. */
	std::string SessionLock;

	/** An optional password for the session. */
	std::string SessionPassword;

	std::mutex SessionMemberMutex;
	std::vector<FVoiceUser> SessionMembers;

	/** Once members get kicked, they land on the ban list to prevent them from rejoining using previously issued tokens. */
	std::mutex BanListMutex;
	std::unordered_set<EOS_ProductUserId> PuidBanList;

	/** Sessions expire after N seconds without any activity or heartbeat */
	static const uint32_t kSessionHeartbeatTimeout;
};
```

`EAC_SDK/Samples/Voice/Server/Source/VoiceUser.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "eos_common.h"

/** Represents a single user in a voiceSession */
class FVoiceUser
{
public:
	FVoiceUser(const std::string& InPuid, const std::string& InIPAddress)
	: IPAddress(InIPAddress)
	{
		Puid = EOS_ProductUserId_FromString(InPuid.c_str());
	}
	inline const EOS_ProductUserId& GetPuid() const { return Puid; }
	inline const std::string& GetIPAddress() const { return IPAddress; }

	bool operator==(const FVoiceUser& Rhs) const { return Puid == Rhs.Puid && IPAddress == Rhs.IPAddress; }

private:
	EOS_ProductUserId Puid;
	std::string IPAddress;
};
```

`EAC_SDK/Samples/Voice/Server/Source/pch.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "pch.h"

```

`EAC_SDK/Samples/Voice/Server/Source/pch.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include <memory>
#include <mutex>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <fstream>
#include <cassert>
#include <future>
#include <iterator>
#include <queue>
#include <unordered_set>
#include <chrono>
#include <random>

#include <stdarg.h>

#ifdef _WIN32
#include <WinSDKVer.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0600
#endif
#include <SDKDDKVer.h>

// Use the C++ standard templated min/max
#define NOMINMAX

// DirectX apps don't need GDI
#define NODRAWTEXT
#define NOGDI
#define NOBITMAP

// Include <mcx.h> if you need this
#define NOMCX

// Include <winsvc.h> if you need this
#define NOSERVICE

// WinHelp is deprecated
#define NOHELP

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <wincodec.h>
#include <shellapi.h>
#endif //_WIN32

// Linux does not have _DEBUG in debug builds
#if !defined(NDEBUG) && !defined(_DEBUG)
#define _DEBUG
#endif

#if ALLOW_RESERVED_OPTIONS
#define DEV_BUILD
#endif

#ifndef _WIN32
typedef wchar_t WCHAR;
typedef wchar_t* LPWSTR, *PWSTR;
#define sprintf_s snprintf
#define __cdecl
#define wsprintf(BUF, FMT, ...) swprintf(BUF, sizeof(BUF)/sizeof(wchar_t), FMT, __VA_ARGS__)
#define OutputDebugStringW(STRING) wprintf(STRING)
#endif // !_WIN32

using uint16 = unsigned short;

class FVoiceUser;
using FVoiceUserPtr = std::shared_ptr<FVoiceUser>;

class FVoiceSession;
using FVoiceSessionPtr = std::shared_ptr<FVoiceSession>;

class FVoiceHost;
using FVoiceHostPtr = std::shared_ptr<FVoiceHost>;

class FVoiceSdk;
using FVoiceSdkPtr = std::shared_ptr<FVoiceSdk>;

using FScopedLock = std::lock_guard<std::mutex>;

using ServerTimePoint = std::chrono::time_point<std::chrono::steady_clock>;

// remove elements matching predicate, returns number of removed elements
template<class T, class A, class Predicate>
size_t erase_if(std::vector<T, A>& c, Predicate pred) {
	const size_t numBefore = c.size();
	c.erase(std::remove_if(c.begin(), c.end(), pred), c.end());
	return numBefore - c.size();
}
```

`EAC_SDK/Samples/Voice/Server/VoiceServer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9de5622e-0212-43ff-bf9f-bf81cfd6d4d4}</ProjectGuid>
    <RootNamespace>VoiceServer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Samples.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win32\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win32\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>Bin\Win64\$(Configuration)\</OutDir>
    <IntDir>Intermediate\Win64\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../$(EOSSDKIncludes);../$(EOSSDKSamplesRoot)/Voice/Server/Source;../$(EOSSDKSamplesRoot)/Voice/Server/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/NotForLicensees/Source/Core;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../$(EOSSDKIncludes);../$(EOSSDKSamplesRoot)/Voice/Server/Source;../$(EOSSDKSamplesRoot)/Voice/Server/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/NotForLicensees/Source/Core;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>EOSSDK-Win32-Shipping.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win32-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x86\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../$(EOSSDKIncludes);../$(EOSSDKSamplesRoot)/Voice/Server/Source;../$(EOSSDKSamplesRoot)/Voice/Server/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/NotForLicensees/Source/Core;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp14</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>../$(EOSSDKIncludes);../$(EOSSDKSamplesRoot)/Voice/Server/Source;../$(EOSSDKSamplesRoot)/Voice/Server/Source/Main;../$(EOSSDKSamplesRoot)/Shared/Source;../$(EOSSDKSamplesRoot)/Shared/External;../$(EOSSDKSamplesRoot)/Shared/Source/Utils;../$(EOSSDKSamplesRoot)/Shared/NotForLicensees/Source/Core;../$(EOSSDKSamplesRoot)/Shared/External/UTF8-CPP/source;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp14</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>../$(EOSSDKLibs);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>EOSSDK-Win64-Shipping.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PreBuildEvent>
      <Command>xcopy /D /Y /R /Q ..\$(EOSSDKDLLs)EOSSDK-Win64-Shipping.dll $(OutDir) &gt;nul
xcopy /D /Y /R /Q ..\$(XAudio2_9Bin)x64\xaudio2_9redist.dll $(Outdir) &gt;nul</Command>
      <Message>Copying New Files to Bin</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\Shared\Source\Utils\CommandLine.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\DebugLog.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\Settings.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\StringUtils.cpp" />
    <ClCompile Include="..\..\Shared\Source\Utils\Utils.cpp" />
    <ClCompile Include="Source\ApiParams.cpp" />
    <ClCompile Include="Source\Main\Main.cpp" />
    <ClCompile Include="Source\Main\ServerMain.cpp" />
    <ClCompile Include="Source\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Source\VoiceApi.cpp" />
    <ClCompile Include="Source\VoiceHost.cpp" />
    <ClCompile Include="Source\VoiceRequestJoin.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <ClCompile Include="Source\VoiceRequestKickUser.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <ClCompile Include="Source\VoiceRequestMuteUser.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <ClCompile Include="Source\VoiceRequest.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <ClCompile Include="Source\VoiceSdk.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">pch.h</PrecompiledHeaderFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <ClCompile Include="Source\VoiceSession.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\Shared\Source\Utils\CommandLine.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\DebugLog.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\Settings.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\StringUtils.h" />
    <ClInclude Include="..\..\Shared\Source\Utils\Utils.h" />
    <ClInclude Include="Source\ApiParams.h" />
    <ClInclude Include="Source\Main\Main.h" />
    <ClInclude Include="Source\NonCopyable.h" />
    <ClInclude Include="Source\pch.h" />
    <ClInclude Include="Source\SampleConstants.h" />
    <ClInclude Include="Source\VoiceApi.h" />
    <ClInclude Include="Source\VoiceHost.h" />
    <ClInclude Include="Source\VoiceRequestJoin.h" />
    <ClInclude Include="Source\VoiceRequestKickUser.h" />
    <ClInclude Include="Source\VoiceRequestMuteUser.h" />
    <ClInclude Include="Source\VoiceRequest.h" />
    <ClInclude Include="Source\VoiceSdk.h" />
    <ClInclude Include="Source\VoiceSession.h" />
    <ClInclude Include="Source\VoiceUser.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EAC_SDK/Samples/Voice/Server/VoiceServer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="SharedSource">
      <UniqueIdentifier>{dd833a82-590b-493f-a4d1-87b48427e8f3}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedSource\Utils">
      <UniqueIdentifier>{877d3ba7-b77b-42d5-a38e-a7a6420ed9e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Main">
      <UniqueIdentifier>{d848b34a-2c50-4bc7-abdc-2f347fdacd68}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceSdk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\ApiParams.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceApi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceHost.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceSession.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceRequestKickUser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceRequestMuteUser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceRequestJoin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source\VoiceRequest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\CommandLine.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\DebugLog.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\Settings.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\StringUtils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="..\..\Shared\Source\Utils\Utils.cpp">
      <Filter>SharedSource\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Source\Main\Main.cpp">
      <Filter>Source Files\Main</Filter>
    </ClCompile>
    <ClCompile Include="Source\Main\ServerMain.cpp">
      <Filter>Source Files\Main</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Source\pch.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\SampleConstants.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceSdk.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\ApiParams.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceApi.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceHost.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceSession.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceUser.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceRequestKickUser.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceRequestMuteUser.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceRequestJoin.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\VoiceRequest.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Source\NonCopyable.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\CommandLine.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\DebugLog.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\Settings.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\StringUtils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="..\..\Shared\Source\Utils\Utils.h">
      <Filter>SharedSource\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Source\Main\Main.h">
      <Filter>Source Files\Main</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EAC_SDK/ThirdPartyNotices/ThirdPartySoftwareNotice.txt`:

```txt

I.	CityHash
Copyright (c) 2011 Google, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

II.	Slicing-by-8 algorithm
Copyright (c) 2004-2006 Intel Corporation.
All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE

III.	Expat XML Parser
Copyright (c) 1998-2000 Thai Open Source Software Center Ltd and Clark Cooper
Copyright (c) 2001-2016 Expat maintainers

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

IV.	ICU 51.2
NOTICE TO USER: Carefully read the following legal agreement.
BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S DATA FILES ("DATA FILES"), AND/OR SOFTWARE ("SOFTWARE"), YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE TERMS AND CONDITIONS OF THIS AGREEMENT.
IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE THE DATA FILES OR SOFTWARE.

COPYRIGHT AND PERMISSION NOTICE

Copyright © 1991-2019 Unicode, Inc. All rights reserved.
Distributed under the Terms of Use in https://www.unicode.org/copyright.html.

Permission is hereby granted, free of charge, to any person obtaining a copy of the Unicode data files and any associated documentation (the "Data Files") or Unicode software and any associated documentation (the "Software") to deal in the Data Files or Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, and/or sell copies of the Data Files or Software, and to permit persons to whom the Data Files or Software are furnished to do so, provided that either (a) this copyright and permission notice appear with all copies of the Data Files or Software, or (b) this copyright and permission notice appear in associated Documentation.

THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.

Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in these Data Files or Software without prior written authorization of the copyright holder.

 
V.	Jemalloc
Licensing

jemalloc is released under the terms of the following BSD-derived license:
--------------------------------------------------------------------------------
Copyright (C) 2002-2013 Jason Evans <jasone@canonware.com>.
All rights reserved.
Copyright (C) 2007-2012 Mozilla Foundation. All rights reserved.
Copyright (C) 2009-2013 Facebook, Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice(s), this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice(s), this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


VI.	libcurl v7.47.1, v7.48.0, v7.55.1
COPYRIGHT AND PERMISSION NOTICE

Copyright (c) 1996 - 2017, Daniel Stenberg, <daniel@haxx.se>, and many contributors, see the THANKS file.

All rights reserved.

Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization of the copyright holder.

VII.	[Intentionally Omitted]

VIII.	libwebsockets v1.7.3
The Epic Games Online Services SDK is based in part on the work of the libwebsockets project (http://libwebsockets.org). Source code for the version of libwebsockets used in Epic Games Online Services SDK can be obtained at https://github.com/EpicGames/ThirdParty

IX.	OpenSSL 1.0.1e
Copyright (c) 1998-2018 The OpenSSL Project. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are 
permitted provided that the following conditions are met:
 
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. All advertising materials mentioning features or use of this software must display the following acknowledgment:
"This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)"

4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to endorse or promote products derived from this software without prior written permission. For written permission, please contact openssl-core@openssl.org.

5. Products derived from this software may not be called "OpenSSL" nor may "OpenSSL" appear in their names without prior written permission of the OpenSSL Project.

6. Redistributions of any form whatsoever must retain the following acknowledgment:
 "This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/)"

THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE OpenSSL PROJECT OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

X.	PLCrashReporter 1.2
Except as noted below, PLCrashReporter is provided under the following license:

 Copyright (c) 2008 - 2014 Plausible Labs Cooperative, Inc.
 All rights reserved.

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.

Additional contributions have been made under the same license terms as above, with copyright held by their respective authors:

 Damian Morris <damian@moso.com.au>
 Copyright (c) 2010 MOSO Corporation, Pty Ltd.
 All rights reserved.

 HockeyApp/Bitstadium
 Copyright (c) 2012 HockeyApp, Bit Stadium GmbH.
 All rights reserved.

The protobuf-c library, as well as the PLCrashLogWriterEncoding.c file are licensed as follows:
 
Copyright 2008, Dave Benson.
 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

XI.	Protobuf
Copyright 2008 Google Inc.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Code generated by the Protocol Buffer compiler is owned by the owner
of the input file used when generating it.  This code is not
standalone and requires a support library to be linked with it.  This
support library is itself covered by the above license.

XII.	Protobuf-c
Copyright (c) 2008-2016, Dave Benson and the protobuf-c authors.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The code generated by the protoc-c compiler is owned by the owner of the input files used when generating it. This code is not standalone and requires a support library to be linked with it. This support library is covered by the above license.

XIII.	gflags
Copyright (c) 2006, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of Google Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

XIV.	LibYUV
Copyright 2011 The LibYuv Project Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of Google nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

XV.	WebRTC stable and trunk version
Copyright (c) 2011, The WebRTC project authors. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

 * Neither the name of Google nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

XVI.	zlib
Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

XVII.	DirectXTK
Copyright (c) 2012-2019 Microsoft Corp

Permission is hereby granted, free of charge, to any person obtaining a copy of this 
software and associated documentation files (the "Software"), to deal in the Software 
without restriction, including without limitation the rights to use, copy, modify, 
merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to the following 
conditions: 

The above copyright notice and this permission notice shall be included in all copies 
or substantial portions of the Software.  

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

XVIII. electron-prebuilt-compile
Copyright (c) 2013-2020 GitHub Inc.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

XIX. Node.js
Node.js is licensed for use as follows:

"""
Copyright Node.js contributors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

This license applies to parts of Node.js originating from the
https://github.com/joyent/node repository:

"""
Copyright Joyent, Inc. and other Node contributors. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
"""

The Node.js license applies to all parts of Node.js that are not externally
maintained libraries.

The externally maintained libraries used by Node.js are:

- Acorn, located at deps/acorn, is licensed as follows:
  """
    MIT License

    Copyright (C) 2012-2018 by various contributors (see AUTHORS)

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
  """

- Acorn plugins, located at deps/acorn-plugins, is licensed as follows:
  """
    Copyright (C) 2017-2018 by Adrian Heine

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
  """

- c-ares, located at deps/cares, is licensed as follows:
  """
    Copyright (c) 2007 - 2018, Daniel Stenberg with many contributors, see AUTHORS
    file.

    Copyright 1998 by the Massachusetts Institute of Technology.

    Permission to use, copy, modify, and distribute this software and its
    documentation for any purpose and without fee is hereby granted, provided that
    the above copyright notice appear in all copies and that both that copyright
    notice and this permission notice appear in supporting documentation, and that
    the name of M.I.T. not be used in advertising or publicity pertaining to
    distribution of the software without specific, written prior permission.
    M.I.T. makes no representations about the suitability of this software for any
    purpose.  It is provided "as is" without express or implied warranty.
  """

- cjs-module-lexer, located at deps/cjs-module-lexer, is licensed as follows:
  """
    MIT License
    -----------

    Copyright (C) 2018-2020 Guy Bedford

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  """

- ICU, located at deps/icu-small, is licensed as follows:
  """
    COPYRIGHT AND PERMISSION NOTICE (ICU 58 and later)

    Copyright © 1991-2020 Unicode, Inc. All rights reserved.
    Distributed under the Terms of Use in https://www.unicode.org/copyright.html.

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of the Unicode data files and any associated documentation
    (the "Data Files") or Unicode software and any associated documentation
    (the "Software") to deal in the Data Files or Software
    without restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, and/or sell copies of
    the Data Files or Software, and to permit persons to whom the Data Files
    or Software are furnished to do so, provided that either
    (a) this copyright and permission notice appear with all copies
    of the Data Files or Software, or
    (b) this copyright and permission notice appear in associated
    Documentation.

    THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT OF THIRD PARTY RIGHTS.
    IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS
    NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
    DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
    DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THE DATA FILES OR SOFTWARE.

    Except as contained in this notice, the name of a copyright holder
    shall not be used in advertising or otherwise to promote the sale,
    use or other dealings in these Data Files or Software without prior
    written authorization of the copyright holder.

    ---------------------

    Third-Party Software Licenses

    This section contains third-party software notices and/or additional
    terms for licensed third-party software components included within ICU
    libraries.

    1. ICU License - ICU 1.8.1 to ICU 57.1

    COPYRIGHT AND PERMISSION NOTICE

    Copyright (c) 1995-2016 International Business Machines Corporation and others
    All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, and/or sell copies of the Software, and to permit persons
    to whom the Software is furnished to do so, provided that the above
    copyright notice(s) and this permission notice appear in all copies of
    the Software and that both the above copyright notice(s) and this
    permission notice appear in supporting documentation.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
    OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
    HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY
    SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
    RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
    CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
    CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

    Except as contained in this notice, the name of a copyright holder
    shall not be used in advertising or otherwise to promote the sale, use
    or other dealings in this Software without prior written authorization
    of the copyright holder.

    All trademarks and registered trademarks mentioned herein are the
    property of their respective owners.

    2. Chinese/Japanese Word Break Dictionary Data (cjdict.txt)

     #     The Google Chrome software developed by Google is licensed under
     # the BSD license. Other software included in this distribution is
     # provided under other licenses, as set forth below.
     #
     #  The BSD License
     #  http://opensource.org/licenses/bsd-license.php
     #  Copyright (C) 2006-2008, Google Inc.
     #
     #  All rights reserved.
     #
     #  Redistribution and use in source and binary forms, with or without
     # modification, are permitted provided that the following conditions are met:
     #
     #  Redistributions of source code must retain the above copyright notice,
     # this list of conditions and the following disclaimer.
     #  Redistributions in binary form must reproduce the above
     # copyright notice, this list of conditions and the following
     # disclaimer in the documentation and/or other materials provided with
     # the distribution.
     #  Neither the name of  Google Inc. nor the names of its
     # contributors may be used to endorse or promote products derived from
     # this software without specific prior written permission.
     #
     #
     #  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
     # CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
     # INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
     # LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
     # BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     #
     #
     #  The word list in cjdict.txt are generated by combining three word lists
     # listed below with further processing for compound word breaking. The
     # frequency is generated with an iterative training against Google web
     # corpora.
     #
     #  * Libtabe (Chinese)
     #    - https://sourceforge.net/project/?group_id=1519
     #    - Its license terms and conditions are shown below.
     #
     #  * IPADIC (Japanese)
     #    - http://chasen.aist-nara.ac.jp/chasen/distribution.html
     #    - Its license terms and conditions are shown below.
     #
     #  ---------COPYING.libtabe ---- BEGIN--------------------
     #
     #  /*
     #   * Copyright (c) 1999 TaBE Project.
     #   * Copyright (c) 1999 Pai-Hsiang Hsiao.
     #   * All rights reserved.
     #   *
     #   * Redistribution and use in source and binary forms, with or without
     #   * modification, are permitted provided that the following conditions
     #   * are met:
     #   *
     #   * . Redistributions of source code must retain the above copyright
     #   *   notice, this list of conditions and the following disclaimer.
     #   * . Redistributions in binary form must reproduce the above copyright
     #   *   notice, this list of conditions and the following disclaimer in
     #   *   the documentation and/or other materials provided with the
     #   *   distribution.
     #   * . Neither the name of the TaBE Project nor the names of its
     #   *   contributors may be used to endorse or promote products derived
     #   *   from this software without specific prior written permission.
     #   *
     #   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     #   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     #   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
     #   * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
     #   * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     #   * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     #   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     #   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     #   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     #   * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     #   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     #   * OF THE POSSIBILITY OF SUCH DAMAGE.
     #   */
     #
     #  /*
     #   * Copyright (c) 1999 Computer Systems and Communication Lab,
     #   *                    Institute of Information Science, Academia
     #       *                    Sinica. All rights reserved.
     #   *
     #   * Redistribution and use in source and binary forms, with or without
     #   * modification, are permitted provided that the following conditions
     #   * are met:
     #   *
     #   * . Redistributions of source code must retain the above copyright
     #   *   notice, this list of conditions and the following disclaimer.
     #   * . Redistributions in binary form must reproduce the above copyright
     #   *   notice, this list of conditions and the following disclaimer in
     #   *   the documentation and/or other materials provided with the
     #   *   distribution.
     #   * . Neither the name of the Computer Systems and Communication Lab
     #   *   nor the names of its contributors may be used to endorse or
     #   *   promote products derived from this software without specific
     #   *   prior written permission.
     #   *
     #   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     #   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     #   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
     #   * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
     #   * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     #   * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     #   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     #   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     #   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     #   * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     #   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     #   * OF THE POSSIBILITY OF SUCH DAMAGE.
     #   */
     #
     #  Copyright 1996 Chih-Hao Tsai @ Beckman Institute,
     #      University of Illinois
     #  c-tsai4@uiuc.edu  http://casper.beckman.uiuc.edu/~c-tsai4
     #
     #  ---------------COPYING.libtabe-----END--------------------------------
     #
     #
     #  ---------------COPYING.ipadic-----BEGIN-------------------------------
     #
     #  Copyright 2000, 2001, 2002, 2003 Nara Institute of Science
     #  and Technology.  All Rights Reserved.
     #
     #  Use, reproduction, and distribution of this software is permitted.
     #  Any copy of this software, whether in its original form or modified,
     #  must include both the above copyright notice and the following
     #  paragraphs.
     #
     #  Nara Institute of Science and Technology (NAIST),
     #  the copyright holders, disclaims all warranties with regard to this
     #  software, including all implied warranties of merchantability and
     #  fitness, in no event shall NAIST be liable for
     #  any special, indirect or consequential damages or any damages
     #  whatsoever resulting from loss of use, data or profits, whether in an
     #  action of contract, negligence or other tortuous action, arising out
     #  of or in connection with the use or performance of this software.
     #
     #  A large portion of the dictionary entries
     #  originate from ICOT Free Software.  The following conditions for ICOT
     #  Free Software applies to the current dictionary as well.
     #
     #  Each User may also freely distribute the Program, whether in its
     #  original form or modified, to any third party or parties, PROVIDED
     #  that the provisions of Section 3 ("NO WARRANTY") will ALWAYS appear
     #  on, or be attached to, the Program, which is distributed substantially
     #  in the same form as set out herein and that such intended
     #  distribution, if actually made, will neither violate or otherwise
     #  contravene any of the laws and regulations of the countries having
     #  jurisdiction over the User or the intended distribution itself.
     #
     #  NO WARRANTY
     #
     #  The program was produced on an experimental basis in the course of the
     #  research and development conducted during the project and is provided
     #  to users as so produced on an experimental basis.  Accordingly, the
     #  program is provided without any warranty whatsoever, whether express,
     #  implied, statutory or otherwise.  The term "warranty" used herein
     #  includes, but is not limited to, any warranty of the quality,
     #  performance, merchantability and fitness for a particular purpose of
     #  the program and the nonexistence of any infringement or violation of
     #  any right of any third party.
     #
     #  Each user of the program will agree and understand, and be deemed to
     #  have agreed and understood, that there is no warranty whatsoever for
     #  the program and, accordingly, the entire risk arising from or
     #  otherwise connected with the program is assumed by the user.
     #
     #  Therefore, neither ICOT, the copyright holder, or any other
     #  organization that participated in or was otherwise related to the
     #  development of the program and their respective officials, directors,
     #  officers and other employees shall be held liable for any and all
     #  damages, including, without limitation, general, special, incidental
     #  and consequential damages, arising out of or otherwise in connection
     #  with the use or inability to use the program or any product, material
     #  or result produced or otherwise obtained by using the program,
     #  regardless of whether they have been advised of, or otherwise had
     #  knowledge of, the possibility of such damages at any time during the
     #  project or thereafter.  Each user will be deemed to have agreed to the
     #  foregoing by his or her commencement of use of the program.  The term
     #  "use" as used herein includes, but is not limited to, the use,
     #  modification, copying and distribution of the program and the
     #  production of secondary products from the program.
     #
     #  In the case where the program, whether in its original form or
     #  modified, was distributed or delivered to or received by a user from
     #  any person, organization or entity other than ICOT, unless it makes or
     #  grants independently of ICOT any specific warranty to the user in
     #  writing, such person, organization or entity, will also be exempted
     #  from and not be held liable to the user for any such damages as noted
     #  above as far as the program is concerned.
     #
     #  ---------------COPYING.ipadic-----END----------------------------------

    3. Lao Word Break Dictionary Data (laodict.txt)

     #  Copyright (c) 2013 International Business Machines Corporation
     #  and others. All Rights Reserved.
     #
     # Project: http://code.google.com/p/lao-dictionary/
     # Dictionary: http://lao-dictionary.googlecode.com/git/Lao-Dictionary.txt
     # License: http://lao-dictionary.googlecode.com/git/Lao-Dictionary-LICENSE.txt
     #              (copied below)
     #
     #  This file is derived from the above dictionary, with slight
     #  modifications.
     #  ----------------------------------------------------------------------
     #  Copyright (C) 2013 Brian Eugene Wilson, Robert Martin Campbell.
     #  All rights reserved.
     #
     #  Redistribution and use in source and binary forms, with or without
     #  modification,
     #  are permitted provided that the following conditions are met:
     #
     #
     # Redistributions of source code must retain the above copyright notice, this
     #  list of conditions and the following disclaimer. Redistributions in
     #  binary form must reproduce the above copyright notice, this list of
     #  conditions and the following disclaimer in the documentation and/or
     #  other materials provided with the distribution.
     #
     #
     # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
     # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
     # COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     # INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     # HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
     # STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
     # OF THE POSSIBILITY OF SUCH DAMAGE.
     #  --------------------------------------------------------------------------

    4. Burmese Word Break Dictionary Data (burmesedict.txt)

     #  Copyright (c) 2014 International Business Machines Corporation
     #  and others. All Rights Reserved.
     #
     #  This list is part of a project hosted at:
     #    github.com/kanyawtech/myanmar-karen-word-lists
     #
     #  --------------------------------------------------------------------------
     #  Copyright (c) 2013, LeRoy Benjamin Sharon
     #  All rights reserved.
     #
     #  Redistribution and use in source and binary forms, with or without
     #  modification, are permitted provided that the following conditions
     #  are met: Redistributions of source code must retain the above
     #  copyright notice, this list of conditions and the following
     #  disclaimer.  Redistributions in binary form must reproduce the
     #  above copyright notice, this list of conditions and the following
     #  disclaimer in the documentation and/or other materials provided
     #  with the distribution.
     #
     #    Neither the name Myanmar Karen Word Lists, nor the names of its
     #    contributors may be used to endorse or promote products derived
     #    from this software without specific prior written permission.
     #
     #  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
     #  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
     #  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     #  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     #  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
     #  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     #  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
     #  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     #  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     #  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     #  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
     #  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     #  SUCH DAMAGE.
     #  --------------------------------------------------------------------------

    5. Time Zone Database

      ICU uses the public domain data and code derived from Time Zone
    Database for its time zone support. The ownership of the TZ database
    is explained in BCP 175: Procedure for Maintaining the Time Zone
    Database section 7.

     # 7.  Database Ownership
     #
     #    The TZ database itself is not an IETF Contribution or an IETF
     #    document.  Rather it is a pre-existing and regularly updated work
     #    that is in the public domain, and is intended to remain in the
     #    public domain.  Therefore, BCPs 78 [RFC5378] and 79 [RFC3979] do
     #    not apply to the TZ Database or contributions that individuals make
     #    to it.  Should any claims be made and substantiated against the TZ
     #    Database, the organization that is providing the IANA
     #    Considerations defined in this RFC, under the memorandum of
     #    understanding with the IETF, currently ICANN, may act in accordance
     #    with all competent court orders.  No ownership claims will be made
     #    by ICANN or the IETF Trust on the database or the code.  Any person
     #    making a contribution to the database or code waives all rights to
     #    future claims in that contribution or in the TZ Database.

    6. Google double-conversion

    Copyright 2006-2011, the V8 project authors. All rights reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials provided
          with the distribution.
        * Neither the name of Google Inc. nor the names of its
          contributors may be used to endorse or promote products derived
          from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  """

- libuv, located at deps/uv, is licensed as follows:
  """
    libuv is licensed for use as follows:

    ====
    Copyright (c) 2015-present libuv project contributors.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.
    ====

    This license applies to parts of libuv originating from the
    https://github.com/joyent/libuv repository:

    ====

    Copyright Joyent, Inc. and other Node contributors. All rights reserved.
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

    ====

    This license applies to all parts of libuv that are not externally
    maintained libraries.

    The externally maintained libraries used by libuv are:

      - tree.h (from FreeBSD), copyright Niels Provos. Two clause BSD license.

      - inet_pton and inet_ntop implementations, contained in src/inet.c, are
        copyright the Internet Systems Consortium, Inc., and licensed under the ISC
        license.

      - stdint-msvc2008.h (from msinttypes), copyright Alexander Chemeris. Three
        clause BSD license.

      - pthread-fixes.c, copyright Google Inc. and Sony Mobile Communications AB.
        Three clause BSD license.

      - android-ifaddrs.h, android-ifaddrs.c, copyright Berkeley Software Design
        Inc, Kenneth MacKay and Emergya (Cloud4all, FP7/2007-2013, grant agreement
        n° 289016). Three clause BSD license.
  """

- llhttp, located at deps/llhttp, is licensed as follows:
  """
    This software is licensed under the MIT License.

    Copyright Fedor Indutny, 2018.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to permit
    persons to whom the Software is furnished to do so, subject to the
    following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    USE OR OTHER DEALINGS IN THE SOFTWARE.
  """

- OpenSSL, located at deps/openssl, is licensed as follows:
  """
    Copyright (c) 1998-2019 The OpenSSL Project.  All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.

    3. All advertising materials mentioning features or use of this
    software must display the following acknowledgment:
    "This product includes software developed by the OpenSSL Project
    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"

    4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
    endorse or promote products derived from this software without
    prior written permission. For written permission, please contact
    openssl-core@openssl.org.

    5. Products derived from this software may not be called "OpenSSL"
    nor may "OpenSSL" appear in their names without prior written
    permission of the OpenSSL Project.

    6. Redistributions of any form whatsoever must retain the following
    acknowledgment:
    "This product includes software developed by the OpenSSL Project
    for use in the OpenSSL Toolkit (http://www.openssl.org/)"

    THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
    EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
    ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
    NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
    OF THE POSSIBILITY OF SUCH DAMAGE.
    ====================================================================

    This product includes cryptographic software written by Eric Young
    (eay@cryptsoft.com).  This product includes software written by Tim
    Hudson (tjh@cryptsoft.com).
  """

- Punycode.js, located at lib/punycode.js, is licensed as follows:
  """
    Copyright Mathias Bynens <https://mathiasbynens.be/>

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  """

- V8, located at deps/v8, is licensed as follows:
  """
    This license applies to all parts of V8 that are not externally
    maintained libraries.  The externally maintained libraries used by V8
    are:

      - PCRE test suite, located in
        test/mjsunit/third_party/regexp-pcre/regexp-pcre.js.  This is based on the
        test suite from PCRE-7.3, which is copyrighted by the University
        of Cambridge and Google, Inc.  The copyright notice and license
        are embedded in regexp-pcre.js.

      - Layout tests, located in test/mjsunit/third_party/object-keys.  These are
        based on layout tests from webkit.org which are copyrighted by
        Apple Computer, Inc. and released under a 3-clause BSD license.

      - Strongtalk assembler, the basis of the files assembler-arm-inl.h,
        assembler-arm.cc, assembler-arm.h, assembler-ia32-inl.h,
        assembler-ia32.cc, assembler-ia32.h, assembler-x64-inl.h,
        assembler-x64.cc, assembler-x64.h, assembler-mips-inl.h,
        assembler-mips.cc, assembler-mips.h, assembler.cc and assembler.h.
        This code is copyrighted by Sun Microsystems Inc. and released
        under a 3-clause BSD license.

      - Valgrind client API header, located at src/third_party/valgrind/valgrind.h
        This is released under the BSD license.

      - The Wasm C/C++ API headers, located at third_party/wasm-api/wasm.{h,hh}
        This is released under the Apache license. The API's upstream prototype
        implementation also formed the basis of V8's implementation in
        src/wasm/c-api.cc.

    These libraries have their own licenses; we recommend you read them,
    as their terms may differ from the terms below.

    Further license information can be found in LICENSE files located in
    sub-directories.

    Copyright 2014, the V8 project authors. All rights reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials provided
          with the distribution.
        * Neither the name of Google Inc. nor the names of its
          contributors may be used to endorse or promote products derived
          from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  """

- SipHash, located at deps/v8/src/third_party/siphash, is licensed as follows:
  """
    SipHash reference C implementation

    Copyright (c) 2016 Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>

    To the extent possible under law, the author(s) have dedicated all
    copyright and related and neighboring rights to this software to the public
    domain worldwide. This software is distributed without any warranty.
  """

- zlib, located at deps/zlib, is licensed as follows:
  """
    zlib.h -- interface of the 'zlib' general purpose compression library
    version 1.2.11, January 15th, 2017

    Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

    This software is provided 'as-is', without any express or implied
    warranty.  In no event will the authors be held liable for any damages
    arising from the use of this software.

    Permission is granted to anyone to use this software for any purpose,
    including commercial applications, and to alter it and redistribute it
    freely, subject to the following restrictions:

    1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software
    in a product, an acknowledgment in the product documentation would be
    appreciated but is not required.
    2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.
    3. This notice may not be removed or altered from any source distribution.

    Jean-loup Gailly        Mark Adler
    jloup@gzip.org          madler@alumni.caltech.edu
  """

- npm, located at deps/npm, is licensed as follows:
  """
    The npm application
    Copyright (c) npm, Inc. and Contributors
    Licensed on the terms of The Artistic License 2.0

    Node package dependencies of the npm application
    Copyright (c) their respective copyright owners
    Licensed on their respective license terms

    The npm public registry at https://registry.npmjs.org
    and the npm website at https://www.npmjs.com
    Operated by npm, Inc.
    Use governed by terms published on https://www.npmjs.com

    "Node.js"
    Trademark Joyent, Inc., https://joyent.com
    Neither npm nor npm, Inc. are affiliated with Joyent, Inc.

    The Node.js application
    Project of Node Foundation, https://nodejs.org

    The npm Logo
    Copyright (c) Mathias Pettersson and Brian Hammond

    "Gubblebum Blocky" typeface
    Copyright (c) Tjarda Koster, https://jelloween.deviantart.com
    Used with permission

    --------

    The Artistic License 2.0

    Copyright (c) 2000-2006, The Perl Foundation.

    Everyone is permitted to copy and distribute verbatim copies
    of this license document, but changing it is not allowed.

    Preamble

    This license establishes the terms under which a given free software
    Package may be copied, modified, distributed, and/or redistributed.
    The intent is that the Copyright Holder maintains some artistic
    control over the development of that Package while still keeping the
    Package available as open source and free software.

    You are always permitted to make arrangements wholly outside of this
    license directly with the Copyright Holder of a given Package.  If the
    terms of this license do not permit the full use that you propose to
    make of the Package, you should contact the Copyright Holder and seek
    a different licensing arrangement.

    Definitions

        "Copyright Holder" means the individual(s) or organization(s)
        named in the copyright notice for the entire Package.

        "Contributor" means any party that has contributed code or other
        material to the Package, in accordance with the Copyright Holder's
        procedures.

        "You" and "your" means any person who would like to copy,
        distribute, or modify the Package.

        "Package" means the collection of files distributed by the
        Copyright Holder, and derivatives of that collection and/or of
        those files. A given Package may consist of either the Standard
        Version, or a Modified Version.

        "Distribute" means providing a copy of the Package or making it
        accessible to anyone else, or in the case of a company or
        organization, to others outside of your company or organization.

        "Distributor Fee" means any fee that you charge for Distributing
        this Package or providing support for this Package to another
        party.  It does not mean licensing fees.

        "Standard Version" refers to the Package if it has not been
        modified, or has been modified only in ways explicitly requested
        by the Copyright Holder.

        "Modified Version" means the Package, if it has been changed, and
        such changes were not explicitly requested by the Copyright
        Holder.

        "Original License" means this Artistic License as Distributed with
        the Standard Version of the Package, in its current version or as
        it may be modified by The Perl Foundation in the future.

        "Source" form means the source code, documentation source, and
        configuration files for the Package.

        "Compiled" form means the compiled bytecode, object code, binary,
        or any other form resulting from mechanical transformation or
        translation of the Source form.

    Permission for Use and Modification Without Distribution

    (1)  You are permitted to use the Standard Version and create and use
    Modified Versions for any purpose without restriction, provided that
    you do not Distribute the Modified Version.

    Permissions for Redistribution of the Standard Version

    (2)  You may Distribute verbatim copies of the Source form of the
    Standard Version of this Package in any medium without restriction,
    either gratis or for a Distributor Fee, provided that you duplicate
    all of the original copyright notices and associated disclaimers.  At
    your discretion, such verbatim copies may or may not include a
    Compiled form of the Package.

    (3)  You may apply any bug fixes, portability changes, and other
    modifications made available from the Copyright Holder.  The resulting
    Package will still be considered the Standard Version, and as such
    will be subject to the Original License.

    Distribution of Modified Versions of the Package as Source

    (4)  You may Distribute your Modified Version as Source (either gratis
    or for a Distributor Fee, and with or without a Compiled form of the
    Modified Version) provided that you clearly document how it differs
    from the Standard Version, including, but not limited to, documenting
    any non-standard features, executables, or modules, and provided that
    you do at least ONE of the following:

        (a)  make the Modified Version available to the Copyright Holder
        of the Standard Version, under the Original License, so that the
        Copyright Holder may include your modifications in the Standard
        Version.

        (b)  ensure that installation of your Modified Version does not
        prevent the user installing or running the Standard Version. In
        addition, the Modified Version must bear a name that is different
        from the name of the Standard Version.

        (c)  allow anyone who receives a copy of the Modified Version to
        make the Source form of the Modified Version available to others
        under

            (i)  the Original License or

            (ii)  a license that permits the licensee to freely copy,
            modify and redistribute the Modified Version using the same
            licensing terms that apply to the copy that the licensee
            received, and requires that the Source form of the Modified
            Version, and of any works derived from it, be made freely
            available in that license fees are prohibited but Distributor
            Fees are allowed.

    Distribution of Compiled Forms of the Standard Version
    or Modified Versions without the Source

    (5)  You may Distribute Compiled forms of the Standard Version without
    the Source, provided that you include complete instructions on how to
    get the Source of the Standard Version.  Such instructions must be
    valid at the time of your distribution.  If these instructions, at any
    time while you are carrying out such distribution, become invalid, you
    must provide new instructions on demand or cease further distribution.
    If you provide valid instructions or cease distribution within thirty
    days after you become aware that the instructions are invalid, then
    you do not forfeit any of your rights under this license.

    (6)  You may Distribute a Modified Version in Compiled form without
    the Source, provided that you comply with Section 4 with respect to
    the Source of the Modified Version.

    Aggregating or Linking the Package

    (7)  You may aggregate the Package (either the Standard Version or
    Modified Version) with other packages and Distribute the resulting
    aggregation provided that you do not charge a licensing fee for the
    Package.  Distributor Fees are permitted, and licensing fees for other
    components in the aggregation are permitted. The terms of this license
    apply to the use and Distribution of the Standard or Modified Versions
    as included in the aggregation.

    (8) You are permitted to link Modified and Standard Versions with
    other works, to embed the Package in a larger work of your own, or to
    build stand-alone binary or bytecode versions of applications that
    include the Package, and Distribute the result without restriction,
    provided the result does not expose a direct interface to the Package.

    Items That are Not Considered Part of a Modified Version

    (9) Works (including, but not limited to, modules and scripts) that
    merely extend or make use of the Package, do not, by themselves, cause
    the Package to be a Modified Version.  In addition, such works are not
    considered parts of the Package itself, and are not subject to the
    terms of this license.

    General Provisions

    (10)  Any use, modification, and distribution of the Standard or
    Modified Versions is governed by this Artistic License. By using,
    modifying or distributing the Package, you accept this license. Do not
    use, modify, or distribute the Package, if you do not accept this
    license.

    (11)  If your Modified Version has been derived from a Modified
    Version made by someone other than you, you are nevertheless required
    to ensure that your Modified Version complies with the requirements of
    this license.

    (12)  This license does not grant you the right to use any trademark,
    service mark, tradename, or logo of the Copyright Holder.

    (13)  This license includes the non-exclusive, worldwide,
    free-of-charge patent license to make, have made, use, offer to sell,
    sell, import and otherwise transfer the Package with respect to any
    patent claims licensable by the Copyright Holder that are necessarily
    infringed by the Package. If you institute patent litigation
    (including a cross-claim or counterclaim) against any party alleging
    that the Package constitutes direct or contributory patent
    infringement, then this Artistic License to you shall terminate on the
    date that such litigation is filed.

    (14)  Disclaimer of Warranty:
    THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
    IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE IMPLIED
    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR
    NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL
    LAW. UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL
    BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
    DAMAGES ARISING IN ANY WAY OUT OF THE USE OF THE PACKAGE, EVEN IF
    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    --------
  """

- GYP, located at tools/gyp, is licensed as follows:
  """
    Copyright (c) 2020 Node.js contributors. All rights reserved.
    Copyright (c) 2009 Google Inc. All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

       * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.
       * Neither the name of Google Inc. nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  """

- inspector_protocol, located at tools/inspector_protocol, is licensed as follows:
  """
    // Copyright 2016 The Chromium Authors. All rights reserved.
    //
    // Redistribution and use in source and binary forms, with or without
    // modification, are permitted provided that the following conditions are
    // met:
    //
    //    * Redistributions of source code must retain the above copyright
    // notice, this list of conditions and the following disclaimer.
    //    * Redistributions in binary form must reproduce the above
    // copyright notice, this list of conditions and the following disclaimer
    // in the documentation and/or other materials provided with the
    // distribution.
    //    * Neither the name of Google Inc. nor the names of its
    // contributors may be used to endorse or promote products derived from
    // this software without specific prior written permission.
    //
    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  """

- jinja2, located at tools/inspector_protocol/jinja2, is licensed as follows:
  """
    Copyright (c) 2009 by the Jinja Team, see AUTHORS for more details.

    Some rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials provided
          with the distribution.

        * The names of the contributors may not be used to endorse or
          promote products derived from this software without specific
          prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  """

- markupsafe, located at tools/inspector_protocol/markupsafe, is licensed as follows:
  """
    Copyright (c) 2010 by Armin Ronacher and contributors.  See AUTHORS
    for more details.

    Some rights reserved.

    Redistribution and use in source and binary forms of the software as well
    as documentation, with or without modification, are permitted provided
    that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * The names of the contributors may not be used to endorse or
      promote products derived from this software without specific
      prior written permission.

    THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE COPYRIGHT HOLDERS AND
    CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
    NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE AND DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGE.
  """

- cpplint.py, located at tools/cpplint.py, is licensed as follows:
  """
    Copyright (c) 2009 Google Inc. All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

       * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.
       * Neither the name of Google Inc. nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  """

- ESLint, located at tools/node_modules/eslint, is licensed as follows:
  """
    Copyright JS Foundation and other contributors, https://js.foundation

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
  """

- babel-eslint, located at tools/node_modules/babel-eslint, is licensed as follows:
  """
    Copyright (c) 2014-2016 Sebastian McKenzie <sebmck@gmail.com>

    MIT License

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  """

- gtest, located at test/cctest/gtest, is licensed as follows:
  """
    Copyright 2008, Google Inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

        * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.
        * Neither the name of Google Inc. nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  """

- nghttp2, located at deps/nghttp2, is licensed as follows:
  """
    The MIT License

    Copyright (c) 2012, 2014, 2015, 2016 Tatsuhiro Tsujikawa
    Copyright (c) 2012, 2014, 2015, 2016 nghttp2 contributors

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  """

- ngtcp2, located at deps/ngtcp2, is licensed as follows:
  """
    The MIT License

    Copyright (c) 2016 ngtcp2 contributors

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  """

- nghttp3, located at deps/nghttp3, is licensed as follows:
  """
    The MIT License

    Copyright (c) 2019 nghttp3 contributors

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  """

- node-inspect, located at deps/node-inspect, is licensed as follows:
  """
    Copyright Node.js contributors. All rights reserved.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.
  """

- large_pages, located at src/large_pages, is licensed as follows:
  """
     Copyright (C) 2018 Intel Corporation

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"),
     to deal in the Software without restriction, including without limitation
     the rights to use, copy, modify, merge, publish, distribute, sublicense,
     and/or sell copies of the Software, and to permit persons to whom
     the Software is furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included
     in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
     THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
     OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
     OR OTHER DEALINGS IN THE SOFTWARE.
  """

- caja, located at lib/internal/freeze_intrinsics.js, is licensed as follows:
  """
     Adapted from SES/Caja - Copyright (C) 2011 Google Inc.
     Copyright (C) 2018 Agoric

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
  """

- brotli, located at deps/brotli, is licensed as follows:
  """
    Copyright (c) 2009, 2010, 2013-2016 by the Brotli Authors.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
  """

- HdrHistogram, located at deps/histogram, is licensed as follows:
  """
    The code in this repository code was Written by Gil Tene, Michael Barker,
    and Matt Warren, and released to the public domain, as explained at
    http://creativecommons.org/publicdomain/zero/1.0/

    For users of this code who wish to consume it under the "BSD" license
    rather than under the public domain or CC0 contribution text mentioned
    above, the code found under this directory is *also* provided under the
    following license (commonly referred to as the BSD 2-Clause License). This
    license does not detract from the above stated release of the code into
    the public domain, and simply represents an additional license granted by
    the Author.

    -----------------------------------------------------------------------------
    ** Beginning of "BSD 2-Clause License" text. **

     Copyright (c) 2012, 2013, 2014 Gil Tene
     Copyright (c) 2014 Michael Barker
     Copyright (c) 2014 Matt Warren
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions are met:

     1. Redistributions of source code must retain the above copyright notice,
        this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright notice,
        this list of conditions and the following disclaimer in the documentation
        and/or other materials provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGE.
  """

- highlight.js, located at doc/api_assets/highlight.pack.js, is licensed as follows:
  """
    BSD 3-Clause License

    Copyright (c) 2006, Ivan Sagalaev.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, this
      list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.

    * Neither the name of the copyright holder nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  """

- node-heapdump, located at src/heap_utils.cc, is licensed as follows:
  """
    ISC License

    Copyright (c) 2012, Ben Noordhuis <info@bnoordhuis.nl>

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

    === src/compat.h src/compat-inl.h ===

    ISC License

    Copyright (c) 2014, StrongLoop Inc.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  """

- rimraf, located at lib/internal/fs/rimraf.js, is licensed as follows:
  """
    The ISC License

    Copyright (c) Isaac Z. Schlueter and Contributors

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
    IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  """

- uvwasi, located at deps/uvwasi, is licensed as follows:
  """
    MIT License

    Copyright (c) 2019 Colin Ihrig and Contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
  """

XX. React
MIT License

Copyright (c) Facebook, Inc. and its affiliates.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

XXI. Roboto Font
Apache License
Font data copyright Google 2012

                      Apache License
                  Version 2.0, January 2004
                http://www.apache.org/licenses/

  TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

  1. Definitions.

    “License” shall mean the terms and conditions for use, reproduction,
    and distribution as defined by Sections 1 through 9 of this document.

    “Licensor” shall mean the copyright owner or entity authorized by
    the copyright owner that is granting the License.

    “Legal Entity” shall mean the union of the acting entity and all
    other entities that control, are controlled by, or are under common
    control with that entity. For the purposes of this definition,
    “control” means (i) the power, direct or indirect, to cause the
    direction or management of such entity, whether by contract or
    otherwise, or (ii) ownership of fifty percent (50%) or more of the
    outstanding shares, or (iii) beneficial ownership of such entity.

    “You” (or “Your”) shall mean an individual or Legal Entity
    exercising permissions granted by this License.

    “Source” form shall mean the preferred form for making modifications,
    including but not limited to software source code, documentation
    source, and configuration files.

    “Object” form shall mean any form resulting from mechanical
    transformation or translation of a Source form, including but
    not limited to compiled object code, generated documentation,
    and conversions to other media types.

    “Work” shall mean the work of authorship, whether in Source or
    Object form, made available under the License, as indicated by a
    copyright notice that is included in or attached to the work
    (an example is provided in the Appendix below).

    “Derivative Works” shall mean any work, whether in Source or Object
    form, that is based on (or derived from) the Work and for which the
    editorial revisions, annotations, elaborations, or other modifications
    represent, as a whole, an original work of authorship. For the purposes
    of this License, Derivative Works shall not include works that remain
    separable from, or merely link (or bind by name) to the interfaces of,
    the Work and Derivative Works thereof.

    “Contribution” shall mean any work of authorship, including
    the original version of the Work and any modifications or additions
    to that Work or Derivative Works thereof, that is intentionally
    submitted to Licensor for inclusion in the Work by the copyright owner
    or by an individual or Legal Entity authorized to submit on behalf of
    the copyright owner. For the purposes of this definition, “submitted”
    means any form of electronic, verbal, or written communication sent
    to the Licensor or its representatives, including but not limited to
    communication on electronic mailing lists, source code control systems,
    and issue tracking systems that are managed by, or on behalf of, the
    Licensor for the purpose of discussing and improving the Work, but
    excluding communication that is conspicuously marked or otherwise
    designated in writing by the copyright owner as “Not a Contribution.”

    “Contributor” shall mean Licensor and any individual or Legal Entity
    on behalf of whom a Contribution has been received by Licensor and
    subsequently incorporated within the Work.

  2. Grant of Copyright License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    copyright license to reproduce, prepare Derivative Works of,
    publicly display, publicly perform, sublicense, and distribute the
    Work and such Derivative Works in Source or Object form.

  3. Grant of Patent License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    (except as stated in this section) patent license to make, have made,
    use, offer to sell, sell, import, and otherwise transfer the Work,
    where such license applies only to those patent claims licensable
    by such Contributor that are necessarily infringed by their
    Contribution(s) alone or by combination of their Contribution(s)
    with the Work to which such Contribution(s) was submitted. If You
    institute patent litigation against any entity (including a
    cross-claim or counterclaim in a lawsuit) alleging that the Work
    or a Contribution incorporated within the Work constitutes direct
    or contributory patent infringement, then any patent licenses
    granted to You under this License for that Work shall terminate
    as of the date such litigation is filed.

  4. Redistribution. You may reproduce and distribute copies of the
    Work or Derivative Works thereof in any medium, with or without
    modifications, and in Source or Object form, provided that You
    meet the following conditions:

    (a) You must give any other recipients of the Work or
      Derivative Works a copy of this License; and

    (b) You must cause any modified files to carry prominent notices
      stating that You changed the files; and

    (c) You must retain, in the Source form of any Derivative Works
      that You distribute, all copyright, patent, trademark, and
      attribution notices from the Source form of the Work,
      excluding those notices that do not pertain to any part of
      the Derivative Works; and

    (d) If the Work includes a “NOTICE” text file as part of its
      distribution, then any Derivative Works that You distribute must
      include a readable copy of the attribution notices contained
      within such NOTICE file, excluding those notices that do not
      pertain to any part of the Derivative Works, in at least one
      of the following places: within a NOTICE text file distributed
      as part of the Derivative Works; within the Source form or
      documentation, if provided along with the Derivative Works; or,
      within a display generated by the Derivative Works, if and
      wherever such third-party notices normally appear. The contents
      of the NOTICE file are for informational purposes only and
      do not modify the License. You may add Your own attribution
      notices within Derivative Works that You distribute, alongside
      or as an addendum to the NOTICE text from the Work, provided
      that such additional attribution notices cannot be construed
      as modifying the License.

    You may add Your own copyright statement to Your modifications and
    may provide additional or different license terms and conditions
    for use, reproduction, or distribution of Your modifications, or
    for any such Derivative Works as a whole, provided Your use,
    reproduction, and distribution of the Work otherwise complies with
    the conditions stated in this License.

  5. Submission of Contributions. Unless You explicitly state otherwise,
    any Contribution intentionally submitted for inclusion in the Work
    by You to the Licensor shall be under the terms and conditions of
    this License, without any additional terms or conditions.
    Notwithstanding the above, nothing herein shall supersede or modify
    the terms of any separate license agreement you may have executed
    with Licensor regarding such Contributions.

  6. Trademarks. This License does not grant permission to use the trade
    names, trademarks, service marks, or product names of the Licensor,
    except as required for reasonable and customary use in describing the
    origin of the Work and reproducing the content of the NOTICE file.

  7. Disclaimer of Warranty. Unless required by applicable law or
    agreed to in writing, Licensor provides the Work (and each
    Contributor provides its Contributions) on an “AS IS” BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    implied, including, without limitation, any warranties or conditions
    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
    PARTICULAR PURPOSE. You are solely responsible for determining the
    appropriateness of using or redistributing the Work and assume any
    risks associated with Your exercise of permissions under this License.

  8. Limitation of Liability. In no event and under no legal theory,
    whether in tort (including negligence), contract, or otherwise,
    unless required by applicable law (such as deliberate and grossly
    negligent acts) or agreed to in writing, shall any Contributor be
    liable to You for damages, including any direct, indirect, special,
    incidental, or consequential damages of any character arising as a
    result of this License or out of the use or inability to use the
    Work (including but not limited to damages for loss of goodwill,
    work stoppage, computer failure or malfunction, or any and all
    other commercial damages or losses), even if such Contributor
    has been advised of the possibility of such damages.

  9. Accepting Warranty or Additional Liability. While redistributing
    the Work or Derivative Works thereof, You may choose to offer,
    and charge a fee for, acceptance of support, warranty, indemnity,
    or other liability obligations and/or rights consistent with this
    License. However, in accepting such obligations, You may act only
    on Your own behalf and on Your sole responsibility, not on behalf
    of any other Contributor, and only if You agree to indemnify,
    defend, and hold each Contributor harmless for any liability
    incurred by, or claims asserted against, such Contributor by reason
    of your accepting any such warranty or additional liability.

  END OF TERMS AND CONDITIONS

  APPENDIX: How to apply the Apache License to your work.

    To apply the Apache License to your work, attach the following
    boilerplate notice, with the fields enclosed by brackets “[]”
    replaced with your own identifying information. (Don’t include
    the brackets!)  The text should be enclosed in the appropriate
    comment syntax for the file format. We also recommend that a
    file or class name and description of purpose be included on the
    same “printed page” as the copyright notice for easier
    identification within third-party archives.

  Copyright [yyyy] [name of copyright owner]

  Licensed under the Apache License, Version 2.0 (the “License”);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an “AS IS” BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

XXII.  Flatbuffers
https://github.com/google/flatbuffers

Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

XXIII. cpp-httplib
The MIT License (MIT)

Copyright (c) 2017 yhirose

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


XXIV.OpenSSL toolkit 
  The OpenSSL toolkit stays under a double license, i.e. both the conditions of
  the OpenSSL License and the original SSLeay license apply to the toolkit.
  See below for the actual license texts.

  OpenSSL License
  ---------------

/* ====================================================================
 * Copyright (c) 1998-2019 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */

 Original SSLeay License
 -----------------------

/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

XXV. Libcurl
COPYRIGHT AND PERMISSION NOTICE

Copyright (c) 1996 - 2021, Daniel Stenberg, daniel@haxx.se, and many contributors, see the THANKS file.

All rights reserved.

Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

XXVI. zlib

/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.11, January 15th, 2017

  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu

*/

Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization of the copyright holder.
```

`EasyAntiCheat.sys/cheatpages.c`:

```c
Checked memory types:
[non-shared only ]  Executable.
[non-shared only ]  Executable and read-only.
[including shared]  Executable and read/write.
[non-shared only ]  Executable and copy-on-write.
[non-shared only ]  Non-cacheable and executable.
[non-shared only ]  Non-cacheable, executable, and read-only.
[including shared]  Non-cacheable, executable, and read/write.
[non-shared only ]  Non-cacheable, executable, and copy-on-write.
[non-shared only ]  Guard page and executable.
[non-shared only ]  Guard page, executable, and read-only.
[including shared]  Guard page, executable, and read/write.
[non-shared only ]  Guard page, executable, and copy-on-write.
[non-shared only ]  Non-cacheable, guard page, and executable.
[non-shared only ]  Non-cacheable, guard page, executable, and read-only.
[including shared]  Non-cacheable, guard page, executable, and read/write.
[non-shared only ]  Non-cacheable, guard page, executable, and copy-on-write.

char __fastcall ScanProcessWorkingSet(__int64 process, char previousMode, WORKINGSET_DETECTION_BUFFER **outDetectionBuffer)
{
  char v3; // bp
  MEMORY_WORKING_SET_INFORMATION *wsi; // rax MAPDST
  WORKINGSET_DETECTION_BUFFER *detectionBuffer; // rax MAPDST
  ULONG_PTR v12; // r12
  int *info; // rbx
  unsigned __int64 protection; // rax

  v3 = 0;
  if ( !outDetectionBuffer )
    return 0;
  *outDetectionBuffer = 0i64;
  wsi = (MEMORY_WORKING_SET_INFORMATION *)AllocatePool(0x100000i64);
  if ( !wsi )
    return v3;
  if ( !QueryVirtualMemory0(0i64, process, 1u, (__int64)wsi, previousMode, 0x100000i64) )// MemoryWorkingSetInformation
    goto LABEL_33;
  detectionBuffer = (WORKINGSET_DETECTION_BUFFER *)AllocatePool(2048i64);
  if ( detectionBuffer )
  {
    memset(detectionBuffer, 0, 2048ui64);
    detectionBuffer->usedBytes = 16;
    detectionBuffer->maxSize = 2048;
  }
  *outDetectionBuffer = detectionBuffer;
  if ( !detectionBuffer )
    goto LABEL_33;
  v12 = 0i64;
  if ( !wsi->NumberOfEntries )
    goto LABEL_32;
  info = (int *)wsi->WorkingSetInfo;
  do
  {
    protection = *(_QWORD *)info & 0x1Fi64;
    if ( protection > 19 )
    {
      if ( protection == 22 )
        goto check_entry;                       // Guard page, executable, and read/write.
      if ( protection != 23 )
      {
        if ( protection <= 25 )
          goto skip_entry;
        if ( protection > 27 )
        {
          if ( protection == 30 )
            goto check_entry;                   // Non-cacheable, guard page, executable, and read/write.
          if ( protection != 31 )
            goto skip_entry;
        }
      }
    }
    else if ( protection < 18 )
    {
      if ( protection < 2 )
        goto skip_entry;
      if ( protection > 3 )
      {
        if ( protection == 6 )
          goto check_entry;                     // Executable and read/write.
        if ( protection != 7 )
        {
          if ( protection <= 9 )
            goto skip_entry;
          if ( protection > 0xB )
          {
            if ( protection == 14 )
              goto check_entry;                 // Non-cacheable, executable, and read/write.
            if ( protection != 15 )
              goto skip_entry;
          }
        }
      }
    }
    if ( previousMode && !_bittest64((const signed __int64 *)info, 8u) )// bit 8 = shared
    {
check_entry:
      v3 = 1;
      CheckWorkingSetEntry(*outDetectionBuffer, info, previousMode);
    }
skip_entry:
    ++v12;
    info += 2;
  }
  while ( v12 < wsi->NumberOfEntries );
  if ( !v3 )
  {
LABEL_32:
    FreePool((__int64)*outDetectionBuffer);
    *outDetectionBuffer = 0i64;
  }
LABEL_33:
  FreePool((__int64)wsi);
  return v3;
}

char __usercall CheckWorkingSetEntry@<al>(WORKINGSET_DETECTION_BUFFER *detectionBuffer@<rdx>, int *pWsiInfo@<r8>, signed int previousMode@<r14d>)
{
  unsigned __int64 v3; // rax
  void *address; // rdi
  unsigned __int64 v7; // r9
  WORKINGSET_DETECTION_ENTRY *prevEntry; // r8
  int wsiInfo; // eax
  __int64 v10; // rdx
  UNICODE_STRING mappedFilename; // [rsp+30h] [rbp-88h]
  UNICODE_STRING string; // [rsp+40h] [rbp-78h]
  WORKINGSET_DETECTION_ENTRY detectionEntry; // [rsp+50h] [rbp-68h]
  MEMORY_BASIC_INFORMATION mbi; // [rsp+78h] [rbp-40h]

  detectionEntry.address = 0i64;
  LOBYTE(v3) = 0;
  address = (void *)(*(_QWORD *)pWsiInfo & 0xFFFFFFFFFFFFF000ui64);// extract page address
  *(_QWORD *)&detectionEntry.offsetFromAllocationBase = 0i64;
  *(_QWORD *)&detectionEntry.isShared = 0i64;
  *(_QWORD *)&detectionEntry.mappedFilename[7] = 0i64;
  detectionEntry.mappedFilename[15] = 0;
  if ( !detectionBuffer )
    return v3;
  LODWORD(v3) = detectionBuffer->maxSize;
  if ( (unsigned int)v3 < 0x10 )
    return v3;
  LODWORD(v3) = v3 - detectionBuffer->usedBytes;
  ++detectionBuffer->unk123;
  if ( (unsigned int)v3 < 33 )
    return v3;
  mbi.BaseAddress = address;
  LOBYTE(v3) = (signed int)QueryVirtualMemory((__int64)address, -1i64, 0, (__int64)&mbi, previousMode, 48i64, 0i64) >= 0;
  if ( !(_BYTE)v3 )
  {
    detectionEntry.address = (__int64)address;
LABEL_14:
    wsiInfo = *pWsiInfo;
    v10 = (unsigned int)detectionBuffer->count;
    detectionEntry.isShared = (*pWsiInfo & 0x100i64) != 0;
    detectionEntry.protection = wsiInfo & 0x1F;
    detectionBuffer->count = v10 + 1;
    LOBYTE(v3) = (unsigned __int64)memmove(&detectionBuffer->entries[v10], &detectionEntry, 33ui64);
    detectionBuffer->usedBytes += 33;
    return v3;
  }
  v7 = 0i64;
  if ( !detectionBuffer->count )
  {
LABEL_9:
    detectionEntry.address = (__int64)mbi.AllocationBase;
    detectionEntry.offsetFromAllocationBase = (_DWORD)address - LODWORD(mbi.AllocationBase);
    if ( GetMappedFilename(-1i64, (__int64)mbi.AllocationBase, (__int64)&mappedFilename, previousMode) )
    {
      if ( sub_289F0(&mappedFilename.Length, (__int64)&string) )
        CopyUnicodeStringToAnsiBuffer((__int64)detectionEntry.mappedFilename, 16i64, &string);
      FreeUnicodeString(&mappedFilename);
    }
    goto LABEL_14;
  }
  prevEntry = detectionBuffer->entries;
  while ( (PVOID)prevEntry->address != mbi.AllocationBase )
  {
    v3 = (unsigned int)detectionBuffer->count;
    ++v7;
    ++prevEntry;
    if ( v7 >= v3 )
      goto LABEL_9;
  }
  return v3;
}
```

`EasyAntiCheat.sys/disk.c`:

```c
void __usercall SendDiskInformation(unsigned int a1@<ecx>, signed int a2@<r14d>)
{
  int crc32; // ebx
  unsigned int packetValueUnk; // ecx
  UNICODE_STRING deviceSerial; // [rsp+20h] [rbp-18h]

  deviceSerial.Length = 0;
  *(_QWORD *)&deviceSerial.MaximumLength = 0i64;
  crc32 = 0;
  *(_DWORD *)((char *)&deviceSerial.Buffer + 2) = 0;
  HIWORD(deviceSerial.Buffer) = 0;
  if ( QueryFilesystemDeviceSerial(3i64, &deviceSerial, a2)
    && deviceSerial.Buffer
    && deviceSerial.Length
    && deviceSerial.MaximumLength )
  {
    crc32 = HashCRC32((char *)deviceSerial.Buffer, deviceSerial.Length, deviceSerial.Length);
  }
  if ( !a1 || !crc32 || (packetValueUnk = 316, a1 != crc32) )
    packetValueUnk = 315;
  SendHWIDDataToServer(packetValueUnk, a1, crc32, &deviceSerial);
  if ( deviceSerial.Buffer && deviceSerial.Length )
  {
    if ( deviceSerial.MaximumLength )
      FreeUnicodeString(&deviceSerial);
  }
}

char __usercall QueryFilesystemDeviceSerial@<al>(__int64 a1@<rcx>, UNICODE_STRING *outData@<rdx>, signed int a3@<r14d>)
{
  char success; // bl
  _DEVICE_OBJECT *deviceObject; // rax MAPDST
  _DEVICE_OBJECT *filesystemDevice; // rax MAPDST
  UNICODE_STRING driverName; // [rsp+20h] [rbp-18h]

  success = 0;
  if ( !outData || KeGetCurrentIrql() || (unsigned __int8)import_KeAreAllApcsDisabled(a1) )
    return 0;
  InitializeUnicodeStringWithCStr(&driverName, (_WORD *)(StringTable + 4419));// \Driver\disk
  deviceObject = (_DEVICE_OBJECT *)GetLastDeviceObjectForDriver(&driverName, a3);
  if ( deviceObject )
  {
    filesystemDevice = (_DEVICE_OBJECT *)IoGetDeviceAttachmentBaseRef(deviceObject);
    if ( filesystemDevice )
    {
      if ( filesystemDevice != deviceObject )
        success = QueryDriveSmartOrStorageData(filesystemDevice, 3, outData);// 3 = query serial
      ObfDereferenceObject(filesystemDevice);
    }
    ObfDereferenceObject(deviceObject);
  }
  return success;
}

__int64 __usercall GetLastDeviceObjectForDriver@<rax>(UNICODE_STRING *driverName@<rcx>, signed int a2@<r14d>)
{
  unsigned int v2; // ebx
  __int64 lastDeviceObject; // r12
  _IMAGE_DOS_HEADER *v4; // rax
  __int64 IoDeviceObject; // rsi
  signed int status1; // edi MAPDST
  unsigned int access; // ST20_4
  unsigned int status0; // eax
  unsigned int bufferSize; // ebp
  __int64 deviceObjectList; // rsi
  __int64 lastDeviceIndex; // rcx
  PVOID *currentDeviceObject; // rdi
  PVOID *v16; // [rsp+20h] [rbp-78h]
  __int64 v17; // [rsp+28h] [rbp-70h]
  OBJECT_ATTRIBUTES objectAttributes; // [rsp+40h] [rbp-58h]
  __int64 deviceObjectNumber; // [rsp+A0h] [rbp+8h]
  PVOID driverObject; // [rsp+A8h] [rbp+10h]
  __int64 driverHandle; // [rsp+B0h] [rbp+18h]

  v2 = 0;
  lastDeviceObject = 0i64;
  LODWORD(deviceObjectNumber) = 0;
  if ( !driverName || !driverName->Buffer || !driverName->Length || !driverName->MaximumLength )
    return 0i64;
  objectAttributes.Length = 48;
  objectAttributes.RootDirectory = 0i64;
  objectAttributes.Attributes = 576;
  objectAttributes.ObjectName = driverName;
  objectAttributes.SecurityDescriptor = 0i64;
  objectAttributes.SecurityQualityOfService = 0i64;
  v4 = (_IMAGE_DOS_HEADER *)qword_4D8C8;
  if ( qword_4D8C8 || (v4 = FindExport(&unk_46B38), IoDeviceObject = 0i64, (qword_4D8C8 = (__int64)v4) != 0) )
    IoDeviceObject = *(_QWORD *)&v4->e_magic;
  if ( IoDeviceObject )
  {
    status1 = 0xC0000002;
    if ( import_ObOpenObjectByName )
    {
      access = 0x80000000;
      status1 = import_ObOpenObjectByName(&objectAttributes, IoDeviceObject, 0i64, 0i64, access, 0i64, &driverHandle);
    }
    else
    {
      status1 = 0xC0000002;
    }
    if ( status1 >= 0 )
    {
      if ( import_ObReferenceObjectByHandle )
      {
        v17 = 0i64;
        v16 = &driverObject;
        status1 = import_ObReferenceObjectByHandle(driverHandle, 1i64, IoDeviceObject);
      }
      else
      {
        status1 = 0xC0000002;
      }
      if ( status1 >= 0 )
      {
        if ( import_IoEnumerateDeviceObjectList )
          status0 = import_IoEnumerateDeviceObjectList(driverObject, 0i64, 0i64, &deviceObjectNumber, v16, v17);
        else
          status0 = 0xC0000002;
        if ( status0 == 0xC0000023 && (unsigned int)deviceObjectNumber > 0 )
        {
          bufferSize = 8 * deviceObjectNumber;
          deviceObjectList = AllocatePool((unsigned int)(8 * deviceObjectNumber));
          if ( deviceObjectList )
          {
            if ( import_IoEnumerateDeviceObjectList )
              status1 = import_IoEnumerateDeviceObjectList(
                          driverObject,
                          deviceObjectList,
                          bufferSize,
                          &deviceObjectNumber,
                          v16,
                          v17);
            if ( status1 >= 0 && (unsigned int)deviceObjectNumber > 0 )
            {
              lastDeviceIndex = (unsigned int)(deviceObjectNumber - 1);
              lastDeviceObject = *(_QWORD *)(deviceObjectList + 8 * lastDeviceIndex);
              if ( (unsigned int)lastDeviceIndex > 0 )
              {
                currentDeviceObject = (PVOID *)deviceObjectList;
                do
                {
                  ObfDereferenceObject(*currentDeviceObject);
                  ++v2;
                  ++currentDeviceObject;
                }
                while ( v2 < (signed int)deviceObjectNumber - 1 );
              }
            }
            FreePool(deviceObjectList);
          }
        }
        ObfDereferenceObject(driverObject);
      }
      CloseHandle(driverHandle, a2);
    }
  }
  return lastDeviceObject;
}

char __fastcall QueryDriveSmartOrStorageData(_DEVICE_OBJECT *deviceObject, int whatToQueryEnum, UNICODE_STRING *outData)
{
  char success; // bl

  success = 0;
  if ( !deviceObject
    || !outData
    || whatToQueryEnum != 2 && whatToQueryEnum != 3
    || KeGetCurrentIrql()
    || (unsigned __int8)import_KeAreAllApcsDisabled(deviceObject) )
  {
    return 0;
  }
  if ( QuerySmartData(whatToQueryEnum, deviceObject, outData)
    || QueryStorageProperty(whatToQueryEnum, deviceObject, outData) )
  {
    success = 1;
  }
  return success;
}

bool __fastcall QuerySmartData(int whatToQueryEnum, _DEVICE_OBJECT *deviceObject, UNICODE_STRING *outData)
{
  bool success; // bl
  _SENDCMDOUTPARAMS *outParams; // rsi
  int querySerial; // edi
  BYTE *data; // rbp
  size_t dataLength; // rdi
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r11
  char v13; // cl
  char v14; // al
  unsigned __int8 c; // al
  ANSI_STRING ansiString; // [rsp+30h] [rbp-C8h]
  SENDCMDINPARAMS inParams; // [rsp+40h] [rbp-B8h]
  char v19; // [rsp+6Eh] [rbp-8Ah]
  char v20; // [rsp+6Fh] [rbp-89h]
  char copiedData[128]; // [rsp+70h] [rbp-88h]
                                                // https://www.winsim.com/diskid32/diskid32.cpp
  success = 0;
  if ( deviceObject && outData )
  {
    outParams = (_SENDCMDOUTPARAMS *)AllocatePool(529i64);
    if ( !outParams )
      return success;
    *(_QWORD *)&outParams->cBufferSize = 0i64;
    *(_QWORD *)outParams->DriverStatus.dwReserved = 0i64;
    outParams->bBuffer[0] = 0;
    memset(&inParams, 0, 33ui64);
    inParams.irDriveRegs.bCommandReg = -20;     // Returns ID sector for ATA
    if ( SendIoControl(
           (__int64)&dword_7C088,               // SMART_RCV_DRIVE_DATA
           deviceObject,
           (__int64)&inParams,
           33u,
           (__int64)outParams,
           529) >= 0 )
    {
      querySerial = whatToQueryEnum - 2;
      if ( !querySerial )
      {
        data = (BYTE *)outParams[3].DriverStatus.dwReserved + 2;// model number
        dataLength = 40i64;
        goto LABEL_9;
      }
      if ( querySerial == 1 )
      {
        data = outParams[1].bBuffer;            // serial number
        dataLength = 20i64;
LABEL_9:
        if ( data && dataLength > 0 )
        {
          memset(copiedData, 0, 128ui64);
          memmove(copiedData, data, dataLength);
          v11 = dataLength - 1;
          v12 = 0i64;
          if ( dataLength - 1 > 0 )
          {
            do
            {
              v13 = copiedData[v12];
              v14 = copiedData[v12 + 1];
              v12 += 2i64;
              *(&v19 + v12) = v14;
              *(&v20 + v12) = v13;
            }
            while ( v12 < v11 );
            if ( v11 > 0 )
            {
              do
              {
                c = copiedData[v11];
                if ( (c < '\t' || c > '\r') && c != 0x20 )
                {
                  if ( c )
                    break;
                }
                else
                {
                  copiedData[v11] = 0;
                }
                --v11;
              }
              while ( v11 );
            }
          }
          ansiString.Buffer = copiedData;
          SetAnsiStringLength(&ansiString, copiedData);
          success = (signed int)AnsiStringToUnicodeString(outData, &ansiString) >= 0;
        }
        goto LABEL_21;
      }
    }
LABEL_21:
    FreePool((__int64)outParams);
    return success;
  }
  return 0;
}

bool __fastcall QueryStorageProperty(int whatToQueryEnum, _DEVICE_OBJECT *driverObject, UNICODE_STRING *outData)
{
  bool status; // bl
  unsigned __int64 dataLength; // rdi
  _STORAGE_DEVICE_DESCRIPTOR *deviceDescriptor; // rsi MAPDST
  char *deviceDescriptorEnd; // rcx
  int querySerial; // ebp
  char *data; // rdx
  unsigned __int64 maxSize0; // rcx
  unsigned __int64 maxSize1; // rcx
  size_t length; // rbp
  signed __int64 v16; // rax
  unsigned __int8 c; // cl
  _STORAGE_PROPERTY_QUERY propertyQuery; // [rsp+30h] [rbp-B8h]
  ANSI_STRING ansiString; // [rsp+40h] [rbp-A8h]
  char copiedData[128]; // [rsp+50h] [rbp-98h]
  __int64 requiredSize; // [rsp+F8h] [rbp+10h]

  status = 0;
  dataLength = 0i64;
  if ( driverObject && outData )
  {
    requiredSize = 0i64;
    *(_DWORD *)propertyQuery.AdditionalParameters = 0;
    propertyQuery.QueryType = 0;
    propertyQuery.PropertyId = 0;
    if ( SendIoControl(2954240i64, driverObject, (__int64)&propertyQuery, 0xCu, (__int64)&requiredSize, 8) < 0 )
      return status;
    if ( HIDWORD(requiredSize) <= 0x28 )
      return status;
    deviceDescriptor = (_STORAGE_DEVICE_DESCRIPTOR *)AllocatePool(HIDWORD(requiredSize));
    if ( !deviceDescriptor )
      return status;
    memset(deviceDescriptor, 0, HIDWORD(requiredSize));
    *(_DWORD *)propertyQuery.AdditionalParameters = 0;
    propertyQuery.QueryType = 0;                // StorageDeviceProperty
    propertyQuery.PropertyId = 0;               // PropertyStandardQuery
    if ( SendIoControl(
           0x2D1400i64,                         // IOCTL_STORAGE_QUERY_PROPERTY
           driverObject,
           (__int64)&propertyQuery,
           0xCu,
           (__int64)deviceDescriptor,
           SHIDWORD(requiredSize)) >= 0 )
    {
      deviceDescriptorEnd = (char *)deviceDescriptor + HIDWORD(requiredSize);
      querySerial = whatToQueryEnum - 2;
      if ( querySerial )
      {
        if ( querySerial == 1 && deviceDescriptor->SerialNumberOffset )
        {
          data = (char *)deviceDescriptor + deviceDescriptor->SerialNumberOffset;
          if ( data < (char *)deviceDescriptor || data >= deviceDescriptorEnd )
            goto LABEL_24;
          maxSize0 = deviceDescriptorEnd - data;
          if ( data )
          {
            if ( maxSize0 > 0 )
            {
              do
              {
                if ( !data[dataLength] )
                  break;
                ++dataLength;
              }
              while ( dataLength < maxSize0 );
            }
            goto LABEL_24;
          }
        }
      }
      else if ( deviceDescriptor->ProductIdOffset )
      {
        data = (char *)deviceDescriptor + deviceDescriptor->ProductIdOffset;
        if ( data < (char *)deviceDescriptor || data >= deviceDescriptorEnd )
          goto LABEL_24;
        maxSize1 = deviceDescriptorEnd - data;
        if ( data )
        {
          if ( maxSize1 > 0 )
          {
            do
            {
              if ( !data[dataLength] )
                break;
              ++dataLength;
            }
            while ( dataLength < maxSize1 );
          }
LABEL_24:
          if ( data && dataLength > 0 )
          {
            length = 127i64;
            if ( dataLength < 127 )
              length = dataLength;
            memmove(copiedData, data, length);
            copiedData[length] = 0;
            if ( length )
            {
              v16 = length - 1;
              if ( length - 1 > 0 )
              {
                do
                {
                  c = copiedData[v16];
                  if ( (c < '\t' || c > '\r') && c != ' ' )
                  {
                    if ( c )
                      break;
                  }
                  else
                  {
                    copiedData[v16] = 0;
                  }
                  --v16;
                }
                while ( v16 );
              }
            }
            *(_QWORD *)&ansiString.Length = copiedData;// it's Buffer but hexrays is doing weird shit
            SetAnsiStringLength(&ansiString, copiedData);
            status = (signed int)AnsiStringToUnicodeString(outData, &ansiString) >= 0;
          }
          goto LABEL_37;
        }
      }
    }
LABEL_37:
    FreePool((__int64)deviceDescriptor);
    return status;
  }
  return 0;
}
```

`EasyAntiCheat.sys/dispatchhook.c`:

```c
char __usercall CheckDriverDispatch@<al>(DRIVER_OBJECT *driverObject@<rcx>, _DWORD *detectionData@<r8>, _DWORD *outStatus@<r9>, signed int a4@<r14d>)
{
  char v4; // bp
  PDRIVER_DISPATCH addr; // rdi
  SYSTEM_MODULE_INFORMATION *moduleInformation; // rax MAPDST
  ULONG moduleIndex; // ecx
  PVOID *cur; // r12
  _BYTE *fileName; // rdx
  unsigned __int64 nameLength; // rax
  size_t nameLength2; // rdi

  v4 = 0;
  if ( !driverObject )
  {
    if ( outStatus )
      *outStatus = 2;
    return 0;
  }
  addr = driverObject->MajorFunction[14];
  if ( !addr )
  {
    if ( outStatus )
      *outStatus = 4;
    return 0;
  }
  moduleInformation = (SYSTEM_MODULE_INFORMATION *)QuerySystemModuleInformation(a4);
  if ( !moduleInformation )
  {
    if ( outStatus )
      *outStatus = 5;
    return 0;
  }
  moduleIndex = 0;
  if ( moduleInformation->Count )
  {
    cur = &moduleInformation->Module[0].ImageBase;
    while ( (unsigned __int64)*cur < MmSystemRangeStart
         || (char *)addr < *cur
         || (char *)addr > (char *)*cur + *((unsigned int *)cur + 2) )
    {
      ++moduleIndex;
      cur += 37;
      if ( moduleIndex >= moduleInformation->Count )
        goto LABEL_29;
    }
    v4 = 1;
    if ( detectionData )
    {
      fileName = cur + 3;
      nameLength = 0i64;
      *detectionData = (_DWORD)addr - *(_DWORD *)cur;
      if ( cur == (PVOID *)0xFFFFFFFFFFFFFFE8i64 )
        goto LABEL_35;
      do
      {
        if ( !fileName[nameLength] )
          break;
        ++nameLength;
      }
      while ( nameLength < 256 );
      nameLength2 = 255i64;
      if ( nameLength < 255 )
      {
LABEL_35:
        nameLength2 = 0i64;
        if ( cur != (PVOID *)0xFFFFFFFFFFFFFFE8i64 )
        {
          do
          {
            if ( !fileName[nameLength2] )
              break;
            ++nameLength2;
          }
          while ( nameLength2 < 256 );
        }
      }
      memmove(detectionData + 2, fileName, nameLength2);
      *((_BYTE *)detectionData + nameLength2 + 8) = 0;
      detectionData[1] = *((_DWORD *)cur + 2);
    }
    if ( outStatus )
      *outStatus = 7;
  }
LABEL_29:
  FreePool((__int64)moduleInformation);
  if ( !v4 && outStatus )
    *outStatus = 6;
  return v4;
}
```

`EasyAntiCheat.sys/dr.c`:

```c
void CheckDebugRegisters()
{
  __int64 v0; // rdx
  __int64 v1; // rcx
  __int64 v2; // rax
  __int64 currentProcessID; // rax
  __int64 *v4; // rax MAPDST
  unsigned __int64 dr7; // [rsp+38h] [rbp+10h]
  unsigned __int64 dr6; // [rsp+40h] [rbp+18h]

  ReadDR6_DR7(&dr6, &dr7);
  if ( (_BYTE)dr7 )
  {
    v2 = import_PsGetCurrentProcess(v1, v0);
    if ( import_PsGetProcessId )
      currentProcessID = import_PsGetProcessId(v2);
    else
      currentProcessID = 0i64;
    v4 = sub_29404(currentProcessID);
    if ( v4 )
    {
      sub_330E0((__int64)v4, 14i64, 0);
      sub_29534((__int64)v4);
    }
  }
}
```

`EasyAntiCheat.sys/driver.c`:

```c
SYSTEM_MODULE_INFORMATION *__usercall LogAllLoadedDrivers@<rax>(signed int a1@<r14d>)
{
  signed __int64 v1; // r13
  SYSTEM_MODULE_INFORMATION *result; // rax
  SYSTEM_MODULE_INFORMATION *systemModuleInformation; // rdi
  _DWORD *logBuffer; // rsi
  _IMAGE_DOS_HEADER *moduleBuffer; // r14
  ULONG moduleIndex; // er15
  PVOID *currentModule; // r12
  __int64 moduleBase; // rcx
  signed __int64 moduleName; // rbp
  unsigned __int64 nameLength; // rbx
  __int64 offsetToFilename; // rax
  signed __int64 v12; // r13
  unsigned __int64 v13; // rdx
  _BYTE *v14; // rcx
  unsigned __int64 v15; // r8
  signed __int64 v16; // rbp
  char v17; // al
  __int64 checksumAndTimestamp; // [rsp+20h] [rbp-38h]
  ULONG entrypointRva; // [rsp+28h] [rbp-30h]
  __int16 nameLength0; // [rsp+2Ch] [rbp-2Ch]
  _IMAGE_NT_HEADERS64 *ntHeaders; // [rsp+60h] [rbp+8h]

  v1 = 4i64;
  result = (SYSTEM_MODULE_INFORMATION *)QuerySystemModuleInformation(a1);
  systemModuleInformation = result;
  if ( result )
  {
    if ( result->Count )
    {
      logBuffer = (_DWORD *)AllocatePool(0x2000i64);
      if ( logBuffer )
      {
        *logBuffer = 0;
        moduleBuffer = (_IMAGE_DOS_HEADER *)AllocatePool(4096i64);
        if ( moduleBuffer )
        {
          moduleIndex = 0;
          if ( systemModuleInformation->Count )
          {
            currentModule = &systemModuleInformation->Module[0].ImageBase;
            do
            {
              moduleBase = (__int64)*currentModule;
              if ( (unsigned __int64)*currentModule >= MmSystemRangeStart && moduleBase != EACBase )
              {
                if ( (unsigned __int64)(v1 + 270) > 0x2000 )
                  break;
                checksumAndTimestamp = 0i64;
                entrypointRva = 0;
                if ( CopyVirtualMemory(moduleBase, 4096i64, (__int64)moduleBuffer) == 4096
                  && ValidatePeHeader(moduleBuffer, 0x1000ui64, 0i64, &ntHeaders) )
                {
                  HIDWORD(checksumAndTimestamp) = ntHeaders->OptionalHeader.CheckSum;
                  LODWORD(checksumAndTimestamp) = ntHeaders->FileHeader.TimeDateStamp;
                  entrypointRva = ntHeaders->OptionalHeader.AddressOfEntryPoint;
                }
                moduleName = (signed __int64)(currentModule + 3);
                nameLength = 0i64;
                if ( currentModule != (PVOID *)0xFFFFFFFFFFFFFFE8i64 )
                {
                  do
                  {
                    if ( !*(_BYTE *)(nameLength + moduleName) )
                      break;
                    ++nameLength;
                  }
                  while ( nameLength < 0xFF );
                }
                nameLength0 = nameLength;
                if ( *((_WORD *)currentModule + 11) == 29
                  && strstrIgnoreCase((_BYTE *)currentModule + 0x18, (_BYTE *)(StringTable + 1187), 29ui64) )// \SystemRoot\system32\drivers\
                {
                  offsetToFilename = *((unsigned __int16 *)currentModule + 11);
                  moduleName += offsetToFilename;
                  LOWORD(nameLength) = nameLength - offsetToFilename;
                  nameLength0 = nameLength;
                }
                *(_QWORD *)((char *)logBuffer + v1) = checksumAndTimestamp;
                v12 = v1 + 14;
                v13 = 0x2000 - v12;
                *(_DWORD *)((char *)logBuffer + v12 - 6) = entrypointRva;
                *(_WORD *)((char *)logBuffer + v12 - 2) = nameLength0;
                v14 = (char *)logBuffer + v12;
                if ( v12 != 0x2000 && v13 <= 0x7FFFFFFF )
                {
                  if ( (unsigned __int16)nameLength <= 0x7FFFFFFEui64 )
                  {
                    v15 = (unsigned __int16)nameLength - v13;
                    v16 = moduleName - (_QWORD)v14;
                    do
                    {
                      if ( !(v15 + v13) )
                        break;
                      v17 = v14[v16];
                      if ( !v17 )
                        break;
                      *v14++ = v17;
                      --v13;
                    }
                    while ( v13 );
                    if ( !v13 )
                      --v14;
                  }
                  *v14 = 0;
                }
                v1 = (unsigned __int16)nameLength + v12;
                ++*logBuffer;
              }
              ++moduleIndex;
              currentModule += 37;
            }
            while ( moduleIndex < systemModuleInformation->Count );
          }
          FreePool((__int64)moduleBuffer);
        }
        SendPacketToServer(294i64, (__int64)logBuffer, (unsigned int)v1);
        FreePool((__int64)logBuffer);
      }
    }
    result = (SYSTEM_MODULE_INFORMATION *)FreePool((__int64)systemModuleInformation);
  }
  return result;
}

__int64 __usercall IterateDirectoriesRecursive@<rax>(UNICODE_STRING *argPath@<rdx>, __int64 *outBuffer@<rcx>, unsigned int a3@<r8d>, unsigned int a4@<r9d>, signed int a5@<r14d>, char a6)
{
  unsigned int index; // ebp
  __int64 directoryObject; // rbx
  signed int status; // eax
  OBJECT_DIRECTORY_INFORMATION *objectInfo; // rsi
  bool isDirectory; // al MAPDST
  bool isRoot; // bl
  unsigned __int16 fullLength; // r8
  DRIVER_OBJECT *driver; // rax MAPDST
  __int64 v16; // rax
  __int64 a6a; // [rsp+20h] [rbp-98h]
  bool isDriver; // [rsp+40h] [rbp-78h]
  int v21; // [rsp+44h] [rbp-74h]
  UNICODE_STRING path; // [rsp+48h] [rbp-70h]
  __int64 directoryHandle; // [rsp+58h] [rbp-60h]
  UNICODE_STRING argPathCopy; // [rsp+60h] [rbp-58h]
  OBJECT_ATTRIBUTES objectAttributes; // [rsp+70h] [rbp-48h]

  index = 0;
  v21 = 0;
  if ( !outBuffer )
    return 0i64;
  if ( !argPath )
    return 0i64;
  if ( !argPath->Buffer )
    return 0i64;
  if ( !argPath->Length )
    return 0i64;
  if ( !argPath->MaximumLength )
    return 0i64;
  if ( !a3 )
    return 0i64;
  if ( !a4 )
    return 0i64;
  directoryObject = GetDirectoryObjectType(a5);
  if ( !directoryObject || !AllocateCopyUnicodeString((__int64)&argPathCopy, argPath) )
    return 0i64;
  objectAttributes.Length = 48;
  objectAttributes.RootDirectory = 0i64;
  objectAttributes.ObjectName = &argPathCopy;
  objectAttributes.Attributes = 512;
  objectAttributes.SecurityDescriptor = 0i64;
  objectAttributes.SecurityQualityOfService = 0i64;
  if ( import_ObOpenObjectByName )
    status = import_ObOpenObjectByName(&objectAttributes, directoryObject, 0i64, 0i64, 1, 0i64, &directoryHandle);
  else
    status = 0xC0000002;
  if ( status >= 0 )
  {
    objectInfo = (OBJECT_DIRECTORY_INFORMATION *)AllocatePool(1024i64);
    if ( objectInfo )
    {
      if ( a3 > 0 )
      {
        do
        {
          LOBYTE(a6a) = 0;
          if ( (signed int)GetNextDirectoryObject((__int64)objectInfo, directoryHandle, 0x400u, a5, a6a, (__int64)&v21) < 0 )
            break;
          isDriver = CompareUnicodeStrings((__int64)&objectInfo->TypeName, (_WORD *)(StringTable + 1247)) == 0;// Driver
          isDirectory = CompareUnicodeStrings((__int64)&objectInfo->TypeName, (_WORD *)(StringTable + 1261)) == 0;// Directory
          if ( (isDriver || isDirectory)
            && argPath->Buffer
            && argPath->Length
            && argPath->MaximumLength
            && objectInfo->Name.Buffer
            && objectInfo->Name.Length
            && objectInfo->Name.MaximumLength )
          {
            isRoot = CompareUnicodeStrings((__int64)argPath, (_WORD *)(StringTable + 1217)) == 0;// \
            fullLength = objectInfo->Name.Length + argPath->Length;
            if ( !isRoot )
              fullLength += 2;
            if ( AllocatePoolForUnicodeString((__int64)&path, argPath, fullLength) )
            {
              if ( !isRoot && StringTable != 4294966079 )
                CopyUnicodeString(&path, StringTable + 1217);// \
              if ( (signed int)AppendUnicodeString(&path, objectInfo) >= 0 )
              {
                if ( isDirectory && a4 > 0 )
                {
                  index += IterateDirectoriesRecursive(&path, &outBuffer[index], a3 - index, a4 - 1, a5, a6);
                }
                else if ( isDriver )
                {
                  driver = (DRIVER_OBJECT *)OpenDriver(&path.Length);
                  if ( driver )
                  {
                    if ( !a6 || driver->DriverSection && driver->DriverStart && driver->DriverSize )
                    {
                      v16 = index++;
                      outBuffer[v16] = (__int64)driver;
                    }
                    else
                    {
                      ObfDereferenceObject(driver);
                    }
                  }
                }
              }
              FreeUnicodeString(&path);
            }
          }
        }
        while ( index < a3 );
      }
      FreePool((__int64)objectInfo);
    }
    CloseHandle(directoryHandle, a5);
  }
  FreeUnicodeString(&argPathCopy);
  return index;
}

char __usercall CheckDriverObjects@<al>(_QWORD *a1@<rcx>, _DWORD *a2@<rdx>, __int64 detectionBuffer@<r8>, signed int a4@<r14d>)
{
  char v4; // bl
  __int64 directoryObject; // rdi
  SYSTEM_MODULE_INFORMATION *moduleInfo; // rsi
  signed int v10; // ST20_4
  signed int v11; // eax
  OBJECT_DIRECTORY_INFORMATION *objectInfo; // rdi
  __int64 v14; // [rsp+20h] [rbp-88h]
  UNICODE_STRING v15; // [rsp+40h] [rbp-68h]
  OBJECT_ATTRIBUTES v2; // [rsp+50h] [rbp-58h]
  int v17; // [rsp+B0h] [rbp+8h]
  __int64 directoryHandle; // [rsp+C8h] [rbp+20h]

  v4 = 0;
  v17 = 0;
  if ( !a1 || !a2 || !detectionBuffer )
    return 0;
  directoryObject = GetDirectoryObjectType(a4);
  if ( directoryObject )
  {
    moduleInfo = (SYSTEM_MODULE_INFORMATION *)QuerySystemModuleInformation(a4);
    if ( moduleInfo )
    {
      InitializeUnicodeStringWithCStr(&v15, (_WORD *)(StringTable + 1221));// \Driver\
      v2.Length = 48;
      v2.ObjectName = &v15;
      v2.RootDirectory = 0i64;
      v2.Attributes = 512;
      v2.SecurityDescriptor = 0i64;
      v2.SecurityQualityOfService = 0i64;
      if ( import_ObOpenObjectByName )
      {
        v10 = 1;
        v11 = import_ObOpenObjectByName(&v2, directoryObject, 0i64, 0i64, v10, 0i64, &directoryHandle);
      }
      else
      {
        v11 = 0xC0000002;
      }
      if ( v11 >= 0 )
      {
        objectInfo = (OBJECT_DIRECTORY_INFORMATION *)AllocatePool(0x400i64);
        if ( objectInfo )
        {
          while ( 1 )
          {
            LOBYTE(v14) = 0;
            if ( (signed int)GetNextDirectoryObject(
                               (__int64)objectInfo,
                               directoryHandle,
                               0x400u,
                               a4,
                               v14,
                               (__int64)&v17) < 0 )
              break;
            if ( IsDriverNotBackedByModule(objectInfo, moduleInfo, a1, a2) )
            {
              AllocateCopyUnicodeString(detectionBuffer, &objectInfo->Name);
              v4 = 1;
              break;
            }
          }
          FreePool((__int64)objectInfo);
        }
        CloseHandle(directoryHandle, a4);
      }
      FreePool((__int64)moduleInfo);
    }
  }
  return v4;
}

char __fastcall IsDriverNotBackedByModule(OBJECT_DIRECTORY_INFORMATION *objectInfo, SYSTEM_MODULE_INFORMATION *moduleInfo, _QWORD *a3, _DWORD *a4)
{
  char v4; // bl
  unsigned __int64 v6; // rsi
  int v11; // eax
  signed int v12; // eax
  unsigned __int64 driverStart; // rcx
  __int64 v15; // rcx
  int v16; // er11
  DRIVER_OBJECT *driverObject; // [rsp+40h] [rbp-38h] MAPDST
  UNICODE_STRING driverName; // [rsp+48h] [rbp-30h]

  v4 = 0;
  v6 = (unsigned __int64)EACBase >> 32;
  if ( !import_IoDriverObjectType )
  {
    import_IoDriverObjectType = (__int64)FindExport(&unk_46B38);
    if ( !import_IoDriverObjectType )
      return 0;
  }
  if ( objectInfo )
  {
    if ( moduleInfo )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          if ( (_DWORD)v6 )
          {
            driverName.Buffer = (PWSTR)AllocatePool(512i64);
            if ( driverName.Buffer )
            {
              driverName.Length = 0;
              driverName.MaximumLength = 512;
              if ( StringTable == 0xFFFFFFFFFFFFEE92i64 )
                v11 = 0;
              else
                v11 = CopyUnicodeString(&driverName, StringTable + 0x116E);// \Driver\
              if ( v11 >= 0 && (signed int)AppendUnicodeString(&driverName, objectInfo) >= 0 )
              {
                v12 = import_ObReferenceObjectByName ? (unsigned int)import_ObReferenceObjectByName(
                                                                       &driverName,
                                                                       576i64,
                                                                       0i64,
                                                                       0i64,
                                                                       *(_QWORD *)import_IoDriverObjectType,
                                                                       0,
                                                                       0i64,
                                                                       &driverObject) : 0xC0000002;
                if ( v12 >= 0 )
                {
                  driverStart = (unsigned __int64)driverObject->DriverStart;
                  if ( driverStart
                    && driverObject->DriverSize
                    && driverObject->DriverSection
                    && driverStart >> 32 == v6
                    && !FindModuleForAddress((unsigned __int64)driverObject->DriverStart, moduleInfo) )
                  {
                    *a3 = v15;
                    *a4 = v16;
                    v4 = 1;
                  }
                  ObfDereferenceObject(driverObject);
                }
              }
              FreePool((__int64)driverName.Buffer);
            }
          }
        }
      }
    }
  }
  return v4;
}

char __fastcall CheckUnloadedDrivers(unsigned __int16 *a1)
{
  UNK_BUFFER2 *v1; // rsi
  char v2; // r12
  __int64 SystemTime; // rdi
  __int64 TickCount; // rbx
  signed __int64 systemTimeFromTickCount; // rbx
  __int64 (__fastcall *MmGetPhysicalAddress)(__int64); // rax
  __int64 PhysMmUnloadedDrivers; // rax
  __int64 unloadedDrivers; // rax MAPDST
  unsigned __int64 index; // r14
  signed __int64 addr; // rax
  signed __int64 decIndex; // r15
  WCHAR *v13; // r13
  USHORT nameLength; // cx
  PWSTR nameBuffer; // rdx
  signed __int64 timeSinceUnload; // rbp
  __int64 bufferPhys; // rax
  LONG v18; // eax
  signed __int64 v19; // r9
  const wchar_t *v20; // r8
  unsigned __int16 v21; // ax
  unsigned __int64 v22; // rbp
  signed __int64 sizeLeft; // r10
  unsigned __int64 v24; // rdx
  __int16 *curCh; // r8
  signed int v26; // er9
  __int16 v27; // cx
  signed __int64 v28; // r11
  __int16 v29; // cx
  __int64 v30; // r15
  _MM_UNLOADED_DRIVER unloadedDriver; // [rsp+30h] [rbp-188h]
  __int64 v33; // [rsp+60h] [rbp-158h]
  UNICODE_STRING name; // [rsp+70h] [rbp-148h]
  char printfBuffer[256]; // [rsp+80h] [rbp-138h]
  __int64 MmUnloadedDrivers; // [rsp+1C8h] [rbp+10h]
  __int64 nullbyte; // [rsp+1D0h] [rbp+18h]
  __int64 SystemTime2; // [rsp+1D8h] [rbp+20h]

  v1 = (UNK_BUFFER2 *)a1;
  nullbyte = 0i64;
  v2 = 0;
  if ( !FindMmUnloadedDrivers(&MmUnloadedDrivers) )
    return 0;
  SystemTime = MEMORY[0xFFFFF78000000014];
  TickCount = MEMORY[0xFFFFF78000000320];
  SystemTime2 = MEMORY[0xFFFFF78000000014];
  systemTimeFromTickCount = KeQueryTimeIncrement() * TickCount;
  if ( !sub_30C04((__int64)v1, 1024u) )
    return v2;
  MmGetPhysicalAddress = import_MmGetPhysicalAddress;
  v1->bytesUsed = 0;
  v1->size = 1024;
  if ( MmGetPhysicalAddress )
    PhysMmUnloadedDrivers = MmGetPhysicalAddress(MmUnloadedDrivers);
  else
    PhysMmUnloadedDrivers = qword_4DBE8;
  if ( !PhysMmUnloadedDrivers )
    goto LABEL_68;
  unloadedDrivers = MapPhysicalMemory(PhysMmUnloadedDrivers, 2000i64);
  if ( !unloadedDrivers )
    goto LABEL_68;
  index = 0i64;
  addr = unloadedDrivers + 2000;
  decIndex = 50i64;
  while ( 1 )
  {
    --decIndex;
    v13 = 0i64;
    v33 = addr - 40;
    memmove(&unloadedDriver, (const void *)(addr - 40), 40ui64);
    nameLength = unloadedDriver.Name.Length;
    nameBuffer = unloadedDriver.Name.Buffer;
    if ( !unloadedDriver.Name.Length
      && !unloadedDriver.Name.MaximumLength
      && !unloadedDriver.Name.Buffer
      && !unloadedDriver.ModuleStart
      && !unloadedDriver.ModuleEnd
      && !unloadedDriver.UnloadTime )
    {
      if ( index > 0 && !byte_4DA66 )
      {
        SendPacketToServer(351i64, 0i64, 0i64);
        byte_4DA66 = 1;
      }
      goto next_entry;
    }
    ++index;
    timeSinceUnload = SystemTime - unloadedDriver.UnloadTime;
    if ( (signed __int64)(SystemTime - unloadedDriver.UnloadTime) > systemTimeFromTickCount )
      break;
    if ( timeSinceUnload <= 36000000000i64 )
      goto check_entry;
next_entry:
    addr = v33;
    if ( !decIndex )
      goto LABEL_63;
  }
  if ( byte_4DA67 )
  {
    SendPacketToServer(350i64, 0i64, 0i64);
    nameBuffer = unloadedDriver.Name.Buffer;
    nameLength = unloadedDriver.Name.Length;
    byte_4DA67 = 1;
  }
check_entry:
  if ( nameBuffer && nameLength && unloadedDriver.Name.MaximumLength )
  {
    if ( import_MmGetPhysicalAddress )
    {
      bufferPhys = import_MmGetPhysicalAddress(nameBuffer);
      nameLength = unloadedDriver.Name.Length;
    }
    else
    {
      bufferPhys = qword_4DBE8;
    }
    if ( bufferPhys && (v13 = (WCHAR *)MapPhysicalMemory(bufferPhys, nameLength)) != 0i64 )
    {
      unloadedDriver.Name.Buffer = v13;
      MmUnloadedDrivers = unloadedDriver.Name.Length;
    }
    else
    {
      unloadedDriver.Name.Buffer = 0i64;
      unloadedDriver.Name.Length = 0;
      unloadedDriver.Name.MaximumLength = 0;
    }
  }
  v18 = CompareUnicodeStrings((__int64)&unloadedDriver, (_WORD *)(StringTable + 7242));// easyanticheat.sys
  v19 = unloadedDriver.ModuleEnd - unloadedDriver.ModuleStart;
  if ( v18 != 0 || v19 != *(_DWORD *)(qword_4E080 + 32) )
  {
    if ( unloadedDriver.Name.Buffer && unloadedDriver.Name.Length > 0xD8u )
    {
      unloadedDriver.Name.Length = 216;
      unloadedDriver.Name.Buffer[108] = 0;
    }
    v20 = (const wchar_t *)(StringTable + 7278);// %wZ 0x%X %i
    _mm_storeu_si128((__m128i *)&name, _mm_loadu_si128((const __m128i *)&unloadedDriver));
    if ( (signed int)VsnwprintfWrapper(
                       (wchar_t *)printfBuffer,
                       0x100ui64,
                       v20,
                       &name,
                       v19,
                       ((unsigned __int64)(timeSinceUnload
                                         + ((unsigned __int128)(timeSinceUnload * (signed __int128)0xD6BF94D5E57A42BDi64) >> 64)) >> 63)
                     + ((signed __int64)(timeSinceUnload
                                       + ((unsigned __int128)(timeSinceUnload * (signed __int128)0xD6BF94D5E57A42BDi64) >> 64)) >> 23)) >= 0
      && !(v1->bytesUsed & 1) )
    {
      v21 = v1->size;
      if ( !(v21 & 1) && v1->bytesUsed <= v21 && v21 <= 0xFFFEu && (v1->pool || !v1->bytesUsed && !v21) )
      {
        v22 = (unsigned __int64)v1->bytesUsed >> 1;
        sizeLeft = 0x7FFFi64;
        v24 = ((unsigned __int64)v21 >> 1) - v22;
        curCh = (__int16 *)printfBuffer;
        v26 = 0;
        v27 = 0;
        if ( (unsigned __int64)v21 >> 1 == v22 )
          goto LABEL_72;
        v28 = 2 * v22 - (_QWORD)printfBuffer + v1->pool;
        do
        {
          if ( !sizeLeft )
            break;
          if ( *curCh == (_WORD)nullbyte )
            break;
          *(__int16 *)((char *)curCh + v28) = *curCh;
          --v24;
          ++curCh;
          --sizeLeft;
          ++v27;
        }
        while ( v24 );
        SystemTime = SystemTime2;
        if ( !v24 )
        {
          if ( sizeLeft )
          {
LABEL_72:
            if ( *curCh )
              v26 = 0x80000005;
          }
        }
        v29 = 2 * (v22 + v27);
        if ( v26 >= 0 )
          v2 = 1;
        v1->bytesUsed = v29;
      }
    }
  }
  if ( v13 && import_MmUnmapVideoDisplay )
    import_MmUnmapVideoDisplay(v13, MmUnloadedDrivers);
  if ( v1->bytesUsed != v1->size )
    goto next_entry;
LABEL_63:
  v30 = unloadedDrivers;
  if ( !index )
    SendPacketToServer(349i64, 0i64, 0i64);
  if ( import_MmUnmapVideoDisplay )
    import_MmUnmapVideoDisplay(v30, 2000i64);
  if ( !v2 )
LABEL_68:
    FreeUnicodeString(v1);
  return v2;
}
```

`EasyAntiCheat.sys/handles.c`:

```c
__int64 __usercall CheckOpenedHandles@<rax>(PVOID protectedProcessID@<rcx>, __int64 a2@<rdx>, unsigned __int64 a3@<r14>)
{
  char v3; // bp
  SYSTEM_HANDLE_INFORMATION *handleInformation; // rax MAPDST
  ULONG index; // esi
  __int64 entry; // rbx
  __int64 ownerProcess; // r13
  __int64 handle; // rbp
  char v12; // r15
  signed int v13; // ebp
  __int64 v14; // [rsp+20h] [rbp-88h]
  __int64 v15; // [rsp+28h] [rbp-80h]
  __int64 v16; // [rsp+30h] [rbp-78h]
  _PROCESS_BASIC_INFORMATION processInfo; // [rsp+40h] [rbp-68h]
  char v19; // [rsp+C0h] [rbp+18h]
  __int64 duplicatedHandle; // [rsp+C8h] [rbp+20h]

  v3 = 1;
  v19 = 1;
  if ( !ReportProcess )
    return 0i64;
  handleInformation = (SYSTEM_HANDLE_INFORMATION *)QuerySystemInformation_0(
                                                     0x10u,
                                                     (unsigned __int64)qword_80000,
                                                     0x1000000u,
                                                     0i64,
                                                     a3);
  if ( !handleInformation )
    return 0i64;
  index = 0;
  if ( handleInformation->Count )
  {
    entry = (__int64)&handleInformation->Info[0].GrantedAccess;
    while ( 1 )
    {
      if ( !v3 )
        goto LABEL_24;
      if ( *(_DWORD *)(entry - 16) > 4u && *(_DWORD *)(entry - 16) != (_DWORD)protectedProcessID )
      {
        ownerProcess = GetProcessHandleFromPID(*(unsigned int *)(entry - 0x10), 1104i64);
        if ( ownerProcess )
          break;
      }
LABEL_23:
      ++index;
      entry += 24i64;
      if ( index >= handleInformation->Count )
        goto LABEL_24;
    }
    if ( !byte_4DEF2 || byte_4DEF2 == *(_BYTE *)(entry - 12) )
    {
      a3 = __readgsqword(0x188u);
      handle = *(unsigned __int16 *)(entry - 0xA);
      v12 = GetPreviousMode(a3, a3);
      SetPreviousMode(0, a3, a3);
      if ( import_NtDuplicateObject )
      {
        LODWORD(v16) = 2;
        LODWORD(v15) = 512;
        LODWORD(v14) = 0;
        v13 = import_NtDuplicateObject(ownerProcess, handle, -1i64, &duplicatedHandle, v14, v15, v16);
      }
      else
      {
        v13 = -1073741822;
      }
      SetPreviousMode(v12, a3, a3);
      if ( v13 >= 0 )
      {
        if ( (signed int)QueryProcessInformation(0, duplicatedHandle, (__int64)&processInfo, 0x30u, a3, 0i64) < 0 )
        {
          CloseHandle(duplicatedHandle, a3);
        }
        else
        {
          CloseHandle(duplicatedHandle, a3);
          byte_4DEF2 = *(_BYTE *)(entry - 12);
          if ( (PVOID)processInfo.UniqueProcessId == protectedProcessID && (unsigned int)word_E063A & *(_DWORD *)entry )
          {
            v3 = ReportProcess(
                   protectedProcessID,
                   *(unsigned int *)(entry - 0x10),// handle owner PID
                   *(unsigned __int16 *)(entry - 10),// handle
                   *(_DWORD *)entry,            // access
                   (PVOID)a2);
            v19 = v3;
            goto LABEL_22;
          }
        }
      }
      v3 = v19;
    }
LABEL_22:
    CloseHandle(ownerProcess, a3);
    goto LABEL_23;
  }
LABEL_24:
  FreePool((__int64)handleInformation);
  return index;
}
```

`EasyAntiCheat.sys/hiddenprocess.c`:

```c
__int64 FindHiddenProcess()
{
  __int64 hiddenProcess; // rbx
  __int64 *processesFromThreads; // r12
  HANDLE *processes; // r14
  unsigned int *list; // r15
  unsigned int processFromThreadCount; // eax
  __int64 processFromThreadCount0; // rsi
  unsigned int processCount; // eax MAPDST
  unsigned int processIndex; // ebp MAPDST
  __int64 *currentProcess; // r13
  __int64 processFromThreadIndex; // rdi
  __int64 *currentProcessFromThread; // rbp
  __int64 pid; // r13
  signed int status; // eax
  __int64 hiddenProcessId; // r11
  HANDLE *v17; // rax
  PVOID *v18; // rdi
  PVOID processObject; // [rsp+50h] [rbp+8h]

  hiddenProcess = 0i64;
  processesFromThreads = (__int64 *)AllocatePool(4096i64);
  if ( processesFromThreads )
  {
    processes = (HANDLE *)AllocatePool(4096i64);
    if ( processes )
    {
      list = CreateUniqueList(1);
      if ( list )
      {
        processFromThreadCount = Get512RunningProcessesFromThreads(processesFromThreads);
        processFromThreadCount0 = processFromThreadCount;
        if ( processFromThreadCount )
        {
          processCount = GetRunningProcesses(processes, 512u, 0i64, 0i64);
          if ( processCount )
          {
            if ( (_DWORD)processFromThreadCount0 != 512 && processCount != 512 )
            {
              processIndex = 0;
              if ( processCount )
              {
                currentProcess = (__int64 *)processes;
                while ( AddListEntry((__int64)list, *currentProcess, 0i64, 0) )
                {
                  ++processIndex;
                  ++currentProcess;
                  if ( processIndex >= processCount )
                    goto LABEL_12;
                }
              }
              else
              {
LABEL_12:
                processFromThreadIndex = 0i64;
                if ( (_DWORD)processFromThreadCount0 )
                {
                  currentProcessFromThread = processesFromThreads;
                  while ( 1 )
                  {
                    pid = import_PsGetProcessId ? import_PsGetProcessId(*currentProcessFromThread) : 0i64;
                    status = import_PsLookupProcessByProcessId ? (unsigned int)import_PsLookupProcessByProcessId(
                                                                                 pid,
                                                                                 &processObject) : 0xC0000002;
                    if ( status < 0 )
                      break;
                    ObfDereferenceObject(processObject);
                    if ( !IsEntryPresentInList((__int64)list, pid) )
                      break;
                    processFromThreadIndex = (unsigned int)(processFromThreadIndex + 1);
                    ++currentProcessFromThread;
                    if ( (unsigned int)processFromThreadIndex >= (unsigned int)processFromThreadCount0 )
                      goto LABEL_38;
                  }
                  hiddenProcess = processesFromThreads[processFromThreadIndex];
                  if ( hiddenProcess )
                  {
                    processCount = GetRunningProcesses(processes, 0x200u, 0i64, 0i64);
                    if ( processCount )
                    {
                      if ( import_PsGetProcessId )
                        hiddenProcessId = import_PsGetProcessId(hiddenProcess);
                      else
                        hiddenProcessId = 0i64;
                      processIndex = 0;
                      if ( processCount )
                      {
                        v17 = processes;
                        while ( *v17 != (HANDLE)hiddenProcessId )
                        {
                          ++processIndex;
                          ++v17;
                          if ( processIndex >= processCount )
                            goto LABEL_35;
                        }
                        hiddenProcess = 0i64;
                      }
LABEL_35:
                      if ( hiddenProcess )
                        IsProcessExiting(hiddenProcess);
                    }
                    else
                    {
                      hiddenProcess = 0i64;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_38:
        FreeList(list);
      }
      else
      {
        processFromThreadCount0 = (unsigned int)processObject;
      }
      FreePool((__int64)processes);
    }
    else
    {
      processFromThreadCount0 = (unsigned int)processObject;
    }
    if ( (_DWORD)processFromThreadCount0 )
    {
      v18 = (PVOID *)processesFromThreads;
      do
      {
        if ( *v18 != (PVOID)hiddenProcess )
          ObfDereferenceObject(*v18);
        ++v18;
        --processFromThreadCount0;
      }
      while ( processFromThreadCount0 );
    }
    FreePool((__int64)processesFromThreads);
  }
  return hiddenProcess;
}

__int64 __fastcall Get512RunningProcessesFromThreads(__int64 *buffer)
{
  unsigned int processCount; // edi
  unsigned __int64 currentTID; // rbx
  __int64 list; // rsi
  signed int v5; // eax
  __int64 process; // r12
  PVOID threadObject; // [rsp+40h] [rbp+8h]

  processCount = 0;
  currentTID = 4i64;
  if ( buffer )
  {
    if ( GetThreadProcess(__readgsqword(0x188u)) )
    {
      list = (__int64)CreateUniqueList(1);
      if ( list )
      {
        do
        {
          if ( processCount >= 512 )
            break;
          if ( import_PsLookupThreadByThreadId )
            v5 = import_PsLookupThreadByThreadId(currentTID, &threadObject);
          else
            v5 = 0xC0000002;
          if ( v5 >= 0 )
          {
            process = GetThreadProcess((__int64)threadObject);
            if ( !IsEntryPresentInList(list, process) )
            {
              import_ObfReferenceObject(process);
              *buffer = process;
              ++processCount;
              ++buffer;
              AddListEntry(list, process, 0i64, 0);
            }
            ObfDereferenceObject(threadObject);
          }
          currentTID += 4i64;
        }
        while ( currentTID < 0x3000 );
        FreeList((PVOID)list);
      }
    }
  }
  return processCount;
}

__int64 __fastcall GetRunningProcesses(HANDLE *outProcesses, unsigned int maxCount, unsigned __int8 (__fastcall *callback)(__int64, __int64), __int64 a4)
{
  unsigned int v4; // edi
  SYSTEM_PROCESS_INFO *processInformation; // rax MAPDST
  SYSTEM_PROCESS_INFO *entry; // rbx
  __int64 pid; // rcx

  v4 = 0;
  if ( !outProcesses || !maxCount )
    return 0i64;
  processInformation = (SYSTEM_PROCESS_INFO *)QuerySystemInformation_0(
                                                5u,
                                                (unsigned __int64)qword_80000,
                                                0x1000000u,
                                                0i64,
                                                a4);
  if ( processInformation )
  {
    entry = processInformation;
    if ( maxCount )
    {
      do
      {
        pid = (__int64)entry->UniqueProcessId;
        if ( pid && (!callback || callback(pid, a4)) )
        {
          ++v4;
          *outProcesses = entry->UniqueProcessId;
          ++outProcesses;
        }
        if ( !entry->NextEntryOffset )
          break;
        entry = (SYSTEM_PROCESS_INFO *)((char *)entry + entry->NextEntryOffset);
      }
      while ( v4 < maxCount );
    }
    FreePool((__int64)processInformation);
  }
  return v4;
}
```

`EasyAntiCheat.sys/hwid.c`:

```c
char __fastcall HWID_HashProcessorFeatures(__int64 a1)
{
  __int64 v1; // rbx
  char *v3; // r11
  char *v4; // r8
  unsigned int v5; // edx
  _WORD *v6; // rcx
  char buffer[64]; // [rsp+20h] [rbp-A8h]

  v1 = a1;
  buffer[0] = 0;
  *(_QWORD *)&buffer[1] = 0i64;
  *(_QWORD *)&buffer[9] = 0i64;
  *(_WORD *)&buffer[17] = 0;
  buffer[19] = 0;
  *(_WORD *)&buffer[32] = 0;
  memset(&buffer[34], 0, 0x7Eui64);
  if ( !v1 )
    return 0;
  HashSHA(0xFFFFF78000000274i64, 0x40u, (DATA_HASH_BUFFER *)buffer);// ProcessorFeatures
  v3 = buffer;
  v4 = &buffer[34];
  v5 = 1;
  do
  {
    if ( v5 >= 0x40 )
      break;
    v5 += 2;
    v6 = (_WORD *)qword_4A230[(unsigned __int8)*v3++];
    *((_WORD *)v4 - 1) = *v6;
    *(_WORD *)v4 = v6[1];
    v4 += 4;
  }
  while ( v5 < 0x29 );
  return CreateUnicodeStringFromPWSTR(v1, &buffer[32]);
}

__int64 __fastcall HWID_GetScannedRegistryKeyName(unsigned int id)
{
  unsigned int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  unsigned int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  unsigned int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  unsigned int v13; // ecx
  int v14; // ecx
  int v15; // ecx

  if ( id <= 0xC )
  {
    if ( id == 12 )
      return StringTable + 3117;                // \Registry\Machine\Hardware\Description\System\CentralProcessor\0
    if ( id > 6 )
    {
      v6 = id - 8;
      if ( !v6 )
        return StringTable + 2843;              // SystemProductName
      v7 = v6 - 1;
      if ( !v7 )
        return StringTable + 2879;              // \Registry\Machine\Hardware\DeviceMap\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0
      v8 = v7 - 1;
      if ( !v8 )
        return StringTable + 3069;              // Identifier
      if ( v8 == 1 )
        return StringTable + 3091;              // SerialNumber
    }
    else
    {
      if ( id == 6 )
        return StringTable + 2805;              // SystemManufacturer
      v1 = id - 1;
      if ( !v1 )
        return StringTable + 2473;              // \Registry\Machine\System\CurrentControlSet\Control\SystemInformation
      v2 = v1 - 1;
      if ( !v2 )
        return StringTable + 2611;              // ComputerHardwareId
      v3 = v2 - 1;
      if ( !v3 )
        return StringTable + 2649;              // \Registry\Machine\Hardware\Description\System\BIOS
      v4 = v3 - 1;
      if ( !v4 )
        return StringTable + 2751;              // BIOSVendor
      if ( v4 == 1 )
        return StringTable + 2773;              // BIOSReleaseDate
    }
    return 0i64;
  }
  if ( id <= 0x12 )
  {
    if ( id == 18 )
      return StringTable + 3661;                // ProductId
    v9 = id - 13;
    if ( !v9 )
      return StringTable + 3247;                // ProcessorNameString
    v10 = v9 - 1;
    if ( !v10 )
      return StringTable + 3287;                // \Registry\Machine\System\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000
    v11 = v10 - 1;
    if ( v11 )
    {
      v12 = v11 - 1;
      if ( !v12 )
        return StringTable + 3511;              // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
      if ( v12 == 1 )
        return StringTable + 3637;              // InstallDate
      return 0i64;
    }
    return StringTable + 3489;                  // DriverDesc
  }
  v13 = id - 19;
  if ( !v13 )
    return StringTable + 3681;                  // \Registry\Machine\Software\Microsoft\Windows\CurrentVersion\WindowsUpdate
  v14 = v13 - 1;
  if ( !v14 )
    return StringTable + 3829;                  // SusClientId
  v15 = v14 - 1;
  if ( v15 )
  {
    if ( v15 != 1 )
      return 0i64;
    return StringTable + 3489;
  }
  return StringTable + 3853;                    // \Registry\Machine\System\CurrentControlSet\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}\0001
}

char __fastcall QueryWMIData(const __m128i *guid0, __int64 *outBuffer)
{
  char status; // bl
  _IMAGE_DOS_HEADER *IoWMIOpenBlock; // rdi
  __int64 v7; // rax
  __int128 guid1; // [rsp+20h] [rbp-28h]
  __int64 v1; // [rsp+58h] [rbp+10h]
  PVOID dataBlockObject; // [rsp+60h] [rbp+18h]

  status = 0;
  if ( !outBuffer )
    return 0;
  IoWMIOpenBlock = (_IMAGE_DOS_HEADER *)import_IoWMIOpenBlock;
  if ( !import_IoWMIOpenBlock )
  {
    IoWMIOpenBlock = FindExport((DATA_HASH_BUFFER *)&unk_46BE0);
    import_IoWMIOpenBlock = (__int64)IoWMIOpenBlock;
    if ( !IoWMIOpenBlock )
      return 0;
  }
  if ( !import_IoWMIQueryAllData )
  {
    import_IoWMIQueryAllData = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))FindExport((DATA_HASH_BUFFER *)&unk_46BF8);
    if ( !import_IoWMIQueryAllData )
      return 0;
  }
  _mm_storeu_si128((__m128i *)&guid1, _mm_loadu_si128(guid0));
  if ( ((__int64 (__fastcall *)(__int128 *, signed __int64, PVOID *))IoWMIOpenBlock)(&guid1, 1i64, &dataBlockObject) >= 0 )
  {
    LODWORD(v1) = 0;
    if ( (unsigned int)import_IoWMIQueryAllData(dataBlockObject, &v1, 0i64) == 0xC0000023 )
    {
      v7 = AllocatePool((unsigned int)v1);
      *outBuffer = v7;
      if ( v7 )
      {
        if ( (signed int)import_IoWMIQueryAllData(dataBlockObject, &v1, v7) < 0 )
          FreePool(*outBuffer);
        else
          status = 1;
      }
    }
    ObfDereferenceObject(dataBlockObject);
  }
  return status;
}

__int64 __usercall GetMachineId@<rax>(__int64 a1@<rcx>, signed int a2@<r14d>)
{
  unsigned int v2; // ebx
  DATA_HASH_BUFFER *v3; // rdi
  char v4; // al
  unsigned __int16 v6; // [rsp+20h] [rbp-18h]
  __int64 v7; // [rsp+28h] [rbp-10h]

  v2 = 0;
  v3 = (DATA_HASH_BUFFER *)a1;
  if ( a1 )
  {
    if ( StringTable == 4294963241 )
      v4 = 0;
    else                                        // MachineId
      v4 = ReadRegistryUnicodeString(StringTable + 4281, (_WORD *)(StringTable + 4055), (__int64)&v6, a2);//  \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion\Windows Activation Technologies\AdminObject\Store
    if ( v4 )
    {
      HashSHA(v7, v6, v3);
      v2 = 20;
      FreeUnicodeString(&v6);
    }
  }
  return v2;
}

char __usercall GetNtoskrnlProductVersion@<al>(UNICODE_STRING *outProductVersion@<rcx>, signed int a2@<r14d>)
{
  char v3; // di
  __int64 resourceAddr; // [rsp+20h] [rbp-28h]
  UNICODE_STRING path; // [rsp+28h] [rbp-20h]
  unsigned int size; // [rsp+58h] [rbp+10h]
  __int64 buffer; // [rsp+60h] [rbp+18h]
  _IMAGE_NT_HEADERS64 *a4; // [rsp+68h] [rbp+20h]

  v3 = 0;
  if ( GetNtoskrnlPath(&path, a2) )
  {
    if ( ReadFileW(&path, &buffer, &size) )
    {
      if ( ValidatePeHeader((_IMAGE_DOS_HEADER *)buffer, size, 0i64, &a4)
        && GetResourceSection(a4, buffer, &resourceAddr, &size) )
      {
        v3 = GetProductVersionFromResource(resourceAddr, size, outProductVersion);
      }
      if ( buffer )
        FreePool(buffer);
    }
    FreeUnicodeString(&path);
  }
  return v3;
}
```

`EasyAntiCheat.sys/kernelpatch.c`:

```c
void __usercall CheckForKernelPatches(__int64 a1@<rcx>, __int64 a2@<rdx>, signed int a3@<r14d>)
{
  signed int v5; // ebx
  _IMAGE_DOS_HEADER *ntoskrnlBase; // rbp
  int v7; // ebx
  signed int v8; // ebx
  bool v9; // sf
  unsigned int v10; // eax
  char v11; // [rsp+30h] [rbp-58h]
  __int64 v12; // [rsp+38h] [rbp-50h]
  _IMAGE_NT_HEADERS64 *v13; // [rsp+40h] [rbp-48h]
  _IMAGE_NT_HEADERS64 *a4; // [rsp+48h] [rbp-40h]
  UNICODE_STRING ntoskrnlPath; // [rsp+50h] [rbp-38h]
  char v16; // [rsp+60h] [rbp-28h]
  __int64 v17; // [rsp+68h] [rbp-20h]
  unsigned __int64 fileLength; // [rsp+A0h] [rbp+18h]
  _IMAGE_DOS_HEADER *fileBuffer; // [rsp+A8h] [rbp+20h]

  v5 = 2;
  ntoskrnlBase = (_IMAGE_DOS_HEADER *)GetNtoskrnlBase();
  if ( ntoskrnlBase && GetNtoskrnlPath(&ntoskrnlPath, a3) )
  {
    if ( (MEMORY[0xFFFFF7800000026C] > 6u
       || MEMORY[0xFFFFF7800000026C] == 6 && (MEMORY[0xFFFFF78000000270] == 2 || MEMORY[0xFFFFF78000000270] == 3))
      && CompareUnicodeStrings((__int64)&ntoskrnlPath, (_WORD *)(StringTable + 4752)) )// \SystemRoot\system32\ntoskrnl.exe
    {
      v5 = 1;
    }
    else if ( ReadFileW(&ntoskrnlPath, (__int64 *)&fileBuffer, (ULONG *)&fileLength) )
    {
      if ( (unsigned int)fileLength >= 0x1000 )
        v5 = !ValidatePeHeader(ntoskrnlBase, 0x1000ui64, &fileLength, &v13)
          || !ValidatePeHeader(fileBuffer, 0x1000ui64, &fileLength, &a4)
          || v13->FileHeader.NumberOfSections != a4->FileHeader.NumberOfSections
          || v13->FileHeader.TimeDateStamp != a4->FileHeader.TimeDateStamp
          || v13->OptionalHeader.AddressOfEntryPoint != a4->OptionalHeader.AddressOfEntryPoint
          || v13->OptionalHeader.CheckSum != a4->OptionalHeader.CheckSum
          || v13->OptionalHeader.SizeOfImage != a4->OptionalHeader.SizeOfImage;
      if ( fileBuffer )
        FreePool((__int64)fileBuffer);
    }
    FreeUnicodeString(&ntoskrnlPath);
  }
  v7 = v5 - 1;
  if ( !v7 )
  {
    v8 = -1073610745;
    goto LABEL_47;
  }
  if ( v7 == 1 )
  {
    v8 = -1073610744;
LABEL_47:
    sub_33230(a2, (unsigned int)v8);
    return;
  }
  v8 = 0;
  v9 = MEMORY[0xFFFFF7800000026C] - 6 < 0;
  if ( MEMORY[0xFFFFF7800000026C] > 6u
    || MEMORY[0xFFFFF7800000026C] == 6
    && (MEMORY[0xFFFFF78000000270] == 2 || (v9 = MEMORY[0xFFFFF78000000270] - 3 < 0, MEMORY[0xFFFFF78000000270] == 3)) )
  {
    if ( GetBCDData((_UNICODE_STRING *)&v16, (UNICODE_STRING *)&v11, a3) )
    {
      if ( v12 )
      {
        if ( CompareUnicodeStrings((__int64)&v11, (_WORD *)(StringTable + 1003))// \Windows\system32\winload.exe
          && CompareUnicodeStrings((__int64)&v11, (_WORD *)(StringTable + 1063)) )// \Windows\system32\winload.efi
        {
          v8 = 0xC0020010;
        }
        FreeUnicodeString(&v11);
      }
      if ( v17 )
      {
        if ( CompareUnicodeStrings((__int64)&v16, (_WORD *)(StringTable + 1123)) )// ntoskrnl.exe
          v8 = 0xC0020011;
        FreeUnicodeString(&v16);
      }
    }
    else
    {
      sub_3329C(a2, 81i64, 0i64);
    }
    v9 = v8 < 0;
    if ( v8 )
      goto LABEL_47;
  }
  sub_25ECC(a2, 1073807366i64, v9);
  v10 = sub_13F3C(a1, a2);
  if ( v10 == 0x40031000 )
    sub_25BF4(0x40031000, a2, a3);
  else
    sub_33230(a2, v10);
  qword_4E0D0 = 0i64;
  qword_4E0D8 = 0i64;
  qword_4E0E0 = 0i64;
  qword_4E0E8 = 0i64;
}

char __usercall GetBCDData@<al>(_UNICODE_STRING *a1@<rdx>, UNICODE_STRING *a2@<rcx>, signed int a3@<r14d>)
{
  char v3; // di
  _UNICODE_STRING *v4; // rsi
  UNICODE_STRING *v5; // rbp
  __int64 globalDataTable; // rbx
  __int64 v7; // rdx
  unsigned __int16 v9; // [rsp+20h] [rbp-128h]
  void *Src; // [rsp+28h] [rbp-120h]
  __m128i v11; // [rsp+30h] [rbp-118h]
  char Dst; // [rsp+40h] [rbp-108h]
  char v13; // [rsp+8Ch] [rbp-BCh]
  __int128 v14; // [rsp+ECh] [rbp-5Ch]
  __int16 v15; // [rsp+FCh] [rbp-4Ch]

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( !a2 || !a1 )
    return 0;
  *(_QWORD *)&a2->Length = 0i64;
  a2->Buffer = 0i64;
  *(_QWORD *)&a1->Length = 0i64;
  a1->Buffer = 0i64;
  if ( QuerySystemBootEnvironmentInformation(&v11, a3) && sub_12080((unsigned __int8 *)&v11, (__int64)&v9) )
  {
    globalDataTable = StringTable;
    v15 = 0;
    memmove(&Dst, (const void *)(StringTable + 188), 0xBCui64);// \Registry\Machine\BCD00000000\Objects\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\Elements\xxxxxxxx
    memmove(&v13, Src, v9);
    _mm_storeu_si128((__m128i *)&v14, _mm_loadu_si128((const __m128i *)(globalDataTable + 378)));
    ReadRegistryUnicodeString(globalDataTable + 396, &Dst, (__int64)v5, a3);
    v7 = StringTable + 396;
    _mm_storeu_si128((__m128i *)&v14, _mm_loadu_si128((const __m128i *)(StringTable + 412)));
    ReadRegistryUnicodeString(v7, &Dst, (__int64)v4, a3);
    FreeUnicodeString(&v9);
  }
  if ( v5->Buffer || v4->Buffer )
    v3 = 1;
  return v3;
}
```

`EasyAntiCheat.sys/mac.c`:

```c
char __fastcall HWID_GetMacAddress(int a1, __int64 a2)
{
  char v2; // bl
  char v6; // [rsp+30h] [rbp-18h]

  v2 = 0;
  v6 = 0;
  if ( !a2 || a1 != 6 )
    return 0;
  if ( GetFirstNetworkDeviceMacAddress((__int64)&GUID_DEVINTERFACE_NET, (HWIDBuffer *)&a1) )
  {
    if ( v6 )
      v2 = 1;
  }
  return v2;
}

char __fastcall GetFirstNetworkDeviceMacAddress(__int64 deviceGuid, HWIDBuffer *hwidBuffer)
{
  char notFound; // bl
  __int64 index; // r12 MAPDST
  signed int status; // eax
  _WORD *it; // rbp MAPDST
  signed __int64 invertedSize; // rcx MAPDST
  _WORD *tempIt; // rdi MAPDST
  bool isNull; // zf
  char v20; // dl
  UNICODE_STRING symbolicLink; // [rsp+20h] [rbp-38h]
  PVOID symbolicLinks; // [rsp+70h] [rbp+18h]

  notFound = 1;
  index = 0i64;
  if ( !GetAdapterMacAddressWrapper || KeGetCurrentIrql() )
    return 0;
  status = import_IoGetDeviceInterfaces ? (unsigned int)import_IoGetDeviceInterfaces(
                                                          deviceGuid,
                                                          0i64,
                                                          0i64,
                                                          &symbolicLinks) : 0xC0000002;
  if ( status < 0 )
    return 0;
  do
  {
    it = (char *)symbolicLinks + 2 * index;
    if ( !*it )
      break;
    invertedSize = -1i64;
    tempIt = (char *)symbolicLinks + 2 * index;
    do
    {
      if ( !invertedSize )
        break;
      isNull = *tempIt == 0;
      ++tempIt;
      --invertedSize;
    }
    while ( !isNull );
    if ( strstrIgnoreCaseW((_WORD *)symbolicLinks + index, (unsigned __int16 *)(StringTable + 828), ~invertedSize - 1) != it )// \??\PCI
      goto LABEL_16;
    InitializeUnicodeStringWithCStr(&symbolicLink, it);
    if ( !hwidBuffer )
      goto LABEL_15;
    if ( GetAdapterMacAddress(hwidBuffer->hwidType, &symbolicLink, hwidBuffer->uniqueIdentifier) == 1 )
    {
      hwidBuffer->found = 1;
LABEL_15:
      notFound = 0;
      goto LABEL_16;
    }
    notFound = 1;
LABEL_16:
    invertedSize = -1i64;
    tempIt = (char *)symbolicLinks + 2 * index;
    do
    {
      if ( !invertedSize )
        break;
      isNull = *tempIt == 0;
      ++tempIt;
      --invertedSize;
    }
    while ( !isNull );
    index += ~invertedSize;
  }
  while ( notFound );
  for ( index = 0i64; notFound; index += ~invertedSize )
  {
    it = (char *)symbolicLinks + 2 * index;
    if ( !*it )
      break;
    invertedSize = -1i64;
    tempIt = (char *)symbolicLinks + 2 * index;
    do
    {
      if ( !invertedSize )
        break;
      isNull = *tempIt == 0;
      ++tempIt;
      --invertedSize;
    }
    while ( !isNull );
    if ( strstrIgnoreCaseW((_WORD *)symbolicLinks + index, (unsigned __int16 *)(StringTable + 844), ~invertedSize - 1) == it )// \??\USB
    {
      InitializeUnicodeStringWithCStr(&symbolicLink, it);
      if ( hwidBuffer )
      {
        if ( GetAdapterMacAddress(hwidBuffer->hwidType, &symbolicLink, hwidBuffer->uniqueIdentifier) != 1 )
        {
          notFound = 1;
          goto LABEL_31;
        }
        hwidBuffer->found = 1;
      }
      notFound = 0;
    }
LABEL_31:
    invertedSize = -1i64;
    tempIt = (char *)symbolicLinks + 2 * index;
    do
    {
      if ( !invertedSize )
        break;
      isNull = *tempIt == 0;
      ++tempIt;
      --invertedSize;
    }
    while ( !isNull );
  }
  index = 0i64;
  if ( notFound )
  {
    while ( 1 )
    {
      it = (char *)symbolicLinks + 2 * index;
      if ( !*it )
        goto LABEL_46;
      InitializeUnicodeStringWithCStr(&symbolicLink, it);
      if ( !hwidBuffer )
        goto LABEL_41;
      if ( GetAdapterMacAddress(hwidBuffer->hwidType, &symbolicLink, hwidBuffer->uniqueIdentifier) == 1 )
        break;
      v20 = 1;
LABEL_42:
      invertedSize = -1i64;
      tempIt = (char *)symbolicLinks + 2 * index;
      do
      {
        if ( !invertedSize )
          break;
        isNull = *tempIt == 0;
        ++tempIt;
        --invertedSize;
      }
      while ( !isNull );
      index += ~invertedSize;
      if ( !v20 )
        goto LABEL_46;
    }
    hwidBuffer->found = 1;
LABEL_41:
    v20 = 0;
    goto LABEL_42;
  }
LABEL_46:
  ExFreePoolWithTag(symbolicLinks, 0);
  return 1;
}

char __fastcall GetAdapterMacAddress(__int64 a1, UNICODE_STRING *deviceName, UNICODE_STRING *outMacAddress)
{
  char result; // al
  char status1; // r13
  int macCrc32; // ebp
  __int64 v8; // rbx
  char v10; // r12
  signed int status; // edi
  int *v12; // rax
  int v13; // ecx
  int *v14; // rax
  int v15; // ecx
  int *v16; // rax
  int v17; // ecx
  int *v18; // rax
  int v19; // ecx
  int *v20; // rax
  int v21; // ecx
  int *v22; // rax
  char *addrNtDeviceIoControlFile; // rax MAPDST
  int v24; // edi MAPDST
  char checksPassed; // si
  int status0; // eax
  int *v29; // rax
  int v30; // ecx
  int *v31; // rax
  int v32; // ecx
  int *v33; // rax
  int v34; // ecx
  int *v35; // rax
  int v36; // ecx
  int *v37; // rax
  int v38; // ecx
  int *v39; // rax
  __int64 ioctl; // [rsp+28h] [rbp-100h]
  __int64 inputSize; // [rsp+38h] [rbp-F0h]
  __int64 inputSize2; // [rsp+40h] [rbp-E8h]
  PVOID outputSize; // [rsp+48h] [rbp-E0h]
  unsigned __int8 macAddress[6]; // [rsp+60h] [rbp-C8h]
  HANDLE fileHandle; // [rsp+68h] [rbp-C0h] MAPDST
  int v46; // [rsp+70h] [rbp-B8h]
  __int16 v47; // [rsp+74h] [rbp-B4h]
  int v48; // [rsp+76h] [rbp-B2h]
  __int16 v49; // [rsp+7Ah] [rbp-AEh]
  int v50; // [rsp+7Ch] [rbp-ACh]
  __int16 v51; // [rsp+80h] [rbp-A8h]
  int v52; // [rsp+82h] [rbp-A6h]
  __int16 v53; // [rsp+86h] [rbp-A2h]
  int v54; // [rsp+88h] [rbp-A0h]
  __int16 v55; // [rsp+8Ch] [rbp-9Ch]
  int v56; // [rsp+8Eh] [rbp-9Ah]
  __int16 v57; // [rsp+92h] [rbp-96h]
  __int64 outValue; // [rsp+B0h] [rbp-78h]
  __int64 addedBytes; // [rsp+B8h] [rbp-70h] MAPDST
  struct _IO_STATUS_BLOCK statusBlock; // [rsp+C0h] [rbp-68h]
  OBJECT_ATTRIBUTES objectAttributes; // [rsp+D0h] [rbp-58h]
  int objectId; // [rsp+138h] [rbp+10h]

  result = 0;
  objectId = 0x1010101;                         // OID_802_3_PERMANENT_ADDRESS
  status1 = 0;
  macAddress[0] = 0;
  *(_DWORD *)&macAddress[1] = 0;
  macAddress[5] = 0;
  macCrc32 = 0;
  if ( deviceName
    && deviceName->Buffer
    && deviceName->Length
    && deviceName->MaximumLength
    && outMacAddress
    && (_DWORD)a1 == 6 )
  {
    if ( !KeGetCurrentIrql() && !(unsigned __int8)import_KeAreAllApcsDisabled(a1) )
    {
      objectAttributes.Length = 48;
      objectAttributes.RootDirectory = 0i64;
      objectAttributes.Attributes = 512;
      objectAttributes.ObjectName = deviceName;
      objectAttributes.SecurityDescriptor = 0i64;
      objectAttributes.SecurityQualityOfService = 0i64;
      if ( ZwCreateFile(&fileHandle, 0x120089u, &objectAttributes, &statusBlock, 0i64, 0x80u, 7u, 1u, 0x20u, 0i64, 0) < 0 )
        return status1;
      v8 = __readgsqword(0x188u);
      v10 = GetPreviousMode(v8, 0);
      SetPreviousMode(0, v8, 0);
      if ( import_NtDeviceIoControlFile )
      {
        LODWORD(outputSize) = 6;
        LODWORD(inputSize) = 4;
        LODWORD(ioctl) = 0x170002;              // IOCTL_NDIS_QUERY_GLOBAL_STATS
        status = import_NtDeviceIoControlFile(
                   fileHandle,
                   0i64,
                   0i64,
                   0i64,
                   &statusBlock,
                   ioctl,
                   &objectId,
                   inputSize,
                   macAddress,
                   outputSize);
      }
      else
      {
        status = 0xC0000002;
      }
      SetPreviousMode(v10, v8, 0);
      if ( status >= 0 )
      {
        v12 = (int *)qword_4A230[macAddress[0]];
        v47 = '-';
        v49 = '-';
        v13 = *v12;
        v51 = '-';
        v14 = (int *)qword_4A230[macAddress[1]];
        v46 = v13;
        v53 = '-';
        v15 = *v14;
        v55 = '-';
        v16 = (int *)qword_4A230[macAddress[2]];
        v48 = v15;
        v57 = 0;
        v17 = *v16;
        v18 = (int *)qword_4A230[macAddress[3]];
        v50 = v17;
        v19 = *v18;
        v20 = (int *)qword_4A230[macAddress[4]];
        v52 = v19;
        v21 = *v20;
        v22 = (int *)qword_4A230[macAddress[5]];
        v54 = v21;
        v56 = *v22;
        status1 = CreateUnicodeStringFromPWSTR((__int64)outMacAddress, &v46);
        if ( status1 )
        {
          addrNtDeviceIoControlFile = (char *)GetNtDeviceIoControlFileAddress();
          v24 = sub_1705C(addrNtDeviceIoControlFile, 0x10i64, &addedBytes);
          if ( v24 && addedBytes )
          {
            checksPassed = 0;
            addrNtDeviceIoControlFile = (char *)GetNtDeviceIoControlFileAddress();
            if ( addrNtDeviceIoControlFile )
            {
              if ( v24 == 0x1290373
                && (unsigned int)sub_1705C((char *)CallNtDeviceIoControlFilePlus10, addedBytes, &outValue) == 0x1290373
                && outValue == addedBytes )
              {
                checksPassed = 1;
                NtDeviceIoControlFilePlus10 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))&addrNtDeviceIoControlFile[addedBytes];
              }
            }
            else
            {
              checksPassed = 0;
            }
            if ( checksPassed )
            {
              if ( v24 != 0x1290373 )
              {
                if ( !byte_4D8AB )
                {
                  SendPacketToServer(353i64, (__int64)&v24, 4i64);
                  byte_4D8AB = 1;
                }
                goto LABEL_37;
              }
              macCrc32 = HashCRC32((char *)macAddress, 6u, 0);
              LODWORD(inputSize2) = 4;
              status0 = CallNtDeviceIoControlFilePlus10_KernelMode(
                          (__int64)fileHandle,
                          0,
                          0,
                          (__int64)&statusBlock,
                          0x170002,
                          (unsigned __int64)&objectId,
                          inputSize2,
                          (unsigned __int64)macAddress);
              goto LABEL_30;
            }
          }
          if ( !byte_4D8AA )
          {
            SendPacketToServer(352i64, 0i64, 0i64);
            status0 = objectId;
            byte_4D8AA = 1;
LABEL_30:
            if ( macCrc32 )
            {
              if ( status0 >= 0 )
              {
                if ( macCrc32 != (unsigned int)HashCRC32((char *)macAddress, 6u, 0) && !byte_4DA64 )
                {
                  v29 = (int *)qword_4A230[macAddress[0]];
                  v47 = 45;
                  v30 = *v29;
                  v49 = 45;
                  v31 = (int *)qword_4A230[macAddress[1]];
                  v46 = v30;
                  v51 = 45;
                  v32 = *v31;
                  v53 = 45;
                  v33 = (int *)qword_4A230[macAddress[2]];
                  v48 = v32;
                  v55 = 45;
                  v34 = *v33;
                  v35 = (int *)qword_4A230[macAddress[3]];
                  v50 = v34;
                  v57 = 0;
                  v36 = *v35;
                  v37 = (int *)qword_4A230[macAddress[4]];
                  v52 = v36;
                  v38 = *v37;
                  v39 = (int *)qword_4A230[macAddress[5]];
                  v54 = v38;
                  v56 = *v39;
                  SendPacketToServer(354i64, (__int64)&v46, 64i64);
                  byte_4DA64 = 1;
                }
              }
              else if ( !byte_4DA65 )
              {
                SendPacketToServer(355i64, (__int64)&v24, 4i64);
                byte_4DA65 = 1;
              }
            }
            goto LABEL_37;
          }
        }
      }
LABEL_37:
      CloseHandle((__int64)fileHandle, 0);
      return status1;
    }
    result = 0;
  }
  return result;
}
```

`EasyAntiCheat.sys/physmem.c`:

```c
bool __fastcall CheckForPhysicalHandle(_DWORD *a1)
{
  SYSTEM_HANDLE_INFORMATION *systemHandleInformation; // r12
  signed int v4; // er11
  PVOID v5; // rax
  unsigned __int64 index; // rbp
  PVOID sectionObjectType; // rcx
  char v8; // r13
  SYSTEM_HANDLE_TABLE_ENTRY_INFO *entry; // rsi
  char v10; // si
  char v11; // r13
  _UNICODE_STRING *v12; // rdx
  char v13; // al
  UNICODE_STRING v14; // [rsp+30h] [rbp-88h]
  UNICODE_STRING a1a; // [rsp+40h] [rbp-78h]
  char v16; // [rsp+50h] [rbp-68h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+60h] [rbp-58h]
  HANDLE SectionHandle; // [rsp+C0h] [rbp+8h]

  if ( !a1 )
    return 0;
  memset(a1, 0, 0x20ui64);
  if ( !import_ObIsKernelHandle || _InterlockedCompareExchange(&dword_4D8B0, 1, 0) )
    return 0;
  systemHandleInformation = (SYSTEM_HANDLE_INFORMATION *)QuerySystemInformation_0(
                                                           0x10u,
                                                           (unsigned __int64)qword_80000,
                                                           0x1000000u,
                                                           0i64,
                                                           1);
  if ( !systemHandleInformation )
    goto LABEL_43;
  InitializeUnicodeStringWithCStr(&a1a, (_WORD *)(StringTable + 7061));// \Device\PhysicalMemory
  ObjectAttributes.ObjectName = &a1a;
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;
  if ( ZwOpenSection(&SectionHandle, 1u, &ObjectAttributes) >= 0 )
  {
    if ( import_ObReferenceObjectByHandle )
      v4 = import_ObReferenceObjectByHandle(SectionHandle, 1i64, 0i64);
    else
      v4 = 0xC0000002;
    v5 = SectionObjectType;
    if ( v4 < 0 )
      v5 = 0i64;
    SectionObjectType = v5;
    ZwClose(SectionHandle);
  }
  index = 0i64;
  if ( systemHandleInformation->Count <= 0 )
    goto LABEL_39;
  sectionObjectType = SectionObjectType;
  v8 = 0;
  entry = systemHandleInformation->Info;
  while ( 1 )
  {
    if ( entry->Object != sectionObjectType || !sectionObjectType || entry->ProcessId == 4 )
      goto LABEL_20;
    if ( !(unsigned __int8)import_ObIsKernelHandle(entry->Handle) )
      break;
    sectionObjectType = SectionObjectType;
LABEL_20:
    ++index;
    ++entry;
    if ( index >= systemHandleInformation->Count )
      goto LABEL_40;
  }
  if ( entry->ProcessId )
    v10 = GetProcessImageFileName(&v14, entry->ProcessId, 1);
  else
    v10 = 0;
  if ( v10 )
    v8 = sub_289F0(&v14.Length, (__int64)&v16);
  v11 = -v8;
  v12 = (_UNICODE_STRING *)((unsigned __int64)&v16 & -(signed __int64)(v11 != 0));
  if ( !a1[1] )
  {
    *(_BYTE *)a1 = 1;
    a1[1] = 13;
    if ( v12 )
    {
      if ( *(_QWORD *)(((unsigned __int64)&v16 & -(signed __int64)(v11 != 0)) + 8)
        && v12->Length
        && *(_WORD *)(((unsigned __int64)&v16 & -(signed __int64)(v11 != 0)) + 2)
        && !*((_BYTE *)a1 + 8) )
      {
        if ( a1 == (_DWORD *)-16i64 )
          v13 = 0;
        else
          v13 = AllocateCopyUnicodeString((__int64)(a1 + 4), v12);
        *((_BYTE *)a1 + 8) = v13;
      }
    }
  }
  if ( v10 )
    FreeUnicodeString(&v14);
LABEL_39:
  sectionObjectType = SectionObjectType;
LABEL_40:
  if ( sectionObjectType )
  {
    ObfDereferenceObject(sectionObjectType);
    SectionObjectType = 0i64;
  }
  FreePool((__int64)systemHandleInformation);
LABEL_43:
  _InterlockedExchange(&dword_4D8B0, 0);
  return a1[1] != 0;
}
```

`EasyAntiCheat.sys/pooltags.c`:

```c
bool __usercall CheckForBannedPooltags@<al>(signed int a1@<r14d>)
{
  signed int v1; // ebx
  SYSTEM_POOLTAG_INFORMATION *pooltagInformation; // rax
  ULONG v3; // edx
  __int64 entry; // rcx

  v1 = 0;
  pooltagInformation = (SYSTEM_POOLTAG_INFORMATION *)QuerySystemInformation_0(0x16u, 0x10000u, 0x100000u, 0i64, a1);
  if ( pooltagInformation )
  {
    v3 = 0;
    if ( pooltagInformation->Count > 0 )
    {
      entry = (__int64)&pooltagInformation->TagInfo[0].PagedAllocs;
      do
      {
        if ( v1 == 3 )
          break;
        if ( *(_DWORD *)(entry - 4) != 'rcIC' || *(_DWORD *)entry <= *(_DWORD *)(entry + 4) )
        {
          if ( *(_DWORD *)(entry - 4) == 'csIC' && *(_DWORD *)entry > *(_DWORD *)(entry + 4) )
            v1 |= 2u;
        }
        else
        {
          v1 |= 1u;
        }
        ++v3;
        entry += 40i64;
      }
      while ( v3 < pooltagInformation->Count );
    }
    FreePool((__int64)pooltagInformation);
  }
  else
  {
    v1 = 3;
  }
  return v1 == 3;
}
```

`EasyAntiCheat.sys/process.c`:

```c
char __usercall CheckProcess@<al>(__int64 a1@<rdx>, unsigned int *buffer@<rcx>, int a3@<esi>)
{
  __int64 *v4; // rdi
  char result; // al
  char *v6; // rcx
  signed int v7; // eax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v11; // rcx
  char *v12; // r9
  unsigned __int64 v13; // rdx
  _DWORD *v14; // rdx
  char v15; // [rsp+20h] [rbp-48h]
  char v16; // [rsp+30h] [rbp-38h]
  PVOID process; // [rsp+78h] [rbp+10h] MAPDST

  v15 = 0;
  v4 = 0i64;
  if ( !buffer )
    return 0;
  v6 = (char *)buffer + 15;
  if ( v6 < (char *)buffer || (unsigned __int64)v6 >= MmUserProbeAddress )
  {
    ExRaiseAccessViolation(v6, a1);
    result = 0;
  }
  else if ( *buffer && *(_QWORD *)(buffer + 1) && buffer[3] )
  {
    if ( import_PsLookupProcessByProcessId )
      v7 = import_PsLookupProcessByProcessId(*buffer, &process);
    else
      v7 = 0xC0000002;
    if ( v7 >= 0 )
    {
      if ( AttachToProcess((__int64)process, (__int64)&v16) )
      {
        LOBYTE(v9) = 1;
        v4 = (__int64 *)CheckCurrentProcess(v9, v8);
        if ( process )
          DetachFromProcess((__int64)process, (__int64)&v16, (char)v4, a3);
      }
      ObfDereferenceObject(process);
    }
    if ( v4 )
    {
      v11 = buffer[3];
      v12 = *(char **)(buffer + 1);
      if ( buffer[3] )
      {
        v13 = (unsigned __int64)&v12[v11 - 1];
        if ( v13 < (unsigned __int64)v12 || v13 >= MmUserProbeAddress )
          ExRaiseAccessViolation(v11, v13);
      }
      v14 = (_DWORD *)*v4;
      if ( *(_DWORD *)*v4 < (unsigned int)v11 )
        LODWORD(v11) = *v14;
      memmove(v12, v14, (unsigned int)v11);
      v15 = 1;
      sub_20430(v4);
    }
    result = v15;
  }
  else
  {
    result = 0;
  }
  return result;
}

UNK_BUFFER3 *__fastcall CheckCurrentProcess(__int64 a1, __int64 a2)
{
  char v3; // r14 MAPDST
  __int64 currentProcess; // rax MAPDST
  UNK_BUFFER3 *buffer; // rax MAPDST
  _IMAGE_DOS_HEADER *v8; // rax
  _IMAGE_DOS_HEADER *v9; // rax
  unsigned int processFlags; // esi
  _IMAGE_DOS_HEADER *baseAddress; // rbx
  __int64 v12; // rdx
  bool v13; // al
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 currentProcess2; // rax MAPDST
  __int64 currentProcessID2; // rax
  bool v19; // cf
  int v20; // eax
  bool v21; // cf
  int v22; // eax
  bool v23; // cf
  int v24; // eax
  bool v25; // cf
  int v26; // eax
  bool v27; // cf
  int v28; // eax
  __int64 parentPID; // rax
  signed int v30; // eax
  PVOID v31; // rcx
  char v32; // al
  char v33; // al
  UNICODE_STRING *v34; // r13
  __int64 v35; // rdx
  _IMAGE_DOS_HEADER *v36; // rax
  unsigned __int64 v37; // rcx
  unsigned __int16 *v38; // rbx
  int v39; // eax
  unsigned int *v40; // rax
  char filename; // [rsp+50h] [rbp-38h]
  unsigned __int16 v43; // [rsp+58h] [rbp-30h]
  unsigned __int8 v44; // [rsp+5Ah] [rbp-2Eh]
  unsigned __int16 v45; // [rsp+5Ch] [rbp-2Ch]
  unsigned int v46; // [rsp+98h] [rbp+10h]
  PVOID parentProcess; // [rsp+A0h] [rbp+18h]
  __int64 currentProcessID; // [rsp+A8h] [rbp+20h]

  v3 = a1;
  v3 = 0;
  currentProcess = import_PsGetCurrentProcess(a1, a2);
  if ( import_PsGetProcessId )
    currentProcessID = import_PsGetProcessId(currentProcess);
  else
    currentProcessID = 0i64;
  buffer = (UNK_BUFFER3 *)AllocatePool(816i64);
  if ( !buffer )
    goto LABEL_99;
  memset(buffer, 0, 0x330ui64);
  v8 = (_IMAGE_DOS_HEADER *)GetProcessBaseAddress(currentProcess);
  buffer->base_address = v8;
  if ( !v8 )
  {
    v9 = (_IMAGE_DOS_HEADER *)GetUsermodeModule(0i64);
    buffer->base_address = v9;
    if ( !v9 )
      goto LABEL_99;
  }
  if ( IsWin32ConsoleSubsystem(currentProcess) )
  {
    processFlags = 0x8001;
  }
  else if ( HasComDescriptor(buffer->base_address) )
  {
    processFlags = 9;
  }
  else if ( GetUsermodeModule((UNICODE_STRING *)(StringTable + 5202)) )// msvbvm60.dll
  {
    processFlags = 17;
  }
  else
  {
    processFlags = 1;
    if ( GetUsermodeModule((UNICODE_STRING *)(StringTable + 4894)) )// perl512.dll
      processFlags = 4097;
  }
  baseAddress = buffer->base_address;
  v13 = IsDbgUiRemoteBreakinPatchedToCallLdrShutdownProcess() || HasBlankNamedSections((__int64)baseAddress, v12);
  if ( v13 )
    processFlags |= 0x20u;
  if ( IsObufuscatedByVMP((__int64)buffer->base_address, v12) )// check for .vmp0 section
    processFlags |= 0x40u;
  currentProcess2 = import_PsGetCurrentProcess(v15, v14);
  if ( import_PsGetProcessId )
    currentProcessID2 = import_PsGetProcessId(currentProcess2);
  else
    currentProcessID2 = 0i64;
  if ( !IsProtectedGameProcessMaybe(currentProcessID2) && GetProcessFileName(currentProcess2, &filename) )
  {
    v19 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 5148);// dllhost.exe
    if ( *(_QWORD *)&filename != *(_QWORD *)(StringTable + 5148)
      || (v19 = v43 < *(_WORD *)(StringTable + 5156), v43 != *(_WORD *)(StringTable + 5156))
      || (v19 = v44 < *(_BYTE *)(StringTable + 5158), v44 != *(_BYTE *)(StringTable + 5158)) )
    {
      v20 = -v19 - (v19 - 1);
    }
    else
    {
      v20 = 0;
    }
    if ( !v20 )
      goto processname_matched;
    v21 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 4545);// svchost.exe
    if ( *(_QWORD *)&filename != *(_QWORD *)(StringTable + 4545)
      || (v21 = v43 < *(_WORD *)(StringTable + 4553), v43 != *(_WORD *)(StringTable + 4553))
      || (v21 = v44 < *(_BYTE *)(StringTable + 4555), v44 != *(_BYTE *)(StringTable + 4555)) )
    {
      v22 = -v21 - (v21 - 1);
    }
    else
    {
      v22 = 0;
    }
    if ( !v22 )
      goto processname_matched;
    v23 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 5160);// taskhost.exe
    if ( *(_QWORD *)&filename != *(_QWORD *)(StringTable + 5160)
      || (v23 = *(_DWORD *)&v43 < *(_DWORD *)(StringTable + 5168), *(_DWORD *)&v43 != *(_DWORD *)(StringTable + 5168)) )
    {
      v24 = -v23 - (v23 - 1);
    }
    else
    {
      v24 = 0;
    }
    if ( !v24 )
      goto processname_matched;
    v25 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 5173);// taskhostex.exe
    if ( *(_QWORD *)&filename != *(_QWORD *)(StringTable + 5173)
      || (v25 = *(_DWORD *)&v43 < *(_DWORD *)(StringTable + 5181), *(_DWORD *)&v43 != *(_DWORD *)(StringTable + 5181))
      || (v25 = v45 < *(_WORD *)(StringTable + 5185), v45 != *(_WORD *)(StringTable + 5185)) )
    {
      v26 = -v25 - (v25 - 1);
    }
    else
    {
      v26 = 0;
    }
    if ( !v26
      || ((v27 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 5188),
           *(_QWORD *)&filename != *(_QWORD *)(StringTable + 5188))// taskhostw.exe
       || (v27 = *(_DWORD *)&v43 < *(_DWORD *)(StringTable + 5196), *(_DWORD *)&v43 != *(_DWORD *)(StringTable + 5196))
       || (v27 = (unsigned __int8)v45 < *(_BYTE *)(StringTable + 5200), (_BYTE)v45 != *(_BYTE *)(StringTable + 5200)) ? (v28 = -v27 - (v27 - 1)) : (v28 = 0),
          !v28) )
    {
processname_matched:                            // this is executed if process name equals any of listed above
      processFlags |= 0x2000u;
      if ( currentProcess2 )
      {
        if ( import_PsGetProcessInheritedFromUniqueProcessId )
          parentPID = import_PsGetProcessInheritedFromUniqueProcessId(currentProcess2);
        else
          parentPID = 0i64;
      }
      else
      {
        parentPID = 0i64;
      }
      if ( parentPID )
      {
        v30 = import_PsLookupProcessByProcessId ? (unsigned int)import_PsLookupProcessByProcessId(
                                                                  parentPID,
                                                                  &parentProcess) : -1073741822;
        if ( v30 >= 0 )
        {
          if ( MEMORY[0xFFFFF7800000026C] != 5 )
          {
            v31 = parentProcess;
            if ( !parentProcess )
            {
LABEL_72:
              processFlags |= 0x4000u;
LABEL_74:
              ObfDereferenceObject(v31);
              goto LABEL_76;
            }
            if ( !QueryTokenIntegrityLevel((__int64)parentProcess, (__int64)&v46) || v46 < 0x4000 )
            {
              v31 = parentProcess;
              goto LABEL_72;
            }
          }
          v31 = parentProcess;
          goto LABEL_74;
        }
      }
      processFlags |= 0x4000u;
    }
  }
LABEL_76:
  if ( v3 && (!currentProcess ? (v32 = 0) : (v32 = GetProcessPath(currentProcess, (__int64)&buffer->process_path)), v32)
    || v3 && GetMappedFilename(-1i64, (__int64)buffer->base_address, (__int64)&buffer->process_path, 0)
    || v3
    && (!currentProcessID ? (v33 = 0) : (v33 = GetProcessImageFileName(&buffer->process_path, currentProcessID, 0)), v33)
    || (v34 = &buffer->process_path, GetProcessPathOrCommandLine(currentProcess, 1, (__int64)&buffer->process_path)) )
  {
    buffer->success = 1;
    v34 = &buffer->process_path;
    if ( IsFileInSystemDirectory(&buffer->process_path) )
      processFlags |= 0x200u;
  }
  v36 = buffer->base_address;
  v37 = (unsigned __int64)&v36[63].e_lfanew + 3;
  if ( (_IMAGE_DOS_HEADER *)((char *)&v36[63].e_lfanew + 3) < v36 || v37 >= MmUserProbeAddress )
  {
    ExRaiseAccessViolation(v37, v35);
  }
  else
  {
    v38 = (unsigned __int16 *)((unsigned __int64)v34 & -(signed __int64)(buffer->success != 0));
    v39 = GetProcessBitness2(currentProcess);
    v40 = CopyProcessInformation(buffer->base_address, 0x1000ui64, 0i64, processFlags, v39, v38, currentProcessID, 0i64);
    *(_QWORD *)&buffer->char0 = v40;
    if ( v40 )
    {
      if ( !buffer->success && GetProcessFileName(currentProcess, &filename) )
        CopyString(*(_QWORD *)&buffer->char0 + 22i64, 0x100ui64, &filename);
      v3 = 1;
    }
  }
LABEL_99:
  if ( !v3 && buffer )
  {
    sub_20430((__int64 *)&buffer->char0);
    buffer = 0i64;
  }
  return buffer;
}

unsigned int *__fastcall CopyProcessInformation(_IMAGE_DOS_HEADER *baseAddress, unsigned __int64 a2, unsigned __int64 a3, unsigned int a4, int a5, unsigned __int16 *a6, __int16 a7, _QWORD *a8)
{
  _DWORD *buffer; // rax MAPDST
  __int64 v14; // rdx
  bool v15; // al
  _WORD *v16; // rcx
  __int64 v17; // r9
  unsigned __int64 v18; // r8
  signed int v19; // eax
  unsigned __int16 v20; // dx
  signed __int64 v21; // rdx
  __int64 v22; // r9
  _QWORD *v23; // r13
  char *v24; // rcx
  int v25; // eax
  _IMAGE_NT_HEADERS64 *v26; // rdx
  _IMAGE_SECTION_HEADER *v27; // rcx
  USHORT v28; // r8
  __int64 v29; // rdi
  int v30; // er13
  unsigned int *v31; // rax
  unsigned int *v32; // rbx
  _IMAGE_NT_HEADERS64 *ntHeader; // [rsp+28h] [rbp-E0h]
  char *Src; // [rsp+30h] [rbp-D8h]
  _DWORD *v35; // [rsp+38h] [rbp-D0h]
  _DWORD *v36; // [rsp+40h] [rbp-C8h]
  int v38; // [rsp+50h] [rbp-B8h]
  _IMAGE_SECTION_HEADER *v39; // [rsp+58h] [rbp-B0h]
  char debugstring; // [rsp+60h] [rbp-A8h]

  buffer = (_DWORD *)AllocatePool(4676i64);
  if ( !buffer )
    return 0i64;
  memset(buffer, 0, 0x244ui64);
  *(_QWORD *)(buffer + 1) = baseAddress;
  buffer[3] = a2;
  buffer[4] = a4;
  if ( a5 )
    *((_BYTE *)buffer + 20) = a5;
  else
    *((_BYTE *)buffer + 20) = 64;
  *((_WORD *)buffer + 267) = a7;
  v15 = !a6 || !*((_QWORD *)a6 + 1) || !*a6 || !a6[1];
  if ( !v15 )
  {
    v16 = (_WORD *)((char *)buffer + 22);
    v17 = 0i64;
    v18 = 0i64;
    v19 = 0;
    if ( *(_BYTE *)a6 & 1 || (v20 = a6[1], v20 & 1) || *a6 > v20 || v20 > 0xFFFEu )
    {
      v19 = 0xC000000D;
    }
    else if ( !*((_QWORD *)a6 + 1) && (*a6 || v20) )
    {
      v19 = -1073741811;
    }
    if ( v19 >= 0 )
    {
      v17 = *((_QWORD *)a6 + 1);
      v18 = (unsigned __int64)*a6 >> 1;
    }
    if ( v19 < 0 )
    {
      *v16 = 0;
    }
    else
    {
      v21 = 256i64;
      v22 = v17 - (_QWORD)v16;
      do
      {
        if ( !v18 )
          break;
        *v16 = *(_WORD *)((char *)v16 + v22);
        ++v16;
        --v21;
        --v18;
      }
      while ( v21 );
      if ( !v21 )
        --v16;
      *v16 = 0;
    }
    if ( sub_289F0(a6, (__int64)&ntHeader) )
      *((_BYTE *)buffer + 21) = (unsigned __int64)(*a6 - (unsigned int)ntHeader) >> 1;
  }
  v23 = buffer + 145;
  v35 = buffer + 145;
  if ( baseAddress && a2 && (unsigned __int64)baseAddress < MmHighestUserAddress )
  {
    v24 = (char *)baseAddress + a2 - 1;
    if ( v24 < (char *)baseAddress || (unsigned __int64)v24 >= MmUserProbeAddress )
    {
      ExRaiseAccessViolation(v24, v14);
    }
    else if ( ValidatePeHeader(baseAddress, a2, 0i64, &ntHeader) && (v25 = IsPe64Or32Bit(baseAddress), (v38 = v25) != 0) )
    {
      *((_BYTE *)buffer + 20) = v25;
      v26 = ntHeader;
      buffer[134] = ntHeader->FileHeader.TimeDateStamp;
      *((_WORD *)buffer + 270) = v26->FileHeader.Machine;
      *((_WORD *)buffer + 271) = v26->FileHeader.Characteristics;
      *((_WORD *)buffer + 284) = 0;
      if ( v25 == 64 )
        buffer[136] = v26->OptionalHeader.ImageBase;
      else
        buffer[136] = HIDWORD(v26->OptionalHeader.ImageBase);
      buffer[137] = v26->OptionalHeader.SizeOfImage;
      buffer[138] = v26->OptionalHeader.BaseOfCode;
      buffer[139] = v26->OptionalHeader.SizeOfCode;
      buffer[140] = v26->OptionalHeader.AddressOfEntryPoint;
      buffer[141] = v26->OptionalHeader.CheckSum;
      v36 = buffer + 145;
      v27 = (_IMAGE_SECTION_HEADER *)((char *)&v26->OptionalHeader + v26->FileHeader.SizeOfOptionalHeader);
      v28 = 0;
      while ( v28 < v26->FileHeader.NumberOfSections )
      {
        if ( (_IMAGE_SECTION_HEADER *)((char *)&v27->Characteristics + 3) < v27
          || (unsigned __int64)&v27->Characteristics + 3 >= MmUserProbeAddress )
        {
          ExRaiseAccessViolation(v27, v26);
          break;
        }
        *v23 = *(_QWORD *)v27->Name;
        ++*((_WORD *)buffer + 284);
        ++v28;
        ++v27;
        v39 = v27;
        ++v23;
        v36 = v23;
      }
      v35 = v23;
      if ( CopyRawDataFromDebugDirectory(baseAddress, (__int64)&debugstring) )
      {
        Src = &debugstring;
        InitAnsiString((ANSI_STRING *)&ntHeader, &debugstring);
        v29 = (unsigned __int16)ntHeader;
        memmove(v23, Src, (unsigned __int16)ntHeader);
        v23 = (_QWORD *)((char *)v23 + v29);
        v35 = v23;
        *((_WORD *)buffer + 287) = v29;
      }
    }
    else
    {
      buffer[4] |= 0x80u;
    }
  }
  v30 = (_DWORD)v23 - (_DWORD)buffer;
  *buffer = v30;
  v31 = (unsigned int *)AllocatePool((unsigned int)(v30 + a3));
  v32 = v31;
  if ( v31 )
  {
    memmove(v31, buffer, (unsigned int)*buffer);
    if ( a3 > 0 )
    {
      if ( a8 )
        *a8 = (char *)v32 + *v32;
    }
  }
  FreePool((__int64)buffer);
  return v32;
}
```

`EasyAntiCheat.sys/servicetable.c`:

```c
char __usercall CheckServiceTable@<al>(signed int a1@<r14d>)
{
  unsigned int v2; // er12
  unsigned __int64 lstar; // rax MAPDST
  unsigned __int64 lstarEnd; // rbp
  unsigned int serviceTableHash; // edi
  unsigned int systemVersion; // eax MAPDST
  __int64 packetType; // rcx
  SystemServiceDescriptorTable *ssdt; // rsi
  unsigned int *detectionBuffer; // rbp
  unsigned int *functionDetectionBuffer; // r12
  unsigned int index; // ebx
  _BYTE *functionName; // rcx
  char *zwSyscallFunction; // rax MAPDST
  __int64 syscallIndex; // rax
  char *syscallFunctionFromSDDT; // rcx
  ULONG numOfServices; // edx
  unsigned int v20; // [rsp+40h] [rbp+8h]

  systemVersion = GetSystemVersion();
  v2 = systemVersion;
  v20 = systemVersion;
  lstar = __readmsr(0xC0000082);
  lstarEnd = (lstar & 0xFFFFFFFFFFFFF000ui64) + 0xFF1;
  if ( KeGetCurrentIrql() > 1u )
    return 0;
  serviceTableHash = 0;
  if ( !lstar )
    return 0;
  if ( !IsAddressWithinNtoskrnl(lstar) )
  {
    systemVersion = GetSystemVersion();
    packetType = 328i64;
    v20 = systemVersion;
LABEL_5:
    SendPacketToServer(packetType, (__int64)&v20, 4i64);
    return 0;
  }
  if ( lstar >= lstarEnd )
  {
LABEL_14:
    ssdt = 0i64;
  }
  else
  {
    while ( 1 )
    {
      if ( (*(_DWORD *)lstar & 0xFFFFFF) == 0x158D4C// lea r10, [rip+offset]
                                                // lea r11, [rip+offset]
                                                // test [something]
        && (*(_DWORD *)(lstar + 7) & 0xFFFFFF) == 0x1D8D4C
        && *(_BYTE *)(lstar + 14) == 0xF7u )
      {
        ssdt = (SystemServiceDescriptorTable *)(*(unsigned int *)(lstar + 3) + lstar + 7);
        if ( IsAddressWithinNtoskrnl((unsigned __int64)ssdt) )
          break;
      }
      if ( ++lstar >= lstarEnd )
        goto LABEL_14;
    }
  }
  if ( !ssdt )
    return 0;
  if ( !IsAddressWithinNtoskrnl((unsigned __int64)ssdt) )
  {
    packetType = 327i64;
    goto LABEL_5;
  }
  if ( !(unsigned __int8)MmIsAddressValid(ssdt) )
    return 0;
  detectionBuffer = (unsigned int *)AllocatePool(72i64);
  memset(detectionBuffer, 0, 72ui64);
  *detectionBuffer = v2;
  functionDetectionBuffer = detectionBuffer + 3;
  index = 0;
  do
  {
    if ( index )
    {
      switch ( index )
      {
        case 1u:
          functionName = (_BYTE *)(StringTable + 4658);// ZwDeviceIoControlFile
          break;
        case 2u:
          functionName = (_BYTE *)(StringTable + 4680);// ZwQueryInformationProcess
          break;
        case 3u:
          functionName = (_BYTE *)(StringTable + 4706);// ZwQuerySystemInformation
          break;
        case 4u:
          functionName = (_BYTE *)(StringTable + 4731);// ZwQueryVirtualMemory
          break;
        default:
          functionName = 0i64;
          break;
      }
    }
    else
    {
      functionName = (_BYTE *)(StringTable + 4645);// ZwCreateFile
    }
    zwSyscallFunction = (char *)GetKernelSyscallFunctionForNtdllFunction(functionName, a1);
    if ( zwSyscallFunction )
    {
      functionDetectionBuffer[1] = UnkHashFunction(zwSyscallFunction, 0x40i64, 0i64);
      if ( GetSyscallIndexFromFunction(&v20, (unsigned __int64)zwSyscallFunction, a1) )
      {
        syscallIndex = v20;
        *functionDetectionBuffer = v20;
        if ( (unsigned int)syscallIndex > 0xFFF || (unsigned int)syscallIndex >= ssdt->NumberOfServices )
          syscallFunctionFromSDDT = 0i64;
        else
          syscallFunctionFromSDDT = (char *)ssdt->ServiceTableBase
                                  + ((unsigned __int64)*((unsigned int *)ssdt->ServiceTableBase + syscallIndex) >> 4);
        functionDetectionBuffer[2] = UnkHashFunction(syscallFunctionFromSDDT, 64i64, 0i64);
      }
    }
    ++index;
    functionDetectionBuffer += 3;
  }
  while ( index < 5 );
  numOfServices = ssdt->NumberOfServices;
  if ( numOfServices <= 0xFFF )
    serviceTableHash = HashCRC32((char *)ssdt->ServiceTableBase, 4 * numOfServices, 0);
  detectionBuffer[1] = serviceTableHash;
  detectionBuffer[2] = ssdt->NumberOfServices;
  SendPacketToServer(317i64, (__int64)detectionBuffer, 72i64);
  FreePool((__int64)detectionBuffer);
  return 1;
}

_WORD *__usercall GetKernelSyscallFunctionForNtdllFunction@<rax>(_BYTE *funcName@<rcx>, signed int a2@<r14d>)
{
  _WORD *v3; // rbx Gets kernel ZwXXX function address which  is equivallent to ntdll Nt/ZwXXX function
  _WORD *result; // rax
  unsigned int copySize; // edi
  char *ntdllExportRva; // rax
  int ntdllSyscallIndex; // er12
  unsigned int i; // edi
  char *ntdllByte; // r13
  int v12; // eax
  __int64 zwFuncIt; // rsi
  char foundRet; // r13
  int syscallIndexOffset; // er15
  unsigned int ntoskrnlOffset; // edi
  unsigned int j; // er14
  unsigned int instructionSize; // eax
  int v19; // ecx
  void *v20; // rcx
  char v21; // al
  _WORD *addr; // rcx
  _BYTE *addr0; // r8 MAPDST
  unsigned __int64 currentOffset; // rdx
  unsigned __int8 v26; // [rsp+48h] [rbp-2E0h]
  __int64 v27; // [rsp+50h] [rbp-2D8h]
  __int64 v28; // [rsp+58h] [rbp-2D0h]
  _WORD *sectionVa; // [rsp+60h] [rbp-2C8h]
  unsigned __int64 v30; // [rsp+68h] [rbp-2C0h]
  char *ntoskrnlBuffer0; // [rsp+70h] [rbp-2B8h] MAPDST
  unsigned __int8 v33; // [rsp+80h] [rbp-2A8h]
  __int64 v34; // [rsp+95h] [rbp-293h]
  __int64 v35; // [rsp+9Dh] [rbp-28Bh]
  char ntdllBuffer[64]; // [rsp+B0h] [rbp-278h]
  char ntoskrnlBuffer[120]; // [rsp+F0h] [rbp-238h]
  unsigned int size; // [rsp+330h] [rbp+8h]
  void *bufferIt; // [rsp+338h] [rbp+10h] MAPDST
  size_t instructionSize_; // [rsp+340h] [rbp+18h]
  unsigned __int64 sectionSize; // [rsp+348h] [rbp+20h]

  v3 = 0i64;
  v26 = 0;
  result = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  if ( funcName && *funcName )
  {
    copySize = 0;
    if ( StringTable != 0xFFFFFFFFFFFFDB93i64
      && ReadFileA((const char *)(StringTable + 0x246D), (__int64)&bufferIt, (__int64)&size) )// \SystemRoot\system32\ntdll.dll
    {
      ntdllExportRva = GetPeExportRva((_IMAGE_DOS_HEADER *)bufferIt, size, (unsigned __int64)funcName);
      if ( ntdllExportRva )
      {
        copySize = size - (_DWORD)ntdllExportRva;
        if ( size - (unsigned int)ntdllExportRva > 64 )
          copySize = 64;
        memmove(ntdllBuffer, (char *)bufferIt + (_QWORD)ntdllExportRva, copySize);
      }
      if ( bufferIt )
        FreePool((__int64)bufferIt);
    }
    if ( copySize )
    {
      if ( GetNtoskrnlSection('txet.', &sectionVa, &sectionSize) )
      {
        ntdllSyscallIndex = 0;
        for ( i = 0; i < 0x10; i += v12 )
        {
          ntdllByte = &ntdllBuffer[i];
          v12 = GetInstructionSize(&v33, &ntdllBuffer[i], a2);
          if ( _bittest((const signed __int32 *)&v35 + 1, 0xCu) )
            break;
          if ( *ntdllByte == 0xB8u )            // mov     eax, ??h
          {
            ntdllSyscallIndex = *(_DWORD *)&ntdllBuffer[i + 1];
            break;
          }
          if ( *ntdllByte == 0xC2u || *ntdllByte == 0xC3u )
            break;
        }
        if ( ntdllSyscallIndex )
        {
          zwFuncIt = (__int64)FindExport((DATA_HASH_BUFFER *)&unk_47588);// can be any ZwXX function
          if ( zwFuncIt )
          {
            foundRet = 0;
            syscallIndexOffset = 0;
            ntoskrnlOffset = 0;
            for ( j = 0; j < 0x10; ++j )
            {
              instructionSize = GetInstructionSize(&v33, (_BYTE *)zwFuncIt, j);
              size = instructionSize;
              if ( _bittest((const signed __int32 *)&v35 + 1, 0xCu) )
                break;
              instructionSize_ = instructionSize;
              bufferIt = &ntoskrnlBuffer[ntoskrnlOffset];
              memmove(&ntoskrnlBuffer[ntoskrnlOffset], (const void *)zwFuncIt, instructionSize);
              if ( *(_BYTE *)zwFuncIt == 0xB8u )
              {
                syscallIndexOffset = ntoskrnlOffset + 1;
                *(_DWORD *)&ntoskrnlBuffer[ntoskrnlOffset + 1] = ntdllSyscallIndex;
              }
              else
              {
                if ( *(_BYTE *)zwFuncIt == 0xC2u || *(_BYTE *)zwFuncIt == 0xC3u )
                {
                  if ( *(_BYTE *)zwFuncIt == 0xC2u )
                    *(_WORD *)&ntoskrnlBuffer[ntoskrnlOffset + 1] = 0xAAAAu;
                  ntoskrnlOffset += size;
                  foundRet = 1;
                  break;
                }
                v19 = HIDWORD(v35);
                if ( _bittest(&v19, 9u) || _bittest(&v19, 8u) )
                {
                  v26 = v33;
                  v27 = v34;
                  v28 = v35;
                  v20 = bufferIt;
                  if ( bufferIt )
                  {
                    v21 = sub_17FB0((unsigned __int64)bufferIt, &v26);
                    v20 = bufferIt;
                  }
                  else
                  {
                    v21 = 0;
                  }
                  if ( !v21 )
                  {
                    memset(v20, 170, instructionSize_);
                    *(_BYTE *)bufferIt = *(_BYTE *)zwFuncIt;
                  }
                  if ( *(_BYTE *)zwFuncIt == 0xE9u )
                  {
                    ntoskrnlOffset += size;
                    goto LABEL_46;
                  }
                }
              }
              ntoskrnlOffset += size;
              zwFuncIt += instructionSize_;
            }
            if ( !foundRet )
              goto LABEL_60;
LABEL_46:
            if ( syscallIndexOffset && ntoskrnlOffset >= 2 && ntoskrnlOffset <= sectionSize )
            {
              for ( addr = sectionVa;
                    addr < (_WORD *)((char *)sectionVa + sectionSize - ntoskrnlOffset);
                    addr = (_WORD *)((char *)addr + 1) )
              {
                if ( *addr == *(_WORD *)ntoskrnlBuffer )
                {
                  addr0 = addr;
                  addr0 = addr;
                  ntoskrnlBuffer0 = ntoskrnlBuffer;
                  ntoskrnlBuffer0 = ntoskrnlBuffer;
                  currentOffset = 0i64;
                  v30 = 0i64;
                  while ( currentOffset < ntoskrnlOffset && (*addr0 == *ntoskrnlBuffer0 || *ntoskrnlBuffer0 == 0xAAu) )
                  {
                    v30 = ++currentOffset;
                    ++addr0;
                    ++ntoskrnlBuffer0;
                  }
                  if ( currentOffset == ntoskrnlOffset )
                  {
                    v3 = addr;
                    break;
                  }
                }
              }
            }
          }
        }
LABEL_60:
        result = v3;
      }
      else
      {
        result = 0i64;
      }
    }
    else
    {
      result = 0i64;
    }
  }
  return result;
}
```

`EasyAntiCheat.sys/suspiciousmodules.c`:

```c
char __fastcall CheckForSuspiciousModules(__int64 a1)
{
  char suspiciousModulesFound; // di
  __int64 *processes; // rax MAPDST
  unsigned int processCount; // esi
  __int64 *pProcess; // rbp
  __int64 v7; // rsi

  suspiciousModulesFound = 0;
  processes = (__int64 *)AllocatePool(4096i64);
  if ( processes )
  {
    processCount = Get512RunningProcessesFromThreads(processes);
    if ( processCount )
    {
      ObfDereferenceObject((PVOID)*processes);
      if ( processCount > 1 )
      {
        pProcess = processes + 1;
        v7 = processCount - 1;
        do
        {
          if ( !suspiciousModulesFound && !sub_1F140(a1) )
            suspiciousModulesFound = IsProcessRunningSuspiciousModule(*pProcess, v7);
          ObfDereferenceObject((PVOID)*pProcess);
          ++pProcess;
          --v7;
        }
        while ( v7 );
      }
    }
    FreePool((__int64)processes);
  }
  return suspiciousModulesFound;
}

char __usercall IsProcessRunningSuspiciousModule@<al>(__int64 process@<rcx>, int a2@<esi>)
{
  char v3; // bl
  char v5; // [rsp+20h] [rbp-38h]

  v3 = 0;
  if ( AttachToProcess(process, (__int64)&v5) )
  {
    if ( GetUsermodeModule((UNICODE_STRING *)(StringTable + 4830))// Dumper.dll
      && GetUsermodeModule((UNICODE_STRING *)(StringTable + 4852))// Glob.dll
      && GetUsermodeModule((UNICODE_STRING *)(StringTable + 4870))// mswsock.dll
      && GetUsermodeModule((UNICODE_STRING *)(StringTable + 4894))// perl512.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 4918))// vmclientcore.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 4952))// vmwarewui.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 4980))// virtualbox.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 5010))// qtcorevbox4.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 5042))// vboxvmm.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 5066)) )// netredirect.dll
    {
      v3 = 1;
    }
    if ( process )
      DetachFromProcess(process, (__int64)&v5, process, a2);
  }
  return v3;
}

char CheckRunningPrograms()
{
  char v0; // bp
  HANDLE *processes; // rax MAPDST
  unsigned int status; // er13
  unsigned int index; // esi
  HANDLE *current; // r12
  signed int v6; // eax
  char v7; // bl
  __int64 v8; // rbx
  unsigned __int64 v9; // r8
  SYSTEM_MODULE_INFORMATION *moduleInformation; // rax MAPDST
  __int64 v11; // r8
  ULONG v13; // esi
  USHORT *v14; // rdi
  CHAR *v15; // rdx
  __int64 v16; // r8
  __int64 v17; // r8
  ANSI_STRING a1; // [rsp+20h] [rbp-48h]
  char v20; // [rsp+30h] [rbp-38h]
  PVOID process; // [rsp+70h] [rbp+8h]

  v0 = 0;
  processes = (HANDLE *)AllocatePool(2048i64);
  if ( !processes )
    goto LABEL_34;
  status = GetRunningProcesses(processes, 0x100u, 0i64, 0i64);
  if ( status > 0 )
  {
    index = 0;
    current = processes;
    while ( 1 )
    {
      if ( *current )
      {
        v6 = import_PsLookupProcessByProcessId ? (unsigned int)import_PsLookupProcessByProcessId(*current, &process) : 0xC0000002;
        if ( v6 >= 0 )
        {
          v7 = GetProcessFileName((__int64)process, &v20);
          ObfDereferenceObject(process);
          if ( v7 )
          {
            v8 = StringTable;
            if ( strstrIgnoreCase(&v20, (_BYTE *)(StringTable + 8018), 7ui64)// dbgview
              || strstrIgnoreCase(&v20, (_BYTE *)(v8 + 8026), v9)// devenv
              || strstrIgnoreCase(&v20, (_BYTE *)(v8 + 8034), 3ui64) )// tv_
            {
              break;
            }
          }
        }
      }
      ++index;
      ++current;
      if ( index >= status )
        goto LABEL_16;
    }
    v0 = 1;
  }
LABEL_16:
  FreePool((__int64)processes);
  if ( !v0 )
  {
LABEL_34:
    moduleInformation = (SYSTEM_MODULE_INFORMATION *)QuerySystemModuleInformation(0);
    if ( moduleInformation )
    {
      v13 = 0;
      if ( moduleInformation->Count > 0 )
      {
        v14 = &moduleInformation->Module[0].OffsetToFileName;
        while ( 1 )
        {
          if ( *(_QWORD *)(v14 - 11) >= MmSystemRangeStart )
          {
            v15 = (char *)v14 + *v14 + 2;
            a1.Buffer = v15;
            if ( v15 )
            {
              SetAnsiStringLength(&a1, v15);
            }
            else
            {
              a1.Length = 0;
              a1.MaximumLength = 0;
            }
            LOBYTE(v11) = 1;
            if ( !(unsigned int)strstr2((__int64)&a1, (const char *)(StringTable + 8038), v11) )// Dbgv.sys
              break;
            LOBYTE(v16) = 1;
            if ( !(unsigned int)strstr2((__int64)&a1, (const char *)(StringTable + 8047), v16) )// PROCMON23.sys
              break;
            LOBYTE(v17) = 1;
            if ( !(unsigned int)strstr2((__int64)&a1, (const char *)(StringTable + 8061), v17) )// dbk64.sys
              break;
          }
          ++v13;
          v14 += 148;
          if ( v13 >= moduleInformation->Count )
            goto LABEL_30;
        }
        v0 = 1;
      }
LABEL_30:
      FreePool((__int64)moduleInformation);
    }
  }
  return v0;
}

bool __fastcall SomeModuleCheck(UNICODE_STRING *a1)
{
  UNICODE_STRING *v1; // rbx
  __int64 v2; // rdi
  bool result; // al

  v1 = a1;
  result = 0;
  if ( a1 )
  {
    if ( a1->Buffer )
    {
      if ( a1->Length )
      {
        if ( a1->MaximumLength )
        {
          v2 = StringTable;
          if ( CompareUnicodeStringsIgnoreCase(a1, (unsigned __int16 *)(StringTable + 8467))//  \System32\atmfd.dll
            || CompareUnicodeStringsIgnoreCase(v1, (unsigned __int16 *)(v2 + 8507))//  \System32\cdd.dll
            || CompareUnicodeStringsIgnoreCase(v1, (unsigned __int16 *)(v2 + 8543))// \System32\rdpdd.dll
            || CompareUnicodeStringsIgnoreCase(v1, (unsigned __int16 *)(v2 + 8583))// \System32\vga.dll
            || CompareUnicodeStringsIgnoreCase(v1, (unsigned __int16 *)(v2 + 8619)) )// \System32\workerdd.dll
          {
            result = 1;
          }
        }
      }
    }
  }
  return result;
}
```

`EasyAntiCheat.sys/systemthread.c`:

```c
__int64 ScanSystemThreads()
{
  __int64 result; // rax
  __int64 currentProcessId; // r14
  int isSystemThread; // er11
  __int64 systemBigPoolInformation; // r12
  SYSTEM_MODULE_INFORMATION *systemModuleInformation; // r13
  CONTEXT *context; // rsi
  unsigned __int64 currentThreadId; // rbx
  signed int status0; // eax
  STACKWALK_ENTRY *entry; // rdi
  __int64 v10; // rcx
  int entryIndex; // er10
  __int64 v12; // r11
  unsigned __int64 v13; // rcx
  int status1; // eax
  __int64 threadProcessId; // rax
  STACKWALK_BUFFER stackwalkBuffer; // [rsp+30h] [rbp-238h]
  PVOID threadObject; // [rsp+270h] [rbp+8h] MAPDST
  __int64 win32StartAddress; // [rsp+278h] [rbp+10h] MAPDST
 
  result = import_PsGetCurrentThreadProcessId();
  currentProcessId = result;
  if ( import_PsIsSystemThread )
  {
    result = import_PsIsSystemThread(__readgsqword(0x188u));
    isSystemThread = (unsigned __int8)result;
  }
  else
  {
    isSystemThread = 0;
  }
  if ( isSystemThread )
  {
    result = import_PsGetCurrentProcess();
    if ( result == PsInitialSystemProcess )
    {
      systemBigPoolInformation = QuerySystemInformation(0x42i64, 0x100000i64, 0x2000000i64);
      result = QuerySystemModuleInformation();
      systemModuleInformation = (SYSTEM_MODULE_INFORMATION *)result;
      if ( result )
      {
        context = (CONTEXT *)AllocatePool(0x4D0i64);
        if ( context )
        {
          currentThreadId = 4i64;
          do
          {
            if ( import_PsLookupThreadByThreadId )
              status0 = import_PsLookupThreadByThreadId(currentThreadId, &threadObject);
            else
              status0 = 0xC0000002;
            if ( status0 >= 0 )
            {
              if ( GetProcessId((__int64)threadObject) == currentProcessId
                && threadObject != (PVOID)__readgsqword(0x188u)
                && StackwalkThread((__int64)threadObject, context, &stackwalkBuffer)
                && stackwalkBuffer.EntryCount > 0u )
              {
                entry = stackwalkBuffer.Entries;
                while ( 1 )
                {
                  if ( !GetModuleEntryForAddress(entry->RipValue, &systemModuleInformation->Count) )
                  {
                    if ( !v10 )
                      break;
                    if ( !v12 )
                      break;
                    v13 = *(_QWORD *)(v12 + 24);
                    if ( !v13
                      || *(_DWORD *)(v12 + 32) <= 0u
                      || entry->RipValue < v13
                      || entry->RipValue >= v13 + *(unsigned int *)(v12 + 32) )
                    {
                      break;
                    }
                  }
                  ++entry;
                  if ( (unsigned int)(entryIndex + 1) >= stackwalkBuffer.EntryCount )
                    goto LABEL_30;
                }
                status1 = QueryWin32StartAddress((__int64)threadObject, &win32StartAddress);
                if ( status1 < 0 )
                  win32StartAddress = 0i64;
                threadProcessId = GetProcessId((__int64)threadObject);
                PerformAdditionalScans(         // This is virtualized.
                                                // Probably checks if address is within any big pool and sends report to server.
                  threadProcessId,
                  (unsigned int)currentThreadId,
                  win32StartAddress,
                  systemModuleInformation,
                  systemBigPoolInformation,
                  &stackwalkBuffer);
              }
LABEL_30:
              ObfDereferenceObject(threadObject);
            }
            currentThreadId += 4i64;
          }
          while ( currentThreadId < 0x3000 );
          FreePool((__int64)context);
        }
        result = FreePool((__int64)systemModuleInformation);
      }
      if ( systemBigPoolInformation )
        result = FreePool(systemBigPoolInformation);
    }
  }
  return result;
}
 
char __fastcall StackwalkThread(__int64 threadObject, CONTEXT *context, STACKWALK_BUFFER *stackwalkBuffer)
{
  char status; // di
  _QWORD *stackBuffer; // rax MAPDST
  size_t copiedSize; // rax
  DWORD64 startRip; // rdx
  unsigned int index; // ebp
  unsigned __int64 rip0; // rcx
  DWORD64 rsp0; // rdx
  __int64 functionTableEntry; // rax
  __int64 moduleBase; // [rsp+40h] [rbp-48h]
  __int64 v17; // [rsp+48h] [rbp-40h]
  __int64 v18; // [rsp+50h] [rbp-38h]
  unsigned __int64 sectionVa; // [rsp+90h] [rbp+8h]
  __int64 sectionSize; // [rsp+A8h] [rbp+20h]
 
  status = 0;
  if ( !threadObject )
    return 0;
  if ( !stackwalkBuffer )
    return 0;
  memset(context, 0, 0x4D0ui64);
  memset(stackwalkBuffer, 0, 0x208ui64);
  if ( !import_RtlVirtualUnwind )
  {
    import_RtlVirtualUnwind = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))FindExport((__int64)&unk_47420);
    if ( !import_RtlVirtualUnwind )
      return 0;
  }
  if ( !import_RtlLookupFunctionEntry )
  {
    import_RtlLookupFunctionEntry = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))FindExport((__int64)&unk_473F0);
    if ( !import_RtlLookupFunctionEntry )
      return 0;
  }
  stackBuffer = (_QWORD *)AllocatePool(4096i64);
  if ( stackBuffer )
  {
    copiedSize = CopyThreadKernelStack(threadObject, 4096i64, stackBuffer, 4096);
    if ( copiedSize )
    {
      if ( copiedSize != 4096 && copiedSize >= 0x48 )
      {
        if ( GetNtoskrnlSection('txet.', &sectionVa, &sectionSize) )
        {
          startRip = stackBuffer[7];
          if ( startRip >= sectionVa && startRip < sectionSize + sectionVa )
          {
            status = 1;
            context->Rip = startRip;
            context->Rsp = (DWORD64)(stackBuffer + 8);
            index = 0;
            do
            {
              rip0 = context->Rip;
              rsp0 = context->Rsp;
              stackwalkBuffer->Entries[stackwalkBuffer->EntryCount].RipValue = rip0;
			  stackwalkBuffer->Entries[stackwalkBuffer->EntryCount++].RspValue = rsp0;
              if ( rip0 < MmSystemRangeStart )
                break;
              if ( rsp0 < MmSystemRangeStart )
                break;
              functionTableEntry = import_RtlLookupFunctionEntry(rip0, &moduleBase, 0i64);
              if ( !functionTableEntry )
                break;
              import_RtlVirtualUnwind(0i64, moduleBase, context->Rip, functionTableEntry, context, &v18, &v17, 0i64);
              if ( !context->Rip )
              {
                stackwalkBuffer->Succeded = 1;
                break;
              }
              ++index;
            }
            while ( index < 0x20 );
          }
        }
      }
    }
    FinalizeFreePool((__int64)stackBuffer);
  }
  return status;
}
 
size_t __usercall CopyThreadKernelStack@<rax>(__int64 threadObject@<rcx>, __int64 maxSize@<rdx>, void *outStackBuffer@<r8>, signed int a4@<r14d>)
{
  size_t copiedSize; // rsi
  __int64 threadStateOffset; // r12 MAPDST
  __int64 kernelStackOffset; // r14
  unsigned int threadStackBaseOffset; // eax
  unsigned __int64 threadStackBase; // rdi
  unsigned int threadStackLimitOffset; // eax
  unsigned __int64 threadStackLimit; // rbp
  int isSystemThread; // er11
  const void **pKernelStack; // r12
  __int64 v16; // rdx
  unsigned int threadLockOffset; // eax
  KSPIN_LOCK *threadLock; // rcx
  void (__fastcall *v19)(_QWORD, __int64); // rax
  unsigned __int8 oldIrql; // [rsp+50h] [rbp+8h]
 
  copiedSize = 0i64;
  threadStateOffset = (unsigned int)GetThreadStateOffset(a4);
  kernelStackOffset = (unsigned int)GetKernelStackOffset();
  threadStackBaseOffset = GetThreadStackBaseOffset();
  if ( threadObject && threadStackBaseOffset )
    threadStackBase = *(_QWORD *)(threadStackBaseOffset + threadObject);
  else
    threadStackBase = 0i64;
  threadStackLimitOffset = GetThreadStackLimitOffset();
  if ( !threadObject )
    return 0i64;
  threadStackLimit = threadStackLimitOffset ? *(_QWORD *)(threadStackLimitOffset + threadObject) : 0i64;
  isSystemThread = import_PsIsSystemThread ? (unsigned __int8)import_PsIsSystemThread(threadObject) : 0;
  if ( !isSystemThread
    || !outStackBuffer
    || !(_DWORD)threadStateOffset
    || !(_DWORD)kernelStackOffset
    || !threadStackBase
    || !threadStackLimit
    || KeGetCurrentIrql() > 1u
    || threadObject == __readgsqword(0x188u) )
  {
    return 0i64;
  }
  pKernelStack = (const void **)(threadObject + kernelStackOffset);
  memset(outStackBuffer, 0, 0x1000ui64);
  if ( LockThread(&oldIrql, threadObject, 0x1000) )
  {
    if ( !(unsigned __int8)PsIsThreadTerminating(threadObject)
      && *(_BYTE *)(threadStateOffset + threadObject) == 5
      && (unsigned __int64)*pKernelStack > threadStackLimit
      && (unsigned __int64)*pKernelStack < threadStackBase
      && MmGetPhysicalAddress(*pKernelStack) )
    {
      copiedSize = threadStackBase - (_QWORD)*pKernelStack;
      if ( copiedSize > 0x1000 )
        copiedSize = 0x1000i64;
      memmove(outStackBuffer, *pKernelStack, copiedSize);
    }
    if ( MEMORY[0xFFFFF7800000026C] >= 6u && (MEMORY[0xFFFFF7800000026C] != 6 || MEMORY[0xFFFFF78000000270]) )
    {
      threadLockOffset = GetThreadLockOffset(0x1000);
      threadLock = (KSPIN_LOCK *)((threadObject + threadLockOffset) & -(signed __int64)(threadLockOffset != 0));
      if ( threadLock )
      {
        KeReleaseSpinLockFromDpcLevel(threadLock);
        __writecr8(oldIrql);
      }
    }
    else
    {
      v19 = (void (__fastcall *)(_QWORD, __int64))qword_4DF00;
      if ( qword_4DF00
        || (v19 = (void (__fastcall *)(_QWORD, __int64))FindExport((__int64)&unk_46D00),
            (qword_4DF00 = (__int64)v19) != 0) )
      {
        LOBYTE(v16) = oldIrql;
        v19(0i64, v16);
      }
    }
  }
  return copiedSize;
}
```

`EasyAntiCheat.sys/tdl.c`:

```c
SYSTEM_BIGPOOL_INFORMATION *__usercall CheckForTDL@<rax>(signed int a1@<r14d>)
{
  SYSTEM_BIGPOOL_INFORMATION *bigpoolInfo; // rax MAPDST
  ULONG index; // esi
  __int64 MmGetPhysicalAddress; // rdx
  SYSTEM_BIGPOOL_ENTRY1 *entry; // rbx
  char detectedTDL; // bp
  __int64 physicalAddress; // rax
  __int64 v8; // rax MAPDST
  unsigned __int64 v10; // rcx
  ULONG_PTR size; // rbx
  unsigned __int64 v12; // rcx
  __int64 alignedSize; // rbx
  __int64 v14; // rax
  __int64 v15; // rax MAPDST

  bigpoolInfo = (SYSTEM_BIGPOOL_INFORMATION *)QuerySystemInformation_0(0x42u, 0x100000u, 0x2000000u, 0i64, a1);
  if ( bigpoolInfo )
  {
    index = 0;
    if ( bigpoolInfo->Count )
    {
      MmGetPhysicalAddress = (__int64)import_MmGetPhysicalAddress;
      entry = (SYSTEM_BIGPOOL_ENTRY1 *)bigpoolInfo->AllocatedInfo;
      while ( 1 )
      {
        detectedTDL = 0;
        if ( *(_QWORD *)&entry->0 & 1 && entry->SizeInBytes >= 0x2000 )// if nonpaged
        {
          if ( entry->TagUlong == 'SldT' )
            break;
          if ( MmGetPhysicalAddress )
          {
            physicalAddress = ((__int64 (__fastcall *)(unsigned __int64))MmGetPhysicalAddress)((_QWORD)entry->VirtualAddress & 0xFFFFFFFFFFFFFFFEui64);
            MmGetPhysicalAddress = (__int64)import_MmGetPhysicalAddress;
          }
          else
          {
            physicalAddress = qword_4DBE8;
          }
          if ( physicalAddress )
          {
            v8 = MapPhysicalMemory(physicalAddress, 4096i64);
            if ( v8 )
            {
              if ( *(_QWORD *)(v8 + 0x184) == 0xB024BC8B48i64 )
              {
                detectedTDL = 0;
                if ( (unsigned int)HashCRC32((char *)(v8 + 0x184), 151u, 0) == 0xC8931AEB )
                  detectedTDL = 1;
              }
              if ( import_MmUnmapVideoDisplay )
                import_MmUnmapVideoDisplay(v8, 4096i64);
            }
            MmGetPhysicalAddress = (__int64)import_MmGetPhysicalAddress;
          }
        }
        else
        {
          detectedTDL = 0;
        }
        if ( detectedTDL )
          break;
        ++index;
        ++entry;
        if ( index >= bigpoolInfo->Count )
          goto LABEL_31;
      }
      v10 = (unsigned __int64)entry->VirtualAddress;
      size = entry->SizeInBytes;
      v12 = v10 & 0xFFFFFFFFFFFFFFFEui64;
      if ( size > (unsigned __int64)qword_80000 )
        size = (ULONG_PTR)qword_80000;
      alignedSize = size & 0xFFFFFFFFFFFFF000ui64;
      if ( MmGetPhysicalAddress )
        v14 = ((__int64 (__fastcall *)(unsigned __int64))MmGetPhysicalAddress)(v12);
      else
        v14 = qword_4DBE8;
      if ( v14 )
      {
        v15 = MapPhysicalMemory(v14, alignedSize);
        if ( v15 )
        {
          SendPacketToServer(133i64, v15, (unsigned int)alignedSize);
          if ( import_MmUnmapVideoDisplay )
            import_MmUnmapVideoDisplay(v15, alignedSize);
        }
      }
    }
LABEL_31:
    bigpoolInfo = (SYSTEM_BIGPOOL_INFORMATION *)FreePool((__int64)bigpoolInfo);
  }
  return bigpoolInfo;
}
```

`EasyAntiCheat.sys/vm.asm`:

```asm
.text:0000000000036C30                         ExecVMREAD      proc near               ; CODE XREF: CheckVM+21↑p
.text:0000000000036C30 0F 78 0A                                vmread  qword ptr [rdx], rcx
.text:0000000000036C33 0F 94 C0                                setz    al
.text:0000000000036C36 0F 92 C1                                setb    cl
.text:0000000000036C39 12 C1                                   adc     al, cl
.text:0000000000036C3B C3                                      retn
.text:0000000000036C3B                         ExecVMREAD      endp

.text:000000000001FD84                         CheckVM         proc near               ; DATA XREF: .pdata:000000000004F960↓o
.text:000000000001FD84
.text:000000000001FD84                         var_28          = byte ptr -28h
.text:000000000001FD84                         var_18          = dword ptr -18h
.text:000000000001FD84                         var_14          = dword ptr -14h
.text:000000000001FD84                         var_10          = dword ptr -10h
.text:000000000001FD84
.text:000000000001FD84                         ; FUNCTION CHUNK AT .text:000000000003724A SIZE 00000023 BYTES
.text:000000000001FD84
.text:000000000001FD84                         ; __unwind { // __C_specific_handler
.text:000000000001FD84 40 53                                   push    rbx
.text:000000000001FD86 48 83 EC 40                             sub     rsp, 40h
.text:000000000001FD8A B3 01                                   mov     bl, 1
.text:000000000001FD8C 88 5C 24 20                             mov     [rsp+48h+var_28], bl
.text:000000000001FD90 33 C0                                   xor     eax, eax
.text:000000000001FD92 89 44 24 30                             mov     [rsp+48h+var_18], eax
.text:000000000001FD96 89 44 24 34                             mov     [rsp+48h+var_14], eax
.text:000000000001FD9A 89 44 24 38                             mov     [rsp+48h+var_10], eax
.text:000000000001FD9E
.text:000000000001FD9E                         loc_1FD9E:                              ; DATA XREF: .rdata:0000000000049114↓o
.text:000000000001FD9E                         ;   __try { // __except at VMNotFound
.text:000000000001FD9E 48 8D 54 24 34                          lea     rdx, [rsp+48h+var_14]
.text:000000000001FDA3 33 C9                                   xor     ecx, ecx
.text:000000000001FDA5 E8 86 6E 01 00                          call    ExecVMREAD
.text:000000000001FDAA 88 5C 24 20                             mov     [rsp+48h+var_28], bl
.text:000000000001FDAE EB 16                                   jmp     short VMFound
.text:000000000001FDAE                         ;   } // starts at 1FD9E
.text:000000000001FDB0                         ; ---------------------------------------------------------------------------
.text:000000000001FDB0
.text:000000000001FDB0                         VMNotFound:                             ; DATA XREF: .rdata:0000000000049114↓o
.text:000000000001FDB0                         ;   __except(loc_3724A) // owned by 1FD9E
.text:000000000001FDB0 0F B6 5C 24 20                          movzx   ebx, [rsp+48h+var_28]
.text:000000000001FDB5 33 C0                                   xor     eax, eax
.text:000000000001FDB7 81 7C 24 30 1D 00 00 C0                 cmp     [rsp+48h+var_18], 0C000001Dh
.text:000000000001FDBF 0F 44 D8                                cmovz   ebx, eax
.text:000000000001FDC2 88 5C 24 20                             mov     [rsp+48h+var_28], bl
.text:000000000001FDC6
.text:000000000001FDC6                         VMFound:                                ; CODE XREF: CheckVM+2A↑j
.text:000000000001FDC6 F6 DB                                   neg     bl
.text:000000000001FDC8 1B C9                                   sbb     ecx, ecx
.text:000000000001FDCA 81 C1 55 01 00 00                       add     ecx, 155h
.text:000000000001FDD0 45 33 C9                                xor     r9d, r9d
.text:000000000001FDD3 45 8D 41 0C                             lea     r8d, [r9+0Ch]
.text:000000000001FDD7 48 8D 54 24 30                          lea     rdx, [rsp+48h+var_18]
.text:000000000001FDDC E8 27 09 01 00                          call    SendPacketToServer
.text:000000000001FDE1 48 83 C4 40                             add     rsp, 40h
.text:000000000001FDE5 5B                                      pop     rbx
.text:000000000001FDE6 C3                                      retn
.text:000000000001FDE6                         ; } // starts at 1FD84
.text:000000000001FDE6                         CheckVM         endp



.text:000000000001FDF0 48 89 5C 24 08                          mov     [rsp+arg_0], rbx
.text:000000000001FDF5 57                                      push    rdi
.text:000000000001FDF6 48 83 EC 50                             sub     rsp, 50h
.text:000000000001FDFA 83 64 24 20 00                          and     [rsp+58h+var_38], 0
.text:000000000001FDFF 33 D2                                   xor     edx, edx        ; Val
.text:000000000001FE01 48 8D 4C 24 24                          lea     rcx, [rsp+58h+Dst] ; Dst
.text:000000000001FE06 44 8D 42 24                             lea     r8d, [rdx+24h]  ; Size
.text:000000000001FE0A E8 11 72 01 00                          call    memset
.text:000000000001FE0F 45 0F 20 C3                             mov     r11, cr8
.text:000000000001FE13 B8 0F 00 00 00                          mov     eax, 0Fh
.text:000000000001FE18 44 0F 22 C0                             mov     cr8, rax
.text:000000000001FE1C 48 8B 7C 24 38                          mov     rdi, [rsp+58h+var_20]
.text:000000000001FE21 44 8D 48 55                             lea     r9d, [rax+55h]
.text:000000000001FE25 4D 8B D1                                mov     r10, r9
.text:000000000001FE28
.text:000000000001FE28                         loc_1FE28:                              ; CODE XREF: sub_1FDF0+70↓j
.text:000000000001FE28 0F 31                                   rdtsc
.text:000000000001FE2A 48 C1 E2 20                             shl     rdx, 20h
.text:000000000001FE2E 48 0B C2                                or      rax, rdx
.text:000000000001FE31 33 C9                                   xor     ecx, ecx
.text:000000000001FE33 4C 8B C0                                mov     r8, rax
.text:000000000001FE36 B8 01 00 00 00                          mov     eax, 1
.text:000000000001FE3B 0F A2                                   cpuid
.text:000000000001FE3D 89 44 24 20                             mov     [rsp+58h+var_38], eax
.text:000000000001FE41 89 5C 24 24                             mov     [rsp+58h+Dst], ebx
.text:000000000001FE45 89 4C 24 28                             mov     [rsp+58h+var_30], ecx
.text:000000000001FE49 89 54 24 2C                             mov     [rsp+58h+var_2C], edx
.text:000000000001FE4D 0F 31                                   rdtsc
.text:000000000001FE4F 48 C1 E2 20                             shl     rdx, 20h
.text:000000000001FE53 48 0B C2                                or      rax, rdx
.text:000000000001FE56 49 2B C0                                sub     rax, r8
.text:000000000001FE59 48 03 F8                                add     rdi, rax
.text:000000000001FE5C 49 83 EA 01                             sub     r10, 1
.text:000000000001FE60 75 C6                                   jnz     short loc_1FE28
.text:000000000001FE62 48 8B 5C 24 40                          mov     rbx, [rsp+58h+var_18]
.text:000000000001FE67 48 89 7C 24 38                          mov     [rsp+58h+var_20], rdi
.text:000000000001FE6C
.text:000000000001FE6C                         loc_1FE6C:                              ; CODE XREF: sub_1FDF0+9B↓j
.text:000000000001FE6C 0F 31                                   rdtsc
.text:000000000001FE6E 48 C1 E2 20                             shl     rdx, 20h
.text:000000000001FE72 48 0B C2                                or      rax, rdx
.text:000000000001FE75 48 8B C8                                mov     rcx, rax
.text:000000000001FE78 0F 31                                   rdtsc
.text:000000000001FE7A 48 C1 E2 20                             shl     rdx, 20h
.text:000000000001FE7E 48 0B C2                                or      rax, rdx
.text:000000000001FE81 48 2B C1                                sub     rax, rcx
.text:000000000001FE84 48 03 D8                                add     rbx, rax
.text:000000000001FE87 49 83 E9 01                             sub     r9, 1
.text:000000000001FE8B 75 DF                                   jnz     short loc_1FE6C
.text:000000000001FE8D 48 89 5C 24 40                          mov     [rsp+58h+var_18], rbx
.text:000000000001FE92 41 0F B6 CB                             movzx   ecx, r11b
.text:000000000001FE96 44 0F 22 C1                             mov     cr8, rcx
.text:000000000001FE9A 48 8D 0D 4F 73 01 00                    lea     rcx, qword_371F0
.text:000000000001FEA1 E9 B4 59 0A 00                          jmp     loc_C585A
```

`README.md`:

```md
 ### <div dir="rtl">العربية</div>
<div dir="rtl">
يوجدت نسختين من EAC: الأولى مدفوعة وتسمى EAC، والأخرى مجانية وتسمى EOC وهي الأكثر شيوعًا في معظم الألعاب. لقد قمت برفع SDK لمساعدتك في فهم كيفية عمل EAC. على كل حال، يعتبر EOC أضعف من النسخة المدفوعة بحكم أنه مجاني، ولكن هذا لا يمنع المطورين من شراء ميزات إضافية. ما أريد تسليط الضوء عليه هنا هو أنه إذا لم يتم تثبيت EOC أو تعريفه بشكل جيد في اللعبة، فمن السهل تجاوزه.
</div>



### ENGLISH
**Found two versions of EAC:** the first one is paid and called EAC, and the other one is free and called EOC, which is the most common in most games. I uploaded the SDK to help you understand how EAC works. In any case, EOC is considered weaker than the paid version because it's free, but that doesn't prevent developers from purchasing additional features. What I want to highlight here is that if EOC is not installed or defined properly in the game, it's easy to bypass it.





**Credit goes to:**
* [Abdulaziz](https://github.com/Abdulaziz7597) for helping me with my research.
* [ch4ncellor](https://github.com/ch4ncellor) for reversing EAC.
* [adrianyy](https://github.com/adrianyy) for his research.



### Original repositories:
* [EAC-Reversal](https://github.com/ch4ncellor/EAC-Reversal) by ch4ncellor
* [EACReversing](https://github.com/adrianyy/EACReversing) by adrianyy


They have already done great work. I just gathered all the resources together, along with the EAC SDK.


# Disclaimer
The information provided in this repository is intended for educational and research purposes only. Any attempt to implement the insights or methodologies described herein should be done in accordance with applicable laws and regulations, and with explicit permission from relevant parties. The authors and contributors of this repository bear no responsibility for any misuse or unauthorized application of the materials presented here.

# Purpose
The aim of this repository is to bring together existing knowledge and resources on EAC, facilitating a deeper understanding of its mechanisms and assisting developers in effectively implementing and securing their games against cheats. By compiling the EAC SDK and the extensive research conducted by experts in the field, we hope to provide a comprehensive resource for both learning and practical application.

```