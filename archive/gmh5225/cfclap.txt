Project Path: arc_gmh5225_cfclap_s855dsyy

Source Tree:

```txt
arc_gmh5225_cfclap_s855dsyy
├── DX.cpp
├── DX.h
├── README.md
├── cfclap.sln
├── cfclap.vcxproj
├── cfclap.vcxproj.filters
├── cfclap.vcxproj.user
├── dllmain.cpp
├── framework.h
├── game.cpp
├── game.h
├── geom.h
├── hax.cpp
├── hax.h
├── offsets.h
├── pch.cpp
├── pch.h
├── ss.jpg
└── utils.h

```

`DX.cpp`:

```cpp
#include "pch.h"
#include "DX.h"
#include "hax.h"
#include "utils.h"
#include "game.h"

#include "imgui/imgui.h"
#include "imgui/imgui_impl_dx9.h"
#include "imgui/imgui_impl_win32.h"


extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

tEndScene DX::gtEndScene = nullptr;
WNDPROC DX::oWndProc = nullptr;

DX::DX() {
  menuInit = false;
  menuShow = true;
  DXLINE = nullptr;
  DXFONT = nullptr;
  DXVB = nullptr;
  m_pDevice = nullptr;
}
bool DX::GetD3D9VT(void** pTable, size_t size) {
  if (!pTable)
    return false;

  IDirect3D9* pD3D = Direct3DCreate9(D3D_SDK_VERSION);

  if (!pD3D)
    return false;

  IDirect3DDevice9* pDummyDevice = nullptr;

  D3DPRESENT_PARAMETERS d3dpp = {};
  d3dpp.Windowed = true;
  d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
  d3dpp.hDeviceWindow = GetForegroundWindow();

  HRESULT dummyDevCreated = pD3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3dpp.hDeviceWindow, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &pDummyDevice);

  if (dummyDevCreated != S_OK) {
#if DEBUG
    log("ERROR: Couldn't get VTable...");
#endif
    return false;
  }

  memcpy(pTable, *(void***)(pDummyDevice), size);

#if DEBUG
  printf("EndScene Address :: %p\n", pTable[42]);
  printf("vTable Address :: %p\n", pTable);
#endif

  pDummyDevice->Release();
  pD3D->Release();
  return true;
}
void DX::Hook() {
  bool getdev = GetD3D9VT(vTable, sizeof(vTable));
  if (getdev) {
    // Found out 15 by looking at memory and finding first integer >=14 that was hookable (not breaking across instructions)
    memcpy(oMemEndScene, vTable[42], 15);
    gtEndScene = (tEndScene)hax::TrampHook64((BYTE*)vTable[42], (BYTE*)DX::hkEndScene, 15);

#if DEBUG
    log("Successful D3D Hook...");
#endif

    HWND window = FindWindowA(NULL, "CROSSFIRE");
    oWndProc = (WNDPROC)SetWindowLongPtr(window, GWLP_WNDPROC, (LONG_PTR)DX::hkWndProc);
#if DEBUG
    log("Successful Window Hook...");
#endif


  }
  else {
#if DEBUG
    log("Failed D3D Hook...");
#endif
  }

}
void DX::Unhook() {
  DWORD oldProtect = 0x0;
  DWORD tmp = 0x0;
  VirtualProtect(vTable[42], 15, PAGE_EXECUTE_READWRITE, &oldProtect);
  memcpy(vTable[42], oMemEndScene, 15);
  VirtualProtect(vTable[42], 15, oldProtect, &tmp);
  VirtualFree(gtEndScene, 0, MEM_RELEASE); //Dangerous? hkEndScene still might be returning this..
  
  if (menuInit) {
    CleanMenu();
    SetWindowLongPtr(FindWindowA(NULL, "CROSSFIRE"), GWLP_WNDPROC, (LONG_PTR)DX::oWndProc);
  }
}
void DX::InitMenu() {
  DX& g_DX = DX::get();

  ImGui::CreateContext();
  ImGuiIO& io = ImGui::GetIO(); (void)io;

  ImGui_ImplWin32_Init(FindWindowA(NULL, "CROSSFIRE"));
  ImGui_ImplDX9_Init(g_DX.m_pDevice);

  menuInit = true;
}
void DX::CleanMenu() {
  ImGui_ImplDX9_Shutdown();
  ImGui_ImplWin32_Shutdown();
  ImGui::DestroyContext();
}
void DX::RenderMenu() {
  ImGui_ImplDX9_NewFrame();
  ImGui_ImplWin32_NewFrame();
  ImGui::NewFrame();

  ImGui::Begin("CFCLAP v1.0");
  ImGui::Text("(%.1f FPS)", ImGui::GetIO().Framerate);
  ImGui::Checkbox("Enable Aimbot", &aimbotOn);
  ImGui::Checkbox("Enable ESP", &espOn);

  ImGui::SliderFloat("Crosshair Size", &xhrSize, 0.0f, 1.0f);
  ImGui::ColorEdit3("Crosshair Color", (float*)&xhrColor);
  ImGui::End();

  ImGui::EndFrame();
  ImGui::Render();
  ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
}

HRESULT __stdcall DX::hkEndScene(LPDIRECT3DDEVICE9 pDevice) {
  DX& g_DX = DX::get();

  if (pDevice != g_DX.m_pDevice) {
#if DEBUG
    log("REPLACE DEVICE");
#endif
    if (g_DX.menuInit) g_DX.CleanMenu();
    if (g_DX.DXFONT) g_DX.DXFONT->Release();
    if (g_DX.DXLINE) g_DX.DXLINE->Release();
    g_DX.DXFONT = nullptr;
    g_DX.DXLINE = nullptr;

    g_DX.m_pDevice = pDevice;
    g_DX.InitMenu();
  }

  if (g_DX.m_pDevice) {
    if (g_DX.menuShow)
      g_DX.RenderMenu();

    g_DX.DrawESP2D();
    g_DX.DrawCircle(400.0, 300.0, g_DX.xhrSize*100.0, 0, true, 32, 
      D3DCOLOR_RGBA(
        (int)(g_DX.xhrColor.x * 255.0f), 
        (int)(g_DX.xhrColor.y * 255.0f), 
        (int)(g_DX.xhrColor.z * 255.0f), 
        150)
      );
  }

  return gtEndScene(pDevice);
}

LRESULT __stdcall DX::hkWndProc(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
  DX& g_DX = DX::get();

  if (g_DX.menuShow) {
    ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);
  }

  return CallWindowProc(oWndProc, hWnd, uMsg, wParam, lParam);
}

void DX::DrawCircle(float x, float y, float radius, int rotate, bool smoothing, int resolution, DWORD color)
{

  std::vector<vertex> circle(resolution + 2);
  float angle = rotate * D3DX_PI / 180;
  float pi = D3DX_PI;


  for (int i = 0; i < resolution + 2; i++)
  {
    circle[i].x = (float)(x - radius * cos(i * (2 * pi / resolution)));
    circle[i].y = (float)(y - radius * sin(i * (2 * pi / resolution)));
    circle[i].z = 0;
    circle[i].rhw = 1;
    circle[i].color = color;
  }

  // Rotate matrix
  int _res = resolution + 2;
  for (int i = 0; i < _res; i++)
  {
    circle[i].x = x + cos(angle) * (circle[i].x - x) - sin(angle) * (circle[i].y - y);
    circle[i].y = y + sin(angle) * (circle[i].x - x) + cos(angle) * (circle[i].y - y);
  }

  m_pDevice->CreateVertexBuffer((resolution + 2) * sizeof(vertex), D3DUSAGE_WRITEONLY, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &DXVB, NULL);

  VOID* pVertices;
  DXVB->Lock(0, (resolution + 2) * sizeof(vertex), (void**)&pVertices, 0);
  memcpy(pVertices, &circle[0], (resolution + 2) * sizeof(vertex));
  DXVB->Unlock();


  m_pDevice->SetTexture(0, NULL);
  m_pDevice->SetPixelShader(NULL);
  if (smoothing)
  {
    m_pDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
    m_pDevice->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, TRUE);
  }
  m_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
  m_pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
  m_pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  m_pDevice->SetStreamSource(0, DXVB, 0, sizeof(vertex));
  m_pDevice->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);

  m_pDevice->DrawPrimitive(D3DPT_LINESTRIP, 0, resolution);
  if (DXVB != NULL) DXVB->Release();
}
void DX::HXDrawText(const char* text, float x, float y, D3DCOLOR color) {
  RECT rect;

  if (!DXFONT)
    D3DXCreateFont(m_pDevice, 14, 0, FW_NORMAL, 1, false, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, L"Arial", &DXFONT);

  SetRect(&rect, x + 1, y + 1, x + 1, y + 1);
  DXFONT->DrawTextA(NULL, text, -1, &rect, DT_CENTER | DT_NOCLIP, D3DCOLOR_ARGB(255, 0, 0, 0));

  SetRect(&rect, x, y, x, y);
  DXFONT->DrawTextA(NULL, text, -1, &rect, DT_CENTER | DT_NOCLIP, color);
}
void DX::DrawLine(vec2 start, vec2 end, int thickness, D3DCOLOR color) {
  if (!DXLINE)
    D3DXCreateLine(m_pDevice, &DXLINE);

  D3DXVECTOR2 Line[2];
  Line[0] = D3DXVECTOR2(start.x, start.y);
  Line[1] = D3DXVECTOR2(end.x, end.y);
  DXLINE->SetWidth(thickness);
  DXLINE->Draw(Line, 2, color);

}
void DX::DrawBox2D(vec2 top, vec2 bot, int thickness, D3DCOLOR color) {
  int height = abs(top.y - bot.y);
  vec2 tl, tr;
  tl.x = top.x - height / 4;
  tr.x = top.x + height / 4;
  tl.y = tr.y = top.y;

  vec2 bl, br;
  bl.x = bot.x - height / 4;
  br.x = bot.x + height / 4;
  bl.y = br.y = bot.y;

  DrawLine(tl, tr, thickness, color);
  DrawLine(bl, br, thickness, color);
  DrawLine(tl, bl, thickness, color);
  DrawLine(tr, br, thickness, color);
}

bool DX::w2s(D3DXVECTOR3* InOut) {
  D3DXVECTOR3 vScreen;
  D3DXVECTOR3 PlayerPos(InOut->x, InOut->y, InOut->z);
  D3DVIEWPORT9 viewPort = { 0 };
  D3DXMATRIX view, projection, world;
  m_pDevice->GetTransform(D3DTS_VIEW, &view);
  m_pDevice->GetTransform(D3DTS_PROJECTION, &projection);
  m_pDevice->GetTransform(D3DTS_WORLD, &world);
  m_pDevice->GetViewport(&viewPort);
  D3DXVec3Project(&vScreen, &PlayerPos, &viewPort, &projection, &view, &world);
  if (vScreen.z < 1.0f && vScreen.x > 0.0f && vScreen.y > 0.0f && vScreen.x < viewPort.Width && vScreen.y < viewPort.Height)
  {
    *InOut = vScreen;
    return true;
  }
  return false;
}

void DX::DrawESP2D() {
  Game& g_CF = Game::get();

  if (!g_CF.CLT_SHELL || !g_CF.InGame() || !espOn) return;

  BYTE* curAddr = (BYTE*)(g_CF.CLT_SHELL + offs::ENT_BEGIN);

  // Loop Entity List
  for (int i = 0; i < 16; i++) {
    Player curP = *(Player*)curAddr;

    if (curP.info.health) {
      D3DXVECTOR3 ptH = D3DXVECTOR3(curP.model->posH.x, curP.model->posH.y, curP.model->posH.z);
      D3DXVECTOR3 ptF = D3DXVECTOR3(curP.model->posF.x, curP.model->posF.y, curP.model->posF.z);
      if (w2s(&ptH) && w2s(&ptF)) {

        vec2 top, bot;
        top.x = ptH.x;
        top.y = ptH.y;
        bot.x = ptF.x;
        bot.y = ptF.y;

        if (curP.info.team == 1)
          DrawBox2D(top, bot, 2, D3DCOLOR_ARGB(255, 0, 0, 255));
        else
          DrawBox2D(top, bot, 2, D3DCOLOR_ARGB(255, 220, 170, 40));

        HXDrawText(curP.info.name, bot.x, bot.y - 12, D3DCOLOR_ARGB(255, 255, 255, 255));
        HXDrawText(std::to_string(curP.info.health).c_str(), top.x, top.y + 4, D3DCOLOR_ARGB(255, 255, 255, 255));

      }
    }

    curAddr += offs::ENT_SIZE;
  }

}
```

`DX.h`:

```h
#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")
#pragma once

typedef HRESULT(__stdcall* tEndScene)(LPDIRECT3DDEVICE9 pDevice);
typedef LRESULT(CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

class DX
{
private:
  DX();

  struct vec2 { float x; float y; };
  struct vec3 { float x; float y; float z; };
  struct vertex
  {
    FLOAT x, y, z, rhw;
    DWORD color;
  };
  static HRESULT __stdcall hkEndScene(LPDIRECT3DDEVICE9 pDevice);
  static LRESULT __stdcall hkWndProc(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  static tEndScene gtEndScene;
  static WNDPROC oWndProc;

  BYTE oMemEndScene[15];
  IDirect3DVertexBuffer9* DXVB;
  void* vTable[119];

  bool GetD3D9VT(void** pTable, size_t size);
  void DrawCircle(float x, float y, float radius, int rotate, bool smoothing, int resolution, DWORD color);
  void HXDrawText(const char* text, float x, float y, D3DCOLOR color);
  void DrawLine(vec2 start, vec2 end, int thickness, D3DCOLOR color);
  void DrawBox2D(vec2 top, vec2 bot, int thickness, D3DCOLOR color);

public:
  ID3DXLine* DXLINE;
  ID3DXFont* DXFONT;
  LPDIRECT3DDEVICE9 m_pDevice;

  bool menuInit;
  bool menuShow;
  bool aimbotOn;
  bool espOn;
  float xhrSize;
  vec3 xhrColor;

  DX(DX const&) = delete;
  DX& operator=(DX const&) = delete;

  static DX& get() {
    static DX inst;
    return inst;
  }

  void Hook();
  void Unhook();
  void InitMenu();
  void RenderMenu();
  void CleanMenu();
  bool w2s(D3DXVECTOR3* InOut);
  void DrawESP2D();
};





```

`README.md`:

```md
# CFClap
### Internal Crossfire Hack
![Hack Screenshot](./ss.jpg)

Demo Video: https://vimeo.com/541375184
## Features
- Ingame Menu (CAPS)
-  ESP
-  FOV Aimbot
- Crosshair Overlay

### Disclaimer
This source code is for educational purposes only. I made this project to learn more about reverse engineering and not to ruin the experience for other gamers. I will not be updating the offsets for this reason.

```

`cfclap.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31005.135
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "cfclap", "cfclap.vcxproj", "{2ADF3829-B85D-4277-8080-5450532A89B0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2ADF3829-B85D-4277-8080-5450532A89B0}.Debug|x64.ActiveCfg = Debug|x64
		{2ADF3829-B85D-4277-8080-5450532A89B0}.Debug|x64.Build.0 = Debug|x64
		{2ADF3829-B85D-4277-8080-5450532A89B0}.Debug|x86.ActiveCfg = Debug|Win32
		{2ADF3829-B85D-4277-8080-5450532A89B0}.Debug|x86.Build.0 = Debug|Win32
		{2ADF3829-B85D-4277-8080-5450532A89B0}.Release|x64.ActiveCfg = Release|x64
		{2ADF3829-B85D-4277-8080-5450532A89B0}.Release|x64.Build.0 = Release|x64
		{2ADF3829-B85D-4277-8080-5450532A89B0}.Release|x86.ActiveCfg = Release|Win32
		{2ADF3829-B85D-4277-8080-5450532A89B0}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9CC48E90-A9A3-45FD-A4CA-86F9C7D44963}
	EndGlobalSection
EndGlobal

```

`cfclap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2adf3829-b85d-4277-8080-5450532a89b0}</ProjectGuid>
    <RootNamespace>cfclap</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(DXSDK_DIR)Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(DXSDK_DIR)Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;CFCLAP_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;CFCLAP_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;CFCLAP_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>d3d9.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;CFCLAP_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>d3d9.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="DX.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="game.h" />
    <ClInclude Include="geom.h" />
    <ClInclude Include="hax.h" />
    <ClInclude Include="imgui\imconfig.h" />
    <ClInclude Include="imgui\imgui.h" />
    <ClInclude Include="imgui\imgui_impl_dx9.h" />
    <ClInclude Include="imgui\imgui_impl_win32.h" />
    <ClInclude Include="imgui\imgui_internal.h" />
    <ClInclude Include="imgui\imstb_rectpack.h" />
    <ClInclude Include="imgui\imstb_textedit.h" />
    <ClInclude Include="imgui\imstb_truetype.h" />
    <ClInclude Include="offsets.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="xorstr.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="DX.cpp" />
    <ClCompile Include="game.cpp" />
    <ClCompile Include="hax.cpp" />
    <ClCompile Include="imgui\imgui.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="imgui\imgui_demo.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="imgui\imgui_draw.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="imgui\imgui_impl_dx9.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="imgui\imgui_impl_win32.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="imgui\imgui_tables.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="imgui\imgui_widgets.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`cfclap.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="geom.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="xorstr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="game.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hax.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DX.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imconfig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imgui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imgui_impl_dx9.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imgui_impl_win32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imgui_internal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imstb_rectpack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imstb_textedit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imstb_truetype.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="game.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hax.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DX.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_demo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_draw.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_impl_dx9.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_impl_win32.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_tables.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_widgets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`cfclap.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`dllmain.cpp`:

```cpp
#include "pch.h"
#include "utils.h"
#include "game.h"
#include "hax.h"
#include "DX.h"

DWORD WINAPI hxT(HMODULE hModule) {

#if DEBUG
  AllocConsole();
  FILE* f;
  freopen_s(&f, "CONOUT$", "w", stdout);
  log("Debug Mode Enabled");
#endif

  DX& g_DX = DX::get();
  Game& g_CF = Game::get();
  g_CF.init();
  g_DX.Hook();

  while (1) {
    // CAPS - Toggle Menu
    if (GetAsyncKeyState(VK_CAPITAL) & 1) {
      g_DX.menuShow = !g_DX.menuShow;
    }
    // DEL - Print Entity List
#if DEBUG
    if (GetAsyncKeyState(VK_DELETE) & 1) {
      log("Call to PrintEntityDbg");
      g_CF.PrintEntityDbg();
    }
#endif
    // PageDOWN - Unhook/Detach
    if (GetAsyncKeyState(VK_NEXT) & 1) {
      g_DX.Unhook();
      break;
    }
    // Left Shift - Aimbot 
    if (GetAsyncKeyState(VK_LSHIFT) && g_DX.aimbotOn) {
      g_CF.FOVAimbot();
    }
  }

#if DEBUG
  log("Exiting...");  
  fclose(f);
  FreeConsole();
#endif

  FreeLibraryAndExitThread(hModule, 0);

  return 0;
}


BOOL APIENTRY DllMain(HMODULE hModule,
  DWORD  ul_reason_for_call,
  LPVOID lpReserved
)
{
  switch (ul_reason_for_call)
  {
  case DLL_PROCESS_ATTACH:
  {
    CloseHandle(
      CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)hxT, hModule, 0, nullptr)
    );
    DisableThreadLibraryCalls(hModule);
  }
  case DLL_THREAD_ATTACH:
  case DLL_THREAD_DETACH:
  case DLL_PROCESS_DETACH:
    break;
  }
  return TRUE;
}



```

`framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>

```

`game.cpp`:

```cpp
#include "pch.h"
#include "game.h"
#include "offsets.h"

void Game::init() {
  Sleep(5000);

  CS_BASE = (DWORD64)GetModuleHandle(L"cshell_x64.dll");
#if DEBUG
  loghex("Base CShell Address is: ", CS_BASE);
#endif

  CF_BASE = (DWORD64)GetModuleHandle(L"crossfire_x64.exe");
#if DEBUG
  loghex("Base CF Address is: ", CF_BASE);
#endif

  CLT_SHELL = *(DWORD64*)(CS_BASE + offs::LT_SHELL);
#if DEBUG
  loghex("CLT_SHELL Address is: ", CLT_SHELL);
#endif

  pLTModel = *(CLTModel**)(CS_BASE + offs::LT_MODELCLIENT_PTR);
#if DEBUG
  loghex("CLTMODEL Address is: ", (DWORD64)pLTModel);
#endif

}

void Game::PrintEntityDbg() {
  if (!CLT_SHELL) return;

  BYTE* curAddr = (BYTE*)(CLT_SHELL + offs::ENT_BEGIN);

  for (int i = 0; i < 16; i++) {
    if (!curAddr) return;
    Player curP = *(Player*)curAddr;

    if (curAddr && *curAddr) {

      printf("PLAYER #%d :: %s :: %d\n", i, curP.info.name, curP.info.team);
    }

    curAddr += offs::ENT_SIZE;
  }
}

bool Game::InGame() {
  return CLT_SHELL && *(BYTE*)(CLT_SHELL + offs::LOCAL_ENT);
}

void Game::GetBonePosition(PlayerModel* obj, uint32_t idx, LTransform* tfm) {
  pLTModel->GetNodeTransform(obj, idx, tfm, true);
}

Player* Game::GetPlayerByIndex(int i) {
  return (Player*)(CLT_SHELL + offs::ENT_BEGIN + (i * offs::ENT_SIZE));
}

void Game::GetAnglesToPlayer(Player* me, Player* target, Vec2& out) {
  LTransform tfmMe, tfmEn;
  GetBonePosition(me->model, 6, &tfmMe);
  GetBonePosition(target->model, 6, &tfmEn);
  Vector3 dV = tfmEn.m_Vec - tfmMe.m_Vec;
  /*
  * Explanation of angles:
  * 
  * For the pitch, (out.y) we calculate the angle using asin,
  * which returns an angle, given the opp & hyp of a right triangle.
  * By passing in the dY from the distance vector as opp and length of 
  * the distance vector as hyp, we can get the angle needed for pitch.
  * (Imagine a triangle where this pitch angle is centered at our eye, the hyp
  * goes from our eye to enemy eye, opp is the delta in Y, and adj is the delta in Z
  * (remember Z is forward/backward in CF). Finally this needs to be negated because in CF
  * aiming all the way up is -90 and all the way down is 90 (reversed of what one might think)
  * 
  * For the yaw, use atan2 which has a range of [-180, 180]. Picture, from birds eye view,
  * you at origin and enemy in first quadrant of plane. Can get angle simply by using the 
  * relative enemy position in x and z. For tan we need opp (use dX) and adj (use dZ).
  * Can also switch them and do 90 - (ans) but thats unnecessarily complicating things
  */
  float dist = dV.Length();
  out.x = atan2(dV.x, dV.z);
  out.y = -asin(dV.y / dist);
}

void Game::aimAtPlayer(Player* me, Player* at) {
  float* yaw = (float*)hax::ResolvePtrChain(CLT_SHELL + offs::LOCAL_ENT, { offs::MP_YAW });
  float* pitch = (float*)hax::ResolvePtrChain(CLT_SHELL + offs::LOCAL_ENT, { offs::MP_PITCH });

  Vec2 newAngles;
  GetAnglesToPlayer(me, at, newAngles);
  *yaw = newAngles.x;
  *pitch = newAngles.y;

}

bool Game::CheckInFOV(float angle, Player* me, Player* target)
{
  Vec2 newAngles;
  GetAnglesToPlayer(me, target, newAngles);

  angle /= 2;
  Vec2 curAngles;
  curAngles.x = *(float*)hax::ResolvePtrChain(CLT_SHELL + offs::LOCAL_ENT, { offs::MP_YAW });
  curAngles.y = *(float*)hax::ResolvePtrChain(CLT_SHELL + offs::LOCAL_ENT, { offs::MP_PITCH });

  // Yaw now needs to be 'normalized' meaning map it from (-inf, +inf) (valid values in the game)
  // to (-180, 180) (what atan2 will return to us)
  // So we have to first use modulo to restrict it to maximum 2pi if its positive and -2pi if its negative
  // Now we need to see:
  // if it's greater than PI, map it to its negative equivalent (-360)
  // if it's less than PI, map it to its positive equivalent (+360)

  if (curAngles.x > 2*M_PI) curAngles.x = std::fmod(curAngles.x, 2*M_PI);
  else if (curAngles.x < -2*M_PI) curAngles.x = std::fmod(curAngles.x, -2*M_PI);
  if (curAngles.x > M_PI) curAngles.x -= 2 * M_PI;
  else if (curAngles.x < -M_PI) curAngles.x += 2 * M_PI;

  return (newAngles.y >= (curAngles.y - angle) &&
    newAngles.y <= (curAngles.y + angle) &&
    newAngles.x >= (curAngles.x - angle) &&
    newAngles.x <= (curAngles.x + angle));
}

void Game::FOVAimbot() {
  while (GetAsyncKeyState(VK_LSHIFT)) {
    if (!CLT_SHELL || !InGame()) return;

    BYTE myIdx = *(BYTE*)(CLT_SHELL + offs::LOCAL_ENT_INDEX);
    Player* me = GetPlayerByIndex(myIdx);
    Player* target = nullptr;

    for (int i = 0; i < 16; i++) {
      Player* enem = GetPlayerByIndex(i);
      if (CheckInFOV(0.10, me, enem) && enem->info.team != me->info.team 
                                     && enem->info.health != 0) {
        target = enem;
        break;
      }
    }

    while (GetAsyncKeyState(VK_LSHIFT) && target 
                                       && target->info.health) {
      aimAtPlayer(me, target);
    }

  }
}

```

`game.h`:

```h
#include "geom.h"
#include "utils.h"
#include "offsets.h"
#include "hax.h"
#pragma once

/*      Game Structs        */
struct PlayerModel {
  char unk0[8]; //vTable
  // X: left-/right+ 
  // Y: vertical down-/up+
  // Z: back-/forward+
  Vector3 posF;
  Vector3 posH;
};
struct PlayerInfo {
  __int8 clientID;
  __int8 team;
  char name[12];
  char unk0[46];
  __int32 health;
};
struct Player {
  PlayerModel* model;
  PlayerInfo info;
};
struct LTransform {
  Vector3 m_Vec;
  char unk[2048];
};


template< class type > type GetVFn(PVOID base, SIZE_T index)
{
  DWORD64* vtablefunc = *(DWORD64**)base;
  return (type)(vtablefunc[index]);
}

class CLTModel
{
public:
  uint32_t GetNodeTransform(PlayerModel* hObj, uint32_t hNode, LTransform* transform, bool bWorldSpace)
  {
    typedef uint32_t(__thiscall* oGetNodeTransform)(void*, PlayerModel*, uint32_t, LTransform*, bool);
    return GetVFn<oGetNodeTransform>(this, 15)(this, hObj, hNode, transform, bWorldSpace);
  }
};

class Game {
private:
  Game() {}

public:
  DWORD64 CS_BASE = 0;
  DWORD64 CF_BASE = 0;
  DWORD64 CLT_SHELL = 0;

  CLTModel* pLTModel = 0;

  Game(Game const&) = delete;
  Game& operator=(Game const&) = delete;

  static Game& get() {
    static Game cf;
    return cf;
  }
  
  void init();
  void PrintEntityDbg();
  bool InGame();

  void GetBonePosition(PlayerModel* obj, uint32_t idx, LTransform* tfm);

  Player* GetPlayerByIndex(int i);
  void GetAnglesToPlayer(Player* me, Player* target, Vec2& out);

  void aimAtPlayer(Player* me, Player* at);
  bool CheckInFOV(float angle, Player* me, Player* target);
  void FOVAimbot();
};

```

`geom.h`:

```h
#pragma once
#include <algorithm>
#define M_PI   3.14159265358979323846264338327950288

class Vector3
{
public:

	float x, y, z;

	Vector3() {};
	Vector3(const float x, const float y, const float z) : x(x), y(y), z(z) {}
	Vector3 operator + (const Vector3& rhs) const { return Vector3(x + rhs.x, y + rhs.y, z + rhs.z); }
	Vector3 operator - (const Vector3& rhs) const { return Vector3(x - rhs.x, y - rhs.y, z - rhs.z); }
	Vector3 operator * (const float& rhs) const { return Vector3(x * rhs, y * rhs, z * rhs); }
	Vector3 operator / (const float& rhs) const { return Vector3(x / rhs, y / rhs, z / rhs); }
	Vector3& operator += (const Vector3& rhs) { return *this = *this + rhs; }
	Vector3& operator -= (const Vector3& rhs) { return *this = *this - rhs; }
	Vector3& operator *= (const float& rhs) { return *this = *this * rhs; }
	Vector3& operator /= (const float& rhs) { return *this = *this / rhs; }
	float Length() const { return sqrtf(x * x + y * y + z * z); }
	Vector3 Normalize() const { return *this * (1 / Length()); }
	float Distance(const Vector3& rhs) const { return (*this - rhs).Length(); }
};

struct Vec4
{
	float x, y, z, w;
};
struct Vec2
{
	float x, y;
};




```

`hax.cpp`:

```cpp
#include "pch.h"
#include "hax.h"

void hax::PatchIn(BYTE* dst, BYTE* src, unsigned int size)
{
	DWORD oldprotect;
	VirtualProtect(dst, size, PAGE_EXECUTE_READWRITE, &oldprotect);

	memcpy(dst, src, size);
	VirtualProtect(dst, size, oldprotect, &oldprotect);
}

void hax::PatchEx(BYTE* dst, BYTE* src, unsigned int size, HANDLE hProcess)
{
	DWORD oldprotect;
	VirtualProtectEx(hProcess, dst, size, PAGE_EXECUTE_READWRITE, &oldprotect);

	WriteProcessMemory(hProcess, dst, src, size, nullptr);
	VirtualProtectEx(hProcess, dst, size, oldprotect, &oldprotect);
}

void hax::WriteNop(BYTE* dst, unsigned int size)
{
	DWORD oldprotect;
	VirtualProtect(dst, size, PAGE_EXECUTE_READWRITE, &oldprotect);

	memset(dst, 0x90, size);
	VirtualProtect(dst, size, oldprotect, &oldprotect);
}

void hax::WriteNopEx(BYTE* dst, unsigned int size, HANDLE hProcess)
{
	BYTE* nopArray = new BYTE[size];
	memset(nopArray, 0x90, size);

	PatchEx(dst, nopArray, size, hProcess);
	delete[] nopArray;
}

uintptr_t hax::ResolvePtrChain(uintptr_t base, std::vector<unsigned int> offsets)
{
	uintptr_t addr = base;
	for (unsigned int i = 0; i < offsets.size(); ++i)
	{
		addr = *(uintptr_t*)addr;
		addr += offsets[i];
	}
	return addr;
}

uintptr_t hax::ResolvePtrChainEx(uintptr_t base, std::vector<unsigned int> offsets, HANDLE hProcess)
{
	uintptr_t addr = base;
	for (unsigned int i = 0; i < offsets.size(); ++i)
	{
		ReadProcessMemory(hProcess, (BYTE*)addr, &addr, sizeof(addr), 0);
		addr += offsets[i];
	}
	return addr;
}

bool hax::Detour32In(BYTE* src, BYTE* dst, const uintptr_t len)
{
	if (len < 5) return false;

	DWORD oldptc;
	VirtualProtect(src, len, PAGE_EXECUTE_READWRITE, &oldptc);

	uintptr_t relativeAddress = dst - src - 5; // -5 to get RVA between (original+jmp) and new function

	*src = 0xE9; //jmp
	*(uintptr_t*)(src + 1) = relativeAddress; //add our address immediately after jmp

	VirtualProtect(src, len, oldptc, &oldptc);
	return true;
}
BYTE* hax::TrampHook32In(BYTE* src, BYTE* dst, const uintptr_t len)
{
	if (len < 5) return 0;

	/*
	* Create Gateway
	* (what executes stolen bytes and returns back to original fn)
	*/
	BYTE* gateway = (BYTE*)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	//write the stolen bytes to the gateway
	memcpy_s(gateway, len, src, len);

	//Get the gateway to destination address
	uintptr_t gatewayRelativeAddr = src - gateway - 5;

	// add the jmp opcode to the end of the gateway
	*(gateway + len) = 0xE9;

	//Write the address of the gateway to the jmp
	*(uintptr_t*)((uintptr_t)gateway + len + 1) = gatewayRelativeAddr;

	/*
	* Create Detour
	*/
	Detour32In(src, dst, len);

	// Need this address bc now that we have overwritten
	// original bytes and created a way to resume normal execution,
	// our 'new' function will need to  return to this gateway at the end
	return gateway;
}


void* hax::TrampHook64(void* pSource, void* pDestination, int dwLen)
{
	DWORD MinLen = 14;

	if (dwLen < MinLen) return NULL;

	BYTE stub[] = {
	0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, //  jmp QWORD PTR [rip+0x0] 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // ptr
	};

	void* pTrampoline = VirtualAlloc(NULL, dwLen + sizeof(stub), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	DWORD dwOld = 0;
	VirtualProtect(pSource, dwLen, PAGE_EXECUTE_READWRITE, &dwOld);

	DWORD64 retto = (DWORD64)pSource + dwLen;

	// trampoline
	memcpy(stub + 6, &retto, 8); // copy address of instruction after our jmp from original 
	memcpy((void*)((DWORD_PTR)pTrampoline), pSource, dwLen); // copy stolen bytes into tramp
	memcpy((void*)((DWORD_PTR)pTrampoline + dwLen), stub, sizeof(stub));  // copy return to original 

	// orig
	memcpy(stub + 6, &pDestination, 8); // copy address of our new fn
	memcpy(pSource, stub, sizeof(stub)); // overwrite original with detour 

	for (int i = MinLen; i < dwLen; i++)
	{
		*(BYTE*)((DWORD_PTR)pSource + i) = 0x90;
	}

	VirtualProtect(pSource, dwLen, dwOld, &dwOld);
	return (void*)((DWORD_PTR)pTrampoline);
}
```

`hax.h`:

```h
#pragma once
#include "pch.h"

namespace hax
{
	void PatchIn(BYTE* dst, BYTE* src, unsigned int size);
	void PatchEx(BYTE* dst, BYTE* src, unsigned int size, HANDLE hProcess);

	void WriteNop(BYTE* dst, unsigned int size);
	void WriteNopEx(BYTE* dst, unsigned int size, HANDLE hProcess);

	uintptr_t ResolvePtrChain(uintptr_t base, std::vector<unsigned int> offsets);
	uintptr_t ResolvePtrChainEx(uintptr_t base, std::vector<unsigned int> offsets, HANDLE hProcess);

	bool Detour32In(BYTE* src, BYTE* dst, const uintptr_t len);
	BYTE* TrampHook32In(BYTE* src, BYTE* dst, const uintptr_t len);

	void* TrampHook64(void* pSource, void* pDestination, int dwLen);

}
```

`offsets.h`:

```h
#pragma once
namespace offs {
  // To get signatures, check what accesses the addresses (not the pointers)
  // of the values found, should find instructions where the offsets for 
  // static pointers matches with the static pointer found earlier in CE

  //48 8B ? ? ? ? ? 48 8B ? FF 90 ? ? ? ? 40 3A
  //mov rcx, [cshell_x64.dll + 1BE4890]
  const DWORD LT_SHELL = 0x1BE4890;
  //48 8B ? ? ? ? ? 48 8B ? 44 0F ? ? 44 8B ? ? ? 48 8B ? ? FF 50 ? 44 89
  //mov rcx,[cshell_x64.dll+1BE1470]
  const DWORD LT_MODELCLIENT_PTR = 0x1BE1470;
  //48 8B ? ? ? ? ? 48 8B ? FF 90 ? ? ? ? 48 8B ? 48 8B ? FF 92 ? ? ? ? 48 3B ? 74
  //mov rcx,[rax+00000090]
  const DWORD LOCAL_ENT = 0x90;
  //48 69 C8 ? ? ? ? 48 8B ? ? ? ? ? 4C 8B ? ? ? ? ? ? 48 85
  //imul rcx, rax, 00000D98
  const DWORD ENT_SIZE = 0xD98;
  //4C 8B ? ? ? ? ? ? 48 85 ? 75 ? 8D 4E
  //mov r15, [rcx + rdi + 00000290]
  const DWORD ENT_BEGIN = 0x290; 
  //0F B6 ? ? ? ? ? 41 0F ? ? ? 48 8B
  //movzx ecx, byte ptr[rsi + 00000288]
  const DWORD LOCAL_ENT_INDEX = 0x288; 

  const DWORD BOT_PITCH = 0xE8C;
  const DWORD BOT_YAW = 0xE90;
  const DWORD MP_PITCH = 0x5DC;
  const DWORD MP_YAW = 0x5E0;

}

```

`pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#include "framework.h"


#include <TlHelp32.h>

#include <vector>
#include <iostream>

#include <cstdlib>
#include <math.h>
#include <string>

#endif //PCH_H

```

`utils.h`:

```h
#pragma once

inline void log(std::string_view message) {
  std::cout << "[+] " << message << std::endl;
}
inline void loghex(std::string_view message, DWORD64 x) {
  std::cout << "[+] " << message << std::hex << x << std::endl;
}


```