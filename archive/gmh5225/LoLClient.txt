Project Path: arc_gmh5225_LoLClient_b_gz4myo

Source Tree:

```txt
arc_gmh5225_LoLClient_b_gz4myo
├── LoLClient
│   ├── App.config
│   ├── BlowFish.cs
│   ├── ENet
│   │   ├── Address.cs
│   │   ├── AddressType.cs
│   │   ├── ENetException.cs
│   │   ├── Event.cs
│   │   ├── EventType.cs
│   │   ├── Host.cs
│   │   ├── Library.cs
│   │   ├── Native.Structs.cs
│   │   ├── Native.cs
│   │   ├── Packet.cs
│   │   ├── PacketFlags.cs
│   │   ├── Peer.cs
│   │   └── PeerState.cs
│   ├── Form1.Designer.cs
│   ├── Form1.cs
│   ├── Form1.resx
│   ├── LoLClient.csproj
│   ├── Packets.cs
│   ├── Program.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   └── enet.dll
└── LoLClient.sln

```

`LoLClient.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.21005.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LoLClient", "LoLClient\LoLClient.csproj", "{C699B269-7D07-4CBD-BF73-2E56BDDAFCF6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C699B269-7D07-4CBD-BF73-2E56BDDAFCF6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C699B269-7D07-4CBD-BF73-2E56BDDAFCF6}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C699B269-7D07-4CBD-BF73-2E56BDDAFCF6}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C699B269-7D07-4CBD-BF73-2E56BDDAFCF6}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`LoLClient/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
    </startup>
</configuration>
```

`LoLClient/BlowFish.cs`:

```cs
//Blowfish encryption (ECB, CBC and CTR mode) as defined by Bruce Schneier here: http://www.schneier.com/paper-blowfish-fse.html
//Complies with test vectors found here: http://www.schneier.com/code/vectors.txt
//non-standard mode provided to be usable with the javascript crypto library found here: http://etherhack.co.uk/symmetric/blowfish/blowfish.html
//By Taylor Hornby, 1/7/1010, 
//Code is partly adopted from the javascript crypto library by Daniel Rench

/*USAGE:

Provide the key when creating the object. The key can be any size up to 448 bits.
The key can be given as a hex string or an array of bytes.
  BlowFish b = new BlowFish("04B915BA43FEB5B6");

The plainText can be either a string or byte array.
  string plainText = "The quick brown fox jumped over the lazy dog.";

Use the Encypt_* methods to encrypt the plaintext in the mode that you want.
To Encrypt or decrypt a byte array using CBC or CTR mode, an array of bytes, you must provide an initialization vector.
A random IV can be created by calling SetRandomIV, then accessed with the IV property as it will be required to decrypt the data.
It is safe for the IV to be known by an attacker, as long as it is NEVER reused. IVs are handled automatically when encrypting and decrypting strings.
  string cipherText = b.Encrypt_CBC(plainText);
  MessageBox.Show(cipherText);

Use the same mode of operation for decryption.
  plainText = b.Decrypt_CBC(cipherText);
  MessageBox.Show(plainText);
*/

/*Which mode should I use?
 *---ECB---
 *  ECB mode encrypts each block of data with the same key, so patterns in a large set of data will be visible. 
 *  Encrypting the same data with the same key will result in the same ciphertext. This mode should NOT be used unless neccessary.
 *  
 *---CBC---
 *  CBC mode encrypts each block of data in succession so that any changes in the data will result in a completly different ciphertext.
 *  Also, an IV is used so that encrypting the same data with the same key will result in a different ciphertext. 
 *  CBC mode is the most popular mode of operation.
 *  
 *---CTR---
 *  CTR mode uses an IV and a counter to encrypt each block individually. 
 *  Like ECB mode, with the added protection of an IV to make sure the same plaintext encrypted with the same key yeilds a different result.
 *  The counter ensures that no patterns will be visible. CTR mode is secure and can be optimized for multi-threaded applications.
 * 
 * For more information on cipher modes of operation, see http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation
 */

/*Things to remember
 * -Always use unique initialization vectors when using CBC and CTR mode. SetRandomIV will do the job for you.
 * -Blowfish is only as secure as the key you provide. When derriving a key from a password, use a secure hash function such as SHA-256 to create the key.
 * -Read "Which mode should I use?" and choose the best mode for your application
 * -Use a MAC to ensure that the ciphertext and IV have not been modified.
 * -Do not use the compatibility mode unless neccessary.
 */

using System;
using System.Text;
using System.Security.Cryptography;

namespace LoLClient
{
    class BlowFish
    {
        #region "Global variables and constants"

        const int ROUNDS = 16; //standard is 16, to increase the number of rounds, bf_P needs to be equal to the number of rouds. Use digits of PI.

        //Random number generator for creating IVs
        RNGCryptoServiceProvider randomSource;

        //SBLOCKS
        private uint[] bf_s0;
        private uint[] bf_s1;
        private uint[] bf_s2;
        private uint[] bf_s3;

        private uint[] bf_P;

        //KEY
        private byte[] key;

        //HALF-BLOCKS
        private uint xl_par;
        private uint xr_par;

        //Initialization Vector for CBC and CTR mode
        private byte[] InitVector;
        private bool IVSet;

        //For compatibility with the javascript crypto library:
        //  http://etherhack.co.uk/symmetric/blowfish/blowfish.html
        private bool nonStandardMethod;

        #endregion

        #region "Constructors"

        /// <summary>
        /// Constructor for hex key
        /// </summary>
        /// <param name="hexKey">Cipher key as a hex string</param>
        public BlowFish(string hexKey)
        {
            randomSource = new RNGCryptoServiceProvider();
            SetupKey(HexToByte(hexKey));
        }

        /// <summary>
        /// Constructor for byte key
        /// </summary>
        /// <param name="cipherKey">Cipher key as a byte array</param>
        public BlowFish(byte[] cipherKey)
        {
            randomSource = new RNGCryptoServiceProvider();
            SetupKey(cipherKey);
        }

        #endregion

        #region "Public methods"

        /// <summary>
        /// Encrypts a string in CBC mode
        /// </summary>
        /// <param name="pt">Plaintext data to encrypt</param>
        /// <returns>Ciphertext with IV appended to front</returns>
        public string Encrypt_CBC(string pt)
        {
            if (!IVSet)
                SetRandomIV();
            return ByteToHex(InitVector) + ByteToHex(Encrypt_CBC(Encoding.ASCII.GetBytes(pt)));
        }

        /// <summary>
        /// Decrypts a string in CBC mode
        /// </summary>
        /// <param name="ct">Ciphertext with IV appended to front</param>
        /// <returns>Plaintext</returns>
        public string Decrypt_CBC(string ct)
        {
            IV = HexToByte(ct.Substring(0, 16));
            return Encoding.ASCII.GetString(Decrypt_CBC(HexToByte(ct.Substring(16)))).Replace("\0", "");
        }

        /// <summary>
        /// Decrypts a byte array in CBC mode.
        /// IV must be created and saved manually.
        /// </summary>
        /// <param name="ct">Ciphertext data to decrypt</param>
        /// <returns>Plaintext</returns>
        public byte[] Decrypt_CBC(byte[] ct)
        {
            return Crypt_CBC(ct, true);
        }

        /// <summary>
        /// Encrypts a byte array in CBC mode.
        /// IV must be created and saved manually.
        /// </summary>
        /// <param name="pt">Plaintext data to encrypt</param>
        /// <returns>Ciphertext</returns>
        public byte[] Encrypt_CBC(byte[] pt)
        {
            return Crypt_CBC(pt, false);
        }

        /// <summary>
        /// Encrypt a string in ECB mode
        /// </summary>
        /// <param name="pt">Plaintext to encrypt as ascii string</param>
        /// <returns>hex value of encrypted data</returns>
        public string Encrypt_ECB(string pt)
        {
            return ByteToHex(Encrypt_ECB(Encoding.ASCII.GetBytes(pt)));
        }

        /// <summary>
        /// Decrypts a string (ECB)
        /// </summary>
        /// <param name="ct">hHex string of the ciphertext</param>
        /// <returns>Plaintext ascii string</returns>
        public string Decrypt_ECB(string ct)
        {
            return Encoding.ASCII.GetString(Decrypt_ECB(HexToByte(ct)));//.Replace("\0", "");
        }

        /// <summary>
        /// Encrypts a byte array in ECB mode
        /// </summary>
        /// <param name="pt">Plaintext data</param>
        /// <returns>Ciphertext bytes</returns>
        public byte[] Encrypt_ECB(byte[] pt)
        {
            return Crypt_ECB(pt, false);
        }

        /// <summary>
        /// Encrypts a byte array in ECB mode
        /// </summary>
        /// <param name="pt">Plaintext data</param>
        /// <returns>Ciphertext bytes</returns>
        public UInt64 Encrypt_ECB(UInt64 pt)
        {
            return BitConverter.ToUInt64(Encrypt_ECB(BitConverter.GetBytes(pt)),0);
        }

        /// <summary>
        /// Decrypts a byte array (ECB)
        /// </summary>
        /// <param name="ct">Ciphertext byte array</param>
        /// <returns>Plaintext</returns>
        public byte[] Decrypt_ECB(byte[] ct)
        {
            return Crypt_ECB(ct, true);
        }

        /// <summary>
        /// Encrypts a string (CTR)
        /// </summary>
        /// <param name="pt">The plaintext to encrypt</param>
        /// <returns>The ciphertext</returns>
        public string Encrypt_CTR(string pt)
        {
            if (!IVSet)
                SetRandomIV();
            return ByteToHex(InitVector) + ByteToHex(Crypt_CTR(Encoding.ASCII.GetBytes(pt), 2));
        }

        /// <summary>
        /// Decrypt a string (CTR)
        /// </summary>
        /// <param name="ct">The ciphertext to decrypt</param>
        /// <returns>The plaintext</returns>
        public string Decrypt_CTR(string ct)
        {
            IV = HexToByte(ct.Substring(0, 16));
            return Encoding.ASCII.GetString(Crypt_CTR(HexToByte(ct.Substring(16)), 2)).Replace("\0", "");
        }

        /// <summary>
        /// Initialization vector for CBC mode.
        /// </summary>
        public byte[] IV
        {
            get { return InitVector; }
            set
            {
                if (value.Length == 8)
                {
                    InitVector = value;
                    IVSet = true;
                }
                else
                {
                    throw new Exception("Invalid IV size.");
                }
            }
        }

        public bool NonStandard
        {
            get { return nonStandardMethod; }
            set { nonStandardMethod = value; }
        }

        /// <summary>
        /// Creates and sets a random initialization vector.
        /// </summary>
        /// <returns>The random IV</returns>
        public byte[] SetRandomIV()
        {
            InitVector = new byte[8];
            randomSource.GetBytes(InitVector);
            IVSet = true;
            return InitVector;
        }

        #endregion

        #region Cryptography

        /// <summary>
        /// Sets up the S-blocks and the key
        /// </summary>
        /// <param name="cipherKey">Block cipher key (1-448 bits)</param>
        private void SetupKey(byte[] cipherKey)
        {
            bf_P = SetupP();
            //set up the S blocks
            bf_s0 = SetupS0();
            bf_s1 = SetupS1();
            bf_s2 = SetupS2();
            bf_s3 = SetupS3();

            key = new byte[cipherKey.Length]; // 448 bits
            if (cipherKey.Length > 56)
            {
                throw new Exception("Key too long. 56 bytes required.");
            }

            Buffer.BlockCopy(cipherKey, 0, key, 0, cipherKey.Length);
            int j = 0;
            for (int i = 0; i < 18; i++)
            {
                uint d = (uint)(((key[j % cipherKey.Length] * 256 + key[(j + 1) % cipherKey.Length]) * 256 + key[(j + 2) % cipherKey.Length]) * 256 + key[(j + 3) % cipherKey.Length]);
                bf_P[i] ^= d;
                j = (j + 4) % cipherKey.Length;
            }

            xl_par = 0;
            xr_par = 0;
            for (int i = 0; i < 18; i += 2)
            {
                encipher();
                bf_P[i] = xl_par;
                bf_P[i + 1] = xr_par;
            }

            for (int i = 0; i < 256; i += 2)
            {
                encipher();
                bf_s0[i] = xl_par;
                bf_s0[i + 1] = xr_par;
            }
            for (int i = 0; i < 256; i += 2)
            {
                encipher();
                bf_s1[i] = xl_par;
                bf_s1[i + 1] = xr_par;
            }
            for (int i = 0; i < 256; i += 2)
            {
                encipher();
                bf_s2[i] = xl_par;
                bf_s2[i + 1] = xr_par;
            }
            for (int i = 0; i < 256; i += 2)
            {
                encipher();
                bf_s3[i] = xl_par;
                bf_s3[i + 1] = xr_par;
            }
        }

        /// <summary>
        /// Encrypts or decrypts data in ECB mode
        /// </summary>
        /// <param name="text">plain/ciphertext</param>
        /// <param name="decrypt">true to decrypt, false to encrypt</param>
        /// <returns>(En/De)crypted data</returns>
        private byte[] Crypt_ECB(byte[] text, bool decrypt)
        {
            byte[] trunctext = new byte[text.Length - text.Length % 8];
            Array.Copy(text, trunctext, trunctext.Length);

            int paddedLen = (trunctext.Length % 8 == 0 ? trunctext.Length : trunctext.Length + 8 - (trunctext.Length % 8));
            byte[] plainText = new byte[paddedLen];
            Buffer.BlockCopy(trunctext, 0, plainText, 0, trunctext.Length);
            byte[] block = new byte[8];
            for (int i = 0; i < plainText.Length; i += 8)
            {
                Buffer.BlockCopy(plainText, i, block, 0, 8);
                if (decrypt)
                {
                    BlockDecrypt(ref block);
                }
                else
                {
                    BlockEncrypt(ref block);
                }
                Buffer.BlockCopy(block, 0, plainText, i, 8);
            }
            Array.Copy(plainText, text, plainText.Length);
            return text;
        }

        public byte[] Crypt_CTR(byte[] text, int numThreads)
        {
            if (!IVSet)
            {
                throw new Exception("IV not set.");
            }
            byte[] input = new byte[8];
            byte[] counter = new byte[8];
            int paddedLen = (text.Length % 8 == 0 ? text.Length : text.Length + 8 - (text.Length % 8));
            byte[] plainText = new byte[paddedLen];
            Buffer.BlockCopy(text, 0, plainText, 0, text.Length);
            byte[] block = new byte[8];
            for (int i = 0; i < plainText.Length; i += 8)
            {
                for (int x = 0; x < 8; x++)
                {
                    input[x] = (byte)(counter[x] ^ InitVector[x]);
                }
                Buffer.BlockCopy(plainText, i, block, 0, 8);
                BlockEncrypt(ref input);
                XorBlock(ref block, input);
                Buffer.BlockCopy(block, 0, plainText, i, 8);
            }
            return plainText;
        }

        /// <summary>
        /// Encrypts or decrypts data in CBC mode
        /// </summary>
        /// <param name="text">plain/ciphertext</param>
        /// <param name="decrypt">true to decrypt, false to encrypt</param>
        /// <returns>(En/De)crypted data</returns>
        private byte[] Crypt_CBC(byte[] text, bool decrypt)
        {
            if (!IVSet)
            {
                throw new Exception("IV not set.");
            }
            int paddedLen = (text.Length % 8 == 0 ? text.Length : text.Length + 8 - (text.Length % 8));
            byte[] plainText = new byte[paddedLen];
            Buffer.BlockCopy(text, 0, plainText, 0, text.Length);
            byte[] block = new byte[8];
            byte[] preblock = new byte[8];
            byte[] iv = new byte[8];
            Buffer.BlockCopy(InitVector, 0, iv, 0, 8);
            if (!decrypt)
            {
                for (int i = 0; i < plainText.Length; i += 8)
                {
                    Buffer.BlockCopy(plainText, i, block, 0, 8);
                    XorBlock(ref block, iv);
                    BlockEncrypt(ref block);
                    Buffer.BlockCopy(block, 0, iv, 0, 8);
                    Buffer.BlockCopy(block, 0, plainText, i, 8);
                }
            }
            else
            {
                for (int i = 0; i < plainText.Length; i += 8)
                {
                    Buffer.BlockCopy(plainText, i, block, 0, 8);

                    Buffer.BlockCopy(block, 0, preblock, 0, 8);
                    BlockDecrypt(ref block);
                    XorBlock(ref block, iv);
                    Buffer.BlockCopy(preblock, 0, iv, 0, 8);

                    Buffer.BlockCopy(block, 0, plainText, i, 8);
                }
            }
            return plainText;
        }

        /// <summary>
        /// XoR encrypts two 8 bit blocks
        /// </summary>
        /// <param name="block">8 bit block 1</param>
        /// <param name="iv">8 bit block 2</param>
        private void XorBlock(ref byte[] block, byte[] iv)
        {
            for (int i = 0; i < block.Length; i++)
            {
                block[i] ^= iv[i];
            }
        }

        /// <summary>
        /// Encrypts a 64 bit block
        /// </summary>
        /// <param name="block">The 64 bit block to encrypt</param>
        private void BlockEncrypt(ref byte[] block)
        {
            SetBlock(block);
            encipher();
            GetBlock(ref block);
        }

        /// <summary>
        /// Decrypts a 64 bit block
        /// </summary>
        /// <param name="block">The 64 bit block to decrypt</param>
        private void BlockDecrypt(ref byte[] block)
        {
            SetBlock(block);
            decipher();
            GetBlock(ref block);
        }

        /// <summary>
        /// Splits the block into the two uint values
        /// </summary>
        /// <param name="block">the 64 bit block to setup</param>
        private void SetBlock(byte[] block)
        {
            byte[] block1 = new byte[4];
            byte[] block2 = new byte[4];
            Buffer.BlockCopy(block, 0, block1, 0, 4);
            Buffer.BlockCopy(block, 4, block2, 0, 4);
            //split the block
            if (nonStandardMethod)
            {
                xr_par = BitConverter.ToUInt32(block1, 0);
                xl_par = BitConverter.ToUInt32(block2, 0);
            }
            else
            {
                //ToUInt32 requires the bytes in reverse order
                Array.Reverse(block1);
                Array.Reverse(block2);
                xl_par = BitConverter.ToUInt32(block1, 0);
                xr_par = BitConverter.ToUInt32(block2, 0);
            }
        }

        /// <summary>
        /// Converts the two uint values into a 64 bit block
        /// </summary>
        /// <param name="block">64 bit buffer to receive the block</param>
        private void GetBlock(ref byte[] block)
        {
            byte[] block1 = new byte[4];
            byte[] block2 = new byte[4];
            if (nonStandardMethod)
            {
                block1 = BitConverter.GetBytes(xr_par);
                block2 = BitConverter.GetBytes(xl_par);
            }
            else
            {
                block1 = BitConverter.GetBytes(xl_par);
                block2 = BitConverter.GetBytes(xr_par);

                //GetBytes returns the bytes in reverse order
                Array.Reverse(block1);
                Array.Reverse(block2);
            }
            //join the block
            Buffer.BlockCopy(block1, 0, block, 0, 4);
            Buffer.BlockCopy(block2, 0, block, 4, 4);
        }

        /// <summary>
        /// Runs the blowfish algorithm (standard 16 rounds)
        /// </summary>
        private void encipher()
        {
            xl_par ^= bf_P[0];
            for (uint i = 0; i < ROUNDS; i += 2)
            {
                xr_par = round(xr_par, xl_par, i + 1);
                xl_par = round(xl_par, xr_par, i + 2);
            }
            xr_par = xr_par ^ bf_P[17];

            //swap the blocks
            uint swap = xl_par;
            xl_par = xr_par;
            xr_par = swap;
        }

        /// <summary>
        /// Runs the blowfish algorithm in reverse (standard 16 rounds)
        /// </summary>
        private void decipher()
        {
            xl_par ^= bf_P[17];
            for (uint i = 16; i > 0; i -= 2)
            {
                xr_par = round(xr_par, xl_par, i);
                xl_par = round(xl_par, xr_par, i - 1);
            }
            xr_par = xr_par ^ bf_P[0];

            //swap the blocks
            uint swap = xl_par;
            xl_par = xr_par;
            xr_par = swap;
        }

        /// <summary>
        /// one round of the blowfish algorithm
        /// </summary>
        /// <param name="a">See spec</param>
        /// <param name="b">See spec</param>
        /// <param name="n">See spec</param>
        /// <returns></returns>
        private uint round(uint a, uint b, uint n)
        {
            uint x1 = (bf_s0[wordByte0(b)] + bf_s1[wordByte1(b)]) ^ bf_s2[wordByte2(b)];
            uint x2 = x1 + bf_s3[this.wordByte3(b)];
            uint x3 = x2 ^ bf_P[n];
            return x3 ^ a;
        }

        #endregion

        #region SBLOCKS
        //SBLOCKS ARE THE HEX DIGITS OF PI. 
        //The amount of hex digits can be increased if you want to experiment with more rounds and longer key lengths

        //Increase the size of this array when increasing the number of rounds
        private uint[] SetupP()
        {
            return new uint[] {
                0x243f6a88,0x85a308d3,0x13198a2e,0x03707344,0xa4093822,0x299f31d0,
                    0x082efa98,0xec4e6c89,0x452821e6,0x38d01377,0xbe5466cf,0x34e90c6c,
                    0xc0ac29b7,0xc97c50dd,0x3f84d5b5,0xb5470917,0x9216d5d9,0x8979fb1b
            };
        }

        private uint[] SetupS0()
        {
            return new uint[] {
                    0xd1310ba6,0x98dfb5ac,0x2ffd72db,0xd01adfb7,0xb8e1afed,0x6a267e96,
                    0xba7c9045,0xf12c7f99,0x24a19947,0xb3916cf7,0x0801f2e2,0x858efc16,
                    0x636920d8,0x71574e69,0xa458fea3,0xf4933d7e,0x0d95748f,0x728eb658,
                    0x718bcd58,0x82154aee,0x7b54a41d,0xc25a59b5,0x9c30d539,0x2af26013,
                    0xc5d1b023,0x286085f0,0xca417918,0xb8db38ef,0x8e79dcb0,0x603a180e,
                    0x6c9e0e8b,0xb01e8a3e,0xd71577c1,0xbd314b27,0x78af2fda,0x55605c60,
                    0xe65525f3,0xaa55ab94,0x57489862,0x63e81440,0x55ca396a,0x2aab10b6,
                    0xb4cc5c34,0x1141e8ce,0xa15486af,0x7c72e993,0xb3ee1411,0x636fbc2a,
                    0x2ba9c55d,0x741831f6,0xce5c3e16,0x9b87931e,0xafd6ba33,0x6c24cf5c,
                    0x7a325381,0x28958677,0x3b8f4898,0x6b4bb9af,0xc4bfe81b,0x66282193,
                    0x61d809cc,0xfb21a991,0x487cac60,0x5dec8032,0xef845d5d,0xe98575b1,
                    0xdc262302,0xeb651b88,0x23893e81,0xd396acc5,0x0f6d6ff3,0x83f44239,
                    0x2e0b4482,0xa4842004,0x69c8f04a,0x9e1f9b5e,0x21c66842,0xf6e96c9a,
                    0x670c9c61,0xabd388f0,0x6a51a0d2,0xd8542f68,0x960fa728,0xab5133a3,
                    0x6eef0b6c,0x137a3be4,0xba3bf050,0x7efb2a98,0xa1f1651d,0x39af0176,
                    0x66ca593e,0x82430e88,0x8cee8619,0x456f9fb4,0x7d84a5c3,0x3b8b5ebe,
                    0xe06f75d8,0x85c12073,0x401a449f,0x56c16aa6,0x4ed3aa62,0x363f7706,
                    0x1bfedf72,0x429b023d,0x37d0d724,0xd00a1248,0xdb0fead3,0x49f1c09b,
                    0x075372c9,0x80991b7b,0x25d479d8,0xf6e8def7,0xe3fe501a,0xb6794c3b,
                    0x976ce0bd,0x04c006ba,0xc1a94fb6,0x409f60c4,0x5e5c9ec2,0x196a2463,
                    0x68fb6faf,0x3e6c53b5,0x1339b2eb,0x3b52ec6f,0x6dfc511f,0x9b30952c,
                    0xcc814544,0xaf5ebd09,0xbee3d004,0xde334afd,0x660f2807,0x192e4bb3,
                    0xc0cba857,0x45c8740f,0xd20b5f39,0xb9d3fbdb,0x5579c0bd,0x1a60320a,
                    0xd6a100c6,0x402c7279,0x679f25fe,0xfb1fa3cc,0x8ea5e9f8,0xdb3222f8,
                    0x3c7516df,0xfd616b15,0x2f501ec8,0xad0552ab,0x323db5fa,0xfd238760,
                    0x53317b48,0x3e00df82,0x9e5c57bb,0xca6f8ca0,0x1a87562e,0xdf1769db,
                    0xd542a8f6,0x287effc3,0xac6732c6,0x8c4f5573,0x695b27b0,0xbbca58c8,
                    0xe1ffa35d,0xb8f011a0,0x10fa3d98,0xfd2183b8,0x4afcb56c,0x2dd1d35b,
                    0x9a53e479,0xb6f84565,0xd28e49bc,0x4bfb9790,0xe1ddf2da,0xa4cb7e33,
                    0x62fb1341,0xcee4c6e8,0xef20cada,0x36774c01,0xd07e9efe,0x2bf11fb4,
                    0x95dbda4d,0xae909198,0xeaad8e71,0x6b93d5a0,0xd08ed1d0,0xafc725e0,
                    0x8e3c5b2f,0x8e7594b7,0x8ff6e2fb,0xf2122b64,0x8888b812,0x900df01c,
                    0x4fad5ea0,0x688fc31c,0xd1cff191,0xb3a8c1ad,0x2f2f2218,0xbe0e1777,
                    0xea752dfe,0x8b021fa1,0xe5a0cc0f,0xb56f74e8,0x18acf3d6,0xce89e299,
                    0xb4a84fe0,0xfd13e0b7,0x7cc43b81,0xd2ada8d9,0x165fa266,0x80957705,
                    0x93cc7314,0x211a1477,0xe6ad2065,0x77b5fa86,0xc75442f5,0xfb9d35cf,
                    0xebcdaf0c,0x7b3e89a0,0xd6411bd3,0xae1e7e49,0x00250e2d,0x2071b35e,
                    0x226800bb,0x57b8e0af,0x2464369b,0xf009b91e,0x5563911d,0x59dfa6aa,
                    0x78c14389,0xd95a537f,0x207d5ba2,0x02e5b9c5,0x83260376,0x6295cfa9,
                    0x11c81968,0x4e734a41,0xb3472dca,0x7b14a94a,0x1b510052,0x9a532915,
                    0xd60f573f,0xbc9bc6e4,0x2b60a476,0x81e67400,0x08ba6fb5,0x571be91f,
                    0xf296ec6b,0x2a0dd915,0xb6636521,0xe7b9f9b6,0xff34052e,0xc5855664,
                    0x53b02d5d,0xa99f8fa1,0x08ba4799,0x6e85076a
            };
        }

        private uint[] SetupS1()
        {
            return new uint[] {
                0x4b7a70e9,0xb5b32944,0xdb75092e,0xc4192623,0xad6ea6b0,0x49a7df7d,
                    0x9cee60b8,0x8fedb266,0xecaa8c71,0x699a17ff,0x5664526c,0xc2b19ee1,
                    0x193602a5,0x75094c29,0xa0591340,0xe4183a3e,0x3f54989a,0x5b429d65,
                    0x6b8fe4d6,0x99f73fd6,0xa1d29c07,0xefe830f5,0x4d2d38e6,0xf0255dc1,
                    0x4cdd2086,0x8470eb26,0x6382e9c6,0x021ecc5e,0x09686b3f,0x3ebaefc9,
                    0x3c971814,0x6b6a70a1,0x687f3584,0x52a0e286,0xb79c5305,0xaa500737,
                    0x3e07841c,0x7fdeae5c,0x8e7d44ec,0x5716f2b8,0xb03ada37,0xf0500c0d,
                    0xf01c1f04,0x0200b3ff,0xae0cf51a,0x3cb574b2,0x25837a58,0xdc0921bd,
                    0xd19113f9,0x7ca92ff6,0x94324773,0x22f54701,0x3ae5e581,0x37c2dadc,
                    0xc8b57634,0x9af3dda7,0xa9446146,0x0fd0030e,0xecc8c73e,0xa4751e41,
                    0xe238cd99,0x3bea0e2f,0x3280bba1,0x183eb331,0x4e548b38,0x4f6db908,
                    0x6f420d03,0xf60a04bf,0x2cb81290,0x24977c79,0x5679b072,0xbcaf89af,
                    0xde9a771f,0xd9930810,0xb38bae12,0xdccf3f2e,0x5512721f,0x2e6b7124,
                    0x501adde6,0x9f84cd87,0x7a584718,0x7408da17,0xbc9f9abc,0xe94b7d8c,
                    0xec7aec3a,0xdb851dfa,0x63094366,0xc464c3d2,0xef1c1847,0x3215d908,
                    0xdd433b37,0x24c2ba16,0x12a14d43,0x2a65c451,0x50940002,0x133ae4dd,
                    0x71dff89e,0x10314e55,0x81ac77d6,0x5f11199b,0x043556f1,0xd7a3c76b,
                    0x3c11183b,0x5924a509,0xf28fe6ed,0x97f1fbfa,0x9ebabf2c,0x1e153c6e,
                    0x86e34570,0xeae96fb1,0x860e5e0a,0x5a3e2ab3,0x771fe71c,0x4e3d06fa,
                    0x2965dcb9,0x99e71d0f,0x803e89d6,0x5266c825,0x2e4cc978,0x9c10b36a,
                    0xc6150eba,0x94e2ea78,0xa5fc3c53,0x1e0a2df4,0xf2f74ea7,0x361d2b3d,
                    0x1939260f,0x19c27960,0x5223a708,0xf71312b6,0xebadfe6e,0xeac31f66,
                    0xe3bc4595,0xa67bc883,0xb17f37d1,0x018cff28,0xc332ddef,0xbe6c5aa5,
                    0x65582185,0x68ab9802,0xeecea50f,0xdb2f953b,0x2aef7dad,0x5b6e2f84,
                    0x1521b628,0x29076170,0xecdd4775,0x619f1510,0x13cca830,0xeb61bd96,
                    0x0334fe1e,0xaa0363cf,0xb5735c90,0x4c70a239,0xd59e9e0b,0xcbaade14,
                    0xeecc86bc,0x60622ca7,0x9cab5cab,0xb2f3846e,0x648b1eaf,0x19bdf0ca,
                    0xa02369b9,0x655abb50,0x40685a32,0x3c2ab4b3,0x319ee9d5,0xc021b8f7,
                    0x9b540b19,0x875fa099,0x95f7997e,0x623d7da8,0xf837889a,0x97e32d77,
                    0x11ed935f,0x16681281,0x0e358829,0xc7e61fd6,0x96dedfa1,0x7858ba99,
                    0x57f584a5,0x1b227263,0x9b83c3ff,0x1ac24696,0xcdb30aeb,0x532e3054,
                    0x8fd948e4,0x6dbc3128,0x58ebf2ef,0x34c6ffea,0xfe28ed61,0xee7c3c73,
                    0x5d4a14d9,0xe864b7e3,0x42105d14,0x203e13e0,0x45eee2b6,0xa3aaabea,
                    0xdb6c4f15,0xfacb4fd0,0xc742f442,0xef6abbb5,0x654f3b1d,0x41cd2105,
                    0xd81e799e,0x86854dc7,0xe44b476a,0x3d816250,0xcf62a1f2,0x5b8d2646,
                    0xfc8883a0,0xc1c7b6a3,0x7f1524c3,0x69cb7492,0x47848a0b,0x5692b285,
                    0x095bbf00,0xad19489d,0x1462b174,0x23820e00,0x58428d2a,0x0c55f5ea,
                    0x1dadf43e,0x233f7061,0x3372f092,0x8d937e41,0xd65fecf1,0x6c223bdb,
                    0x7cde3759,0xcbee7460,0x4085f2a7,0xce77326e,0xa6078084,0x19f8509e,
                    0xe8efd855,0x61d99735,0xa969a7aa,0xc50c06c2,0x5a04abfc,0x800bcadc,
                    0x9e447a2e,0xc3453484,0xfdd56705,0x0e1e9ec9,0xdb73dbd3,0x105588cd,
                    0x675fda79,0xe3674340,0xc5c43465,0x713e38d8,0x3d28f89e,0xf16dff20,
                    0x153e21e7,0x8fb03d4a,0xe6e39f2b,0xdb83adf7
            };
        }

        private uint[] SetupS2()
        {
            return new uint[] {
                0xe93d5a68,0x948140f7,0xf64c261c,0x94692934,0x411520f7,0x7602d4f7,
                    0xbcf46b2e,0xd4a20068,0xd4082471,0x3320f46a,0x43b7d4b7,0x500061af,
                    0x1e39f62e,0x97244546,0x14214f74,0xbf8b8840,0x4d95fc1d,0x96b591af,
                    0x70f4ddd3,0x66a02f45,0xbfbc09ec,0x03bd9785,0x7fac6dd0,0x31cb8504,
                    0x96eb27b3,0x55fd3941,0xda2547e6,0xabca0a9a,0x28507825,0x530429f4,
                    0x0a2c86da,0xe9b66dfb,0x68dc1462,0xd7486900,0x680ec0a4,0x27a18dee,
                    0x4f3ffea2,0xe887ad8c,0xb58ce006,0x7af4d6b6,0xaace1e7c,0xd3375fec,
                    0xce78a399,0x406b2a42,0x20fe9e35,0xd9f385b9,0xee39d7ab,0x3b124e8b,
                    0x1dc9faf7,0x4b6d1856,0x26a36631,0xeae397b2,0x3a6efa74,0xdd5b4332,
                    0x6841e7f7,0xca7820fb,0xfb0af54e,0xd8feb397,0x454056ac,0xba489527,
                    0x55533a3a,0x20838d87,0xfe6ba9b7,0xd096954b,0x55a867bc,0xa1159a58,
                    0xcca92963,0x99e1db33,0xa62a4a56,0x3f3125f9,0x5ef47e1c,0x9029317c,
                    0xfdf8e802,0x04272f70,0x80bb155c,0x05282ce3,0x95c11548,0xe4c66d22,
                    0x48c1133f,0xc70f86dc,0x07f9c9ee,0x41041f0f,0x404779a4,0x5d886e17,
                    0x325f51eb,0xd59bc0d1,0xf2bcc18f,0x41113564,0x257b7834,0x602a9c60,
                    0xdff8e8a3,0x1f636c1b,0x0e12b4c2,0x02e1329e,0xaf664fd1,0xcad18115,
                    0x6b2395e0,0x333e92e1,0x3b240b62,0xeebeb922,0x85b2a20e,0xe6ba0d99,
                    0xde720c8c,0x2da2f728,0xd0127845,0x95b794fd,0x647d0862,0xe7ccf5f0,
                    0x5449a36f,0x877d48fa,0xc39dfd27,0xf33e8d1e,0x0a476341,0x992eff74,
                    0x3a6f6eab,0xf4f8fd37,0xa812dc60,0xa1ebddf8,0x991be14c,0xdb6e6b0d,
                    0xc67b5510,0x6d672c37,0x2765d43b,0xdcd0e804,0xf1290dc7,0xcc00ffa3,
                    0xb5390f92,0x690fed0b,0x667b9ffb,0xcedb7d9c,0xa091cf0b,0xd9155ea3,
                    0xbb132f88,0x515bad24,0x7b9479bf,0x763bd6eb,0x37392eb3,0xcc115979,
                    0x8026e297,0xf42e312d,0x6842ada7,0xc66a2b3b,0x12754ccc,0x782ef11c,
                    0x6a124237,0xb79251e7,0x06a1bbe6,0x4bfb6350,0x1a6b1018,0x11caedfa,
                    0x3d25bdd8,0xe2e1c3c9,0x44421659,0x0a121386,0xd90cec6e,0xd5abea2a,
                    0x64af674e,0xda86a85f,0xbebfe988,0x64e4c3fe,0x9dbc8057,0xf0f7c086,
                    0x60787bf8,0x6003604d,0xd1fd8346,0xf6381fb0,0x7745ae04,0xd736fccc,
                    0x83426b33,0xf01eab71,0xb0804187,0x3c005e5f,0x77a057be,0xbde8ae24,
                    0x55464299,0xbf582e61,0x4e58f48f,0xf2ddfda2,0xf474ef38,0x8789bdc2,
                    0x5366f9c3,0xc8b38e74,0xb475f255,0x46fcd9b9,0x7aeb2661,0x8b1ddf84,
                    0x846a0e79,0x915f95e2,0x466e598e,0x20b45770,0x8cd55591,0xc902de4c,
                    0xb90bace1,0xbb8205d0,0x11a86248,0x7574a99e,0xb77f19b6,0xe0a9dc09,
                    0x662d09a1,0xc4324633,0xe85a1f02,0x09f0be8c,0x4a99a025,0x1d6efe10,
                    0x1ab93d1d,0x0ba5a4df,0xa186f20f,0x2868f169,0xdcb7da83,0x573906fe,
                    0xa1e2ce9b,0x4fcd7f52,0x50115e01,0xa70683fa,0xa002b5c4,0x0de6d027,
                    0x9af88c27,0x773f8641,0xc3604c06,0x61a806b5,0xf0177a28,0xc0f586e0,
                    0x006058aa,0x30dc7d62,0x11e69ed7,0x2338ea63,0x53c2dd94,0xc2c21634,
                    0xbbcbee56,0x90bcb6de,0xebfc7da1,0xce591d76,0x6f05e409,0x4b7c0188,
                    0x39720a3d,0x7c927c24,0x86e3725f,0x724d9db9,0x1ac15bb4,0xd39eb8fc,
                    0xed545578,0x08fca5b5,0xd83d7cd3,0x4dad0fc4,0x1e50ef5e,0xb161e6f8,
                    0xa28514d9,0x6c51133c,0x6fd5c7e7,0x56e14ec4,0x362abfce,0xddc6c837,
                    0xd79a3234,0x92638212,0x670efa8e,0x406000e0
            };
        }

        private uint[] SetupS3()
        {
            return new uint[] {
                    0x3a39ce37,0xd3faf5cf,0xabc27737,0x5ac52d1b,0x5cb0679e,0x4fa33742,
                    0xd3822740,0x99bc9bbe,0xd5118e9d,0xbf0f7315,0xd62d1c7e,0xc700c47b,
                    0xb78c1b6b,0x21a19045,0xb26eb1be,0x6a366eb4,0x5748ab2f,0xbc946e79,
                    0xc6a376d2,0x6549c2c8,0x530ff8ee,0x468dde7d,0xd5730a1d,0x4cd04dc6,
                    0x2939bbdb,0xa9ba4650,0xac9526e8,0xbe5ee304,0xa1fad5f0,0x6a2d519a,
                    0x63ef8ce2,0x9a86ee22,0xc089c2b8,0x43242ef6,0xa51e03aa,0x9cf2d0a4,
                    0x83c061ba,0x9be96a4d,0x8fe51550,0xba645bd6,0x2826a2f9,0xa73a3ae1,
                    0x4ba99586,0xef5562e9,0xc72fefd3,0xf752f7da,0x3f046f69,0x77fa0a59,
                    0x80e4a915,0x87b08601,0x9b09e6ad,0x3b3ee593,0xe990fd5a,0x9e34d797,
                    0x2cf0b7d9,0x022b8b51,0x96d5ac3a,0x017da67d,0xd1cf3ed6,0x7c7d2d28,
                    0x1f9f25cf,0xadf2b89b,0x5ad6b472,0x5a88f54c,0xe029ac71,0xe019a5e6,
                    0x47b0acfd,0xed93fa9b,0xe8d3c48d,0x283b57cc,0xf8d56629,0x79132e28,
                    0x785f0191,0xed756055,0xf7960e44,0xe3d35e8c,0x15056dd4,0x88f46dba,
                    0x03a16125,0x0564f0bd,0xc3eb9e15,0x3c9057a2,0x97271aec,0xa93a072a,
                    0x1b3f6d9b,0x1e6321f5,0xf59c66fb,0x26dcf319,0x7533d928,0xb155fdf5,
                    0x03563482,0x8aba3cbb,0x28517711,0xc20ad9f8,0xabcc5167,0xccad925f,
                    0x4de81751,0x3830dc8e,0x379d5862,0x9320f991,0xea7a90c2,0xfb3e7bce,
                    0x5121ce64,0x774fbe32,0xa8b6e37e,0xc3293d46,0x48de5369,0x6413e680,
                    0xa2ae0810,0xdd6db224,0x69852dfd,0x09072166,0xb39a460a,0x6445c0dd,
                    0x586cdecf,0x1c20c8ae,0x5bbef7dd,0x1b588d40,0xccd2017f,0x6bb4e3bb,
                    0xdda26a7e,0x3a59ff45,0x3e350a44,0xbcb4cdd5,0x72eacea8,0xfa6484bb,
                    0x8d6612ae,0xbf3c6f47,0xd29be463,0x542f5d9e,0xaec2771b,0xf64e6370,
                    0x740e0d8d,0xe75b1357,0xf8721671,0xaf537d5d,0x4040cb08,0x4eb4e2cc,
                    0x34d2466a,0x0115af84,0xe1b00428,0x95983a1d,0x06b89fb4,0xce6ea048,
                    0x6f3f3b82,0x3520ab82,0x011a1d4b,0x277227f8,0x611560b1,0xe7933fdc,
                    0xbb3a792b,0x344525bd,0xa08839e1,0x51ce794b,0x2f32c9b7,0xa01fbac9,
                    0xe01cc87e,0xbcc7d1f6,0xcf0111c3,0xa1e8aac7,0x1a908749,0xd44fbd9a,
                    0xd0dadecb,0xd50ada38,0x0339c32a,0xc6913667,0x8df9317c,0xe0b12b4f,
                    0xf79e59b7,0x43f5bb3a,0xf2d519ff,0x27d9459c,0xbf97222c,0x15e6fc2a,
                    0x0f91fc71,0x9b941525,0xfae59361,0xceb69ceb,0xc2a86459,0x12baa8d1,
                    0xb6c1075e,0xe3056a0c,0x10d25065,0xcb03a442,0xe0ec6e0e,0x1698db3b,
                    0x4c98a0be,0x3278e964,0x9f1f9532,0xe0d392df,0xd3a0342b,0x8971f21e,
                    0x1b0a7441,0x4ba3348c,0xc5be7120,0xc37632d8,0xdf359f8d,0x9b992f2e,
                    0xe60b6f47,0x0fe3f11d,0xe54cda54,0x1edad891,0xce6279cf,0xcd3e7e6f,
                    0x1618b166,0xfd2c1d05,0x848fd2c5,0xf6fb2299,0xf523f357,0xa6327623,
                    0x93a83531,0x56cccd02,0xacf08162,0x5a75ebb5,0x6e163697,0x88d273cc,
                    0xde966292,0x81b949d0,0x4c50901b,0x71c65614,0xe6c6c7bd,0x327a140a,
                    0x45e1d006,0xc3f27b9a,0xc9aa53fd,0x62a80f00,0xbb25bfe2,0x35bdd2f6,
                    0x71126905,0xb2040222,0xb6cbcf7c,0xcd769c2b,0x53113ec0,0x1640e3d3,
                    0x38abbd60,0x2547adf0,0xba38209c,0xf746ce76,0x77afa1c5,0x20756060,
                    0x85cbfe4e,0x8ae88dd8,0x7aaaf9b0,0x4cf9aa7e,0x1948c25c,0x02fb8a8c,
                    0x01c36ae4,0xd6ebe1f9,0x90d4f869,0xa65cdea0,0x3f09252d,0xc208e69f,
                    0xb74e6132,0xce77e25b,0x578fdfe3,0x3ac372e6
            };
        }

        #endregion

        #region Conversions

        //gets the first byte in a uint
        private byte wordByte0(uint w)
        {
            return (byte)(w / 256 / 256 / 256 % 256);
        }

        //gets the second byte in a uint
        private byte wordByte1(uint w)
        {
            return (byte)(w / 256 / 256 % 256);
        }

        //gets the third byte in a uint
        private byte wordByte2(uint w)
        {
            return (byte)(w / 256 % 256);
        }

        //gets the fourth byte in a uint
        private byte wordByte3(uint w)
        {
            return (byte)(w % 256);
        }

        //converts a byte array to a hex string
        private string ByteToHex(byte[] bytes)
        {
            StringBuilder s = new StringBuilder();
            foreach (byte b in bytes)
                s.Append(b.ToString("x2"));
            return s.ToString();
        }

        //converts a hex string to a byte array
        private byte[] HexToByte(string hex)
        {
            byte[] r = new byte[hex.Length / 2];
            for (int i = 0; i < hex.Length - 1; i += 2)
            {
                byte a = GetHex(hex[i]);
                byte b = GetHex(hex[i + 1]);
                r[i / 2] = (byte)(a * 16 + b);
            }
            return r;
        }

        //converts a single hex character to it's decimal value
        private byte GetHex(char x)
        {
            if (x <= '9' && x >= '0')
            {
                return (byte)(x - '0');
            }
            else if (x <= 'z' && x >= 'a')
            {
                return (byte)(x - 'a' + 10);
            }
            else if (x <= 'Z' && x >= 'A')
            {
                return (byte)(x - 'A' + 10);
            }
            return 0;
        }

        #endregion
    }
}
```

`LoLClient/ENet/Address.cs`:

```cs
#region

using System;
using System.Net;
using System.Text;

#endregion

namespace ENet
{
    public unsafe struct Address : IEquatable<Address>
    {
        public const uint IPv4HostAny = Native.ENET_HOST_ANY;
        public const uint IPv4HostBroadcast = Native.ENET_HOST_BROADCAST;

        private Native.ENetAddress _address;

        public Native.ENetAddress NativeData
        {
            get { return _address; }
            set { _address = value; }
        }

        public uint IPv4Host
        {
            get { return _address.host; }
            set { _address.host = value; }
        }

        public ushort Port
        {
            get { return _address.port; }
            set { _address.port = value; }
        }

        public AddressType Type
        {
            get { return AddressType.IPv4; }
        }

        #region IEquatable<Address> Members

        public bool Equals(Address address)
        {
            return Type == address.Type && Port == address.Port
                   && Native.memcmp(GetHostBytes(), address.GetHostBytes());
        }

        #endregion

        public override bool Equals(object obj)
        {
            return obj is Address && Equals((Address) obj);
        }

        public override int GetHashCode()
        {
            return Type.GetHashCode() ^ Port.GetHashCode() ^ IPv4Host.GetHashCode();
        }

        public byte[] GetHostBytes()
        {
            return BitConverter.GetBytes(IPAddress.NetworkToHostOrder((int) IPv4Host));
        }

        public string GetHostName()
        {
            var name = new byte[256];
            fixed (byte* hostName = name)
            {
                if (Native.enet_address_get_host(ref _address, hostName, (IntPtr) name.Length) < 0)
                {
                    return null;
                }
            }
            return BytesToString(name);
        }

        public string GetHostIP()
        {
            var ip = new byte[256];
            fixed (byte* hostIP = ip)
            {
                if (Native.enet_address_get_host_ip(ref _address, hostIP, (IntPtr) ip.Length) < 0)
                {
                    return null;
                }
            }
            return BytesToString(ip);
        }

        public bool SetHost(string hostName)
        {
            if (hostName == null)
            {
                throw new ArgumentNullException("hostName");
            }
            return Native.enet_address_set_host(ref _address,
                                                Encoding.ASCII.GetBytes(hostName)) == 0;
        }

        private static string BytesToString(byte[] bytes)
        {
            try
            {
                return Encoding.ASCII.GetString(bytes, 0, Native.strlen(bytes));
            }
            catch
            {
                return null;
            }
        }
    }
}
```

`LoLClient/ENet/AddressType.cs`:

```cs
namespace ENet
{
    public enum AddressType
    {
        IPv4 = 0
    }
}
```

`LoLClient/ENet/ENetException.cs`:

```cs
#region

using System;

#endregion

namespace ENet
{
    public class ENetException : Exception
    {
        public ENetException(int code, string message)
            : base(message)
        {
            Code = code;
        }

        public int Code { get; private set; }
    }
}
```

`LoLClient/ENet/Event.cs`:

```cs
namespace ENet
{
    public unsafe struct Event
    {
        internal Native.ENetEvent _event;

        public Event(Native.ENetEvent @event)
        {
            _event = @event;
        }

        public byte ChannelID
        {
            get { return _event.channelID; }
        }

        public uint Data
        {
            get { return _event.data; }
        }

        public Native.ENetEvent NativeData
        {
            get { return _event; }
            set { _event = value; }
        }

        public Packet Packet
        {
            get { return new Packet(_event.packet); }
        }

        public Peer Peer
        {
            get { return new Peer(_event.peer); }
        }

        public EventType Type
        {
            get { return _event.type; }
        }
    }
}
```

`LoLClient/ENet/EventType.cs`:

```cs
namespace ENet
{
    public enum EventType
    {
        None = 0,
        Connect = 1,
        Disconnect = 2,
        Receive = 3
    }
}
```

`LoLClient/ENet/Host.cs`:

```cs
#region

using System;

#endregion

namespace ENet
{
    public unsafe class Host : IDisposable
    {
        private Native.ENetHost* _host;

        public bool IsSet
        {
            get { return _host != null; }
        }

        public Native.ENetHost* NativeData
        {
            get { return _host; }
            set { _host = value; }
        }

        #region IDisposable Members

        public void Dispose()
        {
            Dispose(true);
        }

        #endregion

        ~Host()
        {
            Dispose(false);
        }

        private void CheckChannelLimit(int channelLimit)
        {
            if (channelLimit < 0 || channelLimit > Native.ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT)
            {
                throw new ArgumentOutOfRangeException("channelLimit");
            }
        }

        private void CheckCreated()
        {
            if (_host == null)
            {
                throw new InvalidOperationException("Not created.");
            }
        }

        public void Create(ushort port, int peerLimit)
        {
            var address = new Address();
            address.Port = port;
            Create(address, peerLimit);
        }

        public void Create(Address? address, int peerLimit)
        {
            Create(address, peerLimit, 0);
        }

        public void Create(Address? address, int peerLimit, int channelLimit)
        {
            Create(address, peerLimit, channelLimit, 0, 0);
        }

        public void Create(Address? address, int peerLimit, int channelLimit, uint incomingBandwidth, uint outgoingBandwidth)
        {
            if (_host != null)
            {
                throw new InvalidOperationException("Already created.");
            }
            if (peerLimit < 0 || peerLimit > Native.ENET_PROTOCOL_MAXIMUM_PEER_ID)
            {
                throw new ArgumentOutOfRangeException("peerLimit");
            }
            CheckChannelLimit(channelLimit);

            if (address != null)
            {
                var nativeAddress = address.Value.NativeData;
                _host = Native.enet_host_create(ref nativeAddress, (IntPtr) peerLimit,
                                                incomingBandwidth, outgoingBandwidth);
            }
            else
            {
                _host = Native.enet_host_create(null, (IntPtr) peerLimit,
                                                incomingBandwidth, outgoingBandwidth);
            }
            if (_host == null)
            {
                throw new ENetException(0, "Host creation call failed.");
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_host != null)
            {
                Native.enet_host_destroy(_host);
                _host = null;
            }
        }

        public void Broadcast(byte channelID, ref Packet packet)
        {
            CheckCreated();
            packet.CheckCreated();
            Native.enet_host_broadcast(_host, channelID, packet.NativeData);
            packet.NativeData = null; // Broadcast automatically clears this.
        }

        public void CompressWithRangeCoder()
        {
            CheckCreated();
            Native.enet_host_compress_with_range_coder(_host);
        }

        public void DoNotCompress()
        {
            CheckCreated();
            Native.enet_host_compress(_host, null);
        }

        public int CheckEvents(out Event @event)
        {
            CheckCreated();
            Native.ENetEvent nativeEvent;
            var ret = Native.enet_host_check_events(_host, out nativeEvent);
            if (ret <= 0)
            {
                @event = new Event();
                return ret;
            }
            @event = new Event(nativeEvent);
            return ret;
        }

        public Peer Connect(Address address, int channelLimit)
        {
            CheckCreated();
            CheckChannelLimit(channelLimit);

            var nativeAddress = address.NativeData;
            var peer = new Peer(Native.enet_host_connect(_host, ref nativeAddress, (IntPtr) channelLimit));
            if (peer.NativeData == null)
            {
                throw new ENetException(0, "Host connect call failed.");
            }
            return peer;
        }

        public void Flush()
        {
            CheckCreated();
            Native.enet_host_flush(_host);
        }

        public int Service(int timeout)
        {
            if (timeout < 0)
            {
                throw new ArgumentOutOfRangeException("timeout");
            }
            CheckCreated();
            return Native.enet_host_service(_host, null, (uint) timeout);
        }

        public int Service(int timeout, out Event @event)
        {
            if (timeout < 0)
            {
                throw new ArgumentOutOfRangeException("timeout");
            }
            CheckCreated();
            Native.ENetEvent nativeEvent;

            var ret = Native.enet_host_service(_host, out nativeEvent, (uint) timeout);
            if (ret <= 0)
            {
                @event = new Event();
                return ret;
            }
            @event = new Event(nativeEvent);
            return ret;
        }

        public void SetBandwidthLimit(uint incomingBandwidth, uint outgoingBandwidth)
        {
            CheckCreated();
            Native.enet_host_bandwidth_limit(_host, incomingBandwidth, outgoingBandwidth);
        }

        public void SetChannelLimit(int channelLimit)
        {
            CheckChannelLimit(channelLimit);
            CheckCreated();
            Native.enet_host_channel_limit(_host, (IntPtr) channelLimit);
        }
    }
}
```

`LoLClient/ENet/Library.cs`:

```cs
namespace ENet
{
    public static class Library
    {
        public static uint Time
        {
            get { return Native.enet_time_get(); }
            set { Native.enet_time_set(value); }
        }

        public static void Initialize()
        {
            var inits = new Native.ENetCallbacks();
            var ret = Native.enet_initialize_with_callbacks(Native.ENET_VERSION, ref inits);
            if (ret < 0)
            {
                throw new ENetException(ret, "Initialization failed.");
            }
        }

        public static void Deinitialize()
        {
            Native.enet_deinitialize();
        }
    }
}
```

`LoLClient/ENet/Native.Structs.cs`:

```cs
#region

using System;
using System.Runtime.InteropServices;

#endregion

namespace ENet
{
    public static unsafe partial class Native
    {
        #region Nested type: ENetAddress

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetAddress
        {
            public uint host;
            public ushort port;
        }

        #endregion

        #region Nested type: ENetCallbacks

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetCallbacks
        {
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate IntPtr malloc_cb(IntPtr size);

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void free_cb(IntPtr memory);

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void no_memory_cb();

            public IntPtr malloc, free, no_memory;
        }

        #endregion

        #region Nested type: ENetChannel

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetChannel
        {
            public ushort outgoingReliableSequenceNumber;
            public ushort outgoingUnreliableSequenceNumber;
            public ushort usedReliableWindows;
            public ushort reliableWindows;
            public ushort incomingReliableSequenceNumber;
            public ushort incomingUnreliableSequenceNumber;
            public ENetList* incomingReliableCommands;
            public ENetList* incomingUnreliableCommands;
        }

        #endregion

        #region Nested type: ENetCompressor

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetCompressor
        {
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void compress_cb(IntPtr context, IntPtr inBuffers, IntPtr inBufferCount, IntPtr inLimit, IntPtr outData, IntPtr outLimit);

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void decompress_cb(IntPtr context, IntPtr inData, IntPtr inLimit, IntPtr outData, IntPtr outLimit);

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void destroy_cb(IntPtr context);

            public IntPtr context;
            public IntPtr compress, decompress, destroy;
        }

        #endregion

        #region Nested type: ENetEvent

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetEvent
        {
            public EventType type;
            public ENetPeer* peer;
            public byte channelID;
            public uint data;
            public ENetPacket* packet;
        }

        #endregion

        #region Nested type: ENetHost

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetHost
        {
        }

        #endregion

        #region Nested type: ENetList

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetList
        {
            public ENetListNode* sentinel;
        }

        #endregion

        #region Nested type: ENetListNode

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetListNode
        {
            public ENetListNode* next, previous;
        }

        #endregion

        #region Nested type: ENetPacket

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetPacket
        {
            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void freeCallback_cb(IntPtr packet);

            public IntPtr referenceCount;
            public PacketFlags flags;
            public void* data;
            public IntPtr dataLength;
            public IntPtr freeCallback;
        }

        #endregion

        #region Nested type: ENetPeer

        [StructLayout(LayoutKind.Sequential)]
        public struct ENetPeer
        {
            public ENetListNode dispatchList;
            public ENetHost* host;
            public ushort outgoingPeerID;
            public ushort incomingPeerID;
            public uint connectID;
            public byte outgoingSessionID;
            public byte incomingSessionID;
            public ENetAddress address;
            public IntPtr data;
            public PeerState state;
            public ENetChannel* channels;
            public IntPtr channelcount;
            public uint incomingBandwidth;
            public uint outgoingBandwidth;
            public uint incomingBandwidthThrottleEpoch;
            public uint outgoingBandwidthThrottleEpoch;
            public uint incomingDataTotal;
            public uint outgoingDataTotal;
            public uint lastSendTime;
            public uint lastReceiveTime;
            public uint nextTimeout;
            public uint earliestTimeout;
            public uint packetLossEpoch;
            public uint packetsSent;
            public uint packetsLost;
            public uint packetLoss;
            public uint packetLossVariance;
            public uint packetThrottle;
            public uint packetThrottleLimit;
            public uint packetThrottleCounter;
            public uint packetThrottleEpoch;
            public uint packetThrottleAcceleration;
            public uint packetThrottleDeceleration;
            public uint packetThrottleInterval;
            public uint pingInterval;
            public uint timeoutLimit;
            public uint timeoutMinimum;
            public uint timeoutMaximum;
            public uint lastRoundTripTime;
            public uint lowestRoundTripTime;
            public uint lastRoundTripTimeVariance;
            public uint highestRoundTripTimeVariance;
            public uint roundTripTime;
            public uint roundTripTimeVariance;
            public uint mtu;
            public uint windowSize;
            public uint reliableDataInTransit;
            public ushort outgoingReliableSequenceNumber;
            public ENetList* acknowledgements;
            public ENetList* sentReliableCommands;
            public ENetList* sentUnreliableCommands;
            public ENetList* outgoingReliableCommands;
            public ENetList* outgoingUnreliableCommands;
            public ENetList* dispatchedCommands;
            public int needsDispatch;
            public ushort incomingUnsequencedGroup;
            public ushort outgoingUnsequencedGroup;
            public uint unsequencedWindow;
            public uint eventData;
        }

        #endregion
    }
}
```

`LoLClient/ENet/Native.cs`:

```cs
#region

using System;
using System.Runtime.InteropServices;

#endregion

namespace ENet
{
    public static unsafe partial class Native
    {
        private const string LIB = "eNet.dll";

        public const int ENET_PEER_PACKET_THROTTLE_SCALE = 32;
        public const int ENET_PEER_PACKET_THROTTLE_ACCELERATION = 2;
        public const int ENET_PEER_PACKET_THROTTLE_DECELERATION = 2;
        public const int ENET_PEER_PACKET_THROTTLE_INTERVAL = 5000;
        public const int ENET_PROTOCOL_MINIMUM_CHANNEL_COUNT = 0x01;
        public const int ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT = 0xff;
        public const int ENET_PROTOCOL_MAXIMUM_PEER_ID = 0xfff;
        public const uint ENET_VERSION = (1 << 16) | (3 << 8) | (1);
        public const uint ENET_HOST_ANY = 0;
        public const uint ENET_HOST_BROADCAST = 0xffffffff;

        #region Address Functions

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_address_set_host(ref ENetAddress address, byte* hostName);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_address_set_host(ref ENetAddress address, byte[] hostName);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_address_get_host(ref ENetAddress address, byte* hostName, IntPtr nameLength);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_address_get_host(ref ENetAddress address, byte[] hostName, IntPtr nameLength);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_address_get_host_ip(ref ENetAddress address, byte* hostIP, IntPtr ipLength);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_address_get_host_ip(ref ENetAddress address, byte[] hostIP, IntPtr ipLength);

        #endregion

        #region Global Functions

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_deinitialize();

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_initialize();

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_initialize_with_callbacks(uint version, ref ENetCallbacks inits);

        #endregion

        #region Host Functions

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_host_compress_with_range_coder(ENetHost* host);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern ENetHost* enet_host_create(ENetAddress* address,
                                                        IntPtr peerLimit, uint incomingBandwidth, uint outgoingBandwidth);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern ENetHost* enet_host_create(ref ENetAddress address,
                                                        IntPtr peerLimit, uint incomingBandwidth, uint outgoingBandwidth);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_host_destroy(ENetHost* host);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern ENetPeer* enet_host_connect(ENetHost* host, ref ENetAddress address, IntPtr channelCount);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_host_broadcast(ENetHost* host, byte channelID, ENetPacket* packet);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_host_compress(ENetHost* host, ENetCompressor* compressor);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_host_channel_limit(ENetHost* host, IntPtr channelLimit);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_host_bandwidth_limit(ENetHost* host, uint incomingBandwidth, uint outgoingBandwidth);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_host_flush(ENetHost* host);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_host_check_events(ENetHost* host, out ENetEvent @event);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_host_service(ENetHost* host, ENetEvent* @event, uint timeout);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_host_service(ENetHost* host, out ENetEvent @event, uint timeout);

        #endregion

        #region Miscellaneous Functions

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint enet_time_get();

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_time_set(uint newTimeBase);

        #endregion

        #region Packet Functions

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern ENetPacket* enet_packet_create(void* data, IntPtr dataLength, PacketFlags flags);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_packet_destroy(ENetPacket* packet);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_packet_resize(ENetPacket* packet, IntPtr dataLength);

        #endregion

        #region Peer Functions

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_peer_throttle_configure(ENetPeer* peer, uint interval, uint acceleration, uint deceleration);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern int enet_peer_send(ENetPeer* peer, byte channelID, ENetPacket* packet);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern ENetPacket* enet_peer_receive(ENetPeer* peer, out byte channelID);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_peer_reset(ENetPeer* peer);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_peer_ping(ENetPeer* peer);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_peer_disconnect_now(ENetPeer* peer, uint data);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_peer_disconnect(ENetPeer* peer, uint data);

        [DllImport(LIB, CallingConvention = CallingConvention.Cdecl)]
        public static extern void enet_peer_disconnect_later(ENetPeer* peer, uint data);

        #endregion

        #region C# Utility

        public static bool memcmp(byte[] s1, byte[] s2)
        {
            if (s1 == null || s2 == null)
            {
                throw new ArgumentNullException();
            }
            if (s1.Length != s2.Length)
            {
                return false;
            }

            for (var i = 0; i < s1.Length; i++)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }

        public static int strlen(byte[] s)
        {
            if (s == null)
            {
                throw new ArgumentNullException();
            }

            int i;
            for (i = 0; i < s.Length && s[i] != 0; i++) ;
            return i;
        }

        #endregion
    }
}
```

`LoLClient/ENet/Packet.cs`:

```cs
#region

using System;
using System.Runtime.InteropServices;

#endregion

namespace ENet
{
    public unsafe struct Packet : IDisposable
    {
        private Native.ENetPacket* _packet;

        public Packet(Native.ENetPacket* packet)
        {
            _packet = packet;
        }

        public void* Data
        {
            get
            {
                CheckCreated();
                return _packet->data;
            }
        }

        public int Length
        {
            get
            {
                CheckCreated();
                if (_packet->dataLength.ToPointer() > (void*) int.MaxValue)
                {
                    throw new ENetException(0, "Packet too long!");
                }
                return (int) _packet->dataLength;
            }
        }

        public Native.ENetPacket* NativeData
        {
            get { return _packet; }
            set { _packet = value; }
        }

        public bool IsSet
        {
            get { return _packet != null; }
        }

        #region IDisposable Members

        public void Dispose()
        {
            if (_packet != null)
            {
                if (_packet->referenceCount == IntPtr.Zero)
                {
                    Native.enet_packet_destroy(_packet);
                }
                _packet = null;
            }
        }

        #endregion

        internal void CheckCreated()
        {
            if (_packet == null)
            {
                throw new InvalidOperationException("No native packet.");
            }
        }

        public void Create(byte[] data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }
            Create(data, 0, data.Length);
        }

        public void Create(byte[] data, int offset, int length)
        {
            Create(data, offset, length, PacketFlags.None);
        }

        public void Create(byte[] data, int offset, int length, PacketFlags flags)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }
            if (offset < 0 || length < 0 || length > data.Length - offset)
            {
                throw new ArgumentOutOfRangeException();
            }
            fixed (byte* bytes = data)
            {
                Create(bytes + offset, length, flags);
            }
        }

        public void Create(void* data, int length, PacketFlags flags)
        {
            if (_packet != null)
            {
                throw new InvalidOperationException("Already created.");
            }

            _packet = Native.enet_packet_create(data, (IntPtr) length, flags);
            if (_packet == null)
            {
                throw new ENetException(0, "Packet creation call failed.");
            }
        }

        public void CopyTo(byte[] array)
        {
            if (array == null)
            {
                throw new ArgumentNullException("array");
            }
            CopyTo(array, 0, array.Length);
        }

        public void CopyTo(byte[] array, int offset, int length)
        {
            if (array == null)
            {
                throw new ArgumentNullException("array");
            }
            if (offset < 0 || length < 0 || length > array.Length - offset)
            {
                throw new ArgumentOutOfRangeException();
            }

            CheckCreated();
            if (length > Length - offset)
            {
                throw new ArgumentOutOfRangeException();
            }
            if (length > 0)
            {
                Marshal.Copy((IntPtr) ((byte*) Data + offset), array, offset, length);
            }
        }

        public byte[] GetBytes()
        {
            CheckCreated();
            var array = new byte[Length];
            CopyTo(array);
            return array;
        }

        public void Resize(int length)
        {
            if (length < 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }
            CheckCreated();
            var ret = Native.enet_packet_resize(_packet, (IntPtr) length);
            if (ret < 0)
            {
                throw new ENetException(ret, "Packet resize call failed.");
            }
        }
    }
}
```

`LoLClient/ENet/PacketFlags.cs`:

```cs
#region

using System;

#endregion

namespace ENet
{
    [Flags]
    public enum PacketFlags
    {
        None = 0,
        Reliable = 1 << 0,
        Unsequenced = 1 << 1,
        NoAllocate = 1 << 2
    }
}
```

`LoLClient/ENet/Peer.cs`:

```cs
#region

using System;

#endregion

namespace ENet
{
    public unsafe struct Peer
    {
        private Native.ENetPeer* _peer;

        public Peer(Native.ENetPeer* peer)
        {
            _peer = peer;
        }

        public bool IsSet
        {
            get { return _peer != null; }
        }

        public uint RoundTripTime
        {
            get { return _peer->lastRoundTripTime; }
        }

        public Native.ENetPeer* NativeData
        {
            get { return _peer; }
            set { _peer = value; }
        }

        public PeerState State
        {
            get { return IsSet ? _peer->state : PeerState.Uninitialized; }
        }

        public IntPtr UserData
        {
            get
            {
                CheckCreated();
                return _peer->data;
            }
            set
            {
                CheckCreated();
                _peer->data = value;
            }
        }

        private void CheckCreated()
        {
            if (_peer == null)
            {
                throw new InvalidOperationException("No native peer.");
            }
        }

        public void ConfigureThrottle(uint interval, uint acceleration, uint deceleration)
        {
            CheckCreated();
            Native.enet_peer_throttle_configure(_peer, interval, acceleration, deceleration);
        }

        public void Disconnect(uint data)
        {
            CheckCreated();
            Native.enet_peer_disconnect(_peer, data);
        }

        public void DisconnectLater(uint data)
        {
            CheckCreated();
            Native.enet_peer_disconnect_later(_peer, data);
        }

        public void DisconnectNow(uint data)
        {
            CheckCreated();
            Native.enet_peer_disconnect_now(_peer, data);
        }

        public void Ping()
        {
            CheckCreated();
            Native.enet_peer_ping(_peer);
        }

        public void Reset()
        {
            CheckCreated();
            Native.enet_peer_reset(_peer);
        }

        public bool Receive(out byte channelID, out Packet packet)
        {
            CheckCreated();
            Native.ENetPacket* nativePacket;
            nativePacket = Native.enet_peer_receive(_peer, out channelID);
            if (nativePacket == null)
            {
                packet = new Packet();
                return false;
            }
            packet = new Packet(nativePacket);
            return true;
        }

        public bool Send(byte channelID, byte[] data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }
            return Send(channelID, data, 0, data.Length);
        }

        public bool Send(byte channelID, byte[] data, int offset, int length)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }
            bool ret;
            using (var packet = new Packet())
            {
                packet.Create(data, offset, length);
                ret = Send(channelID, packet);
            }
            return ret;
        }

        public bool Send(byte channelID, Packet packet)
        {
            CheckCreated();
            packet.CheckCreated();
            return Native.enet_peer_send(_peer, channelID, packet.NativeData) >= 0;
        }
    }
}
```

`LoLClient/ENet/PeerState.cs`:

```cs
namespace ENet
{
    public enum PeerState
    {
        Uninitialized = -1,
        Disconnected = 0,
        Connecting = 1,
        AcknowledgingConnect = 2,
        ConnectionPending = 3,
        ConnectionSucceeded = 4,
        Connected = 5,
        DisconnectLater = 6,
        Disconnecting = 7,
        AcknowledgingDisconnect = 8,
        Zombie = 9
    }
}
```

`LoLClient/Form1.Designer.cs`:

```cs
namespace LoLClient
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.backgroundWorker1 = new System.ComponentModel.BackgroundWorker();
            this.richTextBox1 = new System.Windows.Forms.RichTextBox();
            this.button1 = new System.Windows.Forms.Button();
            this.button2 = new System.Windows.Forms.Button();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.textBox3 = new System.Windows.Forms.TextBox();
            this.button3 = new System.Windows.Forms.Button();
            this.button4 = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // backgroundWorker1
            // 
            this.backgroundWorker1.DoWork += new System.ComponentModel.DoWorkEventHandler(this.backgroundWorker1_DoWork);
            // 
            // richTextBox1
            // 
            this.richTextBox1.Location = new System.Drawing.Point(4, 13);
            this.richTextBox1.Name = "richTextBox1";
            this.richTextBox1.Size = new System.Drawing.Size(742, 291);
            this.richTextBox1.TabIndex = 0;
            this.richTextBox1.Text = "";
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(810, 63);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(75, 23);
            this.button1.TabIndex = 1;
            this.button1.Text = "button1";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // button2
            // 
            this.button2.Location = new System.Drawing.Point(810, 28);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(75, 23);
            this.button2.TabIndex = 2;
            this.button2.Text = "button2";
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(810, 116);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(100, 20);
            this.textBox1.TabIndex = 3;
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(810, 196);
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(100, 20);
            this.textBox2.TabIndex = 4;
            // 
            // textBox3
            // 
            this.textBox3.Location = new System.Drawing.Point(810, 223);
            this.textBox3.Name = "textBox3";
            this.textBox3.Size = new System.Drawing.Size(100, 20);
            this.textBox3.TabIndex = 5;
            // 
            // button3
            // 
            this.button3.Location = new System.Drawing.Point(810, 250);
            this.button3.Name = "button3";
            this.button3.Size = new System.Drawing.Size(75, 23);
            this.button3.TabIndex = 6;
            this.button3.Text = "button3";
            this.button3.UseVisualStyleBackColor = true;
            this.button3.Click += new System.EventHandler(this.button3_Click);
            // 
            // button4
            // 
            this.button4.Location = new System.Drawing.Point(810, 280);
            this.button4.Name = "button4";
            this.button4.Size = new System.Drawing.Size(75, 23);
            this.button4.TabIndex = 7;
            this.button4.Text = "button4";
            this.button4.UseVisualStyleBackColor = true;
            this.button4.Click += new System.EventHandler(this.button4_Click);
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(939, 410);
            this.Controls.Add(this.button4);
            this.Controls.Add(this.button3);
            this.Controls.Add(this.textBox3);
            this.Controls.Add(this.textBox2);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.button2);
            this.Controls.Add(this.button1);
            this.Controls.Add(this.richTextBox1);
            this.Name = "Form1";
            this.Text = "Form1";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.ComponentModel.BackgroundWorker backgroundWorker1;
        private System.Windows.Forms.RichTextBox richTextBox1;
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.TextBox textBox2;
        private System.Windows.Forms.TextBox textBox3;
        private System.Windows.Forms.Button button3;
        private System.Windows.Forms.Button button4;
    }
}


```

`LoLClient/Form1.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using ENet;

namespace LoLClient
{
    public partial class Form1 : Form
    {
        private BlowFish blowfish;
        private Peer server;
        private Host client;
        private string IPAddr;
        private ushort port;
        private string key;
        private UInt64 playerId;
        private UInt32 netId = 0;
        private Boolean pastLoadScreen = false;
        private Boolean startedGame = false;
        private uint comp = 2;
        private int k = 0;
        bool first = false;
        bool logPackets = false;

        public Form1(string[] args)
        {
            InitializeComponent();
            //args[0] = "192.64.170.20 5108 LuPEhb0bZ95QqcqwsbF6Ag== 50473085";
            String[] arguments = args[0].Split(' ');
            IPAddr = arguments[0];
            port = Convert.ToUInt16(arguments[1]);
            key = arguments[2];
            playerId = Convert.ToUInt64(arguments[3]);
            /*
            l = new Lua();
            l.RegisterFunction("dostuff", this, this.GetType().GetMethod("dostuff"));
            l.DoFile("test.lua");*/
            //string hex = "C4-00-00-00-00-10-00-00-00-11-22-B5-7D-F9-FF-03-00-00-00-05-00-E0-AB-45-01-03-00-00-00-05-00-80-80-80-0C-22-0F-2C-F0-FF-03-00-00-00-05-00-E0-AB-45-01-03-00-00-00-05-00-80-80-80-0C-22-E1-03-93-FF-03-00-00-00-05-00-00-7A-45-01-03-00-00-00-05-00-80-80-80-0C-22-F1-20-4A-FF-03-00-00-00-05-00-00-7A-45-01-03-00-00-00-05-00-80-80-80-0C-22-3E-3C-D2-FF-03-00-00-00-05-00-00-7A-45-01-03-00-00-00-05-00-80-80-80-0C-22-1F-8F-FF-FF-03-00-00-00-05-00-00-7A-45-01-03-00-00-00-05-00-80-80-80-0C-22-0F-AC-26-FF-03-00-00-00-05-00-00-7A-45-01-03-00-00-00-05-00-80-80-80-0C-22-D0-93-67-FF-03-00-00-00-05-00-00-7A-45-01-03-00-00-00-05-00-80-80-80-0C-22-36-B8-53-FF-03-00-00-00-05-20-BC-BE-4C-01-03-00-00-00-05-00-80-80-80-0C-22-E8-00-BA-FF-03-00-00-00-05-20-BC-BE-4C-01-03-00-00-00-05-00-80-80-80-0C-22-D5-47-E6-FF-03-00-00-00-05-20-BC-BE-4C-01-03-00-00-00-05-00-80-80-80-0C-22-71-71-B7-FF-03-00-00-00-05-20-BC-BE-4C-01-03-00-00-00-05-00-80-80-80-0C-22-4C-36-EB-FF-03-00-00-00-05-20-BC-BE-4C-01-03-00-00-00-05-00-80-80-80-0C-22-AF-C9-5E-FF-03-00-00-00-05-20-BC-BE-4C-01-03-00-00-00-05-00-80-80-80-0C-2A-01-00-00-40-FF-7F-00-00-18-FF-FF-87-80-88-02-00-01-00-01-00-00-C8-41-FF-FF-00-00-80-3F-FF-FF-FF-FF-3F-00-00-00-0F-00-80-A2-44-00-80-A2-44-FF-FF-FF-00-00-80-3F-03-00-00-00-05-00-80-80-80-0C-2A-02-00-00-40-FF-7F-00-00-18-FF-FF-87-80-88-02-00-01-00-01-00-00-C8-41-FF-FF-00-00-80-3F-FF-FF-FF-FF-3F-00-00-00-0F-00-80-A2-44-00-80-A2-44-FF-FF-FF-00-00-80-3F-03-00-00-00-05-00-80-80-80-0C-2A-03-00-00-40-FF-7F-00-00-18-FF-FF-87-80-88-02-00-01-00-01-00-00-C8-41-FF-FF-00-00-80-3F-FF-FF-FF-FF-3F-00-00-00-0F-00-80-A2-44-00-80-A2-44-FF-FF-FF-00-00-80-3F-03-00-00-00-05-00-80-80-80-0C";
            //string hex = "61-00-00-00-00-F7-02-00-00-01-00-04-19-00-00-40-01-36-F2-9D-F2-20-15-F2";
            //Update up = new Update(bytes);
            //Waypoints wp = new Waypoints(bytes);
        }
        public static void dostuff()
        {
            Console.WriteLine("rawrd!");
        }
        private void Form1_Load(object sender, EventArgs e)
        {
            backgroundWorker1.RunWorkerAsync();
            //HandleMoveReq(ConvertStringToBytes("61-00-00-00-00-46-10-00-00-01-00-04-1A-00-00-40-00-BE-F3-2E-F3-47-F6-CC-F4"));
            //HandleMoveReq(ConvertStringToBytes("61-00-00-00-00-DD-11-00-00-01-00-02-1A-00-00-40-05-F5-FF-F3"));
        }
        private byte[] ConvertStringToBytes(String hex)
        {
            int NumberChars = hex.Length;
            byte[] bytes = new Byte[NumberChars / 2];
            hex = hex.Replace("-", "");
            NumberChars = hex.Length;
            for (int i = 0; i < NumberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
            return bytes;
        }
        private void Log(string str)
        {
            Console.WriteLine(str);
            richTextBox1.Invoke(new MethodInvoker(delegate()
            {
                richTextBox1.Text = DateTime.Now + " : " + str + "\n" + richTextBox1.Text;
            }));
        }
        private Boolean SendPacket(byte[] data, Channel channelNum)
        {
            String val = ((PacketCmd)data[0]).ToString();
            if (logPackets)
            {
                if (val.All(c => char.IsDigit(c)))
                    Log("send : " + String.Format("{0:X}", data[0]));
                else
                    Log("send : " + ((PacketCmd)data[0]).ToString());
            }
            if (data.Length >= 8 && data[0] != (byte)PacketCmd.PKT_KeyCheck)
            {
                data = blowfish.Encrypt_ECB(data);
            }
            return server.Send((byte)channelNum, data);
        }
        private void HandleEncryptedPacket(Byte[] data, int channel)
        {
            if (data.Length >= 8 && (data[0] != (byte)PacketCmd.PKT_KeyCheck || startedGame))
                data = blowfish.Decrypt_ECB(data);
            HandlePacket(data, channel);
        }
        private void HandlePacket(Byte[] data, int channel)
        {
            //l["packetdatawrapper"] = data.ToList();//BitConverter.ToString(data);
            //l.DoString("OnRecvPacket(packetdatawrapper)");
            String val = ((PacketCmd)data[0]).ToString();
            if (logPackets)
            {
                if (val.All(c => char.IsDigit(c)))
                    Log("recv : " + String.Format("{0:X}", data[0]));
                else
                    Log("recv : " + ((PacketCmd)data[0]).ToString());
            }
            switch ((PacketCmd)data[0])
            {
                case PacketCmd.PKT_Batch: HandleBatchPacket(data); break;
                case PacketCmd.PKT_KeyCheck: HandleKeyCheck(data); break;
                case PacketCmd.PKT_World_SendGameNumber: HandleGameNumber(data); break;
                case PacketCmd.PKT_S2C_QueryStatusAns: HandleQuery(data); break;
                case PacketCmd.PKT_S2C_SynchVersion: HandleSynch(data); break;
                case PacketCmd.PKT_S2C_LoadScreenInfo: HandleScreenInfo(data); break;
                case PacketCmd.PKT_S2C_LoadName: HandleName(data); break;
                case PacketCmd.PKT_S2C_LoadHero: HandleHero(data); break;
                case PacketCmd.PKT_S2C_Ping_Load_Info: HandlePing(data); break;
                case PacketCmd.PKT_S2C_StartSpawn: HandleStartSpawn(data); break;
                case PacketCmd.PKT_S2C_HeroSpawn: HandleHeroSpawn(data); break;
                case PacketCmd.PKT_S2C_MinionSpawn: HandleMinionSpawn(data); break;
                case PacketCmd.PKT_S2C_SetHealth: HandleSetHealth(data); break;
                case PacketCmd.PKT_S2C_TurretSpawn: HandleTurretSpawn(data); break;
                case PacketCmd.PKT_S2C_LevelPropSpawn: HandleLevelPropSpawn(data); break;
                case PacketCmd.PKT_S2C_EndSpawn: HandleEndSpawn(data); break;
                case PacketCmd.PKT_S2C_BuyItemAns: HandleBuyItem(data); break;
                case PacketCmd.PKT_S2C_GameTimer: HandleGameTimer(data); break;
                case PacketCmd.PKT_S2C_GameTimerUpdate: HandleGameTimerUpdate(data); break;
                case PacketCmd.PKT_S2C_StartGame: HandleGameStart(data); break;
                case PacketCmd.PKT_S2C_CharStats: HandleUpdateUnit(data); break;
                case PacketCmd.PKT_S2C_MoveAns: HandleMoveReq(data); break;
                    /*case (PacketCmd)0x10:
                    case PacketCmd.PKT_S2C_SkillUp:
                    case (PacketCmd)0x17:
                    case PacketCmd.PKT_S2C_AutoAttack:
                    case (PacketCmd)0x1c:
                    case (PacketCmd)0x1f:
                    case PacketCmd.PKT_S2C_FogUpdate2:
                    case PacketCmd.PKT_S2C_PlayerInfo:
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x34, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x45, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x6b, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x6e, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x76, CHL_GAMEPLAY);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x7b, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x7f, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x87, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x93, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0x9e, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0xb0, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0xb7, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0xe9, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0xf0, CHL_S2C);
        registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0xfe, CHL_S2C);registerHandler(&PacketHandler::HandleNull,            (PacketCmd)0xfe, CHL_S2C);
        */
                    break;
            }
        }
        private void HandleBatchPacket(Byte[] data)
        {
            int offset = 0;
            Byte[] pkt = data;
            Byte numPackets = pkt[1];
            Byte firstPacketSize = pkt[2];
            offset += 3;
            Byte previousCmd = pkt[offset + 0];
            offset += firstPacketSize;
            for (int i = 2; i < numPackets + 1; ++i)
            {
                Byte flagsAndLength = pkt[offset + 0]; // 6 first bits = size (if not 0xFC), 2 last bits = flags
                Byte size = (Byte)(flagsAndLength >> 2);
                Byte additionalByte = pkt[offset + 1]; // Only preset if flagsAndLength & FLAG_UNK
                Byte command;
                Byte[] buffer = new Byte[8192];
                offset++;
                if ((flagsAndLength & 0x01) > 0)
                { // additionnal byte, skip command   
                    offset++;
                    command = previousCmd;
                }
                else
                {
                    command = pkt[offset + 0];
                    offset++;
                    if ((flagsAndLength & 0x02) > 0)
                    { // looks like when this is set, we keep the same netId, else we use a new one
                        offset++;
                    }
                    else
                    {
                        offset += 4;
                    }
                }
                if (size == 0x3F)
                { // size is too big to be on 6 bits, so instead it's stored later
                    size = pkt[offset + 0];
                    offset++;
                }
                buffer[0] = command;
                for (int j = 0; j < size; j++)
                {
                    buffer[j + 1] = pkt[offset + j];
                }
                HandlePacket(buffer, 2);
                offset += size;
            }
        }
        private void SendConnect(UInt64 userId)
        {
            KeyCheck keyCheck = KeyCheck.Create(playerId, blowfish.Encrypt_ECB(playerId));
            SendPacket(GetBytes<KeyCheck>(keyCheck), Channel.CHL_HANDSHAKE);
        }
        private void HandleKeyCheck(Byte[] data)
        {
            KeyCheck keyCheck;
            keyCheck = GetStruct<KeyCheck>(data);
            if (first){
                //SendPacket(GetBytes<KeyCheck>(keyCheck), Channel.CHL_HANDSHAKE);
            }
            else
            {
                first = true;
            }
            if (keyCheck.userId == playerId)
            {
                //netId = keyCheck.playerNo;// +1;
                Log("netid : " + netId.ToString());
            }
        }
        private void HandleGameNumber(Byte[] data)
        {
            SendQuery();
        }
        private void SendQuery()
        {
            PacketHeader queryStatus = PacketHeader.Create(PacketCmd.PKT_C2S_QueryStatusReq, 0);
            SendPacket(GetBytes(queryStatus), Channel.CHL_C2S);
        }
        private void HandleQuery(Byte[] data)
        {
            SendSynch();
        }
        private void SendSynch()
        {
            SynchVersion synch = SynchVersion.Create();
            SendPacket(GetBytes(synch), Channel.CHL_C2S);
        }
        private void HandleSynch(Byte[] data)
        {
            SynchVersionAns synch = GetStruct<SynchVersionAns>(data);
            ClientReady ready = ClientReady.Create();
            SendPacket(GetBytes(ready), Channel.CHL_LOADING_SCREEN);
            //SendPing(0.0f, 666.6f, 0x000F0001);
            new Thread(() =>
            {
                float i = 5.4f;
                while (true)
                {
                    Thread.Sleep(1000);
                    i += 23.1f;
                    comp += 2;
                    if (i >= 99.5f)
                    {
                        i = 100.0f;
                        if (pastLoadScreen == false && i > 99)
                        {
                            pastLoadScreen = true;
                            SendPing(100.0f, 0.0f, 0x80100040 | comp);
                            SendCharLoaded();
                        }
                        k = k + 1;
                        if (k < 7)
                        {
                            SendPing(i, 0.0f, 0x80100040 | comp);
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        SendPing(i, 15.4f, 0x000F0000 | comp);
                    }
                }
            });
        }
        private void HandleScreenInfo(Byte[] data)
        {
            LoadScreenInfo info = GetStruct<LoadScreenInfo>(data);
        }
        private void HandleName(Byte[] data)
        {
            LoadScreenPlayer info = GetStruct<LoadScreenPlayer>(data);
        }
        private void HandleHero(Byte[] data)
        {
            LoadScreenPlayer info = GetStruct<LoadScreenPlayer>(data);
        }
        private void SendPing(float loaded, float ping, UInt32 unk)
        {
            PingLoadInfo pingPacket = PingLoadInfo.Create();
            pingPacket.userId = 0xFFFFFFFFFFFFFFFF;
            pingPacket.loaded = loaded;
            pingPacket.ping = ping;
            pingPacket.unk2 = unk;
            SendPacket(GetBytes(pingPacket), Channel.CHL_C2S);
        }
        private void HandlePing(Byte[] data)
        {
            PingLoadInfo ping = GetStruct<PingLoadInfo>(data);
            //if (ping.userId == playerId)
            {
                new Thread(() =>
                {
                    Thread.Sleep(1750);
                    float i = ping.loaded;
                    i += 9.1f;
                    comp += 2;
                    if (i >= 99.5f)
                    {
                        i = 100.0f;
                        if (pastLoadScreen == false && i > 99)
                        {
                            pastLoadScreen = true;
                            SendPing(100.0f, 0.0f, 0x80100040 | comp);
                            SendCharLoaded();
                        }
                        k = k + 1;
                        if (k < 7)
                        {
                            SendPing(i, 0.0f, 0x80100040 | comp);
                        }
                    }
                    else
                    {
                        SendPing(i, 15.4f, 0x000F0000 | comp);
                    }
                }).Start();
            }
        }
        private void SendCharLoaded()
        {
            SendPacket(GetBytes(PacketHeader.Create(PacketCmd.PKT_C2S_CharLoaded, 0)), Channel.CHL_C2S);
        }
        private void HandleStartSpawn(Byte[] data)
        {
        }
        private void HandleHeroSpawn(Byte[] data)
        {
            SendGameStart();
        }
        private void HandleMinionSpawn(Byte[] data)
        {
        }
        private void HandleSetHealth(Byte[] data)
        {
        }
        private void HandleTurretSpawn(Byte[] data)
        {
        }
        private void HandleLevelPropSpawn(Byte[] data)
        {
        }
        private void HandleEndSpawn(Byte[] data)
        {
            SendGameStart();
        }
        private void HandleBuyItem(Byte[] data)
        {
        }
        private void HandleGameTimer(Byte[] data)
        {
            GameTimer timer = GetStruct<GameTimer>(data);
            SendGameTime(timer);
        }
        private void HandleGameTimerUpdate(Byte[] data)
        {
            GameTimer timer = GetStruct<GameTimer>(data);
            SendGameTime(timer);
        }
        private void SendGameTime(GameTimer timer)
        {
            GameTime time = GameTime.Create(timer.tick1);
            SendPacket(GetBytes(time), Channel.CHL_GAMEPLAY);
        }
        private void SendGameStart()
        {
            if (!startedGame)
            {
                SendPing(100.0f, 0.0f, 0x80100040);
                SendPacket(GetBytes(PacketHeader8.Create(PacketCmd.PKT_C2S_unkstart)), Channel.CHL_C2S);
                startedGame = SendPacket(GetBytes(StartGame.Create()), Channel.CHL_C2S);
                SendPing(100.0f, 0.0f, 0x80100070);
                SendPing(100.0f, 0.0f, 0x80100072);
            }
        }
        private void HandleGameStart(Byte[] data)
        {
        }
        private void HandleUpdateUnit(Byte[] data)
        {
            Update up = new Update(data);
            GameHeader updateUnit = GetStruct<GameHeader>(data);
            SendUpdateUnitConfirm(updateUnit);
        }
        private void SendUpdateUnitConfirm(GameHeader stats)
        {
            GameHeader realStats = GameHeader.Create(PacketCmd.PKT_C2S_StatsConfirm, 0, stats.tick);
            SendPacket(GetBytes(realStats), Channel.CHL_C2S);
        }
        private void HandleMoveReq(Byte[] data)
        {
            //Waypoints waypoints = new Waypoints(data);
            MoveConfirm move = GetStruct<MoveConfirm>(data);
            move.header.header.cmd = (byte)PacketCmd.PKT_C2S_MoveConfirm;
            SendPacket(GetBytes(move), Channel.CHL_C2S);
        }
        private void SendMove(float x, float y)
        {
            Byte[] netIdBytes = new Byte[4] { 0x19, 0, 0, 0x40 };
            //netIdBytes[0] += (byte)netId;
            Log("move id : " + BitConverter.ToString(netIdBytes));
            MovementReq move = MovementReq.Create(x, y, BitConverter.ToUInt32(netIdBytes, 0));
            SendPacket(GetBytes(move), Channel.CHL_C2S);
        }
        public static Byte[] GetBytes<T>(T msg) where T : struct
        {
            int objsize = Marshal.SizeOf(typeof(T));
            Byte[] ret = new Byte[objsize];
            IntPtr buff = Marshal.AllocHGlobal(objsize);
            Marshal.StructureToPtr(msg, buff, true);
            Marshal.Copy(buff, ret, 0, objsize);
            Marshal.FreeHGlobal(buff);
            return ret;
        }
        public static T GetStruct<T>(Byte[] data) where T : struct
        {
            int objsize = Marshal.SizeOf(typeof(T));
            IntPtr buff = Marshal.AllocHGlobal(objsize);
            Marshal.Copy(data, 0, buff, objsize);
            T retStruct = (T)Marshal.PtrToStructure(buff, typeof(T));
            Marshal.FreeHGlobal(buff);
            return retStruct;
        }
        private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e)
        {
            client = new Host();
            Library.Initialize();
            client.Create(null, 1);

            var address = new Address();
            address.SetHost(IPAddr);
            address.Port = port;

            server = client.Connect(address, 8);

            byte[] blowfishkey = Convert.FromBase64String(key);
            blowfish = new BlowFish(blowfishkey);
            while (client.Service(1) >= 0)
            {
                Event @event;
                while (client.CheckEvents(out @event) > 0)
                {
                    switch (@event.Type)
                    {
                        case EventType.Connect:
                            SendConnect(playerId);
                            break;
                        case EventType.Receive:
                            HandleEncryptedPacket(@event.Packet.GetBytes(), @event.ChannelID);
                            @event.Packet.Dispose();
                            break;
                    }
                }
            }
        }

        private void button1_Click(object sender, EventArgs e)
        {
            server.Disconnect(0);
            server.DisconnectNow(0);
            startedGame = false;
            pastLoadScreen = false;
        }

        private void button2_Click(object sender, EventArgs e)
        {
            var address = new Address();
            address.SetHost(IPAddr);
            address.Port = port;
            server = client.Connect(address, 8);
        }

        private void button3_Click(object sender, EventArgs e)
        {
            SendMove(Convert.ToSingle(textBox2.Text), Convert.ToSingle(textBox3.Text));
        }

        private void button4_Click(object sender, EventArgs e)
        {
            SendPacket(GetBytes(PacketHeader8.Create(PacketCmd.PKT_C2S_Surrender)), Channel.CHL_C2S);
        }
    }
}

```

`LoLClient/Form1.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="backgroundWorker1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`LoLClient/LoLClient.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{C699B269-7D07-4CBD-BF73-2E56BDDAFCF6}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>LoLClient</RootNamespace>
    <AssemblyName>LoLClient</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="BlowFish.cs" />
    <Compile Include="ENet\Address.cs" />
    <Compile Include="ENet\AddressType.cs" />
    <Compile Include="ENet\ENetException.cs" />
    <Compile Include="ENet\Event.cs" />
    <Compile Include="ENet\EventType.cs" />
    <Compile Include="ENet\Host.cs" />
    <Compile Include="ENet\Library.cs" />
    <Compile Include="ENet\Native.cs" />
    <Compile Include="ENet\Native.Structs.cs" />
    <Compile Include="ENet\Packet.cs" />
    <Compile Include="ENet\PacketFlags.cs" />
    <Compile Include="ENet\Peer.cs" />
    <Compile Include="ENet\PeerState.cs" />
    <Compile Include="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="Packets.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <EmbeddedResource Include="Form1.resx">
      <DependentUpon>Form1.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`LoLClient/Packets.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace LoLClient
{
    public enum PacketCmd : byte
    {
        PKT_KeyCheck = 0x00,

        PKT_C2S_InGame = 0x08,
        PKT_S2C_EndSpawn = 0x11,
        PKT_C2S_QueryStatusReq = 0x14,
        PKT_S2C_SkillUp = 0x15,
        PKT_C2S_Ping_Load_Info = 0x16,
        PKT_S2C_AutoAttack = 0x1A,

        PKT_S2C_AddGold = 0x22,
        PKT_S2C_CreateRegion = 0x23,
        PKT_C2S_Mute = 0x27,
        PKT_S2C_PlayerInfo = 0x2A,

        PKT_S2C_ViewAns = 0x2C,
        PKT_C2S_ViewReq = 0x2E,

        PKT_CHAR_SpawnPet = 0x37,
        PKT_C2S_SkillUp = 0x39,
        PKT_S2C_FireSpellMissile = 0x3B,
        PKT_S2C_AttentionPing = 0x40,

        PKT_S2C_Emotion = 0x42,
        PKT_C2S_unkstart = 0x47,
        PKT_C2S_Emotion = 0x48,
        PKT_S2C_CreateHero = 0x4C,
        PKT_S2C_Announce = 0x4D,

        PKT_C2S_StartGame = 0x52,
        PKT_S2C_SynchVersion = 0x54,
        PKT_C2S_ScoreBoard = 0x56,
        PKT_C2S_AttentionPing = 0x57,
        PKT_S2C_SpellSet = 0x5A,
        PKT_S2C_StartGame = 0x5C,

        PKT_S2C_MoveAns = 0x61,
        PKT_S2C_StartSpawn = 0x62,
        PKT_S2C_CreateNeutral = 0x63,
        PKT_C2S_ClientReady = 0x64,
        PKT_S2C_LoadHero = 0x65,
        PKT_S2C_LoadName = 0x66,
        PKT_S2C_LoadScreenInfo = 0x67,
        PKT_ChatBoxMessage = 0x68,
        PKT_S2C_SetTarget = 0x6A,
        PKT_S2C_BuyItemAns = 0x6F,

        PKT_S2C_SetSpellData = 0x70,
        PKT_C2S_MoveReq = 0x72,
        PKT_C2S_MoveConfirm = 0x77,
        PKT_S2C_SpawnMinion = 0x7C,

        PKT_C2S_LockCamera = 0x81,
        PKT_C2S_BuyItemReq = 0x82,
        PKT_S2C_QueryStatusAns = 0x88,
        PKT_S2C_QuestComplete = 0x8C,
        PKT_C2S_Exit = 0x8F,

        PKT_World_SendGameNumber = 0x92,
        PKT_S2C_Ping_Load_Info = 0x95,
        PKT_S2C_ReconnectInfo = 0x98,
        PKT_C2S_CastSpell = 0x9A,
        PKT_S2C_TurretSpawn = 0x9D,

        PKT_S2C_Pause = 0xA1,
        PKT_C2S_Surrender = 0xA4,
        PKT_C2S_StatsConfirm = 0xA8,
        PKT_S2C_SetHealth = 0xAE,
        PKT_C2S_Click = 0xAF,

        PKT_S2C_SpellAnimation = 0xB0,
        PKT_S2C_Tutorial = 0xB3,
        PKT_S2C_CastSpellAns = 0xB5,
        PKT_S2C_AfkWarning = 0xB8,
        PKT_S2C_MinionSpawn = 0xBA,
        PKT_C2S_SynchVersion = 0xBD,
        PKT_C2S_CharLoaded = 0xBE,

        PKT_S2C_GameTimer = 0xC1,
        PKT_S2C_GameTimerUpdate = 0xC2,
        PKT_S2C_CharStats = 0xC4,
        PKT_S2C_EndGame = 0xC6,
        PKT_S2C_SpawnBot = 0xCF,
        
        PKT_S2C_SpawnLevelProp = 0xD0,
        PKT_S2C_UpdateLevelProp = 0xD1,
        PKT_S2C_HandleCapturePointUpdate = 0xD3,
        
        PKT_S2C_GoldGain = 0xE4,
        PKT_S2C_ActivateMinionCamp = 0xE4,


        PKT_Batch = 0xFF
    };
    enum Channel : byte
    {
        CHL_HANDSHAKE = 0,
        CHL_C2S = 1,
        CHL_GAMEPLAY = 2,
        CHL_S2C = 3,
        CHL_LOW_PRIORITY = 4,
        CHL_COMMUNICATION = 5,
        CHL_LOADING_SCREEN = 7,
    };
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public struct KeyCheck
    {
        public Byte cmd;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
        public Byte[] partialKey;
        public UInt32 playerNo;
        public UInt64 userId;
        public UInt32 trash;
        public UInt64 checkId;
        public UInt32 trash2;
        public static KeyCheck Create(UInt64 userId, UInt64 checkId)
        {
            KeyCheck keyCheck;
            keyCheck.cmd = (Byte)PacketCmd.PKT_KeyCheck;
            keyCheck.userId = userId;
            keyCheck.checkId = checkId;
            keyCheck.playerNo = keyCheck.trash = keyCheck.trash2 = 0;
            keyCheck.partialKey = new byte[3] { 0xcc, 0xcc, 0xcc };
            return keyCheck;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct PacketHeader
    {
        public Byte cmd;
        public UInt32 netId;
        public static PacketHeader Create(PacketCmd cmd, UInt32 netId)
        {
            PacketHeader pktHeader;
            pktHeader.cmd = (Byte)cmd;
            pktHeader.netId = netId;
            return pktHeader;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct PacketHeader8
    {
        public PacketHeader header;
        public Byte unk;
        public static PacketHeader8 Create(PacketCmd cmd)
        {
            PacketHeader8 pkt;
            pkt.header = PacketHeader.Create(cmd, 0);
            pkt.unk = 1;
            return pkt;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct StartGame
    {
        public PacketHeader header;
        public UInt64 unk1;
        public UInt64 unk2;
        public static StartGame Create()
        {
            StartGame pkt;
            pkt.header = PacketHeader.Create(PacketCmd.PKT_C2S_StartGame, 0);
            pkt.unk1 = pkt.unk2 = 0;
            return pkt;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct GameHeader
    {
        public PacketHeader header;
        public UInt32 tick;
        public static GameHeader Create(PacketCmd cmd, UInt32 netId, UInt32 tick)
        {
            GameHeader gameHeader = new GameHeader();
            gameHeader.header = PacketHeader.Create(cmd, netId);
            gameHeader.tick = tick;
            return gameHeader;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct GameTime
    {
        public PacketHeader header;
        public float tick1;
        public float tick2;
        public static GameTime Create(float tick)
        {
            GameTime gameHeader = new GameTime();
            gameHeader.header = PacketHeader.Create(PacketCmd.PKT_C2S_InGame, 0);
            gameHeader.tick1 = gameHeader.tick2 = tick;
            return gameHeader;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct GameTimer
    {
        public PacketHeader header;
        public float tick1;
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct SynchVersion
    {
        public PacketHeader header;
        public UInt32 unk1;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
        public Byte[] version; //Dunno how big and when usefull data begins
        public static SynchVersion Create()
        {
            SynchVersion synch;
            int i = 0;
            synch.header = PacketHeader.Create(PacketCmd.PKT_C2S_SynchVersion, 0);
            synch.unk1 = 0;
            synch.version = new Byte[265]; synch.version[i++] = 0x56; synch.version[i++] = 0x65; synch.version[i++] = 0x72; synch.version[i++] = 0x73; synch.version[i++] = 0x69;
            synch.version[i++] = 0x6f; synch.version[i++] = 0x6e; synch.version[i++] = 0x20; synch.version[i++] = 0x34; synch.version[i++] = 0x2e;
            synch.version[i++] = 0x31; synch.version[i++] = 0x36; synch.version[i++] = 0x2e; synch.version[i++] = 0x30; synch.version[i++] = 0x2e;
            synch.version[i++] = 0x32; synch.version[i++] = 0x33; synch.version[i++] = 0x38; synch.version[i++] = 0x20; synch.version[i++] = 0x5b;
            synch.version[i++] = 0x50; synch.version[i++] = 0x55; synch.version[i++] = 0x42; synch.version[i++] = 0x4c; synch.version[i++] = 0x49;
            synch.version[i++] = 0x43; synch.version[i++] = 0x5d; synch.version[i++] = 0x00; synch.version[i++] = 0xfc; synch.version[i++] = 0x97;
            synch.version[i++] = 0x03; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x0f; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0xc0; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0xb8; synch.version[i++] = 0x59;
            synch.version[i++] = 0x66; synch.version[i++] = 0x05; synch.version[i++] = 0xc8; synch.version[i++] = 0x0e; synch.version[i++] = 0x02;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0xb4; synch.version[i++] = 0xf6; synch.version[i++] = 0x22; synch.version[i++] = 0x00; synch.version[i++] = 0xcd;
            synch.version[i++] = 0x76; synch.version[i++] = 0x23; synch.version[i++] = 0x77; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x2c; synch.version[i++] = 0xf7; synch.version[i++] = 0x22;
            synch.version[i++] = 0x00; synch.version[i++] = 0x82; synch.version[i++] = 0x2d; synch.version[i++] = 0x27; synch.version[i++] = 0x75;
            synch.version[i++] = 0xc8; synch.version[i++] = 0x0e; synch.version[i++] = 0x02; synch.version[i++] = 0x00; synch.version[i++] = 0x81;
            synch.version[i++] = 0x02; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x0f; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0xc0; synch.version[i++] = 0xc8; synch.version[i++] = 0x0e; synch.version[i++] = 0x02; synch.version[i++] = 0x00;
            synch.version[i++] = 0x45; synch.version[i++] = 0x0e; synch.version[i++] = 0xc8; synch.version[i++] = 0x09; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x45; synch.version[i++] = 0x0e;
            synch.version[i++] = 0xc8; synch.version[i++] = 0x09; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x0f; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0xc0; synch.version[i++] = 0x34; synch.version[i++] = 0xf7; synch.version[i++] = 0x22;
            synch.version[i++] = 0x00; synch.version[i++] = 0x2f; synch.version[i++] = 0x26; synch.version[i++] = 0x27; synch.version[i++] = 0x75;
            synch.version[i++] = 0xb8; synch.version[i++] = 0x59; synch.version[i++] = 0x66; synch.version[i++] = 0x05; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x98; synch.version[i++] = 0xf9;
            synch.version[i++] = 0x22; synch.version[i++] = 0x00; synch.version[i++] = 0x67; synch.version[i++] = 0xe3; synch.version[i++] = 0x23;
            synch.version[i++] = 0x77; synch.version[i++] = 0x6f; synch.version[i++] = 0xe3; synch.version[i++] = 0x23; synch.version[i++] = 0x77;
            synch.version[i++] = 0xc8; synch.version[i++] = 0x0e; synch.version[i++] = 0x02; synch.version[i++] = 0x00; synch.version[i++] = 0x45;
            synch.version[i++] = 0x0e; synch.version[i++] = 0xc8; synch.version[i++] = 0x09; synch.version[i++] = 0x45; synch.version[i++] = 0x0e;
            synch.version[i++] = 0xc8; synch.version[i++] = 0x09; synch.version[i++] = 0xc8; synch.version[i++] = 0x0e; synch.version[i++] = 0x02;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0xaf; synch.version[i++] = 0xdc; synch.version[i++] = 0x23; synch.version[i++] = 0x77; synch.version[i++] = 0x18;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x87; synch.version[i++] = 0x02;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0xc2; synch.version[i++] = 0xdc; synch.version[i++] = 0x23;
            synch.version[i++] = 0x77; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x38;
            synch.version[i++] = 0x8f; synch.version[i++] = 0x37; synch.version[i++] = 0x05; synch.version[i++] = 0x50; synch.version[i++] = 0xfa;
            synch.version[i++] = 0x97; synch.version[i++] = 0x03; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0xfc; synch.version[i++] = 0x97; synch.version[i++] = 0x03;
            synch.version[i++] = 0xbc; synch.version[i++] = 0x02; synch.version[i++] = 0x18; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0xfc;
            synch.version[i++] = 0x97; synch.version[i++] = 0x03; synch.version[i++] = 0xc8; synch.version[i++] = 0xf7; synch.version[i++] = 0x22;
            synch.version[i++] = 0x00; synch.version[i++] = 0x14; synch.version[i++] = 0xa9; synch.version[i++] = 0x23; synch.version[i++] = 0x77;
            synch.version[i++] = 0x50; synch.version[i++] = 0xfa; synch.version[i++] = 0x97; synch.version[i++] = 0x03; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0xfc;
            synch.version[i++] = 0x97; synch.version[i++] = 0x03; synch.version[i++] = 0x00; synch.version[i++] = 0x00; synch.version[i++] = 0x00;
            synch.version[i++] = 0x00; synch.version[i++] = 0xb7; synch.version[i++] = 0xfd; synch.version[i++] = 0x76; synch.version[i++] = 0xa7;
            synch.version[i++] = 0xc8; synch.version[i++] = 0xfd; synch.version[i++] = 0xfd; synch.version[i++] = 0xfd; synch.version[i++] = 0xfd;
            synch.version[i++] = 0xab; synch.version[i++] = 0xab; synch.version[i++] = 0xab; synch.version[i++] = 0xab; synch.version[i++] = 0xab;
            return synch;
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct SynchBlock
    {
        UInt64 userId;
        UInt16 netId;
        UInt32 skill1;
        UInt32 skill2;
        Byte flag;
        UInt32 teamId;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
        Byte[] data1;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
        Byte[] data2;
        UInt32 unk2;
        UInt32 unk3;
        public static SynchBlock Create()
        {
            SynchBlock synch = new SynchBlock();
            synch.userId = 0xFFFFFFFFFFFFFFFF;
            synch.netId = 0x1E;
            synch.teamId = 0x64;
            synch.flag = 0; //1 for bot?
            synch.unk3 = 0x19;
            return synch;
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct SynchVersionAns
    {
        public PacketHeader header;
        public Byte ok;
        public UInt32 mapId;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)]
        public SynchBlock[] players;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 27)]
        public Byte[] version;      //Ending zero so size 26+0x00
        public Byte ok2;              //1
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 228)]
        public Byte[] unknown;     //Really strange shit
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public Byte[] gameMode;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2232)]
        public Byte[] zero;
        public UInt16 end1;            //0xE2E0
        public Byte end2;             //0xA0 || 0x08
        public static SynchVersionAns Create()
        {
            SynchVersionAns synch = new SynchVersionAns();
            synch.header = PacketHeader.Create(PacketCmd.PKT_S2C_SynchVersion, 0);
            synch.ok = synch.ok2 = 1;
            /*memcpy(version, "Version 4.5.0.264 [PUBLIC]", 27);
            memcpy(gameMode, "CLASSIC", 8);
            memset(zero, 0, 2232);*/
            /*synch.version = new Byte[27];
            synch.unknown = new Byte[228];
            synch.gameMode = new Byte[8];
            synch.zero = new Byte[2232];*/
            synch.end1 = 0xE2E0;
            synch.end2 = 0xA0;
            return synch;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct ClientReady
    {
        public PacketHeader header;
        public UInt32 teamId;
        public static ClientReady Create()
        {
            ClientReady client = new ClientReady();
            client.header = PacketHeader.Create(PacketCmd.PKT_C2S_ClientReady, 0);
            client.teamId = client.header.cmd;
            return client;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct LoadScreenInfo
    {

        public Byte cmd;
        public UInt32 blueMax;
        public UInt32 redMax;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
        public UInt64[] bluePlayerIds; //Team 1, 6 players max
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 144)]
        public Byte[] blueData;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
        public UInt64[] redPlayersIds; //Team 2, 6 players max
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 144)]
        public Byte[] redData;
        public UInt32 bluePlayerNo;
        public UInt32 redPlayerNo;
        public static LoadScreenInfo Create()
        {
            LoadScreenInfo loadScreenInfo = new LoadScreenInfo();
            loadScreenInfo.cmd = (Byte)PacketCmd.PKT_S2C_LoadScreenInfo;
            return loadScreenInfo;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct LoadScreenPlayer
    {
        public Byte cmd;
        public UInt64 userId;
        public UInt32 skinId;
        public UInt32 length;
        public Byte description;
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct PingLoadInfo
    {
        public PacketHeader header;
        public UInt32 unk1;
        public UInt64 userId;//all F's?
        public float loaded;
        public float ping;
        public UInt32 unk2;
        public static PingLoadInfo Create()
        {
            PingLoadInfo ping = new PingLoadInfo();
            ping.header = PacketHeader.Create(PacketCmd.PKT_C2S_Ping_Load_Info, 0);
            return ping;
        }
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct MoveConfirm
    {
        public GameHeader header;
        public Byte zero;
        public static MoveConfirm Create(UInt32 tick)
        {
            MoveConfirm move = new MoveConfirm();
            move.header = GameHeader.Create(PacketCmd.PKT_C2S_MoveConfirm, 0, tick);
            return move;
        }
    }
    enum MoveType : byte
    {
        EMOTE = 1,
        MOVE = 2,
        ATK_MOVE = 7,
        STOP = 10,
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct MovementReq
    {
        PacketHeader header;
        MoveType type;
        float x;
        float y;
        UInt32 zero;
        Byte vectorNo;
        UInt32 netId;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 7)]
        Byte[] moveData;
        public static MovementReq Create(float x, float y, UInt32 netId)
        {
            MovementReq move = new MovementReq();
            move.header = PacketHeader.Create(PacketCmd.PKT_C2S_MoveReq, netId);
            move.x = x;
            move.y = y;
            move.type = MoveType.ATK_MOVE;
            move.vectorNo = 2;
            Byte[] xbytes = BitConverter.GetBytes(x);
            Byte[] ybytes = BitConverter.GetBytes(y);
            move.moveData = new Byte[7]{
                xbytes[0], xbytes[1],
                ybytes[0], ybytes[1],
                0xff, 0xff, 0xff
            };
            return move;
        }
    }
    public class Update
    {
        public class Unit
        {
            public class Mask
            {
                public UInt32 subMask;
                public Byte sectionLen;
                public List<float> values;
                public Mask() { values = new List<float>(); }
            }
            public Byte masterMask;
            public float netId;
            public List<Mask> masks;
            public Unit() { masks = new List<Mask>(); }
        }
        GameHeader header;
        Byte updateCount;
        List<Unit> units;
        public Update(byte[] data)
        {
            List<List<String>> masterMask = new List<List<String>>();
            for (int i = 0; i < 6; i++)
            {
                List<String> mask = new List<String>();
                for (int j = 0; j < 32; j++)
                {
                    mask.Add("null");
                }
                masterMask.Add(mask);
            }
            masterMask[2][7] = "duration";
            masterMask[2][12] = "mp5";
            masterMask[4][1] = "hp";
            masterMask[4][2] = "mp";
            masterMask[4][5] = "xp";
            int offset = 9;
            updateCount = data[offset++];
            units = new List<Unit>();
            for (int i = 0; i < updateCount; i++)
            {
                Unit unit = new Unit();
                unit.masterMask = data[offset++];
                //unit.netId = BitConverter.ToSingle(new byte[4] { data[offset++], data[offset++], data[offset++], data[offset++] }, 0);
                String netId2 = BitConverter.ToString(new byte[4] { data[offset++], data[offset++], data[offset++], data[offset++] }, 0);
                UInt32 temp = unit.masterMask;
                UInt32 temp2 = temp;
                int count = 0;
                while (temp > 0){
                    if ((temp & 1) == 1)
                    {
                        temp2 -= temp;
                        int startPos = offset;
                        Unit.Mask subMask = new Unit.Mask();
                        subMask.subMask = BitConverter.ToUInt32(new byte[4] { data[offset++], data[offset++], data[offset++], data[offset++] }, 0);
                        subMask.sectionLen = data[offset++];
                        UInt32 temp3 = subMask.subMask;
                        int count2 = 0;
                        while (temp3 > 0)
                        {
                            if ((temp3 & 1) == 1)
                            {
                                try
                                {
                                    float val = BitConverter.ToSingle(new byte[4] { data[offset++], data[offset++], data[offset++], data[offset++] }, 0);
                                    subMask.values.Add(val);
                                }
                                catch { }
                            }
                            count2++;
                            temp3 >>= 1;
                            if (offset >= startPos + 5 + subMask.sectionLen)
                                break;
                        }
                        offset = startPos + 5 + subMask.sectionLen;
                    }
                    count++;
                    temp >>= 1;
                }
            }
        }
    }
    public class Waypoints
    {
        public class Unit
        {
            public Byte waypointCount;
            public UInt32 netId;
            public List<Byte> bitMasks;
            public System.Drawing.Point waypoint;
            public Unit() { bitMasks = new List<Byte>(); }
        }
        GameHeader header;
        UInt16 unitCount;
        List<Unit> units;
        public Waypoints(byte[] data)
        {
            int offset = 9;
            unitCount = BitConverter.ToUInt16(new Byte[2] { data[offset++], data[offset++] }, 0);
            units = new List<Unit>();
            for (int i = 0; i < unitCount; i++)
            {
                Unit unit = new Unit();
                unit.waypointCount = (byte)(data[offset++] >> 1);
                unit.netId = BitConverter.ToUInt32(new Byte[4] { data[offset++], data[offset++], data[offset++], data[offset++] }, 0);
                List<Byte> modifierBits = new List<Byte>();
                for (int j = 0; j < Math.Ceiling((double)(unit.waypointCount - 1) / 4); j++)
                {
                    Byte bitMask = data[offset++];
                    unit.bitMasks.Add(bitMask);
                    for (int k = 0; k < 8; k++)
                    {
                        modifierBits.Add((byte)(bitMask & 1));
                        bitMask >>= 1;
                    }
                }
                for (int j = 0; j < unit.waypointCount; j++)
                {
                    Byte popX = modifierBits[modifierBits.Count - 1];
                    modifierBits.RemoveAt(modifierBits.Count - 1);
                    Byte popY = modifierBits[modifierBits.Count - 1];
                    modifierBits.RemoveAt(modifierBits.Count - 1);
                    try
                    {
                        Byte[] x;
                        if (popX == 1)
                            x = new Byte[4] { data[offset++], 0, 0, 0 };
                        else
                            x = new Byte[4] { data[offset++], data[offset++], 0, 0 };
                        Byte[] y;
                        if (popY == 1)
                            y = new Byte[4] { data[offset++], 0, 0, 0 };
                        else
                            y = new Byte[4] { data[offset++], data[offset++], 0, 0 };
                        unit.waypoint = new System.Drawing.Point(BitConverter.ToInt32(x, 0), BitConverter.ToInt32(y, 0));
                    }
                    catch { }
                }
            }
        }
    }
}

```

`LoLClient/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace LoLClient
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1(args));
        }
    }
}

```

`LoLClient/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LoLClient")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("LoLClient")]
[assembly: AssemblyCopyright("Copyright ©  2014")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("829f8f94-448b-4082-8ee8-67f79fabc986")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`LoLClient/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LoLClient.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("LoLClient.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}

```

`LoLClient/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`LoLClient/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LoLClient.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}

```

`LoLClient/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>

```