Project Path: arc_gmh5225_sk3wldbg_efx45kdq

Source Tree:

```txt
arc_gmh5225_sk3wldbg_efx45kdq
├── AUTHORS
├── COPYING
├── ChangeLog
├── LICENSE
├── Makefile
├── README.md
├── bins
│   ├── linux
│   │   ├── ida70
│   │   │   ├── sk3wldbg_user.so
│   │   │   └── sk3wldbg_user64.so
│   │   ├── ida71
│   │   │   ├── sk3wldbg_user.so
│   │   │   └── sk3wldbg_user64.so
│   │   ├── ida72
│   │   │   ├── sk3wldbg_user.so
│   │   │   └── sk3wldbg_user64.so
│   │   ├── ida73
│   │   │   ├── sk3wldbg_user.so
│   │   │   └── sk3wldbg_user64.so
│   │   ├── ida74
│   │   │   ├── sk3wldbg_user.so
│   │   │   └── sk3wldbg_user64.so
│   │   └── ida75
│   │       ├── sk3wldbg_user.so
│   │       └── sk3wldbg_user64.so
│   ├── mac
│   │   ├── ida70
│   │   │   ├── sk3wldbg_user.dylib
│   │   │   └── sk3wldbg_user64.dylib
│   │   ├── ida71
│   │   │   ├── sk3wldbg_user.dylib
│   │   │   └── sk3wldbg_user64.dylib
│   │   ├── ida72
│   │   │   ├── sk3wldbg_user.dylib
│   │   │   └── sk3wldbg_user64.dylib
│   │   ├── ida73
│   │   │   ├── sk3wldbg_user.dylib
│   │   │   └── sk3wldbg_user64.dylib
│   │   ├── ida74
│   │   │   ├── sk3wldbg_user.dylib
│   │   │   └── sk3wldbg_user64.dylib
│   │   └── ida75
│   │       ├── sk3wldbg_user.dylib
│   │       └── sk3wldbg_user64.dylib
│   └── windows
│       ├── ida70
│       │   ├── sk3wldbg_user.dll
│       │   └── sk3wldbg_user64.dll
│       ├── ida71
│       │   ├── sk3wldbg_user.dll
│       │   └── sk3wldbg_user64.dll
│       ├── ida72
│       │   ├── sk3wldbg_user.dll
│       │   └── sk3wldbg_user64.dll
│       ├── ida73
│       │   ├── sk3wldbg_user.dll
│       │   └── sk3wldbg_user64.dll
│       ├── ida74
│       │   ├── sk3wldbg_user.dll
│       │   └── sk3wldbg_user64.dll
│       └── ida75
│           ├── sk3wldbg_user.dll
│           └── sk3wldbg_user64.dll
├── elf_local.h
├── heap.h
├── idc_funcs.cpp
├── idc_funcs.h
├── include
│   ├── list.h
│   ├── qemu.h
│   ├── uc_priv.h
│   └── unicorn
│       ├── arm.h
│       ├── arm64.h
│       ├── m68k.h
│       ├── mips.h
│       ├── platform.h
│       ├── sparc.h
│       ├── unicorn.h
│       └── x86.h
├── linux_kernel_x64.asm
├── linux_x64_syscall_bpcond.py
├── loader.cpp
├── loader.h
├── mem_mgr.cpp
├── mem_mgr.h
├── pe_local.h
├── sk3wldbg.cpp
├── sk3wldbg.h
├── sk3wldbg_arm.cpp
├── sk3wldbg_arm.h
├── sk3wldbg_m68k.cpp
├── sk3wldbg_m68k.h
├── sk3wldbg_mips.cpp
├── sk3wldbg_mips.h
├── sk3wldbg_plugin.cpp
├── sk3wldbg_ppc.cpp
├── sk3wldbg_ppc.h
├── sk3wldbg_sparc.cpp
├── sk3wldbg_sparc.h
├── sk3wldbg_x86.cpp
├── sk3wldbg_x86.h
├── teb32.h
├── vs13
│   ├── lib
│   │   ├── x64
│   │   │   ├── unicorn.dll
│   │   │   └── unicorn.lib
│   │   └── x86
│   │       ├── unicorn.dll
│   │       └── unicorn.lib
│   ├── sk3wldbg.sln
│   ├── sk3wldbg.vcxproj
│   ├── sk3wldbg.vcxproj.filters
│   └── sk3wldbg.vcxproj.user
└── vs17
    ├── lib
    │   ├── x64
    │   │   ├── unicorn.dll
    │   │   └── unicorn.lib
    │   └── x86
    │       ├── unicorn.dll
    │       └── unicorn.lib
    ├── sk3wldbg.sln
    ├── sk3wldbg.vcxproj
    ├── sk3wldbg.vcxproj.filters
    └── sk3wldbg.vcxproj.user

```

`AUTHORS`:

```
Chris Eagle, cseagle at gmail d0t com
```

`COPYING`:

```
The GNU General Public License (GPL) Version 2, June 1991

Copyright (C) 1989, 1991 Free Software Foundation, Inc. 59 Temple Place, Suite 
330, Boston, MA 02111-1307 USA

Everyone is permitted to copy and distribute verbatim copies of this license 
document, but changing it is not allowed.

Preamble

The licenses for most software are designed to take away your freedom to share 
and change it. By contrast, the GNU General Public License is intended to 
guarantee your freedom to share and change free software--to make sure the 
software is free for all its users. This General Public License applies to most 
of the Free Software Foundation's software and to any other program whose 
authors commit to using it. (Some other Free Software Foundation software is 
covered by the GNU Library General Public License instead.) You can apply it to 
your programs, too.

When we speak of free software, we are referring to freedom, not price. Our 
General Public Licenses are designed to make sure that you have the freedom to 
distribute copies of free software (and charge for this service if you wish), 
that you receive source code or can get it if you want it, that you can change 
the software or use pieces of it in new free programs; and that you know you can 
do these things.

To protect your rights, we need to make restrictions that forbid anyone to deny 
you these rights or to ask you to surrender the rights. These restrictions 
translate to certain responsibilities for you if you distribute copies of the 
software, or if you modify it.

For example, if you distribute copies of such a program, whether gratis or for a 
fee, you must give the recipients all the rights that you have. You must make 
sure that they, too, receive or can get the source code. And you must show them 
these terms so they know their rights.

We protect your rights with two steps: (1) copyright the software, and (2) offer 
you this license which gives you legal permission to copy, distribute and/or 
modify the software.

Also, for each author's protection and ours, we want to make certain that 
everyone understands that there is no warranty for this free software. If the 
software is modified by someone else and passed on, we want its recipients to 
know that what they have is not the original, so that any problems introduced by 
others will not reflect on the original authors' reputations.

Finally, any free program is threatened constantly by software patents. We wish 
to avoid the danger that redistributors of a free program will individually 
obtain patent licenses, in effect making the program proprietary. To prevent 
this, we have made it clear that any patent must be licensed for everyone's free 
use or not licensed at all.

The precise terms and conditions for copying, distribution and modification 
follow.

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

0. This License applies to any program or other work which contains a notice 
placed by the copyright holder saying it may be distributed under the terms of 
this General Public License. The "Program", below, refers to any such program or 
work, and a "work based on the Program" means either the Program or any 
derivative work under copyright law: that is to say, a work containing the 
Program or a portion of it, either verbatim or with modifications and/or 
translated into another language. (Hereinafter, translation is included without 
limitation in the term "modification".) Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not covered by 
this License; they are outside its scope. The act of running the Program is not 
restricted, and the output from the Program is covered only if its contents 
constitute a work based on the Program (independent of having been made by 
running the Program). Whether that is true depends on what the Program does.

1. You may copy and distribute verbatim copies of the Program's source code as 
you receive it, in any medium, provided that you conspicuously and appropriately 
publish on each copy an appropriate copyright notice and disclaimer of warranty; 
keep intact all the notices that refer to this License and to the absence of any 
warranty; and give any other recipients of the Program a copy of this License 
along with the Program.

You may charge a fee for the physical act of transferring a copy, and you may at 
your option offer warranty protection in exchange for a fee.

2. You may modify your copy or copies of the Program or any portion of it, thus 
forming a work based on the Program, and copy and distribute such modifications 
or work under the terms of Section 1 above, provided that you also meet all of 
these conditions:

    a) You must cause the modified files to carry prominent notices stating that 
    you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in whole or 
    in part contains or is derived from the Program or any part thereof, to be 
    licensed as a whole at no charge to all third parties under the terms of 
    this License.

    c) If the modified program normally reads commands interactively when run, 
    you must cause it, when started running for such interactive use in the most 
    ordinary way, to print or display an announcement including an appropriate 
    copyright notice and a notice that there is no warranty (or else, saying 
    that you provide a warranty) and that users may redistribute the program 
    under these conditions, and telling the user how to view a copy of this 
    License. (Exception: if the Program itself is interactive but does not 
    normally print such an announcement, your work based on the Program is not 
    required to print an announcement.)

These requirements apply to the modified work as a whole. If identifiable 
sections of that work are not derived from the Program, and can be reasonably 
considered independent and separate works in themselves, then this License, and 
its terms, do not apply to those sections when you distribute them as separate 
works. But when you distribute the same sections as part of a whole which is a 
work based on the Program, the distribution of the whole must be on the terms of 
this License, whose permissions for other licensees extend to the entire whole, 
and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest your 
rights to work written entirely by you; rather, the intent is to exercise the 
right to control the distribution of derivative or collective works based on the 
Program.

In addition, mere aggregation of another work not based on the Program with the 
Program (or with a work based on the Program) on a volume of a storage or 
distribution medium does not bring the other work under the scope of this 
License.

3. You may copy and distribute the Program (or a work based on it, under Section 
2) in object code or executable form under the terms of Sections 1 and 2 above 
provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable source 
    code, which must be distributed under the terms of Sections 1 and 2 above on 
    a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three years, to 
    give any third party, for a charge no more than your cost of physically 
    performing source distribution, a complete machine-readable copy of the 
    corresponding source code, to be distributed under the terms of Sections 1 
    and 2 above on a medium customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer to 
    distribute corresponding source code. (This alternative is allowed only for 
    noncommercial distribution and only if you received the program in object 
    code or executable form with such an offer, in accord with Subsection b 
    above.)

The source code for a work means the preferred form of the work for making 
modifications to it. For an executable work, complete source code means all the 
source code for all modules it contains, plus any associated interface 
definition files, plus the scripts used to control compilation and installation 
of the executable. However, as a special exception, the source code distributed 
need not include anything that is normally distributed (in either source or 
binary form) with the major components (compiler, kernel, and so on) of the 
operating system on which the executable runs, unless that component itself 
accompanies the executable.

If distribution of executable or object code is made by offering access to copy 
from a designated place, then offering equivalent access to copy the source code 
from the same place counts as distribution of the source code, even though third 
parties are not compelled to copy the source along with the object code.

4. You may not copy, modify, sublicense, or distribute the Program except as 
expressly provided under this License. Any attempt otherwise to copy, modify, 
sublicense or distribute the Program is void, and will automatically terminate 
your rights under this License. However, parties who have received copies, or 
rights, from you under this License will not have their licenses terminated so 
long as such parties remain in full compliance.

5. You are not required to accept this License, since you have not signed it. 
However, nothing else grants you permission to modify or distribute the Program 
or its derivative works. These actions are prohibited by law if you do not 
accept this License. Therefore, by modifying or distributing the Program (or any 
work based on the Program), you indicate your acceptance of this License to do 
so, and all its terms and conditions for copying, distributing or modifying the 
Program or works based on it.

6. Each time you redistribute the Program (or any work based on the Program), 
the recipient automatically receives a license from the original licensor to 
copy, distribute or modify the Program subject to these terms and conditions. 
You may not impose any further restrictions on the recipients' exercise of the 
rights granted herein. You are not responsible for enforcing compliance by third 
parties to this License.

7. If, as a consequence of a court judgment or allegation of patent infringement 
or for any other reason (not limited to patent issues), conditions are imposed 
on you (whether by court order, agreement or otherwise) that contradict the 
conditions of this License, they do not excuse you from the conditions of this 
License. If you cannot distribute so as to satisfy simultaneously your 
obligations under this License and any other pertinent obligations, then as a 
consequence you may not distribute the Program at all. For example, if a patent 
license would not permit royalty-free redistribution of the Program by all those 
who receive copies directly or indirectly through you, then the only way you 
could satisfy both it and this License would be to refrain entirely from 
distribution of the Program.

If any portion of this section is held invalid or unenforceable under any 
particular circumstance, the balance of the section is intended to apply and the 
section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any patents or 
other property right claims or to contest validity of any such claims; this 
section has the sole purpose of protecting the integrity of the free software 
distribution system, which is implemented by public license practices. Many 
people have made generous contributions to the wide range of software 
distributed through that system in reliance on consistent application of that 
system; it is up to the author/donor to decide if he or she is willing to 
distribute software through any other system and a licensee cannot impose that 
choice.

This section is intended to make thoroughly clear what is believed to be a 
consequence of the rest of this License.

8. If the distribution and/or use of the Program is restricted in certain 
countries either by patents or by copyrighted interfaces, the original copyright 
holder who places the Program under this License may add an explicit 
geographical distribution limitation excluding those countries, so that 
distribution is permitted only in or among countries not thus excluded. In such 
case, this License incorporates the limitation as if written in the body of this 
License.

9. The Free Software Foundation may publish revised and/or new versions of the 
General Public License from time to time. Such new versions will be similar in 
spirit to the present version, but may differ in detail to address new problems 
or concerns.

Each version is given a distinguishing version number. If the Program specifies 
a version number of this License which applies to it and "any later version", 
you have the option of following the terms and conditions either of that version 
or of any later version published by the Free Software Foundation. If the 
Program does not specify a version number of this License, you may choose any 
version ever published by the Free Software Foundation.

10. If you wish to incorporate parts of the Program into other free programs 
whose distribution conditions are different, write to the author to ask for 
permission. For software which is copyrighted by the Free Software Foundation, 
write to the Free Software Foundation; we sometimes make exceptions for this. 
Our decision will be guided by the two goals of preserving the free status of 
all derivatives of our free software and of promoting the sharing and reuse of 
software generally.

NO WARRANTY

11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE 
PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED 
IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS 
IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT 
NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE 
PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF 
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL 
ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE 
PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, 
SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY 
TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING 
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF 
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER 
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

END OF TERMS AND CONDITIONS

How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest possible use 
to the public, the best way to achieve this is to make it free software which 
everyone can redistribute and change under these terms.

To do so, attach the following notices to the program. It is safest to attach 
them to the start of each source file to most effectively convey the exclusion 
of warranty; and each file should have at least the "copyright" line and a 
pointer to where the full notice is found.

    one line to give the program's name and a brief idea of what it does. 
    Copyright (C)

    This program is free software; you can redistribute it and/or modify it 
    under the terms of the GNU General Public License as published by the Free 
    Software Foundation; either version 2 of the License, or (at your option) 
    any later version.

    This program is distributed in the hope that it will be useful, but WITHOUT 
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
    FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
    more details.

    You should have received a copy of the GNU General Public License along with 
    this program; if not, write to the Free Software Foundation, Inc., 59 Temple 
    Place, Suite 330, Boston, MA 02111-1307 USA

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this when it 
starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author Gnomovision comes 
    with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free 
    software, and you are welcome to redistribute it under certain conditions; 
    type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate 
parts of the General Public License. Of course, the commands you use may be 
called something other than `show w' and `show c'; they could even be 
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your school, 
if any, to sign a "copyright disclaimer" for the program, if necessary. Here is 
a sample; alter the names:

    Yoyodyne, Inc., hereby disclaims all copyright interest in the program 
    `Gnomovision' (which makes passes at compilers) written by James Hacker.

    signature of Ty Coon, 1 April 1989 Ty Coon, President of Vice

This General Public License does not permit incorporating your program into 
proprietary programs. If your program is a subroutine library, you may consider 
it more useful to permit linking proprietary applications with the library. If 
this is what you want to do, use the GNU Library General Public License instead 
of this License.

```

`ChangeLog`:

```
* 03/13/18
  Debugger installs two idc functions:
     int64 sk3wl_mmap(int64 base, long size, int perms) where perms are a combination of:
         #define SEGPERM_EXEC  1         ///< Execute
         #define SEGPERM_WRITE 2         ///< Write
         #define SEGPERM_READ  4         ///< Read
     void sk3wl_munmap(int64 base, long size)
     sk3wl_mmap may be used to map new regions of memory into an emulated unicorn process
* 03/13/18
  Update to build for IDA 7.1
* 10/2/17
  Update to build for IDA 7.0
* 9/6/16
  Build minimal ELF environment in elf stacks
  Improve stability wrt debugger term/restart, and closing databases/ida
  Better state reset between debugging sessions 
* 9/5/16
  Make menu installation thread safe
  Map stacks as RWX until we allow user's to choose X vs NX, for ELF defer to PT_GNU_STACK if present
  Correctly handle endian-ness in ELF headers
* 6/6/16
  Sync to latest Unicorn
  Don't call ANY IDA functions from Unicorn thread!
* 5/31/16
  Change binary name to sk3wldbg_user because IDA wants an _ in debugger names
* 4/26/16
  Initial efforts to handle memory access errors
  Updated binaries
* 4/20/16
  Initial push to github

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`Makefile`:

```
#Set this variable to point to your SDK directory
IDA_SDK=../../

SDKVER=$(shell pwd | grep -o -E "idasdk[0-9]{2,3}" | cut -c 7-)
IDAVER=$(shell pwd | grep -o -E "idasdk[0-9]{2,3}" | cut -c 7- | sed 's/\(.\)\(.\)/\1\.\2/')
IDAVER_MAJOR=$(shell pwd | grep -o -E "idasdk[0-9]{2,3}" | cut -c 7)

PLATFORM=$(shell uname | cut -f 1 -d _)

#Set this variable to the desired name of your compiled plugin
PROC=sk3wldbg_user

ifeq "$(PLATFORM)" "Linux"
IDA=/opt/ida-$(IDAVER)
HAVE_IDA64=$(shell if [ -f $(IDA)/libida64.so ]; then echo -n yes; fi)
PLATFORM_CFLAGS=-D__LINUX__
PLATFORM_LDFLAGS=-shared -s
IDADIR=-L$(IDA)

ifeq "$(IDAVER_MAJOR)" "6"
PLUGIN_EXT32=.plx
PLUGIN_EXT64=.plx64
else
PLUGIN_EXT32=.so
PLUGIN_EXT64=64.so
endif

IDALIB32=-lida
IDALIB64=-lida64

else ifeq "$(PLATFORM)" "Darwin"

IDAHOME=/Applications/IDA Pro $(IDAVER)

ifeq "$(IDAVER_MAJOR)" "6"
IDA=$(shell dirname "`find "$(IDAHOME)" -name idaq | tail -n 1`")
PLUGIN_EXT32=.pmc
PLUGIN_EXT64=.pmc64
else
IDA=$(shell dirname "`find "$(IDAHOME)" -name ida | tail -n 1`")
PLUGIN_EXT32=.dylib
PLUGIN_EXT64=64.dylib
endif

HAVE_IDA64=$(shell find "$(IDA)" -name libida64.dylib -exec echo -n yes \;)
PLATFORM_CFLAGS=-D__MAC__
PLATFORM_LDFLAGS=-dynamiclib
IDADIR=-L"$(IDA)"

IDALIB32=-lida
IDALIB64=-lida64
endif

ifeq "$(IDAVER_MAJOR)" "6"
CFLAGS=-Wextra -Os $(PLATFORM_CFLAGS) -m32 -fPIC
LDFLAGS=$(PLATFORM_LDFLAGS) -m32
else
CFLAGS=-Wextra -Os $(PLATFORM_CFLAGS) -D__X64__ -m64  -fPIC
LDFLAGS=$(PLATFORM_LDFLAGS) -m64
endif

ifeq ($(shell test $(SDKVER) -gt 72; echo $$?),0)
CFLAGS+= -std=c++11
endif

#specify any additional libraries that you may need
EXTRALIBS=-lunicorn

# Destination directory for compiled plugins
OUTDIR=./bin/

#OBJDIR32=x64/
#OBJDIR64=x86/

#list out the object files in your project here
#OBJS32=	$(OBJDIR32)/sk3wldbg.o
#OBJS64=	$(OBJDIR64)/sk3wldbg.o

SRCS=sk3wldbg.cpp sk3wldbg_arm.cpp sk3wldbg_m68k.cpp \
   sk3wldbg_mips.cpp sk3wldbg_plugin.cpp sk3wldbg_ppc.cpp \
   sk3wldbg_sparc.cpp sk3wldbg_x86.cpp loader.cpp mem_mgr.cpp \
   idc_funcs.cpp

BINARY32=$(OUTDIR)$(PROC)$(PLUGIN_EXT32)
BINARY64=$(OUTDIR)$(PROC)$(PLUGIN_EXT64)

ifdef HAVE_IDA64

all: $(OUTDIR) $(BINARY32) $(BINARY64)

clean:
	-@rm *.o
	-@rm $(BINARY32)
	-@rm $(BINARY64)

else

all: $(OUTDIR) $(BINARY32)

clean:
	-@rm *.o
	-@rm $(BINARY32)

endif

$(OUTDIR):
	-@mkdir -p $(OUTDIR)

$(OBJDIR32):
	-@mkdir -p $(OBJDIR32)

$(OBJDIR64):
	-@mkdir -p $(OBJDIR64)

CC=g++
INC=-I$(IDA_SDK)include/ -I./include/

LD=g++

%.o: %.cpp
	$(CC) -c $(CFLAGS) $(INC) $< -o $@

$(BINARY32): $(SRCS)
	$(LD) $(LDFLAGS) -o $@ $(CFLAGS) $(SRCS) $(INC) $(IDADIR) $(IDALIB32) $(EXTRALIBS) 

ifdef HAVE_IDA64

$(BINARY64): $(SRCS)
	$(LD) $(LDFLAGS) -o $@ -D__EA64__ $(CFLAGS) $(SRCS) $(INC) $(IDADIR) $(IDALIB64) $(EXTRALIBS) 

endif

#change sk3wldbg below to the name of your plugin, make sure to add any 
#additional files that your plugin is dependent on
#sk3wldbg.o: sk3wldbg.cpp


```

`README.md`:

```md
## WARNING: THIS CODE IS VERY RAW AND PROBABLY VERY BUGGY!

## Introduction

This is the Sk3wlDbg plugin for IDA Pro. It's purpose is to provide a front
end for using the Unicorn Engine to emulate machine code that you are viewing
with IDA.

The plugin installs as an IDA debugger which you may select whenever you open
an IDA database containing code supported by Unicorn. Currently supported
architectures include:

* x86
* x86-64
* ARM
* ARM64
* MIPS
* MIPS64
* SPARC
* SPARC64
* M68K

## BUILDING:

The plugin is dependent on the Unicorn engine. IDA versions 6.x and older (pre 7.0)
are buit as 32-bit binaries. If you are using one of these versions of IDA you MUST
have a 32-bit build of the Unicorn library for your IDA platform (Windows,
Linux, OS X). If you are using IDA version 7.0 or later, you MUST have a 64-bit build
of Unicorn.

On all platforms you should clone sk3wldbg into your IDA SDK plugins sub-directory
so that you end up with $IDASDKDIR/plugins/sk3wldbg because the build files all use
relative paths to find the IDA header files.

### Building Unicorn for Linux / OSX

* If building Unicorn for IDA 6.x on Linux use: ./make.sh linux32
* If building Unicorn for IDA 7.x on Linux use: ./make.sh linux64
* If building Unicorn for OS X use: ./make.sh macos-universal

Follow `make.sh` with `make install`

### Build sk3wldbg for Linux / OS X:

Use the include Makefile to build the plugin. You may need to adjust the paths
that get searched to find your IDA installation ("/Applications/IDA Pro N.NN" is
assumed on OSX and /opt/ida-N.NN is assumed on Linux, were N.NN is derived from
the name of your IDA SDK directory eg idasdk695 and should match your IDA version
number). This is required to successfully link the plugin. Note that the Makefile
assumes that the Unicorn library headers have been copied into the sk3wldbg
directory alongside the plugin source files (this is already done in the git repo).
If you want to switch to using the actual Unicorn headers, make sure you update the
Makefile.

$ cd $IDASDKDIR/plugins/sk3wldbg
$ make

Compiled binaries will end up in $IDASDKDIR/plugins/sk3wldbg/bin

```
LINUX
         -------------------------------------------
         |        ida        |        ida64        |
         -------------------------------------------
IDA 6.x  |                   |                     |
 plugin  | sk3wldbg_user.plx | sk3wldbg_user.plx64 |
         -------------------------------------------
IDA 7.x  |                   |                     |
 plugin  | sk3wldbg_user.so  | sk3wldbg_user64.so  |
         -------------------------------------------

OS/X
         ------------------------------------------------
         |        ida           |        ida64          |
         ------------------------------------------------
IDA 6.x  |                      |                       |
 plugin  | sk3wldbg_user.pmc    | sk3wldbg_user.pmc64   |
         ------------------------------------------------
IDA 7.x  |                      |                       |
 plugin  | sk3wldbg_user.dylib  | sk3wldbg_user64.dylib |
         ------------------------------------------------
```

Copy the plugin(s) into your <IDADIR>/plugins directory and Sk3wlDbg will be
listed as an available debugger for all architectures supported by Unicorn.

### Build Unicorn for Windows

Unicorn include unicorn.sln which may be used to build both 32 and 64-bit versions
of Unicorn. The necessary binaires end up in unicorn/msvc/distro/Win32 and 
unicorn/msvc/distro/x86. You will need unicorn.lib and unicorn.dll for your
version of IDA (32 or 64-bit). Copy the appropriate unicorn.lib into your 
sk3wldbg git tree at sk3wldbg/lib/x86 or sk3wldbg/lib/x64.

### Build sk3wldbg for Windows

Build with Visual Studio C++ 2013 or later using the included solution (.sln)
file (sk3wlbdg.sln). Several build targets are available depending on which version
of IDA you are using:

```
         -------------------------------------------
         |        ida        |        ida64        |
         -------------------------------------------
IDA 6.x  |   Release/Win32   |  Release64/Win32    |
 plugin  | sk3wldbg_user.plw | sk3wldbg_user.p64   |
         -------------------------------------------
IDA 7.x  |    Release/x64    |   Release64/x64     |
 plugin  | sk3wldbg_user.dll | sk3wldbg_user64.dll |
         -----------------------------------------
```

Note that the project configuration assumes that the Unicorn library headers have
been copied into the sk3wldbg directory alongside the solution file (this is
already done in the git repo). If you want to switch to using the actual Unicorn
headers, make sure you update the Visual Studio project settings.

Copy the plugin(s) into your <IDADIR>/plugins directory and Sk3wlDbg will be
listed as an available debugger for all architectures supported by Unicorn.

Note that the unicorn dll needs to be found in your PATH or copied into your
IDA installation directory.

## INSTALLATION

Assuming you have installed IDA to $IDADIR, install the plugin by copying the
compiled binaries from $IDASDKDIR/bin/plugins to $IDADIR/plugins (Linux/Windows)
or $IDADIR/idabin/plugins (OS X). Windows users should also copy unicorn.dll into
$IDADIR. Linux and OS X users should make sure they have installed the Unicorn
shared library into an appropriate location on their respective systems
(/usr/local/lib often works). This should already be taken care of if you build
and install Unicorn from source.

### Pre-built binaries:

As an alternative to building the plugin yourself, pre-built binaries for 
IDA 6.95 (Windows, Linux, OS X) are available in the bins directory.
Make sure that you have a suitable Unicorn installed for your platform.

## USING THE PLUGIN

With the plugin installed, open a binary of interest in IDA and select Sk3wlDbg
as your debugger (Debugger/Switch debugger). If Sk3wlDbg does not appear as an 
available debugger, it has either not been installed correctly, the Unicorn
shared library can't be found, or the current processor type is not supported
by the plugin.

No options are currently recognized by the plugin. When you launch the debugger
you will be asked whether you wish to begin execution at the cursor location or
at the program's advertised entry point. You should probably also set some
breakpoints to make sure you gain control of the debugger at some point.

The plugin contains very minimalist ELF32/64 and PE/PE32+ loaders to
load the file image into the Unicorn emulator instance. Outside of these formats
the plugin simply copies the contents of your IDA sections into the emulator.
You currently also get a stack and that's about it.

For ELF64/x86_64, the emulator assumes Linux and sets up a minimal trampoline 
from ring 0 to ring 3 at debug start. Additionaly ring 0 code is installed to 
handle sysenter and provide a sysexit back to ring 3. A conditional breakpoint
can be installed at the tail end of the systenter code (marked by a nop) to 
examine the syscall arguments and, if desired, manipulate the process state
before resuming execution. See linux_kernel_x64.asm and linux_x64_syscall_bpcond.py
for ideas.

Future updates will provide similar ring 0 stubs for ELF32/x86/Linux and 
PE32+/x86_64/Windows.

## THINGS THAT WORK (> 0% of the time)

* Basic debugger operations such as step and run
* Breakpoints are just implemented as a set against which the current program counter is compared.
  Software breakpoints (such as INT 3) are not used.
* IDA's "Take memory snapshot" feature works.
* Conditional breakpoints handled by IDA
* Installed IDC functions allow for mapping additional memory into a Unicorn process

```
     int64 sk3wl_mmap(int64 base, long size, int perms) where perms are a combination of:
         #define SEGPERM_EXEC  1         ///< Execute
         #define SEGPERM_WRITE 2         ///< Write
         #define SEGPERM_READ  4         ///< Read
     void sk3wl_munmap(int64 base, long size)
```

`sk3wl_mmap` may be used to map new regions of memory into an emulated unicorn process.
These may be invoked from python via the `eval_idc_expr` function:

```
         idaapi.eval_idc_expr(idaapi.idc_value_t(), BADADDR, "sk3wl_mmap(0x41414000, 0x1000, 7)")
```

## THINGS THAT DON'T WORK (because they are not yet implemented)

* IDA Appcalls
* Exception handling (as in the debugger catching exception that happen in the emulated code like out of bounds memory accesses or illegal instructions)
* Tracing
* Stack traces
* Many other features I have not yet thought of

## OTHER FUTURE WORK

* Extensible hooking interface to hook system calls and other exceptions
* Extensible hooking interface to hook library function calls
* Support for loading required shared libraries into the emulated process
* PEB/TEB and fs segment setup for PE based processes
* Many other features I have not yet thought of

 

```

`elf_local.h`:

```h
#ifndef __ELF_LOCAL
#define __ELF_LOCAL

#include <stdint.h>

struct Elf32_Ehdr {
   uint8_t  e_ident[16];
#define ELF_IDENT  "\177ELF\x01\x01\x01"
#define EI_DATA 5           // endian-ness   1 == little-endian, 2 == big-endian
   uint16_t e_type;         /* Must be 2 for executable */
   uint16_t e_machine;      /* Must be 3 for i386 */
   uint32_t e_version;      /* Must be 1 */
   uint32_t e_entry;        /* Virtual address entry point */
   uint32_t e_phoff;        /* Program Header offset */
   uint32_t e_shoff;        /* Section Header offset */
   uint32_t e_flags;        /* Must be 0 */
   uint16_t e_ehsize;       /* ELF header's size */
   uint16_t e_phentsize;    /* Program header entry size */
   uint16_t e_phnum;        /* # program header entries */
   uint16_t e_shentsize;    /* Section header entry size */
   uint16_t e_shnum;        /* # section header entries */
   uint16_t e_shstrndx;     /* sect header # of str table */
};

enum ptype {
   PT_NULL,
   PT_LOAD,
   PT_DYNAMIC,
   PT_INTERP,
   PT_NOTE,
   PT_SHLIB,
   PT_PHDR,
   PT_TLS,
   PT_NUM
};

struct Elf32_Phdr {
   uint32_t        p_type;         /* Section type */

#define PT_LOOS      0x60000000
#define PT_HIOS      0x6fffffff
#define PT_LOPROC    0x70000000
#define PT_HIPROC    0x7fffffff
#define PT_GNU_STACK (PT_LOOS + 0x474e551)

   uint32_t        p_offset;       /* Offset into the file */
   uint32_t        p_vaddr;        /* Virtual program address */
   uint32_t        p_paddr;        /* Set to zero */
   uint32_t        p_filesz;       /* Section bytes in file */
   uint32_t        p_memsz;        /* Section bytes in memory */
   uint32_t        p_flags;        /* section flags */
#define PF_X        (1<<0)          /* Mapped executable */
#define PF_W        (1<<1)          /* Mapped writable */
#define PF_R        (1<<2)          /* Mapped readable */
   uint32_t        p_align;        /* Only used by core dumps */
};

struct Elf64_Ehdr {
  uint8_t    e_ident[16];     /* Magic number and other info */
  uint16_t   e_type;                 /* Object file type */
  uint16_t   e_machine;              /* Architecture */
  uint32_t   e_version;              /* Object file version */
  uint64_t   e_entry;                /* Entry point virtual address */
  uint64_t   e_phoff;                /* Program header table file offset */
  uint64_t   e_shoff;                /* Section header table file offset */
  uint32_t   e_flags;                /* Processor-specific flags */
  uint16_t   e_ehsize;               /* ELF header size in bytes */
  uint16_t   e_phentsize;            /* Program header table entry size */
  uint16_t   e_phnum;                /* Program header table entry count */
  uint16_t   e_shentsize;            /* Section header table entry size */
  uint16_t   e_shnum;                /* Section header table entry count */
  uint16_t   e_shstrndx;             /* Section header string table index */
};

struct Elf64_Phdr {
  uint32_t   p_type;                 /* Segment type */
  uint32_t   p_flags;                /* Segment flags */
  uint64_t   p_offset;               /* Segment file offset */
  uint64_t   p_vaddr;                /* Segment virtual address */
  uint64_t   p_paddr;                /* Segment physical address */
  uint64_t   p_filesz;               /* Segment size in file */
  uint64_t   p_memsz;                /* Segment size in memory */
  uint64_t   p_align;                /* Segment alignment */
};

/* from linux/auxvec.h */
#define _AT_NULL   0     /* end of vector */
#define _AT_IGNORE 1     /* entry should be ignored */
#define _AT_EXECFD 2     /* file descriptor of program */
#define _AT_PHDR   3     /* program headers for program */
#define _AT_PHENT  4     /* size of program header entry */
#define _AT_PHNUM  5     /* number of program headers */
#define _AT_PAGESZ 6     /* system page size */
#define _AT_BASE   7     /* base address of interpreter */
#define _AT_FLAGS  8     /* flags */
#define _AT_ENTRY  9     /* entry point of program */
#define _AT_NOTELF 10    /* program is not ELF */
#define _AT_UID    11    /* real uid */
#define _AT_EUID   12    /* effective uid */
#define _AT_GID    13    /* real gid */
#define _AT_EGID   14    /* effective gid */
#define _AT_PLATFORM 15  /* string identifying CPU for optimizations */
#define _AT_HWCAP  16    /* arch dependent hints at CPU capabilities */
#define _AT_CLKTCK 17    /* frequency at which times() increments */
/* AT_* values 18 through 22 are reserved */
#define _AT_SECURE 23   /* secure mode boolean */
#define _AT_BASE_PLATFORM 24     /* string identifying real platform, may
                                 * differ from AT_PLATFORM. */
#define _AT_RANDOM 25    /* address of 16 random bytes */
#define _AT_HWCAP2 26    /* extension of AT_HWCAP */

#define _AT_EXECFN  31   /* filename of program */

#define _AT_SYSINFO_EHDR 33 /* base of vdso */

typedef struct _elf_aux {
   uint64_t entry;
   uint64_t vdso;
   uint64_t phdr;
   uint64_t phnum;
   uint64_t phent;
   uint32_t uid;
   uint32_t euid;
   uint32_t gid;
   uint32_t egid;
} elf_aux;

//altval indicies for kernel netnode
#define KERNEL_BRK 0
#define KERNEL_PID 1
#define KERNEL_PPID 2
#define KERNEL_UID 3
#define KERNEL_EUID 4
#define KERNEL_GID 5
#define KERNEL_EGID 6
#define KERNEL_TID 7
#define KERNEL_TID_ADDRESS 8
#define KERNEL_ROBUST_LIST 9
#define KERNEL_ROBUST_LIST_SIZE 10
#define KERNEL_MMAP_TOP 11




#endif

```

`heap.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#ifndef __TEMPLATE_HEAP_H
#define __TEMPLATE_HEAP_H

#include <stdint.h>

#define PREV_IN_USE 1

template <class T>
class heap {
protected:
   struct _chunk {
      T prev_size;
      T size;
      T fd;     //heap_chunk32*
      T bk;     //heap_chunk32*
   };

   struct _list {
      T fd;     //heap_chunk32*
      T bk;     //heap_chunk32*
   };

   void *user_mem;
   T heap_base;
   T heap_end;
   T tail;
   
   void *to_user(T addr);

   inline T CHUNK_ADDR(T a) {return a - 2 * sizeof(T);};
   inline _chunk* CHUNK_PTR(T c) {return (_chunk*)to_user(c);};
   inline T CHUNK_SIZE(_chunk *c) {return c->size & ~1;};

   T marker;
   _list free_list;
   void unlink(T chunk);
   void link(T chunk);
   T best_fit(T size);

public:
   heap(void *heap_mem, T _heap_base, uint32_t _heap_size);
   ~heap();

   T malloc(T size);
   T calloc(T nmemb, T size);
   T realloc(T ptr, T sz);
   void free(T ptr);
};

template <class T>
void *heap<T>::to_user(T addr) {
   return (addr - heap_base) + (char*)user_mem;
}

template <class T>
heap<T>::heap(void *heap_mem, T _heap_base, uint32_t _heap_size) {
   user_mem = heap_mem;
   heap_base = _heap_base;
   heap_end = heap_base + _heap_size;
   tail = heap_base;

   marker = ~(2 * sizeof(T) - 1) & (T)(uint64_t)&free_list;
   free_list.fd = marker;
   free_list.bk = marker;
   //setup initial chunk
   _chunk *chunk = (_chunk *)user_mem;
   chunk->prev_size = 0;
   chunk->size = _heap_size | PREV_IN_USE;
}

template <class T>
heap<T>::~heap() {
}

template <class T>
void heap<T>::unlink(T chunk) {
   _chunk *mchunk = CHUNK_PTR(chunk);
   if (mchunk->fd == marker) {
      free_list.bk = mchunk->bk;
   }
   else {
      _chunk *next = CHUNK_PTR(mchunk->fd);
      next->bk = mchunk->bk;
   }
   if (mchunk->bk == marker) {
      free_list.fd = mchunk->fd;
   }
   else {
      _chunk *prev = CHUNK_PTR(mchunk->bk);
      prev->fd = mchunk->fd;
   }
}

template <class T>
void heap<T>::link(T chunk) {
   _chunk *mchunk = CHUNK_PTR(chunk);
   mchunk->fd = free_list.fd;
   mchunk->bk = marker;
   free_list.fd = chunk;
   if (mchunk->fd != marker) {
      _chunk *nchunk = CHUNK_PTR(mchunk->fd);
      nchunk->bk = chunk;
   }
   else {
      free_list.bk = chunk;
   }
}

template <class T>
T heap<T>::best_fit(T size) {
   T best = 0;
   _chunk *best_chunk = NULL;
   for (T c = free_list.fd; c != marker;) {
      _chunk *chunk = CHUNK_PTR(c);
      if (chunk->size == size) {
         best = c;
         best_chunk = chunk;
         break;
      }
      if (chunk->size > size) {
         if (best == 0) {
            best = c;
            best_chunk = chunk;
         }
         else if ((chunk->size - size) < (best_chunk->size - size)) {
            best = c;
            best_chunk = chunk;
         }
      }
   }
   if (best) {
      unlink(best);
      _chunk *nchunk = CHUNK_PTR(best + CHUNK_SIZE(best_chunk));
      if (best_chunk->size >= (size + sizeof(_chunk))) {
         T split = best + size;
         _chunk *new_chunk = CHUNK_PTR(split);
         new_chunk->size = best_chunk->size - size; //this will have PREV_IN_USE set already
         best_chunk->size = size | PREV_IN_USE;
         nchunk->prev_size = CHUNK_SIZE(new_chunk);
         link(split);
      }
      else {
         //not enough room for a separate chunk, just give back the entire chunk
         //in which case there is no need to adjust the next chunk much
         nchunk->size |= PREV_IN_USE;
      }
   }
   else {
      //take it off the tail chunk
      _chunk *chunk = CHUNK_PTR(tail);
      if (size <= (chunk->size + 2 * sizeof(T))) {
         _chunk *tchunk = CHUNK_PTR(tail + size);
         best = tail;
         tchunk->size = (chunk->size - size) | PREV_IN_USE; //chunk before tail is always in use
         chunk->size = size | PREV_IN_USE;  //chunk before tail is always in use
         tail = tail + size;
      }
      else {
         //ideally we could extend heap at this point
      }
   }
   return best;
}

template <class T>
T heap<T>::malloc(T size) {
   size += 3 * sizeof(T) - 1;
   size &= ~(2 * sizeof(T) - 1);
   if (size < (4 * sizeof(T))) {
      size = 4 * sizeof(T);
   }
   T chunk = best_fit(size);
   if (chunk) {
      chunk += 2 * sizeof(T);
   }
   return chunk;
}

template <class T>
T heap<T>::calloc(T nmemb, T size) {
   T sz = nmemb * size;
   T block = malloc(sz);
   if (block) {
      void *p = to_user(block);
      memset(p, 0, sz);
   }
   return block;
}

template <class T>
T heap<T>::realloc(T ptr, T sz) {
   if (ptr == 0) {
      return malloc(sz);
   }
   if (sz == 0) {
      free(ptr);
      return 0;
   }
   T need = (sz + (3 * sizeof(T) - 1)) & ~(2 * sizeof(T) - 1);
   if (need < (4 * sizeof(T))) {
      need = 4 * sizeof(T);
   }
   T chunk = CHUNK_ADDR(ptr);
   _chunk *mchunk = CHUNK_PTR(chunk);
   T next_chunk = chunk + CHUNK_SIZE(mchunk);
   _chunk *nchunk = CHUNK_PTR(next_chunk);

   if (next_chunk == tail) {
      //adjacent to tail, it either fits or it doesn't
      T max = CHUNK_SIZE(mchunk) + CHUNK_SIZE(nchunk) - 2 * sizeof(T);
      if (sz < max) {
         //it fits, this will accomodate growing or shrinking realloc
         T new_chunk = chunk + need;
         _chunk *newchunk = CHUNK_PTR(new_chunk);
         newchunk->size = CHUNK_SIZE(mchunk) + CHUNK_SIZE(nchunk) - need;
         newchunk->size |= PREV_IN_USE;
         tail = new_chunk;
         mchunk->size = need | (mchunk->size & PREV_IN_USE);
         return ptr;
      }
   }
   else { 
      T next_next = next_chunk + CHUNK_SIZE(nchunk);
      _chunk *nnchunk = CHUNK_PTR(next_next);
      bool next_in_use = (nnchunk->size & 1) == 0;
      if (need <= mchunk->size) {
         //smaller or same
         if (need <= (mchunk->size - sizeof(_chunk))) {
            //enough room to split
            T new_chunk = chunk + need;
            _chunk *newchunk = CHUNK_PTR(new_chunk);
            if (!next_in_use) {
               T nsize = CHUNK_SIZE(mchunk) - need + CHUNK_SIZE(nchunk);
               newchunk->size = nsize | PREV_IN_USE;
               unlink(next_chunk);
               nnchunk->prev_size = nsize;
            }
            else {
               newchunk->size = (CHUNK_SIZE(mchunk) - need) | PREV_IN_USE;
               nchunk->size &= ~1;
            }
            link(new_chunk);
            mchunk->size = need | (mchunk->size & PREV_IN_USE);
         }
         else {
            //don't change a thing
         }
         return ptr;
      }
      if (!next_in_use) {
         //maybe we can grow into the next chunk
         if (need <= (CHUNK_SIZE(mchunk) + CHUNK_SIZE(nchunk))) {
            T tsize = CHUNK_SIZE(nchunk);
            unlink(next_chunk); //we are going to use at least some of this
            if (need <= ((CHUNK_SIZE(mchunk) + tsize) - sizeof(_chunk))) {
               //enough room to split
               T new_chunk = chunk + need;
               _chunk *newchunk = CHUNK_PTR(new_chunk);

               T nsize = CHUNK_SIZE(mchunk) + tsize - need;
               newchunk->size = nsize | PREV_IN_USE;
               nnchunk->prev_size = nsize;
               link(new_chunk);
            }
            else {
               //used all of next chunk
               nnchunk->size |= PREV_IN_USE;
            }            
            mchunk->size = need | (mchunk->size & PREV_IN_USE);
            return ptr;
         }
      }
   }
   //need to do a malloc and copy at this point
   T new_block = malloc(sz);
   if (new_block) {
      T ncopy = CHUNK_SIZE(mchunk) - 2 * sizeof(T) + sizeof(T);  //take next->prev_size field too
      void *dest = to_user(new_block);
      memcpy(dest, &mchunk->fd, ncopy);
      free(ptr);
   }
   return new_block;
}

template <class T>
void heap<T>::free(T ptr) {
   T chunk = CHUNK_ADDR(ptr);
   _chunk *mchunk = CHUNK_PTR(chunk);
   T next_chunk = chunk + CHUNK_SIZE(mchunk);
   _chunk *nchunk = CHUNK_PTR(next_chunk);

   if (next_chunk == tail) {
      mchunk->size += CHUNK_SIZE(nchunk);  //add this into tail
      tail = chunk;
   }
   else {
      T next_next = next_chunk + CHUNK_SIZE(nchunk);
      _chunk *nnchunk = CHUNK_PTR(next_next);
      if ((nnchunk->size & PREV_IN_USE) == 0) {
         //next chunk is not in use, so consolidate forward
         mchunk->size += CHUNK_SIZE(nchunk);  //grow size to include next
         unlink(next_chunk);                   //unlink next chunk
         nnchunk->prev_size = CHUNK_SIZE(mchunk); //update prev_size in new next
      }
      else {
         nchunk->prev_size = CHUNK_SIZE(mchunk);  //this chunk not in use so set prev_size
         nchunk->size &= ~1;  //this chunk is not in use anymore
      }
      link(chunk);
   }

   if ((mchunk->size & PREV_IN_USE) == 0) {
      //prev is not in use, need to consolidate backwards
      T prev_chunk = chunk - mchunk->prev_size;
      unlink(prev_chunk);
      _chunk *pchunk = CHUNK_PTR(prev_chunk);
      pchunk->size += mchunk->size;
      if (chunk == tail) {
         tail = prev_chunk;
      }
      else {
         //chunk was linked during forward consolidation check
         unlink(chunk);
         T next_chunk = chunk + mchunk->size;
         //next chunk already knows that this chunk is not in use from forward consolidation
         _chunk *nchunk = CHUNK_PTR(next_chunk);
         nchunk->prev_size = CHUNK_SIZE(pchunk);
         link(prev_chunk);
      }
   }
}

#endif

```

`idc_funcs.cpp`:

```cpp
/*
   Scripting support for the sk3wldbg IdaPro plugin
   Copyright (c) 2017 Chris Eagle
   
   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option) 
   any later version.
   
   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
   more details.
   
   You should have received a copy of the GNU General Public License along with 
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple 
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#ifndef USE_DANGEROUS_FUNCTIONS
#define USE_DANGEROUS_FUNCTIONS 1
#endif

#ifndef USE_STANDARD_FILE_FUNCTIONS
#define USE_STANDARD_FILE_FUNCTIONS 1
#endif

#include <ida.hpp>
#include <expr.hpp>
#include <segment.hpp>
#include <diskio.hpp>
#include <fpro.h>
#include <loader.hpp>

#include "sk3wldbg.h"
#include "loader.h"
#include "idc_funcs.h"

static sk3wldbg *uc;

#ifdef _WIN32
#define snprintf _snprintf
#endif

#if IDA_SDK_VERSION >= 700

bool set_idc_func_ex(const char *name, idc_func_t *fp, const char *args, int extfunc_flags) {
   ext_idcfunc_t func;
   func.name = name;
   func.fptr = fp;
   func.args = args;
   //hidden default arg used to pass sk3wldbg pointer into each function
   func.defvals = NULL;
   func.ndefvals = 0;
   func.flags = extfunc_flags;
   bool res = add_idc_func(func);
   msg("Installing idc func (%s) %s\n", name, res ? "succeeded" : "failed");
   return res;
}

#endif

void zero_fill(ea_t base, size_t size) {
   //Ida patch_xxx is very SLOW!!!!!
   //workaround is to create temp file containing all your zeros
   //then load that temp file as an additional binary file
   char ftmp[1024];
   qtmpnam(ftmp, sizeof(ftmp));
   size_t block = size;
   if (block > 0x10000) {
      block = 0x10000;
   }
   void *zeros = calloc(block, 1);
   FILE *f = fopen(ftmp, "wb");
   for (size_t done = 0; done < size; done += block) {
      block = size - done;
      if (block > 0x10000) {
         block = 0x10000;
      }
      fwrite(zeros, block, 1, f);
   }
   free(zeros);
   fclose(f);
   linput_t *fin = open_linput(ftmp, false);
   load_binary_file(ftmp, fin, 0, 0, 0, base, size);
   close_linput(fin);
#ifdef __NT__
   DeleteFile(ftmp);   
#else
   unlink(ftmp);
#endif
}

void createNewSegment(const char *name, ea_t base, uint32_t size, uint32_t perms, uint32_t bitness) {
   //create the new segment
   segment_t s;
   s.startEA = base;
   s.endEA = base + size;
   s.align = saRelPara;
   s.comb = scPub;
   s.perm = (uint8_t)perms;
   s.bitness = (uint8_t)bitness;
   bool is_code = (perms & SEGPERM_EXEC) != 0;
   if (is_code) {
      s.type = SEG_CODE;
   }
   else {
      s.type = SEG_DATA;
   }
   s.flags = SFL_DEBUG;
   
   msg("Creating segment %s with bitness %d and perms %d\n", name, s.bitness, s.perm);
   if (add_segm_ex(&s, name, is_code ? "CODE" : "DATA", ADDSEG_QUIET | ADDSEG_NOSREG)) {
      //zero out the newly created segment
      zero_fill(base, size);
   }
   else {
      msg("createNewSegment failed\n");
   }
}

/*
 * native implementation of sk3wl_mmap.
 * long sk3wl_mmap(long base, long size, long perms)
 */
static error_t idaapi idc_mmap(idc_value_t *argv, idc_value_t *res) {
   res->vtype = VT_INT64;
   res->i64 = -1;
   if (argv[0].vtype == VT_INT64 && argv[1].vtype == VT_LONG && argv[2].vtype == VT_LONG) {
      uint64_t base = (uint64_t)argv[0].i64;
      unsigned int sz = (unsigned int)argv[1].num;
      unsigned int perms = (unsigned int)argv[2].num & SEGPERM_MAXVAL;
      if (uc->map_mem_zero(base, base + sz, ida_to_uc_perms_map[perms])) {
         qstring seg_name = "mmap_";
         map_block *mb = uc->memmgr->find_block(base);
         seg_name.sprnt("mmap_%p", mb->guest);
         uint32_t bitness = 1;  //default to 32
         if (uc->debug_mode & UC_MODE_16) {
            bitness = 0;
         }
         else if (uc->debug_mode & UC_MODE_64) {
            bitness = 2;
         }
         createNewSegment(seg_name.c_str(), (ea_t)base, sz, perms, bitness);
         res->i64 = mb->guest;
      }
   }
   return eOk;
}

/*
 * native implementation of sk3wl_munmap.
 * sk3wl_munmap(long base, long size)
 */
static error_t idaapi idc_munmap(idc_value_t *argv, idc_value_t *res) {
   res->vtype = VT_LONG;
   res->num = 0;
   if (argv[0].vtype == VT_INT64 && argv[1].vtype == VT_LONG) {
      uint64_t base = (uint64_t)argv[0].i64;
      unsigned int sz = (unsigned int)argv[1].num;
      uc->memmgr->munmap(base, sz);
      add_segm(0, (ea_t)base, (ea_t)base + sz, "delsegxxx", "DATA", ADDSEG_QUIET | ADDSEG_NOAA);
      del_segm((ea_t)base, SEGMOD_KILL);
   }
   else {
      res->num = -1;
   }
   return eOk;
}

/*
 * Register new IDC functions for use with the debugger
 */
void register_funcs(sk3wldbg *_uc) {
   static const char idc_long_long[] = { VT_INT64, VT_LONG, 0 };
   static const char idc_long_long_long[] = { VT_INT64, VT_LONG, VT_LONG, 0 };
   uc = _uc;
   set_idc_func_ex("sk3wl_mmap", idc_mmap, idc_long_long_long, EXTFUN_BASE);
   set_idc_func_ex("sk3wl_munmap", idc_munmap, idc_long_long, EXTFUN_BASE);
}

/*
 * Unregister IDC functions when the plugin is unloaded
 */
void unregister_funcs() {
   set_idc_func_ex("sk3wl_mmap", NULL, NULL, 0);
   set_idc_func_ex("sk3wl_munmap", NULL, NULL, 0);
}

```

`idc_funcs.h`:

```h
/*
   Scripting support for the sk3wldbg IdaPro plugin
   Copyright (c) 2017 Chris Eagle
   
   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option) 
   any later version.
   
   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
   more details.
   
   You should have received a copy of the GNU General Public License along with 
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple 
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#ifndef __IDC_FUNCS_H
#define __IDC_FUNCS_H

#include "sk3wldbg.h"

/*
  add IDC functions for interacting with the debugger
  sk3wl_mmap();
  sk3wl_munmap();
*/

void register_funcs(sk3wldbg *uc);
void unregister_funcs();

#endif

```

`include/list.h`:

```h
#ifndef UC_LLIST_H
#define UC_LLIST_H

#include "unicorn/platform.h"

struct list_item {
    struct list_item *next;
    void *data;
};

struct list {
    struct list_item *head, *tail;
};

// create a new list
struct list *list_new(void);

// removed linked list nodes but does not free their content
void list_clear(struct list *list);

// insert a new item at the begin of the list.
void *list_insert(struct list *list, void *data);

// append a new item at the end of the list.
void *list_append(struct list *list, void *data);

// returns true if entry was removed, false otherwise
bool list_remove(struct list *list, void *data);

#endif

```

`include/qemu.h`:

```h
/* By Dang Hoang Vu <dang.hvu -at- gmail.com>, 2015 */

#ifndef UC_QEMU_H
#define UC_QEMU_H

struct uc_struct;

#define OPC_BUF_SIZE 640

#include "sysemu/sysemu.h"
#include "sysemu/cpus.h"
#include "exec/cpu-common.h"
#include "exec/memory.h"

#include "qemu/thread.h"
#include "include/qom/cpu.h"

#include "vl.h"

// This two struct is originally from qemu/include/exec/cpu-all.h
// Temporarily moved here since there is circular inclusion.
typedef struct RAMBlock {
    struct MemoryRegion *mr;
    uint8_t *host;
    ram_addr_t offset;
    ram_addr_t length;
    uint32_t flags;
    char idstr[256];
    /* Reads can take either the iothread or the ramlist lock.
     * Writes must take both locks.
     */
    QTAILQ_ENTRY(RAMBlock) next;
    int fd;
} RAMBlock;

typedef struct {
    MemoryRegion *mr;
    void *buffer;
    hwaddr addr;
    hwaddr len;
} BounceBuffer;

typedef struct RAMList {
    /* Protected by the iothread lock.  */
    unsigned long *dirty_memory[DIRTY_MEMORY_NUM];
    RAMBlock *mru_block;
    QTAILQ_HEAD(, RAMBlock) blocks;
    uint32_t version;
} RAMList;

#endif

```

`include/uc_priv.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015 */

#ifndef UC_PRIV_H
#define UC_PRIV_H

#include "unicorn/platform.h"
#include <stdio.h>

#include "qemu.h"
#include "unicorn/unicorn.h"
#include "list.h"

// These are masks of supported modes for each cpu/arch.
// They should be updated when changes are made to the uc_mode enum typedef.
#define UC_MODE_ARM_MASK    (UC_MODE_ARM|UC_MODE_THUMB|UC_MODE_LITTLE_ENDIAN|UC_MODE_MCLASS|UC_MODE_BIG_ENDIAN)
#define UC_MODE_MIPS_MASK   (UC_MODE_MIPS32|UC_MODE_MIPS64|UC_MODE_LITTLE_ENDIAN|UC_MODE_BIG_ENDIAN)
#define UC_MODE_X86_MASK    (UC_MODE_16|UC_MODE_32|UC_MODE_64|UC_MODE_LITTLE_ENDIAN)
#define UC_MODE_PPC_MASK    (UC_MODE_PPC64|UC_MODE_BIG_ENDIAN)
#define UC_MODE_SPARC_MASK  (UC_MODE_SPARC32|UC_MODE_SPARC64|UC_MODE_BIG_ENDIAN)
#define UC_MODE_M68K_MASK   (UC_MODE_BIG_ENDIAN)

#define ARR_SIZE(a) (sizeof(a)/sizeof(a[0]))

#define READ_QWORD(x) ((uint64)x)
#define READ_DWORD(x) (x & 0xffffffff)
#define READ_WORD(x) (x & 0xffff)
#define READ_BYTE_H(x) ((x & 0xffff) >> 8)
#define READ_BYTE_L(x) (x & 0xff)
#define WRITE_DWORD(x, w) (x = (x & ~0xffffffffLL) | (w & 0xffffffff))
#define WRITE_WORD(x, w) (x = (x & ~0xffff) | (w & 0xffff))
#define WRITE_BYTE_H(x, b) (x = (x & ~0xff00) | ((b & 0xff) << 8))
#define WRITE_BYTE_L(x, b) (x = (x & ~0xff) | (b & 0xff))


typedef struct ModuleEntry {
    void (*init)(void);
    QTAILQ_ENTRY(ModuleEntry) node;
    module_init_type type;
} ModuleEntry;

typedef QTAILQ_HEAD(, ModuleEntry) ModuleTypeList;

typedef uc_err (*query_t)(struct uc_struct *uc, uc_query_type type, size_t *result);

// return 0 on success, -1 on failure
typedef int (*reg_read_t)(struct uc_struct *uc, unsigned int *regs, void **vals, int count);
typedef int (*reg_write_t)(struct uc_struct *uc, unsigned int *regs, void *const *vals, int count);

typedef void (*reg_reset_t)(struct uc_struct *uc);

typedef bool (*uc_write_mem_t)(AddressSpace *as, hwaddr addr, const uint8_t *buf, int len);

typedef bool (*uc_read_mem_t)(AddressSpace *as, hwaddr addr, uint8_t *buf, int len);

typedef void (*uc_args_void_t)(void*);

typedef void (*uc_args_uc_t)(struct uc_struct*);
typedef int (*uc_args_int_uc_t)(struct uc_struct*);

typedef bool (*uc_args_tcg_enable_t)(struct uc_struct*);

typedef void (*uc_args_uc_long_t)(struct uc_struct*, unsigned long);

typedef void (*uc_args_uc_u64_t)(struct uc_struct *, uint64_t addr);

typedef MemoryRegion* (*uc_args_uc_ram_size_t)(struct uc_struct*,  hwaddr begin, size_t size, uint32_t perms);

typedef MemoryRegion* (*uc_args_uc_ram_size_ptr_t)(struct uc_struct*,  hwaddr begin, size_t size, uint32_t perms, void *ptr);

typedef void (*uc_mem_unmap_t)(struct uc_struct*, MemoryRegion *mr);

typedef void (*uc_readonly_mem_t)(MemoryRegion *mr, bool readonly);

// which interrupt should make emulation stop?
typedef bool (*uc_args_int_t)(int intno);

// some architecture redirect virtual memory to physical memory like Mips
typedef uint64_t (*uc_mem_redirect_t)(uint64_t address);

// validate if Unicorn supports hooking a given instruction
typedef bool(*uc_insn_hook_validate)(uint32_t insn_enum);

struct hook {
    int type;            // UC_HOOK_*
    int insn;            // instruction for HOOK_INSN
    int refs;            // reference count to free hook stored in multiple lists
    uint64_t begin, end; // only trigger if PC or memory access is in this address (depends on hook type)
    void *callback;      // a uc_cb_* type
    void *user_data;
};

// hook list offsets
// mirrors the order of uc_hook_type from include/unicorn/unicorn.h
enum uc_hook_idx {
    UC_HOOK_INTR_IDX,
    UC_HOOK_INSN_IDX,
    UC_HOOK_CODE_IDX,
    UC_HOOK_BLOCK_IDX,
    UC_HOOK_MEM_READ_UNMAPPED_IDX,
    UC_HOOK_MEM_WRITE_UNMAPPED_IDX,
    UC_HOOK_MEM_FETCH_UNMAPPED_IDX,
    UC_HOOK_MEM_READ_PROT_IDX,
    UC_HOOK_MEM_WRITE_PROT_IDX,
    UC_HOOK_MEM_FETCH_PROT_IDX,
    UC_HOOK_MEM_READ_IDX,
    UC_HOOK_MEM_WRITE_IDX,
    UC_HOOK_MEM_FETCH_IDX,
    UC_HOOK_MEM_READ_AFTER_IDX,

    UC_HOOK_MAX,
};

#define HOOK_FOREACH_VAR_DECLARE                          \
    struct list_item *cur

// for loop macro to loop over hook lists
#define HOOK_FOREACH(uc, hh, idx)                         \
    for (                                                 \
        cur = (uc)->hook[idx##_IDX].head;                 \
        cur != NULL && ((hh) = (struct hook *)cur->data)  \
            /* stop excuting callbacks on stop request */ \
            && !uc->stop_request;                         \
        cur = cur->next)

// if statement to check hook bounds
#define HOOK_BOUND_CHECK(hh, addr)                  \
    ((((addr) >= (hh)->begin && (addr) <= (hh)->end) \
         || (hh)->begin > (hh)->end))

#define HOOK_EXISTS(uc, idx) ((uc)->hook[idx##_IDX].head != NULL)
#define HOOK_EXISTS_BOUNDED(uc, idx, addr) _hook_exists_bounded((uc)->hook[idx##_IDX].head, addr)

static inline bool _hook_exists_bounded(struct list_item *cur, uint64_t addr)
{
    while (cur != NULL) {
        if (HOOK_BOUND_CHECK((struct hook *)cur->data, addr))
            return true;
        cur = cur->next;
    }
    return false;
}

//relloc increment, KEEP THIS A POWER OF 2!
#define MEM_BLOCK_INCR 32

struct uc_struct {
    uc_arch arch;
    uc_mode mode;
    uc_err errnum;  // qemu/cpu-exec.c
    AddressSpace as;
    query_t query;
    reg_read_t reg_read;
    reg_write_t reg_write;
    reg_reset_t reg_reset;

    uc_write_mem_t write_mem;
    uc_read_mem_t read_mem;
    uc_args_void_t release;     // release resource when uc_close()
    uc_args_uc_u64_t set_pc;  // set PC for tracecode
    uc_args_int_t stop_interrupt;   // check if the interrupt should stop emulation

    uc_args_uc_t init_arch, cpu_exec_init_all;
    uc_args_int_uc_t vm_start;
    uc_args_tcg_enable_t tcg_enabled;
    uc_args_uc_long_t tcg_exec_init;
    uc_args_uc_ram_size_t memory_map;
    uc_args_uc_ram_size_ptr_t memory_map_ptr;
    uc_mem_unmap_t memory_unmap;
    uc_readonly_mem_t readonly_mem;
    uc_mem_redirect_t mem_redirect;
    // TODO: remove current_cpu, as it's a flag for something else ("cpu running"?)
    CPUState *cpu, *current_cpu;

    uc_insn_hook_validate insn_hook_validate;

    MemoryRegion *system_memory;    // qemu/exec.c
    MemoryRegion io_mem_rom;    // qemu/exec.c
    MemoryRegion io_mem_notdirty;   // qemu/exec.c
    MemoryRegion io_mem_unassigned; // qemu/exec.c
    MemoryRegion io_mem_watch;  // qemu/exec.c
    RAMList ram_list;   // qemu/exec.c
    BounceBuffer bounce;    // qemu/cpu-exec.c
    volatile sig_atomic_t exit_request; // qemu/cpu-exec.c
    bool global_dirty_log;  // qemu/memory.c
    /* This is a multi-level map on the virtual address space.
       The bottom level has pointers to PageDesc.  */
    void **l1_map;  // qemu/translate-all.c
    size_t l1_map_size;
    /* code generation context */
    void *tcg_ctx;  // for "TCGContext tcg_ctx" in qemu/translate-all.c
    /* memory.c */
    unsigned memory_region_transaction_depth;
    bool memory_region_update_pending;
    bool ioeventfd_update_pending;
    QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners;
    QTAILQ_HEAD(, AddressSpace) address_spaces;
    MachineState *machine_state;
    // qom/object.c
    GHashTable *type_table;
    Type type_interface;
    Object *root;
    Object *owner;
    bool enumerating_types;
    // util/module.c
    ModuleTypeList init_type_list[MODULE_INIT_MAX];
    // hw/intc/apic_common.c
    DeviceState *vapic;
    int apic_no;
    bool mmio_registered;
    bool apic_report_tpr_access;

    // linked lists containing hooks per type
    struct list hook[UC_HOOK_MAX];

    // hook to count number of instructions for uc_emu_start()
    uc_hook count_hook;

    size_t emu_counter; // current counter of uc_emu_start()
    size_t emu_count; // save counter of uc_emu_start()

    uint64_t block_addr;    // save the last block address we hooked

    bool init_tcg;      // already initialized local TCGv variables?
    bool stop_request;  // request to immediately stop emulation - for uc_emu_stop()
    bool quit_request;  // request to quit the current TB, but continue to emulate - for uc_mem_protect()
    bool emulation_done;  // emulation is done by uc_emu_start()
    QemuThread timer;   // timer for emulation timeout
    uint64_t timeout;   // timeout for uc_emu_start()

    uint64_t invalid_addr;  // invalid address to be accessed
    int invalid_error;  // invalid memory code: 1 = READ, 2 = WRITE, 3 = CODE

    uint64_t addr_end;  // address where emulation stops (@end param of uc_emu_start())

    int thumb;  // thumb mode for ARM
    // full TCG cache leads to middle-block break in the last translation?
    bool block_full;
    int size_arg;     // what tcg arg slot do we need to update with the size of the block?
    MemoryRegion **mapped_blocks;
    uint32_t mapped_block_count;
    uint32_t mapped_block_cache_index;
    void *qemu_thread_data; // to support cross compile to Windows (qemu-thread-win32.c)
    uint32_t target_page_size;
    uint32_t target_page_align;
    uint64_t next_pc;   // save next PC for some special cases
    bool hook_insert;	// insert new hook at begin of the hook list (append by default)
};

// Metadata stub for the variable-size cpu context used with uc_context_*()
struct uc_context {
   size_t size;
   char data[0];
};

// check if this address is mapped in (via uc_mem_map())
MemoryRegion *memory_mapping(struct uc_struct* uc, uint64_t address);

#endif
/* vim: set ts=4 noet:  */

```

`include/unicorn/arm.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ARM_H
#define UNICORN_ARM_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM registers
typedef enum uc_arm_reg {
    UC_ARM_REG_INVALID = 0,
    UC_ARM_REG_APSR,
    UC_ARM_REG_APSR_NZCV,
    UC_ARM_REG_CPSR,
    UC_ARM_REG_FPEXC,
    UC_ARM_REG_FPINST,
    UC_ARM_REG_FPSCR,
    UC_ARM_REG_FPSCR_NZCV,
    UC_ARM_REG_FPSID,
    UC_ARM_REG_ITSTATE,
    UC_ARM_REG_LR,
    UC_ARM_REG_PC,
    UC_ARM_REG_SP,
    UC_ARM_REG_SPSR,
    UC_ARM_REG_D0,
    UC_ARM_REG_D1,
    UC_ARM_REG_D2,
    UC_ARM_REG_D3,
    UC_ARM_REG_D4,
    UC_ARM_REG_D5,
    UC_ARM_REG_D6,
    UC_ARM_REG_D7,
    UC_ARM_REG_D8,
    UC_ARM_REG_D9,
    UC_ARM_REG_D10,
    UC_ARM_REG_D11,
    UC_ARM_REG_D12,
    UC_ARM_REG_D13,
    UC_ARM_REG_D14,
    UC_ARM_REG_D15,
    UC_ARM_REG_D16,
    UC_ARM_REG_D17,
    UC_ARM_REG_D18,
    UC_ARM_REG_D19,
    UC_ARM_REG_D20,
    UC_ARM_REG_D21,
    UC_ARM_REG_D22,
    UC_ARM_REG_D23,
    UC_ARM_REG_D24,
    UC_ARM_REG_D25,
    UC_ARM_REG_D26,
    UC_ARM_REG_D27,
    UC_ARM_REG_D28,
    UC_ARM_REG_D29,
    UC_ARM_REG_D30,
    UC_ARM_REG_D31,
    UC_ARM_REG_FPINST2,
    UC_ARM_REG_MVFR0,
    UC_ARM_REG_MVFR1,
    UC_ARM_REG_MVFR2,
    UC_ARM_REG_Q0,
    UC_ARM_REG_Q1,
    UC_ARM_REG_Q2,
    UC_ARM_REG_Q3,
    UC_ARM_REG_Q4,
    UC_ARM_REG_Q5,
    UC_ARM_REG_Q6,
    UC_ARM_REG_Q7,
    UC_ARM_REG_Q8,
    UC_ARM_REG_Q9,
    UC_ARM_REG_Q10,
    UC_ARM_REG_Q11,
    UC_ARM_REG_Q12,
    UC_ARM_REG_Q13,
    UC_ARM_REG_Q14,
    UC_ARM_REG_Q15,
    UC_ARM_REG_R0,
    UC_ARM_REG_R1,
    UC_ARM_REG_R2,
    UC_ARM_REG_R3,
    UC_ARM_REG_R4,
    UC_ARM_REG_R5,
    UC_ARM_REG_R6,
    UC_ARM_REG_R7,
    UC_ARM_REG_R8,
    UC_ARM_REG_R9,
    UC_ARM_REG_R10,
    UC_ARM_REG_R11,
    UC_ARM_REG_R12,
    UC_ARM_REG_S0,
    UC_ARM_REG_S1,
    UC_ARM_REG_S2,
    UC_ARM_REG_S3,
    UC_ARM_REG_S4,
    UC_ARM_REG_S5,
    UC_ARM_REG_S6,
    UC_ARM_REG_S7,
    UC_ARM_REG_S8,
    UC_ARM_REG_S9,
    UC_ARM_REG_S10,
    UC_ARM_REG_S11,
    UC_ARM_REG_S12,
    UC_ARM_REG_S13,
    UC_ARM_REG_S14,
    UC_ARM_REG_S15,
    UC_ARM_REG_S16,
    UC_ARM_REG_S17,
    UC_ARM_REG_S18,
    UC_ARM_REG_S19,
    UC_ARM_REG_S20,
    UC_ARM_REG_S21,
    UC_ARM_REG_S22,
    UC_ARM_REG_S23,
    UC_ARM_REG_S24,
    UC_ARM_REG_S25,
    UC_ARM_REG_S26,
    UC_ARM_REG_S27,
    UC_ARM_REG_S28,
    UC_ARM_REG_S29,
    UC_ARM_REG_S30,
    UC_ARM_REG_S31,

    UC_ARM_REG_C1_C0_2,
    UC_ARM_REG_C13_C0_2,
    UC_ARM_REG_C13_C0_3,

    UC_ARM_REG_ENDING,		// <-- mark the end of the list or registers

    //> alias registers
    UC_ARM_REG_R13 = UC_ARM_REG_SP,
    UC_ARM_REG_R14 = UC_ARM_REG_LR,
    UC_ARM_REG_R15 = UC_ARM_REG_PC,

    UC_ARM_REG_SB = UC_ARM_REG_R9,
    UC_ARM_REG_SL = UC_ARM_REG_R10,
    UC_ARM_REG_FP = UC_ARM_REG_R11,
    UC_ARM_REG_IP = UC_ARM_REG_R12,
} uc_arm_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`include/unicorn/arm64.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ARM64_H
#define UNICORN_ARM64_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM64 registers
typedef enum uc_arm64_reg {
    UC_ARM64_REG_INVALID = 0,

    UC_ARM64_REG_X29,
    UC_ARM64_REG_X30,
    UC_ARM64_REG_NZCV,
    UC_ARM64_REG_SP,
    UC_ARM64_REG_WSP,
    UC_ARM64_REG_WZR,
    UC_ARM64_REG_XZR,
    UC_ARM64_REG_B0,
    UC_ARM64_REG_B1,
    UC_ARM64_REG_B2,
    UC_ARM64_REG_B3,
    UC_ARM64_REG_B4,
    UC_ARM64_REG_B5,
    UC_ARM64_REG_B6,
    UC_ARM64_REG_B7,
    UC_ARM64_REG_B8,
    UC_ARM64_REG_B9,
    UC_ARM64_REG_B10,
    UC_ARM64_REG_B11,
    UC_ARM64_REG_B12,
    UC_ARM64_REG_B13,
    UC_ARM64_REG_B14,
    UC_ARM64_REG_B15,
    UC_ARM64_REG_B16,
    UC_ARM64_REG_B17,
    UC_ARM64_REG_B18,
    UC_ARM64_REG_B19,
    UC_ARM64_REG_B20,
    UC_ARM64_REG_B21,
    UC_ARM64_REG_B22,
    UC_ARM64_REG_B23,
    UC_ARM64_REG_B24,
    UC_ARM64_REG_B25,
    UC_ARM64_REG_B26,
    UC_ARM64_REG_B27,
    UC_ARM64_REG_B28,
    UC_ARM64_REG_B29,
    UC_ARM64_REG_B30,
    UC_ARM64_REG_B31,
    UC_ARM64_REG_D0,
    UC_ARM64_REG_D1,
    UC_ARM64_REG_D2,
    UC_ARM64_REG_D3,
    UC_ARM64_REG_D4,
    UC_ARM64_REG_D5,
    UC_ARM64_REG_D6,
    UC_ARM64_REG_D7,
    UC_ARM64_REG_D8,
    UC_ARM64_REG_D9,
    UC_ARM64_REG_D10,
    UC_ARM64_REG_D11,
    UC_ARM64_REG_D12,
    UC_ARM64_REG_D13,
    UC_ARM64_REG_D14,
    UC_ARM64_REG_D15,
    UC_ARM64_REG_D16,
    UC_ARM64_REG_D17,
    UC_ARM64_REG_D18,
    UC_ARM64_REG_D19,
    UC_ARM64_REG_D20,
    UC_ARM64_REG_D21,
    UC_ARM64_REG_D22,
    UC_ARM64_REG_D23,
    UC_ARM64_REG_D24,
    UC_ARM64_REG_D25,
    UC_ARM64_REG_D26,
    UC_ARM64_REG_D27,
    UC_ARM64_REG_D28,
    UC_ARM64_REG_D29,
    UC_ARM64_REG_D30,
    UC_ARM64_REG_D31,
    UC_ARM64_REG_H0,
    UC_ARM64_REG_H1,
    UC_ARM64_REG_H2,
    UC_ARM64_REG_H3,
    UC_ARM64_REG_H4,
    UC_ARM64_REG_H5,
    UC_ARM64_REG_H6,
    UC_ARM64_REG_H7,
    UC_ARM64_REG_H8,
    UC_ARM64_REG_H9,
    UC_ARM64_REG_H10,
    UC_ARM64_REG_H11,
    UC_ARM64_REG_H12,
    UC_ARM64_REG_H13,
    UC_ARM64_REG_H14,
    UC_ARM64_REG_H15,
    UC_ARM64_REG_H16,
    UC_ARM64_REG_H17,
    UC_ARM64_REG_H18,
    UC_ARM64_REG_H19,
    UC_ARM64_REG_H20,
    UC_ARM64_REG_H21,
    UC_ARM64_REG_H22,
    UC_ARM64_REG_H23,
    UC_ARM64_REG_H24,
    UC_ARM64_REG_H25,
    UC_ARM64_REG_H26,
    UC_ARM64_REG_H27,
    UC_ARM64_REG_H28,
    UC_ARM64_REG_H29,
    UC_ARM64_REG_H30,
    UC_ARM64_REG_H31,
    UC_ARM64_REG_Q0,
    UC_ARM64_REG_Q1,
    UC_ARM64_REG_Q2,
    UC_ARM64_REG_Q3,
    UC_ARM64_REG_Q4,
    UC_ARM64_REG_Q5,
    UC_ARM64_REG_Q6,
    UC_ARM64_REG_Q7,
    UC_ARM64_REG_Q8,
    UC_ARM64_REG_Q9,
    UC_ARM64_REG_Q10,
    UC_ARM64_REG_Q11,
    UC_ARM64_REG_Q12,
    UC_ARM64_REG_Q13,
    UC_ARM64_REG_Q14,
    UC_ARM64_REG_Q15,
    UC_ARM64_REG_Q16,
    UC_ARM64_REG_Q17,
    UC_ARM64_REG_Q18,
    UC_ARM64_REG_Q19,
    UC_ARM64_REG_Q20,
    UC_ARM64_REG_Q21,
    UC_ARM64_REG_Q22,
    UC_ARM64_REG_Q23,
    UC_ARM64_REG_Q24,
    UC_ARM64_REG_Q25,
    UC_ARM64_REG_Q26,
    UC_ARM64_REG_Q27,
    UC_ARM64_REG_Q28,
    UC_ARM64_REG_Q29,
    UC_ARM64_REG_Q30,
    UC_ARM64_REG_Q31,
    UC_ARM64_REG_S0,
    UC_ARM64_REG_S1,
    UC_ARM64_REG_S2,
    UC_ARM64_REG_S3,
    UC_ARM64_REG_S4,
    UC_ARM64_REG_S5,
    UC_ARM64_REG_S6,
    UC_ARM64_REG_S7,
    UC_ARM64_REG_S8,
    UC_ARM64_REG_S9,
    UC_ARM64_REG_S10,
    UC_ARM64_REG_S11,
    UC_ARM64_REG_S12,
    UC_ARM64_REG_S13,
    UC_ARM64_REG_S14,
    UC_ARM64_REG_S15,
    UC_ARM64_REG_S16,
    UC_ARM64_REG_S17,
    UC_ARM64_REG_S18,
    UC_ARM64_REG_S19,
    UC_ARM64_REG_S20,
    UC_ARM64_REG_S21,
    UC_ARM64_REG_S22,
    UC_ARM64_REG_S23,
    UC_ARM64_REG_S24,
    UC_ARM64_REG_S25,
    UC_ARM64_REG_S26,
    UC_ARM64_REG_S27,
    UC_ARM64_REG_S28,
    UC_ARM64_REG_S29,
    UC_ARM64_REG_S30,
    UC_ARM64_REG_S31,
    UC_ARM64_REG_W0,
    UC_ARM64_REG_W1,
    UC_ARM64_REG_W2,
    UC_ARM64_REG_W3,
    UC_ARM64_REG_W4,
    UC_ARM64_REG_W5,
    UC_ARM64_REG_W6,
    UC_ARM64_REG_W7,
    UC_ARM64_REG_W8,
    UC_ARM64_REG_W9,
    UC_ARM64_REG_W10,
    UC_ARM64_REG_W11,
    UC_ARM64_REG_W12,
    UC_ARM64_REG_W13,
    UC_ARM64_REG_W14,
    UC_ARM64_REG_W15,
    UC_ARM64_REG_W16,
    UC_ARM64_REG_W17,
    UC_ARM64_REG_W18,
    UC_ARM64_REG_W19,
    UC_ARM64_REG_W20,
    UC_ARM64_REG_W21,
    UC_ARM64_REG_W22,
    UC_ARM64_REG_W23,
    UC_ARM64_REG_W24,
    UC_ARM64_REG_W25,
    UC_ARM64_REG_W26,
    UC_ARM64_REG_W27,
    UC_ARM64_REG_W28,
    UC_ARM64_REG_W29,
    UC_ARM64_REG_W30,
    UC_ARM64_REG_X0,
    UC_ARM64_REG_X1,
    UC_ARM64_REG_X2,
    UC_ARM64_REG_X3,
    UC_ARM64_REG_X4,
    UC_ARM64_REG_X5,
    UC_ARM64_REG_X6,
    UC_ARM64_REG_X7,
    UC_ARM64_REG_X8,
    UC_ARM64_REG_X9,
    UC_ARM64_REG_X10,
    UC_ARM64_REG_X11,
    UC_ARM64_REG_X12,
    UC_ARM64_REG_X13,
    UC_ARM64_REG_X14,
    UC_ARM64_REG_X15,
    UC_ARM64_REG_X16,
    UC_ARM64_REG_X17,
    UC_ARM64_REG_X18,
    UC_ARM64_REG_X19,
    UC_ARM64_REG_X20,
    UC_ARM64_REG_X21,
    UC_ARM64_REG_X22,
    UC_ARM64_REG_X23,
    UC_ARM64_REG_X24,
    UC_ARM64_REG_X25,
    UC_ARM64_REG_X26,
    UC_ARM64_REG_X27,
    UC_ARM64_REG_X28,

    UC_ARM64_REG_V0,
    UC_ARM64_REG_V1,
    UC_ARM64_REG_V2,
    UC_ARM64_REG_V3,
    UC_ARM64_REG_V4,
    UC_ARM64_REG_V5,
    UC_ARM64_REG_V6,
    UC_ARM64_REG_V7,
    UC_ARM64_REG_V8,
    UC_ARM64_REG_V9,
    UC_ARM64_REG_V10,
    UC_ARM64_REG_V11,
    UC_ARM64_REG_V12,
    UC_ARM64_REG_V13,
    UC_ARM64_REG_V14,
    UC_ARM64_REG_V15,
    UC_ARM64_REG_V16,
    UC_ARM64_REG_V17,
    UC_ARM64_REG_V18,
    UC_ARM64_REG_V19,
    UC_ARM64_REG_V20,
    UC_ARM64_REG_V21,
    UC_ARM64_REG_V22,
    UC_ARM64_REG_V23,
    UC_ARM64_REG_V24,
    UC_ARM64_REG_V25,
    UC_ARM64_REG_V26,
    UC_ARM64_REG_V27,
    UC_ARM64_REG_V28,
    UC_ARM64_REG_V29,
    UC_ARM64_REG_V30,
    UC_ARM64_REG_V31,

    //> pseudo registers
    UC_ARM64_REG_PC,			// program counter register

    UC_ARM64_REG_CPACR_EL1,

    //> thread registers
    UC_ARM64_REG_TPIDR_EL0,
    UC_ARM64_REG_TPIDRRO_EL0,
    UC_ARM64_REG_TPIDR_EL1,
    
    UC_ARM64_REG_ENDING,		// <-- mark the end of the list of registers

    //> alias registers

    UC_ARM64_REG_IP0 = UC_ARM64_REG_X16,
    UC_ARM64_REG_IP1 = UC_ARM64_REG_X17,
    UC_ARM64_REG_FP = UC_ARM64_REG_X29,
    UC_ARM64_REG_LR = UC_ARM64_REG_X30,
} uc_arm64_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`include/unicorn/m68k.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_M68K_H
#define UNICORN_M68K_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> M68K registers
typedef enum uc_m68k_reg {
    UC_M68K_REG_INVALID = 0,

    UC_M68K_REG_A0,
    UC_M68K_REG_A1,
    UC_M68K_REG_A2,
    UC_M68K_REG_A3,
    UC_M68K_REG_A4,
    UC_M68K_REG_A5,
    UC_M68K_REG_A6,
    UC_M68K_REG_A7,

    UC_M68K_REG_D0,
    UC_M68K_REG_D1,
    UC_M68K_REG_D2,
    UC_M68K_REG_D3,
    UC_M68K_REG_D4,
    UC_M68K_REG_D5,
    UC_M68K_REG_D6,
    UC_M68K_REG_D7,

    UC_M68K_REG_SR,
    UC_M68K_REG_PC,

    UC_M68K_REG_ENDING,   // <-- mark the end of the list of registers
} uc_m68k_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`include/unicorn/mips.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_MIPS_H
#define UNICORN_MIPS_H

#ifdef __cplusplus
extern "C" {
#endif

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> MIPS registers
typedef enum UC_MIPS_REG {
    UC_MIPS_REG_INVALID = 0,
    //> General purpose registers
    UC_MIPS_REG_PC,

    UC_MIPS_REG_0,
    UC_MIPS_REG_1,
    UC_MIPS_REG_2,
    UC_MIPS_REG_3,
    UC_MIPS_REG_4,
    UC_MIPS_REG_5,
    UC_MIPS_REG_6,
    UC_MIPS_REG_7,
    UC_MIPS_REG_8,
    UC_MIPS_REG_9,
    UC_MIPS_REG_10,
    UC_MIPS_REG_11,
    UC_MIPS_REG_12,
    UC_MIPS_REG_13,
    UC_MIPS_REG_14,
    UC_MIPS_REG_15,
    UC_MIPS_REG_16,
    UC_MIPS_REG_17,
    UC_MIPS_REG_18,
    UC_MIPS_REG_19,
    UC_MIPS_REG_20,
    UC_MIPS_REG_21,
    UC_MIPS_REG_22,
    UC_MIPS_REG_23,
    UC_MIPS_REG_24,
    UC_MIPS_REG_25,
    UC_MIPS_REG_26,
    UC_MIPS_REG_27,
    UC_MIPS_REG_28,
    UC_MIPS_REG_29,
    UC_MIPS_REG_30,
    UC_MIPS_REG_31,

    //> DSP registers
    UC_MIPS_REG_DSPCCOND,
    UC_MIPS_REG_DSPCARRY,
    UC_MIPS_REG_DSPEFI,
    UC_MIPS_REG_DSPOUTFLAG,
    UC_MIPS_REG_DSPOUTFLAG16_19,
    UC_MIPS_REG_DSPOUTFLAG20,
    UC_MIPS_REG_DSPOUTFLAG21,
    UC_MIPS_REG_DSPOUTFLAG22,
    UC_MIPS_REG_DSPOUTFLAG23,
    UC_MIPS_REG_DSPPOS,
    UC_MIPS_REG_DSPSCOUNT,

    //> ACC registers
    UC_MIPS_REG_AC0,
    UC_MIPS_REG_AC1,
    UC_MIPS_REG_AC2,
    UC_MIPS_REG_AC3,

    //> COP registers
    UC_MIPS_REG_CC0,
    UC_MIPS_REG_CC1,
    UC_MIPS_REG_CC2,
    UC_MIPS_REG_CC3,
    UC_MIPS_REG_CC4,
    UC_MIPS_REG_CC5,
    UC_MIPS_REG_CC6,
    UC_MIPS_REG_CC7,

    //> FPU registers
    UC_MIPS_REG_F0,
    UC_MIPS_REG_F1,
    UC_MIPS_REG_F2,
    UC_MIPS_REG_F3,
    UC_MIPS_REG_F4,
    UC_MIPS_REG_F5,
    UC_MIPS_REG_F6,
    UC_MIPS_REG_F7,
    UC_MIPS_REG_F8,
    UC_MIPS_REG_F9,
    UC_MIPS_REG_F10,
    UC_MIPS_REG_F11,
    UC_MIPS_REG_F12,
    UC_MIPS_REG_F13,
    UC_MIPS_REG_F14,
    UC_MIPS_REG_F15,
    UC_MIPS_REG_F16,
    UC_MIPS_REG_F17,
    UC_MIPS_REG_F18,
    UC_MIPS_REG_F19,
    UC_MIPS_REG_F20,
    UC_MIPS_REG_F21,
    UC_MIPS_REG_F22,
    UC_MIPS_REG_F23,
    UC_MIPS_REG_F24,
    UC_MIPS_REG_F25,
    UC_MIPS_REG_F26,
    UC_MIPS_REG_F27,
    UC_MIPS_REG_F28,
    UC_MIPS_REG_F29,
    UC_MIPS_REG_F30,
    UC_MIPS_REG_F31,

    UC_MIPS_REG_FCC0,
    UC_MIPS_REG_FCC1,
    UC_MIPS_REG_FCC2,
    UC_MIPS_REG_FCC3,
    UC_MIPS_REG_FCC4,
    UC_MIPS_REG_FCC5,
    UC_MIPS_REG_FCC6,
    UC_MIPS_REG_FCC7,

    //> AFPR128
    UC_MIPS_REG_W0,
    UC_MIPS_REG_W1,
    UC_MIPS_REG_W2,
    UC_MIPS_REG_W3,
    UC_MIPS_REG_W4,
    UC_MIPS_REG_W5,
    UC_MIPS_REG_W6,
    UC_MIPS_REG_W7,
    UC_MIPS_REG_W8,
    UC_MIPS_REG_W9,
    UC_MIPS_REG_W10,
    UC_MIPS_REG_W11,
    UC_MIPS_REG_W12,
    UC_MIPS_REG_W13,
    UC_MIPS_REG_W14,
    UC_MIPS_REG_W15,
    UC_MIPS_REG_W16,
    UC_MIPS_REG_W17,
    UC_MIPS_REG_W18,
    UC_MIPS_REG_W19,
    UC_MIPS_REG_W20,
    UC_MIPS_REG_W21,
    UC_MIPS_REG_W22,
    UC_MIPS_REG_W23,
    UC_MIPS_REG_W24,
    UC_MIPS_REG_W25,
    UC_MIPS_REG_W26,
    UC_MIPS_REG_W27,
    UC_MIPS_REG_W28,
    UC_MIPS_REG_W29,
    UC_MIPS_REG_W30,
    UC_MIPS_REG_W31,

    UC_MIPS_REG_HI,
    UC_MIPS_REG_LO,

    UC_MIPS_REG_P0,
    UC_MIPS_REG_P1,
    UC_MIPS_REG_P2,

    UC_MIPS_REG_MPL0,
    UC_MIPS_REG_MPL1,
    UC_MIPS_REG_MPL2,

    UC_MIPS_REG_ENDING,	// <-- mark the end of the list or registers

    // alias registers
    UC_MIPS_REG_ZERO = UC_MIPS_REG_0,
    UC_MIPS_REG_AT = UC_MIPS_REG_1,
    UC_MIPS_REG_V0 = UC_MIPS_REG_2,
    UC_MIPS_REG_V1 = UC_MIPS_REG_3,
    UC_MIPS_REG_A0 = UC_MIPS_REG_4,
    UC_MIPS_REG_A1 = UC_MIPS_REG_5,
    UC_MIPS_REG_A2 = UC_MIPS_REG_6,
    UC_MIPS_REG_A3 = UC_MIPS_REG_7,
    UC_MIPS_REG_T0 = UC_MIPS_REG_8,
    UC_MIPS_REG_T1 = UC_MIPS_REG_9,
    UC_MIPS_REG_T2 = UC_MIPS_REG_10,
    UC_MIPS_REG_T3 = UC_MIPS_REG_11,
    UC_MIPS_REG_T4 = UC_MIPS_REG_12,
    UC_MIPS_REG_T5 = UC_MIPS_REG_13,
    UC_MIPS_REG_T6 = UC_MIPS_REG_14,
    UC_MIPS_REG_T7 = UC_MIPS_REG_15,
    UC_MIPS_REG_S0 = UC_MIPS_REG_16,
    UC_MIPS_REG_S1 = UC_MIPS_REG_17,
    UC_MIPS_REG_S2 = UC_MIPS_REG_18,
    UC_MIPS_REG_S3 = UC_MIPS_REG_19,
    UC_MIPS_REG_S4 = UC_MIPS_REG_20,
    UC_MIPS_REG_S5 = UC_MIPS_REG_21,
    UC_MIPS_REG_S6 = UC_MIPS_REG_22,
    UC_MIPS_REG_S7 = UC_MIPS_REG_23,
    UC_MIPS_REG_T8 = UC_MIPS_REG_24,
    UC_MIPS_REG_T9 = UC_MIPS_REG_25,
    UC_MIPS_REG_K0 = UC_MIPS_REG_26,
    UC_MIPS_REG_K1 = UC_MIPS_REG_27,
    UC_MIPS_REG_GP = UC_MIPS_REG_28,
    UC_MIPS_REG_SP = UC_MIPS_REG_29,
    UC_MIPS_REG_FP = UC_MIPS_REG_30, UC_MIPS_REG_S8 = UC_MIPS_REG_30,
    UC_MIPS_REG_RA = UC_MIPS_REG_31,

    UC_MIPS_REG_HI0 = UC_MIPS_REG_AC0,
    UC_MIPS_REG_HI1 = UC_MIPS_REG_AC1,
    UC_MIPS_REG_HI2 = UC_MIPS_REG_AC2,
    UC_MIPS_REG_HI3 = UC_MIPS_REG_AC3,

    UC_MIPS_REG_LO0 = UC_MIPS_REG_HI0,
    UC_MIPS_REG_LO1 = UC_MIPS_REG_HI1,
    UC_MIPS_REG_LO2 = UC_MIPS_REG_HI2,
    UC_MIPS_REG_LO3 = UC_MIPS_REG_HI3,
} UC_MIPS_REG;

#ifdef __cplusplus
}
#endif

#endif

```

`include/unicorn/platform.h`:

```h
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

/*
 This file is to support header files that are missing in MSVC and
 other non-standard compilers.
*/
#ifndef UNICORN_PLATFORM_H
#define UNICORN_PLATFORM_H

/*
These are the various MSVC versions as given by _MSC_VER:
MSVC++ 14.1 _MSC_VER == 1916 (Visual Studio 2017)
MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)
MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
MSVC++ 7.0  _MSC_VER == 1300
MSVC++ 6.0  _MSC_VER == 1200
MSVC++ 5.0  _MSC_VER == 1100
*/
#define MSC_VER_VS2003	1310
#define MSC_VER_VS2005	1400
#define MSC_VER_VS2008	1500
#define MSC_VER_VS2010	1600
#define MSC_VER_VS2012	1700
#define MSC_VER_VS2013	1800
#define MSC_VER_VS2015	1900
#define MSC_VER_VS2017	1916

// handle stdbool.h compatibility
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif  // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif  // (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif  // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))

#if (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2010)) || defined(_KERNEL_MODE)
// this system does not have stdint.h
typedef signed char  int8_t;
typedef signed short int16_t;
typedef signed int   int32_t;
typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int   uint32_t;
typedef signed long long   int64_t;
typedef unsigned long long uint64_t;

#ifndef _INTPTR_T_DEFINED
 #define _INTPTR_T_DEFINED
 #ifdef _WIN64
typedef long long          intptr_t;
 #else /* _WIN64 */
typedef _W64 int           intptr_t;
 #endif /* _WIN64 */
#endif /* _INTPTR_T_DEFINED */

#ifndef _UINTPTR_T_DEFINED
 #define _UINTPTR_T_DEFINED
 #ifdef _WIN64
typedef unsigned long long uintptr_t;
 #else /* _WIN64 */
typedef _W64 unsigned int  uintptr_t;
 #endif /* _WIN64 */
#endif /* _UINTPTR_T_DEFINED */

#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64
#else // this system has stdint.h
#include <stdint.h>
#endif  // (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2010)) || defined(_KERNEL_MODE)

// handle inttypes.h compatibility
#if (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2013)) || defined(_KERNEL_MODE)
// this system does not have inttypes.h

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8         __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8         __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8         __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8         __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8         __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8         __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16        "hd"
#define PRIi16        "hi"
#define PRIo16        "ho"
#define PRIu16        "hu"
#define PRIx16        "hx"
#define PRIX16        "hX"

#if defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)
#define PRId32        "ld"
#define PRIi32        "li"
#define PRIo32        "lo"
#define PRIu32        "lu"
#define PRIx32        "lx"
#define PRIX32        "lX"
#else	// OSX
#define PRId32        "d"
#define PRIi32        "i"
#define PRIo32        "o"
#define PRIu32        "u"
#define PRIx32        "x"
#define PRIX32        "X"
#endif  // defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)

#if defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)
// redefine functions from inttypes.h used in cstool
#define strtoull _strtoui64
#endif

#define PRId64        __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64        __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64        __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64        __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64        __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64        __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif // #if defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)

// sys/time.h compatibility
#if defined(_MSC_VER)
#include <sys/timeb.h>
#include <winsock2.h>
#include <windows.h>

static int gettimeofday(struct timeval* t, void* timezone)
{
    struct _timeb timebuffer;
    _ftime( &timebuffer );
    t->tv_sec = (long)timebuffer.time;
    t->tv_usec = 1000*timebuffer.millitm;
    return 0;
}
#else
#include <sys/time.h>
#endif

// unistd.h compatibility
#if defined(_MSC_VER)

static int usleep(uint32_t usec)
{
    HANDLE timer;
    LARGE_INTEGER due;

    timer = CreateWaitableTimer(NULL, TRUE, NULL);
    if (!timer)
        return -1;

    due.QuadPart = (-((int64_t) usec)) * 10LL;
    if (!SetWaitableTimer(timer, &due, 0, NULL, NULL, 0)) {
        CloseHandle(timer);
        return -1;
    }
    WaitForSingleObject(timer, INFINITE);
    CloseHandle(timer);

    return 0;
}

#else
#include <unistd.h>
#endif

// misc support
#if defined(_MSC_VER)
#ifdef  _WIN64
typedef signed __int64    ssize_t;
#else
typedef _W64 signed int   ssize_t;
#endif

#define va_copy(d,s) ((d) = (s))
#define strcasecmp	_stricmp
#if (_MSC_VER < MSC_VER_VS2015)
#define snprintf	_snprintf
#endif
#if (_MSC_VER <= MSC_VER_VS2013)
#define strtoll		_strtoi64
#endif
#endif


#endif // UNICORN_PLATFORM_H

```

`include/unicorn/sparc.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_SPARC_H
#define UNICORN_SPARC_H

#ifdef __cplusplus
extern "C" {
#endif

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> SPARC registers
typedef enum uc_sparc_reg {
    UC_SPARC_REG_INVALID = 0,

    UC_SPARC_REG_F0,
    UC_SPARC_REG_F1,
    UC_SPARC_REG_F2,
    UC_SPARC_REG_F3,
    UC_SPARC_REG_F4,
    UC_SPARC_REG_F5,
    UC_SPARC_REG_F6,
    UC_SPARC_REG_F7,
    UC_SPARC_REG_F8,
    UC_SPARC_REG_F9,
    UC_SPARC_REG_F10,
    UC_SPARC_REG_F11,
    UC_SPARC_REG_F12,
    UC_SPARC_REG_F13,
    UC_SPARC_REG_F14,
    UC_SPARC_REG_F15,
    UC_SPARC_REG_F16,
    UC_SPARC_REG_F17,
    UC_SPARC_REG_F18,
    UC_SPARC_REG_F19,
    UC_SPARC_REG_F20,
    UC_SPARC_REG_F21,
    UC_SPARC_REG_F22,
    UC_SPARC_REG_F23,
    UC_SPARC_REG_F24,
    UC_SPARC_REG_F25,
    UC_SPARC_REG_F26,
    UC_SPARC_REG_F27,
    UC_SPARC_REG_F28,
    UC_SPARC_REG_F29,
    UC_SPARC_REG_F30,
    UC_SPARC_REG_F31,
    UC_SPARC_REG_F32,
    UC_SPARC_REG_F34,
    UC_SPARC_REG_F36,
    UC_SPARC_REG_F38,
    UC_SPARC_REG_F40,
    UC_SPARC_REG_F42,
    UC_SPARC_REG_F44,
    UC_SPARC_REG_F46,
    UC_SPARC_REG_F48,
    UC_SPARC_REG_F50,
    UC_SPARC_REG_F52,
    UC_SPARC_REG_F54,
    UC_SPARC_REG_F56,
    UC_SPARC_REG_F58,
    UC_SPARC_REG_F60,
    UC_SPARC_REG_F62,
    UC_SPARC_REG_FCC0,	// Floating condition codes
    UC_SPARC_REG_FCC1,
    UC_SPARC_REG_FCC2,
    UC_SPARC_REG_FCC3,
    UC_SPARC_REG_G0,
    UC_SPARC_REG_G1,
    UC_SPARC_REG_G2,
    UC_SPARC_REG_G3,
    UC_SPARC_REG_G4,
    UC_SPARC_REG_G5,
    UC_SPARC_REG_G6,
    UC_SPARC_REG_G7,
    UC_SPARC_REG_I0,
    UC_SPARC_REG_I1,
    UC_SPARC_REG_I2,
    UC_SPARC_REG_I3,
    UC_SPARC_REG_I4,
    UC_SPARC_REG_I5,
    UC_SPARC_REG_FP,
    UC_SPARC_REG_I7,
    UC_SPARC_REG_ICC,	// Integer condition codes
    UC_SPARC_REG_L0,
    UC_SPARC_REG_L1,
    UC_SPARC_REG_L2,
    UC_SPARC_REG_L3,
    UC_SPARC_REG_L4,
    UC_SPARC_REG_L5,
    UC_SPARC_REG_L6,
    UC_SPARC_REG_L7,
    UC_SPARC_REG_O0,
    UC_SPARC_REG_O1,
    UC_SPARC_REG_O2,
    UC_SPARC_REG_O3,
    UC_SPARC_REG_O4,
    UC_SPARC_REG_O5,
    UC_SPARC_REG_SP,
    UC_SPARC_REG_O7,
    UC_SPARC_REG_Y,

    // special register
    UC_SPARC_REG_XCC,

    // pseudo register
    UC_SPARC_REG_PC,   // program counter register

    UC_SPARC_REG_ENDING,   // <-- mark the end of the list of registers

    // extras
    UC_SPARC_REG_O6 = UC_SPARC_REG_SP,
    UC_SPARC_REG_I6 = UC_SPARC_REG_FP,
} uc_sparc_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`include/unicorn/unicorn.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ENGINE_H
#define UNICORN_ENGINE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"
#include <stdarg.h>

#if defined(UNICORN_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

struct uc_struct;
typedef struct uc_struct uc_engine;

typedef size_t uc_hook;

#include "m68k.h"
#include "x86.h"
#include "arm.h"
#include "arm64.h"
#include "mips.h"
#include "sparc.h"

#ifdef __GNUC__
#define DEFAULT_VISIBILITY __attribute__((visibility("default")))
#else
#define DEFAULT_VISIBILITY
#endif

#ifdef _MSC_VER
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#ifdef UNICORN_SHARED
#define UNICORN_EXPORT __declspec(dllexport)
#else    // defined(UNICORN_STATIC)
#define UNICORN_EXPORT
#endif
#else
#ifdef __GNUC__
#define UNICORN_EXPORT __attribute__((visibility("default")))
#else
#define UNICORN_EXPORT
#endif
#endif

#ifdef __GNUC__
#define UNICORN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define UNICORN_DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement UNICORN_DEPRECATED for this compiler")
#define UNICORN_DEPRECATED
#endif

// Unicorn API version
#define UC_API_MAJOR 1
#define UC_API_MINOR 0

// Unicorn package version
#define UC_VERSION_MAJOR UC_API_MAJOR
#define UC_VERSION_MINOR UC_API_MINOR
#define UC_VERSION_EXTRA 2


/*
  Macro to create combined version which can be compared to
  result of uc_version() API.
*/
#define UC_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Scales to calculate timeout on microsecond unit
// 1 second = 1000,000 microseconds
#define UC_SECOND_SCALE 1000000
// 1 milisecond = 1000 nanoseconds
#define UC_MILISECOND_SCALE 1000

// Architecture type
typedef enum uc_arch {
    UC_ARCH_ARM = 1,    // ARM architecture (including Thumb, Thumb-2)
    UC_ARCH_ARM64,      // ARM-64, also called AArch64
    UC_ARCH_MIPS,       // Mips architecture
    UC_ARCH_X86,        // X86 architecture (including x86 & x86-64)
    UC_ARCH_PPC,        // PowerPC architecture (currently unsupported)
    UC_ARCH_SPARC,      // Sparc architecture
    UC_ARCH_M68K,       // M68K architecture
    UC_ARCH_MAX,
} uc_arch;

// Mode type
typedef enum uc_mode {
    UC_MODE_LITTLE_ENDIAN = 0,    // little-endian mode (default mode)
    UC_MODE_BIG_ENDIAN = 1 << 30, // big-endian mode
    // arm / arm64
    UC_MODE_ARM = 0,              // ARM mode
    UC_MODE_THUMB = 1 << 4,       // THUMB mode (including Thumb-2)
    UC_MODE_MCLASS = 1 << 5,      // ARM's Cortex-M series (currently unsupported)
    UC_MODE_V8 = 1 << 6,          // ARMv8 A32 encodings for ARM (currently unsupported)
    // mips
    UC_MODE_MICRO = 1 << 4,       // MicroMips mode (currently unsupported)
    UC_MODE_MIPS3 = 1 << 5,       // Mips III ISA (currently unsupported)
    UC_MODE_MIPS32R6 = 1 << 6,    // Mips32r6 ISA (currently unsupported)
    UC_MODE_MIPS32 = 1 << 2,      // Mips32 ISA
    UC_MODE_MIPS64 = 1 << 3,      // Mips64 ISA
    // x86 / x64
    UC_MODE_16 = 1 << 1,          // 16-bit mode
    UC_MODE_32 = 1 << 2,          // 32-bit mode
    UC_MODE_64 = 1 << 3,          // 64-bit mode
    // ppc 
    UC_MODE_PPC32 = 1 << 2,       // 32-bit mode (currently unsupported)
    UC_MODE_PPC64 = 1 << 3,       // 64-bit mode (currently unsupported)
    UC_MODE_QPX = 1 << 4,         // Quad Processing eXtensions mode (currently unsupported)
    // sparc
    UC_MODE_SPARC32 = 1 << 2,     // 32-bit mode
    UC_MODE_SPARC64 = 1 << 3,     // 64-bit mode
    UC_MODE_V9 = 1 << 4,          // SparcV9 mode (currently unsupported)
    // m68k
} uc_mode;

// All type of errors encountered by Unicorn API.
// These are values returned by uc_errno()
typedef enum uc_err {
    UC_ERR_OK = 0,   // No error: everything was fine
    UC_ERR_NOMEM,      // Out-Of-Memory error: uc_open(), uc_emulate()
    UC_ERR_ARCH,     // Unsupported architecture: uc_open()
    UC_ERR_HANDLE,   // Invalid handle
    UC_ERR_MODE,     // Invalid/unsupported mode: uc_open()
    UC_ERR_VERSION,  // Unsupported version (bindings)
    UC_ERR_READ_UNMAPPED, // Quit emulation due to READ on unmapped memory: uc_emu_start()
    UC_ERR_WRITE_UNMAPPED, // Quit emulation due to WRITE on unmapped memory: uc_emu_start()
    UC_ERR_FETCH_UNMAPPED, // Quit emulation due to FETCH on unmapped memory: uc_emu_start()
    UC_ERR_HOOK,    // Invalid hook type: uc_hook_add()
    UC_ERR_INSN_INVALID, // Quit emulation due to invalid instruction: uc_emu_start()
    UC_ERR_MAP, // Invalid memory mapping: uc_mem_map()
    UC_ERR_WRITE_PROT, // Quit emulation due to UC_MEM_WRITE_PROT violation: uc_emu_start()
    UC_ERR_READ_PROT, // Quit emulation due to UC_MEM_READ_PROT violation: uc_emu_start()
    UC_ERR_FETCH_PROT, // Quit emulation due to UC_MEM_FETCH_PROT violation: uc_emu_start()
    UC_ERR_ARG,     // Inavalid argument provided to uc_xxx function (See specific function API)
    UC_ERR_READ_UNALIGNED,  // Unaligned read
    UC_ERR_WRITE_UNALIGNED,  // Unaligned write
    UC_ERR_FETCH_UNALIGNED,  // Unaligned fetch
    UC_ERR_HOOK_EXIST,  // hook for this event already existed
    UC_ERR_RESOURCE,    // Insufficient resource: uc_emu_start()
    UC_ERR_EXCEPTION // Unhandled CPU exception
} uc_err;


/*
  Callback function for tracing code (UC_HOOK_CODE & UC_HOOK_BLOCK)

  @address: address where the code is being executed
  @size: size of machine instruction(s) being executed, or 0 when size is unknown
  @user_data: user data passed to tracing APIs.
*/
typedef void (*uc_cb_hookcode_t)(uc_engine *uc, uint64_t address, uint32_t size, void *user_data);

/*
  Callback function for tracing interrupts (for uc_hook_intr())

  @intno: interrupt number
  @user_data: user data passed to tracing APIs.
*/
typedef void (*uc_cb_hookintr_t)(uc_engine *uc, uint32_t intno, void *user_data);

/*
  Callback function for tracing IN instruction of X86

  @port: port number
  @size: data size (1/2/4) to be read from this port
  @user_data: user data passed to tracing APIs.
*/
typedef uint32_t (*uc_cb_insn_in_t)(uc_engine *uc, uint32_t port, int size, void *user_data);

/*
  Callback function for OUT instruction of X86

  @port: port number
  @size: data size (1/2/4) to be written to this port
  @value: data value to be written to this port
*/
typedef void (*uc_cb_insn_out_t)(uc_engine *uc, uint32_t port, int size, uint32_t value, void *user_data);

// All type of memory accesses for UC_HOOK_MEM_*
typedef enum uc_mem_type {
    UC_MEM_READ = 16,   // Memory is read from
    UC_MEM_WRITE,       // Memory is written to
    UC_MEM_FETCH,       // Memory is fetched
    UC_MEM_READ_UNMAPPED,    // Unmapped memory is read from
    UC_MEM_WRITE_UNMAPPED,   // Unmapped memory is written to
    UC_MEM_FETCH_UNMAPPED,   // Unmapped memory is fetched
    UC_MEM_WRITE_PROT,  // Write to write protected, but mapped, memory
    UC_MEM_READ_PROT,   // Read from read protected, but mapped, memory
    UC_MEM_FETCH_PROT,  // Fetch from non-executable, but mapped, memory
    UC_MEM_READ_AFTER,   // Memory is read from (successful access)
} uc_mem_type;

// All type of hooks for uc_hook_add() API.
typedef enum uc_hook_type {
    // Hook all interrupt/syscall events
    UC_HOOK_INTR = 1 << 0,
    // Hook a particular instruction - only a very small subset of instructions supported here
    UC_HOOK_INSN = 1 << 1,
    // Hook a range of code
    UC_HOOK_CODE = 1 << 2,
    // Hook basic blocks
    UC_HOOK_BLOCK = 1 << 3,
    // Hook for memory read on unmapped memory
    UC_HOOK_MEM_READ_UNMAPPED = 1 << 4,
    // Hook for invalid memory write events
    UC_HOOK_MEM_WRITE_UNMAPPED = 1 << 5,
    // Hook for invalid memory fetch for execution events
    UC_HOOK_MEM_FETCH_UNMAPPED = 1 << 6,
    // Hook for memory read on read-protected memory
    UC_HOOK_MEM_READ_PROT = 1 << 7,
    // Hook for memory write on write-protected memory
    UC_HOOK_MEM_WRITE_PROT = 1 << 8,
    // Hook for memory fetch on non-executable memory
    UC_HOOK_MEM_FETCH_PROT = 1 << 9,
    // Hook memory read events.
    UC_HOOK_MEM_READ = 1 << 10,
    // Hook memory write events.
    UC_HOOK_MEM_WRITE = 1 << 11,
    // Hook memory fetch for execution events
    UC_HOOK_MEM_FETCH = 1 << 12,
    // Hook memory read events, but only successful access.
    // The callback will be triggered after successful read.
    UC_HOOK_MEM_READ_AFTER = 1 << 13,
} uc_hook_type;

// Hook type for all events of unmapped memory access
#define UC_HOOK_MEM_UNMAPPED (UC_HOOK_MEM_READ_UNMAPPED + UC_HOOK_MEM_WRITE_UNMAPPED + UC_HOOK_MEM_FETCH_UNMAPPED)
// Hook type for all events of illegal protected memory access
#define UC_HOOK_MEM_PROT (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_FETCH_PROT)
// Hook type for all events of illegal read memory access
#define UC_HOOK_MEM_READ_INVALID (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_READ_UNMAPPED)
// Hook type for all events of illegal write memory access
#define UC_HOOK_MEM_WRITE_INVALID (UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_WRITE_UNMAPPED)
// Hook type for all events of illegal fetch memory access
#define UC_HOOK_MEM_FETCH_INVALID (UC_HOOK_MEM_FETCH_PROT + UC_HOOK_MEM_FETCH_UNMAPPED)
// Hook type for all events of illegal memory access
#define UC_HOOK_MEM_INVALID (UC_HOOK_MEM_UNMAPPED + UC_HOOK_MEM_PROT)
// Hook type for all events of valid memory access
// NOTE: UC_HOOK_MEM_READ is triggered before UC_HOOK_MEM_READ_PROT and UC_HOOK_MEM_READ_UNMAPPED, so
//       this hook may technically trigger on some invalid reads. 
#define UC_HOOK_MEM_VALID (UC_HOOK_MEM_READ + UC_HOOK_MEM_WRITE + UC_HOOK_MEM_FETCH)

/*
  Callback function for hooking memory (READ, WRITE & FETCH)

  @type: this memory is being READ, or WRITE
  @address: address where the code is being executed
  @size: size of data being read or written
  @value: value of data being written to memory, or irrelevant if type = READ.
  @user_data: user data passed to tracing APIs
*/
typedef void (*uc_cb_hookmem_t)(uc_engine *uc, uc_mem_type type,
        uint64_t address, int size, int64_t value, void *user_data);

/*
  Callback function for handling invalid memory access events (UNMAPPED and
    PROT events)

  @type: this memory is being READ, or WRITE
  @address: address where the code is being executed
  @size: size of data being read or written
  @value: value of data being written to memory, or irrelevant if type = READ.
  @user_data: user data passed to tracing APIs

  @return: return true to continue, or false to stop program (due to invalid memory).
           NOTE: returning true to continue execution will only work if if the accessed
           memory is made accessible with the correct permissions during the hook.
           
           In the event of a UC_MEM_READ_UNMAPPED or UC_MEM_WRITE_UNMAPPED callback,
           the memory should be uc_mem_map()-ed with the correct permissions, and the
           instruction will then read or write to the address as it was supposed to.
           
           In the event of a UC_MEM_FETCH_UNMAPPED callback, the memory can be mapped
           in as executable, in which case execution will resume from the fetched address.
           The instruction pointer may be written to in order to change where execution resumes,
           but the fetch must succeed if execution is to resume.
*/
typedef bool (*uc_cb_eventmem_t)(uc_engine *uc, uc_mem_type type,
        uint64_t address, int size, int64_t value, void *user_data);

/*
  Memory region mapped by uc_mem_map() and uc_mem_map_ptr()
  Retrieve the list of memory regions with uc_mem_regions()
*/
typedef struct uc_mem_region {
    uint64_t begin; // begin address of the region (inclusive)
    uint64_t end;   // end address of the region (inclusive)
    uint32_t perms; // memory permissions of the region
} uc_mem_region;

// All type of queries for uc_query() API.
typedef enum uc_query_type {
    // Dynamically query current hardware mode.
    UC_QUERY_MODE = 1,
    UC_QUERY_PAGE_SIZE,
    UC_QUERY_ARCH,
} uc_query_type;

// Opaque storage for CPU context, used with uc_context_*()
struct uc_context;
typedef struct uc_context uc_context;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
     major & minor versions.
     NOTE: This returned value can be compared with version number made
     with macro UC_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
UNICORN_EXPORT
unsigned int uc_version(unsigned int *major, unsigned int *minor);


/*
 Determine if the given architecture is supported by this library.

 @arch: architecture type (UC_ARCH_*)

 @return True if this library supports the given arch.
*/
UNICORN_EXPORT
bool uc_arch_supported(uc_arch arch);


/*
 Create new instance of unicorn engine.

 @arch: architecture type (UC_ARCH_*)
 @mode: hardware mode. This is combined of UC_MODE_*
 @uc: pointer to uc_engine, which will be updated at return time

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_open(uc_arch arch, uc_mode mode, uc_engine **uc);

/*
 Close a Unicorn engine instance.
 NOTE: this must be called only when there is no longer any
 usage of @uc. This API releases some of @uc's cached memory, thus
 any use of the Unicorn API with @uc after it has been closed may
 crash your application. After this, @uc is invalid, and is no
 longer usable.

 @uc: pointer to a handle returned by uc_open()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_close(uc_engine *uc);

/*
 Query internal status of engine.

 @uc: handle returned by uc_open()
 @type: query type. See uc_query_type

 @result: save the internal status queried

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_query(uc_engine *uc, uc_query_type type, size_t *result);

/*
 Report the last error number when some API function fail.
 Like glibc's errno, uc_errno might not retain its old value once accessed.

 @uc: handle returned by uc_open()

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_errno(uc_engine *uc);

/*
 Return a string describing given error code.

 @code: error code (see UC_ERR_* above)

 @return: returns a pointer to a string that describes the error code
   passed in the argument @code
 */
UNICORN_EXPORT
const char *uc_strerror(uc_err code);

/*
 Write to register.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will set to register @regid

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_write(uc_engine *uc, int regid, const void *value);

/*
 Read register value.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_read(uc_engine *uc, int regid, void *value);

/*
 Write multiple register values.

 @uc: handle returned by uc_open()
 @rges:  array of register IDs to store
 @value: pointer to array of register values
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_write_batch(uc_engine *uc, int *regs, void *const *vals, int count);

/*
 Read multiple register values.

 @uc: handle returned by uc_open()
 @rges:  array of register IDs to retrieve
 @value: pointer to array of values to hold registers
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_read_batch(uc_engine *uc, int *regs, void **vals, int count);

/*
 Write to a range of bytes in memory.

 @uc: handle returned by uc_open()
 @address: starting memory address of bytes to set.
 @bytes:   pointer to a variable containing data to be written to memory.
 @size:   size of memory to write to.

 NOTE: @bytes must be big enough to contain @size bytes.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_write(uc_engine *uc, uint64_t address, const void *bytes, size_t size);

/*
 Read a range of bytes in memory.

 @uc: handle returned by uc_open()
 @address: starting memory address of bytes to get.
 @bytes:   pointer to a variable containing data copied from memory.
 @size:   size of memory to read.

 NOTE: @bytes must be big enough to contain @size bytes.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_read(uc_engine *uc, uint64_t address, void *bytes, size_t size);

/*
 Emulate machine code in a specific duration of time.

 @uc: handle returned by uc_open()
 @begin: address where emulation starts
 @until: address where emulation stops (i.e when this address is hit)
 @timeout: duration to emulate the code (in microseconds). When this value is 0,
        we will emulate the code in infinite time, until the code is finished.
 @count: the number of instructions to be emulated. When this value is 0,
        we will emulate all the code available, until the code is finished.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_emu_start(uc_engine *uc, uint64_t begin, uint64_t until, uint64_t timeout, size_t count);

/*
 Stop emulation (which was started by uc_emu_start() API.
 This is typically called from callback functions registered via tracing APIs.

 @uc: handle returned by uc_open()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_emu_stop(uc_engine *uc);

/*
 Register callback for a hook event.
 The callback will be run when the hook event is hit.

 @uc: handle returned by uc_open()
 @hh: hook handle returned from this registration. To be used in uc_hook_del() API
 @type: hook type
 @callback: callback to be run when instruction is hit
 @user_data: user-defined data. This will be passed to callback function in its
      last argument @user_data
 @begin: start address of the area where the callback is effect (inclusive)
 @end: end address of the area where the callback is effect (inclusive)
   NOTE 1: the callback is called only if related address is in range [@begin, @end]
   NOTE 2: if @begin > @end, callback is called whenever this hook type is triggered
 @...: variable arguments (depending on @type)
   NOTE: if @type = UC_HOOK_INSN, this is the instruction ID (ex: UC_X86_INS_OUT)

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_hook_add(uc_engine *uc, uc_hook *hh, int type, void *callback,
        void *user_data, uint64_t begin, uint64_t end, ...);

/*
 Unregister (remove) a hook callback.
 This API removes the hook callback registered by uc_hook_add().
 NOTE: this should be called only when you no longer want to trace.
 After this, @hh is invalid, and nolonger usable.

 @uc: handle returned by uc_open()
 @hh: handle returned by uc_hook_add()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_hook_del(uc_engine *uc, uc_hook hh);

typedef enum uc_prot {
   UC_PROT_NONE = 0,
   UC_PROT_READ = 1,
   UC_PROT_WRITE = 2,
   UC_PROT_EXEC = 4,
   UC_PROT_ALL = 7,
} uc_prot;

/*
 Map memory in for emulation.
 This API adds a memory region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new memory region to be mapped in.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG error.
 @size: size of the new memory region to be mapped in.
    This size must be multiple of 4KB, or this will return with UC_ERR_ARG error.
 @perms: Permissions for the newly mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC,
    or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_map(uc_engine *uc, uint64_t address, size_t size, uint32_t perms);

/*
 Map existing host memory in for emulation.
 This API adds a memory region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new memory region to be mapped in.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG error.
 @size: size of the new memory region to be mapped in.
    This size must be multiple of 4KB, or this will return with UC_ERR_ARG error.
 @perms: Permissions for the newly mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC,
    or this will return with UC_ERR_ARG error.
 @ptr: pointer to host memory backing the newly mapped memory. This host memory is
    expected to be an equal or larger size than provided, and be mapped with at
    least PROT_READ | PROT_WRITE. If it is not, the resulting behavior is undefined.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_map_ptr(uc_engine *uc, uint64_t address, size_t size, uint32_t perms, void *ptr);

/*
 Unmap a region of emulation memory.
 This API deletes a memory mapping from the emulation memory space.

 @uc: handle returned by uc_open()
 @address: starting address of the memory region to be unmapped.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG error.
 @size: size of the memory region to be modified.
    This size must be multiple of 4KB, or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_unmap(uc_engine *uc, uint64_t address, size_t size);

/*
 Set memory permissions for emulation memory.
 This API changes permissions on an existing memory region.

 @uc: handle returned by uc_open()
 @address: starting address of the memory region to be modified.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG error.
 @size: size of the memory region to be modified.
    This size must be multiple of 4KB, or this will return with UC_ERR_ARG error.
 @perms: New permissions for the mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC,
    or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_protect(uc_engine *uc, uint64_t address, size_t size, uint32_t perms);

/*
 Retrieve all memory regions mapped by uc_mem_map() and uc_mem_map_ptr()
 This API allocates memory for @regions, and user must free this memory later
 by free() to avoid leaking memory.
 NOTE: memory regions may be splitted by uc_mem_unmap()

 @uc: handle returned by uc_open()
 @regions: pointer to an array of uc_mem_region struct. This is allocated by
   Unicorn, and must be freed by user later with uc_free()
 @count: pointer to number of struct uc_mem_region contained in @regions

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_regions(uc_engine *uc, uc_mem_region **regions, uint32_t *count);

/*
 Allocate a region that can be used with uc_context_{save,restore} to perform
 quick save/rollback of the CPU context, which includes registers and some
 internal metadata. Contexts may not be shared across engine instances with
 differing arches or modes.

 @uc: handle returned by uc_open()
 @context: pointer to a uc_engine*. This will be updated with the pointer to
   the new context on successful return of this function.
   Later, this allocated memory must be freed with uc_free().

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_alloc(uc_engine *uc, uc_context **context);

/*
 Free the memory allocated by uc_context_alloc & uc_mem_regions.

 @mem: memory allocated by uc_context_alloc (returned in *context), or
       by uc_mem_regions (returned in *regions)

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_free(void *mem);

/*
 Save a copy of the internal CPU context.
 This API should be used to efficiently make or update a saved copy of the
 internal CPU state.

 @uc: handle returned by uc_open()
 @context: handle returned by uc_context_alloc()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_save(uc_engine *uc, uc_context *context);

/*
 Restore the current CPU context from a saved copy.
 This API should be used to roll the CPU context back to a previous
 state saved by uc_context_save().

 @uc: handle returned by uc_open()
 @buffer: handle returned by uc_context_alloc that has been used with uc_context_save

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_restore(uc_engine *uc, uc_context *context);

#ifdef __cplusplus
}
#endif

#endif

```

`include/unicorn/x86.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_X86_H
#define UNICORN_X86_H

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// Memory-Management Register for instructions IDTR, GDTR, LDTR, TR.
// Borrow from SegmentCache in qemu/target-i386/cpu.h
typedef struct uc_x86_mmr {
    uint16_t selector;  /* not used by GDTR and IDTR */
    uint64_t base;      /* handle 32 or 64 bit CPUs */
    uint32_t limit;
    uint32_t flags;     /* not used by GDTR and IDTR */
} uc_x86_mmr;

// Model-Specific Register structure, use this with UC_X86_REG_MSR (as the register ID) in
// call to uc_reg_write/uc_reg_read() to manipulate MSRs.
typedef struct uc_x86_msr {
    uint32_t rid;   // MSR id
    uint64_t value; // MSR value
} uc_x86_msr;

// Callback function for tracing SYSCALL/SYSENTER (for uc_hook_intr())
// @user_data: user data passed to tracing APIs.
typedef void (*uc_cb_insn_syscall_t)(struct uc_struct *uc, void *user_data);

//> X86 registers
typedef enum uc_x86_reg {
	UC_X86_REG_INVALID = 0,
	UC_X86_REG_AH, UC_X86_REG_AL, UC_X86_REG_AX, UC_X86_REG_BH, UC_X86_REG_BL,
	UC_X86_REG_BP, UC_X86_REG_BPL, UC_X86_REG_BX, UC_X86_REG_CH, UC_X86_REG_CL,
	UC_X86_REG_CS, UC_X86_REG_CX, UC_X86_REG_DH, UC_X86_REG_DI, UC_X86_REG_DIL,
	UC_X86_REG_DL, UC_X86_REG_DS, UC_X86_REG_DX, UC_X86_REG_EAX, UC_X86_REG_EBP,
	UC_X86_REG_EBX, UC_X86_REG_ECX, UC_X86_REG_EDI, UC_X86_REG_EDX, UC_X86_REG_EFLAGS,
	UC_X86_REG_EIP, UC_X86_REG_EIZ, UC_X86_REG_ES, UC_X86_REG_ESI, UC_X86_REG_ESP,
	UC_X86_REG_FPSW, UC_X86_REG_FS, UC_X86_REG_GS, UC_X86_REG_IP, UC_X86_REG_RAX,
	UC_X86_REG_RBP, UC_X86_REG_RBX, UC_X86_REG_RCX, UC_X86_REG_RDI, UC_X86_REG_RDX,
	UC_X86_REG_RIP, UC_X86_REG_RIZ, UC_X86_REG_RSI, UC_X86_REG_RSP, UC_X86_REG_SI,
	UC_X86_REG_SIL, UC_X86_REG_SP, UC_X86_REG_SPL, UC_X86_REG_SS, UC_X86_REG_CR0,
	UC_X86_REG_CR1, UC_X86_REG_CR2, UC_X86_REG_CR3, UC_X86_REG_CR4, UC_X86_REG_CR5,
	UC_X86_REG_CR6, UC_X86_REG_CR7, UC_X86_REG_CR8, UC_X86_REG_CR9, UC_X86_REG_CR10,
	UC_X86_REG_CR11, UC_X86_REG_CR12, UC_X86_REG_CR13, UC_X86_REG_CR14, UC_X86_REG_CR15,
	UC_X86_REG_DR0, UC_X86_REG_DR1, UC_X86_REG_DR2, UC_X86_REG_DR3, UC_X86_REG_DR4,
	UC_X86_REG_DR5, UC_X86_REG_DR6, UC_X86_REG_DR7, UC_X86_REG_DR8, UC_X86_REG_DR9,
	UC_X86_REG_DR10, UC_X86_REG_DR11, UC_X86_REG_DR12, UC_X86_REG_DR13, UC_X86_REG_DR14,
	UC_X86_REG_DR15, UC_X86_REG_FP0, UC_X86_REG_FP1, UC_X86_REG_FP2, UC_X86_REG_FP3,
	UC_X86_REG_FP4, UC_X86_REG_FP5, UC_X86_REG_FP6, UC_X86_REG_FP7,
	UC_X86_REG_K0, UC_X86_REG_K1, UC_X86_REG_K2, UC_X86_REG_K3, UC_X86_REG_K4,
	UC_X86_REG_K5, UC_X86_REG_K6, UC_X86_REG_K7, UC_X86_REG_MM0, UC_X86_REG_MM1,
	UC_X86_REG_MM2, UC_X86_REG_MM3, UC_X86_REG_MM4, UC_X86_REG_MM5, UC_X86_REG_MM6,
	UC_X86_REG_MM7, UC_X86_REG_R8, UC_X86_REG_R9, UC_X86_REG_R10, UC_X86_REG_R11,
	UC_X86_REG_R12, UC_X86_REG_R13, UC_X86_REG_R14, UC_X86_REG_R15,
	UC_X86_REG_ST0, UC_X86_REG_ST1, UC_X86_REG_ST2, UC_X86_REG_ST3,
	UC_X86_REG_ST4, UC_X86_REG_ST5, UC_X86_REG_ST6, UC_X86_REG_ST7,
	UC_X86_REG_XMM0, UC_X86_REG_XMM1, UC_X86_REG_XMM2, UC_X86_REG_XMM3, UC_X86_REG_XMM4,
	UC_X86_REG_XMM5, UC_X86_REG_XMM6, UC_X86_REG_XMM7, UC_X86_REG_XMM8, UC_X86_REG_XMM9,
	UC_X86_REG_XMM10, UC_X86_REG_XMM11, UC_X86_REG_XMM12, UC_X86_REG_XMM13, UC_X86_REG_XMM14,
	UC_X86_REG_XMM15, UC_X86_REG_XMM16, UC_X86_REG_XMM17, UC_X86_REG_XMM18, UC_X86_REG_XMM19,
	UC_X86_REG_XMM20, UC_X86_REG_XMM21, UC_X86_REG_XMM22, UC_X86_REG_XMM23, UC_X86_REG_XMM24,
	UC_X86_REG_XMM25, UC_X86_REG_XMM26, UC_X86_REG_XMM27, UC_X86_REG_XMM28, UC_X86_REG_XMM29,
	UC_X86_REG_XMM30, UC_X86_REG_XMM31, UC_X86_REG_YMM0, UC_X86_REG_YMM1, UC_X86_REG_YMM2,
	UC_X86_REG_YMM3, UC_X86_REG_YMM4, UC_X86_REG_YMM5, UC_X86_REG_YMM6, UC_X86_REG_YMM7,
	UC_X86_REG_YMM8, UC_X86_REG_YMM9, UC_X86_REG_YMM10, UC_X86_REG_YMM11, UC_X86_REG_YMM12,
	UC_X86_REG_YMM13, UC_X86_REG_YMM14, UC_X86_REG_YMM15, UC_X86_REG_YMM16, UC_X86_REG_YMM17,
	UC_X86_REG_YMM18, UC_X86_REG_YMM19, UC_X86_REG_YMM20, UC_X86_REG_YMM21, UC_X86_REG_YMM22,
	UC_X86_REG_YMM23, UC_X86_REG_YMM24, UC_X86_REG_YMM25, UC_X86_REG_YMM26, UC_X86_REG_YMM27,
	UC_X86_REG_YMM28, UC_X86_REG_YMM29, UC_X86_REG_YMM30, UC_X86_REG_YMM31, UC_X86_REG_ZMM0,
	UC_X86_REG_ZMM1, UC_X86_REG_ZMM2, UC_X86_REG_ZMM3, UC_X86_REG_ZMM4, UC_X86_REG_ZMM5,
	UC_X86_REG_ZMM6, UC_X86_REG_ZMM7, UC_X86_REG_ZMM8, UC_X86_REG_ZMM9, UC_X86_REG_ZMM10,
	UC_X86_REG_ZMM11, UC_X86_REG_ZMM12, UC_X86_REG_ZMM13, UC_X86_REG_ZMM14, UC_X86_REG_ZMM15,
	UC_X86_REG_ZMM16, UC_X86_REG_ZMM17, UC_X86_REG_ZMM18, UC_X86_REG_ZMM19, UC_X86_REG_ZMM20,
	UC_X86_REG_ZMM21, UC_X86_REG_ZMM22, UC_X86_REG_ZMM23, UC_X86_REG_ZMM24, UC_X86_REG_ZMM25,
	UC_X86_REG_ZMM26, UC_X86_REG_ZMM27, UC_X86_REG_ZMM28, UC_X86_REG_ZMM29, UC_X86_REG_ZMM30,
	UC_X86_REG_ZMM31, UC_X86_REG_R8B, UC_X86_REG_R9B, UC_X86_REG_R10B, UC_X86_REG_R11B,
	UC_X86_REG_R12B, UC_X86_REG_R13B, UC_X86_REG_R14B, UC_X86_REG_R15B, UC_X86_REG_R8D,
	UC_X86_REG_R9D, UC_X86_REG_R10D, UC_X86_REG_R11D, UC_X86_REG_R12D, UC_X86_REG_R13D,
	UC_X86_REG_R14D, UC_X86_REG_R15D, UC_X86_REG_R8W, UC_X86_REG_R9W, UC_X86_REG_R10W,
	UC_X86_REG_R11W, UC_X86_REG_R12W, UC_X86_REG_R13W, UC_X86_REG_R14W, UC_X86_REG_R15W,
	UC_X86_REG_IDTR, UC_X86_REG_GDTR, UC_X86_REG_LDTR, UC_X86_REG_TR, UC_X86_REG_FPCW,
	UC_X86_REG_FPTAG,
    UC_X86_REG_MSR, // Model-Specific Register
    UC_X86_REG_MXCSR,
    UC_X86_REG_ENDING		// <-- mark the end of the list of registers
} uc_x86_reg;

//> X86 instructions
typedef enum uc_x86_insn {
    UC_X86_INS_INVALID = 0,

    UC_X86_INS_AAA,
    UC_X86_INS_AAD,
    UC_X86_INS_AAM,
    UC_X86_INS_AAS,
    UC_X86_INS_FABS,
    UC_X86_INS_ADC,
    UC_X86_INS_ADCX,
    UC_X86_INS_ADD,
    UC_X86_INS_ADDPD,
    UC_X86_INS_ADDPS,
    UC_X86_INS_ADDSD,
    UC_X86_INS_ADDSS,
    UC_X86_INS_ADDSUBPD,
    UC_X86_INS_ADDSUBPS,
    UC_X86_INS_FADD,
    UC_X86_INS_FIADD,
    UC_X86_INS_FADDP,
    UC_X86_INS_ADOX,
    UC_X86_INS_AESDECLAST,
    UC_X86_INS_AESDEC,
    UC_X86_INS_AESENCLAST,
    UC_X86_INS_AESENC,
    UC_X86_INS_AESIMC,
    UC_X86_INS_AESKEYGENASSIST,
    UC_X86_INS_AND,
    UC_X86_INS_ANDN,
    UC_X86_INS_ANDNPD,
    UC_X86_INS_ANDNPS,
    UC_X86_INS_ANDPD,
    UC_X86_INS_ANDPS,
    UC_X86_INS_ARPL,
    UC_X86_INS_BEXTR,
    UC_X86_INS_BLCFILL,
    UC_X86_INS_BLCI,
    UC_X86_INS_BLCIC,
    UC_X86_INS_BLCMSK,
    UC_X86_INS_BLCS,
    UC_X86_INS_BLENDPD,
    UC_X86_INS_BLENDPS,
    UC_X86_INS_BLENDVPD,
    UC_X86_INS_BLENDVPS,
    UC_X86_INS_BLSFILL,
    UC_X86_INS_BLSI,
    UC_X86_INS_BLSIC,
    UC_X86_INS_BLSMSK,
    UC_X86_INS_BLSR,
    UC_X86_INS_BOUND,
    UC_X86_INS_BSF,
    UC_X86_INS_BSR,
    UC_X86_INS_BSWAP,
    UC_X86_INS_BT,
    UC_X86_INS_BTC,
    UC_X86_INS_BTR,
    UC_X86_INS_BTS,
    UC_X86_INS_BZHI,
    UC_X86_INS_CALL,
    UC_X86_INS_CBW,
    UC_X86_INS_CDQ,
    UC_X86_INS_CDQE,
    UC_X86_INS_FCHS,
    UC_X86_INS_CLAC,
    UC_X86_INS_CLC,
    UC_X86_INS_CLD,
    UC_X86_INS_CLFLUSH,
    UC_X86_INS_CLFLUSHOPT,
    UC_X86_INS_CLGI,
    UC_X86_INS_CLI,
    UC_X86_INS_CLTS,
    UC_X86_INS_CLWB,
    UC_X86_INS_CMC,
    UC_X86_INS_CMOVA,
    UC_X86_INS_CMOVAE,
    UC_X86_INS_CMOVB,
    UC_X86_INS_CMOVBE,
    UC_X86_INS_FCMOVBE,
    UC_X86_INS_FCMOVB,
    UC_X86_INS_CMOVE,
    UC_X86_INS_FCMOVE,
    UC_X86_INS_CMOVG,
    UC_X86_INS_CMOVGE,
    UC_X86_INS_CMOVL,
    UC_X86_INS_CMOVLE,
    UC_X86_INS_FCMOVNBE,
    UC_X86_INS_FCMOVNB,
    UC_X86_INS_CMOVNE,
    UC_X86_INS_FCMOVNE,
    UC_X86_INS_CMOVNO,
    UC_X86_INS_CMOVNP,
    UC_X86_INS_FCMOVNU,
    UC_X86_INS_CMOVNS,
    UC_X86_INS_CMOVO,
    UC_X86_INS_CMOVP,
    UC_X86_INS_FCMOVU,
    UC_X86_INS_CMOVS,
    UC_X86_INS_CMP,
    UC_X86_INS_CMPPD,
    UC_X86_INS_CMPPS,
    UC_X86_INS_CMPSB,
    UC_X86_INS_CMPSD,
    UC_X86_INS_CMPSQ,
    UC_X86_INS_CMPSS,
    UC_X86_INS_CMPSW,
    UC_X86_INS_CMPXCHG16B,
    UC_X86_INS_CMPXCHG,
    UC_X86_INS_CMPXCHG8B,
    UC_X86_INS_COMISD,
    UC_X86_INS_COMISS,
    UC_X86_INS_FCOMP,
    UC_X86_INS_FCOMPI,
    UC_X86_INS_FCOMI,
    UC_X86_INS_FCOM,
    UC_X86_INS_FCOS,
    UC_X86_INS_CPUID,
    UC_X86_INS_CQO,
    UC_X86_INS_CRC32,
    UC_X86_INS_CVTDQ2PD,
    UC_X86_INS_CVTDQ2PS,
    UC_X86_INS_CVTPD2DQ,
    UC_X86_INS_CVTPD2PS,
    UC_X86_INS_CVTPS2DQ,
    UC_X86_INS_CVTPS2PD,
    UC_X86_INS_CVTSD2SI,
    UC_X86_INS_CVTSD2SS,
    UC_X86_INS_CVTSI2SD,
    UC_X86_INS_CVTSI2SS,
    UC_X86_INS_CVTSS2SD,
    UC_X86_INS_CVTSS2SI,
    UC_X86_INS_CVTTPD2DQ,
    UC_X86_INS_CVTTPS2DQ,
    UC_X86_INS_CVTTSD2SI,
    UC_X86_INS_CVTTSS2SI,
    UC_X86_INS_CWD,
    UC_X86_INS_CWDE,
    UC_X86_INS_DAA,
    UC_X86_INS_DAS,
    UC_X86_INS_DATA16,
    UC_X86_INS_DEC,
    UC_X86_INS_DIV,
    UC_X86_INS_DIVPD,
    UC_X86_INS_DIVPS,
    UC_X86_INS_FDIVR,
    UC_X86_INS_FIDIVR,
    UC_X86_INS_FDIVRP,
    UC_X86_INS_DIVSD,
    UC_X86_INS_DIVSS,
    UC_X86_INS_FDIV,
    UC_X86_INS_FIDIV,
    UC_X86_INS_FDIVP,
    UC_X86_INS_DPPD,
    UC_X86_INS_DPPS,
    UC_X86_INS_RET,
    UC_X86_INS_ENCLS,
    UC_X86_INS_ENCLU,
    UC_X86_INS_ENTER,
    UC_X86_INS_EXTRACTPS,
    UC_X86_INS_EXTRQ,
    UC_X86_INS_F2XM1,
    UC_X86_INS_LCALL,
    UC_X86_INS_LJMP,
    UC_X86_INS_FBLD,
    UC_X86_INS_FBSTP,
    UC_X86_INS_FCOMPP,
    UC_X86_INS_FDECSTP,
    UC_X86_INS_FEMMS,
    UC_X86_INS_FFREE,
    UC_X86_INS_FICOM,
    UC_X86_INS_FICOMP,
    UC_X86_INS_FINCSTP,
    UC_X86_INS_FLDCW,
    UC_X86_INS_FLDENV,
    UC_X86_INS_FLDL2E,
    UC_X86_INS_FLDL2T,
    UC_X86_INS_FLDLG2,
    UC_X86_INS_FLDLN2,
    UC_X86_INS_FLDPI,
    UC_X86_INS_FNCLEX,
    UC_X86_INS_FNINIT,
    UC_X86_INS_FNOP,
    UC_X86_INS_FNSTCW,
    UC_X86_INS_FNSTSW,
    UC_X86_INS_FPATAN,
    UC_X86_INS_FPREM,
    UC_X86_INS_FPREM1,
    UC_X86_INS_FPTAN,
    UC_X86_INS_FFREEP,
    UC_X86_INS_FRNDINT,
    UC_X86_INS_FRSTOR,
    UC_X86_INS_FNSAVE,
    UC_X86_INS_FSCALE,
    UC_X86_INS_FSETPM,
    UC_X86_INS_FSINCOS,
    UC_X86_INS_FNSTENV,
    UC_X86_INS_FXAM,
    UC_X86_INS_FXRSTOR,
    UC_X86_INS_FXRSTOR64,
    UC_X86_INS_FXSAVE,
    UC_X86_INS_FXSAVE64,
    UC_X86_INS_FXTRACT,
    UC_X86_INS_FYL2X,
    UC_X86_INS_FYL2XP1,
    UC_X86_INS_MOVAPD,
    UC_X86_INS_MOVAPS,
    UC_X86_INS_ORPD,
    UC_X86_INS_ORPS,
    UC_X86_INS_VMOVAPD,
    UC_X86_INS_VMOVAPS,
    UC_X86_INS_XORPD,
    UC_X86_INS_XORPS,
    UC_X86_INS_GETSEC,
    UC_X86_INS_HADDPD,
    UC_X86_INS_HADDPS,
    UC_X86_INS_HLT,
    UC_X86_INS_HSUBPD,
    UC_X86_INS_HSUBPS,
    UC_X86_INS_IDIV,
    UC_X86_INS_FILD,
    UC_X86_INS_IMUL,
    UC_X86_INS_IN,
    UC_X86_INS_INC,
    UC_X86_INS_INSB,
    UC_X86_INS_INSERTPS,
    UC_X86_INS_INSERTQ,
    UC_X86_INS_INSD,
    UC_X86_INS_INSW,
    UC_X86_INS_INT,
    UC_X86_INS_INT1,
    UC_X86_INS_INT3,
    UC_X86_INS_INTO,
    UC_X86_INS_INVD,
    UC_X86_INS_INVEPT,
    UC_X86_INS_INVLPG,
    UC_X86_INS_INVLPGA,
    UC_X86_INS_INVPCID,
    UC_X86_INS_INVVPID,
    UC_X86_INS_IRET,
    UC_X86_INS_IRETD,
    UC_X86_INS_IRETQ,
    UC_X86_INS_FISTTP,
    UC_X86_INS_FIST,
    UC_X86_INS_FISTP,
    UC_X86_INS_UCOMISD,
    UC_X86_INS_UCOMISS,
    UC_X86_INS_VCOMISD,
    UC_X86_INS_VCOMISS,
    UC_X86_INS_VCVTSD2SS,
    UC_X86_INS_VCVTSI2SD,
    UC_X86_INS_VCVTSI2SS,
    UC_X86_INS_VCVTSS2SD,
    UC_X86_INS_VCVTTSD2SI,
    UC_X86_INS_VCVTTSD2USI,
    UC_X86_INS_VCVTTSS2SI,
    UC_X86_INS_VCVTTSS2USI,
    UC_X86_INS_VCVTUSI2SD,
    UC_X86_INS_VCVTUSI2SS,
    UC_X86_INS_VUCOMISD,
    UC_X86_INS_VUCOMISS,
    UC_X86_INS_JAE,
    UC_X86_INS_JA,
    UC_X86_INS_JBE,
    UC_X86_INS_JB,
    UC_X86_INS_JCXZ,
    UC_X86_INS_JECXZ,
    UC_X86_INS_JE,
    UC_X86_INS_JGE,
    UC_X86_INS_JG,
    UC_X86_INS_JLE,
    UC_X86_INS_JL,
    UC_X86_INS_JMP,
    UC_X86_INS_JNE,
    UC_X86_INS_JNO,
    UC_X86_INS_JNP,
    UC_X86_INS_JNS,
    UC_X86_INS_JO,
    UC_X86_INS_JP,
    UC_X86_INS_JRCXZ,
    UC_X86_INS_JS,
    UC_X86_INS_KANDB,
    UC_X86_INS_KANDD,
    UC_X86_INS_KANDNB,
    UC_X86_INS_KANDND,
    UC_X86_INS_KANDNQ,
    UC_X86_INS_KANDNW,
    UC_X86_INS_KANDQ,
    UC_X86_INS_KANDW,
    UC_X86_INS_KMOVB,
    UC_X86_INS_KMOVD,
    UC_X86_INS_KMOVQ,
    UC_X86_INS_KMOVW,
    UC_X86_INS_KNOTB,
    UC_X86_INS_KNOTD,
    UC_X86_INS_KNOTQ,
    UC_X86_INS_KNOTW,
    UC_X86_INS_KORB,
    UC_X86_INS_KORD,
    UC_X86_INS_KORQ,
    UC_X86_INS_KORTESTB,
    UC_X86_INS_KORTESTD,
    UC_X86_INS_KORTESTQ,
    UC_X86_INS_KORTESTW,
    UC_X86_INS_KORW,
    UC_X86_INS_KSHIFTLB,
    UC_X86_INS_KSHIFTLD,
    UC_X86_INS_KSHIFTLQ,
    UC_X86_INS_KSHIFTLW,
    UC_X86_INS_KSHIFTRB,
    UC_X86_INS_KSHIFTRD,
    UC_X86_INS_KSHIFTRQ,
    UC_X86_INS_KSHIFTRW,
    UC_X86_INS_KUNPCKBW,
    UC_X86_INS_KXNORB,
    UC_X86_INS_KXNORD,
    UC_X86_INS_KXNORQ,
    UC_X86_INS_KXNORW,
    UC_X86_INS_KXORB,
    UC_X86_INS_KXORD,
    UC_X86_INS_KXORQ,
    UC_X86_INS_KXORW,
    UC_X86_INS_LAHF,
    UC_X86_INS_LAR,
    UC_X86_INS_LDDQU,
    UC_X86_INS_LDMXCSR,
    UC_X86_INS_LDS,
    UC_X86_INS_FLDZ,
    UC_X86_INS_FLD1,
    UC_X86_INS_FLD,
    UC_X86_INS_LEA,
    UC_X86_INS_LEAVE,
    UC_X86_INS_LES,
    UC_X86_INS_LFENCE,
    UC_X86_INS_LFS,
    UC_X86_INS_LGDT,
    UC_X86_INS_LGS,
    UC_X86_INS_LIDT,
    UC_X86_INS_LLDT,
    UC_X86_INS_LMSW,
    UC_X86_INS_OR,
    UC_X86_INS_SUB,
    UC_X86_INS_XOR,
    UC_X86_INS_LODSB,
    UC_X86_INS_LODSD,
    UC_X86_INS_LODSQ,
    UC_X86_INS_LODSW,
    UC_X86_INS_LOOP,
    UC_X86_INS_LOOPE,
    UC_X86_INS_LOOPNE,
    UC_X86_INS_RETF,
    UC_X86_INS_RETFQ,
    UC_X86_INS_LSL,
    UC_X86_INS_LSS,
    UC_X86_INS_LTR,
    UC_X86_INS_XADD,
    UC_X86_INS_LZCNT,
    UC_X86_INS_MASKMOVDQU,
    UC_X86_INS_MAXPD,
    UC_X86_INS_MAXPS,
    UC_X86_INS_MAXSD,
    UC_X86_INS_MAXSS,
    UC_X86_INS_MFENCE,
    UC_X86_INS_MINPD,
    UC_X86_INS_MINPS,
    UC_X86_INS_MINSD,
    UC_X86_INS_MINSS,
    UC_X86_INS_CVTPD2PI,
    UC_X86_INS_CVTPI2PD,
    UC_X86_INS_CVTPI2PS,
    UC_X86_INS_CVTPS2PI,
    UC_X86_INS_CVTTPD2PI,
    UC_X86_INS_CVTTPS2PI,
    UC_X86_INS_EMMS,
    UC_X86_INS_MASKMOVQ,
    UC_X86_INS_MOVD,
    UC_X86_INS_MOVDQ2Q,
    UC_X86_INS_MOVNTQ,
    UC_X86_INS_MOVQ2DQ,
    UC_X86_INS_MOVQ,
    UC_X86_INS_PABSB,
    UC_X86_INS_PABSD,
    UC_X86_INS_PABSW,
    UC_X86_INS_PACKSSDW,
    UC_X86_INS_PACKSSWB,
    UC_X86_INS_PACKUSWB,
    UC_X86_INS_PADDB,
    UC_X86_INS_PADDD,
    UC_X86_INS_PADDQ,
    UC_X86_INS_PADDSB,
    UC_X86_INS_PADDSW,
    UC_X86_INS_PADDUSB,
    UC_X86_INS_PADDUSW,
    UC_X86_INS_PADDW,
    UC_X86_INS_PALIGNR,
    UC_X86_INS_PANDN,
    UC_X86_INS_PAND,
    UC_X86_INS_PAVGB,
    UC_X86_INS_PAVGW,
    UC_X86_INS_PCMPEQB,
    UC_X86_INS_PCMPEQD,
    UC_X86_INS_PCMPEQW,
    UC_X86_INS_PCMPGTB,
    UC_X86_INS_PCMPGTD,
    UC_X86_INS_PCMPGTW,
    UC_X86_INS_PEXTRW,
    UC_X86_INS_PHADDSW,
    UC_X86_INS_PHADDW,
    UC_X86_INS_PHADDD,
    UC_X86_INS_PHSUBD,
    UC_X86_INS_PHSUBSW,
    UC_X86_INS_PHSUBW,
    UC_X86_INS_PINSRW,
    UC_X86_INS_PMADDUBSW,
    UC_X86_INS_PMADDWD,
    UC_X86_INS_PMAXSW,
    UC_X86_INS_PMAXUB,
    UC_X86_INS_PMINSW,
    UC_X86_INS_PMINUB,
    UC_X86_INS_PMOVMSKB,
    UC_X86_INS_PMULHRSW,
    UC_X86_INS_PMULHUW,
    UC_X86_INS_PMULHW,
    UC_X86_INS_PMULLW,
    UC_X86_INS_PMULUDQ,
    UC_X86_INS_POR,
    UC_X86_INS_PSADBW,
    UC_X86_INS_PSHUFB,
    UC_X86_INS_PSHUFW,
    UC_X86_INS_PSIGNB,
    UC_X86_INS_PSIGND,
    UC_X86_INS_PSIGNW,
    UC_X86_INS_PSLLD,
    UC_X86_INS_PSLLQ,
    UC_X86_INS_PSLLW,
    UC_X86_INS_PSRAD,
    UC_X86_INS_PSRAW,
    UC_X86_INS_PSRLD,
    UC_X86_INS_PSRLQ,
    UC_X86_INS_PSRLW,
    UC_X86_INS_PSUBB,
    UC_X86_INS_PSUBD,
    UC_X86_INS_PSUBQ,
    UC_X86_INS_PSUBSB,
    UC_X86_INS_PSUBSW,
    UC_X86_INS_PSUBUSB,
    UC_X86_INS_PSUBUSW,
    UC_X86_INS_PSUBW,
    UC_X86_INS_PUNPCKHBW,
    UC_X86_INS_PUNPCKHDQ,
    UC_X86_INS_PUNPCKHWD,
    UC_X86_INS_PUNPCKLBW,
    UC_X86_INS_PUNPCKLDQ,
    UC_X86_INS_PUNPCKLWD,
    UC_X86_INS_PXOR,
    UC_X86_INS_MONITOR,
    UC_X86_INS_MONTMUL,
    UC_X86_INS_MOV,
    UC_X86_INS_MOVABS,
    UC_X86_INS_MOVBE,
    UC_X86_INS_MOVDDUP,
    UC_X86_INS_MOVDQA,
    UC_X86_INS_MOVDQU,
    UC_X86_INS_MOVHLPS,
    UC_X86_INS_MOVHPD,
    UC_X86_INS_MOVHPS,
    UC_X86_INS_MOVLHPS,
    UC_X86_INS_MOVLPD,
    UC_X86_INS_MOVLPS,
    UC_X86_INS_MOVMSKPD,
    UC_X86_INS_MOVMSKPS,
    UC_X86_INS_MOVNTDQA,
    UC_X86_INS_MOVNTDQ,
    UC_X86_INS_MOVNTI,
    UC_X86_INS_MOVNTPD,
    UC_X86_INS_MOVNTPS,
    UC_X86_INS_MOVNTSD,
    UC_X86_INS_MOVNTSS,
    UC_X86_INS_MOVSB,
    UC_X86_INS_MOVSD,
    UC_X86_INS_MOVSHDUP,
    UC_X86_INS_MOVSLDUP,
    UC_X86_INS_MOVSQ,
    UC_X86_INS_MOVSS,
    UC_X86_INS_MOVSW,
    UC_X86_INS_MOVSX,
    UC_X86_INS_MOVSXD,
    UC_X86_INS_MOVUPD,
    UC_X86_INS_MOVUPS,
    UC_X86_INS_MOVZX,
    UC_X86_INS_MPSADBW,
    UC_X86_INS_MUL,
    UC_X86_INS_MULPD,
    UC_X86_INS_MULPS,
    UC_X86_INS_MULSD,
    UC_X86_INS_MULSS,
    UC_X86_INS_MULX,
    UC_X86_INS_FMUL,
    UC_X86_INS_FIMUL,
    UC_X86_INS_FMULP,
    UC_X86_INS_MWAIT,
    UC_X86_INS_NEG,
    UC_X86_INS_NOP,
    UC_X86_INS_NOT,
    UC_X86_INS_OUT,
    UC_X86_INS_OUTSB,
    UC_X86_INS_OUTSD,
    UC_X86_INS_OUTSW,
    UC_X86_INS_PACKUSDW,
    UC_X86_INS_PAUSE,
    UC_X86_INS_PAVGUSB,
    UC_X86_INS_PBLENDVB,
    UC_X86_INS_PBLENDW,
    UC_X86_INS_PCLMULQDQ,
    UC_X86_INS_PCMPEQQ,
    UC_X86_INS_PCMPESTRI,
    UC_X86_INS_PCMPESTRM,
    UC_X86_INS_PCMPGTQ,
    UC_X86_INS_PCMPISTRI,
    UC_X86_INS_PCMPISTRM,
    UC_X86_INS_PCOMMIT,
    UC_X86_INS_PDEP,
    UC_X86_INS_PEXT,
    UC_X86_INS_PEXTRB,
    UC_X86_INS_PEXTRD,
    UC_X86_INS_PEXTRQ,
    UC_X86_INS_PF2ID,
    UC_X86_INS_PF2IW,
    UC_X86_INS_PFACC,
    UC_X86_INS_PFADD,
    UC_X86_INS_PFCMPEQ,
    UC_X86_INS_PFCMPGE,
    UC_X86_INS_PFCMPGT,
    UC_X86_INS_PFMAX,
    UC_X86_INS_PFMIN,
    UC_X86_INS_PFMUL,
    UC_X86_INS_PFNACC,
    UC_X86_INS_PFPNACC,
    UC_X86_INS_PFRCPIT1,
    UC_X86_INS_PFRCPIT2,
    UC_X86_INS_PFRCP,
    UC_X86_INS_PFRSQIT1,
    UC_X86_INS_PFRSQRT,
    UC_X86_INS_PFSUBR,
    UC_X86_INS_PFSUB,
    UC_X86_INS_PHMINPOSUW,
    UC_X86_INS_PI2FD,
    UC_X86_INS_PI2FW,
    UC_X86_INS_PINSRB,
    UC_X86_INS_PINSRD,
    UC_X86_INS_PINSRQ,
    UC_X86_INS_PMAXSB,
    UC_X86_INS_PMAXSD,
    UC_X86_INS_PMAXUD,
    UC_X86_INS_PMAXUW,
    UC_X86_INS_PMINSB,
    UC_X86_INS_PMINSD,
    UC_X86_INS_PMINUD,
    UC_X86_INS_PMINUW,
    UC_X86_INS_PMOVSXBD,
    UC_X86_INS_PMOVSXBQ,
    UC_X86_INS_PMOVSXBW,
    UC_X86_INS_PMOVSXDQ,
    UC_X86_INS_PMOVSXWD,
    UC_X86_INS_PMOVSXWQ,
    UC_X86_INS_PMOVZXBD,
    UC_X86_INS_PMOVZXBQ,
    UC_X86_INS_PMOVZXBW,
    UC_X86_INS_PMOVZXDQ,
    UC_X86_INS_PMOVZXWD,
    UC_X86_INS_PMOVZXWQ,
    UC_X86_INS_PMULDQ,
    UC_X86_INS_PMULHRW,
    UC_X86_INS_PMULLD,
    UC_X86_INS_POP,
    UC_X86_INS_POPAW,
    UC_X86_INS_POPAL,
    UC_X86_INS_POPCNT,
    UC_X86_INS_POPF,
    UC_X86_INS_POPFD,
    UC_X86_INS_POPFQ,
    UC_X86_INS_PREFETCH,
    UC_X86_INS_PREFETCHNTA,
    UC_X86_INS_PREFETCHT0,
    UC_X86_INS_PREFETCHT1,
    UC_X86_INS_PREFETCHT2,
    UC_X86_INS_PREFETCHW,
    UC_X86_INS_PSHUFD,
    UC_X86_INS_PSHUFHW,
    UC_X86_INS_PSHUFLW,
    UC_X86_INS_PSLLDQ,
    UC_X86_INS_PSRLDQ,
    UC_X86_INS_PSWAPD,
    UC_X86_INS_PTEST,
    UC_X86_INS_PUNPCKHQDQ,
    UC_X86_INS_PUNPCKLQDQ,
    UC_X86_INS_PUSH,
    UC_X86_INS_PUSHAW,
    UC_X86_INS_PUSHAL,
    UC_X86_INS_PUSHF,
    UC_X86_INS_PUSHFD,
    UC_X86_INS_PUSHFQ,
    UC_X86_INS_RCL,
    UC_X86_INS_RCPPS,
    UC_X86_INS_RCPSS,
    UC_X86_INS_RCR,
    UC_X86_INS_RDFSBASE,
    UC_X86_INS_RDGSBASE,
    UC_X86_INS_RDMSR,
    UC_X86_INS_RDPMC,
    UC_X86_INS_RDRAND,
    UC_X86_INS_RDSEED,
    UC_X86_INS_RDTSC,
    UC_X86_INS_RDTSCP,
    UC_X86_INS_ROL,
    UC_X86_INS_ROR,
    UC_X86_INS_RORX,
    UC_X86_INS_ROUNDPD,
    UC_X86_INS_ROUNDPS,
    UC_X86_INS_ROUNDSD,
    UC_X86_INS_ROUNDSS,
    UC_X86_INS_RSM,
    UC_X86_INS_RSQRTPS,
    UC_X86_INS_RSQRTSS,
    UC_X86_INS_SAHF,
    UC_X86_INS_SAL,
    UC_X86_INS_SALC,
    UC_X86_INS_SAR,
    UC_X86_INS_SARX,
    UC_X86_INS_SBB,
    UC_X86_INS_SCASB,
    UC_X86_INS_SCASD,
    UC_X86_INS_SCASQ,
    UC_X86_INS_SCASW,
    UC_X86_INS_SETAE,
    UC_X86_INS_SETA,
    UC_X86_INS_SETBE,
    UC_X86_INS_SETB,
    UC_X86_INS_SETE,
    UC_X86_INS_SETGE,
    UC_X86_INS_SETG,
    UC_X86_INS_SETLE,
    UC_X86_INS_SETL,
    UC_X86_INS_SETNE,
    UC_X86_INS_SETNO,
    UC_X86_INS_SETNP,
    UC_X86_INS_SETNS,
    UC_X86_INS_SETO,
    UC_X86_INS_SETP,
    UC_X86_INS_SETS,
    UC_X86_INS_SFENCE,
    UC_X86_INS_SGDT,
    UC_X86_INS_SHA1MSG1,
    UC_X86_INS_SHA1MSG2,
    UC_X86_INS_SHA1NEXTE,
    UC_X86_INS_SHA1RNDS4,
    UC_X86_INS_SHA256MSG1,
    UC_X86_INS_SHA256MSG2,
    UC_X86_INS_SHA256RNDS2,
    UC_X86_INS_SHL,
    UC_X86_INS_SHLD,
    UC_X86_INS_SHLX,
    UC_X86_INS_SHR,
    UC_X86_INS_SHRD,
    UC_X86_INS_SHRX,
    UC_X86_INS_SHUFPD,
    UC_X86_INS_SHUFPS,
    UC_X86_INS_SIDT,
    UC_X86_INS_FSIN,
    UC_X86_INS_SKINIT,
    UC_X86_INS_SLDT,
    UC_X86_INS_SMSW,
    UC_X86_INS_SQRTPD,
    UC_X86_INS_SQRTPS,
    UC_X86_INS_SQRTSD,
    UC_X86_INS_SQRTSS,
    UC_X86_INS_FSQRT,
    UC_X86_INS_STAC,
    UC_X86_INS_STC,
    UC_X86_INS_STD,
    UC_X86_INS_STGI,
    UC_X86_INS_STI,
    UC_X86_INS_STMXCSR,
    UC_X86_INS_STOSB,
    UC_X86_INS_STOSD,
    UC_X86_INS_STOSQ,
    UC_X86_INS_STOSW,
    UC_X86_INS_STR,
    UC_X86_INS_FST,
    UC_X86_INS_FSTP,
    UC_X86_INS_FSTPNCE,
    UC_X86_INS_FXCH,
    UC_X86_INS_SUBPD,
    UC_X86_INS_SUBPS,
    UC_X86_INS_FSUBR,
    UC_X86_INS_FISUBR,
    UC_X86_INS_FSUBRP,
    UC_X86_INS_SUBSD,
    UC_X86_INS_SUBSS,
    UC_X86_INS_FSUB,
    UC_X86_INS_FISUB,
    UC_X86_INS_FSUBP,
    UC_X86_INS_SWAPGS,
    UC_X86_INS_SYSCALL,
    UC_X86_INS_SYSENTER,
    UC_X86_INS_SYSEXIT,
    UC_X86_INS_SYSRET,
    UC_X86_INS_T1MSKC,
    UC_X86_INS_TEST,
    UC_X86_INS_UD2,
    UC_X86_INS_FTST,
    UC_X86_INS_TZCNT,
    UC_X86_INS_TZMSK,
    UC_X86_INS_FUCOMPI,
    UC_X86_INS_FUCOMI,
    UC_X86_INS_FUCOMPP,
    UC_X86_INS_FUCOMP,
    UC_X86_INS_FUCOM,
    UC_X86_INS_UD2B,
    UC_X86_INS_UNPCKHPD,
    UC_X86_INS_UNPCKHPS,
    UC_X86_INS_UNPCKLPD,
    UC_X86_INS_UNPCKLPS,
    UC_X86_INS_VADDPD,
    UC_X86_INS_VADDPS,
    UC_X86_INS_VADDSD,
    UC_X86_INS_VADDSS,
    UC_X86_INS_VADDSUBPD,
    UC_X86_INS_VADDSUBPS,
    UC_X86_INS_VAESDECLAST,
    UC_X86_INS_VAESDEC,
    UC_X86_INS_VAESENCLAST,
    UC_X86_INS_VAESENC,
    UC_X86_INS_VAESIMC,
    UC_X86_INS_VAESKEYGENASSIST,
    UC_X86_INS_VALIGND,
    UC_X86_INS_VALIGNQ,
    UC_X86_INS_VANDNPD,
    UC_X86_INS_VANDNPS,
    UC_X86_INS_VANDPD,
    UC_X86_INS_VANDPS,
    UC_X86_INS_VBLENDMPD,
    UC_X86_INS_VBLENDMPS,
    UC_X86_INS_VBLENDPD,
    UC_X86_INS_VBLENDPS,
    UC_X86_INS_VBLENDVPD,
    UC_X86_INS_VBLENDVPS,
    UC_X86_INS_VBROADCASTF128,
    UC_X86_INS_VBROADCASTI32X4,
    UC_X86_INS_VBROADCASTI64X4,
    UC_X86_INS_VBROADCASTSD,
    UC_X86_INS_VBROADCASTSS,
    UC_X86_INS_VCMPPD,
    UC_X86_INS_VCMPPS,
    UC_X86_INS_VCMPSD,
    UC_X86_INS_VCMPSS,
    UC_X86_INS_VCOMPRESSPD,
    UC_X86_INS_VCOMPRESSPS,
    UC_X86_INS_VCVTDQ2PD,
    UC_X86_INS_VCVTDQ2PS,
    UC_X86_INS_VCVTPD2DQX,
    UC_X86_INS_VCVTPD2DQ,
    UC_X86_INS_VCVTPD2PSX,
    UC_X86_INS_VCVTPD2PS,
    UC_X86_INS_VCVTPD2UDQ,
    UC_X86_INS_VCVTPH2PS,
    UC_X86_INS_VCVTPS2DQ,
    UC_X86_INS_VCVTPS2PD,
    UC_X86_INS_VCVTPS2PH,
    UC_X86_INS_VCVTPS2UDQ,
    UC_X86_INS_VCVTSD2SI,
    UC_X86_INS_VCVTSD2USI,
    UC_X86_INS_VCVTSS2SI,
    UC_X86_INS_VCVTSS2USI,
    UC_X86_INS_VCVTTPD2DQX,
    UC_X86_INS_VCVTTPD2DQ,
    UC_X86_INS_VCVTTPD2UDQ,
    UC_X86_INS_VCVTTPS2DQ,
    UC_X86_INS_VCVTTPS2UDQ,
    UC_X86_INS_VCVTUDQ2PD,
    UC_X86_INS_VCVTUDQ2PS,
    UC_X86_INS_VDIVPD,
    UC_X86_INS_VDIVPS,
    UC_X86_INS_VDIVSD,
    UC_X86_INS_VDIVSS,
    UC_X86_INS_VDPPD,
    UC_X86_INS_VDPPS,
    UC_X86_INS_VERR,
    UC_X86_INS_VERW,
    UC_X86_INS_VEXP2PD,
    UC_X86_INS_VEXP2PS,
    UC_X86_INS_VEXPANDPD,
    UC_X86_INS_VEXPANDPS,
    UC_X86_INS_VEXTRACTF128,
    UC_X86_INS_VEXTRACTF32X4,
    UC_X86_INS_VEXTRACTF64X4,
    UC_X86_INS_VEXTRACTI128,
    UC_X86_INS_VEXTRACTI32X4,
    UC_X86_INS_VEXTRACTI64X4,
    UC_X86_INS_VEXTRACTPS,
    UC_X86_INS_VFMADD132PD,
    UC_X86_INS_VFMADD132PS,
    UC_X86_INS_VFMADDPD,
    UC_X86_INS_VFMADD213PD,
    UC_X86_INS_VFMADD231PD,
    UC_X86_INS_VFMADDPS,
    UC_X86_INS_VFMADD213PS,
    UC_X86_INS_VFMADD231PS,
    UC_X86_INS_VFMADDSD,
    UC_X86_INS_VFMADD213SD,
    UC_X86_INS_VFMADD132SD,
    UC_X86_INS_VFMADD231SD,
    UC_X86_INS_VFMADDSS,
    UC_X86_INS_VFMADD213SS,
    UC_X86_INS_VFMADD132SS,
    UC_X86_INS_VFMADD231SS,
    UC_X86_INS_VFMADDSUB132PD,
    UC_X86_INS_VFMADDSUB132PS,
    UC_X86_INS_VFMADDSUBPD,
    UC_X86_INS_VFMADDSUB213PD,
    UC_X86_INS_VFMADDSUB231PD,
    UC_X86_INS_VFMADDSUBPS,
    UC_X86_INS_VFMADDSUB213PS,
    UC_X86_INS_VFMADDSUB231PS,
    UC_X86_INS_VFMSUB132PD,
    UC_X86_INS_VFMSUB132PS,
    UC_X86_INS_VFMSUBADD132PD,
    UC_X86_INS_VFMSUBADD132PS,
    UC_X86_INS_VFMSUBADDPD,
    UC_X86_INS_VFMSUBADD213PD,
    UC_X86_INS_VFMSUBADD231PD,
    UC_X86_INS_VFMSUBADDPS,
    UC_X86_INS_VFMSUBADD213PS,
    UC_X86_INS_VFMSUBADD231PS,
    UC_X86_INS_VFMSUBPD,
    UC_X86_INS_VFMSUB213PD,
    UC_X86_INS_VFMSUB231PD,
    UC_X86_INS_VFMSUBPS,
    UC_X86_INS_VFMSUB213PS,
    UC_X86_INS_VFMSUB231PS,
    UC_X86_INS_VFMSUBSD,
    UC_X86_INS_VFMSUB213SD,
    UC_X86_INS_VFMSUB132SD,
    UC_X86_INS_VFMSUB231SD,
    UC_X86_INS_VFMSUBSS,
    UC_X86_INS_VFMSUB213SS,
    UC_X86_INS_VFMSUB132SS,
    UC_X86_INS_VFMSUB231SS,
    UC_X86_INS_VFNMADD132PD,
    UC_X86_INS_VFNMADD132PS,
    UC_X86_INS_VFNMADDPD,
    UC_X86_INS_VFNMADD213PD,
    UC_X86_INS_VFNMADD231PD,
    UC_X86_INS_VFNMADDPS,
    UC_X86_INS_VFNMADD213PS,
    UC_X86_INS_VFNMADD231PS,
    UC_X86_INS_VFNMADDSD,
    UC_X86_INS_VFNMADD213SD,
    UC_X86_INS_VFNMADD132SD,
    UC_X86_INS_VFNMADD231SD,
    UC_X86_INS_VFNMADDSS,
    UC_X86_INS_VFNMADD213SS,
    UC_X86_INS_VFNMADD132SS,
    UC_X86_INS_VFNMADD231SS,
    UC_X86_INS_VFNMSUB132PD,
    UC_X86_INS_VFNMSUB132PS,
    UC_X86_INS_VFNMSUBPD,
    UC_X86_INS_VFNMSUB213PD,
    UC_X86_INS_VFNMSUB231PD,
    UC_X86_INS_VFNMSUBPS,
    UC_X86_INS_VFNMSUB213PS,
    UC_X86_INS_VFNMSUB231PS,
    UC_X86_INS_VFNMSUBSD,
    UC_X86_INS_VFNMSUB213SD,
    UC_X86_INS_VFNMSUB132SD,
    UC_X86_INS_VFNMSUB231SD,
    UC_X86_INS_VFNMSUBSS,
    UC_X86_INS_VFNMSUB213SS,
    UC_X86_INS_VFNMSUB132SS,
    UC_X86_INS_VFNMSUB231SS,
    UC_X86_INS_VFRCZPD,
    UC_X86_INS_VFRCZPS,
    UC_X86_INS_VFRCZSD,
    UC_X86_INS_VFRCZSS,
    UC_X86_INS_VORPD,
    UC_X86_INS_VORPS,
    UC_X86_INS_VXORPD,
    UC_X86_INS_VXORPS,
    UC_X86_INS_VGATHERDPD,
    UC_X86_INS_VGATHERDPS,
    UC_X86_INS_VGATHERPF0DPD,
    UC_X86_INS_VGATHERPF0DPS,
    UC_X86_INS_VGATHERPF0QPD,
    UC_X86_INS_VGATHERPF0QPS,
    UC_X86_INS_VGATHERPF1DPD,
    UC_X86_INS_VGATHERPF1DPS,
    UC_X86_INS_VGATHERPF1QPD,
    UC_X86_INS_VGATHERPF1QPS,
    UC_X86_INS_VGATHERQPD,
    UC_X86_INS_VGATHERQPS,
    UC_X86_INS_VHADDPD,
    UC_X86_INS_VHADDPS,
    UC_X86_INS_VHSUBPD,
    UC_X86_INS_VHSUBPS,
    UC_X86_INS_VINSERTF128,
    UC_X86_INS_VINSERTF32X4,
    UC_X86_INS_VINSERTF32X8,
    UC_X86_INS_VINSERTF64X2,
    UC_X86_INS_VINSERTF64X4,
    UC_X86_INS_VINSERTI128,
    UC_X86_INS_VINSERTI32X4,
    UC_X86_INS_VINSERTI32X8,
    UC_X86_INS_VINSERTI64X2,
    UC_X86_INS_VINSERTI64X4,
    UC_X86_INS_VINSERTPS,
    UC_X86_INS_VLDDQU,
    UC_X86_INS_VLDMXCSR,
    UC_X86_INS_VMASKMOVDQU,
    UC_X86_INS_VMASKMOVPD,
    UC_X86_INS_VMASKMOVPS,
    UC_X86_INS_VMAXPD,
    UC_X86_INS_VMAXPS,
    UC_X86_INS_VMAXSD,
    UC_X86_INS_VMAXSS,
    UC_X86_INS_VMCALL,
    UC_X86_INS_VMCLEAR,
    UC_X86_INS_VMFUNC,
    UC_X86_INS_VMINPD,
    UC_X86_INS_VMINPS,
    UC_X86_INS_VMINSD,
    UC_X86_INS_VMINSS,
    UC_X86_INS_VMLAUNCH,
    UC_X86_INS_VMLOAD,
    UC_X86_INS_VMMCALL,
    UC_X86_INS_VMOVQ,
    UC_X86_INS_VMOVDDUP,
    UC_X86_INS_VMOVD,
    UC_X86_INS_VMOVDQA32,
    UC_X86_INS_VMOVDQA64,
    UC_X86_INS_VMOVDQA,
    UC_X86_INS_VMOVDQU16,
    UC_X86_INS_VMOVDQU32,
    UC_X86_INS_VMOVDQU64,
    UC_X86_INS_VMOVDQU8,
    UC_X86_INS_VMOVDQU,
    UC_X86_INS_VMOVHLPS,
    UC_X86_INS_VMOVHPD,
    UC_X86_INS_VMOVHPS,
    UC_X86_INS_VMOVLHPS,
    UC_X86_INS_VMOVLPD,
    UC_X86_INS_VMOVLPS,
    UC_X86_INS_VMOVMSKPD,
    UC_X86_INS_VMOVMSKPS,
    UC_X86_INS_VMOVNTDQA,
    UC_X86_INS_VMOVNTDQ,
    UC_X86_INS_VMOVNTPD,
    UC_X86_INS_VMOVNTPS,
    UC_X86_INS_VMOVSD,
    UC_X86_INS_VMOVSHDUP,
    UC_X86_INS_VMOVSLDUP,
    UC_X86_INS_VMOVSS,
    UC_X86_INS_VMOVUPD,
    UC_X86_INS_VMOVUPS,
    UC_X86_INS_VMPSADBW,
    UC_X86_INS_VMPTRLD,
    UC_X86_INS_VMPTRST,
    UC_X86_INS_VMREAD,
    UC_X86_INS_VMRESUME,
    UC_X86_INS_VMRUN,
    UC_X86_INS_VMSAVE,
    UC_X86_INS_VMULPD,
    UC_X86_INS_VMULPS,
    UC_X86_INS_VMULSD,
    UC_X86_INS_VMULSS,
    UC_X86_INS_VMWRITE,
    UC_X86_INS_VMXOFF,
    UC_X86_INS_VMXON,
    UC_X86_INS_VPABSB,
    UC_X86_INS_VPABSD,
    UC_X86_INS_VPABSQ,
    UC_X86_INS_VPABSW,
    UC_X86_INS_VPACKSSDW,
    UC_X86_INS_VPACKSSWB,
    UC_X86_INS_VPACKUSDW,
    UC_X86_INS_VPACKUSWB,
    UC_X86_INS_VPADDB,
    UC_X86_INS_VPADDD,
    UC_X86_INS_VPADDQ,
    UC_X86_INS_VPADDSB,
    UC_X86_INS_VPADDSW,
    UC_X86_INS_VPADDUSB,
    UC_X86_INS_VPADDUSW,
    UC_X86_INS_VPADDW,
    UC_X86_INS_VPALIGNR,
    UC_X86_INS_VPANDD,
    UC_X86_INS_VPANDND,
    UC_X86_INS_VPANDNQ,
    UC_X86_INS_VPANDN,
    UC_X86_INS_VPANDQ,
    UC_X86_INS_VPAND,
    UC_X86_INS_VPAVGB,
    UC_X86_INS_VPAVGW,
    UC_X86_INS_VPBLENDD,
    UC_X86_INS_VPBLENDMB,
    UC_X86_INS_VPBLENDMD,
    UC_X86_INS_VPBLENDMQ,
    UC_X86_INS_VPBLENDMW,
    UC_X86_INS_VPBLENDVB,
    UC_X86_INS_VPBLENDW,
    UC_X86_INS_VPBROADCASTB,
    UC_X86_INS_VPBROADCASTD,
    UC_X86_INS_VPBROADCASTMB2Q,
    UC_X86_INS_VPBROADCASTMW2D,
    UC_X86_INS_VPBROADCASTQ,
    UC_X86_INS_VPBROADCASTW,
    UC_X86_INS_VPCLMULQDQ,
    UC_X86_INS_VPCMOV,
    UC_X86_INS_VPCMPB,
    UC_X86_INS_VPCMPD,
    UC_X86_INS_VPCMPEQB,
    UC_X86_INS_VPCMPEQD,
    UC_X86_INS_VPCMPEQQ,
    UC_X86_INS_VPCMPEQW,
    UC_X86_INS_VPCMPESTRI,
    UC_X86_INS_VPCMPESTRM,
    UC_X86_INS_VPCMPGTB,
    UC_X86_INS_VPCMPGTD,
    UC_X86_INS_VPCMPGTQ,
    UC_X86_INS_VPCMPGTW,
    UC_X86_INS_VPCMPISTRI,
    UC_X86_INS_VPCMPISTRM,
    UC_X86_INS_VPCMPQ,
    UC_X86_INS_VPCMPUB,
    UC_X86_INS_VPCMPUD,
    UC_X86_INS_VPCMPUQ,
    UC_X86_INS_VPCMPUW,
    UC_X86_INS_VPCMPW,
    UC_X86_INS_VPCOMB,
    UC_X86_INS_VPCOMD,
    UC_X86_INS_VPCOMPRESSD,
    UC_X86_INS_VPCOMPRESSQ,
    UC_X86_INS_VPCOMQ,
    UC_X86_INS_VPCOMUB,
    UC_X86_INS_VPCOMUD,
    UC_X86_INS_VPCOMUQ,
    UC_X86_INS_VPCOMUW,
    UC_X86_INS_VPCOMW,
    UC_X86_INS_VPCONFLICTD,
    UC_X86_INS_VPCONFLICTQ,
    UC_X86_INS_VPERM2F128,
    UC_X86_INS_VPERM2I128,
    UC_X86_INS_VPERMD,
    UC_X86_INS_VPERMI2D,
    UC_X86_INS_VPERMI2PD,
    UC_X86_INS_VPERMI2PS,
    UC_X86_INS_VPERMI2Q,
    UC_X86_INS_VPERMIL2PD,
    UC_X86_INS_VPERMIL2PS,
    UC_X86_INS_VPERMILPD,
    UC_X86_INS_VPERMILPS,
    UC_X86_INS_VPERMPD,
    UC_X86_INS_VPERMPS,
    UC_X86_INS_VPERMQ,
    UC_X86_INS_VPERMT2D,
    UC_X86_INS_VPERMT2PD,
    UC_X86_INS_VPERMT2PS,
    UC_X86_INS_VPERMT2Q,
    UC_X86_INS_VPEXPANDD,
    UC_X86_INS_VPEXPANDQ,
    UC_X86_INS_VPEXTRB,
    UC_X86_INS_VPEXTRD,
    UC_X86_INS_VPEXTRQ,
    UC_X86_INS_VPEXTRW,
    UC_X86_INS_VPGATHERDD,
    UC_X86_INS_VPGATHERDQ,
    UC_X86_INS_VPGATHERQD,
    UC_X86_INS_VPGATHERQQ,
    UC_X86_INS_VPHADDBD,
    UC_X86_INS_VPHADDBQ,
    UC_X86_INS_VPHADDBW,
    UC_X86_INS_VPHADDDQ,
    UC_X86_INS_VPHADDD,
    UC_X86_INS_VPHADDSW,
    UC_X86_INS_VPHADDUBD,
    UC_X86_INS_VPHADDUBQ,
    UC_X86_INS_VPHADDUBW,
    UC_X86_INS_VPHADDUDQ,
    UC_X86_INS_VPHADDUWD,
    UC_X86_INS_VPHADDUWQ,
    UC_X86_INS_VPHADDWD,
    UC_X86_INS_VPHADDWQ,
    UC_X86_INS_VPHADDW,
    UC_X86_INS_VPHMINPOSUW,
    UC_X86_INS_VPHSUBBW,
    UC_X86_INS_VPHSUBDQ,
    UC_X86_INS_VPHSUBD,
    UC_X86_INS_VPHSUBSW,
    UC_X86_INS_VPHSUBWD,
    UC_X86_INS_VPHSUBW,
    UC_X86_INS_VPINSRB,
    UC_X86_INS_VPINSRD,
    UC_X86_INS_VPINSRQ,
    UC_X86_INS_VPINSRW,
    UC_X86_INS_VPLZCNTD,
    UC_X86_INS_VPLZCNTQ,
    UC_X86_INS_VPMACSDD,
    UC_X86_INS_VPMACSDQH,
    UC_X86_INS_VPMACSDQL,
    UC_X86_INS_VPMACSSDD,
    UC_X86_INS_VPMACSSDQH,
    UC_X86_INS_VPMACSSDQL,
    UC_X86_INS_VPMACSSWD,
    UC_X86_INS_VPMACSSWW,
    UC_X86_INS_VPMACSWD,
    UC_X86_INS_VPMACSWW,
    UC_X86_INS_VPMADCSSWD,
    UC_X86_INS_VPMADCSWD,
    UC_X86_INS_VPMADDUBSW,
    UC_X86_INS_VPMADDWD,
    UC_X86_INS_VPMASKMOVD,
    UC_X86_INS_VPMASKMOVQ,
    UC_X86_INS_VPMAXSB,
    UC_X86_INS_VPMAXSD,
    UC_X86_INS_VPMAXSQ,
    UC_X86_INS_VPMAXSW,
    UC_X86_INS_VPMAXUB,
    UC_X86_INS_VPMAXUD,
    UC_X86_INS_VPMAXUQ,
    UC_X86_INS_VPMAXUW,
    UC_X86_INS_VPMINSB,
    UC_X86_INS_VPMINSD,
    UC_X86_INS_VPMINSQ,
    UC_X86_INS_VPMINSW,
    UC_X86_INS_VPMINUB,
    UC_X86_INS_VPMINUD,
    UC_X86_INS_VPMINUQ,
    UC_X86_INS_VPMINUW,
    UC_X86_INS_VPMOVDB,
    UC_X86_INS_VPMOVDW,
    UC_X86_INS_VPMOVM2B,
    UC_X86_INS_VPMOVM2D,
    UC_X86_INS_VPMOVM2Q,
    UC_X86_INS_VPMOVM2W,
    UC_X86_INS_VPMOVMSKB,
    UC_X86_INS_VPMOVQB,
    UC_X86_INS_VPMOVQD,
    UC_X86_INS_VPMOVQW,
    UC_X86_INS_VPMOVSDB,
    UC_X86_INS_VPMOVSDW,
    UC_X86_INS_VPMOVSQB,
    UC_X86_INS_VPMOVSQD,
    UC_X86_INS_VPMOVSQW,
    UC_X86_INS_VPMOVSXBD,
    UC_X86_INS_VPMOVSXBQ,
    UC_X86_INS_VPMOVSXBW,
    UC_X86_INS_VPMOVSXDQ,
    UC_X86_INS_VPMOVSXWD,
    UC_X86_INS_VPMOVSXWQ,
    UC_X86_INS_VPMOVUSDB,
    UC_X86_INS_VPMOVUSDW,
    UC_X86_INS_VPMOVUSQB,
    UC_X86_INS_VPMOVUSQD,
    UC_X86_INS_VPMOVUSQW,
    UC_X86_INS_VPMOVZXBD,
    UC_X86_INS_VPMOVZXBQ,
    UC_X86_INS_VPMOVZXBW,
    UC_X86_INS_VPMOVZXDQ,
    UC_X86_INS_VPMOVZXWD,
    UC_X86_INS_VPMOVZXWQ,
    UC_X86_INS_VPMULDQ,
    UC_X86_INS_VPMULHRSW,
    UC_X86_INS_VPMULHUW,
    UC_X86_INS_VPMULHW,
    UC_X86_INS_VPMULLD,
    UC_X86_INS_VPMULLQ,
    UC_X86_INS_VPMULLW,
    UC_X86_INS_VPMULUDQ,
    UC_X86_INS_VPORD,
    UC_X86_INS_VPORQ,
    UC_X86_INS_VPOR,
    UC_X86_INS_VPPERM,
    UC_X86_INS_VPROTB,
    UC_X86_INS_VPROTD,
    UC_X86_INS_VPROTQ,
    UC_X86_INS_VPROTW,
    UC_X86_INS_VPSADBW,
    UC_X86_INS_VPSCATTERDD,
    UC_X86_INS_VPSCATTERDQ,
    UC_X86_INS_VPSCATTERQD,
    UC_X86_INS_VPSCATTERQQ,
    UC_X86_INS_VPSHAB,
    UC_X86_INS_VPSHAD,
    UC_X86_INS_VPSHAQ,
    UC_X86_INS_VPSHAW,
    UC_X86_INS_VPSHLB,
    UC_X86_INS_VPSHLD,
    UC_X86_INS_VPSHLQ,
    UC_X86_INS_VPSHLW,
    UC_X86_INS_VPSHUFB,
    UC_X86_INS_VPSHUFD,
    UC_X86_INS_VPSHUFHW,
    UC_X86_INS_VPSHUFLW,
    UC_X86_INS_VPSIGNB,
    UC_X86_INS_VPSIGND,
    UC_X86_INS_VPSIGNW,
    UC_X86_INS_VPSLLDQ,
    UC_X86_INS_VPSLLD,
    UC_X86_INS_VPSLLQ,
    UC_X86_INS_VPSLLVD,
    UC_X86_INS_VPSLLVQ,
    UC_X86_INS_VPSLLW,
    UC_X86_INS_VPSRAD,
    UC_X86_INS_VPSRAQ,
    UC_X86_INS_VPSRAVD,
    UC_X86_INS_VPSRAVQ,
    UC_X86_INS_VPSRAW,
    UC_X86_INS_VPSRLDQ,
    UC_X86_INS_VPSRLD,
    UC_X86_INS_VPSRLQ,
    UC_X86_INS_VPSRLVD,
    UC_X86_INS_VPSRLVQ,
    UC_X86_INS_VPSRLW,
    UC_X86_INS_VPSUBB,
    UC_X86_INS_VPSUBD,
    UC_X86_INS_VPSUBQ,
    UC_X86_INS_VPSUBSB,
    UC_X86_INS_VPSUBSW,
    UC_X86_INS_VPSUBUSB,
    UC_X86_INS_VPSUBUSW,
    UC_X86_INS_VPSUBW,
    UC_X86_INS_VPTESTMD,
    UC_X86_INS_VPTESTMQ,
    UC_X86_INS_VPTESTNMD,
    UC_X86_INS_VPTESTNMQ,
    UC_X86_INS_VPTEST,
    UC_X86_INS_VPUNPCKHBW,
    UC_X86_INS_VPUNPCKHDQ,
    UC_X86_INS_VPUNPCKHQDQ,
    UC_X86_INS_VPUNPCKHWD,
    UC_X86_INS_VPUNPCKLBW,
    UC_X86_INS_VPUNPCKLDQ,
    UC_X86_INS_VPUNPCKLQDQ,
    UC_X86_INS_VPUNPCKLWD,
    UC_X86_INS_VPXORD,
    UC_X86_INS_VPXORQ,
    UC_X86_INS_VPXOR,
    UC_X86_INS_VRCP14PD,
    UC_X86_INS_VRCP14PS,
    UC_X86_INS_VRCP14SD,
    UC_X86_INS_VRCP14SS,
    UC_X86_INS_VRCP28PD,
    UC_X86_INS_VRCP28PS,
    UC_X86_INS_VRCP28SD,
    UC_X86_INS_VRCP28SS,
    UC_X86_INS_VRCPPS,
    UC_X86_INS_VRCPSS,
    UC_X86_INS_VRNDSCALEPD,
    UC_X86_INS_VRNDSCALEPS,
    UC_X86_INS_VRNDSCALESD,
    UC_X86_INS_VRNDSCALESS,
    UC_X86_INS_VROUNDPD,
    UC_X86_INS_VROUNDPS,
    UC_X86_INS_VROUNDSD,
    UC_X86_INS_VROUNDSS,
    UC_X86_INS_VRSQRT14PD,
    UC_X86_INS_VRSQRT14PS,
    UC_X86_INS_VRSQRT14SD,
    UC_X86_INS_VRSQRT14SS,
    UC_X86_INS_VRSQRT28PD,
    UC_X86_INS_VRSQRT28PS,
    UC_X86_INS_VRSQRT28SD,
    UC_X86_INS_VRSQRT28SS,
    UC_X86_INS_VRSQRTPS,
    UC_X86_INS_VRSQRTSS,
    UC_X86_INS_VSCATTERDPD,
    UC_X86_INS_VSCATTERDPS,
    UC_X86_INS_VSCATTERPF0DPD,
    UC_X86_INS_VSCATTERPF0DPS,
    UC_X86_INS_VSCATTERPF0QPD,
    UC_X86_INS_VSCATTERPF0QPS,
    UC_X86_INS_VSCATTERPF1DPD,
    UC_X86_INS_VSCATTERPF1DPS,
    UC_X86_INS_VSCATTERPF1QPD,
    UC_X86_INS_VSCATTERPF1QPS,
    UC_X86_INS_VSCATTERQPD,
    UC_X86_INS_VSCATTERQPS,
    UC_X86_INS_VSHUFPD,
    UC_X86_INS_VSHUFPS,
    UC_X86_INS_VSQRTPD,
    UC_X86_INS_VSQRTPS,
    UC_X86_INS_VSQRTSD,
    UC_X86_INS_VSQRTSS,
    UC_X86_INS_VSTMXCSR,
    UC_X86_INS_VSUBPD,
    UC_X86_INS_VSUBPS,
    UC_X86_INS_VSUBSD,
    UC_X86_INS_VSUBSS,
    UC_X86_INS_VTESTPD,
    UC_X86_INS_VTESTPS,
    UC_X86_INS_VUNPCKHPD,
    UC_X86_INS_VUNPCKHPS,
    UC_X86_INS_VUNPCKLPD,
    UC_X86_INS_VUNPCKLPS,
    UC_X86_INS_VZEROALL,
    UC_X86_INS_VZEROUPPER,
    UC_X86_INS_WAIT,
    UC_X86_INS_WBINVD,
    UC_X86_INS_WRFSBASE,
    UC_X86_INS_WRGSBASE,
    UC_X86_INS_WRMSR,
    UC_X86_INS_XABORT,
    UC_X86_INS_XACQUIRE,
    UC_X86_INS_XBEGIN,
    UC_X86_INS_XCHG,
    UC_X86_INS_XCRYPTCBC,
    UC_X86_INS_XCRYPTCFB,
    UC_X86_INS_XCRYPTCTR,
    UC_X86_INS_XCRYPTECB,
    UC_X86_INS_XCRYPTOFB,
    UC_X86_INS_XEND,
    UC_X86_INS_XGETBV,
    UC_X86_INS_XLATB,
    UC_X86_INS_XRELEASE,
    UC_X86_INS_XRSTOR,
    UC_X86_INS_XRSTOR64,
    UC_X86_INS_XRSTORS,
    UC_X86_INS_XRSTORS64,
    UC_X86_INS_XSAVE,
    UC_X86_INS_XSAVE64,
    UC_X86_INS_XSAVEC,
    UC_X86_INS_XSAVEC64,
    UC_X86_INS_XSAVEOPT,
    UC_X86_INS_XSAVEOPT64,
    UC_X86_INS_XSAVES,
    UC_X86_INS_XSAVES64,
    UC_X86_INS_XSETBV,
    UC_X86_INS_XSHA1,
    UC_X86_INS_XSHA256,
    UC_X86_INS_XSTORE,
    UC_X86_INS_XTEST,
    UC_X86_INS_FDISI8087_NOP,
    UC_X86_INS_FENI8087_NOP,

    UC_X86_INS_ENDING, // mark the end of the list of insn
} uc_x86_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`linux_kernel_x64.asm`:

```asm
bits 64

%define ARCH_SET_GS 0x1001
%define ARCH_SET_FS 0x1002
%define ARCH_GET_FS 0x1003
%define ARCH_GET_GS 0x1004

%define IA32_EFER 0xc0000080
%define IA32_STAR 0xc0000081
%define IA32_LSTAR 0xc0000082

%define IA32_FS_BASE 0xc0000100
%define IA32_GS_BASE 0xc0000101

%define EINVAL 22

SYSCALL_MAX equ 325+1

times 0xc00 db 0

ENTRY:

   mov rax, 0x4141414141414141    ; replace with desired fs_base
   call set_fs_base

   ; setup syscall handler address
   lea rax, [rel syscall_handler]
   call set_lstar

   ; setup sysret and syscall segments
   mov rax, 0x230010 << 32
   call set_star

   xor rax, rax
   xor rdx, rdx
   xor rcx, rcx
   iretq

set_fs_base:
   mov ecx, IA32_FS_BASE
   call do_wrmsr
   ret

get_fs_base:
   mov ecx, IA32_FS_BASE
   call do_rdmsr
   shl rax, 32
   shrd rax, rdx, 32
   ret

set_gs_base:
   mov ecx, IA32_GS_BASE
   call do_wrmsr
   ret

get_gs_base:
   mov ecx, IA32_GS_BASE
   call do_rdmsr
   shl rax, 32
   shrd rax, rdx, 32
   ret

do_wrmsr:
   mov rdx, rax
   shr rdx, 32
   wrmsr
   ret

do_rdmsr:
   rdmsr
   ret

set_star:
   mov ecx, IA32_STAR
   call do_wrmsr
   ret

set_lstar:               ; syscall addr:
   mov ecx, IA32_LSTAR
   call do_wrmsr
   ret

syscall_handler:
   mov [rel kstack + 0x1000 - 8], rsp
   lea rsp, [rel kstack + 0x1000 - 8]
   push rcx
   push r11
   push rdi
   push rsi
   push rdx
   push r10
   push r8
   push r9
prctl:
   cmp eax, 158    ; arch_prctl
   jnz others
   cmp edi, ARCH_SET_FS
   jnz get_fs
   mov rax, rsi
   call set_fs_base
   jmp success
get_fs:
   cmp edi, ARCH_GET_FS
   jnz set_gs
   call get_fs_base
   mov [rsi], rax
   jmp success
set_gs:
   cmp edi, ARCH_SET_GS
   jnz get_gs
   mov rax, rsi
   call set_gs_base
   jmp success
get_gs:
   cmp edi, ARCH_GET_GS
   jnz einval
   call get_gs_base
   mov [rsi], rax
   jmp success
einval:
   mov eax, EINVAL
   neg rax
   jmp doret
success:
   xor rax, rax
   jmp doret
others:
   ; break here and handle all syscalls via conditional break
   nop
doret:
   pop r9
   pop r8
   pop r10
   pop rdx
   pop rsi
   pop rdi
   pop r11
   pop rcx
   pop rsp
   o64 sysret      ; force 64-bit operad size

align 0x1000
kstack:
```

`linux_x64_syscall_bpcond.py`:

```py
import idaapi

nn = idaapi.netnode("$ kernel")
sc = cpu.rax
cpu.rax = 0
#rather than building a big dict of handlers, this is
#a binary search based on system call #
if sc < 177:
   if sc < 89:
      if sc < 45:
         if sc < 23:
            if sc < 12:
               if sc < 6:
                  if sc < 3:
                     if sc == 0:     #read
                        pass
                     elif sc == 1:   #write
                        pass
                     else:  #2, open
                        msg("open(\"%s\", 0x%x, 0x%x)\n" % (idaapi.get_strlit_contents(cpu.rdi, -1, STRTYPE_C), cpu.rsi, cpu.rdx))
                        cpu.rax = 3
                  elif sc > 3:
                     if sc == 4: #stat
                        pass
                     else:   #5, fstat
                        idaapi.patch_dword(cpu.rsi, 0x4000)
                        idaapi.patch_qword(cpu.rsi + 0x20, 0x1000)
                  else:  #3, close
                     pass
               elif sc > 6:
                  if sc < 9:
                     pass
                  elif sc > 9:
                     if sc == 10:
                        pass   # 10, mprotect
                     else: # 11, munmap
                        msg("munmap(0x%x, 0x%x)\n" % (cpu.rdi, cpu.rsi))
                        rv = idaapi.idc_value_t()
                        idaapi.eval_idc_expr(rv, BADADDR, "sk3wl_munmap(0x%x, 0x%x)" % (cpu.rdi, cpu.rsi))
                        mmt = nn.altval(11)   #KERNEL_MMAP_TOP
                        if mmt == cpu.rdi:
                           nn.altset(11, mmt + cpu.rsi)   #KERNEL_MMAP_TOP
                  else: #mmap
                     msg("mmap(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n" % (cpu.rdi, cpu.rsi, cpu.rdx, cpu.r10, cpu.r8, cpu.r9))
                     mmt = nn.altval(11)   #KERNEL_MMAP_TOP
                     cpu.rax = mmt - cpu.rsi
                     mmt = nn.altset(11, cpu.rax)   #KERNEL_MMAP_TOP
                     rv = idaapi.idc_value_t()
                     idaapi.eval_idc_expr(rv, BADADDR, "sk3wl_mmap(0x%x, 0x%x, 7)" % (cpu.rax, cpu.rsi))
               else: #lstat
                  pass
            elif sc > 12:
               if sc < 17:
                  pass
               elif sc > 17:
                  if sc < 20:
                     if sc == 18: #pwrite64
                        pass
                     else:  #19 readv
                        pass
                  elif sc > 20:
                     if sc == 21: #access
                        cpu.eax = -2  #ENOENT
                        pass
                     else:  #22 pipe
                        pass
                  else: #writev
                     pass
               else: #pread64
                  pass
            else:  #brk
               cb = nn.altval(0)   #KERNEL_BRK
               if cpu.rdi == 0 or cpu.rdi == cb:
                  cpu.rax = cb
               elif cpu.rdi < cb:   #shrinking
                  rv = idaapi.idc_value_t()
                  nb = cpu.rdi & ~0xfff
                  idaapi.eval_idc_expr(rv, BADADDR, "sk3wl_munmap(0x%x, 0x%x)" % (nb, cb - nb))
                  nn.altset(0, nb)   #KERNEL_BRK
                  cpu.rax = nb
               else:  #growing
                  rv = idaapi.idc_value_t()
                  nb = (cpu.rdi + 0xfff) & ~0xfff
                  idaapi.eval_idc_expr(rv, BADADDR, "sk3wl_mmap(0x%x, 0x%x, 7)" % (cb, nb - cb))
                  nn.altset(0, nb)   #KERNEL_BRK
                  cpu.rax = nb
         elif sc > 23:
            if sc < 34:
               pass
            elif sc > 34:
               if sc < 40:
                  if sc < 37:
                     pass
                  elif sc > 37:
                     if sc == 38:  #setitimer
                        pass
                     else: #getpid
                        cpu.rax = nn.altval(1)  #KERNEL_PID
                  else: # alarm
                     pass
               elif sc > 40:
                  pass
               else: # sendfile
                  pass
            else: # pause
               pass
         else:  #select
            pass
      elif sc > 45:
         if sc < 67:
            if sc < 56:
               pass
            elif sc > 56:
               if sc < 61:
                  if sc < 58:
                     pass  #fork, returning 0 
                  elif sc > 58:
                     if sc == 59: #execve
                        msg("execve(\"%s\", ...)\n" % idc.get_strlit_contents(cpu.rdi, -1, STRTYPE_C))
                        cpu.rax = -2   # ENOENT seems reasonable since we can't do this anyway
                        return 1    #actually break
                     else: #60 exit
                        warning("process exited")
                        return 1    #actually break
                  else: #vfork
                     pass
               elif sc > 61:
                  if sc < 64:
                     if sc == 62:  #kill
                        pass
                     else:  #uname
                        for i, ch in enumerate("Linux"):
                           idaapi.patch_byte(cpu.rdi + i, ord(ch))
                        for i, ch in enumerate("ubuntu"):
                           idaapi.patch_byte(cpu.rdi + i + 0x41, ord(ch))
                        for i, ch in enumerate("4.4.0-119-generic"):
                           idaapi.patch_byte(cpu.rdi + i + 0x82, ord(ch))
                        for i, ch in enumerate("#143-Ubuntu SMP Mon Apr 2 16:08:24 UTC 2018"):
                           idaapi.patch_byte(cpu.rdi + i + 0xc3, ord(ch))
                        for i, ch in enumerate("x86_64"):
                           idaapi.patch_byte(cpu.rdi + i + 0x104, ord(ch))
                  elif sc > 64:
                     if sc == 65: #semop
                        pass
                     else:  #semctl
                        pass
                  else:  #semget
                     pass
               else:  #wait4
                  pass
            else:  #clone
               cpu.rax = -1   #make clone attempts fail
         elif sc > 67:
            if sc < 78:
               pass
            elif sc > 78:
               if sc < 83:
                  if sc < 80: #getcwd
                     default_cwd = "/home/user\x00"
                     if cpu.rsi < len(default_cwd):
                        cpu.rax = -34  #ERANGE
                     else:
                        cpu.rax = cpu.rdi
                        for i, ch in enumerate(default_cwd):
                           idaapi.patch_byte(cpu.rdi + i, ord(ch))
                  elif sc > 80:
                     if sc == 81:  #fchdir
                        pass
                     else:   #rename
                        pass 
                  else:  #chdir
                     pass
               elif sc > 83:
                  pass
               else:  #mkdir
                  pass
            else:  #getdents
               pass
         else:  #shmdt
            pass
      else:  #recvfrom
         pass
   elif sc > 89:
      if sc < 133:
         if sc < 111:
            if sc < 100:
               if sc < 94:
                  pass
               elif sc > 94:
                  if sc < 97:
                     pass
                  elif sc > 97:
                     pass
                  else: #getrlimit
                     if cpu.rdi == 3: #RLIMIT_STACK
                        idaapi.patch_qword(cpu.rsi, 0x100000)
                        idaapi.patch_qword(cpu.rsi + 8, 0x100000)
                     #implement others
               else: #lchown
                  pass
            elif sc > 100:
               if sc < 105:
                  if sc < 103:
                     if sc == 101:  #ptrace
                        pass
                     else:   #getuid
                        cpu.rax = nn.altval(3)  #KERNEL_UID
                  elif sc > 103: #getgid
                     cpu.rax = nn.altval(5)  #KERNEL_GID
                  else:  #syslog
                     pass
               elif sc > 105:
                  if sc < 108:
                     if sc == 106:  #setgid
                        pass
                     else:   #geteuid
                        cpu.rax = nn.altval(4)  #KERNEL_EUID
                  elif sc > 108:
                     if sc == 109:  #getpgid
                        pass
                     else:  #110, getppid
                        cpu.rax = nn.altval(2)  #KERNEL_PPID
                  else:  #getegid
                     cpu.rax = nn.altval(6)  #KERNEL_EGID
               else:  #setuid
                  #nn.altset(3, cpu.rax)  #KERNEL_UID
                  pass
            else:  #times
               pass
         elif sc > 111:
            pass
         else:  #getpgrp
            pass
      elif sc > 133:
         pass
      else:  #mknod
         pass
   else:  #readlink
      msg("readlink: %s\n" % idc.get_strlit_contents(cpu.rdi, -1, STRTYPE_C))
      for i, ch in enumerate("/home/user/crack_me"):
         cpu.rax = i
         if i > cpu.rdx:
            break
         idaapi.patch_byte(cpu.rsi + i, ord(ch))
elif sc > 177:
   if sc < 251:
      if sc < 214:
         pass
      elif sc > 214:
         if sc < 232:
            if sc < 223:
               if sc < 218:
                  pass
               elif sc > 218:
                  pass
               else: #set_tid_address
                  nn.altset(8, cpu.rdi)    #KERNEL_TID_ADDRESS
                  cpu.rax = nn.altval(7)   #KERNEL_TID
            elif sc > 223:
               pass
            else: #timer_settime
               pass
         elif sc > 232:
            pass
         else: #epoll_wait
            pass
      else:  #epoll_ctl_old
         pass
   elif sc > 251:
      if sc < 288:
         if sc < 269:
            pass
         elif sc > 269:
            if sc < 278:
               if sc < 273:
                  pass
               elif sc > 273:
                  pass
               else: #set_robust_list
                  nn.altset(9, cpu.rsi) # KERNEL_ROBUST_LIST
                  nn.altset(10, cpu.rdx) # KERNEL_ROBUST_LIST_SIZE
            elif sc > 278:
               pass
            else: #vmsplice
               pass
         else: #faccessat
            pass
      elif sc > 288:
         pass
      else: #accept4
         pass
   else:  #ioprio_set
      pass
else:  #get_kernel_syms
   pass
msg("syscall %d returning 0x%x\n" % (sc, cpu.rax))
return 0

```

`loader.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "loader.h"
#include <ida.hpp>
#include <llong.hpp>
#include <nalt.hpp>
#include <segment.hpp>

#include "elf_local.h"
#include "pe_local.h"
#include "teb32.h"
#include "heap.h"

#pragma pack(push, 1)
struct SegmentDescriptor {
   union {
      struct {
#if __BYTE_ORDER == __LITTLE_ENDIAN
         unsigned short limit0;
         unsigned short base0;
         unsigned char base1;
         unsigned char type:4;
         unsigned char system:1;      /* S flag */
         unsigned char dpl:2;
         unsigned char present:1;     /* P flag */
         unsigned char limit1:4;
         unsigned char avail:1;
         unsigned char is_64_code:1;  /* L flag */
         unsigned char db:1;          /* DB flag */
         unsigned char granularity:1; /* G flag */
         unsigned char base2;
#else
         unsigned char base2;
         unsigned char granularity:1; /* G flag */
         unsigned char db:1;          /* DB flag */
         unsigned char is_64_code:1;  /* L flag */
         unsigned char avail:1;
         unsigned char limit1:4;
         unsigned char present:1;     /* P flag */
         unsigned char dpl:2;
         unsigned char system:1;      /* S flag */
         unsigned char type:4;
         unsigned char base1;
         unsigned short base0;
         unsigned short limit0;
#endif
      };
      uint64_t desc;
   };
};

struct InterruptDescriptor32 {
   union {
      struct {
#if __BYTE_ORDER == __LITTLE_ENDIAN
         unsigned short offset0;
         unsigned short sel;
         unsigned char zero;
         unsigned char d:5;
         unsigned char dpl:2;
         unsigned char present:1;     /* P flag */
         unsigned short offset1;
#else
         unsigned short offset1;
         unsigned char present:1;     /* P flag */
         unsigned char dpl:2;
         unsigned char d:5;
         unsigned char zero;
         unsigned short sel;
         unsigned short offset0;
#endif
      };
      uint64_t desc;
   };
};

struct InterruptDescriptor64 {
   union {
      struct {
#if __BYTE_ORDER == __LITTLE_ENDIAN
         unsigned short offset0;
         unsigned short sel;
         unsigned char ist:3;
         unsigned char pad0:5;
         unsigned char type:4;
         unsigned char pad1:1;
         unsigned char dpl:2;
         unsigned char present:1;     /* P flag */
         unsigned short offset1;
         uint32_t offset2;
         uint32_t pad2;
#else
         uint32_t pad1;
         uint32_t offset2;
         unsigned short offset1;
         unsigned char present:1;     /* P flag */
         unsigned char dpl:2;
         unsigned char pad1:1;
         unsigned char type:4;
         unsigned char pad0:5;
         unsigned char ist:3;
         unsigned short sel;
         unsigned short offset0;
#endif
      };
      struct {
#if __BYTE_ORDER == __LITTLE_ENDIAN
         uint64_t desc0;
         uint64_t desc1;
#else
         uint64_t desc1;
         uint64_t desc0;
#endif
      };
   };
};
#pragma pack(pop)

#define SEGBASE(d) ((uint32_t)((((d).desc >> 16) & 0xffffff) | (((d).desc >> 32) & 0xff000000)))
#define SEGLIMIT(d) ((d).limit0 | (((unsigned int)(d).limit1) << 16))

#define ISROFFS(d) ((uint32_t)((((d).desc >> 32) & 0xfffff0000) | ((d).offset0)))
#define ISROFFS64(d) ((uint64_t)((((d).desc1 & 0xffffffff) << 32) | (((d).desc0 >> 32) & 0xfffff0000) | ((d).offset0)))
#define ISRSEG(d) ((d).sel)

/*    Unicorn perms                    IDA perms
0     UC_PROT_NONE                     0
1     UC_PROT_READ                     SEGPERM_EXEC
2     UC_PROT_WRITE                    SEGPERM_WRITE
3     UC_PROT_WRITE | UC_PROT_READ     SEGPERM_WRITE | SEGPERM_EXEC
4     UC_PROT_EXEC                     SEGPERM_READ
5     UC_PROT_EXEC | UC_PROT_READ      SEGPERM_READ | SEGPERM_EXEC
6     UC_PROT_EXEC | UC_PROT_WRITE     SEGPERM_READ | SEGPERM_WRITE
7     UC_PROT_ALL                      SEGPERM_READ | SEGPERM_WRITE | SEGPERM_EXEC
*/

uint32_t ida_to_uc_perms_map[] = {
   UC_PROT_NONE, UC_PROT_EXEC, UC_PROT_WRITE, UC_PROT_EXEC | UC_PROT_WRITE,
   UC_PROT_READ, UC_PROT_EXEC | UC_PROT_READ, UC_PROT_READ | UC_PROT_WRITE, UC_PROT_ALL
};

uint32_t ida_to_uc_perms_map_win[] = {
   UC_PROT_NONE, UC_PROT_EXEC, UC_PROT_READ, UC_PROT_EXEC | UC_PROT_READ,
   UC_PROT_WRITE, UC_PROT_EXEC | UC_PROT_WRITE, UC_PROT_READ | UC_PROT_WRITE, UC_PROT_ALL
};

uint32_t uc_to_ida_perms_map[] = {
   0, SEGPERM_READ, SEGPERM_WRITE, SEGPERM_READ | SEGPERM_WRITE,
   SEGPERM_EXEC, SEGPERM_EXEC | SEGPERM_READ, SEGPERM_EXEC | SEGPERM_WRITE, SEGPERM_EXEC | SEGPERM_WRITE | SEGPERM_READ
};

const char *win_xp_env[] = {
   "ALLUSERSPROFILE=C:\\Documents and Settings\\All Users",
   "APPDATA=C:\\Documents and Settings\\$USER\\Application Data",
   "CLIENTNAME=Console",
   "CommonProgramFiles=C:\\Program Files\\Common Files",
   "COMPUTERNAME=$HOST",
   "ComSpec=C:\\WINDOWS\\system32\\cmd.exe",
   "FP_NO_HOST_CHECK=NO",
   "HOMEDRIVE=C:",
   "HOMEPATH=\\Documents and Settings\\$USER",
   "LOGONSERVER=\\\\$HOST",
   "NUMBER_OF_PROCESSORS=1",
   "OS=Windows_NT",
   "Path=C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem",
   "PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH",
   "PROCESSOR_ARCHITECTURE=x86",
   "PROCESSOR_IDENTIFIER=x86 Family 6 Model 23 Stepping 10, GenuineIntel",
   "PROCESSOR_LEVEL=6",
   "PROCESSOR_REVISION=170a",
   "ProgramFiles=C:\\Program Files",
   "PROMPT=$P$G",
   "SESSIONNAME=Console",
   "SystemDrive=C:",
   "SystemRoot=C:\\WINDOWS",
   "TEMP=C:\\DOCUME~1\\$DOSUSER\\LOCALS~1\\Temp",
   "TMP=C:\\DOCUME~1\\$DOSUSER\\LOCALS~1\\Temp",
   "USERDOMAIN=$HOST",
   "USERNAME=$USER",
   "USERPROFILE=C:\\Documents and Settings\\$USER",
   "windir=C:\\WINDOWS",
   NULL
};

const char *linux_env[] = {
   "HOSTNAME=$HOST",
   "TERM=vt100",
   "SHELL=/bin/bash",
   "HISTSIZE=1000",
   "USER=$USER",
   "MAIL=/var/spool/mail/$USER",
   "PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin",
   "PWD=/home/$USER",
   "LANG=en_US.UTF-8",
   "HISTCONTROL=ignoredups",
   "SHLVL=1",
   "HOME=/home/$USER",
   "LOGNAME=$USER",
   "LESSOPEN=|/usr/bin/lesspipe.sh %s",
   "G_BROKEN_FILENAMES=1",
   "OLDPWD=/tmp",
   NULL
};

qstring *make_env(const char *env[], const char *userName, const char *hostName, bool windows = true) {
   qstring *res = new qstring();
   for (int i = 0; env[i]; i++) {
      qstring ev(env[i]);
      ev.replace("$USER", userName);
      ev.replace("$HOST", hostName);
      if (windows) {
         if (strlen(userName) > 8) {
            char buf[10];
            ::qstrncpy(buf, userName, 6);
            ::qstrncpy(buf + 6, "~1", 3);
            ev.replace("$DOSUSER", buf);
         }
         else {
            ev.replace("$DOSUSER", userName);
         }
      }
      *res += ev;
      *res += '\x00';
   }
   *res += '\x00';
   return res;
}

#define BITS_16 0
#define BITS_32 1
#define BITS_64 2

//VERY basic descriptor init function, sets many fields to user space sane defaults
static void init_intr_descriptor(InterruptDescriptor32 *desc, uint32_t offset, uint16_t sel, uint8_t dpl, uint8_t size) {
   desc->desc = 0;  //clear the descriptor
   desc->sel = sel;
   desc->offset0 = (uint16_t)offset;
   desc->offset1 = offset >> 16;
   desc->dpl = dpl;
   desc->present = 1;
   desc->d = size ? 0xe : 6;     //interrupt gate (trap gate would be 0xf : 7)
}

//VERY basic descriptor init function, sets many fields to user space sane defaults
static void init_intr_descriptor(InterruptDescriptor64 *desc, uint64_t offset, uint16_t sel, uint8_t dpl) {
   desc->desc0 = 0;  //clear the descriptor
   desc->desc1 = 0;  //clear the descriptor
   desc->sel = sel;
   desc->offset0 = (uint16_t)offset;
   desc->offset1 = (uint16_t)(offset >> 16);
   desc->offset2 = (uint32_t)(offset >> 32);
   desc->dpl = dpl;
   desc->present = 1;
   desc->type = 0xe;    //interrupt gate, trap gate is 0xf
}

//VERY basic descriptor init function, sets many fields to user space sane defaults
static void init_descriptor(SegmentDescriptor *desc, uint32_t base, uint32_t limit, uint8_t is_code, int bitness = BITS_32) {
   desc->desc = 0;  //clear the descriptor
   desc->base0 = base & 0xffff;
   desc->base1 = (base >> 16) & 0xff;
   desc->base2 = base >> 24;
   if (limit > 0xfffff) {
      //need Giant granularity
      limit >>= 12;
      desc->granularity = 1;
   }
   desc->limit0 = limit & 0xffff;
   desc->limit1 = limit >> 16;

   //some sane defaults
   desc->dpl = 3;
   desc->present = 1;
   if (is_code) {
      if (bitness == 1) {
         desc->db = 1;   //32 bit
      }
      else if (bitness == 2) {
         desc->is_64_code = 1;   //64 bit
      }
   }
   else {
      desc->db = 1;   //32 bit
   }
   desc->type = is_code ? 0xb : 3;
   desc->system = 1;  //code or data
}

#define DESC_IDX(reg) (reg >> 3)

void build_sane_gdt(sk3wldbg *uc, uint32_t fs_base, uint64_t init_pc, uint64_t user_sp) {
   uc_err err;
   uc_x86_mmr gdtr = {0, 0, 0, 0};

   uint64_t gdt_address = 0x80000000;

   //unicorn starts w/ cpl == 0

   //initial sp, this will point to iret data to get us to ring 3
   uint64_t init_sp = gdt_address + 0xf00;

   //initial pc, this will point to an iret to kick us up to ring 3
   uint64_t kernel_pc = gdt_address + 0xc00;

   int cpl0_cs = 0x10; //ring 0 cs we will iret from
   int cpl0_ss = 0x18; //ring 0 ss we will iret from
   int user_cs_32 = 0x23; //32-bit ring 3 cs we will iret to
   int user_cs_64 = 0x33; //64-bit ring 3 cs
   int user_ss = 0x2b; //ring 3 ss we will iret to, need this because we can't set a ring 3 ss directly in unicorn
   int r_ds = 0x2b;
   int r_es = 0x2b;
   int r_fs = 0x53;    //32-bit teb
   int r_gs = 0x2b;    //64-bit teb, need to configure w/ wrmsr in ring 0 before transistion to ring 3

   int max_desc = 0x53;
   int ndescs = (max_desc >> 3) + 1;
   uint32_t gdt_size = sizeof(SegmentDescriptor) * ndescs;

   // map GDT
   uint8_t *block = (uint8_t*)uc->map_mem_zero(gdt_address, gdt_address + 0x1000, UC_PROT_WRITE | UC_PROT_READ | UC_PROT_EXEC, SDB_MAP_FIXED);
   SegmentDescriptor *gdt = (SegmentDescriptor *)block;

   //store the iret opcode into memory (initial pc will point here)
   block[0xc00] = 0xcf;   //iret

   //setup stack for iret
   *(uint32_t*)(block + 0xf00) = (uint32_t)init_pc;   //initial ring 3 eip
   *(uint32_t*)(block + 0xf04) = user_cs_32;             //rpl 3 cs
   *(uint32_t*)(block + 0xf08) = (0 << 12) | 0x202;   //iitial eflags, w/ IOPL 0
   *(uint32_t*)(block + 0xf0c) = (uint32_t)user_sp;   //initial ring 3 esp
   *(uint32_t*)(block + 0xf10) = user_ss;             //rpl 3 ss

   err = uc_reg_write(uc->uc, UC_X86_REG_ESP, &init_sp);
   err = uc_reg_write(uc->uc, UC_X86_REG_EIP, &kernel_pc);

   gdtr.base = gdt_address;
   gdtr.limit = gdt_size - 1;

   //setup dpl 0 descriptor for initial rpl 0 cs
   init_descriptor(&gdt[DESC_IDX(cpl0_cs)], 0, 0xfffff000, 1);  //code segment
   gdt[DESC_IDX(cpl0_cs)].dpl = 0;  //set descriptor privilege level

   //setup dpl 3 descriptor for eventual rpl 3 cs
   init_descriptor(&gdt[DESC_IDX(user_cs_32)], 0, 0xfffff000, 1);  //code segment

   //setup dpl 3 descriptor for 64-bit
   init_descriptor(&gdt[DESC_IDX(user_cs_64)], 0, 0xfffff000, 1, BITS_64);  //code segment

   init_descriptor(&gdt[DESC_IDX(r_fs)], fs_base, 0xfff, 0);  //one page data segment simulate fs

   // when setting SS, need rpl == cpl && dpl == cpl
   // unicorn starts with cpl == 0, so we need a dpl 0 descriptor and rpl 0 selector
   // We get to ring 3 using an iret
   init_descriptor(&gdt[DESC_IDX(cpl0_ss)], 0, 0xfffff000, 0);  //ring 0 data
   gdt[DESC_IDX(cpl0_ss)].dpl = 0;  //set descriptor privilege level

   //setup dpl 3 descriptor for eventual rpl 3 ss (also ds, es, gs)
   init_descriptor(&gdt[DESC_IDX(user_ss)], 0, 0xfffff000, 0);  //data segment

   //set up a GDT BEFORE you manipulate any segment registers
   err = uc_reg_write(uc->uc, UC_X86_REG_GDTR, &gdtr);

   // when setting SS, need rpl == cpl && dpl == cpl
   // unicorn starts with cpl == 0, so we need a dpl 0 descriptor and rpl 0 selector
   // this precludes us from initially using a rpl 3 seg_reg such as 0x2b for ss
   err = uc_reg_write(uc->uc, UC_X86_REG_SS, &cpl0_ss);

   err = uc_reg_write(uc->uc, UC_X86_REG_CS, &cpl0_cs);

   //for these we must pass: if (dpl < cpl || dpl < rpl) {
   /*
    if (dpl < cpl || dpl < rpl) {
       raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);
    }
   */
   //we're fine with dpl == rpl
   err = uc_reg_write(uc->uc, UC_X86_REG_DS, &r_ds);
   err = uc_reg_write(uc->uc, UC_X86_REG_ES, &r_es);
   err = uc_reg_write(uc->uc, UC_X86_REG_FS, &r_fs);
   err = uc_reg_write(uc->uc, UC_X86_REG_GS, &r_gs);
}

//var must have been allocated using qalloc

ea_t load_pe_sections(sk3wldbg *uc, void *img, ea_t base, size_t hdr_sz, IMAGE_SECTION_HEADER_ *sections, uint32_t nsect) {
   //load the PE headers
   void *buf = uc->map_mem_zero(base, base + hdr_sz, UC_PROT_READ | UC_PROT_WRITE, SDB_MAP_FIXED);
   ea_t  max = ((base + hdr_sz) + 0xfff) & ~0xfff;
   msg("Copying bytes 0x%x:0x%x into block\n", 0, hdr_sz);
   memcpy(buf, img, hdr_sz);

   //Now load the sections
   for (uint32_t s = 0; s < nsect; s++) {
      ea_t vaddr = base + sections[s].VirtualAddress;
      uint32_t perms = sections[s].Characteristics >> 29;
      uint32_t file_off = sections[s].PointerToRawData;
      uint32_t filesz = sections[s].SizeOfRawData;
      void *block = uc->map_mem_zero(vaddr, vaddr + sections[s].VirtualSize, ida_to_uc_perms_map_win[perms], SDB_MAP_FIXED);
      if (filesz) {
         msg("Copying bytes 0x%x:0x%x into block\n", file_off, file_off + filesz);
         memcpy(block, file_off + (char*)img, filesz);
//         uc_err err = uc_mem_write(uc->uc, vaddr, file_off + (char*)img, filesz);
      }
      max = ((vaddr + sections[s].VirtualSize) + 0xfff) & ~0xfff;
   }
   return max;
}

bool loadPE64(sk3wldbg *uc, void *img, size_t /*sz*/, const char * /*args*/, uint64_t init_pc) {
   IMAGE_DOS_HEADER_ *dos = (IMAGE_DOS_HEADER_*)img;
   if (dos->e_magic != DOS_MAGIC) {
      msg("bad MZ magic\n");
      return false;
   }
   IMAGE_NT_HEADERS64_ *pe = (IMAGE_NT_HEADERS64_*)(dos->e_lfanew + (char*)dos);
   if (pe->Signature != PE_MAGIC) {
      msg("bad PE signature\n");
      return false;
   }
   if (init_pc == BADADDR) {
      init_pc = pe->OptionalHeader.AddressOfEntryPoint + pe->OptionalHeader.ImageBase;
   }
   uc->init_memmgr(0x130000 - 0x100000, 0x800000000000ll);
   IMAGE_SECTION_HEADER_ *sections = (IMAGE_SECTION_HEADER_*)(sizeof(pe->Signature) + sizeof(IMAGE_FILE_HEADER_) +
                                                              pe->FileHeader.SizeOfOptionalHeader +(char*)pe);

   ea_t image_end = load_pe_sections(uc, img, (ea_t)pe->OptionalHeader.ImageBase, pe->OptionalHeader.SizeOfHeaders,
                                     sections, pe->FileHeader.NumberOfSections);

   //PE stack
   uint32_t stack_top = 0x130000;
   uc->map_mem_zero(stack_top - 0x100000, stack_top, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC, SDB_MAP_FIXED);

   stack_top -= 16;
   uc->set_sp(stack_top);

   ea_t heap_addr = image_end + 0x1000;
   void *heap_mem = uc->map_mem_zero(heap_addr, heap_addr + 0x100000, UC_PROT_READ | UC_PROT_WRITE, SDB_MAP_FIXED);
   heap<uint64_t> *_heap = new heap<uint64_t>(heap_mem, heap_addr, 0x100000);
   _heap->malloc(30);

   return true;
}

TEB_ *create_teb_peb32(sk3wldbg *uc, PEB_ **ppeb) {
   uint32_t rnd;
   uc->getRandomBytes(&rnd, sizeof(rnd));
   rnd %= (0x100000 - 0x3000);
   rnd &= ~0xfff;
   uint32_t teb = 0x203000 + rnd;
   uint32_t peb = teb - 0x3000;
   TEB_ *pteb = (TEB_*)uc->map_mem_zero(teb, teb + sizeof(TEB_), UC_PROT_READ | UC_PROT_WRITE, SDB_MAP_FIXED);
   *ppeb = (PEB_*)uc->map_mem_zero(peb, peb + sizeof(PEB_), UC_PROT_READ | UC_PROT_WRITE, SDB_MAP_FIXED);
   pteb->Self = (TEB_p)teb;
   pteb->ProcessEnvironmentBlock = (PEB_p)peb;

   return pteb;
}

bool loadPE32(sk3wldbg *uc, void *img, size_t /*sz*/, const char * /*args*/, uint64_t init_pc) {
   IMAGE_DOS_HEADER_ *dos = (IMAGE_DOS_HEADER_*)img;
   if (dos->e_magic != DOS_MAGIC) {
      msg("bad MZ magic\n");
      return false;
   }
   IMAGE_NT_HEADERS32_ *pe = (IMAGE_NT_HEADERS32_*)(dos->e_lfanew + (char*)dos);
   if (pe->Signature != PE_MAGIC) {
      msg("bad PE signature\n");
      return false;
   }

   if (init_pc == BADADDR) {
      init_pc = pe->OptionalHeader.AddressOfEntryPoint + pe->OptionalHeader.ImageBase;
   }

   uc->init_memmgr(0x130000 - 0x100000, 0x80010000);

   PEB_ *peb;
   TEB_ *teb = create_teb_peb32(uc, &peb);
   ea_t teb_addr = (ea_t)teb->Self;
   ea_t peb_addr = (ea_t)teb->ProcessEnvironmentBlock;

//   msg("peb addr: 0x%x, peb->ImageBase addr: 0x%x, peb->Mutant addr: 0x%x\n", (uint32_t)peb, (uint32_t)&peb->ImageBaseAddress, (uint32_t)&peb->Mutant);

   IMAGE_SECTION_HEADER_ *sections = (IMAGE_SECTION_HEADER_*)(sizeof(pe->Signature) + sizeof(IMAGE_FILE_HEADER_) +
                                                              pe->FileHeader.SizeOfOptionalHeader +(char*)pe);

   ea_t image_end = load_pe_sections(uc, img, pe->OptionalHeader.ImageBase, pe->OptionalHeader.SizeOfHeaders,
                                     sections, pe->FileHeader.NumberOfSections);

   //PE stack
   uint32_t stack_top = 0x130000;
   uc->map_mem_zero(stack_top - 0x100000, stack_top, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC, SDB_MAP_FIXED);

   stack_top -= 16;
   uc->set_sp(stack_top);

   teb->StackBase = (voidp)stack_top;
   teb->StackLimit = (voidp)(stack_top - 0x100000);

   uint32_t heap_addr = (uint32_t)image_end + 0x1000;
   void *heap_mem = uc->map_mem_zero(heap_addr, heap_addr + 0x100000, UC_PROT_READ | UC_PROT_WRITE, SDB_MAP_FIXED);
   heap<uint32_t> *_heap = new heap<uint32_t>(heap_mem, heap_addr, 0x100000);

   peb->ImageBaseAddress = (voidp)pe->OptionalHeader.ImageBase;
   peb->ProcessHeap = (voidp)heap_addr;
   peb->NumberOfHeaps = 1;
   peb->MaximumNumberOfHeaps = 16;

   //the following two fields are in ntdll's bss   **** TODO build a page in ntdll to hold these
   peb->ProcessHeaps = (voidp)heap_addr;   //array of MaximumNumberOfHeaps heap pointers
                                            //first entry in this array is ProcessHeap
   peb->Ldr = (PEB_LDR_DATA_p)heap_addr;    //PEB_LDR_DATA_

   uint16_t pid;
   uc->getRandomBytes(&pid, sizeof(pid));
   pid = (pid % 3000) + 1000;

   teb->ClientId.ProcessId = pid;

   uint16_t tid;
   uc->getRandomBytes(&tid, sizeof(tid));
   tid = (tid % 3000) + 1000;

   teb->ClientId.ThreadId = tid;

   qstring *env = make_env(win_xp_env, "bgates", "apollo");

   //copy env into process heap

   delete env;

   build_sane_gdt(uc, teb_addr, init_pc, stack_top);

   return true;
}

//IDA only runs on little-endian platforms
uint16_t get_elf_16(void *pdata, bool big_endian) {
   uint16_t *d = (uint16_t*)pdata;
   return big_endian ? swap16(*d) : *d;
}

uint32_t get_elf_32(void *pdata, bool big_endian) {
   uint32_t *d = (uint32_t*)pdata;
   return big_endian ? swap32(*d) : *d;
}

uint64_t get_elf_64(void *pdata, bool big_endian) {
   uint64_t *d = (uint64_t*)pdata;
   return big_endian ? swap64((ulonglong)*d) : *d;
}

static uint64_t uc_push_8(sk3wldbg *uc, uint64_t sp, uint8_t val) {
   sp -= 1;
   uc_mem_write(uc->uc, sp, &val, 1);
   return sp;
}

static uint64_t uc_push_32(sk3wldbg *uc, uint64_t sp, uint32_t val, bool big_endian) {
   sp -= sizeof(val);
   if (big_endian) {
      val = swap32(val);
   }
   uc_mem_write(uc->uc, sp, &val, sizeof(val));
   return sp;
}

static uint64_t uc_push_64(sk3wldbg *uc, uint64_t sp, uint64_t val, bool big_endian) {
   sp -= sizeof(val);
   if (big_endian) {
      val = swap64((ulonglong)val);
   }
   uc_mem_write(uc->uc, sp, &val, sizeof(val));
   return sp;
}

static uint64_t uc_push(sk3wldbg *uc, uint64_t sp, uint64_t val, bool is_64, bool big_endian) {
   if (is_64) {
      return uc_push_64(uc, sp, val, big_endian);
   }
   return uc_push_32(uc, sp, (uint32_t)val, big_endian);
}

static uint64_t uc_push_buf(sk3wldbg *uc, uint64_t sp, void *val, uint32_t sz) {
   sp -= sz;
   uc_mem_write(uc->uc, sp, val, sz);
   return sp;
}

static uint64_t uc_push_str(sk3wldbg *uc, uint64_t sp, const char *val, bool with_null = true) {
   size_t sz = strlen(val);
   if (with_null) {
      sz++;
   }
   return uc_push_buf(uc, sp, (void*)val, (uint32_t)sz);
}

void build_sane_elf64_gdt(sk3wldbg *uc, uint64_t fs_base, uint64_t init_pc, uint64_t user_sp) {
   uc_err err;
   uc_x86_mmr gdtr = {0, 0, 0, 0};
   uc_x86_mmr idtr = {0, 0, 0, 0};

   uint64_t gdt_address = 0xFFFF800000000000;
   uint64_t idt_address = gdt_address + 0x400;

   //unicorn starts w/ cpl == 0

   //initial sp, this will point to iret data to get us to ring 3
   uint64_t init_sp = gdt_address + 0xf00;

   //initial pc, this will point to an iret to kick us up to ring 3
   uint64_t kernel_pc = gdt_address + 0xc00;

   uint64_t int3_pc = gdt_address + 0x800;

   int cpl0_cs = 0x10; //ring 0 cs we will iret from
   int cpl0_ss = 0x18; //ring 0 ss we will iret from
   int user_cs_32 = 0x23; //32-bit ring 3 cs we will iret to
   int user_cs_64 = 0x33; //64-bit ring 3 cs
   int user_ss = 0x2b; //ring 3 ss we will iret to, need this because we can't set a ring 3 ss directly in unicorn
   int r_ds = 0;
   int r_es = 0;
   int r_fs = 0;
   int r_gs = 0;       //this is 0x63 in 32-bit code used for tls info, need to set w/ wrmsr
   int intr_seg = 0x40;

   uint64_t ia32_star = cpl0_cs;
   ia32_star <<= 32;

   int max_desc = 0x53;
   int ndescs = (max_desc >> 3) + 1;
   uint32_t gdt_size = sizeof(SegmentDescriptor) * ndescs;

   // map GDT
   uint8_t *block = (uint8_t*)uc->map_mem_zero(gdt_address, gdt_address + 0x1000, UC_PROT_WRITE | UC_PROT_READ | UC_PROT_EXEC, SDB_MAP_FIXED);

   qstring sname;
   sname.sprnt("debug_%p", gdt_address);
   createNewSegment(sname.c_str(), gdt_address, 0x1000, uc_to_ida_perms_map[UC_PROT_WRITE | UC_PROT_READ | UC_PROT_EXEC], 2);

   //a small kernel space stack
   uint8_t *kstack = (uint8_t*)uc->map_mem_zero(gdt_address + 0x1000, gdt_address + 0x2000, UC_PROT_WRITE | UC_PROT_READ, SDB_MAP_FIXED);
   sname.sprnt("debug_%p", gdt_address + 0x1000);
   createNewSegment(sname.c_str(), gdt_address + 0x1000, 0x1000, uc_to_ida_perms_map[UC_PROT_WRITE | UC_PROT_READ], 2);

   SegmentDescriptor *gdt = (SegmentDescriptor *)block;
   InterruptDescriptor64 *idt = (InterruptDescriptor64 *)(block + 0x400);

   //some ring 0 code to both kick us up to ring 3 after unicorn launch and handle
   //any syscall instructions encountered in ring 3.
   char kern[] =
      "\x48\xb8\x41\x41\x41\x41\x41\x41\x41\x41\xe8\x26\x00\x00\x00\x48"
      "\x8d\x05\x80\x00\x00\x00\xe8\x70\x00\x00\x00\x48\xb8\x00\x00\x00"
      "\x00\x10\x00\x23\x00\xe8\x56\x00\x00\x00\x48\x31\xc0\x48\x31\xd2"
      "\x48\x31\xc9\x48\xcf\xb9\x00\x01\x00\xc0\xe8\x34\x00\x00\x00\xc3"
      "\xb9\x00\x01\x00\xc0\xe8\x33\x00\x00\x00\x48\xc1\xe0\x20\x48\x0f"
      "\xac\xd0\x20\xc3\xb9\x01\x01\x00\xc0\xe8\x15\x00\x00\x00\xc3\xb9"
      "\x01\x01\x00\xc0\xe8\x14\x00\x00\x00\x48\xc1\xe0\x20\x48\x0f\xac"
      "\xd0\x20\xc3\x48\x89\xc2\x48\xc1\xea\x20\x0f\x30\xc3\x0f\x32\xc3"
      "\xb9\x81\x00\x00\xc0\xe8\xe9\xff\xff\xff\xc3\xb9\x82\x00\x00\xc0"
      "\xe8\xde\xff\xff\xff\xc3\x48\x89\x25\x5b\x13\x00\x00\x48\x8d\x25"
      "\x54\x13\x00\x00\x51\x41\x53\x57\x56\x52\x41\x52\x41\x50\x41\x51"
      "\x3d\x9e\x00\x00\x00\x75\x57\x81\xff\x02\x10\x00\x00\x75\x0a\x48"
      "\x89\xf0\xe8\x6e\xff\xff\xff\xeb\x40\x81\xff\x03\x10\x00\x00\x75"
      "\x0a\xe8\x6a\xff\xff\xff\x48\x89\x06\xeb\x2e\x81\xff\x01\x10\x00"
      "\x00\x75\x0a\x48\x89\xf0\xe8\x69\xff\xff\xff\xeb\x1c\x81\xff\x04"
      "\x10\x00\x00\x75\x0a\xe8\x65\xff\xff\xff\x48\x89\x06\xeb\x0a\xb8"
      "\x16\x00\x00\x00\x48\xf7\xd8\xeb\x06\x48\x31\xc0\xeb\x01\x90\x41"
      "\x59\x41\x58\x41\x5a\x5a\x5e\x5f\x41\x5b\x59\x5c\x48\x0f\x07\x90";

   *(uint64_t*)(kern + 2) = 0x00007FFFFFEFC880;   //fs_base;

   memcpy(block + 0xc00, kern, sizeof(kern));   //setup fs msr and iret

   //setup stack for iret
   *(uint64_t*)(block + 0xf00) = init_pc;             //initial ring 3 eip
   *(uint64_t*)(block + 0xf08) = user_cs_64;          //rpl 3 cs
   *(uint64_t*)(block + 0xf10) = (0 << 12) | 0x202;   //iitial eflags, w/ IOPL 0
   *(uint64_t*)(block + 0xf18) = user_sp;             //initial ring 3 esp
   *(uint64_t*)(block + 0xf20) = user_ss;             //rpl 3 ss

   err = uc_reg_write(uc->uc, UC_X86_REG_RSP, &init_sp);
   err = uc_reg_write(uc->uc, UC_X86_REG_RIP, &kernel_pc);

   gdtr.base = gdt_address;
   gdtr.limit = gdt_size - 1;

   //setup dpl 0 descriptor for initial rpl 0 cs
   init_descriptor(&gdt[DESC_IDX(cpl0_cs)], 0, 0xfffff000, 1);  //code segment
   gdt[DESC_IDX(cpl0_cs)].dpl = 0;  //set descriptor privilege level

   //setup dpl 3 descriptor for eventual rpl 3 cs
   init_descriptor(&gdt[DESC_IDX(user_cs_32)], 0, 0xfffff000, 1);  //code segment

   //setup dpl 3 descriptor for 64-bit
   init_descriptor(&gdt[DESC_IDX(user_cs_64)], 0, 0xfffff000, 1, BITS_64);  //code segment

   // when setting SS, need rpl == cpl && dpl == cpl
   // unicorn starts with cpl == 0, so we need a dpl 0 descriptor and rpl 0 selector
   // We get to ring 3 using an iret
   init_descriptor(&gdt[DESC_IDX(cpl0_ss)], 0, 0xfffff000, 0);  //ring 0 data
   gdt[DESC_IDX(cpl0_ss)].dpl = 0;  //set descriptor privilege level

   //setup dpl 3 descriptor for eventual rpl 3 ss (also ds, es, gs)
   init_descriptor(&gdt[DESC_IDX(user_ss)], 0, 0xfffff000, 0);  //data segment

   //set up a GDT BEFORE you manipulate any segment registers
   err = uc_reg_write(uc->uc, UC_X86_REG_GDTR, &gdtr);

   //beginnings of an IDT. TODO: finish this up. Need to setup tss for this to work
   int num_intr = 16;
   uint32_t idt_size = sizeof(InterruptDescriptor64) * num_intr;
   idtr.base = idt_address;
   idtr.limit = idt_size - 1;
   init_intr_descriptor(&idt[3], int3_pc, cpl0_cs, 0);

//   err = uc_reg_write(uc->uc, UC_X86_REG_IDTR, &idtr);    //TODO: not ready for this yet

   // when setting SS, need rpl == cpl && dpl == cpl
   // unicorn starts with cpl == 0, so we need a dpl 0 descriptor and rpl 0 selector
   // this precludes us from initially using a rpl 3 seg_reg such as 0x2b for ss
   err = uc_reg_write(uc->uc, UC_X86_REG_SS, &cpl0_ss);

   err = uc_reg_write(uc->uc, UC_X86_REG_CS, &cpl0_cs);

   //for these we must pass: if (dpl < cpl || dpl < rpl) {
   /*
    if (dpl < cpl || dpl < rpl) {
       raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);
    }
   */
   //we're fine with dpl == rpl
   err = uc_reg_write(uc->uc, UC_X86_REG_DS, &r_ds);
   err = uc_reg_write(uc->uc, UC_X86_REG_ES, &r_es);
   err = uc_reg_write(uc->uc, UC_X86_REG_FS, &r_fs);
   err = uc_reg_write(uc->uc, UC_X86_REG_GS, &r_gs);
}

static uint64_t create_elf_env(sk3wldbg *uc, uint64_t sp, elf_aux *av, const char *args, bool is_64, bool big_endian) {
   char bin[256];
   qvector<uint64_t> env;
   qvector<uint64_t> argv;
   qvector<qstring> arguments;
   ssize_t bin_len = get_root_filename(bin, sizeof(bin));
   sp = uc_push(uc, sp, 0, is_64, big_endian);
   sp = uc_push_str(uc, sp, bin);
   sp = uc_push_str(uc, sp, "_=./", false);
   uint64_t at_execfn = sp + 2;
   env.push_back(sp);
   sp = uc_push_str(uc, sp, "HOME=/home/user");
   env.push_back(sp);
   sp = uc_push_str(uc, sp, "PWD=/home/user");
   env.push_back(sp);
   sp = uc_push_str(uc, sp, "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin");
   env.push_back(sp);
   sp = uc_push_str(uc, sp, "SHELL=/bin/bash");
   env.push_back(sp);

   qstring argv_0 = "./";
   argv_0 += bin;
   arguments.push_back(argv_0);
   const char *p1 = args;
   while (true) {
      while (isspace(*p1)) p1++;
      qstring arg;
      if (*p1) {
         char quote = 0;
         if (*p1 == '"' || *p1 == '\'') {
            quote = *p1++;
         }
         while (*p1) {
            if (*p1 == '\\') {
               //need better escape handling, only handling escaped quotes for now
               p1++;
               if (*p1 == 0) {
                  p1--;
               }
            }
            else if (quote) {
               if (*p1 == quote) {
                  p1++;
                  break;
               }
            }
            else if (isspace(*p1)) {
               break;
            }
            arg += *p1++;
         }
         if (arg.length() > 0) {
            arguments.push_back(arg);
         }
      }
      else {
         break;
      }
   }

   while (arguments.size() > 0) {
      qstring &a = arguments.back();
      sp = uc_push_str(uc, sp, a.c_str());
      argv.push_back(sp);
      arguments.pop_back();
   }

   sp &= is_64 ? ~7 : ~3;   //align sp to 4 or 8 bytes

   sp = uc_push_str(uc, sp, "x86_64");
   uint64_t at_platform = sp;
   uint8_t at_random_buf[16];
   uc->getRandomBytes(at_random_buf, sizeof(at_random_buf));
   sp = uc_push_buf(uc, sp, at_random_buf, sizeof(at_random_buf));
   uint64_t at_random = sp;

   sp &= is_64 ? ~7 : ~3;   //align sp to 4 or 8 bytes

   //need to build an AUX vector here
   qvector<uint64_t> aux;
   aux.push_back(_AT_SYSINFO_EHDR);
   aux.push_back(av->vdso);

   aux.push_back(_AT_HWCAP);
   aux.push_back(0xfabfbff);

   aux.push_back(_AT_PAGESZ);
   aux.push_back(0x1000);

   aux.push_back(_AT_CLKTCK);
   aux.push_back(0x64);

   aux.push_back(_AT_PHDR);
   aux.push_back(av->phdr);

   aux.push_back(_AT_PHENT);
   aux.push_back(av->phent);

   aux.push_back(_AT_PHNUM);
   aux.push_back(av->phnum);

   aux.push_back(_AT_BASE);      //base address of ELF interpreter (ld-linux)
   aux.push_back(0);

   aux.push_back(_AT_FLAGS);
   aux.push_back(0);

   aux.push_back(_AT_ENTRY);
   aux.push_back(av->entry);

   aux.push_back(_AT_UID);
   aux.push_back(av->uid);

   aux.push_back(_AT_EUID);
   aux.push_back(av->euid);

   aux.push_back(_AT_GID);
   aux.push_back(av->gid);

   aux.push_back(_AT_EGID);
   aux.push_back(av->egid);

   aux.push_back(_AT_SECURE);
   aux.push_back(0);

   aux.push_back(_AT_RANDOM);
   aux.push_back(at_random);

   aux.push_back(_AT_EXECFN);
   aux.push_back(at_execfn);

   aux.push_back(_AT_PLATFORM);
   aux.push_back(at_platform);

   aux.push_back(_AT_NULL);  //AT_NULL entry
   aux.push_back(0);  //AT_NULL value

   for (int i = aux.size(); i > 0; i--) {
      sp = uc_push(uc, sp, aux[i - 1], is_64, big_endian);
   }

   //null terminate envp array
   sp = uc_push(uc, sp, 0, is_64, big_endian);
   //push envp pointers
   for (qvector<uint64_t>::iterator i = env.begin(); i != env.end(); i++) {
      sp = uc_push(uc, sp, *i, is_64, big_endian);
   }

   //null terminate argv array
   sp = uc_push(uc, sp, 0, is_64, big_endian);
   //remember argc
   uint32_t argc = (uint32_t)argv.size();

   //push argv pointers
   for (qvector<uint64_t>::iterator i = argv.begin(); i != argv.end(); i++) {
      sp = uc_push(uc, sp, *i, is_64, big_endian);
   }
   //push argc
   sp = uc_push(uc, sp, argc, is_64, big_endian);

   return sp;
}

bool loadElf64(sk3wldbg *uc, void *img, uint64_t sz, const char *args, uint64_t init_pc) {
   Elf64_Ehdr *elf = (Elf64_Ehdr*)img;
   uint32_t exec_stack = UC_PROT_EXEC;
   bool big_endian = false;

   if (memcmp(elf->e_ident, "\x7f" "ELF", 4) != 0) {
      msg("bad ELF magic: 0x%x\n", *(uint32_t*)elf->e_ident);
      return false;
   }
   if (elf->e_ident[EI_DATA] == 2) {
      big_endian = true;
   }
   uint64_t e_phoff = get_elf_64(&elf->e_phoff, big_endian);
   if (e_phoff > (sz - sizeof(Elf64_Phdr))) {
      msg("bad e_phoff\n");
      return false;
   }

   if (init_pc == BADADDR) {
      init_pc = elf->e_entry;
   }

   Elf64_Phdr *phdr = (Elf64_Phdr*)(e_phoff + (char*)img);
   Elf64_Phdr *h = phdr;
   uint16_t e_phnum = get_elf_16(&elf->e_phnum, big_endian);

   //check for execstack so we can map the stack first
   //also find base address of binary
   uint64_t elf_base = 0xffffffffffffffffll;
   for (uint16_t i = 0; i < e_phnum; i++, h++) {
      uint32_t p_type = get_elf_32(&h->p_type, big_endian);
      uint32_t p_flags = get_elf_32(&h->p_flags, big_endian);
      if (p_type == PT_GNU_STACK) {
         if ((p_flags & PF_X) == 0) {
            //stack marked NX
            exec_stack = 0;
         }
      }
      else if (p_type == PT_LOAD) {
         uint64_t p_vaddr = get_elf_64(&phdr->p_vaddr, big_endian) & ~0xfff;
         if (p_vaddr < elf_base) {
            elf_base = p_vaddr;
         }
      }
   }
   //ELF stack
   uint64_t stack_max = 0x7ffffffff000ll;
   uint64_t stack_min = 0x7ffffffff000ll - 0x100000;
   uint64_t fs_base = stack_min - 0x3000;
   uint64_t vdso_base = stack_min - 0x4000;
   uc->init_memmgr(0, 0xffff800000002000);  //allow mapping zero page
   uc->map_mem_zero(stack_min, stack_max, UC_PROT_READ | UC_PROT_WRITE | exec_stack);
   msg("elf_fs mapped to %p\n", fs_base);
   uint8_t *elf_fs = (uint8_t*)uc->map_mem_zero(fs_base, fs_base + 0x2000, UC_PROT_READ | UC_PROT_WRITE, SDB_MAP_FIXED);

   uint8_t *vdso = (uint8_t*)uc->map_mem_zero(vdso_base, vdso_base + 0x1000, UC_PROT_READ | UC_PROT_EXEC, SDB_MAP_FIXED);

   elf_aux av;
   av.entry = get_elf_64(&elf->e_entry, big_endian);
   av.vdso = vdso_base;
   av.phdr = elf_base + e_phoff;
   av.phent = get_elf_16(&elf->e_phentsize, big_endian);
   av.phnum = e_phnum;
   av.uid = 1000;
   av.euid = 1000;
   av.gid = 1000;
   av.egid = 1000;

   uint64_t stack_top = create_elf_env(uc, stack_max, &av, args, true, big_endian);
   uc->set_sp(stack_top);

   uc->getRandomBytes(elf_fs + 0x29, 7);   //canary, low byte remains 0
   build_sane_elf64_gdt(uc, fs_base, init_pc, stack_top);

   uint64_t brk = 0;
   for (uint16_t i = 0; i < e_phnum; i++) {
      uint32_t p_type = get_elf_32(&phdr->p_type, big_endian);
      uint32_t p_flags = get_elf_32(&phdr->p_flags, big_endian);
      msg("phdr->p_type: %d\n", p_type);
      if (p_type == PT_LOAD) {
         uint64_t p_vaddr = get_elf_64(&phdr->p_vaddr, big_endian);
         uint64_t p_memsz = get_elf_64(&phdr->p_memsz, big_endian);
         uint64_t p_offset = get_elf_64(&phdr->p_offset, big_endian);
         uint64_t p_filesz = get_elf_64(&phdr->p_filesz, big_endian);
         brk = (p_vaddr + p_memsz + 0xfff) & ~0xfff;
/*
         uint64_t begin = p_vaddr & ~0xfff;
         uint64_t end = (p_vaddr + p_memsz + 0xfff) & ~0xfff;
*/
         msg("ELF64 loader mapping %p bytes at %p, from file offset %p\n",
               (uint64_t)p_memsz, (uint64_t)p_vaddr, (uint64_t)p_offset);
         void *block = uc->map_mem_zero(p_vaddr & ~0xfff, p_vaddr + p_memsz, ida_to_uc_perms_map[p_flags & 7], SDB_MAP_FIXED);
         uint64_t endoff = p_offset + p_filesz;
         uint64_t offset = p_offset & ~0xfff;
         if ((p_flags & PF_W) == 0) { //not writeable, assume entire page is mmapped
            endoff = (endoff + 0xfff) & ~0xfff;
         }
         if (endoff > sz) {
            endoff = sz;
         }
         msg("Copying bytes %p:%p into block\n", (uint64_t)offset, (uint64_t)endoff);
         memcpy(block, offset + (char*)img, (size_t)(endoff - offset));
/*
         uc_err err = uc_mem_write(uc->uc, begin, offset + (char*)img, (size_t)(endoff - offset));
         if (err != UC_ERR_OK) {
            msg("uc_mem_write failed with error: %d\n", err);
         }
*/
      }
      phdr++;
   }

   netnode kernel_nn("$ kernel", 0, true);
   kernel_nn.altset(KERNEL_BRK, (nodeidx_t)brk);
   kernel_nn.altset(KERNEL_MMAP_TOP, (nodeidx_t)vdso_base);

   return true;
}

bool loadElf32(sk3wldbg *uc, void *img, size_t sz, const char *args, uint64_t init_pc) {
   Elf32_Ehdr *elf = (Elf32_Ehdr*)img;
   uint32_t exec_stack = UC_PROT_EXEC;
   bool big_endian = false;

   if (memcmp(elf->e_ident, "\x7f" "ELF", 4) != 0 && memcmp(elf->e_ident, "\x7f" "CGC", 4) != 0) {
      msg("bad ELF magic: 0x%x\n", *(uint32_t*)elf->e_ident);
      return false;
   }
   if (elf->e_ident[EI_DATA] == 2) {
      big_endian = true;
   }
   uint32_t e_phoff = get_elf_32(&elf->e_phoff, big_endian);
   if (e_phoff > (sz - sizeof(Elf32_Phdr))) {
      msg("bad e_phoff\n");
      return false;
   }

   if (init_pc == BADADDR) {
      init_pc = elf->e_entry;
   }

   Elf32_Phdr *phdr = (Elf32_Phdr*)(e_phoff + (char*)img);
   Elf32_Phdr *h = phdr;
   uint16_t e_phnum = get_elf_16(&elf->e_phnum, big_endian);

   uint64_t elf_base = 0xffffffffffffffff;
   //check for execstack so we can map the stack first
   for (uint16_t i = 0; i < e_phnum; i++, h++) {
      uint32_t p_type = get_elf_32(&h->p_type, big_endian);
      uint32_t p_flags = get_elf_32(&h->p_flags, big_endian);
      if (p_type == PT_GNU_STACK) {
         if ((p_flags & PF_X) == 0) {
            //stack marked NX
            exec_stack = 0;
         }
      }
      else if (p_type == PT_LOAD) {
         uint64_t p_vaddr = get_elf_32(&phdr->p_vaddr, big_endian) & ~0xfff;
         if (p_vaddr < elf_base) {
            elf_base = p_vaddr;
         }
      }
   }
   //ELF stack
   uint32_t stack_top = 0xffffe000;
   uint32_t stack_min = stack_top - 0x100000;
   uint32_t fs_base = stack_min - 0x3000;
   uint32_t vdso_base = stack_min - 0x4000;
   uc->init_memmgr(0, stack_top);   //allow mapping zero page
   uc->map_mem_zero(stack_min, stack_top, UC_PROT_READ | UC_PROT_WRITE | exec_stack);

   uint8_t *vdso = (uint8_t*)uc->map_mem_zero(vdso_base, vdso_base + 0x1000, UC_PROT_READ | UC_PROT_EXEC, SDB_MAP_FIXED);

   elf_aux av;
   av.entry = get_elf_32(&elf->e_entry, big_endian);
   av.vdso = vdso_base;
   av.phdr = elf_base + e_phoff;
   av.phent = get_elf_16(&elf->e_phentsize, big_endian);
   av.phnum = e_phnum;
   av.uid = 1000;
   av.euid = 1000;
   av.gid = 1000;
   av.egid = 1000;

   stack_top = (uint32_t)create_elf_env(uc, stack_top, &av, args, false, big_endian);
   uc->set_sp(stack_top);

   uint32_t brk = 0;
   for (uint16_t i = 0; i < e_phnum; i++) {
      uint32_t p_type = get_elf_32(&phdr->p_type, big_endian);
      uint32_t p_flags = get_elf_32(&phdr->p_flags, big_endian);
      msg("phdr->p_type: %d\n", p_type);
      if (p_type == PT_LOAD) {
         uint32_t p_vaddr = get_elf_32(&phdr->p_vaddr, big_endian);
         uint32_t p_memsz = get_elf_32(&phdr->p_memsz, big_endian);
         uint32_t p_offset = get_elf_32(&phdr->p_offset, big_endian);
         uint32_t p_filesz = get_elf_32(&phdr->p_filesz, big_endian);
         brk = (p_vaddr + p_memsz + 0xfff) & ~0xfff;

         msg("ELF32 loader mapping %p bytes at %p, from file offset %p\n",
               (uint64_t)p_memsz, (uint64_t)p_vaddr, (uint64_t)p_offset);
         void *block = uc->map_mem_zero(p_vaddr & ~0xfff, p_vaddr + p_memsz, ida_to_uc_perms_map[p_flags & 7], SDB_MAP_FIXED);
         uint64_t endoff = p_offset + p_filesz;
         uint64_t offset = p_offset & ~0xfff;
         if ((p_flags & PF_W) == 0) { //not writeable, assume entire page is mmapped
            endoff = (endoff + 0xfff) & ~0xfff;
         }
         if (endoff > sz) {
            endoff = sz;
         }
         msg("Copying bytes %p:%p into block\n", (uint64_t)offset, (uint64_t)endoff);
         memcpy(block, offset + (char*)img, (size_t)(endoff - offset));

/*
         uc_err err = uc_mem_write(uc->uc, begin, offset + (char*)img, endoff - offset);
         if (err != UC_ERR_OK) {
            msg("uc_mem_write failed with error: %d\n", err);
         }
*/
      }
      phdr++;
   }

   netnode kernel_nn("$ kernel", 0, true);
   kernel_nn.altset(KERNEL_BRK, (nodeidx_t)brk);
   kernel_nn.altset(KERNEL_MMAP_TOP, (nodeidx_t)vdso_base);

   return true;
}

bool loadImage(sk3wldbg *uc, void *img, size_t sz, const char *args, uint64_t init_pc) {
   bool result = false;
   switch (uc->filetype) {
      case f_PE:
         if (inf.lflags & LFLG_64BIT) {
            msg("loadPE64\n");
            result = loadPE64(uc, img, sz, args, init_pc);
         }
         else {
            msg("loadPE32\n");
            result = loadPE32(uc, img, sz, args, init_pc);
         }
         break;
      case f_ELF: {
         if (inf.lflags & LFLG_64BIT) {
            msg("loadElf64\n");
            result = loadElf64(uc, img, (uint64_t)sz, args, init_pc);
         }
         else {
            msg("loadElf32\n");
            result = loadElf32(uc, img, sz, args, init_pc);
         }
         netnode kernel_nn("$ kernel", 0, true);
         kernel_nn.altset(KERNEL_UID, 1000);
         kernel_nn.altset(KERNEL_EUID, 1000);
         kernel_nn.altset(KERNEL_GID, 1000);
         kernel_nn.altset(KERNEL_EGID, 1000);
         kernel_nn.altset(KERNEL_PID, 1234);
         kernel_nn.altset(KERNEL_PPID, 1232);
         kernel_nn.altset(KERNEL_TID, 54321);
         break;
      }
      default:
         //we don't know how to load this
         //TODO: iterate over IDA sections, and copy content into unicorn
         //need to account for bss stuff which IDA fills with ?? which reads as 0xff
         break;
   }
   return result;
}

```

`loader.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#ifndef __IMAGE_LOADER_H
#define __IMAGE_LOADER_H

#include "sk3wldbg.h"

bool loadImage(sk3wldbg *uc, void *img, size_t sz, const char *args, uint64_t init_pc);
bool loadPE64(sk3wldbg *uc, void *img, size_t sz, const char *args, uint64_t init_pc);
bool loadPE32(sk3wldbg *uc, void *img, size_t sz, const char *args, uint64_t init_pc);
bool loadElf64(sk3wldbg *uc, void *img, size_t sz, const char *args, uint64_t init_pc);
bool loadElf32(sk3wldbg *uc, void *img, size_t sz, const char *args, uint64_t init_pc);

extern unsigned int ida_to_uc_perms_map[];
extern unsigned int ida_to_uc_perms_map_win[];
extern unsigned int uc_to_ida_perms_map[];

#endif

```

`mem_mgr.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#ifndef __NT__
#include <unistd.h>
#endif

#include <stdlib.h>
#include <ida.hpp>
#include <kernwin.hpp>

#include "mem_mgr.h"

//#define DEBUG 1

mem_mgr::mem_mgr(uc_engine *uc, uint64_t map_min, uint64_t map_max) {
   root = NULL;
   this->uc = uc;
   set_mmap_region(map_min, map_max);
}

mem_mgr::mem_mgr(uc_engine *uc) {
   root = NULL;
   this->uc = uc;
   map_min = 0;
   map_max = 0;
   max_block = 0;
}

mem_mgr::~mem_mgr() {
   //need to free/unmap all the pages
}

void mem_mgr::set_mmap_region(uint64_t map_min, uint64_t map_max) {
   if (map_min > map_max) {
      this->map_min = map_max;
      this->map_max = map_min;
   }
   else {
      this->map_min = map_min;
      this->map_max = map_max;
   }
   max_block = this->map_max - this->map_min;
}

void mem_mgr::insert(map_block *tree, map_block *node) {
   if (root == NULL) {
      root = node;
   }
   else if (node->guest <= tree->guest) {
      if (tree->left == NULL) {
         tree->left = node;
      }
      else {
         insert(tree->left, node);
      }
   }
   else {
      if (tree->right == NULL) {
         tree->right = node;
      }
      else {
         insert(tree->right, node);
      }
   }
}

map_block *mem_mgr::add_block(void *host, uint64_t guest, uint32_t length) {
   map_block *m = (map_block*)calloc(sizeof(map_block), 1);
   if (m == NULL) {
      return NULL;
   }
   m->host = host;
   m->guest = guest;
   m->length = length;
   insert(root, m);
   return m;
}

map_block *mem_mgr::find(map_block *tree, uint64_t addr) {
   if (tree == NULL) {
      return NULL;
   }
   if (addr < tree->guest) {
      return find(tree->left, addr);
   }
   else if (addr >= (tree->guest + tree->length)) {
      return find(tree->right, addr);
   }
   return tree;
}

map_block *mem_mgr::find_block(uint64_t addr) {
   return find(root, addr);
}

map_block *mem_mgr::next(map_block *tree, uint64_t addr) {
   if (tree == NULL) {
      return NULL;
   }
   if (addr < tree->guest) {
      //this might be the "next" block, but look for something lower
      map_block *b = next(tree->left, addr);
      return b ? b : tree;
   }
   //next must follow this block
   return next(tree->right, addr);
}

map_block *mem_mgr::next_block(uint64_t addr) {
   return next(root, addr);
}

map_block *mem_mgr::prev(map_block *tree, uint64_t addr) {
   if (tree == NULL) {
      return NULL;
   }
   if (addr >= (tree->guest + tree->length)) {
      //this might be the "prev" block, but look for something higher
      map_block *b = prev(tree->right, addr);
      return b ? b : tree;
   }
   //prev must precede this block
   return prev(tree->left, addr);
}

map_block *mem_mgr::prev_block(uint64_t addr) {
   return prev(root, addr);
}

void *mem_mgr::to_host_ptr(uint64_t addr) {
   map_block *b = find_block(addr);
   if (b) {
      return (addr - b->guest) + (char*)b->host;
   }
   return NULL;
}

//node must be non-null and in the tree (returned by find)
void mem_mgr::remove(map_block *tree, map_block *node) {
   if (tree == NULL || node == NULL) {
      //safety check for invalid args
      return;
   }
   if (node == root) {
      if (root->right) {
         if (root->left) {
            insert(root->right, root->left);
         }
         root = root->right;
      }
      else {
         root = root->left;
      }
   }
   else if (node->guest > tree->guest) {
      if (tree->right == node) {
         tree->right = node->left;
         if (node->right != NULL) {
            insert(tree, node->right);
         }
      }
      else {
         remove(tree->right, node);
      }
   }
   else {
      if (tree->left == node) {
         tree->left = node->left;
         if (node->right != NULL) {
            insert(tree, node->right);
         }
      }
      else {
         remove(tree->left, node);
      }
   }
   node->left = node->right = NULL;
}

/*
//Unicorn permissions are the same as Linux permissions
#define PROT_READ       0x1  // page can be read
#define PROT_WRITE      0x2  // page can be written
#define PROT_EXEC       0x4  // page can be executed
*/
map_block *mem_mgr::mmap(uint64_t addr, uint32_t length, uint32_t perms, uint32_t flags) {
   uint64_t guest = 0;
   bool found = false;
   uint64_t orig = addr;
   map_block *b = NULL;
   if (length & 0xfff) {
      //length must be multiple of page size
#ifdef DEBUG
      msg("mmap: non-aligned size\n");
#endif
      return NULL;
   }
   if (addr & 0xfff) {
      //addr must be page aligned
#ifdef DEBUG
      msg("mmap: non-aligned address\n");
#endif
      return NULL;
   }
   if (length > max_block) {
      //out of memory
#ifdef DEBUG
      msg("mmap: out of memory\n");
#endif
      return NULL;
   }
   //highest address at which this allocation can be made
   uint64_t max_alloc = map_max - length;
   if (addr > max_alloc) {
      if (flags & SDB_MAP_FIXED) {
         //can't do what user wants
#ifdef DEBUG
         msg("mmap: address unavailable for fixed allocation\n");
#endif
         return NULL;
      }
      //just use top down allocation
      addr = 0;
   }
   if (addr || (flags & SDB_MAP_FIXED) != 0) {
//   if (addr) {
      //user wants a specific address
      if (addr < map_min) {
         addr = map_min;
         orig = map_min;
      }
      map_block *n = next_block(addr);
      while (!found && addr >= map_min && addr <= max_alloc) {
         b = find_block(addr);
         if (b) {
            //desired address is already in use
            if (flags & SDB_MAP_FIXED) {
               return NULL;  //can't grant user request
            }
            //compute the next lower address that might fit the entire request block
            addr = b->guest - length;
#ifdef DEBUG
            msg("mmap1: addr set to %p\n", (void*)addr);
#endif
         }
         else if (n == NULL) {
            guest = addr;
#ifdef DEBUG
            msg("mmap2: guest set to %p\n", (void*)guest);
#endif
            found = true;
         }
         else {
            b = prev_block(addr);
            if (b) {
               uint64_t end = b->guest + b->length;
               uint64_t gap = n->guest - addr;
               if (gap >= length) {
                  guest = addr;
#ifdef DEBUG
                  msg("mmap3: guest set to %p\n", (void*)guest);
#endif
                  found = true;
               }
               else {
                  n = b;
               }
            }
            else {
               uint64_t gap = n->guest - addr;
               if (gap >= length) {
                  guest = addr;
#ifdef DEBUG
                  msg("mmap4: guest set to %p\n", (void*)guest);
#endif
                  found = true;
               }
               else {
                  //hit bottom;
                  break;
               }
            }
         }
      }
      addr = orig;
#ifdef DEBUG
      msg("mmap5: addr set to %p\n", (void*)addr);
#endif
      while (!found && addr <= max_alloc) {
         b = find_block(addr);
         n = next_block(addr);
         if (b) {
            addr = b->guest + b->length;
#ifdef DEBUG
            msg("mmap6: addr set to %p\n", (void*)addr);
#endif
         }
         else if (n == NULL) {
            guest = addr;
#ifdef DEBUG
            msg("mmap7: guest set to %p\n", (void*)guest);
#endif
            found = true;
         }
         else {
            uint64_t gap = n->guest - addr;
            if (gap >= length) {
               guest = addr;
#ifdef DEBUG
               msg("mmap8: guest set to %p\n", (void*)guest);
#endif
               found = true;
            }
            else {
               addr = n->guest + n->length;
#ifdef DEBUG
               msg("mmap9: addr set to %p\n", (void*)addr);
#endif
            }
         }
      }
   }
   else {
      uint64_t top = map_max;
      while (1) {
         b = prev_block(top);
         if (b == NULL) {
            if (top >= (length + map_min)) {
               guest = top - length;
#ifdef DEBUG
               msg("mmap10: guest set to %p\n", (void*)guest);
#endif
               found = true;
            }
            break;
         }
         else {
            if ((top - (b->guest + b->length)) > length) {
               //fits in the gap
               guest = top - length;
#ifdef DEBUG
               msg("mmap11: guest set to %p\n", (void*)guest);
#endif
               found = true;
               break;
            }
            top = b->guest;
         }
      }
   }
   if (!found) {
      return NULL;
   }
   void *host = calloc(length, 1);
   if (host == NULL) {
      return NULL;
   }
#ifdef DEBUG
   msg("add_block(ptr, %p, 0x%x)\n", (void*)guest, (uint32_t)length);
#endif
   b = add_block(host, guest, length);
   uc_err err = uc_mem_map_ptr(uc, b->guest, b->length, perms, b->host);
#ifdef DEBUG
   msg("uc_mem_map_ptr(%p, 0x%x, %d)\n", (void*)b->guest, (uint32_t)b->length, perms);
#endif
   if (err != UC_ERR_OK) {
      msg("Failed on uc_mem_map_ptr() with error returned %u: %s\n", err, uc_strerror(err));
   }
   else {
   }

   return b;
}

void mem_mgr::mprotect(uint64_t addr, uint32_t length, uint32_t perms) {
}

void mem_mgr::munmap(uint64_t addr, uint32_t length) {
   uint64_t end = addr + length;
   map_block *b = find_block(addr);
   if (b) {
      uc_mem_unmap(uc, b->guest, b->length);
   }
   do {
      if (b) {
         uint64_t bend = b->guest + b->length;
         remove(root, b);
         if (b->guest < addr) {
            add_block(b->host, b->guest, (uint32_t)(addr - b->guest));
         }
         if (end < bend) {
            add_block((end - b->guest) + (char*)b->host, end, (uint32_t)(bend - end));
            free(b);
            break;
         }
         if (end == bend) {
            free(b);
            break;
         }
         free(b);
      }
   } while ((b = next_block(addr)) != NULL && end > b->guest);
}

```

`mem_mgr.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#ifndef __MEM_MGR_H
#define __MEM_MGR_H

#include <stdint.h>

#include <unicorn/unicorn.h>

#define SDB_MAP_FIXED 1

struct map_block {
   void *host;
   uint64_t guest;
   uint32_t length;
   map_block *left;
   map_block *right;
};

class mem_mgr {
   uc_engine *uc;
   map_block *root;
   uint64_t map_min;
   uint64_t map_max;
   uint64_t max_block;

   void insert(map_block *tree, map_block *node);
   map_block *find(map_block *tree, uint64_t addr);
   map_block *next(map_block *tree, uint64_t addr);
   map_block *next_block(uint64_t addr);
   map_block *prev(map_block *tree, uint64_t addr);
   map_block *prev_block(uint64_t addr);
   void remove(map_block *tree, map_block *node);

public:
   mem_mgr(uc_engine *uc);
   mem_mgr(uc_engine *uc, uint64_t map_min, uint64_t map_max);
   ~mem_mgr();

   void set_mmap_region(uint64_t map_min, uint64_t map_max);
   
   map_block *add_block(void *host, uint64_t guest, uint32_t length);
   map_block *find_block(uint64_t addr);
   void *to_host_ptr(uint64_t addr);
   map_block *mmap(uint64_t addr, uint32_t length, uint32_t perms, uint32_t flags = 0);
   void mprotect(uint64_t addr, uint32_t length, uint32_t perms);
   void munmap(uint64_t addr, uint32_t length);
};

#endif

```

`pe_local.h`:

```h
#ifndef __PE_LOCAL
#define __PE_LOCAL

#include <stdint.h>

#define DOS_MAGIC 0x5a4d       //'MZ'
#define PE_MAGIC 0x4550       //'PE'

struct IMAGE_DOS_HEADER_ {      // DOS .EXE header
   uint16_t   e_magic;            // Magic number
   uint16_t   e_cblp;             // Bytes on last page of file
   uint16_t   e_cp;               // Pages in file
   uint16_t   e_crlc;             // Relocations
   uint16_t   e_cparhdr;          // Size of header in paragraphs
   uint16_t   e_minalloc;         // Minimum extra paragraphs needed
   uint16_t   e_maxalloc;         // Maximum extra paragraphs needed
   uint16_t   e_ss;               // Initial (relative) SS value
   uint16_t   e_sp;               // Initial SP value
   uint16_t   e_csum;             // Checksum
   uint16_t   e_ip;               // Initial IP value
   uint16_t   e_cs;               // Initial (relative) CS value
   uint16_t   e_lfarlc;           // File address of relocation table
   uint16_t   e_ovno;             // Overlay number
   uint16_t   e_res[4];           // Reserved uint16_ts
   uint16_t   e_oemid;            // OEM identifier (for e_oeminfo)
   uint16_t   e_oeminfo;          // OEM information; e_oemid specific
   uint16_t   e_res2[10];         // Reserved uint16_ts
   uint32_t   e_lfanew;           // 0x3C File address of new exe header
};

struct IMAGE_FILE_HEADER_ {
   uint16_t    Machine;                   //0
   uint16_t    NumberOfSections;          //2 
   uint32_t    TimeDateStamp;             //4
   uint32_t    PointerToSymbolTable;      //8
   uint32_t    NumberOfSymbols;           //12
   uint16_t    SizeOfOptionalHeader;      //16
   uint16_t    Characteristics;           //18
};                            //size 20

struct IMAGE_DATA_DIRECTORY_ {
   uint32_t   VirtualAddress;
   uint32_t   Size;
};

struct IMAGE_OPTIONAL_HEADER32_ {
   //
   // Standard fields.
   //
   uint16_t   Magic;                   //0
   uint8_t    MajorLinkerVersion;      //2
   uint8_t    MinorLinkerVersion;      //3
   uint32_t   SizeOfCode;              //4
   uint32_t   SizeOfInitializedData;   //8
   uint32_t   SizeOfUninitializedData; //12
   uint32_t   AddressOfEntryPoint;     //16
   uint32_t   BaseOfCode;              //20
   uint32_t   BaseOfData;              //24 

   //
   // NT additional fields.
   //

   uint32_t   ImageBase;                   //28
   uint32_t   SectionAlignment;            //32
   uint32_t   FileAlignment;               //36
   uint16_t   MajorOperatingSystemVersion; //40
   uint16_t   MinorOperatingSystemVersion; //42
   uint16_t   MajorImageVersion;           //44
   uint16_t   MinorImageVersion;           //46
   uint16_t   MajorSubsystemVersion;       //48
   uint16_t   MinorSubsystemVersion;       //50
   uint32_t   Win32VersionValue;           //52
   uint32_t   SizeOfImage;                 //56
   uint32_t   SizeOfHeaders;               //60
   uint32_t   CheckSum;                    //64
   uint16_t   Subsystem;                   //68
   uint16_t   DllCharacteristics;          //70
   uint32_t   SizeOfStackReserve;          //72
   uint32_t   SizeOfStackCommit;           //76
   uint32_t   SizeOfHeapReserve;           //80
   uint32_t   SizeOfHeapCommit;            //84
   uint32_t   LoaderFlags;                 //88
   uint32_t   NumberOfRvaAndSizes;         //92
   IMAGE_DATA_DIRECTORY_ DataDirectory[16];    //96
};                     //size 224

struct IMAGE_OPTIONAL_HEADER64_ {
   //
   // Standard fields.
   //
   uint16_t   Magic;                   //0
   uint8_t    MajorLinkerVersion;      //2
   uint8_t    MinorLinkerVersion;      //3
   uint32_t   SizeOfCode;              //4
   uint32_t   SizeOfInitializedData;   //8
   uint32_t   SizeOfUninitializedData; //12
   uint32_t   AddressOfEntryPoint;     //16
   uint32_t   BaseOfCode;              //20
   //
   // NT additional fields.
   //
   uint64_t   ImageBase;                   //24
   uint32_t   SectionAlignment;            //32
   uint32_t   FileAlignment;               //36
   uint16_t   MajorOperatingSystemVersion; //40
   uint16_t   MinorOperatingSystemVersion; //42
   uint16_t   MajorImageVersion;           //44
   uint16_t   MinorImageVersion;           //46
   uint16_t   MajorSubsystemVersion;       //48
   uint16_t   MinorSubsystemVersion;       //50
   uint32_t   Win32VersionValue;           //52
   uint32_t   SizeOfImage;                 //56
   uint32_t   SizeOfHeaders;               //60
   uint32_t   CheckSum;                    //64
   uint16_t   Subsystem;                   //68
   uint16_t   DllCharacteristics;          //70
   uint64_t   SizeOfStackReserve;          //72
   uint64_t   SizeOfStackCommit;           //80
   uint64_t   SizeOfHeapReserve;           //88
   uint64_t   SizeOfHeapCommit;            //96
   uint32_t   LoaderFlags;                 //104
   uint32_t   NumberOfRvaAndSizes;         //108
   IMAGE_DATA_DIRECTORY_ DataDirectory[16];    //112
};                     //size 240

struct IMAGE_NT_HEADERS32_ {
   uint32_t Signature;
   IMAGE_FILE_HEADER_ FileHeader;
   IMAGE_OPTIONAL_HEADER32_ OptionalHeader;
};

struct IMAGE_NT_HEADERS64_ {
   uint32_t Signature;
   IMAGE_FILE_HEADER_ FileHeader;
   IMAGE_OPTIONAL_HEADER64_ OptionalHeader;
};

struct IMAGE_SECTION_HEADER_ {
   uint8_t    Name[8];              //0
   uint32_t   VirtualSize;            //8
   uint32_t   VirtualAddress;         //12
   uint32_t   SizeOfRawData;          //16
   uint32_t   PointerToRawData;       //20
   uint32_t   PointerToRelocations;   //24
   uint32_t   PointerToLinenumbers;   //28
   uint16_t   NumberOfRelocations;    //32
   uint16_t   NumberOfLinenumbers;    //34
   uint32_t   Characteristics;        //36
};                   //size 40

#endif


```

`sk3wldbg.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

/*
 *  This is the Sk3wlDbg plugin module
 *
 *  It is known to compile with
 *
 *  - Visual Studio 2010, Linux g++, OS X - clang
 *
 */
#define USE_DANGEROUS_FUNCTIONS

#ifdef __NT__
#ifdef _WIN32
#ifndef _MSC_VER
#include <windows.h>
#endif
#include <winsock2.h>
#endif
#include <winnt.h>
#include <wincrypt.h>
#else
//#ifndef __NT__
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>
#endif

#ifdef PACKED
#undef PACKED
#endif

#define USE_STANDARD_FILE_FUNCTIONS

#include <unicorn/unicorn.h>

#include <pro.h>
#include <ida.hpp>
#include <idp.hpp>
#include <bytes.hpp>
#include <auto.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <typeinf.hpp>
#include <nalt.hpp>
#include <segment.hpp>
#if IDA_SDK_VERSION >= 700
#include <segregs.hpp>
#else
#include <srarea.hpp>
#endif
#include <typeinf.hpp>
#include <struct.hpp>
#include <entry.hpp>
#include <dbg.hpp>
#include <idd.hpp>
#include <ua.hpp>

#include "sk3wldbg.h"
#include "loader.h"

#ifndef _WIN32
#define _snprintf snprintf
#endif

#ifdef DEBUG
#undef DEBUG
#else
#undef DEBUG
#endif

static ssize_t idaapi idd_hook(void * /* ud */, int notification_code, va_list va);

struct safe_msg : public exec_request_t {
   qstring the_msg;
   safe_msg(qstring &msg) : the_msg(msg) {};
   int idaapi execute(void);
};

int idaapi safe_msg::execute() {
   msg("%s", the_msg.c_str());
   return 0;
}

//Not certain this is necessary, but included to provide for message printing from
//the unicorn thread
void do_safe_msg(const char *msg) {
   qstring m(msg);
   safe_msg req(m);
   execute_sync(req, MFF_FAST);
}

qstring *get_process_name() {
   char buf[1024];
   ssize_t sz = get_root_filename(buf, sizeof(buf));
   return new qstring(buf);
}

#if IDA_SDK_VERSION >= 700
static ssize_t idaapi idb_hook(void *user_data, int notification_code, va_list va) {
#else
static int idaapi idb_hook(void *user_data, int notification_code, va_list va) {
#endif
   sk3wldbg *uc = (sk3wldbg*)user_data;
   switch (notification_code) {
      case idb_event::segm_added: {
         segment_t *seg = va_arg(va, segment_t *);
         uintptr_t start = seg->start_ea;
         uintptr_t end = seg->end_ea;
         msg("idb_hook uc == %p\n", uc);
         msg("offset to uc->memmgr == 0x%x\n", ((char*)&uc->memmgr) - (char*)uc);
         msg("uc->memmgr == %p\n", uc->memmgr);
         msg("segm_added mapping, %p:%p\n", (void*)start, (void*)end);
         if (uc->memmgr->find_block(start) == NULL) {
            msg("segm_added mapping, %p:%p\n", (void*)start, (void*)end);
            uc->map_mem_zero(start, end, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC, SDB_MAP_FIXED);
            msg("segm_added mapped, %p:%p\n", (void*)start, (void*)end);
         }
         else {
            msg("segm_added already mapped\n");
         }
         return 1;
      }
   }
   return 0;
}

/// Initialize debugger.
/// This function is called from the main thread.
/// \return success
#if IDA_SDK_VERSION >= 710
bool idaapi uni_init_debugger(const char * /*hostname*/, int /*portnum*/, const char * /*password*/, qstring * /*errbuf*/) {
#else
bool idaapi uni_init_debugger(const char * /*hostname*/, int /*portnum*/, const char * /*password*/) {
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   msg("uni_init_debugger called\n");
#endif
   return true;
}

/// Terminate debugger.
/// This function is called from the main thread.
/// \return success
bool idaapi uni_term_debugger(void) {
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   msg("uni_term_debugger called\n");
#endif
//   safe_msg req("uni_term_debugger called\n");
//   execute_sync(req, MFF_FAST);
   if (uc->uc) {
      uc->emu_state = RS_TERM;
      qsem_post(uc->run_sem);
      //***synchronize here to make sure execution thread has stopped
      qthread_join(uc->process_thread);
//      msg("uni_term_debugger thread joined\n");
      uc->close();

      if (uc->registered_menu) {
         detach_action_from_menu("Debugger/Take memory snapshot", "sk3wldbg:mem_map");
//         unregister_action("sk3wldbg:mem_map");
         uc->registered_menu = false;
      }
//      uc->uc = NULL;
   }

   unhook_from_notification_point(::HT_IDB, idb_hook);

//   safe_msg req2("uni_term_debugger complete\n");
//   execute_sync(req2, MFF_FAST);
   return true;
}

bool sk3wldbg::queue_exception_event(uint32_t code, uint64_t mem_addr, const char *errmsg) {
   debug_event_t exc;
#if IDA_SDK_VERSION >= 710
   exc.set_eid(::EXCEPTION);
#else
   exc.eid = ::EXCEPTION;
#endif
   exc.pid = the_process;
   exc.tid = the_threads.front();
   exc.ea = (ea_t)get_pc();
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "Exception occurred at: %p\n", (void*)exc.ea);
   msg("%s", msgbuf);
#endif
   exc.handled = true;

#if IDA_SDK_VERSION >= 710
   excinfo_t &xcpt = exc.exc();
   xcpt.info = errmsg;
#else
   e_exception_t &xcpt = exc.exc;
   qstrncpy(xcpt.info, errmsg, sizeof(xcpt.info));
#endif

   xcpt.code = code;
   xcpt.can_cont = false;
   xcpt.ea = (ea_t)mem_addr;

   enqueue_debug_evt(exc);
   return true;
}

void sk3wldbg::queue_step_event(uint64_t _pc) {
   debug_event_t cont;
#if IDA_SDK_VERSION >= 710
   cont.set_eid(::STEP);
#else
   cont.eid = ::STEP;
#endif
   cont.pid = the_process;
   cont.tid = the_threads.front();
   cont.ea = (ea_t)_pc;
   cont.handled = true;
   enqueue_debug_evt(cont);
}

bool sk3wldbg::queue_dbg_event(bool is_hardware) {
   debug_event_t brk;
#if IDA_SDK_VERSION >= 710
   brk.set_eid(::BREAKPOINT);
   bptaddr_t &bpt = brk.bpt();
#else
   brk.eid = ::BREAKPOINT;
   e_breakpoint_t &bpt = brk.bpt;
#endif
   brk.pid = the_process;
   brk.tid = the_threads.front();
   brk.ea = (ea_t)get_pc();
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "Breakpoint hit at: %p\n", (void*)brk.ea);
   msg("%s", msgbuf);
#endif
   brk.handled = true;
   bpt.hea = is_hardware ? brk.ea : BADADDR;
   bpt.kea = BADADDR;
   enqueue_debug_evt(brk);
   return true;
}

struct print_pc : public exec_request_t {
   uint64_t pc;
   print_pc(uint64_t _pc) : pc(_pc) {};
   int idaapi execute(void);
};

int idaapi print_pc::execute() {
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "processRunner running from %p\n", (void*)pc);
   msg("%s", msgbuf);
#endif
   return 0;
}

int idaapi processRunner(void *unicorn) {
   sk3wldbg *uc = (sk3wldbg*)unicorn;
   uint64_t pc = uc->get_pc();
   if (pc == 0) {
      msg("PC was not set previously, going with screen EA");
      pc = get_screen_ea();
   }
   else {
      char buf[1024];
      _snprintf(buf, sizeof(buf), "PC was set previously to %p", (void*)pc);
      msg("%s\n", buf);
   }
   uc->start(pc);
   //unicorn start has returned, process has ended, so tell IDA to detach
   debug_event_t detach;
#if IDA_SDK_VERSION >= 710
   detach.set_eid(PROCESS_DETACH);
#else
   detach.eid = PROCESS_DETACH;
#endif
   detach.pid = uc->the_process;
   detach.tid = uc->the_threads.front();
   detach.ea  = BADADDR;
   detach.handled = true;
   uc->enqueue_debug_evt(detach);
   return 0;
}

#if IDA_SDK_VERSION >= 700
/// Return information about the n-th "compatible" running process.
/// If n is 0, the processes list is reinitialized.
/// This function is called from the main thread.
/// \retval 1  ok
/// \retval 0  failed
/// \retval -1 network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_get_processes(procinfo_vec_t *procs, qstring * /*errbuf*/) {
#else
int idaapi uni_get_processes(procinfo_vec_t *procs) {
#endif
#ifdef DEBUG
   msg("uni_get_processes called\n");
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
   process_info_t info;
   qstring *procname = get_process_name();
   info.name = *procname;
   delete procname;
   info.pid = uc->the_process;
   procs->push_back(info);
   return 1;
}
#else
/// Return information about the n-th "compatible" running process.
/// If n is 0, the processes list is reinitialized.
/// This function is called from the main thread.
/// \retval 1  ok
/// \retval 0  failed
/// \retval -1 network error
int idaapi uni_process_get_info(int n, process_info_t *info) {
   if (n) {
      return 0;
   }
#ifdef DEBUG
   msg("uni_process_get_info called\n");
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
   qstring *procname = get_process_name();
   qstrncpy(info->name, procname->c_str(), sizeof(info->name));
   delete procname;
   info->pid = uc->the_process;
   return 1;
}
#endif

#if IDA_SDK_VERSION < 700
//*** Learn proper way to do this in Ida 7.0
struct install_menu : public exec_request_t {
   sk3wldbg *uc;
   install_menu(sk3wldbg *_uc) : uc(_uc) {};
   int idaapi execute(void);
};

int idaapi install_menu::execute() {
   attach_action_to_menu("Debugger/Take memory snapshot", "sk3wldbg:mem_map", SETMENU_APP);
   enable_menu_item("Debugger/Map memory...", false);
   uc->registered_menu = true;
   return 0;
}
#endif

/// Start an executable to debug.
/// This function is called from debthread.
/// \param path              path to executable
/// \param args              arguments to pass to executable
/// \param startdir          current directory of new process
/// \param dbg_proc_flags    \ref DBG_PROC_
/// \param input_path        path to database input file.
///                          (not always the same as 'path' - e.g. if you're analyzing
///                          a dll and want to launch an executable that loads it)
/// \param input_file_crc32  CRC value for 'input_path'
/// \retval  1                    ok
/// \retval  0                    failed
/// \retval -2                    file not found (ask for process options)
/// \retval  1 | #CRC32_MISMATCH  ok, but the input file crc does not match
/// \retval -1                    network error
int idaapi uni_start_process(const char * /*path*/,
                  const char *args,
                  const char * /*startdir*/,
                  int /*dbg_proc_flags*/,
                  const char *input_path,
#if IDA_SDK_VERSION >= 710
                  uint32 /*input_file_crc32*/, qstring * /*errbuf*/) {
#else
                  uint32 /*input_file_crc32*/) {
#endif


#ifdef DEBUG
   msg("uni_start_process called\n");
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;

#if IDA_SDK_VERSION < 700
   //*** Learn proper way to do this in Ida 7.0
   install_menu req(uc);
   execute_sync(req, MFF_FAST);
#endif

   int choice = ask_buttons("Cursor", "Entry point", NULL, ASKBTN_YES, "Begin execution from:");

   ea_t init_pc = BADADDR;

   if (choice == ASKBTN_YES) {
      init_pc = get_screen_ea();
      uc->check_mode(init_pc);
   }

   if (!uc->open()) {
      //failed to open unicorn instance
      return 0;
   }

   qsem_free(uc->run_sem);
   uc->run_sem = qsem_create(NULL, 0);
   qmutex_unlock(uc->evt_mutex);
   uc->clear_memory();
   uc->dbg_evt_list.clear();
   uc->the_threads.clear();

   uc->getRandomBytes(&uc->the_process, 2);
   uc->the_process = (uc->the_process % 40000) + 1000;

   thid_t a_thread = 0;
   do {
      uc->getRandomBytes(&a_thread, 2);
      a_thread = (a_thread % 40000) + 1000;
   } while (a_thread == (thid_t)uc->the_process);
   uc->the_threads.push_back(a_thread);

   FILE *bin = fopen(input_path, "rb");
   bool loaded = false;
   if (bin != NULL) {
      msg("found input file %s\n", input_path);
      if (fseek(bin, 0, SEEK_END) != 0) {
         //HUH?
         msg("SEEK_END fail\n");
      }
      else {
         long sz = ftell(bin);
         void *img = malloc(sz);
         if (img == NULL) {
            //OOM
            msg("image allocate fail\n");
         }
         else {
            msg("reading file of %u bytes\n", (uint32_t)sz);
            fseek(bin, 0, SEEK_SET);
            if (fread(img, sz, 1, bin) != 1) {
               //fail
               msg("fread fail\n");
            }
            else {
               loaded = loadImage(uc, img, sz, args, init_pc);
            }
            free(img);
         }
      }
      fclose(bin);
   }
   void *buf16 = NULL; //memory pointer
   if (uc->debug_mode == UC_MODE_16) {
      //just map a megabyte
      uc->init_memmgr(0, 0x100000);
      buf16 = uc->map_mem_zero(0, 0x100000, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC, SDB_MAP_FIXED);
   }
   else if (uc->get_sp() == 0) {
      //need a stack too, just sling it somewhere
      //add it to uc->memory
      unsigned int stack_top = 0xffffe000;
      uc->init_memmgr(0x100000, stack_top);
      uc->map_mem_zero(stack_top - 0x100000, stack_top, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC, SDB_MAP_FIXED);
      stack_top -= 16;
      uc->set_sp(stack_top);
   }
   if (!loaded) {
      //didn't know format, let's try for what we need from IDA
      //init memory, by copying from IDA
      //May prefer instead to init from file, in which case we need loaders
      //Also need to map in a stack and init stack pointer, this will be
      //architecture dependent since each arch has its own SP register
      //arch specific unicorns also need to set initial register state
      segment_t *seg;
      for (seg = get_first_seg(); seg != NULL; seg = get_next_seg(seg->startEA)) {
         void *buf;
         ssize_t exact = (ssize_t)(seg->endEA - seg->startEA);
         if (uc->debug_mode == UC_MODE_16) {
            buf = seg->startEA + (char*)buf16;
         }
         else {
            buf = uc->map_mem_zero(seg->startEA, seg->endEA, ida_to_uc_perms_map[seg->perm], SDB_MAP_FIXED);
         }
         get_many_bytes(seg->startEA, buf, exact);
      }

      //need other ways to set PC, from start, user specified
      uc->set_pc(init_pc);
   }
   else { // we loaded it, but may need to load any additional segments that exist in IDA
      segment_t *seg;
      void *buf;
      for (seg = get_first_seg(); seg != NULL; seg = get_next_seg(seg->startEA)) {
         if (seg->is_loader_segm()) {
            //should have been handled by our loader
            continue;
         }
         ssize_t exact = (ssize_t)(seg->endEA - seg->startEA);
         buf = uc->map_mem_zero(seg->startEA, seg->endEA, ida_to_uc_perms_map[SEGPERM_EXEC | SEGPERM_WRITE | SEGPERM_READ], SDB_MAP_FIXED);
         msg("trying to populate new segment\n");
         get_many_bytes(seg->startEA, buf, exact);
         msg("populated new segment\n");
      }
   }

   // need to respond to some idb events
   hook_to_notification_point(::HT_IDB, idb_hook, uc);

   //init registers
   //TODO: each architecture subclass should have its own register state initialization

   //register unicorn hooks

   //start in break state, RS_RUN will be set in uni_continue_after_event
   uc->emu_state = RS_BREAK;
   uc->do_suspend = false;
   uc->finished = false;
   uc->single_step = false;

   //this is going to have to run in a separate thread otherwise other
   //debthread functions will never get called
   uc->process_thread = qthread_create(processRunner, uc);
   if (uc->process_thread == NULL) {
      //error failed to create thread
      msg(PLUGIN_NAME": Failed to start process.\n");
      return 0;
   }

   debug_event_t start;
   qstring *procname = get_process_name();
#if IDA_SDK_VERSION >= 710
   start.set_eid(PROCESS_START);
   modinfo_t &mod = start.modinfo();
   mod.name = *procname;
#else
   start.eid = PROCESS_START;
   module_info_t &mod = start.modinfo;
   qstrncpy(mod.name, procname->c_str(), sizeof(start.modinfo.name));
#endif
   delete procname;
   start.pid = uc->the_process;
   start.tid = uc->the_threads.front();
   start.ea = BADADDR;
   start.handled = true;
#if IDA_SDK_VERSION < 730
   mod.base = inf.min_ea;
   mod.size = inf.max_ea - inf.min_ea;
#else
   mod.base = inf_get_min_ea();
   mod.size = inf_get_max_ea() - inf_get_min_ea();
#endif
   mod.rebase_to = BADADDR;
   uc->enqueue_debug_evt(start);

#ifdef DEBUG
   msg("uni_start_process complete\n");
#endif
   return 1;
}

/// Attach to an existing running process.
/// event_id should be equal to -1 if not attaching to a crashed process.
/// This function is called from debthread.
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error

#if IDA_SDK_VERSION >= 710
int idaapi uni_attach_process(pid_t /*pid*/, int /*event_id*/, int /*dbg_proc_flags*/, qstring * /*errbuf*/) {
#else
#if IDA_SDK_VERSION < 690
int idaapi uni_attach_process(pid_t /*pid*/, int /*event_id*/) {
#else
int idaapi uni_attach_process(pid_t /*pid*/, int /*event_id*/, int /*dbg_proc_flags*/) {
#endif
#endif

   //can't do this with unicorn
#ifdef DEBUG
   msg("uni_attach_process called\n");
#endif
   return 0;
}

/// Detach from the debugged process.
/// May be called while the process is running or suspended.
/// Must detach from the process in any case.
/// The kernel will repeatedly call get_debug_event() and until ::PROCESS_DETACH.
/// In this mode, all other events will be automatically handled and process will be resumed.
/// This function is called from debthread.
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
int idaapi uni_detach_process(void) {
#ifdef DEBUG
   msg("uni_detach_process called\n");
#endif
   //for unicorn we will just terminate session if user wants to detach
   sk3wldbg *uc = (sk3wldbg*)dbg;
   uc->emu_state = RS_TERM;
   qsem_post(uc->run_sem);
   //***synchronize here to make sure execution thread has stopped
   qthread_join(uc->process_thread);
#ifdef DEBUG
   msg("uni_detach_process thread joined\n");
#endif
/*
   debug_event_t detach;
#if IDA_SDK_VERSION >= 710
   detach.set_eid(PROCESS_DETACH);
#else
   detach.eid = PROCESS_DETACH;
#endif
   detach.pid = uc->the_process;
   detach.tid = uc->the_threads.front();
   detach.ea  = BADADDR;
   detach.handled = true;
   uc->enqueue_debug_evt(detach);
*/
#ifdef DEBUG
   msg("uni_detach_process complete\n");
#endif
   return 1;
}

/// Rebase database if the debugged program has been rebased by the system.
/// This function is called from the main thread.
void idaapi uni_rebase_if_required_to(ea_t /*new_base*/) {
#ifdef DEBUG
   msg("uni_rebase_if_required_to called: NOT IMPLEMENTED\n");
#endif
}

/// Prepare to pause the process.
/// Normally the next get_debug_event() will pause the process
/// If the process is sleeping then the pause will not occur
/// until the process wakes up. The interface should take care of
/// this situation.
/// If this function is absent, then it won't be possible to pause the program.
/// This function is called from debthread.
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_prepare_to_pause_process(qstring * /*errbuf*/) {
#else
int idaapi uni_prepare_to_pause_process(void) {
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   msg("uni_prepare_to_pause_process called\n");
#endif
   uc->pause();           //??? wait for signal from unicorn theead?
   debug_event_t pause;
#if IDA_SDK_VERSION >= 710
   pause.set_eid(PROCESS_SUSPEND);
   pause.info()[0] = 0;
#else
   pause.eid = ::PROCESS_SUSPEND;
   pause.info[0] = 0;
#endif
   pause.pid = uc->the_process;
   pause.tid = uc->the_threads.front();
#if IDA_SDK_VERSION < 730
   pause.ea = inf.minEA;   //??? get pc from unicorn
#else
   pause.ea = inf_get_min_ea();
#endif
   uc->enqueue_debug_evt(pause);
#ifdef DEBUG
   msg("uni_prepare_to_pause_process complete\n");
#endif
   return 1;
}

/// Stop the process.
/// May be called while the process is running or suspended.
/// Must terminate the process in any case.
/// The kernel will repeatedly call get_debug_event() and until ::PROCESS_EXIT.
/// In this mode, all other events will be automatically handled and process will be resumed.
/// This function is called from debthread.
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_exit_process(qstring * /*errbuf*/) {
#else
int idaapi uni_exit_process(void) {
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   msg("uni_exit_process called\n");
#endif
   uc->emu_state = RS_TERM;
   qsem_post(uc->run_sem);
   //***synchronize here to make sure execution thread has stopped
   qthread_join(uc->process_thread);
#ifdef DEBUG
   msg("uni_exit_process thread joined\n");
#endif
   debug_event_t stop;
#if IDA_SDK_VERSION >= 710
   stop.set_exit_code(::PROCESS_EXIT, 0);
#else
   stop.eid = ::PROCESS_EXIT;
   stop.exit_code = 0;
#endif
   stop.pid = uc->the_process;
   stop.tid = uc->the_threads.front();
#if IDA_SDK_VERSION < 730
   stop.ea = inf.minEA;
#else
   stop.ea = inf_get_min_ea();
#endif
   uc->enqueue_debug_evt(stop);

   return 1;
}

/// Get a pending debug event and suspend the process.
/// This function will be called regularly by IDA.
/// This function is called from debthread.
/// IMPORTANT: commdbg does not expect immediately after a BPT-related event
/// any other event with the same thread/IP - this can cause erroneous
/// restoring of a breakpoint before resume
/// (the bug was encountered 24.02.2015 in pc_linux_upx.elf)
gdecode_t idaapi uni_get_debug_event(debug_event_t *event, int /*timeout_ms*/) {
   sk3wldbg *uc = (sk3wldbg*)dbg;
   if (uc->debug_queue_len() == 0) {
      return GDE_NO_EVENT;
   }
   else {
      uc->dequeue_debug_evt(event);
//      msg("uni_get_debug_event called returning: eid = 0x%08x\n", event->eid);
      //should we ever act on event->eid here?
      return uc->debug_queue_len() > 0 ? GDE_MANY_EVENTS : GDE_ONE_EVENT;
   }
}

/// Continue after handling the event.
/// This function is called from debthread.
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
int idaapi uni_continue_after_event(const debug_event_t *event) {
   sk3wldbg *uc = (sk3wldbg*)dbg;
#if IDA_SDK_VERSION >= 710
   event_id_t eid = event->eid();
#else
   event_id_t eid = event->eid;
#endif
#ifdef DEBUG
   msg("uni_continue_after_event called: eid = 0x%08x\n", eid);
#endif
   if (event == NULL || eid == 2) {// || uc->dbg_evt_list.size() == 0) {
      return 1;
   }
   uc->emu_state = RS_RUN;
   switch (eid) {
      case PROCESS_START:
#ifdef DEBUG
         msg("uni_continue_after_event PROCESS_START\n");
#endif
         qsem_post(uc->run_sem);
         break;
      case PROCESS_EXIT:
#ifdef DEBUG
         msg("uni_continue_after_event PROCESS_EXIT\n");
#endif
         uc->emu_state = RS_TERM;
         qsem_post(uc->run_sem);
         break;
      case THREAD_START:
#ifdef DEBUG
         msg("uni_continue_after_event THREAD_START\n");
#endif
         qsem_post(uc->run_sem);
         break;
      case THREAD_EXIT:
#ifdef DEBUG
         msg("uni_continue_after_event THREAD_EXIT\n");
#endif
         qsem_post(uc->run_sem);
         break;
      case BREAKPOINT:
#ifdef DEBUG
         msg("uni_continue_after_event BREAKPOINT\n");
#endif
         //resume from breakpoint, replace instruction in memory, single step resume again?
         //need to honor resume_mode in this case
         uc->emu_state = uc->resume_mode;
         qsem_post(uc->run_sem);
         break;
      case STEP:
#ifdef DEBUG
         msg("uni_continue_after_event trying to step\n");
#endif
         //state should have been set in set_resume_mode
         //need to honor resume_mode in this case
         uc->emu_state = uc->resume_mode;
         qsem_post(uc->run_sem);
         break;
      case EXCEPTION:
#ifdef DEBUG
         msg("uni_continue_after_event EXCEPTION\n");
#endif
         //give it a try
         qsem_post(uc->run_sem);
         break;
      case LIBRARY_LOAD:
#ifdef DEBUG
         msg("uni_continue_after_event LIBRARY_LOAD\n");
#endif
         qsem_post(uc->run_sem);
         break;
      case LIBRARY_UNLOAD:
#ifdef DEBUG
         msg("uni_continue_after_event LIBRARY_UNLOAD\n");
#endif
         qsem_post(uc->run_sem);
         break;
      case INFORMATION:
#ifdef DEBUG
         msg("uni_continue_after_event INFORMATION\n");
#endif
         break;
#if IDA_SDK_VERSION < 710
      case SYSCALL:
#ifdef DEBUG
         msg("uni_continue_after_event SYSCALL\n");
#endif
         qsem_post(uc->run_sem);
         break;
      case WINMESSAGE:
#ifdef DEBUG
         msg("uni_continue_after_event WINMESSAGE\n");
#endif
         break;
#endif
      case PROCESS_ATTACH:
#ifdef DEBUG
         msg("uni_continue_after_event PRICESS_ATTACH\n");
#endif
         break;
      case PROCESS_DETACH:
#ifdef DEBUG
         msg("uni_continue_after_event PROCESS_DETACH\n");
#endif
         break;
      case PROCESS_SUSPEND:
#ifdef DEBUG
         msg("uni_continue_after_event PROCESS_SUSPEND\n");
#endif
         qsem_post(uc->run_sem);
         break;
      case TRACE_FULL:
#ifdef DEBUG
         msg("uni_continue_after_event TRACE_FULL\n");
#endif
         break;
      case NO_EVENT:
         break;
   }
   return 1;
}

/// Set exception handling.
/// This function is called from debthread or the main thread.
void idaapi uni_set_exception_info(const exception_info_t *info, int qty) {
#ifdef DEBUG
   msg("uni_set_exception_info called\n");
#endif
   for (int i = 0; i < qty; i++) {
      msg("Exception #%d\n", i);
      msg("   Code: 0x%x, flags: 0x%x\n", info[i].code, info[i].flags);
      msg("   Name: %s, Desc: %s\n", info[i].name.c_str(), info[i].desc.c_str());
   }
}

/// This function will be called by the kernel each time
/// it has stopped the debugger process and refreshed the database.
/// The debugger module may add information to the database if it wants.
///
/// The reason for introducing this function is that when an event line
/// LOAD_DLL happens, the database does not reflect the memory state yet
/// and therefore we can't add information about the dll into the database
/// in the get_debug_event() function.
/// Only when the kernel has adjusted the database we can do it.
/// Example: for imported PE DLLs we will add the exported function
/// names to the database.
///
/// This function pointer may be absent, i.e. NULL.
/// This function is called from the main thread.
#if IDA_SDK_VERSION >= 710
void idaapi uni_stopped_at_debug_event(thread_name_vec_t * /*thr_names*/, bool /*dlls_added*/) {
#else
void idaapi uni_stopped_at_debug_event(bool /*dlls_added*/) {
#endif
#ifdef DEBUG
   msg("uni_stopped_at_debug_event called\n");
#endif
}

/// \name Threads
/// The following functions manipulate threads.
/// These functions are called from debthread.
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
int idaapi uni_thread_suspend(thid_t /*tid*/) { ///< Suspend a running thread
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   msg("uni_thread_suspend called\n");
#endif
   uc->pause();
   uc->do_suspend = true;
   //is there an event we need to post to IDA?
   return 1;
}

int idaapi uni_thread_continue(thid_t /*tid*/) { ///< Resume a suspended thread
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   msg("uni_thread_continue called\n");
#endif
   //this is going to have to run in a separate thread otherwise other
   //debthread functions will never get called
   if (uc->do_suspend) {
      uc->do_suspend = false;
   }
   uc->resume();
   return 1;
}

int idaapi uni_set_resume_mode(thid_t /*tid*/, resume_mode_t resmod) { ///< Specify resume action
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   msg("uni_set_resume_mode called. resmod = %d\n", resmod);
#endif
   //*** figure out how best to handle all resume modes
   switch (resmod) {
      case RESMOD_OVER:
         uc->resume_mode = RS_STEP_OVER;
         break;
      case RESMOD_OUT:
         uc->resume_mode = RS_STEP_OUT;
         break;
      case RESMOD_INTO:
         uc->resume_mode = RS_STEP_INTO;
         uc->set_stepping();
         break;
      case RESMOD_NONE:
         uc->resume_mode = RS_RUN;   //????
         break;
      default:
         break;
   }
   return 1;
}

/// Read thread registers.
/// This function is called from debthread.
/// \param tid      thread id
/// \param clsmask  bitmask of register classes to read
/// \param regval   pointer to vector of regvals for all registers.
///                 regval is assumed to have debugger_t::registers_size elements
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_read_registers(thid_t /*tid*/, int clsmask, regval_t *values, qstring * /*errbuf*/) {
#else
int idaapi uni_read_registers(thid_t /*tid*/, int clsmask, regval_t *values) {
#endif
#ifdef DEBUG
   msg("uni_read_registers called\n");
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
   uc_err err = UC_ERR_OK;
   //need to figure out how to do this across all unicorn archs
   for (int i = 0; i < uc->registers_size; i++) {
      if (uc->_registers[i].register_class & clsmask) {
         if (!uc->read_register(i, &values[i])) {
            return 0;
         }
      }
   }
   return 1;
}

/// Write one thread register.
/// This function is called from debthread.
/// \param tid     thread id
/// \param regidx  register index
/// \param regval  new value of the register
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_write_register(thid_t /*tid*/, int regidx, const regval_t *value, qstring * /*errbuf*/) {
#else
int idaapi uni_write_register(thid_t /*tid*/, int regidx, const regval_t *value) {
#endif
#ifdef DEBUG
   msg("uni_write_register called\n");
#endif
   //need to figure out how to do this across all unicorn archs
   sk3wldbg *uc = (sk3wldbg*)dbg;
   uc_err err = uc_reg_write(uc->uc, uc->reg_map[regidx], &value->ival);
   return err == UC_ERR_OK;
}

/// Get information about the base of a segment register.
/// Currently used by the IBM PC module to resolve references like fs:0.
/// This function is called from debthread.
/// \param tid         thread id
/// \param sreg_value  value of the segment register (returned by get_reg_val())
/// \param answer      pointer to the answer. can't be NULL.
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_thread_get_sreg_base(ea_t *answer, thid_t /*tid*/, int /*sreg_value*/, qstring * /*errbuf*/) {
#else
#if IDA_SDK_VERSION >= 700
int idaapi uni_thread_get_sreg_base(ea_t *answer, thid_t /*tid*/, int /*sreg_value*/) {
#else
int idaapi uni_thread_get_sreg_base(thid_t /*tid*/, int /*sreg_value*/, ea_t *answer) {
#endif
#endif
#ifdef DEBUG
   msg("uni_thread_get_sreg_base called\n");
#endif
   //right now unicorn has no way to get this information since base is not a register
   //would need to read decide whether seg is local or global, then UC_X86_REG_L/GDTR,
   //the uc_read_mem to read correct descriptor, then parse out the base address
   *answer = 0;
   return 1;
}

/// \name Memory manipulation
/// The following functions manipulate bytes in the memory.

/// Get information on the memory areas.
/// The debugger module fills 'areas'. The returned vector MUST be sorted.
/// This function is called from debthread.
/// \retval  -3  use idb segmentation
/// \retval  -2  no changes
/// \retval  -1  the process does not exist anymore
/// \retval   0  failed
/// \retval   1  new memory layout is returned
#if IDA_SDK_VERSION >= 710
int idaapi uni_get_memory_info(meminfo_vec_t &areas, qstring * /*errbuf*/) {
#else
int idaapi uni_get_memory_info(meminfo_vec_t &areas) {
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   char msgbuf[4096];
   msg("uni_get_memory_info called\n");
#endif
   uc_mem_region *regions;
   uint32_t count;
   uc_err err = uc_mem_regions(uc->uc, &regions, &count);
#ifdef DEBUG
   msg("uc_mem_regions returned\n");
#endif
   if (err == UC_ERR_OK) {
      for (uint32_t i = 0; i < count; i++) {
         memory_info_t mem;
         mem.startEA = (ea_t)regions[i].begin;
         mem.endEA = (ea_t)regions[i].end - 1;   //-1 because uc_mem_region is inclusive
         mem.perm = uc_to_ida_perms_map[regions[i].perms];
         mem.bitness = 1;  //default to 32
         if (uc->debug_mode & UC_MODE_16) {
            mem.bitness = 0;
         }
         else if (uc->debug_mode & UC_MODE_64) {
            mem.bitness = 2;
         }
         areas.push_back(mem);
#ifdef DEBUG
         _snprintf(msgbuf, sizeof(msgbuf), "   region %d: %p-%p (%d-%d:%d)\n", i,
                  (void*)mem.startEA, (void*)mem.endEA, mem.perm, regions[i].perms, mem.bitness);
         msg("%s", msgbuf);
#endif
      }
      uc_free(regions);
#ifdef DEBUG
      msg("uc_mem_regions returned %d regions\n", count);
#endif
   }
   else {
      msg("Failed on uc_mem_regions() with error returned %u: %s\n", err, uc_strerror(err));
   }
   return 1;
}

/// Read process memory.
/// Returns number of read bytes.
/// This function is called from debthread.
/// \retval 0  read error
/// \retval -1 process does not exist anymore
#if IDA_SDK_VERSION >= 710
ssize_t idaapi uni_read_memory(ea_t ea, void *buffer, size_t size, qstring * /*errbuf*/) {
#else
ssize_t idaapi uni_read_memory(ea_t ea, void *buffer, size_t size) {
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "uni_read_memory called for %p:%d\n", (void*)ea, size);
   msg("%s", msgbuf);
#endif
   uc_err err = uc_mem_read(uc->uc, ea, buffer, size);
   if (err != UC_ERR_OK) {
      msg("Failed on uc_mem_read() with error returned %u: %s\n", err, uc_strerror(err));
   }
   return size;
}

/// Write process memory.
/// This function is called from debthread.
/// \return number of written bytes, -1 if fatal error
#if IDA_SDK_VERSION >= 710
ssize_t idaapi uni_write_memory(ea_t ea, const void *buffer, size_t size, qstring * /*errbuf*/) {
#else
ssize_t idaapi uni_write_memory(ea_t ea, const void *buffer, size_t size) {
#endif
   sk3wldbg *uc = (sk3wldbg*)dbg;
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "uni_write_memory called for %p:%u\n", (void*)ea, (uint32_t)size);
   msg("%s", msgbuf);
#endif
   uc_err err = uc_mem_write(uc->uc, ea, buffer, size);
   if (err != UC_ERR_OK) {
      msg("Failed on uc_mem_write() with error returned %u: %s\n", err, uc_strerror(err));
   }
   return size;
}

/// Is it possible to set breakpoint?.
/// This function is called from debthread or from the main thread if debthread
/// is not running yet.
/// It is called to verify hardware breakpoints.
/// \return ref BPT_
int idaapi uni_is_ok_bpt(bpttype_t type, ea_t ea, int /*len*/) {
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "uni_is_ok_bpt called for %p, type: %d\n", (void*)ea, type);
   msg("%s", msgbuf);
#endif
   //*** test type and setup appropriate actions in hook functions to break
   //    when appropriate
   switch (type) {
      case BPT_EXEC:    //hardware bpt
      case BPT_SOFT:
         //code bpt
         return BPT_OK;
      case BPT_RDWR:
      case BPT_WRITE:
         //data wpt
         //need to make sure read/write hook is installed
      default:
         return BPT_BAD_TYPE;
   }
   return BPT_OK;
}

/// Add/del breakpoints.
/// bpts array contains nadd bpts to add, followed by ndel bpts to del.
/// This function is called from debthread.
/// \return number of successfully modified bpts, -1 if network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_update_bpts(int *nbpts, update_bpt_info_t *bpts, int nadd, int ndel, qstring * /*errbuf*/) {
#else
int idaapi uni_update_bpts(update_bpt_info_t *bpts, int nadd, int ndel) {
#endif
#ifdef DEBUG
   msg("uni_update_bpts called\n");
#endif
   int processed = 0;
   sk3wldbg *uc = (sk3wldbg*)dbg;
   for (int i = 0; i < nadd; i++) {
      uint8_t orig;
      uc_err err = uc_mem_read(uc->uc, bpts[i].ea, &orig, 1);
      if (err == UC_ERR_OK) {
         bpts[i].orgbytes.push_back(orig);
         processed++;
         uc->add_bpt(bpts[i].ea);
      }
   }
   for (int i = nadd; i < (nadd + ndel); i++) {
      uc->del_bpt(bpts[i].ea);
      processed++;
   }
#if IDA_SDK_VERSION >= 710
   *nbpts = processed;
   return DRC_OK;
#else
   return processed;
#endif
}

/// Update low-level (server side) breakpoint conditions.
/// This function is called from debthread.
/// \return nlowcnds. -1-network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_update_lowcnds(int *nupdated, const lowcnd_t * /*lowcnds*/, int nlowcnds, qstring * /*errbuf*/) {
#else
int idaapi uni_update_lowcnds(const lowcnd_t * /*lowcnds*/, int nlowcnds) {
#endif
#ifdef DEBUG
   msg("uni_update_lowcnds called\n");
#endif
   warning("TITLE Under Construction\nICON INFO\nAUTOHIDE NONE\nHIDECANCEL\nConditional breakpoints are currently unimplemented");
#if IDA_SDK_VERSION >= 710
   *nupdated = nlowcnds;
   return DRC_OK;
#else
   return nlowcnds;
#endif
}

/// \name Remote file
/// Open/close/read a remote file.
/// These functions are called from the main thread
/// -1-error
#if IDA_SDK_VERSION >= 700
int idaapi uni_open_file(const char *file, uint64 * /*fsize*/, bool /*readonly*/) {
#else
int idaapi uni_open_file(const char *file, uint32 * /*fsize*/, bool /*readonly*/) {
#endif
#ifdef DEBUG
   msg("uni_open_file called (%s)\n", file);
#endif
   return -1;
}

void idaapi uni_close_file(int /*fn*/) {
#ifdef DEBUG
   msg("uni_close_file called\n");
#endif
   return;
}

#if IDA_SDK_VERSION >= 700
ssize_t idaapi uni_read_file(int /*fn*/, int64 /*off*/, void * /*buf*/, size_t /*size*/) {
#else
ssize_t idaapi uni_read_file(int /*fn*/, uint32 /*off*/, void * /*buf*/, size_t /*size*/) {
#endif
#ifdef DEBUG
   msg("uni_read_file called\n");
#endif
   return -1;
}

/// Map process address.
/// This function may be absent.
/// This function is called from debthread.
/// \param off      offset to map
/// \param regs     current register values. if regs == NULL, then perform
///                 global mapping, which is independent on used registers
///                 usually such a mapping is a trivial identity mapping
/// \param regnum   required mapping. maybe specified as a segment register number
///                 or a regular register number if the required mapping can be deduced
///                 from it. for example, esp implies that ss should be used.
/// \return mapped address or #BADADDR
ea_t idaapi uni_map_address(ea_t off, const regval_t * /*regs*/, int /*regnum*/) {
   ea_t res = BADADDR;
/* TODO
   Lots to be done here. Need to lookup associated segment bas, then add offset
   and check against limit. Return valuse is either base + offset or BADADDR
   For this and other functions, need some helpers that read segment descriptors
*/

/*
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "uni_map_address called for %p\n", (void*)off);
   msg("%s", msgbuf);
*/
/*
   meminfo_vec_t mv;
   uni_get_memory_info(mv);
   for (int i = 0; i < mv.size(); i++) {
      if (mv[i].contains(off)) {
         res = off;
         break;
      }
   }
 */
   return off;
}

/// Set debugger options (parameters that are specific to the debugger module).
/// See the definition of ::set_options_t for arguments.
/// See the convenience function in dbg.hpp if you need to call it.
/// The kernel will call this function after reading the debugger specific
/// config file (arguments are: keyword="", type=#IDPOPT_STR, value="")
/// This function is optional.
/// This function is called from the main thread
//Called with keyword == NULL indicates user has selected "Set specific options" button
// in IDA's Debugger setup dialog
const char *idaapi uni_set_dbg_options(const char *keyword, int /*pri*/,
                                int value_type, const void *value) {
//   msg("uni_set_dbg_options called: %s\n", keyword);
   if (value_type == IDPOPT_STR) {
      msg("   option value: %s\n", (char*)value);
   }
   return IDPOPT_OK;
}

/// Get pointer to debugger specific functions.
/// This function returns a pointer to a structure that holds pointers to
/// debugger module specific functions. For information on the structure
/// layout, please check the corresponding debugger module. Most debugger
/// modules return NULL because they do not have any extensions. Available
/// extensions may be called from plugins.
/// This function is called from the main thread.
const void *idaapi uni_get_debmod_extensions(void) {
#ifdef DEBUG
   msg("uni_get_debmod_extensions called\n");
#endif
   return NULL;
}

/// Calculate the call stack trace.
/// This function is called when the process is suspended and should fill
/// the 'trace' object with the information about the current call stack.
/// If this function is missing or returns false, IDA will use the standard
/// mechanism (based on the frame pointer chain) to calculate the stack trace
/// This function is called from the main thread.
/// \return success
bool idaapi uni_update_call_stack(thid_t /*tid*/, call_stack_t * /*trace*/) {
#ifdef DEBUG
   msg("uni_update_call_stack called\n");
#endif
   warning("TITLE Under Construction\nICON INFO\nAUTOHIDE NONE\nHIDECANCEL\nStack trace is currently unimplemented");
   return false;
}

/// Call application function.
/// This function calls a function from the debugged application.
/// This function is called from debthread
/// \param func_ea      address to call
/// \param tid          thread to use
/// \param fti          type information for the called function
/// \param nargs        number of actual arguments
/// \param regargs      information about register arguments
/// \param stkargs      memory blob to pass as stack arguments (usually contains pointed data)
///                     it must be relocated by the callback but not changed otherwise
/// \param retregs      function return registers.
/// \param[out] errbuf  the error message. if empty on failure, see 'event'.
///                     should not be filled if an appcall exception
///                     happened but #APPCALL_DEBEV is set
/// \param[out] event   the last debug event that occurred during appcall execution
///                     filled only if the appcall execution fails and #APPCALL_DEBEV is set
/// \param options      appcall options, usually taken from \inf{appcall_options}.
///                     possible values: combination of \ref APPCALL_  or 0
/// \return ea of stkargs blob, #BADADDR if failed and errbuf is filled
ea_t idaapi uni_appcall(
     ea_t /*func_ea*/,
     thid_t /*tid*/,
     const struct func_type_data_t * /*fti*/,
     int /*nargs*/,
     const struct regobjs_t * /*regargs*/,
     struct relobj_t * /*stkargs*/,
     struct regobjs_t * /*retregs*/,
     qstring * /*errbuf*/,
     debug_event_t * /*event*/,
     int /*options*/) {

#ifdef DEBUG
   msg("uni_appcall called\n");
#endif
   warning("TITLE Under Construction\nICON INFO\nAUTOHIDE NONE\nHIDECANCEL\nappcall is currently unimplemented");
   return BADADDR;

/*
   sk3wldbg *uc = (sk3wldbg*)dbg;
   if (!uc->save_registers()) {
      *errbuf = "Failed to save current register values";
      return BADADDR;
   }
   uint64_t addr_size = (inf.lflags & LFLG_64BIT) ? 8 :4;
   uint64_t curr_sp = uc->get_sp() & ~0xf; //16 byte align for starters
   curr_sp -= stkargs->size();  //claim the space we need for stack args
   if (uc->call_changes_sp()) {
      //if return address gets saved on the stack account for it
      curr_sp -= addr_size;
   }

   curr_sp &= ~0xf;   //and realign

   if (stkargs->relocate((ea_t)curr_sp, false) == 0) {
      *errbuf = "Failed to relocate stack args";
      return BADADDR;
   }

   //need an address that won't get hit during normal execution of the appcall
   uint64_t appcall_brk = addr_size == 8 ? 0x4141414141414141LL : 0x41414141;
   uc->add_bpt(appcall_brk);

   uc->save_ret_addr(curr_sp);
   //write the stack arguments into the stack
   uc_mem_write(uc->uc, curr_sp + (uc->call_changes_sp() ? addr_size : 0), stkargs->begin(), (size_t)stkargs->size());

   //copy regargs into parameter registers

   //copy parameter registers
   for (uint32_t i = 0; i < regargs->size(); i++) {
      const regobj_t &ri = regargs->at(i);
      int regidx = ri.regidx;
      if (ri.relocate && (ri.size() <= addr_size)) {
         uint64_t relocated = 0;
         memcpy(&relocated, ri.value.begin(), ri.size());
         relocated += curr_sp;
         uc_reg_write(uc->uc, uc->reg_map[regidx], &relocated);
      }
      else {
         uc_reg_write(uc->uc, uc->reg_map[regidx], ri.value.begin());
      }
   }
   uc->set_pc(func_ea);

   //continue execution until we hit the appcall_brk

   if ((options & APPCALL_MANUAL) != 0) {
      return (ea_t)curr_sp;
   }

   //some registers hold return values
   // Retrieve the return value
   if (retregs != NULL) {
      for (uint32_t i = 0; i < retregs->size(); i++) {
         regobj_t &r = retregs->at(i);
         regval_t rv;
         if (uc->read_register(r.regidx, &rv)) {
            memcpy(r.value.begin(), &rv.ival, r.value.size());
            r.relocate = false;
         }
      }
   }

   //now restore pre-appcall context
   uc->restore_registers();
   uc->del_bpt(appcall_brk);

   return (ea_t)curr_sp;
*/
}

/// Cleanup after appcall().
/// The debugger module must keep the stack blob in the memory until this function
/// is called. It will be called by the kernel for each successful appcall().
/// There is an exception: if #APPCALL_MANUAL, IDA may not call cleanup_appcall.
/// If the user selects to terminate a manual appcall, then cleanup_appcall will be called.
/// Otherwise, the debugger module should terminate the appcall when the called
/// function returns.
/// This function is called from debthread.
/// \retval  2  ok, there are pending events
/// \retval  1  ok
/// \retval  0  failed
/// \retval -1  network error
int idaapi uni_cleanup_appcall(thid_t /*tid*/) {
#ifdef DEBUG
   msg("uni_cleanup_appcall called\n");
#endif
   return 1;

/*
   sk3wldbg *uc = (sk3wldbg*)dbg;
   uc->restore_registers();

   //remove breakpoint at end of function
*/
}

/// Evaluate a low level breakpoint condition at 'ea'.
/// Other evaluation errors are displayed in a dialog box.
/// This call is rarely used by IDA when the process has already been suspended
/// for some reason and it has to decide whether the process should be resumed
/// or definitely suspended because of a breakpoint with a low level condition.
/// This function is called from debthread.
/// \retval  1  condition is satisfied
/// \retval  0  not satisfied
/// \retval -1  network error
#if IDA_SDK_VERSION >= 710
int idaapi uni_eval_lowcnd(thid_t /*tid*/, ea_t ea, qstring * /*errbuf*/) {
#else
int idaapi uni_eval_lowcnd(thid_t /*tid*/, ea_t ea) {
#endif
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "uni_eval_lowcnd called: %p\n", (void*)ea);
   msg("%s", msgbuf);
#endif
//   warning("TITLE Under Construction\nICON INFO\nAUTOHIDE NONE\nHIDECANCEL\nConditional breakpoints are currently unimplemented");
   return 1;
}

/// This function is called from main thread
#if IDA_SDK_VERSION >= 700
ssize_t idaapi uni_write_file(int /*fn*/, int64 /*off*/, const void * /*buf*/, size_t /*size*/) {
#else
ssize_t idaapi uni_write_file(int /*fn*/, uint32 /*off*/, const void * /*buf*/, size_t /*size*/) {
#endif
#ifdef DEBUG
   msg("uni_write_file called\n");
#endif
   return -1;
}

/// Perform a debugger-specific function.
/// This function is called from debthread
int idaapi uni_send_ioctl(int /*fn*/, const void * /*buf*/, size_t /*size*/, void ** /*poutbuf*/, ssize_t * /*poutsize*/) {
#ifdef DEBUG
   msg("uni_send_ioctl called\n");
#endif
   return -1;
}

/// Enable/Disable tracing.
/// "trace_flags" can be a set of STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE.
/// See thread_t::trace_mode in debugger.h.
/// This function is called from the main thread.
bool idaapi uni_dbg_enable_trace(thid_t /*tid*/, bool /*enable*/, int /*trace_flags*/) {
#ifdef DEBUG
   msg("uni_dbg_enable_trace called\n");
#endif
   warning("TITLE Under Construction\nICON INFO\nAUTOHIDE NONE\nHIDECANCEL\naTracing is currently unimplemented");
   return false;
}

/// Is tracing enabled? ONLY used for tracers.
/// "trace_bit" can be one of the following: STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE
bool idaapi uni_is_tracing_enabled(thid_t /*tid*/, int /*tracebit*/) {
#ifdef DEBUG
   msg("uni_is_tracing_enabled called\n");
#endif
   return false;
}

/// Execute a command on the remote computer.
/// \return exit code
int idaapi uni_rexec(const char *cmdline) {
#ifdef DEBUG
   msg("uni_rexec called (%s)\n", cmdline);
#endif
   return 0;
}

/// Get (store to out_pattrs) process/debugger-specific runtime attributes.
/// This function is called from main thread.
void idaapi uni_get_debapp_attrs(debapp_attrs_t *out_pattrs) {
#ifdef DEBUG
   msg("uni_get_debapp_attrs called\n");
#endif
#if IDA_SDK_VERSION < 730
   bool is64 = (inf.lflags & LFLG_64BIT) != 0;
   filetype_t filetype = (filetype_t)inf.filetype;
#else
   bool is64 = inf_is_64bit();
   filetype_t filetype = inf_get_filetype();
#endif
   out_pattrs->addrsize = is64 ? 8 :4;
   if (filetype == f_PE) {
      if (is64) {
         out_pattrs->platform = "win64";
      }
      else {
         out_pattrs->platform = "win32";
      }
   }
   else if (filetype == f_ELF) {
      if (is64) {
         out_pattrs->platform = "linux64";
      }
      else {
         out_pattrs->platform = "linux";
      }
   }
   else if (filetype == f_MACHO) {
      if (is64) {
         out_pattrs->platform = "macosx64";
      }
      else {
         out_pattrs->platform = "macosx";
      }
   }
   else {
      out_pattrs->platform = "unk";
   }
   return;
}

#if IDA_SDK_VERSION >= 700
bool idaapi uni_get_srcinfo_path(qstring *path, ea_t base) {
   return false;
}
#endif

#if IDA_SDK_VERSION >= 710
drc_t uni_bin_search(ea_t * /*ea*/, ea_t /*start_ea*/, ea_t /*end_ea*/,
                     const compiled_binpat_vec_t * /*ptns*/, int /*srch_flags*/,
                     qstring * /*errbuf*/) {
   return DRC_NONE;
}
#endif


sk3wldbg::sk3wldbg(const char *procname, uc_arch arch, uc_mode mode, const char *cpu_model) {
   version = IDD_INTERFACE_VERSION;
   uc = NULL;
   name = "sk3wldbg";
   debug_arch = arch;
   debug_mode = mode;
   if (cpu_model != NULL) {
      this->cpu_model = cpu_model;
   }
   evt_mutex = qmutex_create();
   run_sem = qsem_create(NULL, 0);
   emu_state = RS_INIT;
   resume_mode = RS_RUN;
   process_thread = NULL;
   saved = NULL;
   code_hook = 0;
   mem_fault_hook = 0;
   ihook = 0;
   thumb = 0;

#ifdef __NT__
   hProv = NULL;
#else
   hProv = -1;
#endif

   do_suspend = false;
   finished = false;
   single_step = false;
   registered_menu = false;
#if IDA_SDK_VERSION >= 730
   bool is_be = inf_is_be();
#elif IDA_SDK_VERSION >= 700
   bool is_be = inf.is_be();
#else
   bool is_be = inf.mf;
#endif
   if (is_be) {
      debug_mode = (uc_mode)((int)UC_MODE_BIG_ENDIAN | (int)debug_mode);
      msg("sk3wldbg: Setting Big-Endian mode\n");
   }

   id = 0x100;       //debugger id. Can we use one of the existing constants?
   processor = procname;
   flags =   DBG_FLAG_CAN_CONT_BPT | DBG_FLAG_SAFE | DBG_FLAG_DEBTHREAD
           | DBG_FLAG_DEBUG_DLL | DBG_FLAG_ANYSIZE_HWBPT;
            /* maybe use DBG_FLAG_FAKE_MEMORY also */
#if IDA_SDK_VERSION >= 710
   flags2 = DBG_HAS_GET_PROCESSES | DBG_HAS_DETACH_PROCESS | DBG_HAS_REQUEST_PAUSE |
            DBG_HAS_SET_EXCEPTION_INFO | DBG_HAS_THREAD_SUSPEND | DBG_HAS_THREAD_CONTINUE |
            DBG_HAS_SET_RESUME_MODE | DBG_HAS_CHECK_BPT;
#endif

#if IDA_SDK_VERSION < 730
   filetype = (uint8_t)inf.filetype;
#else
   filetype = inf_get_filetype();
#endif

   memory_page_size = 0x1000;
   memmgr = NULL;

   //SET THE FOLLOWING IN YOUR PROCESSOR SPECIFIC SUBCLASS
   register_classes = NULL;
   register_classes_default = 0;    ///< Mask of default printed register classes
   _registers = NULL;               ///< Array of registers. Use registers() to access it
   registers_size = 0;              ///< Number of registers
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

   resume_modes = DBG_RESMOD_STEP_INTO | DBG_RESMOD_STEP_OVER | DBG_RESMOD_STEP_OUT;
                  /* maybe also RESMOD_HANDLE */

   set_dbg_options =             uni_set_dbg_options;

#if IDA_SDK_VERSION < 710
   init_debugger =               uni_init_debugger;
   term_debugger =               uni_term_debugger;
#if IDA_SDK_VERSION >= 700
   get_processes =               uni_get_processes;
#else
   process_get_info =            uni_process_get_info;
#endif
   start_process =               uni_start_process;
   attach_process =              uni_attach_process;
   detach_process =              uni_detach_process;
   rebase_if_required_to =       uni_rebase_if_required_to;
   prepare_to_pause_process =    uni_prepare_to_pause_process;
   exit_process =                uni_exit_process;
   get_debug_event =             uni_get_debug_event;
   continue_after_event =        uni_continue_after_event;
   set_exception_info =          uni_set_exception_info;
   stopped_at_debug_event =      uni_stopped_at_debug_event;
   thread_suspend =              uni_thread_suspend;
   thread_continue =             uni_thread_continue;
   set_resume_mode =             uni_set_resume_mode;
   read_registers =              uni_read_registers;
   write_register =              uni_write_register;
   thread_get_sreg_base =        uni_thread_get_sreg_base;
   get_memory_info =             uni_get_memory_info;
   read_memory =                 uni_read_memory;
   write_memory =                uni_write_memory;
   is_ok_bpt =                   uni_is_ok_bpt;
   update_bpts =                 uni_update_bpts;
   update_lowcnds =              uni_update_lowcnds;
   open_file =                   uni_open_file;
   close_file =                  uni_close_file;
   read_file =                   uni_read_file;
   map_address =                 uni_map_address;
   get_debmod_extensions =       uni_get_debmod_extensions;
   update_call_stack =           uni_update_call_stack;
   appcall =                     uni_appcall;
   cleanup_appcall =             uni_cleanup_appcall;
   eval_lowcnd =                 uni_eval_lowcnd;
   write_file =                  uni_write_file;
   send_ioctl =                  uni_send_ioctl;
   dbg_enable_trace =            uni_dbg_enable_trace;
   is_tracing_enabled =          uni_is_tracing_enabled;
   rexec =                       uni_rexec;
   get_debapp_attrs =            uni_get_debapp_attrs;
#if IDA_SDK_VERSION >= 700
   get_srcinfo_path =            uni_get_srcinfo_path;
#endif

#else  //IDA_SDK_VERSION < 710

   callback = idd_hook;

#endif //IDA_SDK_VERSION < 710

}

sk3wldbg::~sk3wldbg() {
   qmutex_free(evt_mutex);
   qsem_free(run_sem);
   if (hProv) {
#ifdef __NT__
      CryptReleaseContext(hProv, 0);
#else
      ::close(hProv);
#endif
   }
   if (memmgr) {
      //is this going to take care of all the mappings
      //replace the memmap vector with this???
      delete memmgr;
      memmgr = NULL;
   }
   for (vector<void*>::iterator i = memmap.begin(); i != memmap.end(); i++) {
      qfree(*i);
   }
}

void sk3wldbg::enqueue_debug_evt(debug_event_t &evt) {
#ifdef DEBUG
   char msgbuf[4096];
#if IDA_SDK_VERSION >= 710
   _snprintf(msgbuf, sizeof(msgbuf), "Queueing event eid = %d, ea = %p\n", evt.eid(), (void*)evt.ea);
#else
   _snprintf(msgbuf, sizeof(msgbuf), "Queueing event eid = %d, ea = %p\n", evt.eid, (void*)evt.ea);
#endif
   msg("%s", msgbuf);
#endif
   qmutex_lock(evt_mutex);
   dbg_evt_list.push_back(evt);
   qmutex_unlock(evt_mutex);
}

bool sk3wldbg::dequeue_debug_evt(debug_event_t *out) {
   if (debug_queue_len() == 0) {
      return false;
   }
   qmutex_lock(evt_mutex);
   *out = dbg_evt_list.front();
   dbg_evt_list.pop_front();
   qmutex_unlock(evt_mutex);
   return true;
}

void sk3wldbg::close() {
   if (code_hook) {
      uc_hook_del(uc, code_hook);
      code_hook = 0;
   }
   if (mem_fault_hook) {
      uc_hook_del(uc, mem_fault_hook);
      mem_fault_hook = 0;
   }
   if (ihook) {
      uc_hook_del(uc, ihook);
      ihook = 0;
   }

   detach_action_from_menu("Debugger/Take memory snapshot", "sk3wldbg:mem_map");

//   safe_msg req("sk3wldbg: closing unicorn instance\n");
//   execute_sync(req, MFF_FAST);
//   msg("sk3wldbg: closing unicorn instance\n");
   uc_close(uc);
//   uc = NULL;
}

void sk3wldbg::runtime_exception(uc_err err, uint64_t pc) {
   char errmsg[1024];
   errmsg[0] = 0;
#ifdef DEBUG
   _snprintf(errmsg, sizeof(errmsg), "runtime_exception(0x%x, %p)", (uint32_t)err, (void*)pc);
   msg("%s\n", errmsg);
#endif
   switch (err) {
      case UC_ERR_READ_UNMAPPED:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at 0x%p attempted to read from unmapped memory", (void*)pc);
         break;
      case UC_ERR_WRITE_UNMAPPED:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to write to unmapped memory", (void*)pc);
         break;
      case UC_ERR_FETCH_UNMAPPED:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to execute from unmapped memory", (void*)pc);
         break;
      case UC_ERR_WRITE_PROT:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to write to write protected memory", (void*)pc);
         break;
      case UC_ERR_READ_PROT:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to read from read protected unmapped memory", (void*)pc);
         break;
      case UC_ERR_FETCH_PROT:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to fetch from NX memory", (void*)pc);
         break;
   }
   queue_exception_event(11, pc, errmsg);
}

void sk3wldbg::start(uint64_t pc) {
   check_mode((ea_t)pc);
   qsem_wait(run_sem, -1);
   //not a fan of mentioning thumb here, need to push this back down to ARM specific code
   //to force unicorn to begin in thumb mode, low bit of address needs to be set
   uc_err err = uc_emu_start(uc, pc | thumb, (uint64_t)-1, 0, 0);
   if (err != UC_ERR_OK) {
      runtime_exception(err, get_pc());
   }
}

void sk3wldbg::pause() {
   emu_state = RS_PAUSE;
}

void sk3wldbg::resume() {
   emu_state = RS_RUN;
   qsem_post(run_sem);
}

bool sk3wldbg::open() {
//   uc_err err = uc_open(debug_arch, debug_mode, cpu_model.c_str(), &uc);
#ifdef DEBUG
   msg("uc_open mode is 0x%0x\n", debug_mode);
#endif
   uc_err err = uc_open(debug_arch, debug_mode, &uc);
   if (err) {
      msg("Failed on uc_open() with error returned: %u\n", err);
      return false;
   }
   memmgr = new mem_mgr(uc);
   msg("sk3wldbg::open uc == %p, memmgr = %p\n", this, memmgr);
   install_initial_hooks();
   return true;
}

void sk3wldbg::init_memmgr(uint64_t map_min, uint64_t map_max) {
   if (memmgr == NULL) {
      memmgr = new mem_mgr(uc, map_min, map_max);
   }
   else {
      memmgr->set_mmap_region(map_min, map_max);
   }
}

void sk3wldbg::map_mem_copy(uint64_t startAddr, uint64_t endAddr, unsigned int perms, void *src) {
   uint64_t exact = endAddr - startAddr;
   char *block = (char*)map_mem_zero(startAddr, endAddr, perms, SDB_MAP_FIXED);
   if (block) {
      memcpy(block, src, (size_t)exact);
   }
}

/*
void *sk3wldbg::map_mem_zero(uint64_t startAddr, uint64_t endAddr, unsigned int perms) {
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "map_mem_zero(%p, %p, 0x%x)\n", (void*)startAddr, (void*)endAddr, perms);
   msg("%s", msgbuf);
   endAddr = (endAddr + 0xfff) & ~0xfff;
   uint64_t pageAddr = startAddr & ~0xfff;
   uint64_t blockSize = endAddr - pageAddr;
   void *block = qcalloc((size_t)blockSize, 1);
   if (block) {
      uc_err err = uc_mem_map_ptr(uc, pageAddr, (size_t)blockSize, perms, block);
      if (err != UC_ERR_OK) {
         msg("Failed on uc_mem_map() with error returned %u: %s\n", err, uc_strerror(err));
         qfree(block);
      }
      else {
         memmap.push_back(block);
         //return a pointer to the byte corresponding to startAddr
         //this may not be the first byte of block if startAddr was not page aligned
         return (startAddr - pageAddr) + (char*)block;
      }
   }
   return NULL;
}
*/

void *sk3wldbg::map_mem_zero(uint64_t startAddr, uint64_t endAddr, unsigned int perms, uint32_t flags) {
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "map_mem_zero(%p, %p, 0x%x)\n", (void*)startAddr, (void*)endAddr, perms);
   msg("%s", msgbuf);
   endAddr = (endAddr + 0xfff) & ~0xfff;
   uint64_t pageAddr = startAddr & ~0xfff;
   uint64_t blockSize = endAddr - pageAddr;
   if (blockSize & 0xffffffff00000000ll) {
      //too large
      msg("Size too large in map_mem_zero\n");
      return NULL;
   }
   // for now we cheat and make all sections rwx in unicorn to easily handle self modifying code
   // we would need to handle mprotect and VirtualProtect-like functions to catch permission changes
   perms = UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC;
   map_block *b = memmgr->mmap(pageAddr, (uint32_t)blockSize, perms, flags);
   if (b) {
      //return a pointer to the byte corresponding to startAddr
      //this may not be the first byte of block if startAddr was not page aligned
      _snprintf(msgbuf, sizeof(msgbuf), "Allocated at %p in map_mem_zero\n", (void*)startAddr);
      msg("%s", msgbuf);
      return (startAddr - pageAddr) + (char*)b->host;
   }
   _snprintf(msgbuf, sizeof(msgbuf), "Failed to allocate at %p in map_mem_zero\n", (void*)startAddr);
   msg("%s", msgbuf);
   return NULL;
}

void sk3wldbg::getRandomBytes(void *buf, unsigned int len) {
#ifdef __NT__
   if (hProv == 0) {
      CryptAcquireContext(&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT);
   }
   CryptGenRandom(hProv, len, (BYTE*)buf);
#else
   if (hProv == -1) {
      hProv = ::open("/dev/urandom", O_RDONLY);
   }
   read(hProv, buf, len);
#endif
}

void sk3wldbg::add_bpt(uint64_t bpt_addr) {
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "add_bpt: %p\n", (void*)bpt_addr);
   msg("%s", msgbuf);
#endif
   breakpoints.insert(bpt_addr);
}

void sk3wldbg::del_bpt(uint64_t bpt_addr) {
#ifdef DEBUG
   char msgbuf[4096];
   _snprintf(msgbuf, sizeof(msgbuf), "del_bpt: %p\n", (void*)bpt_addr);
   msg("%s", msgbuf);
#endif
   breakpoints.erase(bpt_addr);
}

uint64_t sk3wldbg::get_pc() {
   uint64_t pc = 0;
   for (int i = 0; i < registers_size; i++) {
      if (_registers[i].flags & REGISTER_IP) {
         uc_err err = uc_reg_read(uc, reg_map[i], &pc);
         if (err == UC_ERR_OK) {
            return pc;
         }
         break;
      }
   }
   return (uint64_t)-1LL;
}

bool sk3wldbg::set_pc(uint64_t pc) {
#ifdef DEBUG
   char buf[4096];
   _snprintf(buf, sizeof(buf), "set_pc called to set to %p\n", (void*)pc);
   msg("%s", buf);
#endif
   for (int i = 0; i < registers_size; i++) {
      if (_registers[i].flags & REGISTER_IP) {
         uc_err err = uc_reg_write(uc, reg_map[i], &pc);
         if (err == UC_ERR_OK) {
            return true;
         }
         break;
      }
   }
   return false;
}

uint64_t sk3wldbg::get_sp() {
   uint64_t sp = 0;
   for (int i = 0; i < registers_size; i++) {
      if (_registers[i].flags & REGISTER_SP) {
         uc_err err = uc_reg_read(uc, reg_map[i], &sp);
         if (err == UC_ERR_OK) {
            return sp;
         }
         break;
      }
   }
   return (uint64_t)-1LL;
}

bool sk3wldbg::set_sp(uint64_t sp) {
   for (int i = 0; i < registers_size; i++) {
      if (_registers[i].flags & REGISTER_SP) {
         uc_err err = uc_reg_write(uc, reg_map[i], &sp);
         if (err == UC_ERR_OK) {
            return true;
         }
         break;
      }
   }
   return false;
}

void intr_hook(uc_engine *uc, uint32_t intno, void *user_data) {
   char errmsg[1024];
   errmsg[0] = 0;
#ifdef DEBUG
   qsnprintf(errmsg, sizeof(errmsg), "intr_hook(0x%x)", intno);
   msg("%s\n", errmsg);
#endif
}

bool generic_mem_fault_hook(uc_engine *uc, uc_mem_type type, uint64_t address,
                            int /*size*/, int64_t value, sk3wldbg *dbg) {
   uint64_t pc = dbg->get_pc();
   char errmsg[1024];
   errmsg[0] = 0;
#ifdef DEBUG
   _snprintf(errmsg, sizeof(errmsg), "generic_mem_fault_hook(0x%x, %p)", (uint32_t)type, (void*)address);
   msg("%s\n", errmsg);
#endif
   switch (type) {
      case UC_MEM_READ_UNMAPPED:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to read from unmapped memory", (void*)pc);
         break;
      case UC_MEM_WRITE_UNMAPPED:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to write to unmapped memory", (void*)pc);
         break;
      case UC_MEM_FETCH_UNMAPPED:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to execute from unmapped memory", (void*)pc);
         break;
      case UC_MEM_WRITE_PROT:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to write to write protected memory", (void*)pc);
         break;
      case UC_MEM_READ_PROT:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to read from read protected unmapped memory", (void*)pc);
         break;
      case UC_MEM_FETCH_PROT:
         _snprintf(errmsg, sizeof(errmsg), "The instruction at %p attempted to fetch from NX memory", (void*)pc);
         break;
   }
   dbg->queue_exception_event(11, address, errmsg);
   return false;
}

//This function is called from within the unicorn thread
//We do all checking for debugger related events at each instruction here
void generic_code_hook(uc_engine *uc, uint64_t address, uint32_t size, sk3wldbg *dbg) {
   bool stopping = false;
#ifdef DEBUG
   char buf[1204];
   _snprintf(buf, sizeof(buf), "code hit at: %p, expecting to exec %p\n", (void*)address, (void*)get_dword((ea_t)address));
   do_safe_msg(buf);
   uint32_t opc;
   uc_mem_read(dbg->uc, address, &opc, sizeof(opc));
   qsnprintf(buf, sizeof(buf), "really executing 0x%x\n", opc);
   do_safe_msg(buf);
/*
   uint32_t *cp = (uint32_t*)dbg->memmgr->to_host_ptr(address);
   if (cp == NULL) {
      ::qsnprintf(buf, sizeof(buf), "dereffing mem ptr yields a NULL ptr\n");
   }
   else {
      ::qsnprintf(buf, sizeof(buf), "dereffing mem ptr yields 0x%x\n", *cp);
   }
   do_safe_msg(buf);
*/
#endif
   bool is_brk = false;
   if (dbg->breakpoints.find((ea_t)address) != dbg->breakpoints.end()) {
      //this is a breakpoint
      dbg->set_state(RS_BREAK);
      //tell IDA we hit a breakpoint
      dbg->queue_dbg_event(false);
      is_brk = true;
#ifdef DEBUG
      do_safe_msg("This is a breakpoint\n");
#endif
   }
   if (dbg->tbreaks.find((ea_t)address) != dbg->tbreaks.end() || dbg->is_stepping()) {
      //this is a temproary breakpoint
      dbg->tbreaks.erase((ea_t)address);
      if (!is_brk) {
         //don't want to queue both a breakpoint and a step event at same address
         dbg->set_state(RS_BREAK);
         dbg->queue_step_event(address);
      }
      dbg->clear_stepping();
#ifdef DEBUG
      do_safe_msg("This is a step break\n");
#endif
   }
#ifdef DEBUG
   ::qsnprintf(buf, sizeof(buf), "emu_state: %d\n", dbg->get_state());
   do_safe_msg(buf);
#endif
   switch (dbg->get_state()) {
      case RS_BREAK:
         //need to wait for resume from user
      case RS_PAUSE:
         //we are paused until user causes qsem_post to get called
      case RS_INIT:
         //first time in, wait for the signal to go
#ifdef DEBUG
         do_safe_msg("code_hook is waiting\n");
#endif
         qsem_wait(dbg->run_sem, -1);
#ifdef DEBUG
         do_safe_msg("code_hook done waiting\n");
#endif
         //at this point user wants to run or term
         break;
      case RS_RUN:
         //no need to stop if we are running
         break;
      case RS_STEP_INTO:
         //indicate we want to break at next instruction
         dbg->set_stepping();
         break;
      case RS_STEP_OVER:
         //add a breakpoint at the return address
         dbg->tbreaks.insert((ea_t)address + size);
         //and keep running
         break;
      case RS_STEP_OUT:
         //*** not implemented, start balancing calls (+1) against rets (-1) until count == -1
         dbg->set_stepping();
//         dbg->tbreaks.insert((ea_t)address + size);
         break;
      case RS_TERM:
         //break out of emulation loop
         uc_emu_stop(uc);
         stopping = true;
         break;
   }

#ifdef DEBUG
   ea_t cpc = (ea_t)dbg->get_pc();
   _snprintf(buf, sizeof(buf), "pc out of break is: %p\n", (void*)cpc);
   do_safe_msg(buf);
#endif

   uint8_t *inst = new uint8_t[size]; //change over to to_host_ptr when mem_mgr gets integrated
   uc_mem_read(uc, address, inst, size);
   if (!stopping && dbg->is_system_call(inst, size)) {
      dbg->handle_system_call(inst, size);
   }
   delete [] inst;

#ifdef DEBUG
   cpc = (ea_t)dbg->get_pc();
   _snprintf(buf, sizeof(buf), "pc leaving is: %p\n", (void*)cpc);
   do_safe_msg(buf);
#endif

}

run_state sk3wldbg::get_state() {
   return emu_state;
}

void sk3wldbg::set_state(run_state new_state) {
   emu_state = new_state;
}

void sk3wldbg::install_initial_hooks() {
   uc_err err = uc_hook_add(uc, &code_hook, UC_HOOK_CODE, (void*)generic_code_hook, this, 1, 0);
   if (err) {
      code_hook = 0;
      msg("Failed on uc_hook_add(generic_code_hook) with error returned: %u\n", err);
   }
   err = uc_hook_add(uc, &mem_fault_hook, UC_HOOK_MEM_INVALID, (void*)generic_mem_fault_hook, this, 1, 0);
   if (err) {
      mem_fault_hook = 0;
      msg("Failed on uc_hook_add(generic_mem_fault_hook) with error returned: %u\n", err);
   }
/*
   err = uc_hook_add(uc, &ihook, UC_HOOK_INTR, (void*)intr_hook, this, 1, 0);
   if (err) {
      ihook = 0;
      msg("Failed on uc_hook_add(intr_hook) with error returned: %u\n", err);
   }
*/
}

bool sk3wldbg::read_register(int regidx, regval_t *value) {
   int32_t rtype = RVT_INT;
#if IDA_SDK_VERSION >= 700
   op_dtype_t dt = _registers[regidx].dtype;
#else
   char dt = _registers[regidx].dtyp;
#endif
   if (dt == dt_float || dt == dt_double) {
      rtype = RVT_FLOAT;
   }
   value->rvtype = rtype;
   return uc_reg_read(uc, reg_map[regidx], &value->ival) == UC_ERR_OK;
}

bool sk3wldbg::save_registers() {
   if (saved != NULL) {
      //this should not happen, but what if it does?
      qfree(saved);
      saved = NULL;
   }
   saved = (regval_t*)qalloc(sizeof(regval_t) * registers_size);
#if IDA_SDK_VERSION >= 710
   qstring errbuf;
   if (uni_read_registers(0, -1, saved, &errbuf) == 0) {
#else
   if (uni_read_registers(0, -1, saved) == 0) {
#endif
      qfree(saved);
      saved = NULL;
      return false;
   }
   return true;
}

bool sk3wldbg::restore_registers() {
   if (saved == NULL ) {
      return false;
   }
   for (int regidx = 0; regidx < registers_size; regidx++) {
      uc_err err = uc_reg_write(uc, reg_map[regidx], &saved->ival);
   }
   qfree(saved);
   saved = NULL;
   return true;
}

//return non-zero to have ida refresh all windows
int idaapi mem_map_action_handler::activate(action_activation_ctx_t *ctx) {
   uint64_t base = 0;
   uint64_t size = 0x1000;
   uint16_t perms = 3;
   int ok;
   sk3wldbg *uc = (sk3wldbg*)dbg;
//   msg("mem_map_action_handler activated\n");
   ok = AskUsingForm_c("Map Memory Region\n\n\n<Start address:L:18:20::>\n<Region size  :L:18:20::><Read:C>\n<Write:C>\n<Exec:C>>\n", &base, &size, &perms);
   if (ok) {
      if (base & 0xfff) {
         warning("AUTOHIDE NONE\nHIDECANCEL\nRegion base address must be page aligned");
      }
      else if (size & 0xfff) {
         warning("AUTOHIDE NONE\nHIDECANCEL\nRegion size must be page aligned");
      }
      else {
         //we need to make sure that unicorn is paused when we do this
//         uc_err err = uc_mem_map(uc->uc, base, (size_t)size, perms);
      }
   }
   return 0;
}

action_state_t idaapi mem_map_action_handler::update(action_update_ctx_t *ctx) {
//   msg("mem_map_action_handler::update called\n");
   return AST_ENABLE_ALWAYS;
}

#if IDA_SDK_VERSION >= 710

static ssize_t idaapi idd_hook(void * /* ud */, int notification_code, va_list va) {
   sk3wldbg *uc = (sk3wldbg*)dbg;

   int retcode = DRC_NONE;
   qstring *errbuf;

   switch (notification_code) {
      case debugger_t::ev_init_debugger: {
         const char *hostname = va_arg(va, const char *);
         int portnum = va_arg(va, int);
         const char *password = va_arg(va, const char *);
         errbuf = va_arg(va, qstring *);
         return uni_init_debugger(hostname, portnum, password, errbuf);
      }

      case debugger_t::ev_term_debugger:
         return uni_term_debugger();

      case debugger_t::ev_get_processes: {
         procinfo_vec_t *procs = va_arg(va, procinfo_vec_t *);
         errbuf = va_arg(va, qstring *);
         return uni_get_processes(procs, errbuf);
      }

      case debugger_t::ev_start_process: {
         const char *path = va_arg(va, const char *);
         const char *args = va_arg(va, const char *);
         const char *startdir = va_arg(va, const char *);
         uint32 dbg_proc_flags = va_arg(va, uint32);
         const char *input_path = va_arg(va, const char *);
         uint32 input_file_crc32 = va_arg(va, uint32);
         errbuf = va_arg(va, qstring *);
         return uni_start_process(path, args, startdir, dbg_proc_flags,
                                input_path, input_file_crc32, errbuf);
      }

      case debugger_t::ev_attach_process: {
         pid_t pid = va_argi(va, pid_t);
         int event_id = va_arg(va, int);
         uint32 dbg_proc_flags = va_arg(va, uint32);
         errbuf = va_arg(va, qstring *);
         return uni_attach_process(pid, event_id, dbg_proc_flags, errbuf);
      }

      case debugger_t::ev_detach_process:
         return uni_detach_process();

      case debugger_t::ev_get_debapp_attrs: {
         debapp_attrs_t *out_pattrs = va_arg(va, debapp_attrs_t *);
         uni_get_debapp_attrs(out_pattrs);
         return DRC_OK;
      }

      case debugger_t::ev_rebase_if_required_to: {
         ea_t new_base = va_arg(va, ea_t);
         uni_rebase_if_required_to(new_base);
         return DRC_OK;
      }

      case debugger_t::ev_request_pause:
         errbuf = va_arg(va, qstring *);
         return uni_prepare_to_pause_process(errbuf);

      case debugger_t::ev_exit_process:
         errbuf = va_arg(va, qstring *);
         return uni_exit_process(errbuf);

      case debugger_t::ev_get_debug_event: {
         gdecode_t *code = va_arg(va, gdecode_t *);
         debug_event_t *event = va_arg(va, debug_event_t *);
         int timeout_ms = va_arg(va, int);
         *code = uni_get_debug_event(event, timeout_ms);
         return DRC_OK;
         break;
      }

      case debugger_t::ev_resume: {
         debug_event_t *event = va_arg(va, debug_event_t *);
         return uni_continue_after_event(event);
      }

      case debugger_t::ev_set_exception_info: {
         exception_info_t *info = va_arg(va, exception_info_t *);
         int qty = va_arg(va, int);
         uni_set_exception_info(info, qty);
         return DRC_OK;
      }

      case debugger_t::ev_suspended: {
         bool dlls_added = va_argi(va, bool);
         thread_name_vec_t *thr_names = va_arg(va, thread_name_vec_t *);
         uni_stopped_at_debug_event(thr_names, dlls_added);
         return DRC_OK;
      }

      case debugger_t::ev_thread_suspend: {
         thid_t tid = va_argi(va, thid_t);
         return uni_thread_suspend(tid);
      }

      case debugger_t::ev_thread_continue: {
         thid_t tid = va_argi(va, thid_t);
         return uni_thread_continue(tid);
      }

      case debugger_t::ev_set_resume_mode: {
         thid_t tid = va_argi(va, thid_t);
         resume_mode_t resmod = va_argi(va, resume_mode_t);
         return uni_set_resume_mode(tid, resmod);
      }

      case debugger_t::ev_read_registers: {
         thid_t tid = va_argi(va, thid_t);
         int clsmask = va_arg(va, int);
         regval_t *values = va_arg(va, regval_t *);
         errbuf = va_arg(va, qstring *);
         return uni_read_registers(tid, clsmask, values, errbuf);
      }

      case debugger_t::ev_write_register: {
         thid_t tid = va_argi(va, thid_t);
         int regidx = va_arg(va, int);
         const regval_t *value = va_arg(va, const regval_t *);
         errbuf = va_arg(va, qstring *);
         return uni_write_register(tid, regidx, value, errbuf);
      }

      case debugger_t::ev_thread_get_sreg_base: {
         ea_t *answer = va_arg(va, ea_t *);
         thid_t tid = va_argi(va, thid_t);
         int sreg_value = va_arg(va, int);
         errbuf = va_arg(va, qstring *);
         return uni_thread_get_sreg_base(answer, tid, sreg_value, errbuf);
      }

      case debugger_t::ev_get_memory_info: {
         meminfo_vec_t *ranges = va_arg(va, meminfo_vec_t *);
         errbuf = va_arg(va, qstring *);
         return uni_get_memory_info(*ranges, errbuf);
      }

      case debugger_t::ev_read_memory: {
         size_t *nbytes = va_arg(va, size_t *);
         ea_t ea = va_arg(va, ea_t);
         void *buffer = va_arg(va, void *);
         size_t size = va_arg(va, size_t);
         errbuf = va_arg(va, qstring *);
         ssize_t code = uni_read_memory(ea, buffer, size, errbuf);
         *nbytes = code >= 0 ? code : 0;
         return code >= 0 ? DRC_OK : DRC_NOPROC;
      }

      case debugger_t::ev_write_memory: {
         size_t *nbytes = va_arg(va, size_t *);
         ea_t ea = va_arg(va, ea_t);
         const void *buffer = va_arg(va, void *);
         size_t size = va_arg(va, size_t);
         errbuf = va_arg(va, qstring *);
         ssize_t code = uni_write_memory(ea, buffer, size, errbuf);
         *nbytes = code >= 0 ? code : 0;
         return code >= 0 ? DRC_OK : DRC_NOPROC;
      }

      case debugger_t::ev_check_bpt: {
         int *bptvc = va_arg(va, int *);
         bpttype_t type = va_argi(va, bpttype_t);
         ea_t ea = va_arg(va, ea_t);
         int len = va_arg(va, int);
         *bptvc = uni_is_ok_bpt(type, ea, len);
         return DRC_OK;
      }

      case debugger_t::ev_update_bpts: {
         int *nbpts = va_arg(va, int *);
         update_bpt_info_t *bpts = va_arg(va, update_bpt_info_t *);
         int nadd = va_arg(va, int);
         int ndel = va_arg(va, int);
         errbuf = va_arg(va, qstring *);
         return uni_update_bpts(nbpts, bpts, nadd, ndel, errbuf);
      }

      case debugger_t::ev_update_lowcnds: {
         int *nupdated = va_arg(va, int *);
         const lowcnd_t *lowcnds = va_arg(va, const lowcnd_t *);
         int nlowcnds = va_arg(va, int);
         errbuf = va_arg(va, qstring *);
         return uni_update_lowcnds(nupdated, lowcnds, nlowcnds, errbuf);
      }

      case debugger_t::ev_open_file: {
         const char *file = va_arg(va, const char *);
         uint64 *fsize = va_arg(va, uint64 *);
         bool readonly = va_argi(va, bool);
         return uni_open_file(file, fsize, readonly);
      }

      case debugger_t::ev_close_file: {
         int fn = va_arg(va, int);
         uni_close_file(fn);
         retcode = DRC_OK;
      }

      case debugger_t::ev_read_file: {
         int fn = va_arg(va, int);
         qoff64_t off = va_arg(va, qoff64_t);
         void *buf = va_arg(va, void *);
         size_t size = va_arg(va, size_t);
         return uni_read_file(fn, off, buf, size);
      }

      case debugger_t::ev_write_file: {
         int fn = va_arg(va, int);
         qoff64_t off = va_arg(va, qoff64_t);
         const void *buf = va_arg(va, const void *);
         size_t size = va_arg(va, size_t);
         return uni_write_file(fn, off, buf, size);
      }

      case debugger_t::ev_map_address: {
         ea_t *mapped = va_arg(va, ea_t *);
         ea_t ea = va_arg(va, ea_t);
         const regval_t *regs = va_arg(va, const regval_t *);
         int regnum = va_arg(va, int);
         *mapped = uni_map_address(ea, regs, regnum);
         return DRC_OK;
      }

#ifdef GET_DEBMOD_EXTS
      case debugger_t::ev_get_debmod_extensions: {
         const void **ext = va_arg(va, const void **);
         *ext = GET_DEBMOD_EXTS();
         return DRC_OK;
      }
#endif

#ifdef HAVE_UPDATE_CALL_STACK
      case debugger_t::ev_update_call_stack: {
         thid_t tid = va_argi(va, thid_t);
         call_stack_t *trace = va_arg(va, call_stack_t *);
         return uni_update_call_stack(tid, trace);
      }
#endif

#ifdef HAVE_APPCALL
      case debugger_t::ev_appcall: {
         ea_t *blob_ea = va_arg(va, ea_t *);
         ea_t func_ea = va_arg(va, ea_t);
         thid_t tid = va_arg(va, thid_t);
         const func_type_data_t *fti = va_arg(va, const func_type_data_t *);
         int nargs = va_arg(va, int);
         const regobjs_t *regargs = va_arg(va, const regobjs_t *);
         relobj_t *stkargs = va_arg(va, relobj_t *);
         regobjs_t *retregs = va_arg(va, regobjs_t *);
         errbuf = va_arg(va, qstring *);
         debug_event_t *event = va_arg(va, debug_event_t *);
         int opts = va_arg(va, int);
         *blob_ea = uni_appcall(func_ea, tid, fti, nargs, regargs, stkargs, retregs, errbuf, event, opts);
         return DRC_OK;
      }

      case debugger_t::ev_cleanup_appcall: {
         thid_t tid = va_argi(va, thid_t);
         return uni_cleanup_appcall(tid);
      }
#endif

      case debugger_t::ev_eval_lowcnd: {
         thid_t tid = va_argi(va, thid_t);
         ea_t ea = va_arg(va, ea_t);
         errbuf = va_arg(va, qstring *);
         return uni_eval_lowcnd(tid, ea, errbuf);
      }

      case debugger_t::ev_send_ioctl: {
         int fn = va_arg(va, int);
         const void *buf = va_arg(va, const void *);
         size_t size = va_arg(va, size_t);
         void **poutbuf = va_arg(va, void **);
         ssize_t *poutsize = va_arg(va, ssize_t *);
         return uni_send_ioctl(fn, buf, size, poutbuf, poutsize);
      }

      case debugger_t::ev_dbg_enable_trace: {
         thid_t tid = va_arg(va, thid_t);
         bool enable = va_argi(va, bool);
         int trace_flags = va_arg(va, int);
         return uni_dbg_enable_trace(tid, enable, trace_flags) ? DRC_OK : DRC_NONE;
      }

      case debugger_t::ev_is_tracing_enabled: {
         thid_t tid = va_arg(va, thid_t);
         int tracebit = va_arg(va, int);
         return uni_is_tracing_enabled(tid, tracebit) ? DRC_OK : DRC_NONE;
         break;
      }

      case debugger_t::ev_rexec: {
         const char *cmdline = va_arg(va, const char *);
         return uni_rexec(cmdline);
      }

      case debugger_t::ev_get_srcinfo_path: {
         qstring *path = va_arg(va, qstring *);
         ea_t base = va_arg(va, ea_t);
         bool ok = uni_get_srcinfo_path(path, base);
         return ok ? DRC_OK : DRC_NONE;
      }

      case debugger_t::ev_bin_search: {
         ea_t *ea = va_arg(va, ea_t *);
         ea_t start_ea = va_arg(va, ea_t);
         ea_t end_ea = va_arg(va, ea_t);
         const compiled_binpat_vec_t *ptns = va_arg(va, const compiled_binpat_vec_t *);
         int srch_flags = va_arg(va, int);
         errbuf = va_arg(va, qstring *);
         if (ptns != NULL) {
            return uni_bin_search(ea, start_ea, end_ea, ptns, srch_flags, errbuf);
         }
      }
   }

   return retcode;

}

#endif

```

`sk3wldbg.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#ifndef __UNICORN_H
#define __UNICORN_H

#ifndef USE_DANGEROUS_FUNCTIONS
#define USE_DANGEROUS_FUNCTIONS
#endif

#ifdef __NT__

#ifdef _WIN32
#ifndef _MSC_VER
#include <windows.h>
#endif
#include <winsock2.h>
#endif

#include <winnt.h>
#include <wincrypt.h>
#else
//#ifndef __NT__
#include <stdio.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <sys/time.h>
#endif

#include <unicorn/unicorn.h>

#include <pro.h>
#include <ida.hpp>
#include <idd.hpp>
#include <kernwin.hpp>

#include <vector>
#include <set>

#include "mem_mgr.h"

using std::set;
using std::vector;

#ifndef PLUGIN_NAME
#define PLUGIN_NAME "sk3wldbg"
#endif

typedef qlist<debug_event_t> evt_list_t;
typedef qlist<thid_t> thread_list;

void createNewSegment(const char *name, ea_t base, uint32_t size, uint32_t perms, uint32_t bitness);

#if IDA_SDK_VERSION >= 710
#define register_classes regclasses
#define register_classes_default default_regclasses
#define _registers registers
#define registers_size nregs
#define PROCESS_START PROCESS_STARTED
#define PROCESS_EXIT PROCESS_EXITED
#define THREAD_START THREAD_STARTED
#define THREAD_EXIT THREAD_EXITED
#define LIBRARY_LOAD LIB_LOADED
#define LIBRARY_UNLOAD LIB_UNLOADED
#define PROCESS_ATTACH PROCESS_ATTACHED
#define PROCESS_DETACH PROCESS_DETACHED
#define PROCESS_SUSPEND PROCESS_SUSPENDED
#endif

enum run_state {
   RS_INIT = 1,
   RS_RUN,
   RS_STEP_OVER,
   RS_STEP_INTO,
   RS_STEP_OUT,
   RS_PAUSE,
   RS_BREAK,
   RS_TERM
};

struct sk3wldbg : public debugger_t {

#ifdef __NT__
   HCRYPTPROV hProv;
#else
   int hProv;
#endif

   uint32_t thumb;
   uint32_t the_process;
   
   thread_list the_threads;

   set<uint64_t> breakpoints;
   set<uint64_t> tbreaks;
   vector<void*> memmap;
   mem_mgr *memmgr;

   uc_arch debug_arch;
   uc_mode debug_mode;
   qstring cpu_model;

   uc_engine *uc;
   uc_context *ctx;  //somtimes we need to save/restore state
   bool do_suspend;
   bool finished;
   bool single_step;
   bool registered_menu;
   meminfo_vec_t memory;
   evt_list_t dbg_evt_list;
   qmutex_t evt_mutex;
   qsemaphore_t run_sem;
   run_state emu_state;
   run_state resume_mode;
   qthread_t process_thread;
   regval_t *saved;
   
   uc_hook code_hook;
   uc_hook mem_fault_hook;
   uc_hook ihook;
   
   event_id_t last_eid;
   
   int32_t *reg_map;  //map of internal unicorn reg enums to dbg->_register index values

   sk3wldbg(const char *procname, uc_arch arch, uc_mode mode, const char *cpu_model = NULL);
   ~sk3wldbg();   
   
   virtual void install_initial_hooks();
   virtual bool is_system_call(uint8_t *inst, uint32_t size) {return false;};
   virtual void handle_system_call(uint8_t *inst, uint32_t size) {};
   virtual void check_mode(ea_t addr) {};
   
   void queue_step_event(uint64_t _pc);
   void enqueue_debug_evt(debug_event_t &evt);
   bool dequeue_debug_evt(debug_event_t *out);
   size_t debug_queue_len() {return dbg_evt_list.size();}
   
   bool is_stepping() {return single_step;}
   void clear_stepping() {single_step = false;}
   void set_stepping() {single_step = true;}

   void runtime_exception(uc_err err, uint64_t pc);
   bool queue_exception_event(uint32_t code, uint64_t mem_addr, const char *msg);
   bool queue_dbg_event(bool is_hardware);
   
   void close();
   void start(uint64_t initial_pc);
   void pause();
   void resume();
   bool open();
   void clear_memory() {memory.clear();}
   void init_memmgr(uint64_t map_min, uint64_t map_max);
   void *map_mem_zero(uint64_t startAddr, uint64_t endAddr, unsigned int perms, uint32_t flags = 0);
   void map_mem_copy(uint64_t startAddr, uint64_t endAddr, unsigned int perms, void *src);
   void getRandomBytes(void *buf, unsigned int len);

   void add_bpt(uint64_t bpt_addr);
   void del_bpt(uint64_t bpt_addr);

   bool read_register(int regidx, regval_t *values);
   bool save_registers();
   bool restore_registers();
   
   virtual bool call_changes_sp() {return false;};
   //emulate what this processor does when a function is called
   //some processors push, some processors save it in a register
   //emulate the right thing here. This is to support appcall
   virtual bool save_ret_addr(uint64_t retaddr) = 0;
   
   bool done() {return finished;}
   uint64_t get_pc();
   bool set_pc(uint64_t);
   uint64_t get_sp();
   bool set_sp(uint64_t);

   run_state get_state();
   void set_state(run_state new_state);
};

struct mem_map_action_handler : public action_handler_t {
   int idaapi activate(action_activation_ctx_t *ctx);
   action_state_t idaapi update(action_update_ctx_t *ctx);
};

//Some idasdk70 transition macros
#if IDA_SDK_VERSION >= 700

#define startEA start_ea 
#define endEA end_ea 

#define minEA min_ea
#define maxEA max_ea
#define ominEA omin_ea
#define omaxEA omax_ea
#define procName procname

#define get_flags_novalue(ea) get_flags(ea)
#define isEnum0(f) is_enum0(f)
#define isEnum1(f) is_enum1(f)
#define isStroff0(f) is_stroff0(f)
#define isStroff1(f) is_stroff1(f)
#define isOff0(f) is_off0(f)
#define isOff1(f) is_off1(f)
#define isOff(f, n) is_off(f, n)
#define isEnum(f, n) is_enum(f, n)
#define isStroff(f, n) is_stroff(f, n)
#define isUnknown(f) is_unknown(f)
#define getFlags(f) get_flags(f)

#define isStruct(f) is_struct(f)
#define isASCII(f) is_strlit(f)
#define do_unknown(a, f) del_items(a, f)
#define do_unknown_range(a, s, f) del_items(a, f, s)
#define isCode(f) is_code(f)

#define get_member_name2 get_member_name

#define put_many_bytes(a, b, s) put_bytes(a, b, s)
#define patch_many_bytes(a, b, s) patch_bytes(a, b, s)
#define get_many_bytes(a, b, s) get_bytes(b, s, a)

#define do_data_ex(a, d, s, t) create_data(a, d, s, t)
#define doDwrd(a, l) create_dword(a, l)
#define doStruct(a, l, t) create_struct(a, l, t)
#define get_long(a) get_dword(a)

#define dwrdflag dword_flag

#define isEnabled(a) is_mapped(a)
#define isLoaded(a) is_loaded(a)

#define switchto_tform(w, f) activate_widget(w, f)
#define find_tform(c) find_widget(c)

#define get_segreg(a, r) get_sreg(a, r)
#define AskUsingForm_c ask_form

#else //Some idasdk70 transition macros, we are pre 7.0 below

#define start_ea startEA
#define end_ea endEA

#define ev_add_cref add_cref
#define ev_add_dref add_dref
#define ev_del_cref del_cref
#define ev_del_dref del_dref
#define ev_oldfile oldfile
#define ev_newfile newfile
#define ev_auto_queue_empty auto_queue_empty

#define set_func_start func_setstart 
#define set_func_end func_setend

#define get_sreg(a, r) get_segreg(a, r)
#define get_dword(a) get_long(a)

#define ask_form AskUsingForm_c

#endif //Some idasdk70 transition macros

#endif

```

`sk3wldbg_arm.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg_arm.h"
#include <idp.hpp>
#include <segment.hpp>
#if IDA_SDK_VERSION >= 700
#include <segregs.hpp>
#else
#include <srarea.hpp>
#endif

static const char *arm_register_classes[] = {
   "General registers",
   NULL
};

enum ArmRegClass {
   ARM_GENERAL = 1
};

static const char* arm_flags[] = {
  "MODE", "MODE", "MODE", "MODE", "MODE", "T", "F", "I",
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
  "Q", "V", "C", "Z", "N"
};

static struct register_info_t arm_regs[] = {
   {"R0", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R1", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R2", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R3", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R4", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R5", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R6", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R7", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R8", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R9", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R10", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R11", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"R12", REGISTER_ADDRESS, ARM_GENERAL, dt_dword, NULL, 0},
   {"SP", REGISTER_ADDRESS | REGISTER_SP, ARM_GENERAL, dt_dword, NULL, 0},
   {"LR", REGISTER_ADDRESS, ARM_GENERAL,  dt_dword, NULL, 0},
   {"PC", REGISTER_ADDRESS | REGISTER_IP, ARM_GENERAL, dt_dword, NULL, 0},
   {"PSR", 0, ARM_GENERAL, dt_dword, arm_flags, 0xF80000FF},
};

#define ARM_LR 14

static int32_t arm_reg_map[] = {
   UC_ARM_REG_R0, UC_ARM_REG_R1, UC_ARM_REG_R2, UC_ARM_REG_R3, UC_ARM_REG_R4,
   UC_ARM_REG_R5, UC_ARM_REG_R6, UC_ARM_REG_R7, UC_ARM_REG_R8,
   UC_ARM_REG_R9, UC_ARM_REG_R10, UC_ARM_REG_R11, UC_ARM_REG_R12,
   UC_ARM_REG_SP, UC_ARM_REG_LR, UC_ARM_REG_PC, UC_ARM_REG_CPSR
};

static struct register_info_t aarch64_regs[] = {
   {"X0", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X1", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X2", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X3", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X4", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X5", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X6", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X7", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X8", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X9", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X10", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X11", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X12", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X13", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X14", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X15", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X16", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X17", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X18", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X19", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X20", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X21", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X22", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X23", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X24", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X25", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X26", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X27", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X28", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"X29", REGISTER_ADDRESS, ARM_GENERAL, dt_qword, NULL, 0},
   {"LR", REGISTER_ADDRESS, ARM_GENERAL,  dt_qword, NULL, 0},
   {"SP", REGISTER_ADDRESS | REGISTER_SP, ARM_GENERAL, dt_qword, NULL, 0},
   {"PC", REGISTER_ADDRESS | REGISTER_IP, ARM_GENERAL, dt_qword, NULL, 0},
   {"PSR", 0, ARM_GENERAL, dt_dword, arm_flags, 0xF80000FF},
};

#define ARM64_LR 30

static int32_t arm64_reg_map[] = {
   UC_ARM64_REG_X0, UC_ARM64_REG_X1, UC_ARM64_REG_X2, UC_ARM64_REG_X3, UC_ARM64_REG_X4,
   UC_ARM64_REG_X5, UC_ARM64_REG_X6, UC_ARM64_REG_X7, UC_ARM64_REG_X8,
   UC_ARM64_REG_X9, UC_ARM64_REG_X10, UC_ARM64_REG_X11, UC_ARM64_REG_X12,
   UC_ARM64_REG_X13, UC_ARM64_REG_X14, UC_ARM64_REG_X15, UC_ARM64_REG_X16, UC_ARM64_REG_X17,
   UC_ARM64_REG_X18, UC_ARM64_REG_X19, UC_ARM64_REG_X20, UC_ARM64_REG_X21,
   UC_ARM64_REG_X22, UC_ARM64_REG_X23, UC_ARM64_REG_X24, UC_ARM64_REG_X25,
   UC_ARM64_REG_X26, UC_ARM64_REG_X27, UC_ARM64_REG_X28, UC_ARM64_REG_X29,
   UC_ARM64_REG_LR, UC_ARM64_REG_SP, UC_ARM64_REG_PC, UC_ARM64_REG_NZCV
};

sk3wldbg_arm::sk3wldbg_arm() : sk3wldbg("ARM", UC_ARCH_ARM, UC_MODE_ARM) {
   //reset any overridden function pointers and setup register name fields

   if (debug_mode & UC_MODE_BIG_ENDIAN) {
      processor = "ARMB";
   }

   //TODO: test the IDA "T" register to see if this is thumb code before creating emulator instance

   register_classes = arm_register_classes;
   register_classes_default = 1;        ///< Mask of default printed register classes
   _registers = arm_regs;               ///< Array of registers. Use registers() to access it
   registers_size = qnumber(arm_regs);  ///< Number of registers
   reg_map = arm_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

}

void sk3wldbg_arm::check_mode(ea_t addr) {
   sel_t treg = get_segreg(addr, 20);   //20 is ARM T reg
   if (treg) {
      debug_mode = (uc_mode)((int)UC_MODE_THUMB | (int)debug_mode);
//      msg("Enabling thumb mode\n");
      thumb = 1;
   }
}

bool sk3wldbg_arm::save_ret_addr(uint64_t retaddr) {
   uc_reg_write(uc, reg_map[ARM_LR], &retaddr);
   return true;
}

sk3wldbg_aarch64::sk3wldbg_aarch64() : sk3wldbg("ARM", UC_ARCH_ARM64, UC_MODE_ARM) {
   //reset any overridden function pointers and setup register name fields

   if (debug_mode & UC_MODE_BIG_ENDIAN) {
      processor = "ARMB";
   }

   register_classes = arm_register_classes;
   register_classes_default = 1;          ///< Mask of default printed register classes
   _registers = aarch64_regs;             ///< Array of registers. Use registers() to access it
   registers_size = qnumber(aarch64_regs); ///< Number of registers
   reg_map = arm64_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

}

void sk3wldbg_aarch64::check_mode(ea_t addr) {
   sel_t thumb = get_segreg(addr, 20);   //20 is ARM T reg
   if (thumb) {
      debug_mode = (uc_mode)((int)UC_MODE_THUMB | (int)debug_mode);
   }
}

bool sk3wldbg_aarch64::save_ret_addr(uint64_t retaddr) {
   uc_reg_write(uc, reg_map[ARM64_LR], &retaddr);
   return true;
}


```

`sk3wldbg_arm.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg.h"

struct sk3wldbg_arm : public sk3wldbg {
   sk3wldbg_arm();
   void check_mode(ea_t addr);
   bool save_ret_addr(uint64_t retaddr);
};

struct sk3wldbg_aarch64 : public sk3wldbg {
   sk3wldbg_aarch64();
   void check_mode(ea_t addr);
   bool save_ret_addr(uint64_t retaddr);
};


```

`sk3wldbg_m68k.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg_m68k.h"

static const char *m68k_register_classes[] = {
   "General registers",
   NULL
};

enum M68kRegClass {
   M68K_GENERAL = 1
};

static const char* m68k_flags[] = {
  "C", "V", "Z", "N", "X", NULL, NULL, NULL,
  "I", "I", "I", NULL, "M", "S", "T", "T"
};

static struct register_info_t m68k_regs[] = {
   {"D0", 0, M68K_GENERAL, dt_dword, NULL, 0},
   {"D1", 0, M68K_GENERAL, dt_dword, NULL, 0},
   {"D2", 0, M68K_GENERAL, dt_dword, NULL, 0},
   {"D3", 0, M68K_GENERAL, dt_dword, NULL, 0},
   {"D4", 0, M68K_GENERAL, dt_dword, NULL, 0},
   {"D5", 0, M68K_GENERAL, dt_dword, NULL, 0},
   {"D6", 0, M68K_GENERAL, dt_dword, NULL, 0},
   {"D7", 0, M68K_GENERAL, dt_dword, NULL, 0},
   {"A0", REGISTER_ADDRESS, M68K_GENERAL, dt_dword, NULL, 0},
   {"A1", REGISTER_ADDRESS, M68K_GENERAL, dt_dword, NULL, 0},
   {"A2", REGISTER_ADDRESS, M68K_GENERAL, dt_dword, NULL, 0},
   {"A3", REGISTER_ADDRESS, M68K_GENERAL, dt_dword, NULL, 0},
   {"A4", REGISTER_ADDRESS, M68K_GENERAL, dt_dword, NULL, 0},
   {"A5", REGISTER_ADDRESS, M68K_GENERAL, dt_dword, NULL, 0},
   {"A6", REGISTER_ADDRESS, M68K_GENERAL, dt_dword, NULL, 0},
   {"SP", REGISTER_ADDRESS | REGISTER_SP, M68K_GENERAL, dt_dword, NULL, 0},
   {"PC", REGISTER_ADDRESS | REGISTER_IP, M68K_GENERAL, dt_dword, NULL, 0},
   {"CCR", 0, M68K_GENERAL, dt_word, m68k_flags, 0xF71F},
};

static int32_t m68k_reg_map[] = {
   UC_M68K_REG_D0, UC_M68K_REG_D1, UC_M68K_REG_D2, UC_M68K_REG_D3, UC_M68K_REG_D4,
   UC_M68K_REG_D5, UC_M68K_REG_D6, UC_M68K_REG_D7, UC_M68K_REG_A0,
   UC_M68K_REG_A1, UC_M68K_REG_A2, UC_M68K_REG_A3, UC_M68K_REG_A3,
   UC_M68K_REG_A4, UC_M68K_REG_A5, UC_M68K_REG_A6, UC_M68K_REG_A7,
   UC_M68K_REG_PC, UC_M68K_REG_SR
};

sk3wldbg_m68k::sk3wldbg_m68k() : sk3wldbg("68000", UC_ARCH_M68K, UC_MODE_32) {
   //reset any overridden function pointers and setup register name fields

   register_classes = m68k_register_classes;
   register_classes_default = 1;    ///< Mask of default printed register classes
   _registers = m68k_regs;               ///< Array of registers. Use registers() to access it
   registers_size = qnumber(m68k_regs);  ///< Number of registers
   reg_map = m68k_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array
}

bool sk3wldbg_m68k::save_ret_addr(uint64_t retaddr) {
   uint64_t new_sp = get_sp() - sizeof(uint32_t);
   uc_mem_write(uc, new_sp, &retaddr, sizeof(uint32_t));
   set_sp(new_sp);
   return true;
}

```

`sk3wldbg_m68k.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg.h"

struct sk3wldbg_m68k : public sk3wldbg {
   sk3wldbg_m68k();
   bool save_ret_addr(uint64_t retaddr);
   bool call_changes_sp() {return true;};
};


```

`sk3wldbg_mips.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg_mips.h"
#include <idp.hpp>

static const char *mips_register_classes[] = {
   "General registers",
   "Floating point registers",
   NULL
};

enum MipsRegClass {
   MIPS_GENERAL = 1,
   MIPS_FPU = 2
};

static struct register_info_t mips_regs[] = {
   {"zero", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"at", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"v0", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"v1", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"a0", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"a1", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"a2", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"a3", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t0", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t1", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t2", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t3", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t4", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t5", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t6", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t7", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"s0", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"s1", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"s2", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"s3", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"s4", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"s5", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"s6", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"s7", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t8", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"t9", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"k0", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"k1", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"gp", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"sp", REGISTER_SP | REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"fp", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"ra", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"FP0", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP1", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP2", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP3", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP4", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP5", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP6", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP7", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP8", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP9", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP10", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP11", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP12", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP13", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP14", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP15", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP16", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP17", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP18", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP19", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP20", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP21", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP22", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP23", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP24", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP25", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP26", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP27", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP28", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP29", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP30", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP31", 0, MIPS_FPU, dt_double, NULL, 0},
//   {"LR", REGISTER_ADDRESS, MIPS_GENERAL, dt_dword, NULL, 0},
   {"PC", REGISTER_ADDRESS | REGISTER_IP, MIPS_GENERAL, dt_dword, NULL, 0}
};

#define MIPS_RA 31

static int32_t mips_reg_map[] = {
   UC_MIPS_REG_0, UC_MIPS_REG_1, UC_MIPS_REG_2, UC_MIPS_REG_3, UC_MIPS_REG_4,
   UC_MIPS_REG_5, UC_MIPS_REG_6, UC_MIPS_REG_7, UC_MIPS_REG_8,
   UC_MIPS_REG_9, UC_MIPS_REG_10, UC_MIPS_REG_11, UC_MIPS_REG_12,
   UC_MIPS_REG_13, UC_MIPS_REG_14, UC_MIPS_REG_15, UC_MIPS_REG_16, UC_MIPS_REG_17,
   UC_MIPS_REG_18, UC_MIPS_REG_19, UC_MIPS_REG_20, UC_MIPS_REG_21,
   UC_MIPS_REG_22, UC_MIPS_REG_23, UC_MIPS_REG_24, UC_MIPS_REG_25,
   UC_MIPS_REG_26, UC_MIPS_REG_27, UC_MIPS_REG_28,
   UC_MIPS_REG_SP, UC_MIPS_REG_FP, UC_MIPS_REG_RA,
   UC_MIPS_REG_F0, UC_MIPS_REG_F1, UC_MIPS_REG_F2, UC_MIPS_REG_F3, UC_MIPS_REG_F4,
   UC_MIPS_REG_F5, UC_MIPS_REG_F6, UC_MIPS_REG_F7, UC_MIPS_REG_F8,
   UC_MIPS_REG_F9, UC_MIPS_REG_F10, UC_MIPS_REG_F11, UC_MIPS_REG_F12,
   UC_MIPS_REG_F13, UC_MIPS_REG_F14, UC_MIPS_REG_F15, UC_MIPS_REG_F16, UC_MIPS_REG_F17,
   UC_MIPS_REG_F18, UC_MIPS_REG_F19, UC_MIPS_REG_F20, UC_MIPS_REG_F21,
   UC_MIPS_REG_F22, UC_MIPS_REG_F23, UC_MIPS_REG_F24, UC_MIPS_REG_F25,
   UC_MIPS_REG_F26, UC_MIPS_REG_F27, UC_MIPS_REG_F28, UC_MIPS_REG_F29,
   UC_MIPS_REG_F30, UC_MIPS_REG_F31,
   UC_MIPS_REG_PC
};

static struct register_info_t mips_regs64[] = {
   {"zero", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"at", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"v0", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"v1", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"a0", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"a1", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"a2", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"a3", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t0", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t1", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t2", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t3", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t4", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t5", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t6", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t7", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"s0", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"s1", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"s2", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"s3", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"s4", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"s5", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"s6", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"s7", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t8", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"t9", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"k0", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"k1", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"gp", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"sp", REGISTER_SP | REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"fp", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"ra", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"FP0", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP1", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP2", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP3", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP4", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP5", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP6", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP7", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP8", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP9", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP10", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP11", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP12", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP13", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP14", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP15", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP16", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP17", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP18", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP19", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP20", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP21", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP22", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP23", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP24", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP25", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP26", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP27", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP28", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP29", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP30", 0, MIPS_FPU, dt_double, NULL, 0},
   {"FP31", 0, MIPS_FPU, dt_double, NULL, 0},
//   {"LR", REGISTER_ADDRESS, MIPS_GENERAL, dt_qword, NULL, 0},
   {"PC", REGISTER_ADDRESS | REGISTER_IP, MIPS_GENERAL, dt_qword, NULL, 0}
};

#define MIPS64_RA 31

static int32_t mips64_reg_map[] = {
   UC_MIPS_REG_0, UC_MIPS_REG_1, UC_MIPS_REG_2, UC_MIPS_REG_3, UC_MIPS_REG_4,
   UC_MIPS_REG_5, UC_MIPS_REG_6, UC_MIPS_REG_7, UC_MIPS_REG_8,
   UC_MIPS_REG_9, UC_MIPS_REG_10, UC_MIPS_REG_11, UC_MIPS_REG_12,
   UC_MIPS_REG_13, UC_MIPS_REG_14, UC_MIPS_REG_15, UC_MIPS_REG_16, UC_MIPS_REG_17,
   UC_MIPS_REG_18, UC_MIPS_REG_19, UC_MIPS_REG_20, UC_MIPS_REG_21,
   UC_MIPS_REG_22, UC_MIPS_REG_23, UC_MIPS_REG_24, UC_MIPS_REG_25,
   UC_MIPS_REG_26, UC_MIPS_REG_27, UC_MIPS_REG_28,
   UC_MIPS_REG_SP, UC_MIPS_REG_FP, UC_MIPS_REG_RA,
   UC_MIPS_REG_F0, UC_MIPS_REG_F1, UC_MIPS_REG_F2, UC_MIPS_REG_F3, UC_MIPS_REG_F4,
   UC_MIPS_REG_F5, UC_MIPS_REG_F6, UC_MIPS_REG_F7, UC_MIPS_REG_F8,
   UC_MIPS_REG_F9, UC_MIPS_REG_F10, UC_MIPS_REG_F11, UC_MIPS_REG_F12,
   UC_MIPS_REG_F13, UC_MIPS_REG_F14, UC_MIPS_REG_F15, UC_MIPS_REG_F16, UC_MIPS_REG_F17,
   UC_MIPS_REG_F18, UC_MIPS_REG_F19, UC_MIPS_REG_F20, UC_MIPS_REG_F21,
   UC_MIPS_REG_F22, UC_MIPS_REG_F23, UC_MIPS_REG_F24, UC_MIPS_REG_F25,
   UC_MIPS_REG_F26, UC_MIPS_REG_F27, UC_MIPS_REG_F28, UC_MIPS_REG_F29,
   UC_MIPS_REG_F30, UC_MIPS_REG_F31,
   UC_MIPS_REG_PC
};

sk3wldbg_mips::sk3wldbg_mips() : sk3wldbg("mipsl", UC_ARCH_MIPS, UC_MODE_MIPS32) {
   //reset any overridden function pointers and setup register name fields

   if (debug_mode & UC_MODE_BIG_ENDIAN) {
      processor = "mipsb";
   }

   register_classes = mips_register_classes;
   register_classes_default = MIPS_GENERAL;    ///< Mask of default printed register classes
   _registers = mips_regs;               ///< Array of registers. Use registers() to access it
   registers_size = qnumber(mips_regs);              ///< Number of registers
   reg_map = mips_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

}

bool sk3wldbg_mips::save_ret_addr(uint64_t retaddr) {
   uc_reg_write(uc, reg_map[MIPS_RA], &retaddr);
   return true;
}

sk3wldbg_mips64::sk3wldbg_mips64() : sk3wldbg("mipsl", UC_ARCH_MIPS, UC_MODE_MIPS64) {
   //reset any overridden function pointers and setup register name fields

   if (debug_mode & UC_MODE_BIG_ENDIAN) {
      processor = "mipsb";
   }

   register_classes = NULL;
   register_classes_default = 0;    ///< Mask of default printed register classes
   _registers = NULL;               ///< Array of registers. Use registers() to access it
   registers_size = 0;              ///< Number of registers
   reg_map = mips64_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

}

bool sk3wldbg_mips64::save_ret_addr(uint64_t retaddr) {
   uc_reg_write(uc, reg_map[MIPS64_RA], &retaddr);
   return true;
}

```

`sk3wldbg_mips.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg.h"

struct sk3wldbg_mips : public sk3wldbg {
   sk3wldbg_mips();
   bool save_ret_addr(uint64_t retaddr);
};

struct sk3wldbg_mips64 : public sk3wldbg {
   sk3wldbg_mips64();
   bool save_ret_addr(uint64_t retaddr);
};


```

`sk3wldbg_plugin.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

/*
 *  This is the Sk3wlDbg plugin module
 *
 *  It is known to compile with
 *
 *  - Visual Studio 2010, Linux g++, OS X - clang
 *
 */

#ifdef PACKED
#undef PACKED
#endif

#define USE_DANGEROUS_FUNCTIONS

#include <unicorn/unicorn.h>

#include <ida.hpp>
#include <idp.hpp>
#include <bytes.hpp>
#include <auto.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <typeinf.hpp>
#include <nalt.hpp>
#include <segment.hpp>
#if IDA_SDK_VERSION >= 700
#include <segregs.hpp>
#else
#include <srarea.hpp>
#endif
#include <typeinf.hpp>
#include <struct.hpp>
#include <entry.hpp>
#include <dbg.hpp>
#include <idd.hpp>
#include <ua.hpp>

#include "sk3wldbg_x86.h"
#include "sk3wldbg_arm.h"
#include "sk3wldbg_mips.h"
#include "sk3wldbg_sparc.h"
#include "sk3wldbg_ppc.h"
#include "sk3wldbg_m68k.h"
#include "idc_funcs.h"

static bool hooked = false;

#if IDA_SDK_VERSION < 750

//make life easier in a post 7.5 world
#define PLUGIN_MULTI 0

int idaapi plugin_init(void);
void idaapi plugin_term(void);

#else

plugmod_t *idaapi plugin_init(void);

#define plugin_run NULL
#define plugin_term NULL

#endif

#if IDA_SDK_VERSION < 700

void idaapi plugin_run(int /*arg*/) {
   return;
}

#elif IDA_SDK_VERSION < 750

bool idaapi plugin_run(size_t /*arg*/) {
   return true;
}

#endif

//--------------------------------------------------------------------------
//
//      PLUGIN DESCRIPTION BLOCK
//
//--------------------------------------------------------------------------

plugin_t PLUGIN = {
  IDP_INTERFACE_VERSION,
  PLUGIN_DBG | PLUGIN_HIDE | PLUGIN_MULTI,   // plugin flags

  plugin_init,                 // initialize

  plugin_term,                 // terminate. this pointer may be NULL.

  plugin_run,                  // invoke plugin

  "Sk3wlDbg",                   // long comment about the plugin
                        // it could appear in the status line
                        // or as a hint

  "Sk3wlDbg",                   // multiline help about the plugin

  "Sk3wlDbg",            // the preferred short name of the plugin
  ""                    // the preferred hotkey to run the plugin
};

static mem_map_action_handler mem_map_handler;

static action_desc_t mem_map_action = {
   sizeof(action_desc_t),
   "sk3wldbg:mem_map",
   "Map memory...",
   &mem_map_handler,
   &PLUGIN,
   NULL,
   NULL,
   0
};

static bool registered = false;

#if IDA_SDK_VERSION >= 700
static ssize_t idaapi ui_hook(void *user_data, int notification_code, va_list va) {
#else
static int idaapi ui_hook(void *user_data, int notification_code, va_list va) {
#endif
   switch (notification_code) {
      case ui_debugger_menu_change: {
         bool enable = va_arg(va, int) != 0;
         msg("ui_debugger_menu_change received, enable = %u\n", enable);
/*
         if (enable) {
            register_action(mem_map_action);
            attach_action_to_menu("Debugger/Take memory snapshot", "sk3wldbg:mem_map", SETMENU_APP);
            registered = true;
         }
         else if (registered) {
            detach_action_from_menu("Debugger/Take memory snapshot", "sk3wldbg:mem_map");
            unregister_action("sk3wldbg:mem_map");
            registered = false;
         }
*/
         return 1;
      }
   }
   return 0;
}

void idaapi term_common(void) {
#ifdef DEBUG
   msg(PLUGIN_NAME": term entered\n");
#endif

   if (hooked) {
      unhook_from_notification_point(::HT_UI, ui_hook);
      hooked = false;
   }
   if (registered) {
      //This call is currently causing IDA to crash so something is
      //not being done correctly.
      //Wrong place to unregister? Wrong thread to unregister from?
//      unregister_action("sk3wldbg:mem_map");
   }

#ifdef DEBUG
   msg(PLUGIN_NAME": term exiting\n");
#endif
}

bool init_common(void) {
   sk3wldbg *sdbg = NULL;
   msg("sk3wldbg trying to init\n");
   int debug_mode = UC_MODE_32;
   if (inf.lflags & LFLG_64BIT) {
      debug_mode = UC_MODE_64;
   }
   else if (inf.lflags & LFLG_PC_FLAT) {
      debug_mode = UC_MODE_32;
   }
   else {
      //let's assume it's 16 bit code
      debug_mode = UC_MODE_16;
   }
   switch (ph.id) {
      case PLFM_386:
         if (debug_mode == UC_MODE_32) {
            sdbg = new sk3wldbg_x86_32();
         }
         else if (debug_mode == UC_MODE_64) {
            sdbg = new sk3wldbg_x86_64();
         }
         else if (debug_mode == UC_MODE_16) {
            sdbg = new sk3wldbg_x86_16();
         }
         break;
      case PLFM_68K:
         sdbg = new sk3wldbg_m68k();
         break;
      case PLFM_ARM:
         if (debug_mode == UC_MODE_32) {
            sdbg = new sk3wldbg_arm();
         }
         else {
            sdbg = new sk3wldbg_aarch64();
         }
         break;
      case PLFM_MIPS:
         if (debug_mode == UC_MODE_32) {
            sdbg = new sk3wldbg_mips();
         }
         else {
            sdbg = new sk3wldbg_mips64();
         }
         break;
      case PLFM_SPARC:
         if (debug_mode == UC_MODE_32) {
            sdbg = new sk3wldbg_sparc();
         }
         else {
            sdbg = new sk3wldbg_sparc64();
         }
         break;
      case PLFM_PPC:
         if (debug_mode == UC_MODE_32) {
            sdbg = new sk3wldbg_ppc();
         }
         else {
            sdbg = new sk3wldbg_ppc64();
         }
         break;
      default:
         msg("sk3wldbg: unsupported processor\n");
         return false;
   }
//   hook_to_notification_point(::HT_UI, ui_hook, dbg);
//   hooked = true;
   dbg = sdbg;
   register_funcs(sdbg);
   register_action(mem_map_action);
   registered = true;
   msg(PLUGIN_NAME" keeping sk3wldbg\n");
   return true;
}

//--------------------------------------------------------------------------
//
//      Initialize.
//
//      IDA will call this function only once.
//      If this function returns PLGUIN_SKIP, IDA will never load it again.
//      If this function returns PLUGIN_OK, IDA will unload the plugin but
//      remember that the plugin agreed to work with the database.
//      The plugin will be loaded again if the user invokes it by
//      pressing the hotkey or selecting it from the menu.
//      After the second load the plugin will stay on memory.
//      If this function returns PLUGIN_KEEP, IDA will keep the plugin
//      in the memory. In this case the initialization function can hook
//      into the processor module and user interface notification points.
//      See the hook_to_notification_point() function.
//
#if IDA_SDK_VERSION < 750
int idaapi plugin_init(void) {
   if (init_common()) {
      return PLUGIN_KEEP;
   }
   else {
      return PLUGIN_SKIP;
   }
}

//--------------------------------------------------------------------------
//      Terminate.
//
//      IDA will call this function when the user asks to exit.
//      This function won't be called in the case of emergency exits.

#ifndef DEBUG
#define DEBUG
#endif

void idaapi plugin_term(void) {
   term_common();
}

#else  //IDA_SDK_VERSION >= 750

// things are done differently beginning in 7.5

struct sk3wl_plugmod_t : public plugmod_t {
  /// Invoke the plugin.
  virtual bool idaapi run(size_t arg);

  /// Virtual destructor.
  virtual ~sk3wl_plugmod_t();
};

plugmod_t *idaapi plugin_init(void) {
   if (init_common()) {
      return new sk3wl_plugmod_t();
   }
   else {
      return NULL;
   }
}

sk3wl_plugmod_t::~sk3wl_plugmod_t(void) {
   term_common();
}

bool idaapi sk3wl_plugmod_t::run(size_t /*arg*/) {
   return true;
}


#endif

```

`sk3wldbg_ppc.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg_ppc.h"

static const char *ppc_register_classes[] = {
   "General registers",
   "Floating point registers",
   NULL
};

enum PpcRegClass {
   PPC_GENERAL = 1,
   PPC_FPU = 2
};

static const char* ppc_flags[] = {
  "CR0", "CR0", "CR0", "CR0",
  "CR1", "CR1", "CR1", "CR1",
  "CR2", "CR2", "CR2", "CR2",
  "CR3", "CR3", "CR3", "CR3",
  "CR4", "CR4", "CR4", "CR4",
  "CR5", "CR5", "CR5", "CR5",
  "CR6", "CR6", "CR6", "CR6",
  "CR7", "CR7", "CR7", "CR7"
};

static const char* ppc_xer_flags[] = {
  "SO", "OV", "CA", NULL, NULL,
  NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL,
  NULL, NULL, NULL, NULL, NULL,
  NULL, NULL,
  "COUNT", "COUNT", "COUNT", "COUNT", "COUNT"
};

static const char* ppc_fpu_flags[] = {
  "FX", "FEX", "VX", "OX",
  "UX", "ZX", "XX", "VXSNAN",
  "VXISI", "VXIDI", "VXZDZ", "VXIMZ",
  "VXVC", "FR", "FI", "FPRF",
  "FPRF", "FPRF", "FPRF", "FPRF",
  NULL, "VXSOFT", "VXSQRT", "VXCVI",
  "VE", "OE", "UE", "ZE",
  "XE", "NI", "RN", "RN"
};

static struct register_info_t ppc_regs[] = {
   {"GPR0", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR1", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR2", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR3", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR4", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR5", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR6", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR7", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR8", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR9", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR10", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR11", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR12", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR13", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR14", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR15", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR16", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR17", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR18", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR19", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR20", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR21", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR22", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR23", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR24", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR25", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR26", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR27", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR28", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR29", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR30", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"GPR31", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"FPR0", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR1", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR2", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR3", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR4", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR5", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR6", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR7", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR8", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR9", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR10", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR11", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR12", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR13", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR14", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR15", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR16", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR17", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR18", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR19", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR20", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR21", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR22", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR23", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR24", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR25", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR26", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR27", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR28", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR29", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR30", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR31", 0, PPC_FPU, dt_double, NULL, 0},
   {"LR", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"CTR", REGISTER_ADDRESS, PPC_GENERAL, dt_dword, NULL, 0},
   {"PC", REGISTER_ADDRESS | REGISTER_IP, PPC_GENERAL, dt_dword, NULL, 0},
   {"CR", 0, PPC_GENERAL, dt_dword, ppc_flags, 0xFFFFFFFF},
   {"XER", 0, PPC_GENERAL, dt_dword, ppc_xer_flags, 0xF8000007},
   {"FPSCR", 0, PPC_FPU, dt_dword, ppc_fpu_flags, 0xFFEFFFFF},
};

#define PPC_LR 64

static struct register_info_t ppc_regs64[] = {
   {"GPR0", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR1", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR2", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR3", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR4", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR5", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR6", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR7", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR8", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR9", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR10", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR11", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR12", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR13", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR14", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR15", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR16", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR17", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR18", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR19", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR20", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR21", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR22", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR23", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR24", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR25", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR26", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR27", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR28", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR29", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR30", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"GPR31", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"FPR0", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR1", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR2", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR3", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR4", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR5", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR6", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR7", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR8", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR9", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR10", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR11", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR12", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR13", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR14", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR15", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR16", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR17", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR18", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR19", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR20", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR21", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR22", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR23", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR24", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR25", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR26", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR27", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR28", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR29", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR30", 0, PPC_FPU, dt_double, NULL, 0},
   {"FPR31", 0, PPC_FPU, dt_double, NULL, 0},
   {"LR", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"CTR", REGISTER_ADDRESS, PPC_GENERAL, dt_qword, NULL, 0},
   {"PC", REGISTER_ADDRESS | REGISTER_IP, PPC_GENERAL, dt_qword, NULL, 0},
   {"CR", 0, PPC_GENERAL, dt_dword, ppc_flags, 0xFFF03FFF},
   {"XER", 0, PPC_GENERAL, dt_dword, ppc_xer_flags, 0xF8000007},
   {"FPSCR", 0, PPC_FPU, dt_dword, ppc_fpu_flags, 0xFFEFFFFF},
};

#define PPC64_LR 64

sk3wldbg_ppc::sk3wldbg_ppc() : sk3wldbg("PPCL", UC_ARCH_PPC, UC_MODE_32) {
   //reset any overridden function pointers and setup register name fields

   if (debug_mode & UC_MODE_BIG_ENDIAN) {
      processor = "PPC";
   }

   register_classes = ppc_register_classes;
   register_classes_default = PPC_GENERAL;    ///< Mask of default printed register classes
   _registers = ppc_regs;               ///< Array of registers. Use registers() to access it
   registers_size = qnumber(ppc_regs);  ///< Number of registers
//   reg_map = ppc_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

}

bool sk3wldbg_ppc::save_ret_addr(uint64_t retaddr) {
   uc_reg_write(uc, reg_map[PPC_LR], &retaddr);
   return true;
}

sk3wldbg_ppc64::sk3wldbg_ppc64() : sk3wldbg("PPCL", UC_ARCH_PPC, UC_MODE_64) {
   //reset any overridden function pointers and setup register name fields

   if (debug_mode & UC_MODE_BIG_ENDIAN) {
      processor = "PPC";
   }

   register_classes = ppc_register_classes;
   register_classes_default = PPC_GENERAL;    ///< Mask of default printed register classes
   _registers = ppc_regs64;               ///< Array of registers. Use registers() to access it
   registers_size = qnumber(ppc_regs64);  ///< Number of registers
//   reg_map = ppc64_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

}

bool sk3wldbg_ppc64::save_ret_addr(uint64_t retaddr) {
   uc_reg_write(uc, reg_map[PPC64_LR], &retaddr);
   return true;
}


```

`sk3wldbg_ppc.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg.h"

struct sk3wldbg_ppc : public sk3wldbg {
   sk3wldbg_ppc();
   bool save_ret_addr(uint64_t retaddr);
};

struct sk3wldbg_ppc64 : public sk3wldbg {
   sk3wldbg_ppc64();
   bool save_ret_addr(uint64_t retaddr);
};


```

`sk3wldbg_sparc.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg_sparc.h"

static const char *sparc_register_classes[] = {
   "General registers",
   NULL
};

enum SparcRegClass {
   SPARC_GENERAL = 1
};

static const char* sparc_flags[] = {
  "CWP", "CWP", "CWP", "CWP", "CWP", "ET", "PS", "S", "PIL", "PIL", "PIL", "PIL",
  "EF", "EC", NULL, NULL, NULL, NULL, NULL, NULL, "C", "V", "Z", "N",
  "VER", "VER", "VER", "VER", "IMPL", "IMPL", "IMPL", "IMPL"
};

static struct register_info_t sparc_regs[] = {
   {"g0", 0, SPARC_GENERAL, dt_dword, NULL, 0},
   {"g1", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"g2", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"g3", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"g4", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"g5", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"g6", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"g7", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"o0", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"o1", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"o2", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"o3", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"o4", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"o5", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"sp", REGISTER_ADDRESS | REGISTER_SP, SPARC_GENERAL, dt_dword, NULL, 0},
   {"o7", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"l0", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"l1", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"l2", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"l3", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"l4", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"l5", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"l6", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"l7", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"i0", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"i1", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"i2", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"i3", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"i4", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"i5", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"fp", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"i7", REGISTER_ADDRESS, SPARC_GENERAL, dt_dword, NULL, 0},
   {"PC", REGISTER_ADDRESS | REGISTER_IP, SPARC_GENERAL, dt_dword, NULL, 0},
   {"PSR", 0, SPARC_GENERAL, dt_dword, sparc_flags, 0xFFF03FFF},
};

#define SPARC_LR 15

static int32_t sparc_reg_map[] = {
   UC_SPARC_REG_G0, UC_SPARC_REG_G1, UC_SPARC_REG_G2, UC_SPARC_REG_G3,
   UC_SPARC_REG_G4, UC_SPARC_REG_G5, UC_SPARC_REG_G6, UC_SPARC_REG_G7,
   UC_SPARC_REG_O0, UC_SPARC_REG_O1, UC_SPARC_REG_O2, UC_SPARC_REG_O3,
   UC_SPARC_REG_O4, UC_SPARC_REG_O5, UC_SPARC_REG_SP, UC_SPARC_REG_O7,
   UC_SPARC_REG_L0, UC_SPARC_REG_L1, UC_SPARC_REG_L2, UC_SPARC_REG_L3,
   UC_SPARC_REG_L4, UC_SPARC_REG_L5, UC_SPARC_REG_L6, UC_SPARC_REG_L7,
   UC_SPARC_REG_I0, UC_SPARC_REG_I1, UC_SPARC_REG_I2, UC_SPARC_REG_I3,
   UC_SPARC_REG_I4, UC_SPARC_REG_I5, UC_SPARC_REG_FP, UC_SPARC_REG_I7,
   UC_SPARC_REG_PC, UC_SPARC_REG_ICC
};

#define sparc64_reg_map sparc_reg_map

sk3wldbg_sparc::sk3wldbg_sparc() : sk3wldbg("sparcl", UC_ARCH_SPARC, UC_MODE_32) {
   //reset any overridden function pointers and setup register name fields

   if (debug_mode & UC_MODE_BIG_ENDIAN) {
      processor = "sparcb";
   }

   register_classes = sparc_register_classes;
   register_classes_default = SPARC_GENERAL;    ///< Mask of default printed register classes
   _registers = sparc_regs;               ///< Array of registers. Use registers() to access it
   registers_size = qnumber(sparc_regs);  ///< Number of registers
   reg_map = sparc_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

}

bool sk3wldbg_sparc::save_ret_addr(uint64_t retaddr) {
   uc_reg_write(uc, reg_map[SPARC_LR], &retaddr);
   return true;
}

sk3wldbg_sparc64::sk3wldbg_sparc64() : sk3wldbg("sparcl", UC_ARCH_SPARC, UC_MODE_64) {
   //reset any overridden function pointers and setup register name fields

   if (debug_mode & UC_MODE_BIG_ENDIAN) {
      processor = "sparcb";
   }

   register_classes = sparc_register_classes;
   register_classes_default = SPARC_GENERAL;    ///< Mask of default printed register classes
   _registers = sparc_regs;               ///< Array of registers. Use registers() to access it
   registers_size = qnumber(sparc_regs);  ///< Number of registers
   reg_map = sparc64_reg_map;
   bpt_bytes = NULL;                ///< Array of bytes for a breakpoint instruction
   bpt_size = 0;                    ///< Size of this array

}

bool sk3wldbg_sparc64::save_ret_addr(uint64_t retaddr) {
   uc_reg_write(uc, reg_map[SPARC_LR], &retaddr);
   return true;
}


```

`sk3wldbg_sparc.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg.h"

struct sk3wldbg_sparc : public sk3wldbg {
   sk3wldbg_sparc();
   bool save_ret_addr(uint64_t retaddr);
};

struct sk3wldbg_sparc64 : public sk3wldbg {
   sk3wldbg_sparc64();
   bool save_ret_addr(uint64_t retaddr);
};


```

`sk3wldbg_x86.cpp`:

```cpp
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg_x86.h"
#include <unicorn/x86.h>

#define LINUX_X86_EXIT       1
#define LINUX_X86_FORK       2
#define LINUX_X86_READ       3
#define LINUX_X86_WRITE      4
#define LINUX_X86_OPEN       5
#define LINUX_X86_CLOSE      6
#define LINUX_X86_PTRACE     26
#define LINUX_X86_ALARM      27
#define LINUX_X86_BRK        42
#define LINUX_X86_SIGNAL     48
#define LINUX_X86_MMAP       90
#define LINUX_X86_MUNMAP     91
#define LINUX_X86_SOCKETCALL 102
#define LINUX_X86_MPROTECT   125
#define LINUX_X86_EXIT_GROUP 252

static const char *x86_register_classes[] = {
   "General registers",
   "Segment registers",
   "FPU registers",
   "MMX registers",
   "XMM registers",
   NULL
};

enum X86RegClass {
   X86_GENERAL = 1,
   X86_SEGMENT = 2,
   X86_FPU = 4,
   X86_MMX = 8,
   X86_XMM = 16
};

static const char *flag_bits_16[32] = {
   "CF", NULL, "PF", NULL, "AF", NULL, "ZF", "SF", "TF", "IF", "DF", "OF"
};

static const char *flag_bits[32] = {
   "CF", NULL, "PF", NULL, "AF", NULL, "ZF", "SF", "TF", "IF", "DF", "OF",
   "IOPL", "IOPL", "NT", NULL, "RF", "VM", "AC", "VIF", "VIP", "ID"
};

static struct register_info_t x86_16_regs[] = {
   {"EAX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"ECX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EDX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EBX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"ESP", REGISTER_SP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EBP", REGISTER_FP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"ESI", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EDI", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EIP", REGISTER_IP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EFL", 0, X86_GENERAL, dt_dword, flag_bits, 0xdd5},
   {"CS", REGISTER_CS, X86_SEGMENT, dt_word, NULL, 0},
   {"DS", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"SS", REGISTER_SS, X86_SEGMENT, dt_word, NULL, 0},
   {"ES", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"FS", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"GS", 0, X86_SEGMENT, dt_word, NULL, 0},
};

static int32_t x86_16_reg_map[] = {
   UC_X86_REG_EAX, UC_X86_REG_ECX, UC_X86_REG_EDX, UC_X86_REG_EBX,
   UC_X86_REG_ESP, UC_X86_REG_EBP, UC_X86_REG_ESI, UC_X86_REG_EDI,
   UC_X86_REG_EIP, UC_X86_REG_EFLAGS, UC_X86_REG_CS, UC_X86_REG_DS,
   UC_X86_REG_SS, UC_X86_REG_ES, UC_X86_REG_FS, UC_X86_REG_GS
};

static struct register_info_t x86_regs[] = {
   {"EAX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"ECX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EDX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EBX", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"ESP", REGISTER_SP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EBP", REGISTER_FP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"ESI", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EDI", REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EIP", REGISTER_IP | REGISTER_ADDRESS, X86_GENERAL, dt_dword, NULL, 0},
   {"EFL", 0, X86_GENERAL, dt_dword, flag_bits, 0xdd5},
   {"CS", REGISTER_CS, X86_SEGMENT, dt_word, NULL, 0},
   {"DS", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"SS", REGISTER_SS, X86_SEGMENT, dt_word, NULL, 0},
   {"ES", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"FS", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"GS", 0, X86_SEGMENT, dt_word, NULL, 0}
};

static int32_t x86_reg_map[] = {
   UC_X86_REG_EAX, UC_X86_REG_ECX, UC_X86_REG_EDX, UC_X86_REG_EBX,
   UC_X86_REG_ESP, UC_X86_REG_EBP, UC_X86_REG_ESI, UC_X86_REG_EDI,
   UC_X86_REG_EIP, UC_X86_REG_EFLAGS, UC_X86_REG_CS, UC_X86_REG_DS,
   UC_X86_REG_SS, UC_X86_REG_ES, UC_X86_REG_FS, UC_X86_REG_GS
};

static struct register_info_t x64_regs[] = {
   {"RAX", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"RCX", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"RDX", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"RBX", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"RSP", REGISTER_SP | REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"RBP", REGISTER_FP | REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"RSI", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"RDI", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"R8", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"R9", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"R10", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"R11", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"R12", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"R13", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"R14", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"R15", REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"RIP", REGISTER_IP | REGISTER_ADDRESS, X86_GENERAL, dt_qword, NULL, 0},
   {"EFL", 0, X86_GENERAL, dt_dword, flag_bits, 0xdd5},
   {"CS", REGISTER_CS, X86_SEGMENT, dt_word, NULL, 0},
   {"DS", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"SS", REGISTER_SS, X86_SEGMENT, dt_word, NULL, 0},
   {"ES", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"FS", 0, X86_SEGMENT, dt_word, NULL, 0},
   {"GS", 0, X86_SEGMENT, dt_word, NULL, 0},
};

static int32_t x64_reg_map[] = {
   UC_X86_REG_RAX, UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_RBX,
   UC_X86_REG_RSP, UC_X86_REG_RBP, UC_X86_REG_RSI, UC_X86_REG_RDI,
   UC_X86_REG_R8, UC_X86_REG_R9, UC_X86_REG_R10, UC_X86_REG_R11,
   UC_X86_REG_R12, UC_X86_REG_R13, UC_X86_REG_R14, UC_X86_REG_R15,
   UC_X86_REG_RIP, UC_X86_REG_EFLAGS, UC_X86_REG_CS, UC_X86_REG_DS,
   UC_X86_REG_SS, UC_X86_REG_ES, UC_X86_REG_FS, UC_X86_REG_GS
};

sk3wldbg_x86_16::sk3wldbg_x86_16() : sk3wldbg("metapc", UC_ARCH_X86, UC_MODE_16) {
   //reset any overridden function pointers and setup register name fields
   register_classes = x86_register_classes;
   register_classes_default = X86_GENERAL;  ///< Mask of default printed register classes
   _registers = x86_16_regs;                ///< Array of registers. Use registers() to access it
   registers_size = qnumber(x86_16_regs);   ///< Number of registers
   reg_map = x86_16_reg_map;
   bpt_bytes = (const uchar *)"\xcc";  ///< Array of bytes for a breakpoint instruction
   bpt_size = 1;                    ///< Size of this array

}

bool sk3wldbg_x86_16::save_ret_addr(uint64_t retaddr) {
   uint64_t new_sp = get_sp() - sizeof(uint16_t);
   uc_mem_write(uc, new_sp, &retaddr, sizeof(uint64_t));
   set_sp(new_sp);
   return true;
}

sk3wldbg_x86_32::sk3wldbg_x86_32() : sk3wldbg("metapc", UC_ARCH_X86, UC_MODE_32) {
   //reset any overridden function pointers and setup register name fields

   register_classes = x86_register_classes;
   register_classes_default = X86_GENERAL;  ///< Mask of default printed register classes
   _registers = x86_regs;                ///< Array of registers. Use registers() to access it
   registers_size = qnumber(x86_regs);   ///< Number of registers
   reg_map = x86_reg_map;
   bpt_bytes = (const uchar *)"\xcc";    ///< Array of bytes for a breakpoint instruction
   bpt_size = 1;                         ///< Size of this array

}

bool sk3wldbg_x86_32::save_ret_addr(uint64_t retaddr) {
   uint64_t new_sp = get_sp() - sizeof(uint32_t);
   uc_mem_write(uc, new_sp, &retaddr, sizeof(uint32_t));
   set_sp(new_sp);
   return true;
}

bool sk3wldbg_x86_32::is_system_call(uint8_t *inst, uint32_t size) {
   //need to check OS flavor
   if (size == 2 && 0x80cd == *(uint16_t*)inst) {
      return true;
   }
   return false;
}

void sk3wldbg_x86_32::handle_system_call(uint8_t *inst, uint32_t size) {
   //need to check OS flavor
   if (size == 2 && 0x80cd == *(uint16_t*)inst) {
      uint32_t eax;
      uc_reg_read(uc, UC_X86_REG_EAX, &eax);
      switch (eax) {
         case LINUX_X86_EXIT:
            uc_emu_stop(uc);
            break;
         case LINUX_X86_FORK:
            break;
         case LINUX_X86_READ:
            break;
         case LINUX_X86_WRITE:
            break;
         case LINUX_X86_OPEN:
            break;
         case LINUX_X86_CLOSE:
            break;
         case LINUX_X86_PTRACE:
            break;
         case LINUX_X86_ALARM:
            break;
         case LINUX_X86_BRK:
            break;
         case LINUX_X86_SIGNAL:
            break;
         case LINUX_X86_MMAP:
            break;
         case LINUX_X86_MUNMAP:
            break;
         case LINUX_X86_SOCKETCALL:
            break;
         case LINUX_X86_MPROTECT:
            break;
         case LINUX_X86_EXIT_GROUP:
            break;
         default:
            break;
      }
   }
}

void x86_32_bkpt(uc_engine *uc, sk3wldbg_x86_32 *dbg) {
   uc_emu_stop(uc);
   dbg->emu_state = RS_PAUSE;
   debug_event_t brk;

#if IDA_SDK_VERSION >= 710
   brk.set_eid(::BREAKPOINT);
   bptaddr_t &bpt = brk.bpt();
#else
   brk.eid = ::BREAKPOINT;
   e_breakpoint_t &bpt = brk.bpt;
#endif
   brk.pid = dbg->the_process;
   brk.tid = dbg->the_threads.front();
   brk.ea = (ea_t)dbg->get_pc();
   msg("x86 breakpoint hit at: %p\n", (uint64_t)brk.ea);
   brk.handled = true;
   bpt.hea = bpt.kea = brk.ea;
   dbg->enqueue_debug_evt(brk);
}

void x86_32_code_hook(uc_engine *uc, uint64_t address, uint32_t /*size*/, sk3wldbg_x86_32 *dbg) {
   static uint64_t last_pc;
//   msg("x86 code hit at: %p\n", address);
   if (last_pc != address && dbg->breakpoints.find((ea_t)address) != dbg->breakpoints.end()) {
      uc_emu_stop(uc);
//      dbg->emu_state = RS_PAUSE;
      dbg->queue_dbg_event(false);
   }
   last_pc = address;
}

void x86_32_trace(uc_engine * /*uc*/, uint64_t /*address*/, uint32_t /*size*/, void *user_data) {
   sk3wldbg_x86_32 *emu = (sk3wldbg_x86_32*)user_data;
   //record trace data and continue?
   //might need to check for breakpoints in here if other methods fail
}

/*
void sk3wldbg_x86_32::install_initial_hooks() {
   uc_hook hh;
   uc_err err = uc_hook_add(uc, &hh, UC_HOOK_CODE, x86_32_code_hook, this, 1, 0);
   if (err) {
      msg("Failed on uc_hook_add(x86_32_code_hook) with error returned: %u\n", err);
   }
}
*/

sk3wldbg_x86_64::sk3wldbg_x86_64() : sk3wldbg("metapc", UC_ARCH_X86, UC_MODE_64) {
   //reset any overridden function pointers and setup register name fields
   register_classes = x86_register_classes;
   register_classes_default = X86_GENERAL;  ///< Mask of default printed register classes
   _registers = x64_regs;                ///< Array of registers. Use registers() to access it
   registers_size = qnumber(x64_regs);   ///< Number of registers
   reg_map = x64_reg_map;
   bpt_bytes = (const uchar *)"\xcc";  ///< Array of bytes for a breakpoint instruction
   bpt_size = 1;                    ///< Size of this array

}

bool sk3wldbg_x86_64::save_ret_addr(uint64_t retaddr) {
   uint64_t new_sp = get_sp() - sizeof(uint64_t);
   uc_mem_write(uc, new_sp, &retaddr, sizeof(uint64_t));
   set_sp(new_sp);
   return true;
}

```

`sk3wldbg_x86.h`:

```h
/*
   Source for Sk3wlDbg IdaPro plugin
   Copyright (c) 2016 Chris Eagle

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include "sk3wldbg.h"

struct sk3wldbg_x86_16 : public sk3wldbg {
   sk3wldbg_x86_16();
   bool save_ret_addr(uint64_t retaddr);
   bool call_changes_sp() {return true;};
};

struct sk3wldbg_x86_32 : public sk3wldbg {
   sk3wldbg_x86_32();   
   bool save_ret_addr(uint64_t retaddr);
   bool call_changes_sp() {return true;};
   virtual bool is_system_call(uint8_t *inst, uint32_t size);
   virtual void handle_system_call(uint8_t *inst, uint32_t size);
};

struct sk3wldbg_x86_64 : public sk3wldbg {
   sk3wldbg_x86_64();
   bool save_ret_addr(uint64_t retaddr);
   bool call_changes_sp() {return true;};
};

```

`teb32.h`:

```h
//
// [TEB_/PEB_/SEH SUMMARY]
// This file contains the undocumented TEB_ (Thread Environment Block) and PEB_ (Process Environment Block)
// definitions for the Intel x86 32-bit Windows operating systems starting from NT 3.51 through Windows 10.  The TEB_
// is also known as the TIB (Thread Information Block), especially under the Windows 9.x operating systems.
//
// Additionally I have added the definitions for the partially documented Win32 SEH (Structured Exception Handling)
// that are not only referenced by the TEB_, but are normally strewn across both C headers and assembler includes.
// These definitions also include the constants specific to the Visual C++ compiler's implementation of Win32
// SEH beyond the facilities provided by the Windows operating systems.  The TEB_ and PEB_ are declared near the
// bottom of this file, with all referenced structures recursively defined above them for completeness sake.
//
// Should you be writing low level code, you might find all of these definitions in one spot a handy reference.  If
// you wanted to use this C header file in your own code, you'd probably want to remove the redundant definitions
// (almost all except for the TEB_ and PEB_ structures) as they are defined automatically as a result of including
// windows.h.  If you won't be including windows.h or are compiling with GCC under Linux, no changes are
// necessary.
//
// [WINDOWS COMPATIBILITY]
// Both the TEB_ and PEB_ structures support Windows NT 3.51 thru Windows 10
//
// [HOW TO ACCESS THESE STRUCTURES]
// The pointers to these structures can be obtained using the following x86 assembly code:
//      mov eax, fs:[18h]   //eax = TEB_
//      mov eax, fs:[30h]   //eax = PEB_
//
// Or, by using the following Visual C++ compiler intrinsics:
//      voidp pTeb = __readfsdword(0x18);
//      voidp pPeb = __readfsdword(0x30);
//
// [BUGS]
// This header file is meant mostly for documentation purposes as an alternative to the various tables found
// online; therefore it may contain bugs such that certain members might not be at the offsets stated in the
// comments because I may have forgotten to pad prior members so that everything lines up.  However, I did attempt
// to have all the members line up as documented by each member's offset (see comment to right of each member), so
// please report any bugs or additions to: http://bytepointer.com/contact.htm
//
// [STYLE USED IN THIS FILE]
// I modified the structures included in this file either from the original official forms found in the Windows
// headers or from various sources online, although the result is functionally equivalent.  The modifications were
// made according to the following scheme for simplicity and clarity:
//
// - array size values are in hex (base-16)
//
// - I avoided creating extraneous pointer types either standalone or as part of the trailing portions of structure
//  definitions.  These take the format Pxxxx where xxxx is the type. Microsoft has historically declared Pxxxx
//  definitions for practically every Windows structure in place of the type identifier with a trailing asterisk.
//  I've always found the trailing asterisk signifying a pointer type to be clearer than the Pxxxx alternative
//  because you can quickly spot them at a glance (especially when syntax hilighting kicks in).
//
// - Windows headers use many aliases for 8, 16, 32 and 64-bit values (UCHAR, ULONG, ULONG_PTR, LONG, LONGLONG, etc.)
//   which are inconsistent at times. I tend to prefer the explicitly specific assembler names: BYTE, WORD, DWORD and
//   QWORD as they are more platform independent names for unsigned values.  Any signed integer type consisting of
//   the term LONG (especially the recursive LONGLONG) just makes me cringe because I don't feel they convey size
//   very well. My naming scheme is therefore:
//
//     BYTE-SIZE                      1     2       4         8
//     unsigned integer types:     BYTE, WORD,  DWORD and QWORD
//     signed integer types:       CHAR, INT16, INT32 and INT64
//
// NOTE: voidp and DWORD may be used interchangeably on 32-bit operating systems, however I attempted
//       to use voidp (or typed structure pointer where possible) where I was sure the member was to
//       hold a pointer.  Otherwise and where members were to hold padding ints (of any size), I
//       avoided the use of pointer types even when originally declared to be of type voidp. Also I
//       retained the use of some aliases, such as BOOLEAN, NTSTATUS, _HANDLE, etc. only for the
//       purpose of preserving the meaning of the associated structure members.
//
// [MICROSOFT FIRST DOCUMENTS THE TEB_ and PEB_]
// Starting with the release of Visual Studio .NET (2002), Microsoft released a new header, winternl.h
// with the Platform SDK. Within this new header was the first public documentation for the TEB_ and PEB_.
// Microsoft, being legally forced to disclose this information, only released 2 members of the PEB_
// (BeingDebugged,SessionId) and 3 members of the TEB_ (TlsSlots,ReservedForOle,TlsExpansionSlots).
// The original portion of the winternl.h header file is shown below along with Microsoft's usual stern
// warnings about not using these fields because Windows might change.
//
//      //
//      // The PEB_ and TEB_ structures are subject to changes between Windows
//      // releases, thus the fields offsets may change as well as the Reserved
//      // fields.  The Reserved fields are reserved for use only by the Windows
//      // operating systems.  Do not assume a maximum size for the structures.
//      //
//
//      // Instead of using the BeingDebugged field, use the Win32 APIs
//      //     IsDebuggerPresent, CheckRemoteDebuggerPresent
//      // Instead of using the SessionId field, use the Win32 APIs
//      //     GetCurrentProcessId and ProcessIdToSessionId
//      // Sample x86 assembly code that gets the SessionId (subject to change
//      //     between Windows releases, use the Win32 APIs to make your application
//      //     resilient to changes)
//      //     mov     eax,fs:[00000018]
//      //     mov     eax,[eax+0x30]
//      //     mov     eax,[eax+0x1d4]
//      //
//      struct PEB_ {
//          BYTE Reserved1[2];
//          BYTE BeingDebugged;
//          BYTE Reserved2[229];
//          voidp Reserved3[59];
//          ULONG SessionId;
//      } PEB_, *PPEB;
//
//      // Instead of using the Tls fields, use the Win32 TLS APIs
//      //     TlsAlloc, TlsGetValue, TlsSetValue, TlsFree
//      //
//      // Instead of using the ReservedForOle field, use the COM API
//      //     CoGetContextToken
//      //
//      struct TEB_ {
//          BYTE Reserved1[1952];
//          voidp Reserved2[412];
//          voidp TlsSlots[64];
//          BYTE Reserved3[8];
//          voidp Reserved4[26];
//          voidp ReservedForOle;  // Windows 2000 only
//          voidp Reserved5[4];
//          voidp TlsExpansionSlots;
//      } TEB_;
//      typedef TEB_ *PTEB;
//
// [REFERENCES]
// The information below was compiled from various sources:
//    http://www.geoffchappell.com/studies/windows/win32/ntdll/structs/TEB_/index.htm
//    http://www.geoffchappell.com/studies/windows/win32/ntdll/structs/PEB_/index.htm
//    http://terminus.rewolf.pl/terminus/structures/ntdll/_TEB32_x86.html
//    https://en.wikipedia.org/wiki/Win32_Thread_Information_Block
//    http://www.nirsoft.net/kernel_struct/vista/index.html
//    Microsoft's Platform SDK headers / MSDN
//
// [CHANGELIST]
//    2018-05-02:   -now can be compiled alongside windows.h (without changes) or by defining WANT_ALL_WINDOWS_H_DEFINITIONS so this file can be used standalone
//                  -this file may also be included alongside tebpeb64.h which can be found at http://bytepointer.com/resources/tebpeb64.h
//                  -increased PEB_ size to 0x258 for [at least] Windows 10: member addition dwSystemCallMode at offset 0x254
//                   REFERENCE: https://www.malwaretech.com/2015/07/windows-10-system-call-stub-changes.html
//
//    2017-07-29:   initial public release (first stable version)
//

#include <stdint.h>

//disable some Visual C++ warnings
#ifdef _MSC_VER
    //when compiling as C
    #pragma warning (disable:4214) //Warning Level 4: C4214: nonstandard extension used : bit field types other than int

    //"#pragma pack(1)" not needed as Microsoft has designed all structure members to be on natural boundaries

    #ifndef STDCALL
        #define STDCALL         __stdcall
    #endif
    #ifndef CDECL
        #define CDECL           __cdecl
    #endif
#else
    //assume GCC
    #ifndef STDCALL
        #define STDCALL         __attribute__ ((stdcall))
    #endif
    #ifndef CDECL
        #define CDECL           __attribute__ ((cdecl))
    #endif
#endif

typedef uint32_t voidp;     //proxy for void*
typedef uint32_t CHARp;     //proxy for CHAR*
typedef uint32_t WCHARp;     //proxy for WCHAR*
typedef uint32_t DWORDp;     //proxy for DWORD*
typedef voidp    _HANDLE;

#ifndef _MSC_VER

//
// Base types
//

//This is for 32 bit so we need pointer fields to size out to 32 bits even when
//building on 64-bit systems

typedef uint8_t           BYTE;
typedef int8_t            CHAR;
typedef uint16_t          WORD;
typedef int16_t           INT16;
typedef uint32_t          DWORD;
typedef int32_t           INT32;
typedef BYTE              BOOLEAN;
typedef BYTE              UCHAR;
typedef voidp             _HANDLE;
typedef WORD              WCHAR;
typedef WORD              USHORT;
typedef DWORD             LCID;
typedef DWORD             KAFFINITY;
typedef DWORD             ULONG;

#endif //#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS


//always declare 64-bit types

#ifdef _MSC_VER
    //Visual C++
    typedef unsigned __int64    QWORD;
    typedef __int64             INT64;
#else
    //GCC
    typedef uint64_t  QWORD;
    typedef int64_t   INT64;
#endif


//#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS

//
// General-purpose structures
//

union LARGE_INTEGER_
{
    struct
    {
        DWORD   LowPart;
        INT32   HighPart;
    } u;
    INT64       QuadPart;
};

union ULARGE_INTEGER_
{
    struct
    {
       DWORD LowPart;
       DWORD HighPart;
    } u;
    QWORD QuadPart;
};

struct GUID_
{
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
};

typedef voidp LIST_ENTRY_p;

struct LIST_ENTRY_
{
    LIST_ENTRY_p Flink;
    LIST_ENTRY_p Blink;
};

struct RTL_CRITICAL_SECTION_;

typedef voidp RTL_CRITICAL_SECTION_p;

struct RTL_CRITICAL_SECTION_
{
    WORD                    Type;
    WORD                    CreatorBackTraceIndex;
    RTL_CRITICAL_SECTION_p   CriticalSection;
    LIST_ENTRY_              ProcessLocksList;
    DWORD                   EntryCount;
    DWORD                   ContentionCount;
    DWORD                   Flags;
    WORD                    CreatorBackTraceIndexHigh;
    WORD                    SpareUSHORT;
};

typedef voidp RTL_CRITICAL_SECTION_DEBUG_p;

struct RTL_CRITICAL_SECTION_DEBUG_
{
    RTL_CRITICAL_SECTION_DEBUG_p DebugInfo;
    INT32                       LockCount;
    INT32                       RecursionCount;
    _HANDLE                      OwningThread;
    _HANDLE                      LockSemaphore;
    DWORD                       SpinCount;
};

//#endif //WANT_ALL_WINDOWS_H_DEFINITIONS


struct CLIENT_ID_
{
     DWORD  ProcessId;
     DWORD  ThreadId;
};

struct PROCESSOR_NUMBER_
{
    WORD    Group;
    BYTE    Number;
    BYTE    Reserved;
};

struct STRING_
{
    WORD    Length;
    WORD    MaximumLength;
    CHARp   Buffer;
};

struct UNICODE_STRING_
{
    WORD    Length;
    WORD    MaximumLength;
    WCHARp  Buffer;
};


//
// Exception-specific structures and definitions
//

//CONTEXT_ flags
#define CONTEXT_i386                    0x00010000                      // this assumes that i386 and
#define CONTEXT_i486                    0x00010000                      // i486 have identical CONTEXT_ records
#define CONTEXT_CONTROL                 (CONTEXT_i386 | 0x00000001L)    // SS:SP, CS:IP, FLAGS, BP
#define CONTEXT_INTEGER                 (CONTEXT_i386 | 0x00000002L)    // AX, BX, CX, DX, SI, DI
#define CONTEXT_SEGMENTS                (CONTEXT_i386 | 0x00000004L)    // DS, ES, FS, GS
#define CONTEXT_FLOATING_POINT          (CONTEXT_i386 | 0x00000008L)    // 387 state
#define CONTEXT_DEBUG_REGISTERS         (CONTEXT_i386 | 0x00000010L)    // DB 0-3,6,7
#define CONTEXT_EXTENDED_REGISTERS      (CONTEXT_i386 | 0x00000020L)    // cpu specific extensions
#define CONTEXT_FULL                    (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS)
#define CONTEXT_ALL                     (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | CONTEXT_EXTENDED_REGISTERS)

//exception flags
#define EXCEPTION_NONCONTINUABLE        0x1     // Noncontinuable exception
#define EXCEPTION_UNWINDING             0x2     // Unwind is in progress; same as EH_UNWINDING
#define EXCEPTION_EXIT_UNWIND           0x4     // Exit unwind is in progress; same as EH_EXIT_UNWIND
#define EXCEPTION_STACK_INVALID         0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL           0x10    // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND         0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND       0x40    // Collided exception handler call
#define EXCEPTION_UNWIND                (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)
#define IS_UNWINDING(Flag)              ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag)            ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag)          (Flag & EXCEPTION_TARGET_UNWIND)

//msvc exception filter expression return codes
#define EXCEPTION_EXECUTE_HANDLER       1   //same as FILTER_ACCEPT
#define EXCEPTION_CONTINUE_SEARCH       0   //same as FILTER_CONTINUE_SEARCH
#define EXCEPTION_CONTINUE_EXECUTION    -1  //same as FILTER_DISMISS

//#ifdef WANT_ALL_WINDOWS_H_DEFINITIONS

//exception handler (disposition) return values
enum EXCEPTION_DISPOSITION_
{
    _ExceptionContinueExecution,         //0; same as DISPOSITION_DISMISS, _XCPT_CONTINUE_EXECUTION
    _ExceptionContinueSearch,            //1; same as DISPOSITION_CONTINUE_SEARCH, _XCPT_CONTINUE_SEARCH
    _ExceptionNestedException,           //2; same as DISPOSITION_NESTED_EXCEPTION
    _ExceptionCollidedUnwind             //3; same as DISPOSITION_COLLIDED_UNWIND
};

typedef voidp EXCEPTION_RECORD_p;

#define EXCEPTION_MAXIMUM_PARAMETERS 15
struct EXCEPTION_RECORD_ //size=0x50
{
    DWORD               ExceptionCode;                                          //0x00
    DWORD               ExceptionFlags;                                         //0x04 - see possible values above
    EXCEPTION_RECORD_p   ExceptionRecord;                                        //0x08
    voidp               ExceptionAddress;                                       //0x0C
    DWORD               NumberParameters;                                       //0x10
    DWORD               ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];     //0x14
};

#define SIZE_OF_80387_REGISTERS 80
struct FLOATING_SAVE_AREA_ //size=0x70
{
    DWORD   ControlWord;                                //0x00
    DWORD   StatusWord;                                 //0x04
    DWORD   TagWord;                                    //0x08
    DWORD   ErrorOffset;                                //0x0C
    DWORD   ErrorSelector;                              //0x10
    DWORD   DataOffset;                                 //0x14
    DWORD   DataSelector;                               //0x18
    BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];      //0x1C
    DWORD   Cr0NpxState;                                //0x6C
};

#define MAXIMUM_SUPPORTED_EXTENSION 512
struct CONTEXT_ //size=0x2CC
{
    //determines which groups of members are valid
    DWORD               ContextFlags;                                       //0x00 - see possible values above
    //following member group valid when CONTEXT_DEBUG_REGISTERS set
    DWORD               Dr0;                                                //0x04
    DWORD               Dr1;                                                //0x08
    DWORD               Dr2;                                                //0x0C
    DWORD               Dr3;                                                //0x10
    DWORD               Dr6;                                                //0x14
    DWORD               Dr7;                                                //0x18
    //following member valid when CONTEXT_FLOATING_POINT set
    FLOATING_SAVE_AREA_  FloatSave;                                          //0x1C
    //following member group valid when CONTEXT_SEGMENTS set
    DWORD               SegGs;                                              //0x8C
    DWORD               SegFs;                                              //0x90
    DWORD               SegEs;                                              //0x94
    DWORD               SegDs;                                              //0x98
    //following member group valid when CONTEXT_INTEGER set
    DWORD               Edi;                                                //0x9C
    DWORD               Esi;                                                //0xA0
    DWORD               Ebx;                                                //0xA4
    DWORD               Edx;                                                //0xA8
    DWORD               Ecx;                                                //0xAC
    DWORD               Eax;                                                //0xB0
    //following member group valid when CONTEXT_CONTROL set
    DWORD               Ebp;                                                //0xB4
    DWORD               Eip;                                                //0xB8
    DWORD               SegCs;                                              //0xBC
    DWORD               EFlags;                                             //0xC0
    DWORD               Esp;                                                //0xC4
    DWORD               SegSs;                                              //0xC8
    //following member valid when CONTEXT_EXTENDED_REGISTERS set
    BYTE                ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];     //0xCC
};

typedef voidp CONTEXT_p;

//used with UnhandledExceptionFilter()/SetUnhandledExceptionFilter() and newer Vectored Exception handling functions
struct EXCEPTION_POINTERS_
{
    EXCEPTION_RECORD_p   ExceptionRecord;
    CONTEXT_p            ContextRecord;
};

//#endif //WANT_ALL_WINDOWS_H_DEFINITIONS

struct EXCEPTION_REGISTRATION_;

typedef voidp EXCEPTION_REGISTRATION_p;

//dispatcher CONTEXT_ is reserved for exception handler implementation (e.g. compilers)
struct DISPATCHER_CONTEXT_
{
    EXCEPTION_REGISTRATION_p RegistrationPointer;
};

//exception handler signatures
//typedef EXCEPTION_DISPOSITION_ (CDECL *ExceptionHandler)(EXCEPTION_RECORD_p ExceptionRecord, EXCEPTION_REGISTRATION_p EstablisherFrame, CONTEXT_p ContextRecord, DISPATCHER_CONTEXT_p DispatcherContext); //same as EXCEPTION_ROUTINE and _except_handler
//typedef INT32 (STDCALL *TopLevelExceptionFilter)(EXCEPTION_POINTERS_* ExceptionInfo); //same as TOP_LEVEL_EXCEPTION_FILTER for SetUnhandledExceptionFilter();
//typedef INT32 (STDCALL *VectoredExceptionHandler)(EXCEPTION_POINTERS_* ExceptionInfo); //same as PVECTORED_EXCEPTION_HANDLER and above signature used with AddVectoredExceptionHandler(), RemoveVectoredExceptionHandler() for XP/WS03 and up

typedef voidp ExceptionHandler_p;
typedef voidp EXCEPTION_REGISTRATION_p;

//stack exception frame a.k.a. EXCEPTION_REGISTRATION_RECORD
struct EXCEPTION_REGISTRATION_
{
    EXCEPTION_REGISTRATION_p     prev;
    ExceptionHandler_p           handler;
};
#define EXCEPTION_CHAIN_END ((EXCEPTION_REGISTRATION_p)-1)

//
// PEB_-specific structures
//

//forward declarations for unknown structures
struct ACTIVATION_CONTEXT_DATA_ {voidp dummy;}; //XP and up
struct ASSEMBLY_STORAGE_MAP_ {voidp dummy;};       //XP and up
struct FLS_CALLBACK_INFO_ {voidp dummy;};             //WS03 and up

struct RTL_DRIVE_LETTER_CURDIR_
{
     WORD       Flags;
     WORD       Length;
     DWORD      TimeStamp;
     STRING_     DosPath;
};

struct PEB_LDR_DATA_
{
     DWORD          Length;
     BYTE           Initialized;
     voidp          SsHandle;
     LIST_ENTRY_     InLoadOrderModuleList;
     LIST_ENTRY_     InMemoryOrderModuleList;
     LIST_ENTRY_     InInitializationOrderModuleList;
     voidp          EntryInProgress;
};

struct LDR_DATA_TABLE_ENTRY_ {
   LIST_ENTRY_ InLoadOrderLinks;
   LIST_ENTRY_ InMemoryOrderLinks;
   union {
       LIST_ENTRY_ InInitializationOrderLinks;
       LIST_ENTRY_ InProgressLinks;
   };
   voidp DllBase;
   voidp EntryPoint;
   ULONG SizeOfImage;
   UNICODE_STRING_ FullDllName;
   UNICODE_STRING_ BaseDllName;
   ULONG Flags;
   union {
       UCHAR FlagGroup [4];
       ULONG _Flags;
       struct {
           ULONG PackagedBinary : 1;           // 0x00000001
           ULONG MarkedForRemoval : 1;         // 0x00000002
           ULONG ImageDll : 1;                 // 0x00000004
           ULONG LoadNotificationsSent : 1;    // 0x00000008
           ULONG TelemetryEntryProcessed : 1;  // 0x00000010
           ULONG ProcessStaticImport : 1;      // 0x00000020
           ULONG InLegacyLists : 1;            // 0x00000040
           ULONG InIndexes : 1;                // 0x00000080
           ULONG ShimDll : 1;                  // 0x00000100
           ULONG InExceptionTable : 1;         // 0x00000200
           ULONG ReservedFlags1 : 2;
           ULONG LoadInProgress : 1;           // 0x00001000
           ULONG ReservedFlags2 : 1;
           ULONG EntryProcessed : 1;           // 0x00004000
           ULONG ReservedFlags3 : 3;
           ULONG DontCallForThreads : 1;       // 0x00040000
           ULONG ProcessAttachCalled : 1;      // 0x00080000
           ULONG ProcessAttachFailed : 1;      // 0x00100000
           ULONG CorDeferredValidate : 1;      // 0x00200000
           ULONG CorImage : 1;                 // 0x00400000
           ULONG DontRelocate : 1;             // 0x00800000
           ULONG CorILOnly : 1;                // 0x01000000
           ULONG ReservedFlags5 : 3;
           ULONG Redirected : 1;               // 0x10000000
           ULONG ReservedFlags6 : 2;
           ULONG CompatDatabaseProcessed : 1;  // 0x80000000
       };
   };
   USHORT LoadCount;
   USHORT ObsoleteLoadCount;
   USHORT TlsIndex;
   union {
       LIST_ENTRY_ HashLinks;
       struct {
           voidp SectionPointer;
           ULONG CheckSum;
       };
   };
};

typedef voidp PEB_FREE_BLOCK_p;

struct PEB_FREE_BLOCK_
{
     PEB_FREE_BLOCK_p    Next;
     DWORD              Size;
};

struct RTL_USER_PROCESS_PARAMETERS_
{
    DWORD                   MaximumLength;                 //0x00
    DWORD                   Length;                        //0x04
    DWORD                   Flags;                         //0x08
    DWORD                   DebugFlags;                    //0x0C
    voidp                   ConsoleHandle;                 //0x10
    DWORD                   ConsoleFlags;                  //0x14
    _HANDLE                  StdInputHandle;                //0x18
    _HANDLE                  StdOutputHandle;               //0x1C
    _HANDLE                  StdErrorHandle;                //0x20
    UNICODE_STRING_          CurrentDirectoryPath;          //0x24
    _HANDLE                  CurrentDirectoryHandle;        //0x2C
    UNICODE_STRING_          DllPath;                       //0x30
    UNICODE_STRING_          ImagePathName;                 //0x38
    UNICODE_STRING_          CommandLine;                   //0x40
    voidp                   Environment;                   //0x48
    DWORD                   StartingPositionLeft;          //0x4C
    DWORD                   StartingPositionTop;           //0x50
    DWORD                   Width;                         //0x54
    DWORD                   Height;                        //0x58
    DWORD                   CharWidth;                     //0x5C
    DWORD                   CharHeight;                    //0x60
    DWORD                   ConsoleTextAttributes;         //0x64
    DWORD                   WindowFlags;                   //0x68
    DWORD                   ShowWindowFlags;               //0x6C
    UNICODE_STRING_          WindowTitle;                   //0x70
    UNICODE_STRING_          DesktopName;                   //0x78
    UNICODE_STRING_          ShellInfo;                     //0x80
    UNICODE_STRING_          RuntimeData;                   //0x88
    RTL_DRIVE_LETTER_CURDIR_ DLCurrentDirectory[0x20];      //0x90
};

typedef voidp PEB_LDR_DATA_p;
typedef voidp RTL_USER_PROCESS_PARAMETERS_p;

typedef voidp ACTIVATION_CONTEXT_DATA_p;
typedef voidp ASSEMBLY_STORAGE_MAP_p;
typedef voidp ACTIVATION_CONTEXT_DATA_p;
typedef voidp ASSEMBLY_STORAGE_MAP_p;

typedef voidp FLS_CALLBACK_INFO_p;


//
// PEB_ (Process Environment Block) 32-bit
//
// The size of this structure is OS dependent:
//    0x0098    NT 3.51
//    0x0150    NT 4.0
//    0x01E8    Win2k
//    0x020C    XP
//    0x0230    WS03
//    0x0238    Vista
//    0x0240    Win7_BETA
//    0x0248    Win6
//    0x0250    Win8
//    0x0258    Win10
//
struct PEB_
{
    BOOLEAN                         InheritedAddressSpace;              //0x0000
    BOOLEAN                         ReadImageFileExecOptions;           //0x0001
    BOOLEAN                         BeingDebugged;                      //0x0002
    union
    {
        BOOLEAN                     SpareBool;                          //0x0003 (NT3.51-late WS03)
        struct
        {
            BYTE                    ImageUsesLargePages          : 1;   //0x0003:0 (WS03_SP1+)
            BYTE                    IsProtectedProcess           : 1;   //0x0003:1 (Vista+)
            BYTE                    IsLegacyProcess              : 1;   //0x0003:2 (Vista+)
            BYTE                    IsImageDynamicallyRelocated  : 1;   //0x0003:3 (Vista+)
            BYTE                    SkipPatchingUser32Forwarders : 1;   //0x0003:4 (Vista_SP1+)
            BYTE                    IsPackagedProcess            : 1;   //0x0003:5 (Win8_BETA+)
            BYTE                    IsAppContainer               : 1;   //0x0003:6 (Win8_RTM+)
            BYTE                    SpareBits                    : 1;   //0x0003:7
        } bits;
    } byte3;
    _HANDLE                          Mutant;                             //0x0004
    voidp                           ImageBaseAddress;                   //0x0008
    PEB_LDR_DATA_p                   Ldr;                                //0x000C  (all loaded modules in process)
    RTL_USER_PROCESS_PARAMETERS_p    ProcessParameters;                  //0x0010
    voidp                           SubSystemData;                      //0x0014
    voidp                           ProcessHeap;                        //0x0018
    RTL_CRITICAL_SECTION_p           FastPebLock;                        //0x001C
    union
    {
        voidp                       FastPebLockRoutine;                 //0x0020 (NT3.51-Win2k)
        voidp                       SparePtr1;                          //0x0020 (early WS03)
        voidp                       AtlThunkSListPtr;                   //0x0020 (late WS03+)
    } dword20;
    union
    {
        voidp                       FastPebUnlockRoutine;               //0x0024 (NT3.51-XP)
        voidp                       SparePtr2;                          //0x0024 (WS03)
        voidp                       IFEOKey;                            //0x0024 (Vista+)
    } dword24;
    union
    {
        DWORD                       EnvironmentUpdateCount;             //0x0028 (NT3.51-WS03)
        struct
        {
            DWORD                   ProcessInJob            : 1;        //0x0028:0 (Vista+)
            DWORD                   ProcessInitializing     : 1;        //0x0028:1 (Vista+)
            DWORD                   ProcessUsingVEH         : 1;        //0x0028:2 (Vista_SP1+)
            DWORD                   ProcessUsingVCH         : 1;        //0x0028:3 (Vista_SP1+)
            DWORD                   ProcessUsingFTH         : 1;        //0x0028:4 (Win7_BETA+)
            DWORD                   ReservedBits0           : 27;       //0x0028:5 (Win7_BETA+)
        } vista_CrossProcessFlags;
    } struct28;
    union
    {
        voidp                       KernelCallbackTable;                //0x002C (Vista+)
        voidp                       UserSharedInfoPtr;                  //0x002C (Vista+)
    } dword2C;
    DWORD                           SystemReserved;                     //0x0030 (NT3.51-XP)
    //Microsoft seems to keep changing their mind with DWORD 0x34
    union
    {
        DWORD                       SystemReserved2;                    //0x0034 (NT3.51-Win2k)
        struct
        {
            DWORD                   ExecuteOptions          : 2;        //0x0034:0 (XP-early WS03)
            DWORD                   SpareBits               : 30;       //0x0034:2 (XP-early WS03)
        } xpBits;
        DWORD                       AtlThunkSListPtr32;                 //0x0034 (late XP,Win7+)
        DWORD                       SpareUlong;                         //0x0034 (late WS03-Vista)
        struct
        {
            DWORD                   HeapTracingEnabled      : 1;        //0x0034:0 (Win7_BETA)
            DWORD                   CritSecTracingEnabled   : 1;        //0x0034:1 (Win7_BETA)
            DWORD                   SpareTracingBits        : 30;       //0x0034:2 (Win7_BETA)
        } win7_TracingFlags;
    } dword34;
    union
    {
        PEB_FREE_BLOCK_p             FreeList;                           //0x0038 (NT3.51-early Vista)
        DWORD                       SparePebPtr0;                       //0x0038 (last Vista)
        voidp                       ApiSetMap;                          //0x0038 (Win7+)
    } dword38;
    DWORD                           TlsExpansionCounter;                //0x003C
    voidp                           TlsBitmap;                          //0x0040
    DWORD                           TlsBitmapBits[2];                   //0x0044
    voidp                           ReadOnlySharedMemoryBase;           //0x004C
    union
    {
        voidp                       ReadOnlyShareMemoryHeap;            //0x0050 (NT3.51-WS03)
        voidp                       HotpatchInformation;                //0x0050 (Vista+)
    } dword50;
    voidp                          ReadOnlyStaticServerData;           //0x0054 really void**
    voidp                           AnsiCodePageData;                   //0x0058
    voidp                           OemCodePageData;                    //0x005C
    voidp                           UnicodeCaseTableData;               //0x0060
    DWORD                           NumberOfProcessors;                 //0x0064
    DWORD                           NtGlobalFlag;                       //0x0068
    LARGE_INTEGER_                   CriticalSectionTimeout;             //0x0070
    DWORD                           HeapSegmentReserve;                 //0x0078
    DWORD                           HeapSegmentCommit;                  //0x007C
    DWORD                           HeapDeCommitTotalFreeThreshold;     //0x0080
    DWORD                           HeapDeCommitFreeBlockThreshold;     //0x0084
    DWORD                           NumberOfHeaps;                      //0x0088
    DWORD                           MaximumNumberOfHeaps;               //0x008C
    voidp                           ProcessHeaps;                       //0x0090 really void**
    voidp                           GdiSharedHandleTable;               //0x0094

    //end of NT 3.51 members / members that follow available on NT 4.0 and up

    voidp                           ProcessStarterHelper;               //0x0098
    DWORD                           GdiDCAttributeList;                 //0x009C
    union
    {
        struct
        {
            voidp                   LoaderLock;                         //0x00A0 (NT4)
        } nt4;
        struct
        {
            RTL_CRITICAL_SECTION_p   LoaderLock;                         //0x00A0 (Win2k+)
        } win2k;
    } dwordA0;
    DWORD                           OSMajorVersion;                     //0x00A4
    DWORD                           OSMinorVersion;                     //0x00A8
    WORD                            OSBuildNumber;                      //0x00AC
    WORD                            OSCSDVersion;                       //0x00AE
    DWORD                           OSPlatformId;                       //0x00B0
    DWORD                           ImageSubsystem;                     //0x00B4
    DWORD                           ImageSubsystemMajorVersion;         //0x00B8
    DWORD                           ImageSubsystemMinorVersion;         //0x00BC
    union
    {
        KAFFINITY                   ImageProcessAffinityMask;           //0x00C0 (NT4-early Vista)
        KAFFINITY                   ActiveProcessAffinityMask;          //0x00C0 (late Vista+)
    } dwordC0;
    DWORD                           GdiHandleBuffer[0x22];              //0x00C4
    voidp                           PostProcessInitRoutine;             //0x014C / void (*PostProcessInitRoutine) (void);

    //members that follow available on Windows 2000 and up

    voidp                           TlsExpansionBitmap;                 //0x0150
    DWORD                           TlsExpansionBitmapBits[0x20];       //0x0154
    DWORD                           SessionId;                          //0x01D4
    ULARGE_INTEGER_                  AppCompatFlags;                     //0x01D8
    ULARGE_INTEGER_                  AppCompatFlagsUser;                 //0x01E0
    voidp                           pShimData;                          //0x01E8
    voidp                           AppCompatInfo;                      //0x01EC
    UNICODE_STRING_                  CSDVersion;                         //0x01F0

    //members that follow available on Windows XP and up

    ACTIVATION_CONTEXT_DATA_p        ActivationContextData;              //0x01F8
    ASSEMBLY_STORAGE_MAP_p           ProcessAssemblyStorageMap;          //0x01FC
    ACTIVATION_CONTEXT_DATA_p        SystemDefaultActivationContextData; //0x0200
    ASSEMBLY_STORAGE_MAP_p           SystemAssemblyStorageMap;           //0x0204
    DWORD                           MinimumStackCommit;                 //0x0208

    //members that follow available on Windows Server 2003 and up

    FLS_CALLBACK_INFO_p              FlsCallback;                        //0x020C
    LIST_ENTRY_                      FlsListHead;                        //0x0210
    voidp                           FlsBitmap;                          //0x0218
    DWORD                           FlsBitmapBits[4];                   //0x021C
    DWORD                           FlsHighIndex;                       //0x022C

    //members that follow available on Windows Vista and up

    voidp                           WerRegistrationData;                //0x0230
    voidp                           WerShipAssertPtr;                   //0x0234

    //members that follow available on Windows 7 BETA and up

    union
    {
        voidp                       pContextData;                       //0x0238 (prior to Windows 8)
        voidp                       pUnused;                            //0x0238 (Windows 8)
    } dword238;
    voidp                           pImageHeaderHash;                   //0x023C

    //members that follow available on Windows 7 RTM and up

    struct //TracingFlags
    {
        DWORD                       HeapTracingEnabled       :1;        //0x0240:0
        DWORD                       CritSecTracingEnabled    :1;        //0x0240:1
        DWORD                       LibLoaderTracingEnabled  :1;        //0x0240:2
        DWORD                       SpareTracingBits         :29;       //0x0240:3
    } dword240;
    DWORD                           dummy02;                            //0x0244

    //members that follow available on Windows 8 and up

    QWORD                           CsrServerReadOnlySharedMemoryBase;  //0x0248

    //members that follow available by at least Windows 10 (possibly Windows 8)

    DWORD                           dwUnknown0250;                      //0x0250 (must exist at least by Windows 10)
    DWORD                           dwSystemCallMode;                   //0x0254 / set to 2 under 64-bit Windows in a 32-bit process (WOW64)
                                                                        //         used in 64-bit mode switch prior to ring 0 kernel-mode transitions
};


//
// TEB_-specific structures
//

//GDI_TEB_BATCH_ - size=0x04E0
struct GDI_TEB_BATCH_
{
    union
    {
        DWORD   Offset;
        struct
        {
            DWORD Offset                : 31;  //0x00:00  Win 8.1 Update 1+
            DWORD HasRenderingCommand   : 1;   //0x00:31  Win 8.1 Update 1+
        } bits;
    } dword0;
    DWORD   HDC;
    DWORD   Buffer[0x136];
};

struct TEB_ACTIVE_FRAME_CONTEXT_
{
     DWORD  Flags;
     CHARp  FrameName;
};

typedef voidp TEB_ACTIVE_FRAME_p;
typedef voidp TEB_ACTIVE_FRAME_CONTEXT_p;

struct TEB_ACTIVE_FRAME_
{
     DWORD                      Flags;
     TEB_ACTIVE_FRAME_p          Previous;
     TEB_ACTIVE_FRAME_CONTEXT_p  CONTEXT_;
};

typedef voidp PEB_p;
typedef voidp TEB_p;
typedef voidp TEB_ACTIVE_FRAME_p;

//
// TEB_ (Thread Environment Block) a.k.a. TIB (Thread Information Block) 32-bit
//
// The size of this structure is OS dependent:
//    0x0F28    NT 3.51
//    0x0F88    NT 4.0
//    0x0FA4    Win2k
//    0x0FB4    prior to XP SP2
//    0x0FB8    XP SP2/WS03+
//    0x0FBC    WS03 SP1+
//    0x0FF8    Vista/WS08
//    0x0FE4    Win7/WS08 R2
//    0x0FE8    Win8-Win8.1/WS12
//    0x1000    Win10
//
struct TEB_
{
    //NT_TIB structure portion
    EXCEPTION_REGISTRATION_p     ExceptionList;                              //0x0000 / Current Structured Exception Handling (SEH) frame
    voidp                       StackBase;                                  //0x0004 / Bottom of stack (high address)
    voidp                       StackLimit;                                 //0x0008 / Ceiling of stack (low address)
    voidp                       SubSystemTib;                               //0x000C
    union
    {
        voidp                   FiberData;                                  //0x0010
        DWORD                   Version;                                    //0x0010
    } dword10;
    voidp                       ArbitraryUserPointer;                       //0x0014
    TEB_p                        Self;                                       //0x0018
    //NT_TIB ends (NT subsystem independent part)

    voidp                       EnvironmentPointer;                         //0x001C
    CLIENT_ID_                   ClientId;                                   //0x0020
    //                          ClientId.ProcessId                          //0x0020 / value retrieved by GetCurrentProcessId()
    //                          ClientId.ThreadId                           //0x0024 / value retrieved by GetCurrentThreadId()
    voidp                       ActiveRpcHandle;                            //0x0028
    voidp                       ThreadLocalStoragePointer;                  //0x002C
    PEB_p                       ProcessEnvironmentBlock;                    //0x0030
    DWORD                       LastErrorValue;                             //0x0034
    DWORD                       CountOfOwnedCriticalSections;               //0x0038
    voidp                       CsrClientThread;                            //0x003C
    voidp                       Win32ThreadInfo;                            //0x0040
    DWORD                       User32Reserved[0x1A];                       //0x0044
    DWORD                       UserReserved[5];                            //0x00AC
    voidp                       WOW32Reserved;                              //0x00C0 / user-mode 32-bit (WOW64) -> 64-bit CONTEXT_ switch function prior to kernel-mode transition
    LCID                        CurrentLocale;                              //0x00C4
    DWORD                       FpSoftwareStatusRegister;                   //0x00C8
    union
    {
        DWORD                   SystemReserved1[0x36];                      //0x00CC (NT 3.51-Win8)
        struct
        {
            DWORD               Reserved1[0x16];                            //0x00CC
            voidp               pKThread;                                   //0x0124 / pointer to KTHREAD (ETHREAD) structure
            DWORD               Reserved2[0x1F];                            //0x0128
        } kernelInfo;
        struct
        {
            DWORD               ReservedForDebuggerInstrumentation[0x10];   //0x00CC (Win10 PRE-RTM+)
            DWORD               SystemReserved1[0x26];                      //0x010C (Win10 PRE-RTM+)
        } win10;
    } dwordCC;
    int32_t /*NTSTATUS*/        ExceptionCode;                              //0x01A4
    union
    {
        BYTE                    SpareBytes1[0x2C];                          //0x01A8 (NT3.51-Win2k)
        struct
        {
            BYTE                ActivationContextStack[0x14];               //0x01A8 (XP-early WS03)
            BYTE                SpareBytes1[0x18];                          //0x01BC (XP-early WS03)
        } xp;
        struct
        {
            voidp               ActivationContextStackPointer;              //0x01A8 (WS03+)
            union
            {
                BYTE            SpareBytes1[0x24];                          //0x01AC (WS03-Win8.1)
                struct
                {
                    voidp       InstrumentationCallbackSp;                  //0x01AC (Win10+)
                    voidp       InstrumentationCallbackPreviousPc;          //0x01B0 (Win10+)
                    voidp       InstrumentationCallbackPreviousSp;          //0x01B4 (Win10+)
                    BOOLEAN     InstrumentationCallbackDisabled;            //0x01B8 (Win10+)
                    BYTE        SpareBytes[0x17];                           //0x01B9 (Win10+)
                } win10;
            } dword1AC;
            union
            {
                BYTE            SpareBytes2[4];                             //0x01D0 (WS03)
                DWORD           TxFsContext;                                //0x01D0 (Vista+)
            } dword1D0;
        } lateWs03;
    } dword1A8;
    GDI_TEB_BATCH_               GdiTebBatch;                                //0x01D4
    CLIENT_ID_                   RealClientId;                               //0x06B4
    _HANDLE                      GdiCachedProcessHandle;                     //0x06BC
    DWORD                       GdiClientPID;                               //0x06C0
    DWORD                       GdiClientTID;                               //0x06C4
    voidp                       GdiThreadLocalInfo;                         //0x06C8
    DWORD                       Win32ClientInfo[0x3E];                      //0x06CC
    voidp                       glDispatchTable[0xE9];                      //0x07C4
    DWORD                       glReserved1[0x1D];                          //0x0B68
    voidp                       glReserved2;                                //0x0BDC
    voidp                       glSectionInfo;                              //0x0BE0
    voidp                       glSection;                                  //0x0BE4
    voidp                       glTable;                                    //0x0BE8
    voidp                       glCurrentRC;                                //0x0BEC
    voidp                       glContext;                                  //0x0BF0
    int32_t /*NTSTATUS*/        LastStatusValue;                            //0x0BF4
    UNICODE_STRING_              StaticUnicodeString;                        //0x0BF8
    WCHAR                       StaticUnicodeBuffer[0x105];                 //0x0C00
    voidp                       DeallocationStack;                          //0x0E0C
    voidp                       TlsSlots[0x40];                             //0x0E10
    LIST_ENTRY_                  TlsLinks;                                   //0x0F10
    voidp                       Vdm;                                        //0x0F18
    voidp                       ReservedForNtRpc;                           //0x0F1C
    voidp                       DbgSsReserved[2];                           //0x0F20

    //end of NT 3.51 members / members that follow available on NT 4.0 and up

    union
    {
        DWORD                   ThreadErrorMode;                            //0x0F28 (OS?) / RtlSetThreadErrorMode
        DWORD                   HardErrorsAreDisabled;                      //0x0F28 (NT4-XP)
        DWORD                   HardErrorMode;                              //0x0F28 (WS03+)
    } dwordF28;
    union
    {
        struct
        {
            DWORD               Instrumentation[0x10];                      //0x0F2C (NT4-early WS03)
        } nt;
        struct
        {
            union
            {
                struct
                {
                    DWORD       Instrumentation[0x0E];                      //0x0F2C (late WS03+)
                    voidp       SubProcessTag;                              //0x0F64 (late WS03+)
                } beforeVista;
                struct
                {
                    DWORD       Instrumentation[9];                         //0x0F2C (Vista+)
                    GUID_        ActivityId;                                 //0x0F50 (Vista+)
                    voidp       SubProcessTag;                              //0x0F60 (Vista+)
                    union
                    {
                        DWORD   EtwLocalData;                               //0x0F64 (WIN8 PRE-RTM)
                        DWORD   PerflibData;                                //0x0F64 (WIN8 RTM+)
                    } win8;

                } vista;
            } dwordF2C;
            voidp               EtwTraceData;                               //0x0F68 (late WS03+)
        } ws03;
    } dwordF2C;
    voidp                       WinSockData;                                //0x0F6C
    DWORD                       GdiBatchCount;                              //0x0F70
    union
    {
        struct
        {
            union
            {
                struct
                {
                    BOOLEAN     InDbgPrint;                                 //0x0F74 (NT4-WS03)
                    BOOLEAN     FreeStackOnTermination;                     //0x0F75 (NT4-WS03)
                    BOOLEAN     HasFiberData;                               //0x0F76 (NT4-WS03)
                } beforeVista;
                union
                {
                    BOOLEAN     SpareBool0;                                 //0x0F74 (Vista)
                    BOOLEAN     SpareBool1;                                 //0x0F75 (Vista)
                    BOOLEAN     SpareBool2;                                 //0x0F76 (Vista)
                } vista;
            } u;
            BOOLEAN             IdealProcessor;                             //0x0F77 (NT4-Vista)
        } beforeWin7;
        PROCESSOR_NUMBER_        CurrentIdealProcessor;                      //0x0F74 (Win7+)
    } dwordF74;
    union
    {
        DWORD                   Spare3;                                     //0x0F78 (NT4-early WS03)
        DWORD                   GuaranteedStackBytes;                       //0x0F78 (late WS03+)
    } dwordF78;
    voidp                       ReservedForPerf;                            //0x0F7C
    voidp                       ReservedForOle;                             //0x0F80
    DWORD                       WaitingOnLoaderLock;                        //0x0F84

    //members that follow available on Windows 2000 and up

    union
    {
        struct
        {
            //Wx86ThreadState structure
            DWORDp              CallBx86Eip;                                //0x0F88 (Win2k-early WS03)
            voidp               DeallocationCpu;                            //0x0F8C (Win2k-early WS03)
            BYTE                UseKnownWx86Dll;                            //0x0F90 (Win2k-early WS03)
            CHAR                OleStubInvoked;                             //0x0F91 (Win2k-early WS03)
            BYTE                Padding[2];                                 //0x0F92
        } beforeLateWs03;
        struct
        {
            union
            {
                voidp           SparePointer1;                              //0x0F88 (late WS03)
                voidp           SavedPriorityState;                         //0x0F88 (Vista+)
            } dwordF88;
            union
            {
                voidp           SoftPatchPtr1;                              //0x0F8C (late WS03-Win7)
                voidp           ReservedForCodeCoverage;                    //0x0F8C (Win8+)
            } dwordF8C;
            union
            {
                voidp           SoftPatchPtr2;                              //0x0F90 (late WS03)
                voidp           ThreadPoolData;                             //0x0F90 (Vista+)
            } dwordF90;
        } lateWs03;
    } dwordF88;
    voidp                       TlsExpansionSlots;                          //0x0F94
    union
    {
        LCID                    ImpersonationLocale;                        //0x0F98 (Win2k-Vista)
        DWORD                   MuiGeneration;                              //0x0F98 (Win7+)
    } dwordF98;
    DWORD                       IsImpersonating;                            //0x0F9C
    voidp                       NlsCache;                                   //0x0FA0

    //members that follow available on Windows XP and up

    voidp                       pShimData;                                  //0x0FA4
    union
    {
        DWORD                   HeapVirtualAffinity;                        //0x0FA8 (XP-Win7)
        struct
        {
            WORD                HeapVirtualAffinity;                        //0x0FA8 (Win8+)
            WORD                LowFragHeapDataSlot;                        //0x0FAA (Win8+)
        } win8;
    } dwordFA8;
    _HANDLE                      CurrentTransactionHandle;                   //0x0FAC
    TEB_ACTIVE_FRAME_p           ActiveFrame;                                //0x0FB0

    //members that follow available on Windows XP SP2 and up

    union
    {
        voidp                   FlsData;                                    //0x0FB4 (WS03+)
        struct
        {
            BOOLEAN             SafeThunkCall;                              //0x0FB4 (XP SP2)
            BOOLEAN             BooleanSpare[3];                            //0x0FB5 (XP SP2)
        } xpSp2;
    } dwordFB4;
    union
    {
        struct
        {
            BOOLEAN             SafeThunkCall;                              //0x0FB8 (late WS03)
            BOOLEAN             BooleanSpare[3];                            //0x0FB9 (late WS03)
        } ws03;
        voidp                   PreferredLanguages;                         //0x0FB8 (Vista+)
    } dwordFB8;

    //members that follow available on Windows Vista and up

    voidp                       UserPrefLanguages;                          //0x0FBC
    voidp                       MergedPrefLanguages;                        //0x0FC0
    DWORD                       MuiImpersonation;                           //0x0FC4
    union
    {
        volatile WORD           CrossTebFlags;                              //0x0FC8
        struct
        {
            WORD                SpareCrossTebBits : 16;                     //0x0FC8
        } bits;
    } wordFC8;
    union
    {
        WORD                    SameTebFlags;                               //0x0FCA
        struct
        {
            WORD                SafeThunkCall        : 1;                   //0x0FCA:0x00
            WORD                InDebugPrint         : 1;                   //0x0FCA:0x01
            WORD                HasFiberData         : 1;                   //0x0FCA:0x02
            WORD                SkipThreadAttach     : 1;                   //0x0FCA:0x03
            WORD                WerInShipAssertCode  : 1;                   //0x0FCA:0x04
            WORD                RanProcessInit       : 1;                   //0x0FCA:0x05
            WORD                ClonedThread         : 1;                   //0x0FCA:0x06
            WORD                SuppressDebugMsg     : 1;                   //0x0FCA:0x07
            WORD                DisableUserStackWalk : 1;                   //0x0FCA:0x08
            WORD                RtlExceptionAttached : 1;                   //0x0FCA:0x09
            WORD                InitialThread        : 1;                   //0x0FCA:0x0A
            WORD                SessionAware         : 1;                   //0x0FCA:0x0B
        } bits;
    } wordFCA;
    voidp                       TxnScopeEnterCallback;                      //0x0FCC
    voidp                       TxnScopeExitCallback;                       //0x0FD0
    voidp                       TxnScopeContext;                            //0x0FD4
    DWORD                       LockCount;                                  //0x0FD8
    union
    {
        struct
        {
            DWORD               ProcessRundown;                             //0x0FDC (Vista)
            QWORD               LastSwitchTime;                             //0x0FE0 (Vista)
            QWORD               TotalSwitchOutTime;                         //0x0FE8 (Vista)
            LARGE_INTEGER_       WaitReasonBitMap;                           //0x0FF0 (Vista)
        } vista;

        //end of Vista members

        struct
        {
            union
            {
                DWORD           SpareUlong0;                                //0x0FDC (Win7-Win8)
                INT32           WowTebOffset;                               //0x0FDC (Win10+)
            } dwordFDC;
            voidp               ResourceRetValue;                           //0x0FE0 (Win7+)

            //end of Windows 7 members (TEB_ shrunk after Vista)

            voidp               ReservedForWdf;                             //0x0FE4 (Win8+)

            //end of Windows 8 members

        } afterVista;
    } dwordFDC;

    //members that follow available on Windows 10 and up (currently unknown)

    BYTE                        ReservedForWin10[0x18];                     //0x0FE8

}; //struct TEB_

```

`vs13/sk3wldbg.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Express 2013 for Windows Desktop
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sk3wldbg", "sk3wldbg.vcxproj", "{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
		Release64|Win32 = Release64|Win32
		Release64|x64 = Release64|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release|Win32.ActiveCfg = Release|Win32
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release|Win32.Build.0 = Release|Win32
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release|x64.ActiveCfg = Release|x64
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release|x64.Build.0 = Release|x64
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release64|Win32.ActiveCfg = Release64|Win32
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release64|Win32.Build.0 = Release64|Win32
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release64|x64.ActiveCfg = Release64|x64
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release64|x64.Build.0 = Release64|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`vs13/sk3wldbg.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release64|Win32">
      <Configuration>Release64</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release64|x64">
      <Configuration>Release64</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}</ProjectGuid>
    <RootNamespace>sk3wldbg</RootNamespace>
    <ProjectName>sk3wldbg</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v120</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v120</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v120</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v120</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\bin\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">..\bin\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">false</LinkIncremental>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.plw</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release|x64'">.dll</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">.p64</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">.dll</TargetExt>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_user</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_user</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">$(ProjectName)_user</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">$(ProjectName)_user64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <OutDir>..\bin\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TargetEnvironment>Win32</TargetEnvironment>
      <TypeLibraryName>$(IntDir)\sk3wldbg.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\..\include;..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;__IDP__;WIN32;_WINDOWS;_USRDLL;__NT__;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>$(IntDir)\sk3wldbg.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)\</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)\</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)\</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>
      </AdditionalOptions>
      <AdditionalDependencies>ida.lib;unicorn.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(ProjectName)_user$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>lib\x86;..\..\..\lib\x86_win_vc_32;..\..\..\lib\vc.w32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>$(IntDir)\sk3wldbg.lib</ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(IntDir)\sk3wldbg.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TypeLibraryName>$(IntDir)\sk3wldbg.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\..\include;..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;__IDP__;__X64__;_WINDOWS;_USRDLL;__NT__;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>
      </AdditionalOptions>
      <AdditionalDependencies>ida.lib;unicorn.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(ProjectName)_user$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>lib\x64;..\..\..\lib\x64_win_vc_32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>$(IntDir)$(TargetName).lib</ImportLibrary>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(IntDir)\sk3wldbg.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TargetEnvironment>Win32</TargetEnvironment>
      <TypeLibraryName>$(IntDir)\sk3wldbg.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\..\include;..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;__IDP__;WIN32;_WINDOWS;_USRDLL;__NT__;_CRT_SECURE_NO_WARNINGS;__EA64__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>$(IntDir)\sk3wldbg.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)\</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)\</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)\</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>
      </AdditionalOptions>
      <AdditionalDependencies>ida.lib;unicorn.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(ProjectName)_user$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>lib\x86;..\..\..\lib\x86_win_vc_64;..\..\..\lib\vc.w64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>$(IntDir)\sk3wldbg.lib</ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(IntDir)\sk3wldbg.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TypeLibraryName>$(IntDir)\sk3wldbg.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\..\include;..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;__IDP__;__X64__;_WINDOWS;_USRDLL;__NT__;_CRT_SECURE_NO_WARNINGS;__EA64__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>
      </AdditionalOptions>
      <AdditionalDependencies>ida.lib;unicorn.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(ProjectName)_user64$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>lib\x64;..\..\..\lib\x64_win_vc_64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>$(IntDir)$(TargetName).lib</ImportLibrary>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(IntDir)\sk3wldbg.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\idc_funcs.cpp" />
    <ClCompile Include="..\loader.cpp" />
    <ClCompile Include="..\mem_mgr.cpp" />
    <ClCompile Include="..\sk3wldbg.cpp" />
    <ClCompile Include="..\sk3wldbg_arm.cpp" />
    <ClCompile Include="..\sk3wldbg_m68k.cpp" />
    <ClCompile Include="..\sk3wldbg_mips.cpp" />
    <ClCompile Include="..\sk3wldbg_plugin.cpp" />
    <ClCompile Include="..\sk3wldbg_ppc.cpp" />
    <ClCompile Include="..\sk3wldbg_sparc.cpp" />
    <ClCompile Include="..\sk3wldbg_x86.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\elf_local.h" />
    <ClInclude Include="..\heap.h" />
    <ClInclude Include="..\idc_funcs.h" />
    <ClInclude Include="..\loader.h" />
    <ClInclude Include="..\mem_mgr.h" />
    <ClInclude Include="..\pe_local.h" />
    <ClInclude Include="..\sk3wldbg.h" />
    <ClInclude Include="..\sk3wldbg_arm.h" />
    <ClInclude Include="..\sk3wldbg_m68k.h" />
    <ClInclude Include="..\sk3wldbg_mips.h" />
    <ClInclude Include="..\sk3wldbg_ppc.h" />
    <ClInclude Include="..\sk3wldbg_sparc.h" />
    <ClInclude Include="..\sk3wldbg_x86.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`vs13/sk3wldbg.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{66bf7bc0-eeba-4bc3-9122-b703939aded1}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{6231a689-590d-458b-b802-12bd4f39ff5a}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{80893d90-0de1-4ed1-b3e2-6b799d770fe6}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\loader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_arm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_m68k.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_mips.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_ppc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_sparc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_x86.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mem_mgr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\idc_funcs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\loader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_arm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_m68k.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_mips.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_ppc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_sparc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_x86.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mem_mgr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\idc_funcs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\elf_local.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\pe_local.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\heap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`vs13/sk3wldbg.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`vs17/sk3wldbg.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Express 2013 for Windows Desktop
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sk3wldbg", "sk3wldbg.vcxproj", "{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
		Release64|Win32 = Release64|Win32
		Release64|x64 = Release64|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release|Win32.ActiveCfg = Release|Win32
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release|Win32.Build.0 = Release|Win32
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release|x64.ActiveCfg = Release|x64
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release|x64.Build.0 = Release|x64
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release64|Win32.ActiveCfg = Release64|Win32
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release64|Win32.Build.0 = Release64|Win32
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release64|x64.ActiveCfg = Release64|x64
		{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}.Release64|x64.Build.0 = Release64|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`vs17/sk3wldbg.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release64|Win32">
      <Configuration>Release64</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release64|x64">
      <Configuration>Release64</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7B4A96A3-659F-44A7-8A1E-B99CB16DD02E}</ProjectGuid>
    <RootNamespace>sk3wldbg</RootNamespace>
    <ProjectName>sk3wldbg</ProjectName>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\bin\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">..\bin\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">false</LinkIncremental>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.plw</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release|x64'">.dll</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">.p64</TargetExt>
    <TargetExt Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">.dll</TargetExt>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_user</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_user</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">$(ProjectName)_user</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">$(ProjectName)_user64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <OutDir>..\bin\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TargetEnvironment>Win32</TargetEnvironment>
      <TypeLibraryName>$(IntDir)\sk3wldbg.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\..\include;..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;__IDP__;WIN32;_WINDOWS;_USRDLL;__NT__;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>$(IntDir)\sk3wldbg.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)\</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)\</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)\</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>
      </AdditionalOptions>
      <AdditionalDependencies>ida.lib;unicorn_staload.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(ProjectName)_user$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>lib\x86;..\..\..\lib\x86_win_vc_32;..\..\..\lib\vc.w32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>$(IntDir)\sk3wldbg.lib</ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(IntDir)\sk3wldbg.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TypeLibraryName>$(IntDir)\sk3wldbg.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\..\include;..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;__IDP__;__X64__;_WINDOWS;_USRDLL;__NT__;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>
      </AdditionalOptions>
      <AdditionalDependencies>ida.lib;unicorn.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(ProjectName)_user$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>lib\x64;..\..\..\lib\x64_win_vc_32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>$(IntDir)$(TargetName).lib</ImportLibrary>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(IntDir)\sk3wldbg.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TargetEnvironment>Win32</TargetEnvironment>
      <TypeLibraryName>$(IntDir)\sk3wldbg.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\..\include;..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;__IDP__;WIN32;_WINDOWS;_USRDLL;__NT__;_CRT_SECURE_NO_WARNINGS;__EA64__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>$(IntDir)\sk3wldbg.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)\</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)\</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)\</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>
      </AdditionalOptions>
      <AdditionalDependencies>ida.lib;unicorn_staload.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(ProjectName)_user$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>lib\x86;..\..\..\lib\x86_win_vc_64;..\..\..\lib\vc.w64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>$(IntDir)\sk3wldbg.lib</ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(IntDir)\sk3wldbg.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TypeLibraryName>$(IntDir)\sk3wldbg.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\..\include;..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;__IDP__;__X64__;_WINDOWS;_USRDLL;__NT__;_CRT_SECURE_NO_WARNINGS;__EA64__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>
      </AdditionalOptions>
      <AdditionalDependencies>ida.lib;unicorn.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(ProjectName)_user64$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>lib\x64;..\..\..\lib\x64_win_vc_64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>$(IntDir)$(TargetName).lib</ImportLibrary>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ProgramDatabaseFile>$(IntDir)$(TargetName).pdb</ProgramDatabaseFile>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(IntDir)\sk3wldbg.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\idc_funcs.cpp" />
    <ClCompile Include="..\loader.cpp" />
    <ClCompile Include="..\mem_mgr.cpp" />
    <ClCompile Include="..\sk3wldbg.cpp" />
    <ClCompile Include="..\sk3wldbg_arm.cpp" />
    <ClCompile Include="..\sk3wldbg_m68k.cpp" />
    <ClCompile Include="..\sk3wldbg_mips.cpp" />
    <ClCompile Include="..\sk3wldbg_plugin.cpp" />
    <ClCompile Include="..\sk3wldbg_ppc.cpp" />
    <ClCompile Include="..\sk3wldbg_sparc.cpp" />
    <ClCompile Include="..\sk3wldbg_x86.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\elf_local.h" />
    <ClInclude Include="..\heap.h" />
    <ClInclude Include="..\idc_funcs.h" />
    <ClInclude Include="..\loader.h" />
    <ClInclude Include="..\mem_mgr.h" />
    <ClInclude Include="..\pe_local.h" />
    <ClInclude Include="..\sk3wldbg.h" />
    <ClInclude Include="..\sk3wldbg_arm.h" />
    <ClInclude Include="..\sk3wldbg_m68k.h" />
    <ClInclude Include="..\sk3wldbg_mips.h" />
    <ClInclude Include="..\sk3wldbg_ppc.h" />
    <ClInclude Include="..\sk3wldbg_sparc.h" />
    <ClInclude Include="..\sk3wldbg_x86.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`vs17/sk3wldbg.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{66bf7bc0-eeba-4bc3-9122-b703939aded1}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{6231a689-590d-458b-b802-12bd4f39ff5a}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{80893d90-0de1-4ed1-b3e2-6b799d770fe6}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\loader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_arm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_m68k.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_mips.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_ppc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_sparc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sk3wldbg_x86.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\mem_mgr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\idc_funcs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\loader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_arm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_m68k.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_mips.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_ppc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_sparc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\sk3wldbg_x86.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\mem_mgr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\idc_funcs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\elf_local.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\pe_local.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\heap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`vs17/sk3wldbg.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```