Project Path: arc_gmh5225_NullDriverCheat_ypi9kci8

Source Tree:

```txt
arc_gmh5225_NullDriverCheat_ypi9kci8
├── NullDriverCheat
│   ├── NullDriverCheat.inf
│   ├── NullDriverCheat.vcxproj
│   ├── NullDriverCheat.vcxproj.filters
│   ├── definitions.h
│   ├── hook.cpp
│   ├── hook.h
│   ├── main.cpp
│   ├── memory.cpp
│   ├── memory.h
│   └── messages.h
├── NullDriverCheat.sln
└── README.md

```

`NullDriverCheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31515.178
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NullDriverCheat", "NullDriverCheat\NullDriverCheat.vcxproj", "{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|ARM.ActiveCfg = Debug|ARM
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|ARM.Build.0 = Debug|ARM
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|ARM.Deploy.0 = Debug|ARM
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|ARM64.Build.0 = Debug|ARM64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|x64.ActiveCfg = Debug|x64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|x64.Build.0 = Debug|x64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|x64.Deploy.0 = Debug|x64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|x86.ActiveCfg = Debug|Win32
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|x86.Build.0 = Debug|Win32
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Debug|x86.Deploy.0 = Debug|Win32
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|ARM.ActiveCfg = Release|ARM
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|ARM.Build.0 = Release|ARM
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|ARM.Deploy.0 = Release|ARM
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|ARM64.ActiveCfg = Release|ARM64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|ARM64.Build.0 = Release|ARM64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|ARM64.Deploy.0 = Release|ARM64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|x64.ActiveCfg = Release|x64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|x64.Build.0 = Release|x64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|x64.Deploy.0 = Release|x64
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|x86.ActiveCfg = Release|Win32
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|x86.Build.0 = Release|Win32
		{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5FDC9E6E-BCF2-43F0-89E4-FB48AA6FA748}
	EndGlobalSection
EndGlobal

```

`NullDriverCheat/NullDriverCheat.inf`:

```inf
;
; NullDriverCheat.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=SCSIAdaptera;Sample ; TODO: edit Class
ClassGuid={4d36e97b-e325-11ce-bfc1-08002be10319};{78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=NullDriverCheat.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
NullDriverCheat_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
NullDriverCheat.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%NullDriverCheat.DeviceDesc%=NullDriverCheat_Device, Root\NullDriverCheat ; TODO: edit hw-id

[NullDriverCheat_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
NullDriverCheat.sys

;-------------- Service installation
[NullDriverCheat_Device.NT.Services]
AddService = NullDriverCheat,%SPSVCINST_ASSOCSERVICE%, NullDriverCheat_Service_Inst

; -------------- NullDriverCheat driver install sections
[NullDriverCheat_Service_Inst]
DisplayName    = %NullDriverCheat.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\NullDriverCheat.sys

;
;--- NullDriverCheat_Device Coinstaller installation ------
;

[NullDriverCheat_Device.NT.CoInstallers]
AddReg=NullDriverCheat_Device_CoInstaller_AddReg
CopyFiles=NullDriverCheat_Device_CoInstaller_CopyFiles

[NullDriverCheat_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[NullDriverCheat_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[NullDriverCheat_Device.NT.Wdf]
KmdfService =  NullDriverCheat, NullDriverCheat_wdfsect
[NullDriverCheat_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "NullDriverCheat Installation Disk"
NullDriverCheat.DeviceDesc = "NullDriverCheat Device"
NullDriverCheat.SVCDESC = "NullDriverCheat Service"

```

`NullDriverCheat/NullDriverCheat.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C3ADCBC4-1E41-4081-A6A4-3BA097F32B49}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>NullDriverCheat</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="NullDriverCheat.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="definitions.h" />
    <ClInclude Include="hook.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="messages.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hook.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="memory.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NullDriverCheat/NullDriverCheat.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="NullDriverCheat.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="definitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="messages.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`NullDriverCheat/definitions.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntstrsafe.h>
#include <wdm.h>
#pragma comment (lib,"ntoskrnl.lib")

typedef enum _SYSTEM_INFORMATION_CLASS
{

	SystemBasicInformation = 0,
	SystemProcessorInformation = 1,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemPathInformation = 4,
	SystemProcessInformation = 5,
	SystemCallCountInformation = 6,
	SystemDeviceInformation = 7,
	SystemProcessorPerformanceInformation = 8,
	SystemFlagsInformation = 9,
	SystemCallTimeInformation = 10,
	SystemModuleInformation = 11

} SYSTEM_INFORMATION_CLASS,
* PSYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];

} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];

}RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

extern "C" __declspec(dllimport)
NTSTATUS NTAPI ZwProtectVirtualMemory(HANDLE ProcessHandle,
	PVOID * BaseAddress,
	SIZE_T * NumberOfBytesToProtect,
	ULONG  NewAccessProtection,
	PULONG OldAccessProtection
);

extern "C" NTKERNELAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
	_In_ PVOID ImageBase,
	_In_ PCCH RoutineName
);

extern "C" NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);

extern "C" NTKERNELAPI
PPEB
PsGetProcessPeb(
	IN PEPROCESS Process
);

extern "C" NTSTATUS NTAPI MmCopyVirtualMemory(
	PEPROCESS  	SourceProcess,
	PVOID  	SourceAddress,
	PEPROCESS  	TargetProcess,
	PVOID  	TargetAddress,
	SIZE_T  	BufferSize,
	KPROCESSOR_MODE  	PreviousMode,
	PSIZE_T  	ReturnSize
);

typedef VOID(NTAPI* PPS_POST_PROCESS_INIT_ROUTINE)(VOID);

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16]; // size = 16
	PVOID Reserved2[10];// 10 * 8 = 80
	UNICODE_STRING ImagePathName; //hex(80) = 0x60
	UNICODE_STRING CommandLine; //0x70
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;


//Structs from https://www.vergiliusproject.com/kernels/x64/Windows%2011/Insider%20Preview%20(Jun%202021)/_PEB

typedef struct _PEB_LDR_DATA
{
	ULONG Length;                                                           //0x0
	UCHAR Initialized;                                                      //0x4
	VOID* SsHandle;                                                         //0x8
	struct _LIST_ENTRY InLoadOrderModuleList;                               //0x10
	struct _LIST_ENTRY InMemoryOrderModuleList;                             //0x20
	struct _LIST_ENTRY InInitializationOrderModuleList;                     //0x30

}PEB_LDR_DATA, * PPEB_LDR_DATA;;

typedef struct _LDR_DATA_TABLE_ENTRY {
	struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
	struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x10
	struct _LIST_ENTRY InInitializationOrderLinks;                          //0x20
	VOID* DllBase;                                                          //0x30
	VOID* EntryPoint;                                                       //0x38
	ULONG SizeOfImage;                                                      //0x40
	struct _UNICODE_STRING FullDllName;                                     //0x48
	struct _UNICODE_STRING BaseDllName;                                     //0x58
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB {
    BYTE Padding1[2];
    BYTE BeingDebugged; //0x2
    BYTE Padding2[16];
    PPEB_LDR_DATA Ldr;//0x18
} PEB, * PPEB;


//char(*__kaboom)[sizeof(PEB)] = 1;
//static_assert(sizeof(PEB) == 0x284, "Player class size");
```

`NullDriverCheat/hook.cpp`:

```cpp
#include "hook.h"
#include "messages.h"


GdiSelectBrush_t GdiSelectBrush = NULL;
PatBlt_t NtGdiPatBlt = NULL;
NtUserGetDC_t NtUserGetDC = NULL;
NtGdiCreateSolidBrush_t NtGdiCreateSolidBrush = NULL;
ReleaseDC_t NtUserReleaseDC = NULL;
DeleteObjectApp_t NtGdiDeleObjectApp = NULL;


bool hook::call_kernel_function(void* kernel_function_address) 
{

	if (!kernel_function_address) {
		return false;
	}

	PVOID* function = reinterpret_cast<PVOID*>(get_system_module_export("\\SystemRoot\\System32\\drivers\\dxgkrnl.sys", 
		"NtOpenCompositionSurfaceSectionInfo"));
		//Mine -> "NtOpenCompositionSurfaceSectionInfo"

	if (!function) {
		return false;
	}

	BYTE orig[] = { 0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // Allocated memory where we will write our shellcode;
	//sizeof(orig) == sizeof(shell_code) + sizeof(&hook_address)
	BYTE shell_code[] = {0x90,0x90,0x90,0x48,0xB8};
	//nop nop ; Used to bypass basic anti-hooks
	//mov rax, fffff
	BYTE shell_code_end[] = { 0xFF,0xE0 }; //jmp rax

	RtlSecureZeroMemory(&orig, sizeof(orig));
	memcpy((PVOID)(ULONG_PTR)orig,&shell_code,sizeof(shell_code));
	uintptr_t hook_address = reinterpret_cast<uintptr_t>(kernel_function_address);
	memcpy((PVOID)((ULONG_PTR)orig + sizeof(shell_code)), &hook_address, sizeof(void*));
	memcpy((PVOID)((ULONG_PTR)orig + sizeof(shell_code) + sizeof(void*)), &shell_code_end, sizeof(shell_code_end));


	write_to_read_only_memory(function, &orig, sizeof(orig));

	//Draw rectangle stuff from https://www.youtube.com/watch?v=YzY-Uhg7IUU
	/*
	GdiSelectBrush = (GdiSelectBrush_t)get_system_module_export(L"win32kfull.sys", "NtGdiSelectBrush");
	NtGdiCreateSolidBrush = (NtGdiCreateSolidBrush_t)get_system_module_export(L"win32kfull.sys", "NtGdiCreateSolidBrush");
	NtGdiPatBlt = (PatBlt_t)get_system_module_export(L"win32kfull.sys", "NtGdiPatBlt");
	NtUserGetDC = (NtUserGetDC_t)get_system_module_export(L"win32kfull.sys", "NtUserGetDC");
	NtUserReleaseDC = (ReleaseDC_t)get_system_module_export(L"win32kfull.sys", "NtUserReleaseDC");
	NtGdiDeleObjectApp = (DeleteObjectApp_t)get_system_module_export(L"win32kfull.sys", "NtGdiDeleObjectApp");
	*/


	return true;
}

NTSTATUS hook::hook_handler(PVOID  called_param) {

	NULL_MEMORY* instructions = (NULL_MEMORY*)called_param;
	DebugMessage("Command received");

	//Getting module base address
	if (instructions->req_base != FALSE) {
		DebugMessage("Hi from Kernel");
		ANSI_STRING AS;
		UNICODE_STRING ModuleName;

		RtlInitAnsiString(&AS, instructions->module_name);
		RtlAnsiStringToUnicodeString(&ModuleName, &AS, TRUE);

		PEPROCESS process;
		DebugMessage("My process id is: %lu", instructions->pid);
		PsLookupProcessByProcessId((HANDLE)instructions->pid, &process);
		if (process) {
			ULONG64 base_address64 = NULL;
			base_address64 = get_module_base_x64(process, ModuleName);
			instructions->base_address = base_address64;
			RtlFreeUnicodeString(&ModuleName);
		}
		else {
			return STATUS_ABANDONED;
		}
	}

	//Writting memory
	else if (instructions->write != FALSE) {
		//Check that we're in a valid memory range
		if (instructions->address < 0x7FFFFFFFFFFF && instructions->address > 0) {

			//We allocate a buffer
			PVOID kernelBuff = ExAllocatePool(NonPagedPool, instructions->size);

			if (!kernelBuff)
			{
				// couldn't allocate mem buffer
				return STATUS_UNSUCCESSFUL;
			}

			if (!memcpy(kernelBuff, instructions->buffer_address, instructions->size)) {
				return STATUS_UNSUCCESSFUL;
			}

			PEPROCESS process;
			PsLookupProcessByProcessId((HANDLE)instructions->pid, &process);
			write_kernel_memory((HANDLE)instructions->pid, instructions->address, kernelBuff, instructions->size);
			ExFreePool(kernelBuff);

		}
	}

	else if (instructions->read != FALSE) {
		DebugMessage("Read command received");
		//Check that we're in a valid memory range
		if (instructions->address < 0x7FFFFFFFFFFF && instructions->address > 0) {
			DebugMessage("address is in the right thing");
			DebugMessage("PID: %d",instructions->pid);
			DebugMessage("address: %d", instructions->address);
			DebugMessage("Size: %d", instructions->size);




			read_kernel_memory((HANDLE)instructions->pid, (uintptr_t)instructions->address, instructions->output, instructions->size);
			DebugMessage("outpu: %d", *(DWORD*)instructions->output);

		}
	}

	return STATUS_SUCCESS;
}


INT hook::FrameRect(HDC hDC, CONST RECT* lprc, HBRUSH hbr, int thickness) {
	HBRUSH oldbrush;
	RECT r = *lprc;

	if (!(oldbrush = GdiSelectBrush(hDC, hbr))) return 0;

	NtGdiPatBlt(hDC, r.left, r.top, thickness, r.bottom - r.top, PATCOPY);
	NtGdiPatBlt(hDC, r.right - thickness, r.top, thickness, r.bottom - r.top, PATCOPY);
	NtGdiPatBlt(hDC, r.left, r.top, r.right, thickness, PATCOPY);
	NtGdiPatBlt(hDC, r.left, r.bottom - thickness, r.right, r.right - r.left, PATCOPY);
	
	GdiSelectBrush(hDC, oldbrush);
	return 1;

};

```

`NullDriverCheat/hook.h`:

```h
#pragma once
#include "memory.h"

#define PATCOPY             (DWORD)0x00F00021

typedef HBRUSH(*GdiSelectBrush_t)(_In_ HDC hdc, _In_ HBRUSH hbr);

typedef  BOOL(*PatBlt_t)(_In_ HDC,
	_In_ int x,
	_In_ int y,
	_In_ int w,
	_In_ int h,
	_In_ DWORD);

typedef HDC(*NtUserGetDC_t)(HWND hwnd);

typedef HBRUSH(*NtGdiCreateSolidBrush_t)(_In_ COLORREF crColor, _In_opt_ HBRUSH hbr);

typedef int (*ReleaseDC_t)(HDC hdc);
typedef BOOL(*DeleteObjectApp_t)(HANDLE hobj);

namespace hook {
	bool call_kernel_function(void* kernel_function_address);
	NTSTATUS hook_handler(PVOID  called_param);
	INT FrameRect(HDC hDC, CONST RECT* lprc, HBRUSH hbr, int thickness);
}

```

`NullDriverCheat/main.cpp`:

```cpp
#include "hook.h"

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PUNICODE_STRING reg_path) {
	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(reg_path);

	if (hook::call_kernel_function(&hook::hook_handler)) {
		DbgPrint(0, 0, "NullDriver | Function hooked!\n");
		return STATUS_SUCCESS;
	}
	else {
		DbgPrint(0, 0, "NullDriver | Function hook failesd!\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}
	


}
```

`NullDriverCheat/memory.cpp`:

```cpp
#include "memory.h"





PVOID get_system_module_base(const char* module_name) {
	ULONG bytes = 0;
	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation,NULL,bytes,&bytes);
	
	if (!bytes)
		return NULL;

	PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x77617273);//Tag wars ->77 61 72 73
	
	status = ZwQuerySystemInformation(SystemModuleInformation,modules,bytes, &bytes);

	if (!NT_SUCCESS(status)) {
		return NULL;
	}

	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules; // Getting list of modules
	PVOID module_base = 0,module_size = 0;

	//looping through module list and comparing path name to what we want
	for (ULONG i = 0; i < modules->NumberOfModules; i++) {
		if (strcmp((char*)module[i].FullPathName, module_name) == 0)
			//If it matches,
		{
			module_base = module[i].ImageBase;
			module_size = (PVOID)module[i].ImageSize;
			break;
		}
	}

	if (modules) {
		ExFreePoolWithTag(modules, NULL);
	}

	if (module_base <= 0) {
		return 0;
	}

	return module_base;
}


PVOID get_system_module_export(const char* module_name, LPCSTR routine_name) {

	PVOID lpModule = get_system_module_base(module_name);

	if (!lpModule) {
		return 0;
	}

	return RtlFindExportedRoutineByName(lpModule,routine_name);
}

PVOID get_system_routine_address(PCWSTR routine_name) {

	UNICODE_STRING name;
	RtlInitUnicodeString(&name, routine_name);
	return MmGetSystemRoutineAddress(&name);
}


PVOID get_system_module_export(LPCWSTR module_name, LPCSTR routine_name) {

	PLIST_ENTRY module_list = reinterpret_cast<PLIST_ENTRY>(get_system_routine_address(L"PsLoadedModuleList"));

	if (!module_list) {
		return NULL;
	}

	for (PLIST_ENTRY link = module_list; link != module_list->Blink; link = link->Flink) {
		LDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(link, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		UNICODE_STRING name;
		RtlInitUnicodeString(&name, module_name);
		if (RtlEqualUnicodeString(&entry->BaseDllName, &name, TRUE)) {
			return (entry->DllBase) ? RtlFindExportedRoutineByName(entry->DllBase, routine_name) : NULL;
		}
	}
}

bool write_memory(void* address, void* buffer, size_t size) {
	
	if (!RtlCopyMemory(address, buffer, size)) {
		return false;
	}

	else {
		return true;
	}
}
bool write_to_read_only_memory(void* address, void* buffer, size_t size) {

	PMDL Mdl = IoAllocateMdl(address, (ULONG)size, FALSE, FALSE,NULL);

	if (!Mdl) {
		return false;
	}

	MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);
	PVOID Mapping = MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
	MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);

	write_memory(Mapping, buffer, size);

	MmUnmapLockedPages(Mapping, Mdl);
	MmUnlockPages(Mdl);
	IoFreeMdl(Mdl);

	return true;

}

ULONG64 get_module_base_x64(PEPROCESS proc, UNICODE_STRING module_name) {
	PPEB pPeb = PsGetProcessPeb(proc);

	if (!pPeb)
	{
		return NULL;
	}

	KAPC_STATE state;

	KeStackAttachProcess(proc, &state);

	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;

	if (!pLdr) {
		//We're already attached and PEB is invalid so we detach
		KeUnstackDetachProcess(&state);
		return NULL;
	}

	//loop the linked list's Flinks; in the video, that's ModuleListLoadOrder
	for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->InLoadOrderModuleList.Flink; list != &pLdr->InLoadOrderModuleList; list = (PLIST_ENTRY)list->Flink)
	{
		PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		if (RtlCompareUnicodeString(&pEntry->BaseDllName, &module_name, TRUE) == NULL)
		{
			ULONG64 baseAddr = (ULONG64)pEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}
	}

	KeUnstackDetachProcess(&state);
	return NULL;
}


bool read_kernel_memory(HANDLE pid, uintptr_t address, void* buffer, SIZE_T size) {

	if (!address || !buffer || !size)
		return false;
	SIZE_T bytes = 0;
	NTSTATUS status = STATUS_SUCCESS;
	PEPROCESS process;
	//The PsLookupProcessByProcessId routine accepts the process ID of a process and returns a referenced pointer to EPROCESS structure of the process.
	PsLookupProcessByProcessId((HANDLE)pid, &process);

	status = MmCopyVirtualMemory(process, (void*)address, (PEPROCESS)PsGetCurrentProcess(), (void*)buffer, size, KernelMode, &bytes);

	if (!NT_SUCCESS(status)) {
		return false;
	}
	else {
		return true;
	}
}
bool write_kernel_memory(HANDLE pid, uintptr_t address, void* buffer, SIZE_T size) {

	if (!address || !buffer || !size)
		return false;
	SIZE_T bytes = 0;
	NTSTATUS status = STATUS_SUCCESS;
	PEPROCESS process;
	//The PsLookupProcessByProcessId routine accepts the process ID of a process and returns a referenced pointer to EPROCESS structure of the process.
	PsLookupProcessByProcessId((HANDLE)pid, &process);


	KAPC_STATE state;
	//The KeStackAttachProcess routine attaches the current thread to the address space of the target process.
	KeStackAttachProcess((PEPROCESS)process, &state);

	MEMORY_BASIC_INFORMATION info;

	status = ZwQueryVirtualMemory(ZwCurrentProcess(), (PVOID)address, MemoryBasicInformation, &info, sizeof(info), NULL);

	if (!NT_SUCCESS(status)) {

		// We need to detach
		//The KeUnstackDetachProcess routine detaches the current thread from the address space of a process and restores the previous attach state.
		KeUnstackDetachProcess(&state);
		return false;
	}

	//We check we have enough space to write to memory
	if (((uintptr_t)info.BaseAddress + info.RegionSize) < (address + size)){

		KeUnstackDetachProcess(&state);
		return false;
	}

	//Check memory protection + Mem_commit is on
	if (!(info.State & MEM_COMMIT) || (info.Protect & (PAGE_GUARD | PAGE_NOACCESS))) {
		KeUnstackDetachProcess(&state);
		return false;
	}

	//Checking all the flags that will allow us to write to memory
	if ((info.Protect & PAGE_EXECUTE_READWRITE) || (info.Protect & PAGE_EXECUTE_WRITECOPY) || (info.Protect & PAGE_READWRITE) || (info.Protect & PAGE_WRITECOPY))
	{

		//If it's any of these flags, we can write to memory using RtlCopyMemory
		RtlCopyMemory((void*)address, buffer, size);



	}

	KeUnstackDetachProcess(&state);
	return true; 
}
```

`NullDriverCheat/memory.h`:

```h
#pragma once
#include "definitions.h"

PVOID get_system_module_base(const char* module_name);
PVOID get_system_module_export(const char* module_name, LPCSTR routine_name);
PVOID get_system_module_export(LPCWSTR module_name, LPCSTR routine_name);
bool write_memory(void* address, void* buffer, size_t size);
bool write_to_read_only_memory(void* address, void* buffer, size_t size);
ULONG64 get_module_base_x64(PEPROCESS proc, UNICODE_STRING module_name);
bool read_kernel_memory(HANDLE pid, uintptr_t address, void* buffer, SIZE_T size);
bool write_kernel_memory(HANDLE pid, uintptr_t address, void* buffer, SIZE_T size);

typedef struct _NULL_MEMORY {

	void* buffer_address;
	UINT_PTR address;
	ULONGLONG size;
	ULONG pid;
	BOOLEAN write;
	BOOLEAN read;
	BOOLEAN req_base;
	void* output;
	const char* module_name;
	ULONG64 base_address;
}NULL_MEMORY;

```

`NullDriverCheat/messages.h`:

```h
#pragma once

#include <ntdef.h>

#define DebugMessage(x, ...) DbgPrintEx(0, 0, x, __VA_ARGS__)
```

`README.md`:

```md
# NullDriverCheat
My implementation for Windows 11 of Null's Driver Cheat.
Series available here:
https://www.youtube.com/watch?v=KNGr4m99PTU

This has a couple of minor changes; we use NtOpenCompositionSurfaceSectionInfo to avoid detection and a different memory pool tag.
Could potentially look at encrypting strings to hide this a little bit better in Kernel mem.
Honestly, while this works, it'll probably get detected by EAC pretty quickly once the cheat becomes popular and they write a sig for the driver.

```