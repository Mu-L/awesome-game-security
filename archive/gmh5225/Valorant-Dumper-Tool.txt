Project Path: arc_gmh5225_Valorant-Dumper-Tool_f6kwtmhb

Source Tree:

```txt
arc_gmh5225_Valorant-Dumper-Tool_f6kwtmhb
├── README.md
├── VLTool
│   ├── VLTool.vcxproj
│   ├── dllmain.cpp
│   └── utils.hpp
└── VLTool.sln

```

`README.md`:

```md
# Valorant-Dumper-Tool
**VLTool - Valorant Dumper Tool**

A basic offset dumper, credits to peeps on uc for the sigs!

**Offsets currently being dumped:**
- Key
- State
- OwningGameInstance
- LocalPlayers
- Pawn
- RootComponent
- RootPosition
- DamageController
- CameraPosition
- CameraRotation
- CameraFOV

**Updated to latest patch**

```

`VLTool.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31702.278
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VLTool", "VLTool\VLTool.vcxproj", "{557FB16C-C25A-474B-BC17-FF6303C4667C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Debug|x64.ActiveCfg = Debug|x64
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Debug|x64.Build.0 = Debug|x64
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Debug|x86.ActiveCfg = Debug|Win32
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Debug|x86.Build.0 = Debug|Win32
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Release|x64.ActiveCfg = Release|x64
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Release|x64.Build.0 = Release|x64
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Release|x86.ActiveCfg = Release|Win32
		{557FB16C-C25A-474B-BC17-FF6303C4667C}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {39468716-5ECC-4077-80D0-D8FB76EA97E9}
	EndGlobalSection
EndGlobal

```

`VLTool/VLTool.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{557fb16c-c25a-474b-bc17-ff6303c4667c}</ProjectGuid>
    <RootNamespace>dumper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>VLTool</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>F:\v_dumper\dumper;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>F:\v_dumper\dumper;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions); _CRT_SECURE_NO_WARNINGS</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;DUMPER_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>MinSpace</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ProjectReference>
      <LinkLibraryDependencies>true</LinkLibraryDependencies>
      <UseLibraryDependencyInputs>true</UseLibraryDependencyInputs>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="utils.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`VLTool/dllmain.cpp`:

```cpp
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <errhandlingapi.h>

#include "utils.hpp"

#pragma comment(lib, "ntdll.lib")

DWORD WINAPI Main()
{
	AllocConsole();
	freopen("CONIN$", "r", stdin);
	freopen("CONOUT$", "w", stdout);
	freopen("CONOUT$", "w", stderr);

	SetConsoleTitleA("Valorant Dumper | github.com/chase1803");

	DWORD TextPageCount = 0;
	DWORD DataPageCount = 0;

	PIMAGE_DOS_HEADER dos_header = (PIMAGE_DOS_HEADER)GetModuleHandleA(NULL);
	PIMAGE_NT_HEADERS nt_header = (PIMAGE_NT_HEADERS)((DWORD_PTR)dos_header + dos_header->e_lfanew);

	DWORD NumberOfSections = nt_header->FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER Section = (PIMAGE_SECTION_HEADER)((DWORD_PTR)&nt_header->OptionalHeader + nt_header->FileHeader.SizeOfOptionalHeader);

	for (DWORD i = 0; i < NumberOfSections; ++i)
	{
		if (strcmp((const char*)(Section + i)->Name, ".text") == 0)
		{
			Utils::Memory::TextBase = (DWORD_PTR)dos_header + (Section + i)->PointerToRawData - 0x1000;
			Utils::Memory::TextSize += ((Section + i)->SizeOfRawData);
			TextPageCount = ((Section + i)->SizeOfRawData) / 0x1000;
			break;
		}
	}

	const char* code_buffer = (const char*)calloc(1, Utils::Memory::TextSize);
	*(PVOID*)&ZwRaiseException = GetProcAddress(GetModuleHandleA("ntdll.dll"), "ZwRaiseException");

	Utils::Fmt::PrintMessage("Preparing Dumper! Please Wait...\n");

	for (int i = 0; i < TextPageCount; i++)
	{
		PVOID address = (PVOID)(Utils::Memory::TextBase + i * 0x1000);

		MEMORY_BASIC_INFORMATION mbi;
		memset(&mbi, 0, sizeof(mbi));
		VirtualQuery(address, &mbi, sizeof(mbi));

		if (mbi.Protect == PAGE_NOACCESS)
			Utils::Memory::Protect(address);

		memset(&mbi, 0, sizeof(mbi));
		VirtualQuery(address, &mbi, sizeof(mbi));

		if (mbi.Protect != PAGE_NOACCESS)
			memcpy((char*)code_buffer + ((DWORD_PTR)address - Utils::Memory::TextBase), address, 0x1000);
	}

	Utils::GetAddresses(Utils::Memory::TextBase, code_buffer, Utils::Memory::TextSize);
	Utils::PrintOffsets();

	return 0;
};

DWORD WINAPI Lazy(LPVOID lpParameter)
{
	Main();
	return 0;
};

BOOL WINAPI DllMain(HMODULE module, DWORD reason, LPVOID reserved)
{
	if (reason == DLL_PROCESS_ATTACH)
	{
		CloseHandle(CreateThread(NULL, 0, Lazy, NULL, 0, NULL));
	}
	return TRUE;
};

```

`VLTool/utils.hpp`:

```hpp
#pragma once

#include <winternl.h>
#include <fstream>
#include <Psapi.h>
#include <heapapi.h>
#include <dbghelp.h>
#include <shlobj.h>
#include <tchar.h>

void(__stdcall* ZwRaiseException)(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT ThreadContext, BOOLEAN HandleException);

namespace Utils
{
	namespace Fmt
	{
		void PrintMessage(const char* fmt, ...);
		void PrintSingleCharacter(char fmt);
	}

	namespace Memory
	{
		uintptr_t PatternScan(const char* buffer, uint64_t startAddress, uint64_t size, const char* pattern, const char* mask, int offset);

		void Protect(PVOID address);
		DWORD WINAPI RaiseEx(PVOID address);

		DWORD_PTR TextBase = 0;
		DWORD TextSize = 0;
	}

	bool GetAddresses(DWORD_PTR Address, const char* buffer, DWORD Size);
	bool PrintOffsets();
};

namespace Offsets
{
	namespace Globals
	{
		uintptr_t UWorldState, UWorldKey = UWorldState + 0x38;
	}
	uintptr_t OwningGameInstance, LocalPlayers, LocalPawn, RootComponent, RootPosition, DamageController, CameraPosition, CameraRotation, CameraFOV;
};

bool Utils::GetAddresses(DWORD_PTR Address, const char* buffer, DWORD Size)
{
	Offsets::Globals::UWorldState = Memory::PatternScan(buffer, Address, Size, "\x4B\x8B\xBC\xD5\x00\x00\x00\x00\x41\x8B\xC2\x2B\xC2\x45\x8B\xCA", "xxxx????xxxxxxxx", 0x5);
	if (!Offsets::Globals::UWorldState)
	{
		Utils::Fmt::PrintMessage("Failed to get UWorldState!\n");
	}

	Offsets::OwningGameInstance = Memory::PatternScan(buffer, Address, Size, "\x49\x8B\x87\x00\x00\x00\x00\x48\x85\xC0\x74\x09\x48\x8B\xB0\x00\x00\x00\x00\xEB\x07", "xxx????xxxxxxxx????xx", 0x4);
	if (!Offsets::OwningGameInstance)
	{
		Utils::Fmt::PrintMessage("Failed to get OwningGameInstance!\n");
	}

	Offsets::LocalPlayers = Memory::PatternScan(buffer, Address, Size, "\x4E\x8B\x4C\xC1\x00\x49\xC1\xEA\x20\xB8\x00\x00\x00\x00\x41\xF7\xE0\x41\x8B\xC0", "xxxx?xxxxx????xxxxxx", 0x5);
	if (!Offsets::LocalPlayers)
	{
		Utils::Fmt::PrintMessage("Failed to get LocalPlayers!\n");
	}

	Offsets::LocalPawn = Memory::PatternScan(buffer, Address, Size, "\x48\x8B\x40\x08\xFF\x15\x00\x00\x00\x00\x90\x48\x85\xF6\x74\x14\x48\x8B\x06\x48\x8B\xCE\x48\x8B\x80\x00\x00\x00\x00\xFF\x15\x00\x00\x00\x00\x90", "xxxxxx????xxxxxxxxxxxxxxx????xx????x", 0x1A);
	if (!Offsets::LocalPawn)
	{
		Utils::Fmt::PrintMessage("Failed to get LocalPawn!\n");
	}

	Offsets::RootComponent = Memory::PatternScan(buffer, Address, Size, "\x48\x8B\x83\x00\x00\x00\x00\x48\x85\xC0\x74\x08\x48\x05\x00\x00\x00\x00\xEB\x07", "xxx????xxxxxxx????xx", 0x4);
	if (!Offsets::RootComponent)
	{
		Utils::Fmt::PrintMessage("Failed to get RootComponent!\n");
	}

	Offsets::RootPosition = Memory::PatternScan(buffer, Address, Size, "\x8B\x87\x00\x00\x00\x00\x89\x83\x00\x00\x00\x00\x48\x8B\x87\x00\x00\x00\x00\x48\x89\x83\x00\x00\x00\x00\x48\x81\xC3\x00\x00\x00\x00\x49\x3B\xDE", "xx????xx????xxx????xxx????xxx????xxx", 0x3);
	if (!Offsets::RootPosition)
	{
		Utils::Fmt::PrintMessage("Failed to get RootPosition!\n");
	}

	Offsets::DamageController = Memory::PatternScan(buffer, Address, Size, "\x48\x8B\x89\x00\x00\x00\x00\x0F\x28\xF2\x48\x8B\xFA\x48\x85\xC9", "xxx????xxxxxxxxx", 0x4);
	if (!Offsets::DamageController)
	{
		Utils::Fmt::PrintMessage("Failed to get DamageController!\n");
	}

	Offsets::CameraPosition = Memory::PatternScan(buffer, Address, Size, "\xF2\x0F\x11\x87\x00\x00\x00\x00\x8B\x48\x08\x89\x8F\x00\x00\x00\x00\xF2\x0F\x10\x40\x00", "xxxx????xxxxx????xxxx?", 0x5);
	if (!Offsets::CameraPosition)
	{
		Utils::Fmt::PrintMessage("Failed to get CameraPosition!\n");
	}

	Offsets::CameraRotation = Memory::PatternScan(buffer, Address, Size, "\xF2\x0F\x11\x87\x00\x00\x00\x00\x8B\x48\x14\x89\x8F\x00\x00\x00\x00\x8B\x40\x18\x89\x87\x00\x00\x00\x00", "xxxx????xxxxx????xxxxx????", 0x5);
	if (!Offsets::CameraRotation)
	{
		Utils::Fmt::PrintMessage("Failed to get CameraRotation!\n");
	}

	Offsets::CameraFOV = Memory::PatternScan(buffer, Address, Size, "\xF2\x0F\x11\x87\x00\x00\x00\x00\x8B\x48\x14\x89\x8F\x00\x00\x00\x00\x8B\x40\x18\x89\x87\x00\x00\x00\x00", "xxxx????xxxxx????xxxxx????", 0x17);
	if (!Offsets::CameraFOV)
	{
		Utils::Fmt::PrintMessage("Failed to get CameraFOV!\n");
	}

	return true;
};

bool Utils::PrintOffsets()
{
	Fmt::PrintMessage("UWorldState -> 0x%X\n", *(uintptr_t*)Offsets::Globals::UWorldState);
	Fmt::PrintMessage("UWorldKey -> 0x%X\n", *(uintptr_t*)Offsets::Globals::UWorldKey);
	Fmt::PrintMessage("OwningGameInstance -> 0x%X\n", *(uintptr_t*)Offsets::OwningGameInstance);
	Fmt::PrintMessage("LocalPlayers -> 0x%X\n", *(char*)Offsets::LocalPlayers);
	Fmt::PrintMessage("LocalPawn -> 0x%X\n", *(short*)Offsets::LocalPawn);
	Fmt::PrintMessage("RootComponent -> 0x%X\n", *(short*)Offsets::RootComponent);
	Fmt::PrintMessage("RootPosition -> 0x%X\n", *(short*)Offsets::RootPosition);
	Fmt::PrintMessage("DamageController -> 0x%X\n", *(short*)Offsets::DamageController);
	Fmt::PrintMessage("CameraPosition -> 0x%X\n", *(short*)Offsets::CameraPosition);
	Fmt::PrintMessage("CameraRotation -> 0x%X\n", *(short*)Offsets::CameraRotation);
	Fmt::PrintMessage("CameraFOV -> 0x%X\n", *(short*)Offsets::CameraFOV);

	return true;
};

DWORD WINAPI Utils::Memory::RaiseEx(PVOID address)
{
	PEXCEPTION_RECORD exr = NULL;
	CONTEXT ctx;

	ctx.Rip = TerminateThread((HANDLE)-2, 0);
	exr->NumberParameters = 2;
	exr->ExceptionCode = EXCEPTION_ACCESS_VIOLATION;
	exr->ExceptionAddress = address;
	exr->ExceptionInformation[1] = (ULONG_PTR)address;

	ZwRaiseException(exr, &ctx, 1);
	return 0;
};

void Utils::Memory::Protect(PVOID address)
{
	HANDLE hthread = CreateThread(NULL, 0, RaiseEx, address, NULL, 0);
	WaitForSingleObject(hthread, INFINITE);
	CloseHandle(hthread);
};

void Utils::Fmt::PrintSingleCharacter(char fmt)
{
	DWORD written;
	WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), &fmt, 1, &written, NULL);
};

void Utils::Fmt::PrintMessage(const char* fmt, ...)
{
	char buf[4096];
	va_list args;
	va_start(args, fmt);
	vsnprintf(buf, 4096, fmt, args);
	char* bufptr = buf;
	while (*bufptr)
	{
		if (*bufptr == '~')
		{
			++bufptr;
			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), *bufptr);

		}
		else
		{
			PrintSingleCharacter(*bufptr);
		}
		++bufptr;

	}
	PrintSingleCharacter('\n');
	va_end(args);
};

uintptr_t Utils::Memory::PatternScan(const char* buffer, uint64_t startAddress, uint64_t size, const char* pattern, const char* mask, int offset)
{
	size_t pos = 0;
	auto maskLength = strlen(mask);

	for (int j = 0; j < size; j++)
	{
		if (buffer[j] == pattern[pos] || mask[pos] == '?')
		{
			if (mask[pos + 1] == '\0')
			{
				return startAddress + j - maskLength + offset;

			}
			pos++;

		}
		else pos = 0;

	}
	return 0;
};

```