Project Path: arc_gmh5225_memcs_i_0p91wf

Source Tree:

```txt
arc_gmh5225_memcs_i_0p91wf
├── Cargo.toml
├── README.md
├── client
│   ├── Cargo.toml
│   └── src
│       ├── main.rs
│       ├── menu
│       │   ├── mod.rs
│       │   └── stateful_list.rs
│       └── structs.rs
├── core
│   ├── Cargo.toml
│   └── src
│       ├── cheat_ctx.rs
│       ├── lib.rs
│       └── sdk
│           ├── csgo
│           │   ├── clientstate.rs
│           │   ├── common.rs
│           │   ├── entity.rs
│           │   ├── mod.rs
│           │   └── signonstate.rs
│           ├── error.rs
│           ├── mod.rs
│           ├── offset_manager.rs
│           └── structs
│               ├── global_vars.rs
│               ├── glow.rs
│               ├── matrix3x4.rs
│               ├── mod.rs
│               ├── player_info.rs
│               ├── radar_player.rs
│               └── vec3.rs
└── offsets.toml

```

`Cargo.toml`:

```toml
[workspace]

members = [
    "core",
    "client",
]

```

`README.md`:

```md
Status: Rewritten.

todo:
- [ ] Clean up code
- [ ] Aimbot

```

`client/Cargo.toml`:

```toml
[package]
name = "memcs-client"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
memflow = "=0.2.0-beta10"
memcs-core = { path = "../core" }
simple_file_logger = "0.3.1"
log = "0.4.19"

# Menu
crossterm = "0.26.1"
tui = { version = "0.19.0", features = ["crossterm"] }
```

`client/src/main.rs`:

```rs
mod structs;
mod menu;

use std::{time::Duration, sync::{Mutex, Arc}, thread::JoinHandle};

use memflow::{prelude::MemoryView, types::Address};

use memcs_core::{sdk::{csgo::{Entity, set_model_brightness, SignOnState, set_send_packet, get_attack}, self}, CheatCtx};
use simple_file_logger::{init_logger, LogLevel};
use structs::{SharedData, Color, PlayerInfo};

fn chams(ctx: &mut CheatCtx, entity: &Entity, color: Color) {
    let entity_list = entity.get_entity_list(ctx).unwrap();

    ctx.process.write(entity_list + 0x70, &color.red()).unwrap();
    ctx.process.write(entity_list + 0x71, &color.green()).unwrap();
    ctx.process.write(entity_list + 0x72, &color.blue()).unwrap();
}

fn glow(ctx: &mut CheatCtx, glowmanager: Address, entity: &Entity) {
    let glow_idx = entity.get_glowindex(ctx).unwrap();

    // write glow shit
    let offset = glow_idx * 0x38;

    let color = sdk::structs::GlowObjectColor {
        channel_r: 1.0,
        channel_g: 0.25,
        channel_b: 0.25,
        channel_a: 0.75
    };

    let occlusion = sdk::structs::GlowObjectOcclusion {
        render_when_occluded: true,
        render_when_unoccluded: false,
    };

    ctx.process.write(glowmanager + (offset + 0x8), &color).unwrap();
    ctx.process.write(glowmanager + (offset + 0x28), &occlusion).unwrap();
}

fn cheat_thread(shared_data: Arc<Mutex<SharedData>>) -> JoinHandle<()> {
    std::thread::spawn(move || {
        let mut ctx = memcs_core::CheatCtx::setup().unwrap();
        let chams_color = Color::new(25, 255, 25, 50.0);

        loop {
            let start_time = std::time::Instant::now();

            let client_state = sdk::csgo::ClientState::get(&mut ctx).unwrap();
            let game_state = client_state.get_state(&mut ctx).unwrap();

            if game_state == SignOnState::Full {
                let glowmanager = sdk::csgo::get_glowmanager(&mut ctx).unwrap();
                let local = Entity::get_local(&mut ctx).unwrap();
                let local_index = local.get_index(&mut ctx).unwrap();
                let local_team = local.get_team(&mut ctx).unwrap();
                let globals = sdk::csgo::get_globalvars(&mut ctx).unwrap();
                let mut names = vec![PlayerInfo::default(); 64];

                if shared_data.lock().unwrap().config.fakelag {
                    if globals.tickcount % 16 == 0 {
                        set_send_packet(&mut ctx, true).unwrap();
                    } else {
                        set_send_packet(&mut ctx, false).unwrap();
                    }
                }
    
                for index in 0..globals.max_clients {
                    let entity = Entity::from_index(&mut ctx, index as usize).unwrap();
    
                    if !entity.is_player(&mut ctx).unwrap() {
                        continue;
                    }
    
                    let mut is_alive = true;
            
                    if entity.get_health(&mut ctx).unwrap() <= 0 {
                        is_alive = false;
                    }
    
                    let is_enemy = entity.get_team(&mut ctx).unwrap() != local_team;
                    let is_local = local_index - 1 == index;
                    let player_info = client_state.get_userinfo_table(&mut ctx, index).unwrap();
                    let name = player_info.get_name(&mut ctx).unwrap();
                    names[index as usize] = PlayerInfo::new(Some(name), is_enemy, is_local, is_alive);
    
                    if !is_alive {
                        continue;
                    }
    
                    if is_enemy {
                        let lock = shared_data.lock().unwrap();
    
                        if lock.config.glow {
                            glow(&mut ctx, glowmanager, &entity);
                        }
    
                        if lock.config.radar {
                            entity.set_spotted(&mut ctx, true).unwrap();
                        }
    
                        if lock.config.chams {
                            chams(&mut ctx, &entity, chams_color);
                        } else if lock.chams_once {
                            chams(&mut ctx, &entity, Color::new(255, 255, 255, 0.0));
                        }
                    }
                }
    
                let mut lock = shared_data.lock().unwrap();
                lock.player_list = names.to_vec();
    
                if lock.config.chams {
                    set_model_brightness(&mut ctx, chams_color.brightness()).unwrap();
    
                    if !lock.chams_once {
                        lock.chams_once = true;
                    }
                } else if lock.chams_once {
                    set_model_brightness(&mut ctx, 0.0).unwrap();
                    lock.chams_once = false;
                }

                if lock.config.fakelag {
                    lock.fakelag_once = true;
                } else if lock.fakelag_once {
                    set_send_packet(&mut ctx, true).unwrap();
                    lock.fakelag_once = false;
                }
            } else {
                let mut lock = shared_data.lock().unwrap();

                if lock.chams_once {
                    set_model_brightness(&mut ctx, 0.0).unwrap();
                    lock.chams_once = false;
                }

                lock.player_list = vec![];
            }

            let end_time = std::time::Instant::now();
            let elapsed = end_time.checked_duration_since(start_time);
    
            let mut lock = shared_data.lock()
                .expect("Mutex is poisoned!");

            lock.elapsed_time = elapsed;
            lock.game_state = Some(game_state);

            if lock.engine_base.is_none() {
                lock.engine_base = Some(ctx.engine_module.base);
            }

            if lock.client_base.is_none() {
                lock.client_base = Some(ctx.client_module.base);
            }

            if lock.should_exit {
                if !lock.chams_once && !lock.fakelag_once {
                    break;
                } else {
                    lock.config.chams = false;
                    lock.config.fakelag = false;
                }
            }

            drop(lock);
            
            std::thread::sleep(Duration::from_millis(1))
        }
    })
}

fn main() {
    init_logger("memcs-client", LogLevel::Info).unwrap();

    let data = SharedData::default();
    let shared_data = Arc::new(Mutex::new(data));

    let join_handle = cheat_thread(Arc::clone(&shared_data));
    menu::run_menu(Arc::clone(&shared_data)).unwrap();
    join_handle.join().expect("Cheat is still running.");
}

```

`client/src/menu/mod.rs`:

```rs
use std::{sync::{Arc, Mutex}, time::Duration};

use crossterm::{terminal::{enable_raw_mode, EnterAlternateScreen, disable_raw_mode, LeaveAlternateScreen}, execute, event::{EnableMouseCapture, DisableMouseCapture, Event, self, KeyCode}};
use memcs_core::sdk::csgo::SignOnState;
use tui::{backend::{Backend, CrosstermBackend}, Frame, layout::{Layout, Direction, Constraint}, widgets::{List, ListItem, Block, Borders}, style::{Style, Modifier}, Terminal};

use crate::structs::{SharedData, PlayerInfo};

use self::stateful_list::StatefulList;

mod stateful_list;

const BORDER_STYLE: tui::style::Color = tui::style::Color::LightCyan;
const TEXT_STYLE: tui::style::Color = tui::style::Color::DarkGray;
const LOCAL_TEXT_STYLE: tui::style::Color = tui::style::Color::White;
const ENEMY_TEXT_STYLE: tui::style::Color = tui::style::Color::LightRed;
const FRIENDLY_TEXT_STYLE: tui::style::Color = tui::style::Color::LightBlue;

pub struct Menu {
    shared_data: Arc<Mutex<SharedData>>,
    settings_list: StatefulList<(String, bool)>
}

impl Menu {
    fn new(shared_data: Arc<Mutex<SharedData>>) -> Menu {
        Menu {
            shared_data,
            settings_list: StatefulList::with_items(vec![
                (String::from("glow"), false),
                (String::from("radar"), false),
                (String::from("chams"), false),
                (String::from("fakelag"), false)
            ])
        }
    }

    pub fn kill_cheat(&self) {
        let mut lock = self.shared_data.lock().unwrap();
        lock.should_exit = true;
    }

    pub fn run<B: Backend>(&mut self, f: &mut Frame<B>) {
        let rects = Layout::default()
            .direction(Direction::Horizontal)
            .constraints([
                Constraint::Percentage(55),
                Constraint::Percentage(25),
                Constraint::Percentage(20),
            ])
            .margin(1)
            .split(f.size());
        
        let lock = self.shared_data.lock().unwrap();
        let settings = get_settings_block(&self.settings_list);
        let player_info = get_player_block(&lock.player_list);
        let statistics = get_statistics_block(lock.elapsed_time, lock.game_state);
        drop(lock);

        f.render_stateful_widget(settings, rects[0], &mut self.settings_list.state);
        f.render_widget(player_info, rects[1]);
        f.render_widget(statistics, rects[2]);
    }
}

pub fn run_menu(shared_data: Arc<Mutex<SharedData>>) -> std::io::Result<()> {
    enable_raw_mode()?;
    let mut stdout = std::io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let mut menu = Menu::new(shared_data.clone());
    terminal.clear().unwrap();
    
    loop {
        terminal.draw(|f| {
            menu.run(f);
        }).unwrap();

        if crossterm::event::poll(std::time::Duration::from_millis(200))? {
            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Char('q') => {
                        menu.kill_cheat();
                        break
                    },
                    KeyCode::Down => menu.settings_list.next(),
                    KeyCode::Up => menu.settings_list.previous(),
                    KeyCode::Char(' ') => {
                        if let Some(idx) = menu.settings_list.state.selected() {
                            let mut lock = shared_data.lock().unwrap();

                            fn switch(items: &mut [(String, bool)], setting: &mut bool, index: usize) {
                                *setting = !*setting;
                                items[index].1 = *setting;
                            }

                            match idx {
                                0 => {
                                    switch(&mut menu.settings_list.items, &mut lock.config.glow, idx)
                                },
                                1 => {
                                    switch(&mut menu.settings_list.items, &mut lock.config.radar, idx)
                                },
                                2 => {
                                    switch(&mut menu.settings_list.items, &mut lock.config.chams, idx)
                                },
                                3 => {
                                    switch(&mut menu.settings_list.items, &mut lock.config.fakelag, idx)
                                }
                                _ => {}
                            }
                        };
                    },
                    _ => {}
                }
            }
        }
    }

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen, DisableMouseCapture)?;
    terminal.show_cursor()?;
    Ok(())
}

fn get_settings_block(list_state: &StatefulList<(String, bool)>) -> List<'static> {
    let items: Vec<ListItem> = list_state
        .items
        .iter()
        .map(|i| {
            let enabled_text = match i.1 {
                false => "disabled",
                true => "enabled"
            };
            ListItem::new(format!("{} - {}", i.0, enabled_text))
                .style(
                    Style::default()
                        .fg(TEXT_STYLE)
                )
        })
        .collect();

    List::new(items)
        .block(
            Block::default()
                .title("settings")
                .borders(Borders::ALL)
                .border_style(
                    Style::default()
                        .fg(BORDER_STYLE)
                )
        )
        .highlight_style(
            Style::default()
                .add_modifier(Modifier::BOLD),
        )
        .highlight_symbol(">> ")
}

fn get_player_block(player_data: &[PlayerInfo]) -> List<'static> {
    let player_data = player_data
        .iter()
        .filter(|data| data.name().is_some());

    let items: Vec<ListItem> = player_data
        .map(|data| {
            let style = match (data.is_enemy(), data.is_local()) {
                (true, false) => Style::default().fg(ENEMY_TEXT_STYLE),
                (false, true) => Style::default().fg(LOCAL_TEXT_STYLE),
                (true, true) => Style::default().fg(ENEMY_TEXT_STYLE),
                (false, false) => Style::default().fg(FRIENDLY_TEXT_STYLE),
            };

            let name = match data.is_alive() {
                true => data.name().unwrap(),
                false => format!("[D] {}", data.name().unwrap()),
            };

            ListItem::new(name)
            .style(
                style
            )
    }).collect();

    List::new(items)
        .block(
            Block::default()
                .title("player list")
                .borders(Borders::ALL)
                .border_style(
                    Style::default()
                        .fg(BORDER_STYLE)
                )
        )
}

fn get_statistics_block(elapsed_time: Option<Duration>, game_state: Option<SignOnState>) -> List<'static> {
    let game_state_str = match game_state {
        Some(state) => state.to_string(),
        None => String::from("unknown"),
    };

    let items = vec![
        ListItem::new(format!("runtime: {} µs", elapsed_time.unwrap_or_default().as_micros()))
            .style(
                Style::default()
                .fg(TEXT_STYLE)
                .add_modifier(Modifier::ITALIC)
            ),

        ListItem::new(format!("state: {}",game_state_str))
            .style(
                Style::default()
                .fg(TEXT_STYLE)
                .add_modifier(Modifier::ITALIC)
            ),

        ListItem::new(" "),

        ListItem::new("Press q to quit.")
            .style(
                Style::default()
                .fg(TEXT_STYLE)
            )
    ];

    List::new(items)
        .block(
            Block::default()
                .title("info")
                .borders(Borders::ALL)
                .border_style(
                    Style::default()
                        .fg(BORDER_STYLE)
                )
        )
}
```

`client/src/menu/stateful_list.rs`:

```rs
use tui::widgets::ListState;

pub struct StatefulList<T> {
    pub state: ListState,
    pub items: Vec<T>,
}

impl<T> StatefulList<T> {
    pub fn with_items(items: Vec<T>) -> StatefulList<T> {
        StatefulList {
            state: ListState::default(),
            items,
        }
    }

    pub fn next(&mut self) {
        let i = match self.state.selected() {
            Some(i) => {
                if i >= self.items.len() - 1 {
                    0
                } else {
                    i + 1
                }
            }
            None => 0,
        };
        self.state.select(Some(i));
    }

    pub fn previous(&mut self) {
        let i = match self.state.selected() {
            Some(i) => {
                if i == 0 {
                    self.items.len() - 1
                } else {
                    i - 1
                }
            }
            None => 0,
        };
        self.state.select(Some(i));
    }
}
```

`client/src/structs.rs`:

```rs
use memcs_core::sdk::csgo::SignOnState;
use memflow::types::Address;

#[derive(Clone, Copy)]
pub struct Config {
    pub glow: bool,
    pub bhop: bool,
    pub radar: bool,
    pub chams: bool,
    pub fakelag: bool,
}

#[derive(Clone)]
pub struct PlayerInfo {
    name: Option<String>,
    is_enemy: bool,
    is_local: bool,
    is_alive: bool,
}

impl PlayerInfo {
    pub fn new(name: Option<String>, is_enemy: bool, is_local: bool, is_alive: bool) -> Self {
        Self {
            name, is_enemy, is_local, is_alive
        }
    }

    pub fn default() -> Self {
        Self {
            name: None,
            is_enemy: false,
            is_local: false,
            is_alive: false,
        }
    }

    pub fn name(&self) -> Option<String> {
        self.name.clone()
    }

    pub fn is_enemy(&self) -> bool {
        self.is_enemy
    }

    pub fn is_local(&self) -> bool {
        self.is_local
    }

    pub fn is_alive(&self) -> bool {
        self.is_alive
    }
}

#[derive(Clone)]
pub struct SharedData {
    pub player_list: Vec<PlayerInfo>,
    pub elapsed_time: Option<std::time::Duration>,
    pub engine_base: Option<Address>,
    pub client_base: Option<Address>,
    pub config: Config,
    pub chams_once: bool,
    pub fakelag_once: bool,
    pub should_exit: bool,
    pub game_state: Option<SignOnState>,
}

impl SharedData {
    pub fn default() -> Self {
        Self {
            player_list: vec![],
            elapsed_time: None,
            engine_base: None,
            client_base: None,
            config: Config {
                glow: false,
                bhop: false,
                radar: false,
                chams: false,
                fakelag: false,
            },
            chams_once: false,
            fakelag_once: false,
            should_exit: false,
            game_state: None,
        }
    }
}

#[derive(Clone, Copy)]
pub struct Color {
    r: u8,
    g: u8,
    b: u8,
    brightness: f32,
}

impl Color {
    pub fn new(r: u8, g: u8, b: u8, brightness: f32) -> Color {
        Color {
            r, g, b, brightness
        }
    }

    pub fn red(&self) -> u8 {
        self.r
    }

    pub fn green(&self) -> u8 {
        self.g
    }

    pub fn blue(&self) -> u8 {
        self.b
    }

    pub fn brightness(&self) -> f32 {
        self.brightness
    }
}
```

`core/Cargo.toml`:

```toml
[package]
name = "memcs-core"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
memflow = "=0.2.0-beta10"
dataview = "1.0.1"
toml = "0.7.5"
serde = "1.0.164"
serde_json = "1.0.99"
regex = "1.8.4"
nom = "7.1.3"
libm = "0.2.7"
log = "0.4.19"
simplelog = "0.12.1"
reqwest = { version = "0.11.18", features = ["blocking"] }
thiserror = "1.0.40"
num-traits = "0.2"
num-derive = "0.4"
num = "0.4.1"

```

`core/src/cheat_ctx.rs`:

```rs
use log::info;
use memflow::prelude::v1::*;

use crate::sdk::{self, Offsets};

pub struct CheatCtx {
    pub process: IntoProcessInstanceArcBox<'static>,
    pub client_module: ModuleInfo,
    pub engine_module: ModuleInfo,
    pub offsets: Offsets,
}

impl CheatCtx {
    pub fn setup() -> std::result::Result<CheatCtx, super::sdk::error::Error> {
        let inventory = Inventory::scan();

        let os = inventory.builder()
            .connector("qemu")
            .os("win32")
            .build()?;

        info!("Created kernel - addr: {}", os.info().base);

        let mut process = os.into_process_by_name("csgo.exe")?;

        info!(
            "Found csgo process - {} - addr: {}",
            process.info().pid,
            process.info().address
        );

        let client_module = process.module_by_name("client.dll")?;
        info!("Found client module - addr: {}", client_module.base);

        let engine_module = process.module_by_name("engine.dll")?;
        info!("Found engine module - addr: {}", engine_module.base);

        let offsets = sdk::get_offsets()?;

        let ctx = Self {
            process,
            client_module,
            engine_module,
            offsets,
        };

        Ok(ctx)
    }
}

```

`core/src/lib.rs`:

```rs
mod cheat_ctx;
#[allow(dead_code)]
pub mod sdk;

pub use cheat_ctx::CheatCtx;

#[macro_use]
extern crate num_derive;
```

`core/src/sdk/csgo/clientstate.rs`:

```rs
use memflow::{prelude::MemoryView, types::Address};

use crate::{
    cheat_ctx::CheatCtx,
    sdk::{
        error::Error,
        structs::{PlayerInfo, Vec3},
    },
};

use super::SignOnState;

pub struct ClientState {
    pub ptr: Address,
}

impl ClientState {
    pub fn get(ctx: &mut CheatCtx) -> Result<ClientState, Error> {
        let offset = ctx.offsets.get_sig("dwClientState")?;
        let ptr = ctx.process.read_addr32(ctx.engine_module.base + offset)?;

        Ok(ClientState { ptr })
    }

    pub fn get_viewangles(&self, ctx: &mut CheatCtx) -> Result<Vec3, Error> {
        let offset = ctx.offsets.get_sig("dwClientState_ViewAngles")?;
        Ok(ctx.process.read(self.ptr + offset)?)
    }

    pub fn set_viewangles(&self, ctx: &mut CheatCtx, newangles: Vec3) -> Result<(), Error> {
        let offset = ctx.offsets.get_sig("dwClientState_ViewAngles")?;
        Ok(ctx.process.write(self.ptr + offset, &newangles)?)
    }

    pub fn get_userinfo_table(
        &self,
        ctx: &mut CheatCtx,
        index: i32,
    ) -> Result<PlayerInfo, Error> {
        let offset = ctx.offsets.get_sig("dwClientState_PlayerInfo").unwrap();
        let userinfotable_ptr = ctx.process.read_addr32(self.ptr + offset)?;
        let items_ptr = ctx.process.read_addr32(userinfotable_ptr + 0x40)?;
        let items = ctx.process.read_addr32(items_ptr + 0xC)?;
        let info = ctx.process.read_addr32(items + 0x28 + (index * 0x34))?;

        Ok(PlayerInfo {
            addr: info
        })
    }

    pub fn is_ingame(&self, ctx: &mut CheatCtx) -> Result<bool, Error> {
        let offset = ctx.offsets.get_sig("dwClientState_State")?;
        let state: i32 = ctx.process.read(self.ptr + offset)?;
        Ok(state == 6)
    }

    pub fn get_state(&self, ctx: &mut CheatCtx) -> Result<SignOnState, Error> {
        let offset = ctx.offsets.get_sig("dwClientState_State")?;
        let state: i32 = ctx.process.read(self.ptr + offset)?;
        Ok(num::FromPrimitive::from_i32(state).unwrap())
    }

}
```

`core/src/sdk/csgo/common.rs`:

```rs
use memflow::{prelude::MemoryView, types::Address};

use crate::{
    cheat_ctx::CheatCtx,
    sdk::{error::Error, structs::GlobalVars},
};

pub fn get_playerresource(ctx: &mut CheatCtx) -> Result<Address, Error> {
    let offset = ctx.offsets.get_sig("dwPlayerResource")?;
    Ok(ctx.process.read_addr32(ctx.client_module.base + offset)?)
}

pub fn get_radarbase(ctx: &mut CheatCtx) -> Result<Address, Error> {
    let offset = ctx.offsets.get_sig("dwRadarBase")?;
    let offset = ctx.process.read_addr32(ctx.client_module.base + offset)?;

    Ok(ctx.process.read_addr32(offset + 0x74)?)
}

pub fn get_globalvars(ctx: &mut CheatCtx) -> Result<GlobalVars, Error> {
    let offset = ctx.offsets.get_sig("dwGlobalVars")?;
    Ok(ctx.process.read(ctx.engine_module.base + offset)?)
}

pub fn get_glowmanager(ctx: &mut CheatCtx) -> Result<Address, Error> {
    let offset = ctx.offsets.get_sig("dwGlowObjectManager")?;
    Ok(ctx.process.read_addr32(ctx.client_module.base + offset)?)
}

pub fn set_model_brightness(ctx: &mut CheatCtx, brightness: f32) -> Result<(), Error> {
    let offset = ctx.offsets.get_sig("model_ambient_min")?;
    let offset_as_u32 = offset as u32;
    let ptr = ctx.engine_module.base.to_umem() as u32 + offset_as_u32 - 0x2c;

    let brightness_as_u32: u32 = brightness.to_bits();
    let xored: u32 = brightness_as_u32 ^ ptr;

    Ok(ctx.process.write(ctx.engine_module.base + offset, &xored)?)
}

pub fn set_send_packet(ctx: &mut CheatCtx, value: bool) -> Result<(), Error> {
    let offset = ctx.offsets.get_sig("dwbSendPackets")?;
    let data = if value { 1u8 } else { 0u8 };
    Ok(ctx.process.write(ctx.engine_module.base + offset, &data )?)
}

pub fn get_attack(ctx: &mut CheatCtx) -> Result<i32, Error> {
    let offset = ctx.offsets.get_sig("dwForceAttack")?;
    Ok(ctx.process.read(ctx.client_module.base + offset)?)
}

pub const RANKS: [&str; 19] = [
    "Unranked",
    "Silver I",
    "Silver II",
    "Silver III",
    "Silver IV",
    "Silver Elite",
    "Silver Elite Master",
    "Gold Nova I",
    "Gold Nova II",
    "Gold Nova III",
    "Gold Nova Master",
    "Master Guardian I",
    "Master Guardian II",
    "Master Guardian Elite",
    "Distinguished Master Guardian",
    "Legendary Eagle",
    "Legendary Eagle Master",
    "Supreme Master First Class",
    "The Global Elite",
];

```

`core/src/sdk/csgo/entity.rs`:

```rs
use memflow::{prelude::MemoryView, types::Address};

use crate::{
    cheat_ctx::CheatCtx,
    sdk::{
        error::Error,
        structs::{Matrix3x4, RadarPlayer, Vec3},
    },
};

pub struct Entity {
    pub ptr: Address,
    pub index: usize,
}

impl Entity {
    pub fn from_index(ctx: &mut CheatCtx, index: usize) -> Result<Entity, Error> {
        let offset = ctx.offsets.get_sig("dwEntityList")?;
        let ptr = ctx
            .process
            .read_addr32(ctx.client_module.base + offset + (index * 0x10))?;

        Ok(Entity { ptr, index })
    }

    pub fn get_local(ctx: &mut CheatCtx) -> Result<Entity, Error> {
        let offset = ctx.offsets.get_sig("dwLocalPlayer")?;
        let ptr = ctx.process.read_addr32(ctx.client_module.base + offset)?;

        let index: i32 = ctx.process.read(ptr + 0x64)?;

        Ok(Entity {
            ptr,
            index: index as usize,
        })
    }

    pub fn get_index(&self, ctx: &mut CheatCtx) -> Result<i32, Error> {
        Ok(ctx.process.read(self.ptr + 0x64)?)
    }

    pub fn get_health(&self, ctx: &mut CheatCtx) -> Result<i32, Error> {
        let offset = ctx.offsets.get_var("m_iHealth")?;
        Ok(ctx.process.read(self.ptr + offset)?)
    }

    pub fn get_team(&self, ctx: &mut CheatCtx) -> Result<i32, Error> {
        let offset = ctx.offsets.get_var("m_iTeamNum")?;
        Ok(ctx.process.read(self.ptr + offset)?)
    }

    pub fn get_dormant(&self, ctx: &mut CheatCtx) -> Result<bool, Error> {
        let offset = ctx.offsets.get_var("m_bDormant")?;
        let data: u8 = ctx.process.read(self.ptr + offset)?;

        Ok(data != 0)
    }

    pub fn get_glowindex(&self, ctx: &mut CheatCtx) -> Result<usize, Error> {
        let offset = ctx.offsets.get_var("m_iGlowIndex")?;
        let data: i32 = ctx.process.read(self.ptr + offset)?;

        Ok(data as usize)
    }

    pub fn get_pos(&self, ctx: &mut CheatCtx) -> Result<Vec3, Error> {
        let offset = ctx.offsets.get_var("m_vecOrigin")?;
        Ok(ctx.process.read(self.ptr + offset)?)
    }

    pub fn get_viewoffset(&self, ctx: &mut CheatCtx) -> Result<Vec3, Error> {
        let offset = ctx.offsets.get_var("m_vecViewOffset")?;
        Ok(ctx.process.read(self.ptr + offset)?)
    }

    pub fn get_aimpunch(&self, ctx: &mut CheatCtx) -> Result<Vec3, Error> {
        let offset = ctx.offsets.get_var("m_aimPunchAngle")?;
        Ok(ctx.process.read(self.ptr + offset)?)
    }

    pub fn get_spotted(&self, ctx: &mut CheatCtx) -> Result<bool, Error> {
        let offset = ctx.offsets.get_var("m_bSpotted")?;
        let data: u8 = ctx.process.read(self.ptr + offset)?;

        Ok(data != 0)
    }

    pub fn set_spotted(&self, ctx: &mut CheatCtx, value: bool) -> Result<(), Error> {
        let offset = ctx.offsets.get_var("m_bSpotted")?;
        Ok(ctx.process.write(self.ptr + offset, &(value as u8))?)
    }

    pub fn get_spotted_mask(&self, ctx: &mut CheatCtx) -> Result<i32, Error> {
        let offset = ctx.offsets.get_var("m_bSpottedByMask")?;
        Ok(ctx.process.read(self.ptr + offset)?)
    }

    pub fn get_bonematrix_ptr(&self, ctx: &mut CheatCtx) -> Result<Address, Error> {
        let offset = ctx.offsets.get_var("m_dwBoneMatrix")?;
        Ok(ctx.process.read_addr32(self.ptr + offset)?)
    }

    pub fn get_bonepos(&self, ctx: &mut CheatCtx, bone_id: usize) -> Result<Vec3, Error> {
        let bonematrix_ptr = self.get_bonematrix_ptr(ctx)?;
        let bonematrix: Matrix3x4 = ctx.process.read(bonematrix_ptr + (bone_id * 0x30))?;

        Ok(Vec3::new(
            bonematrix.row0[3],
            bonematrix.row1[3],
            bonematrix.row2[3],
        ))
    }

    pub fn get_comp_rank(
        &self,
        ctx: &mut CheatCtx,
        player_resources: Address,
    ) -> Result<i32, Error> {
        let offset = ctx.offsets.get_var("m_iCompetitiveRanking")?;
        Ok(ctx
            .process
            .read(player_resources + offset + (self.index * 0x4))?)
    }

    pub fn get_comp_wins(
        &self,
        ctx: &mut CheatCtx,
        player_resources: Address,
    ) -> Result<i32, Error> {
        let offset = ctx.offsets.get_var("m_iCompetitiveWins")?;
        Ok(ctx
            .process
            .read(player_resources + offset + (self.index * 0x4))?)
    }

    pub fn get_radarplayer(
        &self,
        ctx: &mut CheatCtx,
        radar_base: Address,
    ) -> Result<RadarPlayer, Error> {
        Ok(ctx
            .process
            .read(radar_base + (0x174 * (self.index + 1)) - 0x3C)?)
    }

    pub fn get_entity_list(&self, ctx: &mut CheatCtx) -> Result<Address, Error> {
        let offset = ctx.offsets.get_sig("dwEntityList")?;
        Ok(ctx
            .process
            .read_addr32(ctx.client_module.base + offset + (self.index * 0x10))?)
    }

    pub fn get_class_id(&self, ctx: &mut CheatCtx) -> Result<u32, Error> {
        let ptr1 = ctx.process.read_addr32(self.ptr + 0x8)?;
        let ptr2 = ctx.process.read_addr32(ptr1 + 2 * 0x4)?;
        let ptr3 = ctx.process.read_addr32(ptr2 + 0x1)?;
        Ok(ctx.process.read(ptr3 + 0x14)?)
    }

    pub fn is_player(&self, ctx: &mut CheatCtx) -> Result<bool, Error> {
        let class_id = self.get_class_id(ctx)?;
        log::info!("{}", class_id);
        Ok(class_id == 40)
    }
}

```

`core/src/sdk/csgo/mod.rs`:

```rs
mod clientstate;
mod common;
mod entity;
mod signonstate;

pub use clientstate::ClientState;
pub use common::*;
pub use entity::*;
pub use signonstate::SignOnState;
```

`core/src/sdk/csgo/signonstate.rs`:

```rs
#[derive(FromPrimitive, ToPrimitive, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum SignOnState {
    None = 0,
    Challenge,
    Connected,
    New,
    Prespawn,
    Spawn,
    Full,
    ChangeLevel
}

impl SignOnState {
    pub fn as_str(&self) -> &str {
        match self {
            SignOnState::None => "disconnected",
            SignOnState::Challenge => "challenge",
            SignOnState::Connected => "connected",
            SignOnState::New => "new",
            SignOnState::Prespawn => "prespawn",
            SignOnState::Spawn => "spawn",
            SignOnState::Full => "ingame",
            SignOnState::ChangeLevel => "change level",
        }
    }
}

impl core::fmt::Display for SignOnState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
```

`core/src/sdk/error.rs`:

```rs
use std::string::FromUtf8Error;

use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("could not find signature")]
    SignatureNotFoundError,

    #[error("could not find netvar")]
    NetvarNotFoundError,

    #[error("unknown io error")]
    IoError(#[from] std::io::Error),

    #[error("failure when converting from utf8")]
    FromUtf8Error(#[from] FromUtf8Error),

    #[error("failure when parsing toml")]
    ParseError(#[from] toml::de::Error),

    #[error("reqwest failure")]
    ReqwestError(#[from] reqwest::Error),

    #[error("unknown memflow error")]
    MemflowError(#[from] memflow::error::Error),

    #[error("unrar error")]
    MemflowPartial { msg: String },

    #[error("unknown data store error")]
    Unknown,
}

impl<T> From<memflow::error::PartialError<T>> for Error {
    fn from(err: memflow::error::PartialError<T>) -> Self {
        let msg = err.to_string();
        Self::MemflowPartial { msg }
    }
}

```

`core/src/sdk/mod.rs`:

```rs
pub mod csgo;
pub mod error;
mod offset_manager;
pub mod structs;

pub use offset_manager::*;

```

`core/src/sdk/offset_manager.rs`:

```rs
use std::collections::HashMap;

use toml::{map::Map, Value};

use super::error::Error;

#[derive(Clone, Default)]
pub struct Offsets {
    sigs: HashMap<String, i64>,
    vars: HashMap<String, i64>,
}

impl Offsets {
    pub fn new(signatures: Map<String, Value>, netvars: Map<String, Value>) -> Self {
        let mut sigs = HashMap::new();
        signatures.into_iter().for_each(|f| {
            sigs.insert(f.0, f.1.as_integer().unwrap());
        });

        let mut vars = HashMap::new();
        netvars.into_iter().for_each(|f| {
            vars.insert(f.0, f.1.as_integer().unwrap());
        });

        Self { sigs, vars }
    }

    pub fn get_sig(&self, sig_name: &str) -> Result<i64, super::error::Error> {
        self.sigs
            .get(sig_name)
            .copied()
            .ok_or(Error::SignatureNotFoundError)
    }

    pub fn get_var(&self, var_name: &str) -> Result<i64, super::error::Error> {
        self.vars
            .get(var_name)
            .copied()
            .ok_or(Error::NetvarNotFoundError)
    }
}

pub fn get_offsets() -> Result<Offsets, Error> {
    let offsets = read_offsets_from_file()?;

    let netvars = offsets["netvars"].as_table().unwrap().clone();
    let signatures = offsets["signatures"].as_table().unwrap().clone();

    let offsets = Offsets::new(signatures, netvars);

    Ok(offsets)
}

fn read_offsets_from_file() -> Result<Value, Error> {
    if std::path::Path::new("./offsets.toml").exists() {
        let file_content = std::fs::read("./offsets.toml")?;

        let file_content = String::from_utf8(file_content)?;
        let file_content = file_content.parse::<Value>()?;

        Ok(file_content)
    } else {
        let res = reqwest::blocking::get(
            "https://raw.githubusercontent.com/frk1/hazedumper/master/csgo.toml",
        )?;
        let content = res.text()?;

        std::fs::write("./offsets.toml", content)?;

        read_offsets_from_file()
    }
}

```

`core/src/sdk/structs/global_vars.rs`:

```rs
#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub struct GlobalVars {
    pub realtime: f32,                     // 0x00
    pub framecount: f32,                   // 0x04
    pub absoluteframetime: f32,            // 0x08
    pub absoluteframestarttimestddev: f32, // 0x0C
    pub curtime: f32,                      // 0x10
    pub frametime: f32,                    // 0x14
    pub max_clients: i32,                  // 0x18
    pub tickcount: i32,                    // 0x1C
    pub interval_per_tick: f32,            // 0x20
    pub interpolation_amount: f32,         // 0x24
    pub sim_ticks_this_frame: i32,         // 0x28
    pub network_protocol: i32,             // 0x2C
    pub save_data: i32,                    // 0x30
    pub client: bool,                      // 0x34
    pub remote_client: bool,               // 0x35
    pub timestamp_networking_base: i32,    // 0x36
    pub timestamp_randomize_window: i32,   // 0x3A
} // 0x3E

unsafe impl dataview::Pod for GlobalVars {}

```

`core/src/sdk/structs/glow.rs`:

```rs
#[derive(Clone, Copy)]
#[repr(C)]
pub struct GlowObjectColor {
    pub channel_r: f32,
    pub channel_g: f32,
    pub channel_b: f32,
    pub channel_a: f32,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct GlowObjectOcclusion {
    pub render_when_occluded: bool,
    pub render_when_unoccluded: bool,
}

unsafe impl dataview::Pod for GlowObjectColor {}
unsafe impl dataview::Pod for GlowObjectOcclusion {}

```

`core/src/sdk/structs/matrix3x4.rs`:

```rs
#[derive(Clone, Copy)]
#[repr(C)]
pub struct Matrix3x4 {
    pub row0: [f32; 4],
    pub row1: [f32; 4],
    pub row2: [f32; 4],
}

unsafe impl dataview::Pod for Matrix3x4 {}

```

`core/src/sdk/structs/mod.rs`:

```rs
mod global_vars;
mod glow;
mod matrix3x4;
mod player_info;
mod radar_player;
mod vec3;

pub use global_vars::GlobalVars;
pub use glow::*;
pub use matrix3x4::Matrix3x4;
pub use player_info::PlayerInfo;
pub use radar_player::RadarPlayer;
pub use vec3::Vec3;

```

`core/src/sdk/structs/player_info.rs`:

```rs
use memflow::{types::Address, prelude::MemoryView};

use crate::{CheatCtx, sdk::error::Error};

#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct PlayerInfo {
    pub addr: Address
}

impl PlayerInfo {
    pub fn get_name(&self, ctx: &mut CheatCtx) -> Result<String, Error> {
        Ok(ctx.process.read_char_string_n(self.addr + 0x10, 128)?)
    }
}

unsafe impl dataview::Pod for PlayerInfo {}

```

`core/src/sdk/structs/radar_player.rs`:

```rs
use super::vec3::Vec3;

#[derive(Clone, Copy)]
#[repr(C)]
pub struct RadarPlayer {
    pub origin: Vec3,         // 0x0000
    pub viewangles: Vec3,     // 0x000C
    padding_0x0018: [u8; 56], // 0x0018
    pub health: i32,          // 0x0050
    name: [char; 32],         // 0x0054
    pad_0x00d4: [u8; 117],    // 0x00D4
    pub visible: u8,          // 0x00E9
} // full size: 0x0B32

impl RadarPlayer {
    pub fn get_name(&self) -> String {
        self.name.iter().cloned().collect()
    }
}

unsafe impl dataview::Pod for RadarPlayer {}

```

`core/src/sdk/structs/vec3.rs`:

```rs
#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl Vec3 {
    pub fn new(x: f32, y: f32, z: f32) -> Vec3 {
        Vec3 { x, y, z }
    }
}

unsafe impl dataview::Pod for Vec3 {}

```

`offsets.toml`:

```toml
timestamp = 1686124261

[signatures]
anim_overlays = 10640
clientstate_choked_commands = 19760
clientstate_delta_ticks = 372
clientstate_last_outgoing_command = 19756
clientstate_net_channel = 156
convar_name_hash_table = 197024
dwClientState = 5894556
dwClientState_GetLocalPlayer = 384
dwClientState_IsHLTV = 19784
dwClientState_Map = 652
dwClientState_MapDirectory = 392
dwClientState_MaxPlayer = 904
dwClientState_PlayerInfo = 21184
dwClientState_State = 264
dwClientState_ViewAngles = 19856
dwEntityList = 81788796
dwForceAttack = 52616680
dwForceAttack2 = 52616692
dwForceBackward = 52616752
dwForceForward = 52616740
dwForceJump = 86752472
dwForceLeft = 52616608
dwForceRight = 52616620
dwGameDir = 6532480
dwGameRulesProxy = 87225572
dwGetAllClasses = 14729108
dwGlobalVars = 5893728
dwGlowObjectManager = 87403016
dwInput = 86365520
dwInterfaceLinkList = 10073252
dwLocalPlayer = 14592396
dwMouseEnable = 86217136
dwMouseEnablePtr = 86217088
dwPlayerResource = 52609312
dwRadarBase = 86207060
dwSensitivity = 14609320
dwSensitivityPtr = 14609320
dwSetClanTag = 580224
dwViewMatrix = 81726916
dwWeaponTable = 86369836
dwWeaponTableIndex = 12908
dwYawPtr = 14608696
dwZoomSensitivityRatioPtr = 14631848
dwbSendPackets = 905906
dwppDirect3DDevice9 = 680640
find_hud_element = 1488192208
force_update_spectator_glow = 4036986
interface_engine_cvar = 260764
is_c4_owner = 4092320
m_bDormant = 237
m_bIsLocalPlayer = 13864
m_flSpawnTime = 66496
m_pStudioHdr = 10576
m_pitchClassPtr = 86216872
m_yawClassPtr = 14608696
model_ambient_min = 5902740
set_abs_angles = 1997328
set_abs_origin = 1996880

[netvars]
cs_gamerules_data = 0
m_ArmorValue = 71628
m_Collision = 800
m_CollisionGroup = 1140
m_Local = 12236
m_MoveType = 604
m_OriginalOwnerXuidHigh = 12756
m_OriginalOwnerXuidLow = 12752
m_SurvivalGameRuleDecisionTypes = 4904
m_SurvivalRules = 3328
m_aimPunchAngle = 12348
m_aimPunchAngleVel = 12360
m_angEyeAnglesX = 71632
m_angEyeAnglesY = 71636
m_bBombDefused = 10688
m_bBombPlanted = 2469
m_bBombTicking = 10640
m_bFreezePeriod = 32
m_bGunGameImmunity = 39312
m_bHasDefuser = 71644
m_bHasHelmet = 71616
m_bInReload = 12981
m_bIsDefusing = 39292
m_bIsQueuedMatchmaking = 116
m_bIsScoped = 39284
m_bIsValveDS = 124
m_bSpotted = 2365
m_bSpottedByMask = 2432
m_bStartedArming = 13312
m_bUseCustomAutoExposureMax = 2521
m_bUseCustomAutoExposureMin = 2520
m_bUseCustomBloomScale = 2522
m_clrRender = 112
m_dwBoneMatrix = 9896
m_fAccuracyPenalty = 13120
m_fFlags = 260
m_flC4Blow = 10656
m_flCustomAutoExposureMax = 2528
m_flCustomAutoExposureMin = 2524
m_flCustomBloomScale = 2532
m_flDefuseCountDown = 10684
m_flDefuseLength = 10680
m_flFallbackWear = 12768
m_flFlashDuration = 66672
m_flFlashMaxAlpha = 66668
m_flLastBoneSetupTime = 10536
m_flLowerBodyYawTarget = 39644
m_flNextAttack = 11648
m_flNextPrimaryAttack = 12872
m_flSimulationTime = 616
m_flTimerLength = 10660
m_hActiveWeapon = 12040
m_hBombDefuser = 10692
m_hMyWeapons = 11784
m_hObserverTarget = 13212
m_hOwner = 10716
m_hOwnerEntity = 332
m_hViewModel = 13064
m_iAccountID = 12248
m_iClip1 = 12916
m_iCompetitiveRanking = 6788
m_iCompetitiveWins = 7048
m_iCrosshairId = 71736
m_iDefaultFOV = 13116
m_iEntityQuality = 12220
m_iFOV = 12788
m_iFOVStart = 12792
m_iGlowIndex = 66696
m_iHealth = 256
m_iItemDefinitionIndex = 12218
m_iItemIDHigh = 12240
m_iMostRecentModelBoneCounter = 9872
m_iObserverMode = 13192
m_iShotsFired = 66528
m_iState = 12904
m_iTeamNum = 244
m_lifeState = 607
m_nBombSite = 10644
m_nFallbackPaintKit = 12760
m_nFallbackSeed = 12764
m_nFallbackStatTrak = 12772
m_nForceBone = 9868
m_nModelIndex = 600
m_nTickBase = 13376
m_nViewModelIndex = 10704
m_rgflCoordinateFrame = 1092
m_szCustomName = 12364
m_szLastPlaceName = 13764
m_thirdPersonViewAngles = 12776
m_vecOrigin = 312
m_vecVelocity = 276
m_vecViewOffset = 264
m_viewPunchAngle = 12336
m_zoomLevel = 13280

```