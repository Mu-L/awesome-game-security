Project Path: arc_gmh5225_cheat-attack-thread-slemu_rgp01uhf

Source Tree:

```txt
arc_gmh5225_cheat-attack-thread-slemu_rgp01uhf
├── README.md
├── bytes.h
├── emulator.h
├── entry.cpp
├── imports.h
├── process.h
├── slemu.vcxproj
├── slemu.vcxproj.filters
├── slemu.vcxproj.user
├── thread.h
└── utils.h

```

`README.md`:

```md
# slemu
A simple SCP-SL Anti-cheat usermode emulator

https://www.unknowncheats.me/forum/anti-cheat-bypass/507676-scp-sl-anti-cheat-emulator.html#post3481160

```

`bytes.h`:

```h
namespace bytes
{
	unsigned char loop[] =
	{
		0x48, 0x83, 0xEC, 0x28,
		0xB9, 0x64, 0x00, 0x00, 0x00,
		0xFF, 0x15, 0x02, 0x00, 0x00, 0x00, 0xEB, 0x08,
		0xA0, 0xAD, 0x3B, 0x74, 0xFB, 0x7F, 0x00, 0x00,
		0xEB, 0xEE
	};
}
```

`emulator.h`:

```h
namespace emulator
{
	auto emulate( const wchar_t* process_name, const wchar_t* module_name ) -> bool
	{
		const auto process = utils::get_process( process_name );

		if ( !process )
		{
			dbg( "%S not found", process_name );
			return false;
		}
		dbg( "%S: %i", process_name, process->get_id( ) );

		const auto module = process->get_module_entry( module_name );

		if ( !module.modBaseAddr )
		{
			dbg( "%S not found", module_name );
			return false;
		}
		dbg( "%S base: 0x%llx", module_name, module.modBaseAddr );

		for ( auto &thread : process->get_threads( ) )
		{
			const auto win32_start_address = thread->get_win32_start_address( );

			if ( win32_start_address > reinterpret_cast< std::uintptr_t > ( module.modBaseAddr ) + module.modBaseSize ||
				win32_start_address < reinterpret_cast< std::uintptr_t > ( module.modBaseAddr ) )
			{
				continue;
			}
			dbg( "%S thread found 0x%llx", module_name, win32_start_address );

			const auto local_kernel_base = utils::get_module( L"KERNELBASE.dll" );
			const auto local_sleep_ex = reinterpret_cast< std::uintptr_t > ( GetProcAddress( local_kernel_base, "SleepEx" ) );

			const auto remote_kernel_base = process->get_module_entry( L"KERNELBASE.dll" ).modBaseAddr;
			dbg( "%S's kernelbase.dll: 0x%llx", process_name, remote_kernel_base );

			const auto remote_sleep_ex = remote_kernel_base + local_sleep_ex - reinterpret_cast< std::uintptr_t > ( local_kernel_base );

			*reinterpret_cast< void ** >( &bytes::loop[17] ) = remote_sleep_ex;
			dbg( "prepared shellcode [SleepEx: 0x%llx]", remote_sleep_ex );

			const auto shellcode = process->allocate( sizeof( bytes::loop ), PAGE_EXECUTE_READWRITE );
			process->write( shellcode, bytes::loop, sizeof( bytes::loop ) );
			dbg( "shellcode created: 0x%llx", shellcode );

			auto ctx = thread->get_ctx( );
			ctx.Rip = shellcode;

			thread->set_ctx( ctx );
			dbg( "shellcode executed" );

			thread->close( );
			dbg( "thread trapped" );
		}

		process->close( );

		return true;
	}
}
```

`entry.cpp`:

```cpp
#include "imports.h"

auto main( ) -> int
{
	dbg	( "emuation status: %d", emulator::emulate( L"SCPSL.exe", L"SL-AC.dll" ) );

	return std::cin.get( );
}
```

`imports.h`:

```h
#include <windows.h>
#include <tlhelp32.h>
#include <string>
#include <vector>
#include <thread>
#include <iostream>
#include <winternl.h>
#include <windef.h>

#define dbg(content, ...) printf( "[+] " content "\n", __VA_ARGS__)

#include "thread.h"
#include "process.h"
#include "utils.h"
#include "bytes.h"
#include "emulator.h"
```

`process.h`:

```h
class c_process
{
public:

    auto get_id( ) -> std::uint32_t
    {
        return GetProcessId( reinterpret_cast< HANDLE >( this ) );
    }

    auto get_module_entry( const wchar_t* name ) -> MODULEENTRY32
    {
        const auto snapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, this->get_id( ) );

        MODULEENTRY32 module_entry = { 0 };
        module_entry.dwSize = sizeof( module_entry );
       
        Module32First( snapshot, &module_entry );

        do
        {
            if ( wcscmp( module_entry.szModule, name ) )
            {
                continue;
            }

            CloseHandle( snapshot );
            return module_entry;

        } while ( Module32Next( snapshot, &module_entry ) );

        CloseHandle( snapshot );

        return { 0 };
    }

    auto close( ) -> bool
    {
        return CloseHandle( reinterpret_cast< HANDLE >( this ) );
    }

	auto get_threads( ) -> std::vector<c_thread *>
	{
        std::vector<c_thread *> threads;
        threads.clear( );

        THREADENTRY32 thread_entry;
        thread_entry.dwSize = sizeof( thread_entry );

        const auto snapshot = CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, 0 );

        Thread32First( snapshot, &thread_entry );
       
        do
        {
            if ( thread_entry.dwSize < FIELD_OFFSET( THREADENTRY32, th32OwnerProcessID ) + sizeof( thread_entry.th32OwnerProcessID ) || GetProcessId(reinterpret_cast<HANDLE>( this ) ) != thread_entry.th32OwnerProcessID )
            {
                continue;
            }

            threads.push_back( reinterpret_cast< c_thread * > ( OpenThread( THREAD_ALL_ACCESS, 0, thread_entry.th32ThreadID ) ) );

            thread_entry.dwSize = sizeof( thread_entry );
        } while ( Thread32Next( snapshot, &thread_entry ) );

        CloseHandle( snapshot );

        return threads;
	}

    auto write( std::uintptr_t address, void* buffer, std::size_t size ) -> bool
    {
        std::size_t bytes;
        if ( !WriteProcessMemory( reinterpret_cast< HANDLE >( this ), ( void * )address, buffer, size, &bytes ) || bytes != size )
        {
            return false;
        }

        return true;
    }

    auto allocate( const std::size_t size, unsigned long protection ) -> std::uintptr_t
    {
        return reinterpret_cast< std::uintptr_t> ( VirtualAllocEx( reinterpret_cast<HANDLE> ( this ), 0, size, MEM_COMMIT | MEM_RESERVE, protection ) );
    }
};
```

`slemu.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="bytes.h" />
    <ClInclude Include="emulator.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="process.h" />
    <ClInclude Include="thread.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1d563729-318f-4414-8973-6e6216efc458}</ProjectGuid>
    <RootNamespace>emu</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\</OutDir>
    <IntDir>$(SolutionDir)bin\intermediates\</IntDir>
    <TargetName>$(ProjectName)_x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`slemu.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utils.h" />
    <ClInclude Include="process.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="thread.h" />
    <ClInclude Include="bytes.h" />
    <ClInclude Include="emulator.h" />
  </ItemGroup>
</Project>
```

`slemu.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`thread.h`:

```h
class c_thread
{
public:

	auto get_id( ) -> uint32_t
	{
		return GetThreadId( reinterpret_cast< HANDLE >( this ) );
	}

	auto get_ctx( ) -> CONTEXT
	{
		CONTEXT ctx { 0 };
		ctx.ContextFlags = CONTEXT_FULL;
		GetThreadContext( reinterpret_cast< HANDLE >( this ), &ctx );

		return ctx;
	}

	auto close( ) -> bool
	{
		return CloseHandle( reinterpret_cast< HANDLE >( this ) );
	}

	auto set_ctx( CONTEXT ctx ) -> bool
	{
		return SetThreadContext( reinterpret_cast< HANDLE >( this ), &ctx );
	}

	auto get_win32_start_address( ) -> uintptr_t
	{
		uintptr_t win32_start_address;

		NtQueryInformationThread( reinterpret_cast< HANDLE > ( this ), static_cast<THREADINFOCLASS> ( 9 ), &win32_start_address, sizeof( DWORD64 ), 0 );

		return win32_start_address;
	}
};
```

`utils.h`:

```h
namespace utils
{
	auto get_process( const wchar_t *name ) -> c_process *
	{
		PROCESSENTRY32 process_info;
		process_info.dwSize = sizeof( process_info );

		const auto snapshot = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );

		Process32First( snapshot, &process_info );
		do
		{
			if ( wcscmp( process_info.szExeFile, name ) == 0 )
			{
				CloseHandle( snapshot );

				return reinterpret_cast<c_process*>( OpenProcess( PROCESS_ALL_ACCESS, 0, process_info.th32ProcessID ) );
			}
		} while ( Process32Next( snapshot, &process_info ) );

		CloseHandle( snapshot );

		return nullptr;
	}

	auto get_module( const wchar_t* name ) -> HMODULE
	{
		const auto handle = GetModuleHandle( name );

		return ( handle ? handle : LoadLibrary( name ) );
	}
}
```