Project Path: arc_gmh5225_Malicious-code-detection-bugu_vnv2f83x

Source Tree:

```txt
arc_gmh5225_Malicious-code-detection-bugu_vnv2f83x
├── LICENSE
├── Makefile
├── README.md
├── README_zh.md
├── api
│   ├── bugu
│   │   └── service
│   │       └── v1
│   │           ├── bugu.pb.go
│   │           ├── bugu.pb.validate.go
│   │           ├── bugu.proto
│   │           ├── bugu.swagger.json
│   │           ├── bugu_error.pb.go
│   │           ├── bugu_error.pb.validate.go
│   │           ├── bugu_error.proto
│   │           ├── bugu_error.swagger.json
│   │           ├── bugu_error_errors.pb.go
│   │           ├── bugu_file.go
│   │           ├── bugu_file_http.go
│   │           ├── bugu_grpc.pb.go
│   │           ├── bugu_http.pb.go
│   │           └── cpp
│   │               ├── bugu.grpc.pb.cc
│   │               ├── bugu.grpc.pb.h
│   │               ├── bugu.pb.cc
│   │               └── bugu.pb.h
│   ├── detect
│   │   └── service
│   │       └── v1
│   │           ├── cpp
│   │           │   ├── detect.grpc.pb.cc
│   │           │   ├── detect.grpc.pb.h
│   │           │   ├── detect.pb.cc
│   │           │   └── detect.pb.h
│   │           ├── detect.pb.go
│   │           ├── detect.pb.validate.go
│   │           ├── detect.proto
│   │           ├── detect.swagger.json
│   │           └── detect_grpc.pb.go
│   ├── obfusion
│   │   └── service
│   │       └── v1
│   │           ├── bugu_obfusion.pb.go
│   │           ├── bugu_obfusion.pb.validate.go
│   │           ├── bugu_obfusion.proto
│   │           ├── bugu_obfusion.swagger.json
│   │           ├── bugu_obfusion_grpc.pb.go
│   │           └── cpp
│   │               ├── bugu_obfusion.grpc.pb.cc
│   │               ├── bugu_obfusion.grpc.pb.h
│   │               ├── bugu_obfusion.pb.cc
│   │               └── bugu_obfusion.pb.h
│   └── packer
│       └── service
│           └── v1
│               ├── bugu_packer.pb.go
│               ├── bugu_packer.pb.validate.go
│               ├── bugu_packer.proto
│               ├── bugu_packer.swagger.json
│               ├── bugu_packer_grpc.pb.go
│               └── cpp
│                   ├── bugu_packer.grpc.pb.cc
│                   ├── bugu_packer.grpc.pb.h
│                   ├── bugu_packer.pb.cc
│                   └── bugu_packer.pb.h
├── app
│   ├── bugu
│   │   └── service
│   │       ├── Dockerfile
│   │       ├── Makefile
│   │       ├── cmd
│   │       │   └── server
│   │       │       ├── main.go
│   │       │       ├── wire.go
│   │       │       └── wire_gen.go
│   │       ├── configs
│   │       │   ├── config.yaml
│   │       │   └── registry.yaml
│   │       ├── go.mod
│   │       ├── go.sum
│   │       └── internal
│   │           ├── biz
│   │           │   ├── artifact.go
│   │           │   ├── biz.go
│   │           │   ├── file.go
│   │           │   ├── obfusion.go
│   │           │   ├── packer.go
│   │           │   └── user.go
│   │           ├── conf
│   │           │   ├── conf.pb.go
│   │           │   └── conf.proto
│   │           ├── data
│   │           │   ├── artifact.go
│   │           │   ├── data.go
│   │           │   ├── data_test.go
│   │           │   ├── ent
│   │           │   │   ├── artifact
│   │           │   │   │   ├── artifact.go
│   │           │   │   │   └── where.go
│   │           │   │   ├── artifact.go
│   │           │   │   ├── artifact_create.go
│   │           │   │   ├── artifact_delete.go
│   │           │   │   ├── artifact_query.go
│   │           │   │   ├── artifact_update.go
│   │           │   │   ├── client.go
│   │           │   │   ├── config.go
│   │           │   │   ├── context.go
│   │           │   │   ├── ent.go
│   │           │   │   ├── enttest
│   │           │   │   │   └── enttest.go
│   │           │   │   ├── file
│   │           │   │   │   ├── file.go
│   │           │   │   │   └── where.go
│   │           │   │   ├── file.go
│   │           │   │   ├── file_create.go
│   │           │   │   ├── file_delete.go
│   │           │   │   ├── file_query.go
│   │           │   │   ├── file_update.go
│   │           │   │   ├── generate.go
│   │           │   │   ├── hook
│   │           │   │   │   └── hook.go
│   │           │   │   ├── migrate
│   │           │   │   │   ├── migrate.go
│   │           │   │   │   └── schema.go
│   │           │   │   ├── mutation.go
│   │           │   │   ├── predicate
│   │           │   │   │   └── predicate.go
│   │           │   │   ├── runtime
│   │           │   │   │   └── runtime.go
│   │           │   │   ├── runtime.go
│   │           │   │   ├── schema
│   │           │   │   │   ├── artifact.go
│   │           │   │   │   ├── file.go
│   │           │   │   │   └── user.go
│   │           │   │   ├── tx.go
│   │           │   │   ├── user
│   │           │   │   │   ├── user.go
│   │           │   │   │   └── where.go
│   │           │   │   ├── user.go
│   │           │   │   ├── user_create.go
│   │           │   │   ├── user_delete.go
│   │           │   │   ├── user_query.go
│   │           │   │   └── user_update.go
│   │           │   ├── file.go
│   │           │   ├── obfusion.go
│   │           │   ├── packer.go
│   │           │   └── user.go
│   │           ├── pkg
│   │           │   ├── http
│   │           │   │   └── error
│   │           │   │       └── error.go
│   │           │   └── middleware
│   │           │       └── auth
│   │           │           └── auth.go
│   │           ├── server
│   │           │   ├── http.go
│   │           │   └── server.go
│   │           └── service
│   │               ├── artifact.go
│   │               ├── file.go
│   │               ├── service.go
│   │               └── user.go
│   ├── detect
│   │   └── service
│   │       ├── CMakeLists.txt
│   │       ├── Makefile
│   │       ├── configs
│   │       │   └── config.json
│   │       ├── include
│   │       │   └── bugu_dectet
│   │       │       └── bugu_detect.h
│   │       ├── resnet
│   │       │   ├── CMakeLists.txt
│   │       │   ├── include
│   │       │   │   └── resnet
│   │       │   │       └── resnet_18.h
│   │       │   └── src
│   │       │       ├── g_logging.h
│   │       │       └── resnet_18.cc
│   │       └── src
│   │           ├── CMakeLists.txt
│   │           ├── bugu_detect_impl.cc
│   │           ├── bugu_detect_impl.h
│   │           ├── bugu_detect_server.cc
│   │           ├── bugu_detect_server.h
│   │           ├── conf
│   │           │   ├── conf.pb.cc
│   │           │   ├── conf.pb.h
│   │           │   ├── conf.proto
│   │           │   └── config.h
│   │           ├── data
│   │           │   ├── data.cc
│   │           │   └── data.h
│   │           ├── main.cc
│   │           ├── thread
│   │           │   ├── x_thread.cc
│   │           │   └── x_thread.h
│   │           ├── thread_pool
│   │           │   ├── x_task.h
│   │           │   ├── x_thread_pool.cc
│   │           │   └── x_thread_pool.h
│   │           └── utils
│   │               ├── credentials.cc
│   │               ├── credentials.h
│   │               └── interrupt_sleeper.h
│   ├── obfusion
│   │   └── service
│   │       ├── CMakeLists.txt
│   │       ├── Dockerfile
│   │       ├── Makefile
│   │       ├── configs
│   │       │   └── config.json
│   │       ├── include
│   │       │   └── bugu_obfusion
│   │       │       └── bugu_obfusion.h
│   │       ├── src
│   │       │   ├── CMakeLists.txt
│   │       │   ├── bugu_obfusion_impl.cc
│   │       │   ├── bugu_obfusion_impl.h
│   │       │   ├── bugu_obfusion_server.cc
│   │       │   ├── bugu_obfusion_server.h
│   │       │   ├── conf
│   │       │   │   ├── conf.pb.cc
│   │       │   │   ├── conf.pb.h
│   │       │   │   ├── conf.proto
│   │       │   │   └── config.h
│   │       │   ├── data.cc
│   │       │   ├── data.h
│   │       │   ├── main.cc
│   │       │   ├── obfusion_task.cc
│   │       │   ├── obfusion_task.h
│   │       │   ├── thread
│   │       │   │   ├── x_thread.cc
│   │       │   │   └── x_thread.h
│   │       │   ├── thread_pool
│   │       │   │   ├── x_task.h
│   │       │   │   ├── x_thread_pool.cc
│   │       │   │   └── x_thread_pool.h
│   │       │   └── utils
│   │       │       ├── credentials.cc
│   │       │       ├── credentials.h
│   │       │       └── interrupt_sleeper.h
│   │       └── third_party
│   │           └── obfusion
│   └── packer
│       └── service
│           ├── CMakeLists.txt
│           ├── Dockerfile
│           ├── Makefile
│           ├── configs
│           │   └── config.json
│           ├── include
│           │   └── bugu_packer
│           │       └── bugu_packer.h
│           └── src
│               ├── CMakeLists.txt
│               ├── bugu_packer_impl.cc
│               ├── bugu_packer_impl.h
│               ├── bugu_packer_server.cc
│               ├── bugu_packer_server.h
│               ├── conf
│               │   ├── conf.pb.cc
│               │   ├── conf.pb.h
│               │   ├── conf.proto
│               │   └── config.h
│               ├── data.cc
│               ├── data.h
│               ├── main.cc
│               ├── packer_task.cc
│               ├── packer_task.h
│               ├── thread
│               │   ├── x_thread.cc
│               │   └── x_thread.h
│               ├── thread_pool
│               │   ├── x_task.h
│               │   ├── x_thread_pool.cc
│               │   └── x_thread_pool.h
│               └── utils
│                   ├── credentials.cc
│                   ├── credentials.h
│                   └── interrupt_sleeper.h
├── app_makefile
├── cpp_makefile
├── deploy
│   ├── consul
│   │   └── docker-compose.yml
│   └── docker-compose
│       ├── docker-bake.hcl
│       └── docker-compose.yml
├── docs
│   ├── README.md
│   ├── _coverpage.md
│   ├── _navbar.md
│   ├── _sidebar.md
│   ├── api.html
│   ├── index.html
│   └── zh-cn
│       ├── README_zh.md
│       ├── _coverpage.md
│       └── _sidebar.md
├── go.mod
├── go.sum
├── pkg
│   ├── file.go
│   ├── go.mod
│   ├── go.sum
│   └── hash.go
└── third_party
    ├── README.md
    ├── errors
    │   └── errors.proto
    ├── google
    │   ├── api
    │   │   ├── annotations.proto
    │   │   ├── http.proto
    │   │   └── httpbody.proto
    │   └── protobuf
    │       ├── descriptor.proto
    │       ├── empty.proto
    │       └── timestamp.proto
    ├── protoc-gen-openapiv2
    │   └── options
    │       ├── annotations.proto
    │       └── openapiv2.proto
    └── validate
        ├── README.md
        └── validate.proto

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 HominSu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
.PHONY: init
# init env
init:
	go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
	go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
	go install github.com/go-kratos/kratos/cmd/kratos/v2@latest
	go install github.com/go-kratos/kratos/cmd/protoc-gen-go-http/v2@latest
	go install github.com/go-kratos/kratos/cmd/protoc-gen-go-errors/v2@latest
	go install github.com/google/gnostic/cmd/protoc-gen-openapi@v0.6.1

.PHONY: api
# generate api
api:
	find app -mindepth 2 -maxdepth 2 -type d -print | xargs -L 1 bash -c 'cd "$$0" && pwd && $(MAKE) api'

.PHONY: wire
# generate wire
wire:
	find app -mindepth 2 -maxdepth 2 -type d -print | xargs -L 1 bash -c 'cd "$$0" && pwd && $(MAKE) wire'

.PHONY: conf
# generate proto
conf:
	find app -mindepth 2 -maxdepth 2 -type d -print | xargs -L 1 bash -c 'cd "$$0" && pwd && $(MAKE) conf'

.PHONY: generate
# generate generate
generate:
	find app -mindepth 2 -maxdepth 2 -type d -print | xargs -L 1 bash -c 'cd "$$0" && pwd && $(MAKE) generate'

.PHONY: grpc-cpp
# generate grpc-cpp
grpc-cpp:
	find app -mindepth 2 -maxdepth 2 -type d -print | xargs -L 1 bash -c 'cd "$$0" && pwd && $(MAKE) grpc-cpp'

.PHONY: build
# generate build
build:
	find app -mindepth 2 -maxdepth 2 -type d -print | xargs -L 1 bash -c 'cd "$$0" && pwd && $(MAKE) build'

.PHONY: docker
# generate docker
docker:
	find app -mindepth 2 -maxdepth 2 -type d -print | xargs -L 1 bash -c 'cd "$$0" && pwd && $(MAKE) docker'

.PHONY: buildx
# generate buildx
buildx:
	find app -mindepth 2 -maxdepth 2 -type d -print | xargs -L 1 bash -c 'cd "$$0" && pwd && $(MAKE) buildx'
```

`README.md`:

```md
<div id="top"></div>

<!-- PROJECT SHIELDS -->
<p align="center">
<a href="https://github.com/hominsu/bugu/graphs/contributors"><img src="https://img.shields.io/github/contributors/hominsu/bugu.svg?style=for-the-badge" alt="Contributors"></a>
<a href="https://github.com/hominsu/bugu/network/members"><img src="https://img.shields.io/github/forks/hominsu/bugu.svg?style=for-the-badge" alt="Forks"></a>
<a href="https://github.com/hominsu/bugu/stargazers"><img src="https://img.shields.io/github/stars/hominsu/bugu.svg?style=for-the-badge" alt="Stargazers"></a>
<a href="https://github.com/hominsu/bugu/issues"><img src="https://img.shields.io/github/issues/hominsu/bugu.svg?style=for-the-badge" alt="Issues"></a>
<a href="https://github.com/hominsu/bugu/blob/master/LICENSE"><img src="https://img.shields.io/github/license/hominsu/bugu.svg?style=for-the-badge" alt="License"></a>
<a href="https://github.com/hominsu/bugu/actions/workflows/docker-publish.yml"><img src="https://img.shields.io/github/workflow/status/hominsu/bugu/Docker%20Deploy?style=for-the-badge" alt="Deploy"></a>
</p>


<!-- PROJECT LOGO -->
<br/>
<div align="center">
<!--   <a href="https://github.com/hominsu/bugu">
    <img src="images/logo.png" alt="Logo" width="80" height="80">
  </a> -->

<h3 align="center">bugu</h3>

  <p align="center">
    Malicious code detection and complication system
    <br/>
    <a href="https://hominsu.github.io/bugu/"><strong>Explore the docs » (you are here)</strong></a>
    <br/>
    <br/>
    <a href="https://github.com/hominsu/bugu">View Demo</a>
    ·
    <a href="https://github.com/hominsu/bugu/issues">Report Bug</a>
    ·
    <a href="https://github.com/hominsu/bugu/issues">Request Feature</a>
  </p>
</div>

## Description

Kill - free system based on artificial intelligence detection

## Details

```mermaid
flowchart LR
	admin("admin service") <-.-> user("user service")
	bugu("bugu service") <-.-> user
	bugu <-.-> detect("detect service")
	bugu <-.-> packer("packer service")
	bugu <-.-> confusion("confusion service")
	
	subgraph DB
	redis[("redis")]
	userdb[("user db")]
	kafka[("kafka")]
	end
	
	subgraph File
	oss[("oss")]
	metadatadb[("file meta db")]
	end
	
	bugu <-.file.-> oss
	admin <-.file.-> oss
	
	bugu <-.file metadata.-> metadatadb
	admin <-.file metadata.-> metadatadb
	
	user <-.user info.-> userdb
	user <-.user cache.-> redis
	
	bugu -.delay task.-> kafka
	detect <-.delay task.- kafka
	packer <-.delay task.- kafka
	confusion <-.delay task.- kafka
	
	subgraph Other Infrastructure
	consul("Consul")
	sls("Aliyun Log Service")
	end
	
```

```

`README_zh.md`:

```md
<div id="top"></div>

<!-- PROJECT SHIELDS -->
<p align="center">
<a href="https://github.com/hominsu/bugu/graphs/contributors"><img src="https://img.shields.io/github/contributors/hominsu/bugu.svg?style=for-the-badge" alt="Contributors"></a>
<a href="https://github.com/hominsu/bugu/network/members"><img src="https://img.shields.io/github/forks/hominsu/bugu.svg?style=for-the-badge" alt="Forks"></a>
<a href="https://github.com/hominsu/bugu/stargazers"><img src="https://img.shields.io/github/stars/hominsu/bugu.svg?style=for-the-badge" alt="Stargazers"></a>
<a href="https://github.com/hominsu/bugu/issues"><img src="https://img.shields.io/github/issues/hominsu/bugu.svg?style=for-the-badge" alt="Issues"></a>
<a href="https://github.com/hominsu/bugu/blob/master/LICENSE"><img src="https://img.shields.io/github/license/hominsu/bugu.svg?style=for-the-badge" alt="License"></a>
<a href="https://github.com/hominsu/bugu/actions/workflows/docker-publish.yml"><img src="https://img.shields.io/github/workflow/status/hominsu/bugu/Docker%20Deploy?style=for-the-badge" alt="Deploy"></a>
</p>


<!-- PROJECT LOGO -->
<br/>
<div align="center">
<!--   <a href="https://github.com/hominsu/bugu">
    <img src="images/logo.png" alt="Logo" width="80" height="80">
  </a> -->

<h3 align="center">bugu</h3>

  <p align="center">
    恶意代码检测和复杂化系统
    <br/>
    <a href="https://hominsu.github.io/bugu/"><strong>Explore the docs » (you are here)</strong></a>
    <br/>
    <br/>
    <a href="https://github.com/hominsu/bugu">View Demo</a>
    ·
    <a href="https://github.com/hominsu/bugu/issues">Report Bug</a>
    ·
    <a href="https://github.com/hominsu/bugu/issues">Request Feature</a>
  </p>
</div>

## Description

基于人工智能检测的免杀系统

## Details

```mermaid
flowchart LR
	admin("admin service") <-.-> user("user service")
	bugu("bugu service") <-.-> user
	bugu <-.-> detect("detect service")
	bugu <-.-> packer("packer service")
	bugu <-.-> confusion("confusion service")
	
	subgraph DB
	redis[("redis")]
	userdb[("user db")]
	kafka[("kafka")]
	end
	
	subgraph File
	oss[("oss")]
	metadatadb[("file meta db")]
	end
	
	bugu <-.file.-> oss
	admin <-.file.-> oss
	
	bugu <-.file metadata.-> metadatadb
	admin <-.file metadata.-> metadatadb
	
	user <-.user info.-> userdb
	user <-.user cache.-> redis
	
	bugu -.delay task.-> kafka
	detect <-.delay task.- kafka
	packer <-.delay task.- kafka
	confusion <-.delay task.- kafka
	
	subgraph Other Infrastructure
	consul("Consul")
	sls("Aliyun Log Service")
	end
	
```

```

`api/bugu/service/v1/bugu.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: v1/bugu.proto

package v1

import (
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Type int32

const (
	Type_TYPE_ADPOSHEL     Type = 0
	Type_TYPE_AGENT        Type = 1
	Type_TYPE_ALLAPLE      Type = 2
	Type_TYPE_AMONETIZE    Type = 3
	Type_TYPE_ANDROM       Type = 4
	Type_TYPE_AUTORUN      Type = 5
	Type_TYPE_BROWSE_FOX   Type = 6
	Type_TYPE_DINWOD       Type = 7
	Type_TYPE_ELEX         Type = 8
	Type_TYPE_EXPIRO       Type = 9
	Type_TYPE_FASONG       Type = 10
	Type_TYPE_HACK_KMS     Type = 11
	Type_TYPE_HLUX         Type = 12
	Type_TYPE_INJECTOR     Type = 13
	Type_TYPE_INSTALL_CORE Type = 14
	Type_TYPE_MULTI_Plug   Type = 15
	Type_TYPE_NEOREKLAMI   Type = 16
	Type_TYPE_NESHTA       Type = 17
	Type_TYPE_OTHER        Type = 18
	Type_TYPE_REGRUN       Type = 19
	Type_TYPE_SALITY       Type = 20
	Type_TYPE_SNARASITE    Type = 21
	Type_TYPE_STABTINKO    Type = 22
	Type_TYPE_VBA          Type = 23
	Type_TYPE_VBKRYPT      Type = 24
	Type_TYPE_VILSEL       Type = 25
)

// Enum value maps for Type.
var (
	Type_name = map[int32]string{
		0:  "TYPE_ADPOSHEL",
		1:  "TYPE_AGENT",
		2:  "TYPE_ALLAPLE",
		3:  "TYPE_AMONETIZE",
		4:  "TYPE_ANDROM",
		5:  "TYPE_AUTORUN",
		6:  "TYPE_BROWSE_FOX",
		7:  "TYPE_DINWOD",
		8:  "TYPE_ELEX",
		9:  "TYPE_EXPIRO",
		10: "TYPE_FASONG",
		11: "TYPE_HACK_KMS",
		12: "TYPE_HLUX",
		13: "TYPE_INJECTOR",
		14: "TYPE_INSTALL_CORE",
		15: "TYPE_MULTI_Plug",
		16: "TYPE_NEOREKLAMI",
		17: "TYPE_NESHTA",
		18: "TYPE_OTHER",
		19: "TYPE_REGRUN",
		20: "TYPE_SALITY",
		21: "TYPE_SNARASITE",
		22: "TYPE_STABTINKO",
		23: "TYPE_VBA",
		24: "TYPE_VBKRYPT",
		25: "TYPE_VILSEL",
	}
	Type_value = map[string]int32{
		"TYPE_ADPOSHEL":     0,
		"TYPE_AGENT":        1,
		"TYPE_ALLAPLE":      2,
		"TYPE_AMONETIZE":    3,
		"TYPE_ANDROM":       4,
		"TYPE_AUTORUN":      5,
		"TYPE_BROWSE_FOX":   6,
		"TYPE_DINWOD":       7,
		"TYPE_ELEX":         8,
		"TYPE_EXPIRO":       9,
		"TYPE_FASONG":       10,
		"TYPE_HACK_KMS":     11,
		"TYPE_HLUX":         12,
		"TYPE_INJECTOR":     13,
		"TYPE_INSTALL_CORE": 14,
		"TYPE_MULTI_Plug":   15,
		"TYPE_NEOREKLAMI":   16,
		"TYPE_NESHTA":       17,
		"TYPE_OTHER":        18,
		"TYPE_REGRUN":       19,
		"TYPE_SALITY":       20,
		"TYPE_SNARASITE":    21,
		"TYPE_STABTINKO":    22,
		"TYPE_VBA":          23,
		"TYPE_VBKRYPT":      24,
		"TYPE_VILSEL":       25,
	}
)

func (x Type) Enum() *Type {
	p := new(Type)
	*p = x
	return p
}

func (x Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Type) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_bugu_proto_enumTypes[0].Descriptor()
}

func (Type) Type() protoreflect.EnumType {
	return &file_v1_bugu_proto_enumTypes[0]
}

func (x Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Type.Descriptor instead.
func (Type) EnumDescriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{0}
}

type RegisterRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User *RegisterRequest_User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *RegisterRequest) Reset() {
	*x = RegisterRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RegisterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterRequest) ProtoMessage() {}

func (x *RegisterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{0}
}

func (x *RegisterRequest) GetUser() *RegisterRequest_User {
	if x != nil {
		return x.User
	}
	return nil
}

type RegisterReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User *UserStruct `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *RegisterReply) Reset() {
	*x = RegisterReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RegisterReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterReply) ProtoMessage() {}

func (x *RegisterReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterReply.ProtoReflect.Descriptor instead.
func (*RegisterReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{1}
}

func (x *RegisterReply) GetUser() *UserStruct {
	if x != nil {
		return x.User
	}
	return nil
}

type LoginRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User *LoginRequest_User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *LoginRequest) Reset() {
	*x = LoginRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoginRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoginRequest) ProtoMessage() {}

func (x *LoginRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{2}
}

func (x *LoginRequest) GetUser() *LoginRequest_User {
	if x != nil {
		return x.User
	}
	return nil
}

type LoginReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User  *UserStruct `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Token string      `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *LoginReply) Reset() {
	*x = LoginReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoginReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoginReply) ProtoMessage() {}

func (x *LoginReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoginReply.ProtoReflect.Descriptor instead.
func (*LoginReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{3}
}

func (x *LoginReply) GetUser() *UserStruct {
	if x != nil {
		return x.User
	}
	return nil
}

func (x *LoginReply) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type GetCurrentUserRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetCurrentUserRequest) Reset() {
	*x = GetCurrentUserRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetCurrentUserRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCurrentUserRequest) ProtoMessage() {}

func (x *GetCurrentUserRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCurrentUserRequest.ProtoReflect.Descriptor instead.
func (*GetCurrentUserRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{4}
}

func (x *GetCurrentUserRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type GetCurrentUserReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User *UserStruct `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *GetCurrentUserReply) Reset() {
	*x = GetCurrentUserReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetCurrentUserReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCurrentUserReply) ProtoMessage() {}

func (x *GetCurrentUserReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCurrentUserReply.ProtoReflect.Descriptor instead.
func (*GetCurrentUserReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{5}
}

func (x *GetCurrentUserReply) GetUser() *UserStruct {
	if x != nil {
		return x.User
	}
	return nil
}

type UpdateUserRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User *UpdateUserRequest_User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *UpdateUserRequest) Reset() {
	*x = UpdateUserRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UpdateUserRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateUserRequest) ProtoMessage() {}

func (x *UpdateUserRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateUserRequest.ProtoReflect.Descriptor instead.
func (*UpdateUserRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{6}
}

func (x *UpdateUserRequest) GetUser() *UpdateUserRequest_User {
	if x != nil {
		return x.User
	}
	return nil
}

type UpdateUserReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	User *UserStruct `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *UpdateUserReply) Reset() {
	*x = UpdateUserReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UpdateUserReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateUserReply) ProtoMessage() {}

func (x *UpdateUserReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateUserReply.ProtoReflect.Descriptor instead.
func (*UpdateUserReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{7}
}

func (x *UpdateUserReply) GetUser() *UserStruct {
	if x != nil {
		return x.User
	}
	return nil
}

type UserStruct struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Email    string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
}

func (x *UserStruct) Reset() {
	*x = UserStruct{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserStruct) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserStruct) ProtoMessage() {}

func (x *UserStruct) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserStruct.ProtoReflect.Descriptor instead.
func (*UserStruct) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{8}
}

func (x *UserStruct) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *UserStruct) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *UserStruct) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

type GetFileMetaRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
}

func (x *GetFileMetaRequest) Reset() {
	*x = GetFileMetaRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetFileMetaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileMetaRequest) ProtoMessage() {}

func (x *GetFileMetaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileMetaRequest.ProtoReflect.Descriptor instead.
func (*GetFileMetaRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{9}
}

func (x *GetFileMetaRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *GetFileMetaRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

type GetFileMetaReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FileId    string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	FileSha_1 string `protobuf:"bytes,2,opt,name=file_sha_1,json=fileSha1,proto3" json:"file_sha_1,omitempty"`
	FileSize  int64  `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FileAddr  string `protobuf:"bytes,4,opt,name=file_addr,json=fileAddr,proto3" json:"file_addr,omitempty"`
	Type      Type   `protobuf:"varint,5,opt,name=type,proto3,enum=bugu.service.v1.Type" json:"type,omitempty"`
}

func (x *GetFileMetaReply) Reset() {
	*x = GetFileMetaReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetFileMetaReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileMetaReply) ProtoMessage() {}

func (x *GetFileMetaReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileMetaReply.ProtoReflect.Descriptor instead.
func (*GetFileMetaReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{10}
}

func (x *GetFileMetaReply) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

func (x *GetFileMetaReply) GetFileSha_1() string {
	if x != nil {
		return x.FileSha_1
	}
	return ""
}

func (x *GetFileMetaReply) GetFileSize() int64 {
	if x != nil {
		return x.FileSize
	}
	return 0
}

func (x *GetFileMetaReply) GetFileAddr() string {
	if x != nil {
		return x.FileAddr
	}
	return ""
}

func (x *GetFileMetaReply) GetType() Type {
	if x != nil {
		return x.Type
	}
	return Type_TYPE_ADPOSHEL
}

type GetFileMetaByUserIdRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *GetFileMetaByUserIdRequest) Reset() {
	*x = GetFileMetaByUserIdRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetFileMetaByUserIdRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileMetaByUserIdRequest) ProtoMessage() {}

func (x *GetFileMetaByUserIdRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileMetaByUserIdRequest.ProtoReflect.Descriptor instead.
func (*GetFileMetaByUserIdRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{11}
}

func (x *GetFileMetaByUserIdRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

type GetFileMetaByUserIdReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FileMetadata []*GetFileMetaReply `protobuf:"bytes,1,rep,name=file_metadata,json=fileMetadata,proto3" json:"file_metadata,omitempty"`
}

func (x *GetFileMetaByUserIdReply) Reset() {
	*x = GetFileMetaByUserIdReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetFileMetaByUserIdReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileMetaByUserIdReply) ProtoMessage() {}

func (x *GetFileMetaByUserIdReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileMetaByUserIdReply.ProtoReflect.Descriptor instead.
func (*GetFileMetaByUserIdReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{12}
}

func (x *GetFileMetaByUserIdReply) GetFileMetadata() []*GetFileMetaReply {
	if x != nil {
		return x.FileMetadata
	}
	return nil
}

type DeleteFileMetadataRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
}

func (x *DeleteFileMetadataRequest) Reset() {
	*x = DeleteFileMetadataRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DeleteFileMetadataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileMetadataRequest) ProtoMessage() {}

func (x *DeleteFileMetadataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileMetadataRequest.ProtoReflect.Descriptor instead.
func (*DeleteFileMetadataRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{13}
}

func (x *DeleteFileMetadataRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *DeleteFileMetadataRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

type DeleteFileMetadataReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *DeleteFileMetadataReply) Reset() {
	*x = DeleteFileMetadataReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DeleteFileMetadataReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteFileMetadataReply) ProtoMessage() {}

func (x *DeleteFileMetadataReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteFileMetadataReply.ProtoReflect.Descriptor instead.
func (*DeleteFileMetadataReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{14}
}

type DetectRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
}

func (x *DetectRequest) Reset() {
	*x = DetectRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DetectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetectRequest) ProtoMessage() {}

func (x *DetectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetectRequest.ProtoReflect.Descriptor instead.
func (*DetectRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{15}
}

func (x *DetectRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *DetectRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

type DetectReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ArtifactId string `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
}

func (x *DetectReply) Reset() {
	*x = DetectReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DetectReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetectReply) ProtoMessage() {}

func (x *DetectReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetectReply.ProtoReflect.Descriptor instead.
func (*DetectReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{16}
}

func (x *DetectReply) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

type ConfusionRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
}

func (x *ConfusionRequest) Reset() {
	*x = ConfusionRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConfusionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfusionRequest) ProtoMessage() {}

func (x *ConfusionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfusionRequest.ProtoReflect.Descriptor instead.
func (*ConfusionRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{17}
}

func (x *ConfusionRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *ConfusionRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

type ConfusionReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ArtifactId       string `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	FileId           string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	AffiliatedFileId string `protobuf:"bytes,3,opt,name=affiliated_file_id,json=affiliatedFileId,proto3" json:"affiliated_file_id,omitempty"`
	Method           string `protobuf:"bytes,4,opt,name=method,proto3" json:"method,omitempty"`
}

func (x *ConfusionReply) Reset() {
	*x = ConfusionReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConfusionReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfusionReply) ProtoMessage() {}

func (x *ConfusionReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfusionReply.ProtoReflect.Descriptor instead.
func (*ConfusionReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{18}
}

func (x *ConfusionReply) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *ConfusionReply) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

func (x *ConfusionReply) GetAffiliatedFileId() string {
	if x != nil {
		return x.AffiliatedFileId
	}
	return ""
}

func (x *ConfusionReply) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

type PackerRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
}

func (x *PackerRequest) Reset() {
	*x = PackerRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PackerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackerRequest) ProtoMessage() {}

func (x *PackerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackerRequest.ProtoReflect.Descriptor instead.
func (*PackerRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{19}
}

func (x *PackerRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *PackerRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

type PackerReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ArtifactId       string `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	FileId           string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	AffiliatedFileId string `protobuf:"bytes,3,opt,name=affiliated_file_id,json=affiliatedFileId,proto3" json:"affiliated_file_id,omitempty"`
	Method           string `protobuf:"bytes,4,opt,name=method,proto3" json:"method,omitempty"`
}

func (x *PackerReply) Reset() {
	*x = PackerReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PackerReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackerReply) ProtoMessage() {}

func (x *PackerReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackerReply.ProtoReflect.Descriptor instead.
func (*PackerReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{20}
}

func (x *PackerReply) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *PackerReply) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

func (x *PackerReply) GetAffiliatedFileId() string {
	if x != nil {
		return x.AffiliatedFileId
	}
	return ""
}

func (x *PackerReply) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

type GetArtifactMetadataRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId     string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ArtifactId string `protobuf:"bytes,2,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
}

func (x *GetArtifactMetadataRequest) Reset() {
	*x = GetArtifactMetadataRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetArtifactMetadataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetArtifactMetadataRequest) ProtoMessage() {}

func (x *GetArtifactMetadataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetArtifactMetadataRequest.ProtoReflect.Descriptor instead.
func (*GetArtifactMetadataRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{21}
}

func (x *GetArtifactMetadataRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *GetArtifactMetadataRequest) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

type GetArtifactMetadataReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ArtifactId       string `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	FileId           string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	AffiliatedFileId string `protobuf:"bytes,3,opt,name=affiliated_file_id,json=affiliatedFileId,proto3" json:"affiliated_file_id,omitempty"`
	Method           string `protobuf:"bytes,4,opt,name=method,proto3" json:"method,omitempty"`
}

func (x *GetArtifactMetadataReply) Reset() {
	*x = GetArtifactMetadataReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetArtifactMetadataReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetArtifactMetadataReply) ProtoMessage() {}

func (x *GetArtifactMetadataReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetArtifactMetadataReply.ProtoReflect.Descriptor instead.
func (*GetArtifactMetadataReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{22}
}

func (x *GetArtifactMetadataReply) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *GetArtifactMetadataReply) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

func (x *GetArtifactMetadataReply) GetAffiliatedFileId() string {
	if x != nil {
		return x.AffiliatedFileId
	}
	return ""
}

func (x *GetArtifactMetadataReply) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

type GetArtifactMetadataByFileIdRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FileId string `protobuf:"bytes,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
}

func (x *GetArtifactMetadataByFileIdRequest) Reset() {
	*x = GetArtifactMetadataByFileIdRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetArtifactMetadataByFileIdRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetArtifactMetadataByFileIdRequest) ProtoMessage() {}

func (x *GetArtifactMetadataByFileIdRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetArtifactMetadataByFileIdRequest.ProtoReflect.Descriptor instead.
func (*GetArtifactMetadataByFileIdRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{23}
}

func (x *GetArtifactMetadataByFileIdRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *GetArtifactMetadataByFileIdRequest) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

type GetArtifactMetadataByFileIdReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ArtifactMetadata []*GetArtifactMetadataReply `protobuf:"bytes,1,rep,name=artifact_metadata,json=artifactMetadata,proto3" json:"artifact_metadata,omitempty"`
}

func (x *GetArtifactMetadataByFileIdReply) Reset() {
	*x = GetArtifactMetadataByFileIdReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetArtifactMetadataByFileIdReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetArtifactMetadataByFileIdReply) ProtoMessage() {}

func (x *GetArtifactMetadataByFileIdReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetArtifactMetadataByFileIdReply.ProtoReflect.Descriptor instead.
func (*GetArtifactMetadataByFileIdReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{24}
}

func (x *GetArtifactMetadataByFileIdReply) GetArtifactMetadata() []*GetArtifactMetadataReply {
	if x != nil {
		return x.ArtifactMetadata
	}
	return nil
}

type DeleteArtifactMetadataRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId     string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ArtifactId string `protobuf:"bytes,2,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
}

func (x *DeleteArtifactMetadataRequest) Reset() {
	*x = DeleteArtifactMetadataRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DeleteArtifactMetadataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteArtifactMetadataRequest) ProtoMessage() {}

func (x *DeleteArtifactMetadataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteArtifactMetadataRequest.ProtoReflect.Descriptor instead.
func (*DeleteArtifactMetadataRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{25}
}

func (x *DeleteArtifactMetadataRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *DeleteArtifactMetadataRequest) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

type DeleteArtifactMetadataReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *DeleteArtifactMetadataReply) Reset() {
	*x = DeleteArtifactMetadataReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DeleteArtifactMetadataReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteArtifactMetadataReply) ProtoMessage() {}

func (x *DeleteArtifactMetadataReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteArtifactMetadataReply.ProtoReflect.Descriptor instead.
func (*DeleteArtifactMetadataReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{26}
}

type RegisterRequest_User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Email    string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *RegisterRequest_User) Reset() {
	*x = RegisterRequest_User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RegisterRequest_User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterRequest_User) ProtoMessage() {}

func (x *RegisterRequest_User) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterRequest_User.ProtoReflect.Descriptor instead.
func (*RegisterRequest_User) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{0, 0}
}

func (x *RegisterRequest_User) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *RegisterRequest_User) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *RegisterRequest_User) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type LoginRequest_User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *LoginRequest_User) Reset() {
	*x = LoginRequest_User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LoginRequest_User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoginRequest_User) ProtoMessage() {}

func (x *LoginRequest_User) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoginRequest_User.ProtoReflect.Descriptor instead.
func (*LoginRequest_User) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{2, 0}
}

func (x *LoginRequest_User) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *LoginRequest_User) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type UpdateUserRequest_User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Email    string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	Username string `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *UpdateUserRequest_User) Reset() {
	*x = UpdateUserRequest_User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UpdateUserRequest_User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateUserRequest_User) ProtoMessage() {}

func (x *UpdateUserRequest_User) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateUserRequest_User.ProtoReflect.Descriptor instead.
func (*UpdateUserRequest_User) Descriptor() ([]byte, []int) {
	return file_v1_bugu_proto_rawDescGZIP(), []int{6, 0}
}

func (x *UpdateUserRequest_User) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *UpdateUserRequest_User) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *UpdateUserRequest_User) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *UpdateUserRequest_User) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

var File_v1_bugu_proto protoreflect.FileDescriptor

var file_v1_bugu_proto_rawDesc = []byte{
	0x0a, 0x0d, 0x76, 0x31, 0x2f, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x0f, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31,
	0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x61, 0x6e, 0x6e,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61,
	0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x61, 0x6e, 0x6e,
	0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17,
	0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xa2, 0x01, 0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69,
	0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a, 0x04, 0x75,
	0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x62, 0x75, 0x67, 0x75,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69,
	0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x55, 0x73, 0x65, 0x72,
	0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x1a, 0x54, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1a,
	0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d,
	0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c,
	0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x40, 0x0a, 0x0d,
	0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x2f, 0x0a,
	0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x75,
	0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73,
	0x65, 0x72, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0x80,
	0x01, 0x0a, 0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x36, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e,
	0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x55, 0x73, 0x65,
	0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x1a, 0x38, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12,
	0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
	0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x22, 0x53, 0x0a, 0x0a, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12,
	0x2f, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e,
	0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72,
	0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x31, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x18, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05,
	0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x02, 0x69, 0x64, 0x22, 0x46, 0x0a, 0x13, 0x47, 0x65, 0x74,
	0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x12, 0x2f, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b,
	0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x52, 0x04, 0x75, 0x73, 0x65,
	0x72, 0x22, 0xb6, 0x01, 0x0a, 0x11, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x3b, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73,
	0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04,
	0x75, 0x73, 0x65, 0x72, 0x1a, 0x64, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05,
	0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61,
	0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a,
	0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x42, 0x0a, 0x0f, 0x55, 0x70,
	0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x2f, 0x0a,
	0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x62, 0x75,
	0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73,
	0x65, 0x72, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0x58,
	0x0a, 0x0a, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x12, 0x18, 0x0a, 0x02,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0,
	0x01, 0x01, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08,
	0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
	0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x5a, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x46,
	0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x21,
	0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49,
	0x64, 0x12, 0x21, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x66, 0x69,
	0x6c, 0x65, 0x49, 0x64, 0x22, 0xb8, 0x01, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65,
	0x4d, 0x65, 0x74, 0x61, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x21, 0x0a, 0x07, 0x66, 0x69, 0x6c,
	0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72,
	0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x0a,
	0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x68, 0x61, 0x5f, 0x31, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x68, 0x61, 0x31, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69,
	0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x66,
	0x69, 0x6c, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f,
	0x61, 0x64, 0x64, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65,
	0x41, 0x64, 0x64, 0x72, 0x12, 0x29, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x15, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x22,
	0x3f, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x42, 0x79,
	0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x21, 0x0a,
	0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08,
	0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64,
	0x22, 0x62, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x42,
	0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x46, 0x0a, 0x0d,
	0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74,
	0x61, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x52, 0x0c, 0x66, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x22, 0x61, 0x0a, 0x19, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x46, 0x69,
	0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x21, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x75, 0x73,
	0x65, 0x72, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52,
	0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x22, 0x19, 0x0a, 0x17, 0x44, 0x65, 0x6c, 0x65, 0x74,
	0x65, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x70,
	0x6c, 0x79, 0x22, 0x55, 0x0a, 0x0d, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06,
	0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01,
	0x01, 0x52, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x22, 0x38, 0x0a, 0x0b, 0x44, 0x65, 0x74,
	0x65, 0x63, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x29, 0x0a, 0x0b, 0x61, 0x72, 0x74, 0x69,
	0x66, 0x61, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa,
	0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x0a, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63,
	0x74, 0x49, 0x64, 0x22, 0x58, 0x0a, 0x10, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0,
	0x01, 0x01, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x07, 0x66, 0x69,
	0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05,
	0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x22, 0xae, 0x01,
	0x0a, 0x0e, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x12, 0x29, 0x0a, 0x0b, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52,
	0x0a, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x07, 0x66,
	0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42,
	0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x36,
	0x0a, 0x12, 0x61, 0x66, 0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x69, 0x6c,
	0x65, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72,
	0x03, 0xb0, 0x01, 0x01, 0x52, 0x10, 0x61, 0x66, 0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65, 0x64,
	0x46, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x22, 0x55,
	0x0a, 0x0d, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x21, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72,
	0x49, 0x64, 0x12, 0x21, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x66,
	0x69, 0x6c, 0x65, 0x49, 0x64, 0x22, 0xab, 0x01, 0x0a, 0x0b, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x72,
	0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x29, 0x0a, 0x0b, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63,
	0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72,
	0x03, 0xb0, 0x01, 0x01, 0x52, 0x0a, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x49, 0x64,
	0x12, 0x21, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x66, 0x69, 0x6c,
	0x65, 0x49, 0x64, 0x12, 0x36, 0x0a, 0x12, 0x61, 0x66, 0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65,
	0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x10, 0x61, 0x66, 0x66, 0x69, 0x6c,
	0x69, 0x61, 0x74, 0x65, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x6d,
	0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x65, 0x74,
	0x68, 0x6f, 0x64, 0x22, 0x6a, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61,
	0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x21, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x75, 0x73,
	0x65, 0x72, 0x49, 0x64, 0x12, 0x29, 0x0a, 0x0b, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74,
	0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03,
	0xb0, 0x01, 0x01, 0x52, 0x0a, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x49, 0x64, 0x22,
	0xb8, 0x01, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x4d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x29, 0x0a, 0x0b,
	0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x0a, 0x61, 0x72, 0x74,
	0x69, 0x66, 0x61, 0x63, 0x74, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x5f,
	0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0,
	0x01, 0x01, 0x52, 0x06, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x36, 0x0a, 0x12, 0x61, 0x66,
	0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01,
	0x52, 0x10, 0x61, 0x66, 0x66, 0x69, 0x6c, 0x69, 0x61, 0x74, 0x65, 0x64, 0x46, 0x69, 0x6c, 0x65,
	0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x22, 0x6a, 0x0a, 0x22, 0x47, 0x65,
	0x74, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
	0x61, 0x42, 0x79, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x12, 0x21, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06, 0x75, 0x73, 0x65,
	0x72, 0x49, 0x64, 0x12, 0x21, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06,
	0x66, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x22, 0x7a, 0x0a, 0x20, 0x47, 0x65, 0x74, 0x41, 0x72, 0x74,
	0x69, 0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x42, 0x79, 0x46,
	0x69, 0x6c, 0x65, 0x49, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x56, 0x0a, 0x11, 0x61, 0x72,
	0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x5f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x41, 0x72, 0x74, 0x69, 0x66,
	0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x52, 0x10, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0x22, 0x6d, 0x0a, 0x1d, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x41, 0x72, 0x74, 0x69,
	0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05, 0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x06,
	0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x29, 0x0a, 0x0b, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61,
	0x63, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x08, 0xfa, 0x42, 0x05,
	0x72, 0x03, 0xb0, 0x01, 0x01, 0x52, 0x0a, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x49,
	0x64, 0x22, 0x1d, 0x0a, 0x1b, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x41, 0x72, 0x74, 0x69, 0x66,
	0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x2a, 0xdb, 0x03, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x11, 0x0a, 0x0d, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x41, 0x44, 0x50, 0x4f, 0x53, 0x48, 0x45, 0x4c, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x47, 0x45, 0x4e, 0x54, 0x10, 0x01, 0x12, 0x10, 0x0a, 0x0c,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x4c, 0x4c, 0x41, 0x50, 0x4c, 0x45, 0x10, 0x02, 0x12, 0x12,
	0x0a, 0x0e, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x4d, 0x4f, 0x4e, 0x45, 0x54, 0x49, 0x5a, 0x45,
	0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x4e, 0x44, 0x52, 0x4f,
	0x4d, 0x10, 0x04, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x55, 0x54, 0x4f,
	0x52, 0x55, 0x4e, 0x10, 0x05, 0x12, 0x13, 0x0a, 0x0f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x42, 0x52,
	0x4f, 0x57, 0x53, 0x45, 0x5f, 0x46, 0x4f, 0x58, 0x10, 0x06, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x44, 0x49, 0x4e, 0x57, 0x4f, 0x44, 0x10, 0x07, 0x12, 0x0d, 0x0a, 0x09, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x45, 0x4c, 0x45, 0x58, 0x10, 0x08, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x45, 0x58, 0x50, 0x49, 0x52, 0x4f, 0x10, 0x09, 0x12, 0x0f, 0x0a, 0x0b, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x46, 0x41, 0x53, 0x4f, 0x4e, 0x47, 0x10, 0x0a, 0x12, 0x11, 0x0a, 0x0d,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x48, 0x41, 0x43, 0x4b, 0x5f, 0x4b, 0x4d, 0x53, 0x10, 0x0b, 0x12,
	0x0d, 0x0a, 0x09, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x48, 0x4c, 0x55, 0x58, 0x10, 0x0c, 0x12, 0x11,
	0x0a, 0x0d, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x4a, 0x45, 0x43, 0x54, 0x4f, 0x52, 0x10,
	0x0d, 0x12, 0x15, 0x0a, 0x11, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x54, 0x41, 0x4c,
	0x4c, 0x5f, 0x43, 0x4f, 0x52, 0x45, 0x10, 0x0e, 0x12, 0x13, 0x0a, 0x0f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x4d, 0x55, 0x4c, 0x54, 0x49, 0x5f, 0x50, 0x6c, 0x75, 0x67, 0x10, 0x0f, 0x12, 0x13, 0x0a,
	0x0f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4e, 0x45, 0x4f, 0x52, 0x45, 0x4b, 0x4c, 0x41, 0x4d, 0x49,
	0x10, 0x10, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4e, 0x45, 0x53, 0x48, 0x54,
	0x41, 0x10, 0x11, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x54, 0x48, 0x45,
	0x52, 0x10, 0x12, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45, 0x47, 0x52,
	0x55, 0x4e, 0x10, 0x13, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x41, 0x4c,
	0x49, 0x54, 0x59, 0x10, 0x14, 0x12, 0x12, 0x0a, 0x0e, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x4e,
	0x41, 0x52, 0x41, 0x53, 0x49, 0x54, 0x45, 0x10, 0x15, 0x12, 0x12, 0x0a, 0x0e, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x53, 0x54, 0x41, 0x42, 0x54, 0x49, 0x4e, 0x4b, 0x4f, 0x10, 0x16, 0x12, 0x0c, 0x0a,
	0x08, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x42, 0x41, 0x10, 0x17, 0x12, 0x10, 0x0a, 0x0c, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x56, 0x42, 0x4b, 0x52, 0x59, 0x50, 0x54, 0x10, 0x18, 0x12, 0x0f, 0x0a,
	0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x49, 0x4c, 0x53, 0x45, 0x4c, 0x10, 0x19, 0x32, 0xd9,
	0x0e, 0x0a, 0x04, 0x42, 0x75, 0x67, 0x75, 0x12, 0x62, 0x0a, 0x08, 0x52, 0x65, 0x67, 0x69, 0x73,
	0x74, 0x65, 0x72, 0x12, 0x20, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
	0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x14, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0e, 0x22, 0x09, 0x2f,
	0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x73, 0x3a, 0x01, 0x2a, 0x12, 0x5f, 0x0a, 0x05, 0x4c,
	0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1d, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x22, 0x1a, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x14, 0x22, 0x0f, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73,
	0x65, 0x72, 0x73, 0x2f, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x3a, 0x01, 0x2a, 0x12, 0x75, 0x0a, 0x0e,
	0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x55, 0x73, 0x65, 0x72, 0x12, 0x26,
	0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72,
	0x65, 0x6e, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x15, 0x82, 0xd3,
	0xe4, 0x93, 0x02, 0x0f, 0x12, 0x0d, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b,
	0x69, 0x64, 0x7d, 0x12, 0x68, 0x0a, 0x0a, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65,
	0x72, 0x12, 0x22, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73,
	0x65, 0x72, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x14, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0e, 0x1a,
	0x09, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x73, 0x3a, 0x01, 0x2a, 0x12, 0x89, 0x01,
	0x0a, 0x0b, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x23, 0x2e,
	0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x21, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61,
	0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x32, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x2c, 0x12, 0x2a, 0x2f,
	0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64,
	0x7d, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x7b, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x7d,
	0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x8f, 0x01, 0x0a, 0x13, 0x47, 0x65,
	0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72, 0x49,
	0x64, 0x12, 0x2b, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x42,
	0x79, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x29,
	0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x42, 0x79, 0x55, 0x73,
	0x65, 0x72, 0x49, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x20, 0x82, 0xd3, 0xe4, 0x93, 0x02,
	0x1a, 0x12, 0x18, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x75, 0x73, 0x65,
	0x72, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x9e, 0x01, 0x0a, 0x12,
	0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0x12, 0x2a, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x4d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x28,
	0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64,
	0x61, 0x74, 0x61, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x32, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x2c,
	0x2a, 0x2a, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x75, 0x73, 0x65, 0x72,
	0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x7b, 0x66, 0x69, 0x6c, 0x65, 0x5f,
	0x69, 0x64, 0x7d, 0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x93, 0x01, 0x0a,
	0x06, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x12, 0x1e, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74,
	0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x4b, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x45, 0x12, 0x28, 0x2f,
	0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64,
	0x7d, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x7b, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x7d,
	0x2f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x5a, 0x19, 0x22, 0x14, 0x2f, 0x76, 0x31, 0x2f, 0x75,
	0x73, 0x65, 0x72, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x3a,
	0x01, 0x2a, 0x12, 0xa2, 0x01, 0x0a, 0x09, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e,
	0x12, 0x21, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x52,
	0x65, 0x70, 0x6c, 0x79, 0x22, 0x51, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x4b, 0x12, 0x2b, 0x2f, 0x76,
	0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x7d,
	0x2f, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x7b, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f,
	0x63, 0x6f, 0x6e, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x5a, 0x1c, 0x22, 0x17, 0x2f, 0x76, 0x31,
	0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x75,
	0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x01, 0x2a, 0x12, 0x93, 0x01, 0x0a, 0x06, 0x50, 0x61, 0x63, 0x6b,
	0x65, 0x72, 0x12, 0x1e, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x22, 0x4b, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x45, 0x12, 0x28, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73,
	0x65, 0x72, 0x2f, 0x7b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x66, 0x69, 0x6c,
	0x65, 0x2f, 0x7b, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x70, 0x61, 0x63, 0x6b,
	0x65, 0x72, 0x5a, 0x19, 0x22, 0x14, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x66,
	0x69, 0x6c, 0x65, 0x2f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x3a, 0x01, 0x2a, 0x12, 0xa9, 0x01,
	0x0a, 0x13, 0x47, 0x65, 0x74, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74,
	0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x2b, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x41, 0x72, 0x74, 0x69, 0x66,
	0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x29, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74,
	0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x3a, 0x82,
	0xd3, 0xe4, 0x93, 0x02, 0x34, 0x12, 0x32, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f,
	0x7b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61,
	0x63, 0x74, 0x2f, 0x7b, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x7d,
	0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0xb9, 0x01, 0x0a, 0x1b, 0x47, 0x65,
	0x74, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
	0x61, 0x42, 0x79, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x33, 0x2e, 0x62, 0x75, 0x67, 0x75,
	0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x41,
	0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x42,
	0x79, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x31,
	0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31,
	0x2e, 0x47, 0x65, 0x74, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x42, 0x79, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x64, 0x52, 0x65, 0x70, 0x6c,
	0x79, 0x22, 0x32, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x2c, 0x12, 0x2a, 0x2f, 0x76, 0x31, 0x2f, 0x75,
	0x73, 0x65, 0x72, 0x2f, 0x7b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x61, 0x72,
	0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x7b, 0x66, 0x69, 0x6c,
	0x65, 0x5f, 0x69, 0x64, 0x7d, 0x12, 0xb2, 0x01, 0x0a, 0x16, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
	0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
	0x12, 0x2e, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63,
	0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x2c, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63,
	0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x3a,
	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x34, 0x2a, 0x32, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72,
	0x2f, 0x7b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x61, 0x72, 0x74, 0x69, 0x66,
	0x61, 0x63, 0x74, 0x2f, 0x7b, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x5f, 0x69, 0x64,
	0x7d, 0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x42, 0xb4, 0x01, 0x5a, 0x2e, 0x67,
	0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x73,
	0x75, 0x2f, 0x62, 0x75, 0x67, 0x75, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x75, 0x67, 0x75, 0x2f,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x76, 0x31, 0x92, 0x41, 0x80,
	0x01, 0x12, 0x57, 0x0a, 0x0a, 0x45, 0x2d, 0x43, 0x6f, 0x64, 0x65, 0x20, 0x41, 0x50, 0x49, 0x22,
	0x44, 0x0a, 0x0c, 0x42, 0x75, 0x67, 0x75, 0x20, 0x42, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x12,
	0x1f, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
	0x63, 0x6f, 0x6d, 0x2f, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x73, 0x75, 0x2f, 0x62, 0x75, 0x67, 0x75,
	0x1a, 0x13, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x73, 0x75, 0x40, 0x66, 0x6f, 0x78, 0x6d, 0x61, 0x69,
	0x6c, 0x2e, 0x63, 0x6f, 0x6d, 0x32, 0x03, 0x31, 0x2e, 0x30, 0x2a, 0x01, 0x02, 0x32, 0x10, 0x61,
	0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x6a, 0x73, 0x6f, 0x6e, 0x3a,
	0x10, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x6a, 0x73, 0x6f,
	0x6e, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_v1_bugu_proto_rawDescOnce sync.Once
	file_v1_bugu_proto_rawDescData = file_v1_bugu_proto_rawDesc
)

func file_v1_bugu_proto_rawDescGZIP() []byte {
	file_v1_bugu_proto_rawDescOnce.Do(func() {
		file_v1_bugu_proto_rawDescData = protoimpl.X.CompressGZIP(file_v1_bugu_proto_rawDescData)
	})
	return file_v1_bugu_proto_rawDescData
}

var file_v1_bugu_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_v1_bugu_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_v1_bugu_proto_goTypes = []interface{}{
	(Type)(0),                                  // 0: bugu.service.v1.Type
	(*RegisterRequest)(nil),                    // 1: bugu.service.v1.RegisterRequest
	(*RegisterReply)(nil),                      // 2: bugu.service.v1.RegisterReply
	(*LoginRequest)(nil),                       // 3: bugu.service.v1.LoginRequest
	(*LoginReply)(nil),                         // 4: bugu.service.v1.LoginReply
	(*GetCurrentUserRequest)(nil),              // 5: bugu.service.v1.GetCurrentUserRequest
	(*GetCurrentUserReply)(nil),                // 6: bugu.service.v1.GetCurrentUserReply
	(*UpdateUserRequest)(nil),                  // 7: bugu.service.v1.UpdateUserRequest
	(*UpdateUserReply)(nil),                    // 8: bugu.service.v1.UpdateUserReply
	(*UserStruct)(nil),                         // 9: bugu.service.v1.UserStruct
	(*GetFileMetaRequest)(nil),                 // 10: bugu.service.v1.GetFileMetaRequest
	(*GetFileMetaReply)(nil),                   // 11: bugu.service.v1.GetFileMetaReply
	(*GetFileMetaByUserIdRequest)(nil),         // 12: bugu.service.v1.GetFileMetaByUserIdRequest
	(*GetFileMetaByUserIdReply)(nil),           // 13: bugu.service.v1.GetFileMetaByUserIdReply
	(*DeleteFileMetadataRequest)(nil),          // 14: bugu.service.v1.DeleteFileMetadataRequest
	(*DeleteFileMetadataReply)(nil),            // 15: bugu.service.v1.DeleteFileMetadataReply
	(*DetectRequest)(nil),                      // 16: bugu.service.v1.DetectRequest
	(*DetectReply)(nil),                        // 17: bugu.service.v1.DetectReply
	(*ConfusionRequest)(nil),                   // 18: bugu.service.v1.ConfusionRequest
	(*ConfusionReply)(nil),                     // 19: bugu.service.v1.ConfusionReply
	(*PackerRequest)(nil),                      // 20: bugu.service.v1.PackerRequest
	(*PackerReply)(nil),                        // 21: bugu.service.v1.PackerReply
	(*GetArtifactMetadataRequest)(nil),         // 22: bugu.service.v1.GetArtifactMetadataRequest
	(*GetArtifactMetadataReply)(nil),           // 23: bugu.service.v1.GetArtifactMetadataReply
	(*GetArtifactMetadataByFileIdRequest)(nil), // 24: bugu.service.v1.GetArtifactMetadataByFileIdRequest
	(*GetArtifactMetadataByFileIdReply)(nil),   // 25: bugu.service.v1.GetArtifactMetadataByFileIdReply
	(*DeleteArtifactMetadataRequest)(nil),      // 26: bugu.service.v1.DeleteArtifactMetadataRequest
	(*DeleteArtifactMetadataReply)(nil),        // 27: bugu.service.v1.DeleteArtifactMetadataReply
	(*RegisterRequest_User)(nil),               // 28: bugu.service.v1.RegisterRequest.User
	(*LoginRequest_User)(nil),                  // 29: bugu.service.v1.LoginRequest.User
	(*UpdateUserRequest_User)(nil),             // 30: bugu.service.v1.UpdateUserRequest.User
}
var file_v1_bugu_proto_depIdxs = []int32{
	28, // 0: bugu.service.v1.RegisterRequest.user:type_name -> bugu.service.v1.RegisterRequest.User
	9,  // 1: bugu.service.v1.RegisterReply.user:type_name -> bugu.service.v1.UserStruct
	29, // 2: bugu.service.v1.LoginRequest.user:type_name -> bugu.service.v1.LoginRequest.User
	9,  // 3: bugu.service.v1.LoginReply.user:type_name -> bugu.service.v1.UserStruct
	9,  // 4: bugu.service.v1.GetCurrentUserReply.user:type_name -> bugu.service.v1.UserStruct
	30, // 5: bugu.service.v1.UpdateUserRequest.user:type_name -> bugu.service.v1.UpdateUserRequest.User
	9,  // 6: bugu.service.v1.UpdateUserReply.user:type_name -> bugu.service.v1.UserStruct
	0,  // 7: bugu.service.v1.GetFileMetaReply.type:type_name -> bugu.service.v1.Type
	11, // 8: bugu.service.v1.GetFileMetaByUserIdReply.file_metadata:type_name -> bugu.service.v1.GetFileMetaReply
	23, // 9: bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata:type_name -> bugu.service.v1.GetArtifactMetadataReply
	1,  // 10: bugu.service.v1.Bugu.Register:input_type -> bugu.service.v1.RegisterRequest
	3,  // 11: bugu.service.v1.Bugu.Login:input_type -> bugu.service.v1.LoginRequest
	5,  // 12: bugu.service.v1.Bugu.GetCurrentUser:input_type -> bugu.service.v1.GetCurrentUserRequest
	7,  // 13: bugu.service.v1.Bugu.UpdateUser:input_type -> bugu.service.v1.UpdateUserRequest
	10, // 14: bugu.service.v1.Bugu.GetFileMeta:input_type -> bugu.service.v1.GetFileMetaRequest
	12, // 15: bugu.service.v1.Bugu.GetFileMetaByUserId:input_type -> bugu.service.v1.GetFileMetaByUserIdRequest
	14, // 16: bugu.service.v1.Bugu.DeleteFileMetadata:input_type -> bugu.service.v1.DeleteFileMetadataRequest
	16, // 17: bugu.service.v1.Bugu.Detect:input_type -> bugu.service.v1.DetectRequest
	18, // 18: bugu.service.v1.Bugu.Confusion:input_type -> bugu.service.v1.ConfusionRequest
	20, // 19: bugu.service.v1.Bugu.Packer:input_type -> bugu.service.v1.PackerRequest
	22, // 20: bugu.service.v1.Bugu.GetArtifactMetadata:input_type -> bugu.service.v1.GetArtifactMetadataRequest
	24, // 21: bugu.service.v1.Bugu.GetArtifactMetadataByFileId:input_type -> bugu.service.v1.GetArtifactMetadataByFileIdRequest
	26, // 22: bugu.service.v1.Bugu.DeleteArtifactMetadata:input_type -> bugu.service.v1.DeleteArtifactMetadataRequest
	2,  // 23: bugu.service.v1.Bugu.Register:output_type -> bugu.service.v1.RegisterReply
	4,  // 24: bugu.service.v1.Bugu.Login:output_type -> bugu.service.v1.LoginReply
	6,  // 25: bugu.service.v1.Bugu.GetCurrentUser:output_type -> bugu.service.v1.GetCurrentUserReply
	8,  // 26: bugu.service.v1.Bugu.UpdateUser:output_type -> bugu.service.v1.UpdateUserReply
	11, // 27: bugu.service.v1.Bugu.GetFileMeta:output_type -> bugu.service.v1.GetFileMetaReply
	13, // 28: bugu.service.v1.Bugu.GetFileMetaByUserId:output_type -> bugu.service.v1.GetFileMetaByUserIdReply
	15, // 29: bugu.service.v1.Bugu.DeleteFileMetadata:output_type -> bugu.service.v1.DeleteFileMetadataReply
	17, // 30: bugu.service.v1.Bugu.Detect:output_type -> bugu.service.v1.DetectReply
	19, // 31: bugu.service.v1.Bugu.Confusion:output_type -> bugu.service.v1.ConfusionReply
	21, // 32: bugu.service.v1.Bugu.Packer:output_type -> bugu.service.v1.PackerReply
	23, // 33: bugu.service.v1.Bugu.GetArtifactMetadata:output_type -> bugu.service.v1.GetArtifactMetadataReply
	25, // 34: bugu.service.v1.Bugu.GetArtifactMetadataByFileId:output_type -> bugu.service.v1.GetArtifactMetadataByFileIdReply
	27, // 35: bugu.service.v1.Bugu.DeleteArtifactMetadata:output_type -> bugu.service.v1.DeleteArtifactMetadataReply
	23, // [23:36] is the sub-list for method output_type
	10, // [10:23] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_v1_bugu_proto_init() }
func file_v1_bugu_proto_init() {
	if File_v1_bugu_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_v1_bugu_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RegisterRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RegisterReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoginRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoginReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetCurrentUserRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetCurrentUserReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UpdateUserRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UpdateUserReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserStruct); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetFileMetaRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetFileMetaReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetFileMetaByUserIdRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetFileMetaByUserIdReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeleteFileMetadataRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeleteFileMetadataReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DetectRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DetectReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConfusionRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConfusionReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PackerRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PackerReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetArtifactMetadataRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetArtifactMetadataReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetArtifactMetadataByFileIdRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetArtifactMetadataByFileIdReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeleteArtifactMetadataRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeleteArtifactMetadataReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RegisterRequest_User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LoginRequest_User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UpdateUserRequest_User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_v1_bugu_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_bugu_proto_goTypes,
		DependencyIndexes: file_v1_bugu_proto_depIdxs,
		EnumInfos:         file_v1_bugu_proto_enumTypes,
		MessageInfos:      file_v1_bugu_proto_msgTypes,
	}.Build()
	File_v1_bugu_proto = out.File
	file_v1_bugu_proto_rawDesc = nil
	file_v1_bugu_proto_goTypes = nil
	file_v1_bugu_proto_depIdxs = nil
}

```

`api/bugu/service/v1/bugu.pb.validate.go`:

```go
// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: v1/bugu.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _bugu_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterRequestValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterRequestValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterRequestValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterRequestMultiError(errors)
	}

	return nil
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error { return m }

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string { return "RegisterRequestValidationError" }

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequestValidationError{}

// Validate checks the field values on RegisterReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReplyMultiError, or
// nil if none found.
func (m *RegisterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterReplyValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterReplyMultiError(errors)
	}

	return nil
}

// RegisterReplyMultiError is an error wrapping multiple validation errors
// returned by RegisterReply.ValidateAll() if the designated constraints
// aren't met.
type RegisterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReplyMultiError) AllErrors() []error { return m }

// RegisterReplyValidationError is the validation error returned by
// RegisterReply.Validate if the designated constraints aren't met.
type RegisterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReplyValidationError) ErrorName() string { return "RegisterReplyValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReplyValidationError{}

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginRequestValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginRequestValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginRequestValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on LoginReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReplyMultiError, or
// nil if none found.
func (m *LoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReplyValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return LoginReplyMultiError(errors)
	}

	return nil
}

// LoginReplyMultiError is an error wrapping multiple validation errors
// returned by LoginReply.ValidateAll() if the designated constraints aren't met.
type LoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReplyMultiError) AllErrors() []error { return m }

// LoginReplyValidationError is the validation error returned by
// LoginReply.Validate if the designated constraints aren't met.
type LoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReplyValidationError) ErrorName() string { return "LoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReplyValidationError{}

// Validate checks the field values on GetCurrentUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCurrentUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCurrentUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCurrentUserRequestMultiError, or nil if none found.
func (m *GetCurrentUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCurrentUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = GetCurrentUserRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCurrentUserRequestMultiError(errors)
	}

	return nil
}

func (m *GetCurrentUserRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetCurrentUserRequestMultiError is an error wrapping multiple validation
// errors returned by GetCurrentUserRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCurrentUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCurrentUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCurrentUserRequestMultiError) AllErrors() []error { return m }

// GetCurrentUserRequestValidationError is the validation error returned by
// GetCurrentUserRequest.Validate if the designated constraints aren't met.
type GetCurrentUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCurrentUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCurrentUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCurrentUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCurrentUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCurrentUserRequestValidationError) ErrorName() string {
	return "GetCurrentUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCurrentUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCurrentUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCurrentUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCurrentUserRequestValidationError{}

// Validate checks the field values on GetCurrentUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCurrentUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCurrentUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCurrentUserReplyMultiError, or nil if none found.
func (m *GetCurrentUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCurrentUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCurrentUserReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCurrentUserReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCurrentUserReplyValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCurrentUserReplyMultiError(errors)
	}

	return nil
}

// GetCurrentUserReplyMultiError is an error wrapping multiple validation
// errors returned by GetCurrentUserReply.ValidateAll() if the designated
// constraints aren't met.
type GetCurrentUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCurrentUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCurrentUserReplyMultiError) AllErrors() []error { return m }

// GetCurrentUserReplyValidationError is the validation error returned by
// GetCurrentUserReply.Validate if the designated constraints aren't met.
type GetCurrentUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCurrentUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCurrentUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCurrentUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCurrentUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCurrentUserReplyValidationError) ErrorName() string {
	return "GetCurrentUserReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetCurrentUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCurrentUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCurrentUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCurrentUserReplyValidationError{}

// Validate checks the field values on UpdateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRequestMultiError, or nil if none found.
func (m *UpdateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserRequestValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserRequestValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserRequestValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserRequestMultiError(errors)
	}

	return nil
}

// UpdateUserRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRequestMultiError) AllErrors() []error { return m }

// UpdateUserRequestValidationError is the validation error returned by
// UpdateUserRequest.Validate if the designated constraints aren't met.
type UpdateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequestValidationError) ErrorName() string {
	return "UpdateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequestValidationError{}

// Validate checks the field values on UpdateUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserReplyMultiError, or nil if none found.
func (m *UpdateUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserReplyValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserReplyMultiError(errors)
	}

	return nil
}

// UpdateUserReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateUserReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserReplyMultiError) AllErrors() []error { return m }

// UpdateUserReplyValidationError is the validation error returned by
// UpdateUserReply.Validate if the designated constraints aren't met.
type UpdateUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserReplyValidationError) ErrorName() string { return "UpdateUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e UpdateUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserReplyValidationError{}

// Validate checks the field values on UserStruct with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserStruct) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserStruct with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserStructMultiError, or
// nil if none found.
func (m *UserStruct) ValidateAll() error {
	return m.validate(true)
}

func (m *UserStruct) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = UserStructValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Email

	// no validation rules for Username

	if len(errors) > 0 {
		return UserStructMultiError(errors)
	}

	return nil
}

func (m *UserStruct) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UserStructMultiError is an error wrapping multiple validation errors
// returned by UserStruct.ValidateAll() if the designated constraints aren't met.
type UserStructMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserStructMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserStructMultiError) AllErrors() []error { return m }

// UserStructValidationError is the validation error returned by
// UserStruct.Validate if the designated constraints aren't met.
type UserStructValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserStructValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserStructValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserStructValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserStructValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserStructValidationError) ErrorName() string { return "UserStructValidationError" }

// Error satisfies the builtin error interface
func (e UserStructValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserStruct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserStructValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserStructValidationError{}

// Validate checks the field values on GetFileMetaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFileMetaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileMetaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFileMetaRequestMultiError, or nil if none found.
func (m *GetFileMetaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileMetaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = GetFileMetaRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = GetFileMetaRequestValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetFileMetaRequestMultiError(errors)
	}

	return nil
}

func (m *GetFileMetaRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetFileMetaRequestMultiError is an error wrapping multiple validation errors
// returned by GetFileMetaRequest.ValidateAll() if the designated constraints
// aren't met.
type GetFileMetaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileMetaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileMetaRequestMultiError) AllErrors() []error { return m }

// GetFileMetaRequestValidationError is the validation error returned by
// GetFileMetaRequest.Validate if the designated constraints aren't met.
type GetFileMetaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileMetaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileMetaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileMetaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileMetaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileMetaRequestValidationError) ErrorName() string {
	return "GetFileMetaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFileMetaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileMetaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileMetaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileMetaRequestValidationError{}

// Validate checks the field values on GetFileMetaReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetFileMetaReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileMetaReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFileMetaReplyMultiError, or nil if none found.
func (m *GetFileMetaReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileMetaReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = GetFileMetaReplyValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FileSha_1

	// no validation rules for FileSize

	// no validation rules for FileAddr

	// no validation rules for Type

	if len(errors) > 0 {
		return GetFileMetaReplyMultiError(errors)
	}

	return nil
}

func (m *GetFileMetaReply) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetFileMetaReplyMultiError is an error wrapping multiple validation errors
// returned by GetFileMetaReply.ValidateAll() if the designated constraints
// aren't met.
type GetFileMetaReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileMetaReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileMetaReplyMultiError) AllErrors() []error { return m }

// GetFileMetaReplyValidationError is the validation error returned by
// GetFileMetaReply.Validate if the designated constraints aren't met.
type GetFileMetaReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileMetaReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileMetaReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileMetaReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileMetaReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileMetaReplyValidationError) ErrorName() string { return "GetFileMetaReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetFileMetaReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileMetaReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileMetaReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileMetaReplyValidationError{}

// Validate checks the field values on GetFileMetaByUserIdRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFileMetaByUserIdRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileMetaByUserIdRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFileMetaByUserIdRequestMultiError, or nil if none found.
func (m *GetFileMetaByUserIdRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileMetaByUserIdRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = GetFileMetaByUserIdRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetFileMetaByUserIdRequestMultiError(errors)
	}

	return nil
}

func (m *GetFileMetaByUserIdRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetFileMetaByUserIdRequestMultiError is an error wrapping multiple
// validation errors returned by GetFileMetaByUserIdRequest.ValidateAll() if
// the designated constraints aren't met.
type GetFileMetaByUserIdRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileMetaByUserIdRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileMetaByUserIdRequestMultiError) AllErrors() []error { return m }

// GetFileMetaByUserIdRequestValidationError is the validation error returned
// by GetFileMetaByUserIdRequest.Validate if the designated constraints aren't met.
type GetFileMetaByUserIdRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileMetaByUserIdRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileMetaByUserIdRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileMetaByUserIdRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileMetaByUserIdRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileMetaByUserIdRequestValidationError) ErrorName() string {
	return "GetFileMetaByUserIdRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFileMetaByUserIdRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileMetaByUserIdRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileMetaByUserIdRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileMetaByUserIdRequestValidationError{}

// Validate checks the field values on GetFileMetaByUserIdReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFileMetaByUserIdReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileMetaByUserIdReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFileMetaByUserIdReplyMultiError, or nil if none found.
func (m *GetFileMetaByUserIdReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileMetaByUserIdReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFileMetadata() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetFileMetaByUserIdReplyValidationError{
						field:  fmt.Sprintf("FileMetadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetFileMetaByUserIdReplyValidationError{
						field:  fmt.Sprintf("FileMetadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetFileMetaByUserIdReplyValidationError{
					field:  fmt.Sprintf("FileMetadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetFileMetaByUserIdReplyMultiError(errors)
	}

	return nil
}

// GetFileMetaByUserIdReplyMultiError is an error wrapping multiple validation
// errors returned by GetFileMetaByUserIdReply.ValidateAll() if the designated
// constraints aren't met.
type GetFileMetaByUserIdReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileMetaByUserIdReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileMetaByUserIdReplyMultiError) AllErrors() []error { return m }

// GetFileMetaByUserIdReplyValidationError is the validation error returned by
// GetFileMetaByUserIdReply.Validate if the designated constraints aren't met.
type GetFileMetaByUserIdReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileMetaByUserIdReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileMetaByUserIdReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileMetaByUserIdReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileMetaByUserIdReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileMetaByUserIdReplyValidationError) ErrorName() string {
	return "GetFileMetaByUserIdReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetFileMetaByUserIdReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileMetaByUserIdReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileMetaByUserIdReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileMetaByUserIdReplyValidationError{}

// Validate checks the field values on DeleteFileMetadataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFileMetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFileMetadataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFileMetadataRequestMultiError, or nil if none found.
func (m *DeleteFileMetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFileMetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = DeleteFileMetadataRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = DeleteFileMetadataRequestValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteFileMetadataRequestMultiError(errors)
	}

	return nil
}

func (m *DeleteFileMetadataRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DeleteFileMetadataRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteFileMetadataRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteFileMetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileMetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileMetadataRequestMultiError) AllErrors() []error { return m }

// DeleteFileMetadataRequestValidationError is the validation error returned by
// DeleteFileMetadataRequest.Validate if the designated constraints aren't met.
type DeleteFileMetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileMetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileMetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileMetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileMetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileMetadataRequestValidationError) ErrorName() string {
	return "DeleteFileMetadataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFileMetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFileMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileMetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileMetadataRequestValidationError{}

// Validate checks the field values on DeleteFileMetadataReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFileMetadataReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFileMetadataReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFileMetadataReplyMultiError, or nil if none found.
func (m *DeleteFileMetadataReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFileMetadataReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteFileMetadataReplyMultiError(errors)
	}

	return nil
}

// DeleteFileMetadataReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteFileMetadataReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteFileMetadataReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileMetadataReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileMetadataReplyMultiError) AllErrors() []error { return m }

// DeleteFileMetadataReplyValidationError is the validation error returned by
// DeleteFileMetadataReply.Validate if the designated constraints aren't met.
type DeleteFileMetadataReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileMetadataReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileMetadataReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileMetadataReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileMetadataReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileMetadataReplyValidationError) ErrorName() string {
	return "DeleteFileMetadataReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFileMetadataReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFileMetadataReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileMetadataReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileMetadataReplyValidationError{}

// Validate checks the field values on DetectRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DetectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DetectRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DetectRequestMultiError, or
// nil if none found.
func (m *DetectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DetectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = DetectRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = DetectRequestValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DetectRequestMultiError(errors)
	}

	return nil
}

func (m *DetectRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DetectRequestMultiError is an error wrapping multiple validation errors
// returned by DetectRequest.ValidateAll() if the designated constraints
// aren't met.
type DetectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DetectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DetectRequestMultiError) AllErrors() []error { return m }

// DetectRequestValidationError is the validation error returned by
// DetectRequest.Validate if the designated constraints aren't met.
type DetectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DetectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DetectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DetectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DetectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DetectRequestValidationError) ErrorName() string { return "DetectRequestValidationError" }

// Error satisfies the builtin error interface
func (e DetectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDetectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DetectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DetectRequestValidationError{}

// Validate checks the field values on DetectReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DetectReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DetectReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DetectReplyMultiError, or
// nil if none found.
func (m *DetectReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DetectReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetArtifactId()); err != nil {
		err = DetectReplyValidationError{
			field:  "ArtifactId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DetectReplyMultiError(errors)
	}

	return nil
}

func (m *DetectReply) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DetectReplyMultiError is an error wrapping multiple validation errors
// returned by DetectReply.ValidateAll() if the designated constraints aren't met.
type DetectReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DetectReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DetectReplyMultiError) AllErrors() []error { return m }

// DetectReplyValidationError is the validation error returned by
// DetectReply.Validate if the designated constraints aren't met.
type DetectReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DetectReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DetectReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DetectReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DetectReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DetectReplyValidationError) ErrorName() string { return "DetectReplyValidationError" }

// Error satisfies the builtin error interface
func (e DetectReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDetectReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DetectReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DetectReplyValidationError{}

// Validate checks the field values on ConfusionRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConfusionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfusionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfusionRequestMultiError, or nil if none found.
func (m *ConfusionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfusionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = ConfusionRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = ConfusionRequestValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConfusionRequestMultiError(errors)
	}

	return nil
}

func (m *ConfusionRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ConfusionRequestMultiError is an error wrapping multiple validation errors
// returned by ConfusionRequest.ValidateAll() if the designated constraints
// aren't met.
type ConfusionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfusionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfusionRequestMultiError) AllErrors() []error { return m }

// ConfusionRequestValidationError is the validation error returned by
// ConfusionRequest.Validate if the designated constraints aren't met.
type ConfusionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfusionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfusionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfusionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfusionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfusionRequestValidationError) ErrorName() string { return "ConfusionRequestValidationError" }

// Error satisfies the builtin error interface
func (e ConfusionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfusionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfusionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfusionRequestValidationError{}

// Validate checks the field values on ConfusionReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfusionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfusionReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfusionReplyMultiError,
// or nil if none found.
func (m *ConfusionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfusionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetArtifactId()); err != nil {
		err = ConfusionReplyValidationError{
			field:  "ArtifactId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = ConfusionReplyValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetAffiliatedFileId()); err != nil {
		err = ConfusionReplyValidationError{
			field:  "AffiliatedFileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Method

	if len(errors) > 0 {
		return ConfusionReplyMultiError(errors)
	}

	return nil
}

func (m *ConfusionReply) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ConfusionReplyMultiError is an error wrapping multiple validation errors
// returned by ConfusionReply.ValidateAll() if the designated constraints
// aren't met.
type ConfusionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfusionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfusionReplyMultiError) AllErrors() []error { return m }

// ConfusionReplyValidationError is the validation error returned by
// ConfusionReply.Validate if the designated constraints aren't met.
type ConfusionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfusionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfusionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfusionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfusionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfusionReplyValidationError) ErrorName() string { return "ConfusionReplyValidationError" }

// Error satisfies the builtin error interface
func (e ConfusionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfusionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfusionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfusionReplyValidationError{}

// Validate checks the field values on PackerRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PackerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PackerRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PackerRequestMultiError, or
// nil if none found.
func (m *PackerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PackerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = PackerRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = PackerRequestValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PackerRequestMultiError(errors)
	}

	return nil
}

func (m *PackerRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PackerRequestMultiError is an error wrapping multiple validation errors
// returned by PackerRequest.ValidateAll() if the designated constraints
// aren't met.
type PackerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PackerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PackerRequestMultiError) AllErrors() []error { return m }

// PackerRequestValidationError is the validation error returned by
// PackerRequest.Validate if the designated constraints aren't met.
type PackerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PackerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PackerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PackerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PackerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PackerRequestValidationError) ErrorName() string { return "PackerRequestValidationError" }

// Error satisfies the builtin error interface
func (e PackerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPackerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PackerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PackerRequestValidationError{}

// Validate checks the field values on PackerReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PackerReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PackerReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PackerReplyMultiError, or
// nil if none found.
func (m *PackerReply) ValidateAll() error {
	return m.validate(true)
}

func (m *PackerReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetArtifactId()); err != nil {
		err = PackerReplyValidationError{
			field:  "ArtifactId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = PackerReplyValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetAffiliatedFileId()); err != nil {
		err = PackerReplyValidationError{
			field:  "AffiliatedFileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Method

	if len(errors) > 0 {
		return PackerReplyMultiError(errors)
	}

	return nil
}

func (m *PackerReply) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// PackerReplyMultiError is an error wrapping multiple validation errors
// returned by PackerReply.ValidateAll() if the designated constraints aren't met.
type PackerReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PackerReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PackerReplyMultiError) AllErrors() []error { return m }

// PackerReplyValidationError is the validation error returned by
// PackerReply.Validate if the designated constraints aren't met.
type PackerReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PackerReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PackerReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PackerReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PackerReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PackerReplyValidationError) ErrorName() string { return "PackerReplyValidationError" }

// Error satisfies the builtin error interface
func (e PackerReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPackerReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PackerReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PackerReplyValidationError{}

// Validate checks the field values on GetArtifactMetadataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetArtifactMetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetArtifactMetadataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetArtifactMetadataRequestMultiError, or nil if none found.
func (m *GetArtifactMetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetArtifactMetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = GetArtifactMetadataRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetArtifactId()); err != nil {
		err = GetArtifactMetadataRequestValidationError{
			field:  "ArtifactId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetArtifactMetadataRequestMultiError(errors)
	}

	return nil
}

func (m *GetArtifactMetadataRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetArtifactMetadataRequestMultiError is an error wrapping multiple
// validation errors returned by GetArtifactMetadataRequest.ValidateAll() if
// the designated constraints aren't met.
type GetArtifactMetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetArtifactMetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetArtifactMetadataRequestMultiError) AllErrors() []error { return m }

// GetArtifactMetadataRequestValidationError is the validation error returned
// by GetArtifactMetadataRequest.Validate if the designated constraints aren't met.
type GetArtifactMetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetArtifactMetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetArtifactMetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetArtifactMetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetArtifactMetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetArtifactMetadataRequestValidationError) ErrorName() string {
	return "GetArtifactMetadataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetArtifactMetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetArtifactMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetArtifactMetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetArtifactMetadataRequestValidationError{}

// Validate checks the field values on GetArtifactMetadataReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetArtifactMetadataReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetArtifactMetadataReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetArtifactMetadataReplyMultiError, or nil if none found.
func (m *GetArtifactMetadataReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetArtifactMetadataReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetArtifactId()); err != nil {
		err = GetArtifactMetadataReplyValidationError{
			field:  "ArtifactId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = GetArtifactMetadataReplyValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetAffiliatedFileId()); err != nil {
		err = GetArtifactMetadataReplyValidationError{
			field:  "AffiliatedFileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Method

	if len(errors) > 0 {
		return GetArtifactMetadataReplyMultiError(errors)
	}

	return nil
}

func (m *GetArtifactMetadataReply) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetArtifactMetadataReplyMultiError is an error wrapping multiple validation
// errors returned by GetArtifactMetadataReply.ValidateAll() if the designated
// constraints aren't met.
type GetArtifactMetadataReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetArtifactMetadataReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetArtifactMetadataReplyMultiError) AllErrors() []error { return m }

// GetArtifactMetadataReplyValidationError is the validation error returned by
// GetArtifactMetadataReply.Validate if the designated constraints aren't met.
type GetArtifactMetadataReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetArtifactMetadataReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetArtifactMetadataReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetArtifactMetadataReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetArtifactMetadataReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetArtifactMetadataReplyValidationError) ErrorName() string {
	return "GetArtifactMetadataReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetArtifactMetadataReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetArtifactMetadataReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetArtifactMetadataReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetArtifactMetadataReplyValidationError{}

// Validate checks the field values on GetArtifactMetadataByFileIdRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetArtifactMetadataByFileIdRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetArtifactMetadataByFileIdRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetArtifactMetadataByFileIdRequestMultiError, or nil if none found.
func (m *GetArtifactMetadataByFileIdRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetArtifactMetadataByFileIdRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = GetArtifactMetadataByFileIdRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetFileId()); err != nil {
		err = GetArtifactMetadataByFileIdRequestValidationError{
			field:  "FileId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetArtifactMetadataByFileIdRequestMultiError(errors)
	}

	return nil
}

func (m *GetArtifactMetadataByFileIdRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetArtifactMetadataByFileIdRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetArtifactMetadataByFileIdRequest.ValidateAll() if the designated
// constraints aren't met.
type GetArtifactMetadataByFileIdRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetArtifactMetadataByFileIdRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetArtifactMetadataByFileIdRequestMultiError) AllErrors() []error { return m }

// GetArtifactMetadataByFileIdRequestValidationError is the validation error
// returned by GetArtifactMetadataByFileIdRequest.Validate if the designated
// constraints aren't met.
type GetArtifactMetadataByFileIdRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetArtifactMetadataByFileIdRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetArtifactMetadataByFileIdRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetArtifactMetadataByFileIdRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetArtifactMetadataByFileIdRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetArtifactMetadataByFileIdRequestValidationError) ErrorName() string {
	return "GetArtifactMetadataByFileIdRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetArtifactMetadataByFileIdRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetArtifactMetadataByFileIdRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetArtifactMetadataByFileIdRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetArtifactMetadataByFileIdRequestValidationError{}

// Validate checks the field values on GetArtifactMetadataByFileIdReply with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetArtifactMetadataByFileIdReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetArtifactMetadataByFileIdReply with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetArtifactMetadataByFileIdReplyMultiError, or nil if none found.
func (m *GetArtifactMetadataByFileIdReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetArtifactMetadataByFileIdReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetArtifactMetadata() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetArtifactMetadataByFileIdReplyValidationError{
						field:  fmt.Sprintf("ArtifactMetadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetArtifactMetadataByFileIdReplyValidationError{
						field:  fmt.Sprintf("ArtifactMetadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetArtifactMetadataByFileIdReplyValidationError{
					field:  fmt.Sprintf("ArtifactMetadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetArtifactMetadataByFileIdReplyMultiError(errors)
	}

	return nil
}

// GetArtifactMetadataByFileIdReplyMultiError is an error wrapping multiple
// validation errors returned by
// GetArtifactMetadataByFileIdReply.ValidateAll() if the designated
// constraints aren't met.
type GetArtifactMetadataByFileIdReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetArtifactMetadataByFileIdReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetArtifactMetadataByFileIdReplyMultiError) AllErrors() []error { return m }

// GetArtifactMetadataByFileIdReplyValidationError is the validation error
// returned by GetArtifactMetadataByFileIdReply.Validate if the designated
// constraints aren't met.
type GetArtifactMetadataByFileIdReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetArtifactMetadataByFileIdReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetArtifactMetadataByFileIdReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetArtifactMetadataByFileIdReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetArtifactMetadataByFileIdReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetArtifactMetadataByFileIdReplyValidationError) ErrorName() string {
	return "GetArtifactMetadataByFileIdReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetArtifactMetadataByFileIdReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetArtifactMetadataByFileIdReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetArtifactMetadataByFileIdReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetArtifactMetadataByFileIdReplyValidationError{}

// Validate checks the field values on DeleteArtifactMetadataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteArtifactMetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteArtifactMetadataRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteArtifactMetadataRequestMultiError, or nil if none found.
func (m *DeleteArtifactMetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteArtifactMetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetUserId()); err != nil {
		err = DeleteArtifactMetadataRequestValidationError{
			field:  "UserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetArtifactId()); err != nil {
		err = DeleteArtifactMetadataRequestValidationError{
			field:  "ArtifactId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteArtifactMetadataRequestMultiError(errors)
	}

	return nil
}

func (m *DeleteArtifactMetadataRequest) _validateUuid(uuid string) error {
	if matched := _bugu_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DeleteArtifactMetadataRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteArtifactMetadataRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteArtifactMetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteArtifactMetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteArtifactMetadataRequestMultiError) AllErrors() []error { return m }

// DeleteArtifactMetadataRequestValidationError is the validation error
// returned by DeleteArtifactMetadataRequest.Validate if the designated
// constraints aren't met.
type DeleteArtifactMetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteArtifactMetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteArtifactMetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteArtifactMetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteArtifactMetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteArtifactMetadataRequestValidationError) ErrorName() string {
	return "DeleteArtifactMetadataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteArtifactMetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteArtifactMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteArtifactMetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteArtifactMetadataRequestValidationError{}

// Validate checks the field values on DeleteArtifactMetadataReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteArtifactMetadataReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteArtifactMetadataReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteArtifactMetadataReplyMultiError, or nil if none found.
func (m *DeleteArtifactMetadataReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteArtifactMetadataReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteArtifactMetadataReplyMultiError(errors)
	}

	return nil
}

// DeleteArtifactMetadataReplyMultiError is an error wrapping multiple
// validation errors returned by DeleteArtifactMetadataReply.ValidateAll() if
// the designated constraints aren't met.
type DeleteArtifactMetadataReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteArtifactMetadataReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteArtifactMetadataReplyMultiError) AllErrors() []error { return m }

// DeleteArtifactMetadataReplyValidationError is the validation error returned
// by DeleteArtifactMetadataReply.Validate if the designated constraints
// aren't met.
type DeleteArtifactMetadataReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteArtifactMetadataReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteArtifactMetadataReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteArtifactMetadataReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteArtifactMetadataReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteArtifactMetadataReplyValidationError) ErrorName() string {
	return "DeleteArtifactMetadataReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteArtifactMetadataReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteArtifactMetadataReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteArtifactMetadataReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteArtifactMetadataReplyValidationError{}

// Validate checks the field values on RegisterRequest_User with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest_User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest_User with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequest_UserMultiError, or nil if none found.
func (m *RegisterRequest_User) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest_User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Email

	// no validation rules for Password

	if len(errors) > 0 {
		return RegisterRequest_UserMultiError(errors)
	}

	return nil
}

// RegisterRequest_UserMultiError is an error wrapping multiple validation
// errors returned by RegisterRequest_User.ValidateAll() if the designated
// constraints aren't met.
type RegisterRequest_UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequest_UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequest_UserMultiError) AllErrors() []error { return m }

// RegisterRequest_UserValidationError is the validation error returned by
// RegisterRequest_User.Validate if the designated constraints aren't met.
type RegisterRequest_UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequest_UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequest_UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequest_UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequest_UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequest_UserValidationError) ErrorName() string {
	return "RegisterRequest_UserValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterRequest_UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest_User.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequest_UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequest_UserValidationError{}

// Validate checks the field values on LoginRequest_User with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginRequest_User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest_User with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginRequest_UserMultiError, or nil if none found.
func (m *LoginRequest_User) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest_User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Email

	// no validation rules for Password

	if len(errors) > 0 {
		return LoginRequest_UserMultiError(errors)
	}

	return nil
}

// LoginRequest_UserMultiError is an error wrapping multiple validation errors
// returned by LoginRequest_User.ValidateAll() if the designated constraints
// aren't met.
type LoginRequest_UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequest_UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequest_UserMultiError) AllErrors() []error { return m }

// LoginRequest_UserValidationError is the validation error returned by
// LoginRequest_User.Validate if the designated constraints aren't met.
type LoginRequest_UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequest_UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequest_UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequest_UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequest_UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequest_UserValidationError) ErrorName() string {
	return "LoginRequest_UserValidationError"
}

// Error satisfies the builtin error interface
func (e LoginRequest_UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest_User.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequest_UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequest_UserValidationError{}

// Validate checks the field values on UpdateUserRequest_User with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRequest_User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRequest_User with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRequest_UserMultiError, or nil if none found.
func (m *UpdateUserRequest_User) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRequest_User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Email

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return UpdateUserRequest_UserMultiError(errors)
	}

	return nil
}

// UpdateUserRequest_UserMultiError is an error wrapping multiple validation
// errors returned by UpdateUserRequest_User.ValidateAll() if the designated
// constraints aren't met.
type UpdateUserRequest_UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRequest_UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRequest_UserMultiError) AllErrors() []error { return m }

// UpdateUserRequest_UserValidationError is the validation error returned by
// UpdateUserRequest_User.Validate if the designated constraints aren't met.
type UpdateUserRequest_UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequest_UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequest_UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequest_UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequest_UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequest_UserValidationError) ErrorName() string {
	return "UpdateUserRequest_UserValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequest_UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest_User.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequest_UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequest_UserValidationError{}

```

`api/bugu/service/v1/bugu.proto`:

```proto
syntax = "proto3";

package bugu.service.v1;

import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";
import "validate/validate.proto";

option go_package = "github.com/hominsu/bugu/api/bugu/service/v1;v1";

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "E-Code API";
    version: "1.0";
    description: "";
    contact: {
      name: "Bugu Backend";
      url: "https://github.com/hominsu/bugu";
      email: "hominsu@foxmail.com";
    };
  };
  schemes: HTTPS;
  consumes: "application/json";
  produces: "application/json";
};

service Bugu {
  rpc Register (RegisterRequest) returns (RegisterReply) {
    option (google.api.http) = {
      post: "/v1/users",
      body: "*",
    };
  };

  rpc Login (LoginRequest) returns (LoginReply) {
    option (google.api.http) = {
      post: "/v1/users/login",
      body: "*",
    };
  };

  rpc GetCurrentUser (GetCurrentUserRequest) returns (GetCurrentUserReply) {
    option (google.api.http) = {
      get: "/v1/user/{id}",
    };
  };

  rpc UpdateUser (UpdateUserRequest) returns (UpdateUserReply) {
    option (google.api.http) = {
      put: "/v1/users",
      body: "*",
    };
  };

  rpc GetFileMeta (GetFileMetaRequest) returns (GetFileMetaReply) {
    option (google.api.http) = {
      get: "/v1/user/{user_id}/file/{file_id}/metadata",
    };
  };

  rpc GetFileMetaByUserId (GetFileMetaByUserIdRequest) returns (GetFileMetaByUserIdReply) {
    option (google.api.http) = {
      get: "/v1/user/{user_id}/files",
    };
  };

  rpc DeleteFileMetadata (DeleteFileMetadataRequest) returns (DeleteFileMetadataReply) {
    option (google.api.http) = {
      delete: "/v1/user/{user_id}/file/{file_id}/metadata",
    };
  };

  rpc Detect (DetectRequest) returns (DetectReply) {
    option (google.api.http) = {
      get: "/v1/user/{user_id}/file/{file_id}/detect",
      additional_bindings: {
        post: "/v1/user/file/detect",
        body: "*"
      }
    };
  };

  rpc Confusion (ConfusionRequest) returns (ConfusionReply) {
    option (google.api.http) = {
      get: "/v1/user/{user_id}/file/{file_id}/confusion",
      additional_bindings: {
        post: "/v1/user/file/confusion",
        body: "*"
      }
    };
  };

  rpc Packer (PackerRequest) returns (PackerReply) {
    option (google.api.http) = {
      get: "/v1/user/{user_id}/file/{file_id}/packer",
      additional_bindings: {
        post: "/v1/user/file/packer",
        body: "*"
      }
    };
  };

  rpc GetArtifactMetadata (GetArtifactMetadataRequest) returns (GetArtifactMetadataReply) {
    option (google.api.http) = {
      get: "/v1/user/{user_id}/artifact/{artifact_id}/metadata",
    };
  };

  rpc GetArtifactMetadataByFileId (GetArtifactMetadataByFileIdRequest) returns (GetArtifactMetadataByFileIdReply) {
    option (google.api.http) = {
      get: "/v1/user/{user_id}/artifact/file/{file_id}",
    };
  };

  rpc DeleteArtifactMetadata (DeleteArtifactMetadataRequest) returns (DeleteArtifactMetadataReply) {
    option (google.api.http) = {
      delete: "/v1/user/{user_id}/artifact/{artifact_id}/metadata",
    };
  };
};

message RegisterRequest {
  message User {
    string username = 1;
    string email = 2;
    string password = 3;
  }
  User user = 1;
}

message RegisterReply {
  UserStruct user = 1;
}

message LoginRequest {
  message User {
    string email = 1;
    string password = 2;
  }
  User user = 1;
}

message LoginReply {
  UserStruct user = 1;
  string token = 2;
}

message GetCurrentUserRequest {
  string id = 1 [(validate.rules).string = {uuid: true}];
}

message GetCurrentUserReply {
  UserStruct user = 1;
}

message UpdateUserRequest {
  message User {
    string id = 1;
    string email = 2;
    string username = 4;
    string password = 5;
  }
  User user = 1;
}

message UpdateUserReply {
  UserStruct user = 1;
}

message UserStruct {
  string id = 1 [(validate.rules).string = {uuid: true}];
  string email = 2;
  string username = 3;
}

enum Type {
  TYPE_ADPOSHEL = 0;
  TYPE_AGENT = 1;
  TYPE_ALLAPLE = 2;
  TYPE_AMONETIZE = 3;
  TYPE_ANDROM = 4;
  TYPE_AUTORUN = 5;
  TYPE_BROWSE_FOX = 6;
  TYPE_DINWOD = 7;
  TYPE_ELEX = 8;
  TYPE_EXPIRO = 9;
  TYPE_FASONG = 10;
  TYPE_HACK_KMS = 11;
  TYPE_HLUX = 12;
  TYPE_INJECTOR = 13;
  TYPE_INSTALL_CORE = 14;
  TYPE_MULTI_Plug = 15;
  TYPE_NEOREKLAMI = 16;
  TYPE_NESHTA = 17;
  TYPE_OTHER = 18;
  TYPE_REGRUN = 19;
  TYPE_SALITY = 20;
  TYPE_SNARASITE = 21;
  TYPE_STABTINKO = 22;
  TYPE_VBA = 23;
  TYPE_VBKRYPT = 24;
  TYPE_VILSEL = 25;
}

message GetFileMetaRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
}

message GetFileMetaReply {
  string file_id = 1 [(validate.rules).string = {uuid: true}];
  string file_sha_1 = 2;
  int64 file_size = 3;
  string file_addr = 4;
  Type type = 5;
}

message GetFileMetaByUserIdRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
}

message GetFileMetaByUserIdReply {
  repeated GetFileMetaReply file_metadata = 1;
}

message DeleteFileMetadataRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
}

message DeleteFileMetadataReply {
}

message DetectRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
}

message DetectReply {
  string artifact_id = 1 [(validate.rules).string = {uuid: true}];
}

message ConfusionRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
}

message ConfusionReply {
  string artifact_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
  string affiliated_file_id = 3 [(validate.rules).string = {uuid: true}];
  string method = 4;
}

message PackerRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
}

message PackerReply {
  string artifact_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
  string affiliated_file_id = 3 [(validate.rules).string = {uuid: true}];
  string method = 4;
}

message GetArtifactMetadataRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
  string artifact_id = 2 [(validate.rules).string = {uuid: true}];
}

message GetArtifactMetadataReply {
  string artifact_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
  string affiliated_file_id = 3 [(validate.rules).string = {uuid: true}];
  string method = 4;
}

message GetArtifactMetadataByFileIdRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
  string file_id = 2 [(validate.rules).string = {uuid: true}];
}

message GetArtifactMetadataByFileIdReply {
  repeated GetArtifactMetadataReply artifact_metadata = 1;
}

message DeleteArtifactMetadataRequest {
  string user_id = 1 [(validate.rules).string = {uuid: true}];
  string artifact_id = 2 [(validate.rules).string = {uuid: true}];
}

message DeleteArtifactMetadataReply {
}
```

`api/bugu/service/v1/bugu.swagger.json`:

```json
{
  "swagger": "2.0",
  "info": {
    "title": "E-Code API",
    "version": "1.0",
    "contact": {
      "name": "Bugu Backend",
      "url": "https://github.com/hominsu/bugu",
      "email": "hominsu@foxmail.com"
    }
  },
  "tags": [
    {
      "name": "Bugu"
    }
  ],
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/user/file/confusion": {
      "post": {
        "operationId": "Bugu_Confusion2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ConfusionReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ConfusionRequest"
            }
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/file/detect": {
      "post": {
        "operationId": "Bugu_Detect2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DetectReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1DetectRequest"
            }
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/file/packer": {
      "post": {
        "operationId": "Bugu_Packer2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PackerReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1PackerRequest"
            }
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/{id}": {
      "get": {
        "operationId": "Bugu_GetCurrentUser",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetCurrentUserReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/{userId}/artifact/file/{fileId}": {
      "get": {
        "operationId": "Bugu_GetArtifactMetadataByFileId",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetArtifactMetadataByFileIdReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "fileId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/{userId}/artifact/{artifactId}/metadata": {
      "get": {
        "operationId": "Bugu_GetArtifactMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetArtifactMetadataReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "artifactId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      },
      "delete": {
        "operationId": "Bugu_DeleteArtifactMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteArtifactMetadataReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "artifactId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/{userId}/file/{fileId}/confusion": {
      "get": {
        "operationId": "Bugu_Confusion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ConfusionReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "fileId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/{userId}/file/{fileId}/detect": {
      "get": {
        "operationId": "Bugu_Detect",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DetectReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "fileId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/{userId}/file/{fileId}/metadata": {
      "get": {
        "operationId": "Bugu_GetFileMeta",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetFileMetaReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "fileId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      },
      "delete": {
        "operationId": "Bugu_DeleteFileMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteFileMetadataReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "fileId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/{userId}/file/{fileId}/packer": {
      "get": {
        "operationId": "Bugu_Packer",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PackerReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "fileId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/user/{userId}/files": {
      "get": {
        "operationId": "Bugu_GetFileMetaByUserId",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetFileMetaByUserIdReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/users": {
      "post": {
        "operationId": "Bugu_Register",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RegisterReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1RegisterRequest"
            }
          }
        ],
        "tags": [
          "Bugu"
        ]
      },
      "put": {
        "operationId": "Bugu_UpdateUser",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateUserReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1UpdateUserRequest"
            }
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    },
    "/v1/users/login": {
      "post": {
        "operationId": "Bugu_Login",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1LoginReply"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1LoginRequest"
            }
          }
        ],
        "tags": [
          "Bugu"
        ]
      }
    }
  },
  "definitions": {
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "servicev1Type": {
      "type": "string",
      "enum": [
        "TYPE_ADPOSHEL",
        "TYPE_AGENT",
        "TYPE_ALLAPLE",
        "TYPE_AMONETIZE",
        "TYPE_ANDROM",
        "TYPE_AUTORUN",
        "TYPE_BROWSE_FOX",
        "TYPE_DINWOD",
        "TYPE_ELEX",
        "TYPE_EXPIRO",
        "TYPE_FASONG",
        "TYPE_HACK_KMS",
        "TYPE_HLUX",
        "TYPE_INJECTOR",
        "TYPE_INSTALL_CORE",
        "TYPE_MULTI_Plug",
        "TYPE_NEOREKLAMI",
        "TYPE_NESHTA",
        "TYPE_OTHER",
        "TYPE_REGRUN",
        "TYPE_SALITY",
        "TYPE_SNARASITE",
        "TYPE_STABTINKO",
        "TYPE_VBA",
        "TYPE_VBKRYPT",
        "TYPE_VILSEL"
      ],
      "default": "TYPE_ADPOSHEL"
    },
    "v1ConfusionReply": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string"
        },
        "fileId": {
          "type": "string"
        },
        "affiliatedFileId": {
          "type": "string"
        },
        "method": {
          "type": "string"
        }
      }
    },
    "v1ConfusionRequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "string"
        },
        "fileId": {
          "type": "string"
        }
      }
    },
    "v1DeleteArtifactMetadataReply": {
      "type": "object"
    },
    "v1DeleteFileMetadataReply": {
      "type": "object"
    },
    "v1DetectReply": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string"
        }
      }
    },
    "v1DetectRequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "string"
        },
        "fileId": {
          "type": "string"
        }
      }
    },
    "v1GetArtifactMetadataByFileIdReply": {
      "type": "object",
      "properties": {
        "artifactMetadata": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1GetArtifactMetadataReply"
          }
        }
      }
    },
    "v1GetArtifactMetadataReply": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string"
        },
        "fileId": {
          "type": "string"
        },
        "affiliatedFileId": {
          "type": "string"
        },
        "method": {
          "type": "string"
        }
      }
    },
    "v1GetCurrentUserReply": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/v1UserStruct"
        }
      }
    },
    "v1GetFileMetaByUserIdReply": {
      "type": "object",
      "properties": {
        "fileMetadata": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1GetFileMetaReply"
          }
        }
      }
    },
    "v1GetFileMetaReply": {
      "type": "object",
      "properties": {
        "fileId": {
          "type": "string"
        },
        "fileSha1": {
          "type": "string"
        },
        "fileSize": {
          "type": "string",
          "format": "int64"
        },
        "fileAddr": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/servicev1Type"
        }
      }
    },
    "v1LoginReply": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/v1UserStruct"
        },
        "token": {
          "type": "string"
        }
      }
    },
    "v1LoginRequest": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/v1LoginRequestUser"
        }
      }
    },
    "v1LoginRequestUser": {
      "type": "object",
      "properties": {
        "email": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      }
    },
    "v1PackerReply": {
      "type": "object",
      "properties": {
        "artifactId": {
          "type": "string"
        },
        "fileId": {
          "type": "string"
        },
        "affiliatedFileId": {
          "type": "string"
        },
        "method": {
          "type": "string"
        }
      }
    },
    "v1PackerRequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "string"
        },
        "fileId": {
          "type": "string"
        }
      }
    },
    "v1RegisterReply": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/v1UserStruct"
        }
      }
    },
    "v1RegisterRequest": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/v1RegisterRequestUser"
        }
      }
    },
    "v1RegisterRequestUser": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      }
    },
    "v1UpdateUserReply": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/v1UserStruct"
        }
      }
    },
    "v1UpdateUserRequest": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/v1UpdateUserRequestUser"
        }
      }
    },
    "v1UpdateUserRequestUser": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "username": {
          "type": "string"
        },
        "password": {
          "type": "string"
        }
      }
    },
    "v1UserStruct": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "username": {
          "type": "string"
        }
      }
    }
  }
}

```

`api/bugu/service/v1/bugu_error.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: v1/bugu_error.proto

package v1

import (
	_ "github.com/go-kratos/kratos/v2/errors"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type UserServiceErrorReason int32

const (
	UserServiceErrorReason_UNKNOWN_ERROR         UserServiceErrorReason = 0
	UserServiceErrorReason_INTERNAL_SERVER_ERROR UserServiceErrorReason = 1
	UserServiceErrorReason_NOT_FOUND_ERROR       UserServiceErrorReason = 2
	UserServiceErrorReason_LOGIN_FAILED          UserServiceErrorReason = 3
	UserServiceErrorReason_REGISTER_FAILED       UserServiceErrorReason = 4
	UserServiceErrorReason_CREATE_FAILED         UserServiceErrorReason = 5
	UserServiceErrorReason_CREATE_CONFLICT       UserServiceErrorReason = 6
	UserServiceErrorReason_UUID_GENERATE_FAILED  UserServiceErrorReason = 7
	UserServiceErrorReason_UUID_PARSE_FAILED     UserServiceErrorReason = 8
	UserServiceErrorReason_JSON_UNMARSHAL_FAILED UserServiceErrorReason = 9
)

// Enum value maps for UserServiceErrorReason.
var (
	UserServiceErrorReason_name = map[int32]string{
		0: "UNKNOWN_ERROR",
		1: "INTERNAL_SERVER_ERROR",
		2: "NOT_FOUND_ERROR",
		3: "LOGIN_FAILED",
		4: "REGISTER_FAILED",
		5: "CREATE_FAILED",
		6: "CREATE_CONFLICT",
		7: "UUID_GENERATE_FAILED",
		8: "UUID_PARSE_FAILED",
		9: "JSON_UNMARSHAL_FAILED",
	}
	UserServiceErrorReason_value = map[string]int32{
		"UNKNOWN_ERROR":         0,
		"INTERNAL_SERVER_ERROR": 1,
		"NOT_FOUND_ERROR":       2,
		"LOGIN_FAILED":          3,
		"REGISTER_FAILED":       4,
		"CREATE_FAILED":         5,
		"CREATE_CONFLICT":       6,
		"UUID_GENERATE_FAILED":  7,
		"UUID_PARSE_FAILED":     8,
		"JSON_UNMARSHAL_FAILED": 9,
	}
)

func (x UserServiceErrorReason) Enum() *UserServiceErrorReason {
	p := new(UserServiceErrorReason)
	*p = x
	return p
}

func (x UserServiceErrorReason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UserServiceErrorReason) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_bugu_error_proto_enumTypes[0].Descriptor()
}

func (UserServiceErrorReason) Type() protoreflect.EnumType {
	return &file_v1_bugu_error_proto_enumTypes[0]
}

func (x UserServiceErrorReason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UserServiceErrorReason.Descriptor instead.
func (UserServiceErrorReason) EnumDescriptor() ([]byte, []int) {
	return file_v1_bugu_error_proto_rawDescGZIP(), []int{0}
}

var File_v1_bugu_error_proto protoreflect.FileDescriptor

var file_v1_bugu_error_proto_rawDesc = []byte{
	0x0a, 0x13, 0x76, 0x31, 0x2f, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0f, 0x62, 0x75, 0x67, 0x75, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x13, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x2f, 0x65,
	0x72, 0x72, 0x6f, 0x72, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2a, 0x88, 0x02, 0x0a, 0x16,
	0x55, 0x73, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x45, 0x72, 0x72, 0x6f, 0x72,
	0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x11, 0x0a, 0x0d, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57,
	0x4e, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x00, 0x12, 0x1f, 0x0a, 0x15, 0x49, 0x4e, 0x54,
	0x45, 0x52, 0x4e, 0x41, 0x4c, 0x5f, 0x53, 0x45, 0x52, 0x56, 0x45, 0x52, 0x5f, 0x45, 0x52, 0x52,
	0x4f, 0x52, 0x10, 0x01, 0x1a, 0x04, 0xa8, 0x45, 0x94, 0x03, 0x12, 0x19, 0x0a, 0x0f, 0x4e, 0x4f,
	0x54, 0x5f, 0x46, 0x4f, 0x55, 0x4e, 0x44, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x02, 0x1a,
	0x04, 0xa8, 0x45, 0x94, 0x03, 0x12, 0x10, 0x0a, 0x0c, 0x4c, 0x4f, 0x47, 0x49, 0x4e, 0x5f, 0x46,
	0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x03, 0x12, 0x13, 0x0a, 0x0f, 0x52, 0x45, 0x47, 0x49, 0x53,
	0x54, 0x45, 0x52, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x04, 0x12, 0x11, 0x0a, 0x0d,
	0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x05, 0x12,
	0x13, 0x0a, 0x0f, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 0x46, 0x4c, 0x49,
	0x43, 0x54, 0x10, 0x06, 0x12, 0x18, 0x0a, 0x14, 0x55, 0x55, 0x49, 0x44, 0x5f, 0x47, 0x45, 0x4e,
	0x45, 0x52, 0x41, 0x54, 0x45, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x07, 0x12, 0x15,
	0x0a, 0x11, 0x55, 0x55, 0x49, 0x44, 0x5f, 0x50, 0x41, 0x52, 0x53, 0x45, 0x5f, 0x46, 0x41, 0x49,
	0x4c, 0x45, 0x44, 0x10, 0x08, 0x12, 0x19, 0x0a, 0x15, 0x4a, 0x53, 0x4f, 0x4e, 0x5f, 0x55, 0x4e,
	0x4d, 0x41, 0x52, 0x53, 0x48, 0x41, 0x4c, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x09,
	0x1a, 0x04, 0xa0, 0x45, 0xf4, 0x03, 0x42, 0x29, 0x50, 0x01, 0x5a, 0x25, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x73, 0x75, 0x2f, 0x62,
	0x75, 0x67, 0x75, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x76,
	0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_v1_bugu_error_proto_rawDescOnce sync.Once
	file_v1_bugu_error_proto_rawDescData = file_v1_bugu_error_proto_rawDesc
)

func file_v1_bugu_error_proto_rawDescGZIP() []byte {
	file_v1_bugu_error_proto_rawDescOnce.Do(func() {
		file_v1_bugu_error_proto_rawDescData = protoimpl.X.CompressGZIP(file_v1_bugu_error_proto_rawDescData)
	})
	return file_v1_bugu_error_proto_rawDescData
}

var file_v1_bugu_error_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_v1_bugu_error_proto_goTypes = []interface{}{
	(UserServiceErrorReason)(0), // 0: bugu.service.v1.UserServiceErrorReason
}
var file_v1_bugu_error_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_v1_bugu_error_proto_init() }
func file_v1_bugu_error_proto_init() {
	if File_v1_bugu_error_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_v1_bugu_error_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   0,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_v1_bugu_error_proto_goTypes,
		DependencyIndexes: file_v1_bugu_error_proto_depIdxs,
		EnumInfos:         file_v1_bugu_error_proto_enumTypes,
	}.Build()
	File_v1_bugu_error_proto = out.File
	file_v1_bugu_error_proto_rawDesc = nil
	file_v1_bugu_error_proto_goTypes = nil
	file_v1_bugu_error_proto_depIdxs = nil
}

```

`api/bugu/service/v1/bugu_error.pb.validate.go`:

```go
// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: v1/bugu_error.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

```

`api/bugu/service/v1/bugu_error.proto`:

```proto
syntax = "proto3";

package bugu.service.v1;

import "errors/errors.proto";

option go_package = "github.com/hominsu/bugu/service/v1;v1";
option java_multiple_files = true;

enum UserServiceErrorReason {
    option (errors.default_code) = 500;

    UNKNOWN_ERROR = 0;
    INTERNAL_SERVER_ERROR = 1 [(errors.code) = 404];
    NOT_FOUND_ERROR = 2 [(errors.code) = 404];
    LOGIN_FAILED = 3;
    REGISTER_FAILED = 4;
    CREATE_FAILED = 5;
    CREATE_CONFLICT = 6;
    UUID_GENERATE_FAILED = 7;
    UUID_PARSE_FAILED = 8;
    JSON_UNMARSHAL_FAILED = 9;
}
```

`api/bugu/service/v1/bugu_error.swagger.json`:

```json
{
  "swagger": "2.0",
  "info": {
    "title": "v1/bugu_error.proto",
    "version": "version not set"
  },
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    }
  }
}

```

`api/bugu/service/v1/bugu_error_errors.pb.go`:

```go
// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package v1

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

func IsUnknownError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_UNKNOWN_ERROR.String() && e.Code == 500
}

func ErrorUnknownError(format string, args ...interface{}) *errors.Error {
	return errors.New(500, UserServiceErrorReason_UNKNOWN_ERROR.String(), fmt.Sprintf(format, args...))
}

func IsInternalServerError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_INTERNAL_SERVER_ERROR.String() && e.Code == 404
}

func ErrorInternalServerError(format string, args ...interface{}) *errors.Error {
	return errors.New(404, UserServiceErrorReason_INTERNAL_SERVER_ERROR.String(), fmt.Sprintf(format, args...))
}

func IsNotFoundError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_NOT_FOUND_ERROR.String() && e.Code == 404
}

func ErrorNotFoundError(format string, args ...interface{}) *errors.Error {
	return errors.New(404, UserServiceErrorReason_NOT_FOUND_ERROR.String(), fmt.Sprintf(format, args...))
}

func IsLoginFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_LOGIN_FAILED.String() && e.Code == 500
}

func ErrorLoginFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, UserServiceErrorReason_LOGIN_FAILED.String(), fmt.Sprintf(format, args...))
}

func IsRegisterFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_REGISTER_FAILED.String() && e.Code == 500
}

func ErrorRegisterFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, UserServiceErrorReason_REGISTER_FAILED.String(), fmt.Sprintf(format, args...))
}

func IsCreateFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_CREATE_FAILED.String() && e.Code == 500
}

func ErrorCreateFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, UserServiceErrorReason_CREATE_FAILED.String(), fmt.Sprintf(format, args...))
}

func IsCreateConflict(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_CREATE_CONFLICT.String() && e.Code == 500
}

func ErrorCreateConflict(format string, args ...interface{}) *errors.Error {
	return errors.New(500, UserServiceErrorReason_CREATE_CONFLICT.String(), fmt.Sprintf(format, args...))
}

func IsUuidGenerateFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_UUID_GENERATE_FAILED.String() && e.Code == 500
}

func ErrorUuidGenerateFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, UserServiceErrorReason_UUID_GENERATE_FAILED.String(), fmt.Sprintf(format, args...))
}

func IsUuidParseFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_UUID_PARSE_FAILED.String() && e.Code == 500
}

func ErrorUuidParseFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, UserServiceErrorReason_UUID_PARSE_FAILED.String(), fmt.Sprintf(format, args...))
}

func IsJsonUnmarshalFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserServiceErrorReason_JSON_UNMARSHAL_FAILED.String() && e.Code == 500
}

func ErrorJsonUnmarshalFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(500, UserServiceErrorReason_JSON_UNMARSHAL_FAILED.String(), fmt.Sprintf(format, args...))
}

```

`api/bugu/service/v1/bugu_file.go`:

```go
package v1

import (
	nethttp "net/http"

	"github.com/go-kratos/kratos/v2/transport/http"
)

type BuguFileServer interface {
	UploadFile(http.Context) error
	DownloadFile(http.Context) error
	mustEmbedUnimplementedBuguFileServer()
}

// UnimplementedBuguFileServer must be embedded to have forward compatible implementations.
type UnimplementedBuguFileServer struct{}

func (UnimplementedBuguFileServer) UploadFile(ctx http.Context) error {
	return ctx.String(nethttp.StatusInternalServerError, "method UploadFile not implemented")
}

func (UnimplementedBuguFileServer) DownloadFile(ctx http.Context) error {
	return ctx.String(nethttp.StatusInternalServerError, "method DownloadFile not implemented")
}

func (UnimplementedBuguFileServer) mustEmbedUnimplementedBuguFileServer() {}

type UnsafeBuguFileServer interface {
	mustEmbedUnimplementedBuguFileServer()
}

```

`api/bugu/service/v1/bugu_file_http.go`:

```go
package v1

import (
	"github.com/go-kratos/kratos/v2/transport/http"
)

type BuguFileHTTPServer interface {
	UploadFile(http.Context) error
	DownloadFile(http.Context) error
}

func RegisterBuguFileHTTPServer(s *http.Server, srv BuguFileHTTPServer, filter ...http.FilterFunc) {
	r := s.Route("/", filter...)
	r.POST("/v1/user/{userId}/files", BuguUploadFileHTTPHandler(srv))
	r.GET("/v1/user/{userId}/file/{fileId}", BuguDownloadFileHTTPHandler(srv))
}

func BuguUploadFileHTTPHandler(srv BuguFileHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		return srv.UploadFile(ctx)
	}
}

func BuguDownloadFileHTTPHandler(srv BuguFileHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		return srv.DownloadFile(ctx)
	}
}

```

`api/bugu/service/v1/bugu_grpc.pb.go`:

```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: v1/bugu.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BuguClient is the client API for Bugu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuguClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error)
	GetCurrentUser(ctx context.Context, in *GetCurrentUserRequest, opts ...grpc.CallOption) (*GetCurrentUserReply, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserReply, error)
	GetFileMeta(ctx context.Context, in *GetFileMetaRequest, opts ...grpc.CallOption) (*GetFileMetaReply, error)
	GetFileMetaByUserId(ctx context.Context, in *GetFileMetaByUserIdRequest, opts ...grpc.CallOption) (*GetFileMetaByUserIdReply, error)
	DeleteFileMetadata(ctx context.Context, in *DeleteFileMetadataRequest, opts ...grpc.CallOption) (*DeleteFileMetadataReply, error)
	Detect(ctx context.Context, in *DetectRequest, opts ...grpc.CallOption) (*DetectReply, error)
	Confusion(ctx context.Context, in *ConfusionRequest, opts ...grpc.CallOption) (*ConfusionReply, error)
	Packer(ctx context.Context, in *PackerRequest, opts ...grpc.CallOption) (*PackerReply, error)
	GetArtifactMetadata(ctx context.Context, in *GetArtifactMetadataRequest, opts ...grpc.CallOption) (*GetArtifactMetadataReply, error)
	GetArtifactMetadataByFileId(ctx context.Context, in *GetArtifactMetadataByFileIdRequest, opts ...grpc.CallOption) (*GetArtifactMetadataByFileIdReply, error)
	DeleteArtifactMetadata(ctx context.Context, in *DeleteArtifactMetadataRequest, opts ...grpc.CallOption) (*DeleteArtifactMetadataReply, error)
}

type buguClient struct {
	cc grpc.ClientConnInterface
}

func NewBuguClient(cc grpc.ClientConnInterface) BuguClient {
	return &buguClient{cc}
}

func (c *buguClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error) {
	out := new(RegisterReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginReply, error) {
	out := new(LoginReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) GetCurrentUser(ctx context.Context, in *GetCurrentUserRequest, opts ...grpc.CallOption) (*GetCurrentUserReply, error) {
	out := new(GetCurrentUserReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/GetCurrentUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserReply, error) {
	out := new(UpdateUserReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) GetFileMeta(ctx context.Context, in *GetFileMetaRequest, opts ...grpc.CallOption) (*GetFileMetaReply, error) {
	out := new(GetFileMetaReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/GetFileMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) GetFileMetaByUserId(ctx context.Context, in *GetFileMetaByUserIdRequest, opts ...grpc.CallOption) (*GetFileMetaByUserIdReply, error) {
	out := new(GetFileMetaByUserIdReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/GetFileMetaByUserId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) DeleteFileMetadata(ctx context.Context, in *DeleteFileMetadataRequest, opts ...grpc.CallOption) (*DeleteFileMetadataReply, error) {
	out := new(DeleteFileMetadataReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/DeleteFileMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) Detect(ctx context.Context, in *DetectRequest, opts ...grpc.CallOption) (*DetectReply, error) {
	out := new(DetectReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) Confusion(ctx context.Context, in *ConfusionRequest, opts ...grpc.CallOption) (*ConfusionReply, error) {
	out := new(ConfusionReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/Confusion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) Packer(ctx context.Context, in *PackerRequest, opts ...grpc.CallOption) (*PackerReply, error) {
	out := new(PackerReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/Packer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) GetArtifactMetadata(ctx context.Context, in *GetArtifactMetadataRequest, opts ...grpc.CallOption) (*GetArtifactMetadataReply, error) {
	out := new(GetArtifactMetadataReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/GetArtifactMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) GetArtifactMetadataByFileId(ctx context.Context, in *GetArtifactMetadataByFileIdRequest, opts ...grpc.CallOption) (*GetArtifactMetadataByFileIdReply, error) {
	out := new(GetArtifactMetadataByFileIdReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/GetArtifactMetadataByFileId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buguClient) DeleteArtifactMetadata(ctx context.Context, in *DeleteArtifactMetadataRequest, opts ...grpc.CallOption) (*DeleteArtifactMetadataReply, error) {
	out := new(DeleteArtifactMetadataReply)
	err := c.cc.Invoke(ctx, "/bugu.service.v1.Bugu/DeleteArtifactMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuguServer is the server API for Bugu service.
// All implementations must embed UnimplementedBuguServer
// for forward compatibility
type BuguServer interface {
	Register(context.Context, *RegisterRequest) (*RegisterReply, error)
	Login(context.Context, *LoginRequest) (*LoginReply, error)
	GetCurrentUser(context.Context, *GetCurrentUserRequest) (*GetCurrentUserReply, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserReply, error)
	GetFileMeta(context.Context, *GetFileMetaRequest) (*GetFileMetaReply, error)
	GetFileMetaByUserId(context.Context, *GetFileMetaByUserIdRequest) (*GetFileMetaByUserIdReply, error)
	DeleteFileMetadata(context.Context, *DeleteFileMetadataRequest) (*DeleteFileMetadataReply, error)
	Detect(context.Context, *DetectRequest) (*DetectReply, error)
	Confusion(context.Context, *ConfusionRequest) (*ConfusionReply, error)
	Packer(context.Context, *PackerRequest) (*PackerReply, error)
	GetArtifactMetadata(context.Context, *GetArtifactMetadataRequest) (*GetArtifactMetadataReply, error)
	GetArtifactMetadataByFileId(context.Context, *GetArtifactMetadataByFileIdRequest) (*GetArtifactMetadataByFileIdReply, error)
	DeleteArtifactMetadata(context.Context, *DeleteArtifactMetadataRequest) (*DeleteArtifactMetadataReply, error)
	mustEmbedUnimplementedBuguServer()
}

// UnimplementedBuguServer must be embedded to have forward compatible implementations.
type UnimplementedBuguServer struct {
}

func (UnimplementedBuguServer) Register(context.Context, *RegisterRequest) (*RegisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedBuguServer) Login(context.Context, *LoginRequest) (*LoginReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedBuguServer) GetCurrentUser(context.Context, *GetCurrentUserRequest) (*GetCurrentUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentUser not implemented")
}
func (UnimplementedBuguServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedBuguServer) GetFileMeta(context.Context, *GetFileMetaRequest) (*GetFileMetaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileMeta not implemented")
}
func (UnimplementedBuguServer) GetFileMetaByUserId(context.Context, *GetFileMetaByUserIdRequest) (*GetFileMetaByUserIdReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileMetaByUserId not implemented")
}
func (UnimplementedBuguServer) DeleteFileMetadata(context.Context, *DeleteFileMetadataRequest) (*DeleteFileMetadataReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFileMetadata not implemented")
}
func (UnimplementedBuguServer) Detect(context.Context, *DetectRequest) (*DetectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedBuguServer) Confusion(context.Context, *ConfusionRequest) (*ConfusionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Confusion not implemented")
}
func (UnimplementedBuguServer) Packer(context.Context, *PackerRequest) (*PackerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Packer not implemented")
}
func (UnimplementedBuguServer) GetArtifactMetadata(context.Context, *GetArtifactMetadataRequest) (*GetArtifactMetadataReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArtifactMetadata not implemented")
}
func (UnimplementedBuguServer) GetArtifactMetadataByFileId(context.Context, *GetArtifactMetadataByFileIdRequest) (*GetArtifactMetadataByFileIdReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArtifactMetadataByFileId not implemented")
}
func (UnimplementedBuguServer) DeleteArtifactMetadata(context.Context, *DeleteArtifactMetadataRequest) (*DeleteArtifactMetadataReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteArtifactMetadata not implemented")
}
func (UnimplementedBuguServer) mustEmbedUnimplementedBuguServer() {}

// UnsafeBuguServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuguServer will
// result in compilation errors.
type UnsafeBuguServer interface {
	mustEmbedUnimplementedBuguServer()
}

func RegisterBuguServer(s grpc.ServiceRegistrar, srv BuguServer) {
	s.RegisterService(&Bugu_ServiceDesc, srv)
}

func _Bugu_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_GetCurrentUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).GetCurrentUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/GetCurrentUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).GetCurrentUser(ctx, req.(*GetCurrentUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_GetFileMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).GetFileMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/GetFileMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).GetFileMeta(ctx, req.(*GetFileMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_GetFileMetaByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileMetaByUserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).GetFileMetaByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/GetFileMetaByUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).GetFileMetaByUserId(ctx, req.(*GetFileMetaByUserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_DeleteFileMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).DeleteFileMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/DeleteFileMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).DeleteFileMetadata(ctx, req.(*DeleteFileMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).Detect(ctx, req.(*DetectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_Confusion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfusionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).Confusion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/Confusion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).Confusion(ctx, req.(*ConfusionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_Packer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).Packer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/Packer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).Packer(ctx, req.(*PackerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_GetArtifactMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).GetArtifactMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/GetArtifactMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).GetArtifactMetadata(ctx, req.(*GetArtifactMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_GetArtifactMetadataByFileId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactMetadataByFileIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).GetArtifactMetadataByFileId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/GetArtifactMetadataByFileId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).GetArtifactMetadataByFileId(ctx, req.(*GetArtifactMetadataByFileIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bugu_DeleteArtifactMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteArtifactMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguServer).DeleteArtifactMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu.service.v1.Bugu/DeleteArtifactMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguServer).DeleteArtifactMetadata(ctx, req.(*DeleteArtifactMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Bugu_ServiceDesc is the grpc.ServiceDesc for Bugu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Bugu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bugu.service.v1.Bugu",
	HandlerType: (*BuguServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Bugu_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Bugu_Login_Handler,
		},
		{
			MethodName: "GetCurrentUser",
			Handler:    _Bugu_GetCurrentUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _Bugu_UpdateUser_Handler,
		},
		{
			MethodName: "GetFileMeta",
			Handler:    _Bugu_GetFileMeta_Handler,
		},
		{
			MethodName: "GetFileMetaByUserId",
			Handler:    _Bugu_GetFileMetaByUserId_Handler,
		},
		{
			MethodName: "DeleteFileMetadata",
			Handler:    _Bugu_DeleteFileMetadata_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _Bugu_Detect_Handler,
		},
		{
			MethodName: "Confusion",
			Handler:    _Bugu_Confusion_Handler,
		},
		{
			MethodName: "Packer",
			Handler:    _Bugu_Packer_Handler,
		},
		{
			MethodName: "GetArtifactMetadata",
			Handler:    _Bugu_GetArtifactMetadata_Handler,
		},
		{
			MethodName: "GetArtifactMetadataByFileId",
			Handler:    _Bugu_GetArtifactMetadataByFileId_Handler,
		},
		{
			MethodName: "DeleteArtifactMetadata",
			Handler:    _Bugu_DeleteArtifactMetadata_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/bugu.proto",
}

```

`api/bugu/service/v1/bugu_http.pb.go`:

```go
// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.2.2

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type BuguHTTPServer interface {
	Confusion(context.Context, *ConfusionRequest) (*ConfusionReply, error)
	DeleteArtifactMetadata(context.Context, *DeleteArtifactMetadataRequest) (*DeleteArtifactMetadataReply, error)
	DeleteFileMetadata(context.Context, *DeleteFileMetadataRequest) (*DeleteFileMetadataReply, error)
	Detect(context.Context, *DetectRequest) (*DetectReply, error)
	GetArtifactMetadata(context.Context, *GetArtifactMetadataRequest) (*GetArtifactMetadataReply, error)
	GetArtifactMetadataByFileId(context.Context, *GetArtifactMetadataByFileIdRequest) (*GetArtifactMetadataByFileIdReply, error)
	GetCurrentUser(context.Context, *GetCurrentUserRequest) (*GetCurrentUserReply, error)
	GetFileMeta(context.Context, *GetFileMetaRequest) (*GetFileMetaReply, error)
	GetFileMetaByUserId(context.Context, *GetFileMetaByUserIdRequest) (*GetFileMetaByUserIdReply, error)
	Login(context.Context, *LoginRequest) (*LoginReply, error)
	Packer(context.Context, *PackerRequest) (*PackerReply, error)
	Register(context.Context, *RegisterRequest) (*RegisterReply, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserReply, error)
}

func RegisterBuguHTTPServer(s *http.Server, srv BuguHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/users", _Bugu_Register0_HTTP_Handler(srv))
	r.POST("/v1/users/login", _Bugu_Login0_HTTP_Handler(srv))
	r.GET("/v1/user/{id}", _Bugu_GetCurrentUser0_HTTP_Handler(srv))
	r.PUT("/v1/users", _Bugu_UpdateUser0_HTTP_Handler(srv))
	r.GET("/v1/user/{user_id}/file/{file_id}/metadata", _Bugu_GetFileMeta0_HTTP_Handler(srv))
	r.GET("/v1/user/{user_id}/files", _Bugu_GetFileMetaByUserId0_HTTP_Handler(srv))
	r.DELETE("/v1/user/{user_id}/file/{file_id}/metadata", _Bugu_DeleteFileMetadata0_HTTP_Handler(srv))
	r.POST("/v1/user/file/detect", _Bugu_Detect0_HTTP_Handler(srv))
	r.GET("/v1/user/{user_id}/file/{file_id}/detect", _Bugu_Detect1_HTTP_Handler(srv))
	r.POST("/v1/user/file/confusion", _Bugu_Confusion0_HTTP_Handler(srv))
	r.GET("/v1/user/{user_id}/file/{file_id}/confusion", _Bugu_Confusion1_HTTP_Handler(srv))
	r.POST("/v1/user/file/packer", _Bugu_Packer0_HTTP_Handler(srv))
	r.GET("/v1/user/{user_id}/file/{file_id}/packer", _Bugu_Packer1_HTTP_Handler(srv))
	r.GET("/v1/user/{user_id}/artifact/{artifact_id}/metadata", _Bugu_GetArtifactMetadata0_HTTP_Handler(srv))
	r.GET("/v1/user/{user_id}/artifact/file/{file_id}", _Bugu_GetArtifactMetadataByFileId0_HTTP_Handler(srv))
	r.DELETE("/v1/user/{user_id}/artifact/{artifact_id}/metadata", _Bugu_DeleteArtifactMetadata0_HTTP_Handler(srv))
}

func _Bugu_Register0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RegisterRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/Register")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Register(ctx, req.(*RegisterRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RegisterReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_Login0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LoginRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/Login")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Login(ctx, req.(*LoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LoginReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_GetCurrentUser0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetCurrentUserRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/GetCurrentUser")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetCurrentUser(ctx, req.(*GetCurrentUserRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetCurrentUserReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_UpdateUser0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateUserRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/UpdateUser")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateUser(ctx, req.(*UpdateUserRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateUserReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_GetFileMeta0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetFileMetaRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/GetFileMeta")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFileMeta(ctx, req.(*GetFileMetaRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetFileMetaReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_GetFileMetaByUserId0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetFileMetaByUserIdRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/GetFileMetaByUserId")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetFileMetaByUserId(ctx, req.(*GetFileMetaByUserIdRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetFileMetaByUserIdReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_DeleteFileMetadata0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteFileMetadataRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/DeleteFileMetadata")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteFileMetadata(ctx, req.(*DeleteFileMetadataRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteFileMetadataReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_Detect0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DetectRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/Detect")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Detect(ctx, req.(*DetectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DetectReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_Detect1_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DetectRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/Detect")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Detect(ctx, req.(*DetectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DetectReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_Confusion0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ConfusionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/Confusion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Confusion(ctx, req.(*ConfusionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ConfusionReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_Confusion1_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ConfusionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/Confusion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Confusion(ctx, req.(*ConfusionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ConfusionReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_Packer0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PackerRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/Packer")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Packer(ctx, req.(*PackerRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*PackerReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_Packer1_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PackerRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/Packer")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Packer(ctx, req.(*PackerRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*PackerReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_GetArtifactMetadata0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetArtifactMetadataRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/GetArtifactMetadata")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetArtifactMetadata(ctx, req.(*GetArtifactMetadataRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetArtifactMetadataReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_GetArtifactMetadataByFileId0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetArtifactMetadataByFileIdRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/GetArtifactMetadataByFileId")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetArtifactMetadataByFileId(ctx, req.(*GetArtifactMetadataByFileIdRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetArtifactMetadataByFileIdReply)
		return ctx.Result(200, reply)
	}
}

func _Bugu_DeleteArtifactMetadata0_HTTP_Handler(srv BuguHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteArtifactMetadataRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/bugu.service.v1.Bugu/DeleteArtifactMetadata")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteArtifactMetadata(ctx, req.(*DeleteArtifactMetadataRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteArtifactMetadataReply)
		return ctx.Result(200, reply)
	}
}

type BuguHTTPClient interface {
	Confusion(ctx context.Context, req *ConfusionRequest, opts ...http.CallOption) (rsp *ConfusionReply, err error)
	DeleteArtifactMetadata(ctx context.Context, req *DeleteArtifactMetadataRequest, opts ...http.CallOption) (rsp *DeleteArtifactMetadataReply, err error)
	DeleteFileMetadata(ctx context.Context, req *DeleteFileMetadataRequest, opts ...http.CallOption) (rsp *DeleteFileMetadataReply, err error)
	Detect(ctx context.Context, req *DetectRequest, opts ...http.CallOption) (rsp *DetectReply, err error)
	GetArtifactMetadata(ctx context.Context, req *GetArtifactMetadataRequest, opts ...http.CallOption) (rsp *GetArtifactMetadataReply, err error)
	GetArtifactMetadataByFileId(ctx context.Context, req *GetArtifactMetadataByFileIdRequest, opts ...http.CallOption) (rsp *GetArtifactMetadataByFileIdReply, err error)
	GetCurrentUser(ctx context.Context, req *GetCurrentUserRequest, opts ...http.CallOption) (rsp *GetCurrentUserReply, err error)
	GetFileMeta(ctx context.Context, req *GetFileMetaRequest, opts ...http.CallOption) (rsp *GetFileMetaReply, err error)
	GetFileMetaByUserId(ctx context.Context, req *GetFileMetaByUserIdRequest, opts ...http.CallOption) (rsp *GetFileMetaByUserIdReply, err error)
	Login(ctx context.Context, req *LoginRequest, opts ...http.CallOption) (rsp *LoginReply, err error)
	Packer(ctx context.Context, req *PackerRequest, opts ...http.CallOption) (rsp *PackerReply, err error)
	Register(ctx context.Context, req *RegisterRequest, opts ...http.CallOption) (rsp *RegisterReply, err error)
	UpdateUser(ctx context.Context, req *UpdateUserRequest, opts ...http.CallOption) (rsp *UpdateUserReply, err error)
}

type BuguHTTPClientImpl struct {
	cc *http.Client
}

func NewBuguHTTPClient(client *http.Client) BuguHTTPClient {
	return &BuguHTTPClientImpl{client}
}

func (c *BuguHTTPClientImpl) Confusion(ctx context.Context, in *ConfusionRequest, opts ...http.CallOption) (*ConfusionReply, error) {
	var out ConfusionReply
	pattern := "/v1/user/{user_id}/file/{file_id}/confusion"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/Confusion"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) DeleteArtifactMetadata(ctx context.Context, in *DeleteArtifactMetadataRequest, opts ...http.CallOption) (*DeleteArtifactMetadataReply, error) {
	var out DeleteArtifactMetadataReply
	pattern := "/v1/user/{user_id}/artifact/{artifact_id}/metadata"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/DeleteArtifactMetadata"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) DeleteFileMetadata(ctx context.Context, in *DeleteFileMetadataRequest, opts ...http.CallOption) (*DeleteFileMetadataReply, error) {
	var out DeleteFileMetadataReply
	pattern := "/v1/user/{user_id}/file/{file_id}/metadata"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/DeleteFileMetadata"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) Detect(ctx context.Context, in *DetectRequest, opts ...http.CallOption) (*DetectReply, error) {
	var out DetectReply
	pattern := "/v1/user/{user_id}/file/{file_id}/detect"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/Detect"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) GetArtifactMetadata(ctx context.Context, in *GetArtifactMetadataRequest, opts ...http.CallOption) (*GetArtifactMetadataReply, error) {
	var out GetArtifactMetadataReply
	pattern := "/v1/user/{user_id}/artifact/{artifact_id}/metadata"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/GetArtifactMetadata"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) GetArtifactMetadataByFileId(ctx context.Context, in *GetArtifactMetadataByFileIdRequest, opts ...http.CallOption) (*GetArtifactMetadataByFileIdReply, error) {
	var out GetArtifactMetadataByFileIdReply
	pattern := "/v1/user/{user_id}/artifact/file/{file_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/GetArtifactMetadataByFileId"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) GetCurrentUser(ctx context.Context, in *GetCurrentUserRequest, opts ...http.CallOption) (*GetCurrentUserReply, error) {
	var out GetCurrentUserReply
	pattern := "/v1/user/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/GetCurrentUser"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) GetFileMeta(ctx context.Context, in *GetFileMetaRequest, opts ...http.CallOption) (*GetFileMetaReply, error) {
	var out GetFileMetaReply
	pattern := "/v1/user/{user_id}/file/{file_id}/metadata"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/GetFileMeta"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) GetFileMetaByUserId(ctx context.Context, in *GetFileMetaByUserIdRequest, opts ...http.CallOption) (*GetFileMetaByUserIdReply, error) {
	var out GetFileMetaByUserIdReply
	pattern := "/v1/user/{user_id}/files"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/GetFileMetaByUserId"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) Login(ctx context.Context, in *LoginRequest, opts ...http.CallOption) (*LoginReply, error) {
	var out LoginReply
	pattern := "/v1/users/login"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/Login"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) Packer(ctx context.Context, in *PackerRequest, opts ...http.CallOption) (*PackerReply, error) {
	var out PackerReply
	pattern := "/v1/user/{user_id}/file/{file_id}/packer"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/Packer"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) Register(ctx context.Context, in *RegisterRequest, opts ...http.CallOption) (*RegisterReply, error) {
	var out RegisterReply
	pattern := "/v1/users"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/Register"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BuguHTTPClientImpl) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...http.CallOption) (*UpdateUserReply, error) {
	var out UpdateUserReply
	pattern := "/v1/users"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/bugu.service.v1.Bugu/UpdateUser"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

```

`api/bugu/service/v1/cpp/bugu.grpc.pb.cc`:

```cc
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bugu.proto

#include "bugu.pb.h"
#include "bugu.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace bugu {
namespace service {
namespace v1 {

static const char* Bugu_method_names[] = {
  "/bugu.service.v1.Bugu/Register",
  "/bugu.service.v1.Bugu/Login",
  "/bugu.service.v1.Bugu/GetCurrentUser",
  "/bugu.service.v1.Bugu/UpdateUser",
  "/bugu.service.v1.Bugu/GetFileMeta",
  "/bugu.service.v1.Bugu/GetFileMetaByUserId",
  "/bugu.service.v1.Bugu/DeleteFileMetadata",
  "/bugu.service.v1.Bugu/Detect",
  "/bugu.service.v1.Bugu/Confusion",
  "/bugu.service.v1.Bugu/Packer",
  "/bugu.service.v1.Bugu/GetArtifactMetadata",
  "/bugu.service.v1.Bugu/GetArtifactMetadataByFileId",
  "/bugu.service.v1.Bugu/DeleteArtifactMetadata",
};

std::unique_ptr< Bugu::Stub> Bugu::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Bugu::Stub> stub(new Bugu::Stub(channel, options));
  return stub;
}

Bugu::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Register_(Bugu_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Login_(Bugu_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetCurrentUser_(Bugu_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_UpdateUser_(Bugu_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetFileMeta_(Bugu_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetFileMetaByUserId_(Bugu_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DeleteFileMetadata_(Bugu_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Detect_(Bugu_method_names[7], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Confusion_(Bugu_method_names[8], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Packer_(Bugu_method_names[9], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetArtifactMetadata_(Bugu_method_names[10], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetArtifactMetadataByFileId_(Bugu_method_names[11], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DeleteArtifactMetadata_(Bugu_method_names[12], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Bugu::Stub::Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::bugu::service::v1::RegisterReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::RegisterRequest, ::bugu::service::v1::RegisterReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Register_, context, request, response);
}

void Bugu::Stub::async::Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::RegisterRequest, ::bugu::service::v1::RegisterReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Register_, context, request, response, std::move(f));
}

void Bugu::Stub::async::Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Register_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::RegisterReply>* Bugu::Stub::PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::RegisterReply, ::bugu::service::v1::RegisterRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Register_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::RegisterReply>* Bugu::Stub::AsyncRegisterRaw(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRegisterRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::bugu::service::v1::LoginReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::LoginRequest, ::bugu::service::v1::LoginReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Login_, context, request, response);
}

void Bugu::Stub::async::Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::LoginRequest, ::bugu::service::v1::LoginReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Login_, context, request, response, std::move(f));
}

void Bugu::Stub::async::Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Login_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::LoginReply>* Bugu::Stub::PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::LoginReply, ::bugu::service::v1::LoginRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Login_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::LoginReply>* Bugu::Stub::AsyncLoginRaw(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncLoginRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::bugu::service::v1::GetCurrentUserReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::GetCurrentUserRequest, ::bugu::service::v1::GetCurrentUserReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetCurrentUser_, context, request, response);
}

void Bugu::Stub::async::GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::GetCurrentUserRequest, ::bugu::service::v1::GetCurrentUserReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetCurrentUser_, context, request, response, std::move(f));
}

void Bugu::Stub::async::GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetCurrentUser_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetCurrentUserReply>* Bugu::Stub::PrepareAsyncGetCurrentUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::GetCurrentUserReply, ::bugu::service::v1::GetCurrentUserRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetCurrentUser_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetCurrentUserReply>* Bugu::Stub::AsyncGetCurrentUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetCurrentUserRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::bugu::service::v1::UpdateUserReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::UpdateUserRequest, ::bugu::service::v1::UpdateUserReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_UpdateUser_, context, request, response);
}

void Bugu::Stub::async::UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::UpdateUserRequest, ::bugu::service::v1::UpdateUserReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_UpdateUser_, context, request, response, std::move(f));
}

void Bugu::Stub::async::UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_UpdateUser_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::UpdateUserReply>* Bugu::Stub::PrepareAsyncUpdateUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::UpdateUserReply, ::bugu::service::v1::UpdateUserRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_UpdateUser_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::UpdateUserReply>* Bugu::Stub::AsyncUpdateUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncUpdateUserRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::bugu::service::v1::GetFileMetaReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::GetFileMetaRequest, ::bugu::service::v1::GetFileMetaReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetFileMeta_, context, request, response);
}

void Bugu::Stub::async::GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::GetFileMetaRequest, ::bugu::service::v1::GetFileMetaReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetFileMeta_, context, request, response, std::move(f));
}

void Bugu::Stub::async::GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetFileMeta_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaReply>* Bugu::Stub::PrepareAsyncGetFileMetaRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::GetFileMetaReply, ::bugu::service::v1::GetFileMetaRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetFileMeta_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaReply>* Bugu::Stub::AsyncGetFileMetaRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetFileMetaRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::bugu::service::v1::GetFileMetaByUserIdReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::GetFileMetaByUserIdRequest, ::bugu::service::v1::GetFileMetaByUserIdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetFileMetaByUserId_, context, request, response);
}

void Bugu::Stub::async::GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::GetFileMetaByUserIdRequest, ::bugu::service::v1::GetFileMetaByUserIdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetFileMetaByUserId_, context, request, response, std::move(f));
}

void Bugu::Stub::async::GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetFileMetaByUserId_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaByUserIdReply>* Bugu::Stub::PrepareAsyncGetFileMetaByUserIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::GetFileMetaByUserIdReply, ::bugu::service::v1::GetFileMetaByUserIdRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetFileMetaByUserId_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaByUserIdReply>* Bugu::Stub::AsyncGetFileMetaByUserIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetFileMetaByUserIdRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::bugu::service::v1::DeleteFileMetadataReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::DeleteFileMetadataRequest, ::bugu::service::v1::DeleteFileMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_DeleteFileMetadata_, context, request, response);
}

void Bugu::Stub::async::DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::DeleteFileMetadataRequest, ::bugu::service::v1::DeleteFileMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DeleteFileMetadata_, context, request, response, std::move(f));
}

void Bugu::Stub::async::DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DeleteFileMetadata_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteFileMetadataReply>* Bugu::Stub::PrepareAsyncDeleteFileMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::DeleteFileMetadataReply, ::bugu::service::v1::DeleteFileMetadataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_DeleteFileMetadata_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteFileMetadataReply>* Bugu::Stub::AsyncDeleteFileMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncDeleteFileMetadataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::bugu::service::v1::DetectReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::DetectRequest, ::bugu::service::v1::DetectReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Detect_, context, request, response);
}

void Bugu::Stub::async::Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::DetectRequest, ::bugu::service::v1::DetectReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Detect_, context, request, response, std::move(f));
}

void Bugu::Stub::async::Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Detect_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DetectReply>* Bugu::Stub::PrepareAsyncDetectRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::DetectReply, ::bugu::service::v1::DetectRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Detect_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DetectReply>* Bugu::Stub::AsyncDetectRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncDetectRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::bugu::service::v1::ConfusionReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::ConfusionRequest, ::bugu::service::v1::ConfusionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Confusion_, context, request, response);
}

void Bugu::Stub::async::Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::ConfusionRequest, ::bugu::service::v1::ConfusionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Confusion_, context, request, response, std::move(f));
}

void Bugu::Stub::async::Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Confusion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::ConfusionReply>* Bugu::Stub::PrepareAsyncConfusionRaw(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::ConfusionReply, ::bugu::service::v1::ConfusionRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Confusion_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::ConfusionReply>* Bugu::Stub::AsyncConfusionRaw(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncConfusionRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::bugu::service::v1::PackerReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::PackerRequest, ::bugu::service::v1::PackerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Packer_, context, request, response);
}

void Bugu::Stub::async::Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::PackerRequest, ::bugu::service::v1::PackerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Packer_, context, request, response, std::move(f));
}

void Bugu::Stub::async::Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Packer_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::PackerReply>* Bugu::Stub::PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::PackerReply, ::bugu::service::v1::PackerRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Packer_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::PackerReply>* Bugu::Stub::AsyncPackerRaw(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPackerRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::bugu::service::v1::GetArtifactMetadataReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::GetArtifactMetadataRequest, ::bugu::service::v1::GetArtifactMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetArtifactMetadata_, context, request, response);
}

void Bugu::Stub::async::GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::GetArtifactMetadataRequest, ::bugu::service::v1::GetArtifactMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetArtifactMetadata_, context, request, response, std::move(f));
}

void Bugu::Stub::async::GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetArtifactMetadata_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataReply>* Bugu::Stub::PrepareAsyncGetArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::GetArtifactMetadataReply, ::bugu::service::v1::GetArtifactMetadataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetArtifactMetadata_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataReply>* Bugu::Stub::AsyncGetArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetArtifactMetadataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::bugu::service::v1::GetArtifactMetadataByFileIdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetArtifactMetadataByFileId_, context, request, response);
}

void Bugu::Stub::async::GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::bugu::service::v1::GetArtifactMetadataByFileIdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetArtifactMetadataByFileId_, context, request, response, std::move(f));
}

void Bugu::Stub::async::GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetArtifactMetadataByFileId_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* Bugu::Stub::PrepareAsyncGetArtifactMetadataByFileIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::GetArtifactMetadataByFileIdReply, ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetArtifactMetadataByFileId_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* Bugu::Stub::AsyncGetArtifactMetadataByFileIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetArtifactMetadataByFileIdRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Bugu::Stub::DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::bugu::service::v1::DeleteArtifactMetadataReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu::service::v1::DeleteArtifactMetadataRequest, ::bugu::service::v1::DeleteArtifactMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_DeleteArtifactMetadata_, context, request, response);
}

void Bugu::Stub::async::DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu::service::v1::DeleteArtifactMetadataRequest, ::bugu::service::v1::DeleteArtifactMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DeleteArtifactMetadata_, context, request, response, std::move(f));
}

void Bugu::Stub::async::DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DeleteArtifactMetadata_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteArtifactMetadataReply>* Bugu::Stub::PrepareAsyncDeleteArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu::service::v1::DeleteArtifactMetadataReply, ::bugu::service::v1::DeleteArtifactMetadataRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_DeleteArtifactMetadata_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteArtifactMetadataReply>* Bugu::Stub::AsyncDeleteArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncDeleteArtifactMetadataRaw(context, request, cq);
  result->StartCall();
  return result;
}

Bugu::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::RegisterRequest, ::bugu::service::v1::RegisterReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::RegisterRequest* req,
             ::bugu::service::v1::RegisterReply* resp) {
               return service->Register(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::LoginRequest, ::bugu::service::v1::LoginReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::LoginRequest* req,
             ::bugu::service::v1::LoginReply* resp) {
               return service->Login(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::GetCurrentUserRequest, ::bugu::service::v1::GetCurrentUserReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::GetCurrentUserRequest* req,
             ::bugu::service::v1::GetCurrentUserReply* resp) {
               return service->GetCurrentUser(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::UpdateUserRequest, ::bugu::service::v1::UpdateUserReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::UpdateUserRequest* req,
             ::bugu::service::v1::UpdateUserReply* resp) {
               return service->UpdateUser(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::GetFileMetaRequest, ::bugu::service::v1::GetFileMetaReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::GetFileMetaRequest* req,
             ::bugu::service::v1::GetFileMetaReply* resp) {
               return service->GetFileMeta(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::GetFileMetaByUserIdRequest, ::bugu::service::v1::GetFileMetaByUserIdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::GetFileMetaByUserIdRequest* req,
             ::bugu::service::v1::GetFileMetaByUserIdReply* resp) {
               return service->GetFileMetaByUserId(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::DeleteFileMetadataRequest, ::bugu::service::v1::DeleteFileMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::DeleteFileMetadataRequest* req,
             ::bugu::service::v1::DeleteFileMetadataReply* resp) {
               return service->DeleteFileMetadata(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::DetectRequest, ::bugu::service::v1::DetectReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::DetectRequest* req,
             ::bugu::service::v1::DetectReply* resp) {
               return service->Detect(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::ConfusionRequest, ::bugu::service::v1::ConfusionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::ConfusionRequest* req,
             ::bugu::service::v1::ConfusionReply* resp) {
               return service->Confusion(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::PackerRequest, ::bugu::service::v1::PackerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::PackerRequest* req,
             ::bugu::service::v1::PackerReply* resp) {
               return service->Packer(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::GetArtifactMetadataRequest, ::bugu::service::v1::GetArtifactMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::GetArtifactMetadataRequest* req,
             ::bugu::service::v1::GetArtifactMetadataReply* resp) {
               return service->GetArtifactMetadata(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::bugu::service::v1::GetArtifactMetadataByFileIdReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* req,
             ::bugu::service::v1::GetArtifactMetadataByFileIdReply* resp) {
               return service->GetArtifactMetadataByFileId(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Bugu_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Bugu::Service, ::bugu::service::v1::DeleteArtifactMetadataRequest, ::bugu::service::v1::DeleteArtifactMetadataReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](Bugu::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu::service::v1::DeleteArtifactMetadataRequest* req,
             ::bugu::service::v1::DeleteArtifactMetadataReply* resp) {
               return service->DeleteArtifactMetadata(ctx, req, resp);
             }, this)));
}

Bugu::Service::~Service() {
}

::grpc::Status Bugu::Service::Register(::grpc::ServerContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::Login(::grpc::ServerContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::GetCurrentUser(::grpc::ServerContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::UpdateUser(::grpc::ServerContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::GetFileMeta(::grpc::ServerContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::GetFileMetaByUserId(::grpc::ServerContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::DeleteFileMetadata(::grpc::ServerContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::Detect(::grpc::ServerContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::Confusion(::grpc::ServerContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::Packer(::grpc::ServerContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::GetArtifactMetadata(::grpc::ServerContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::GetArtifactMetadataByFileId(::grpc::ServerContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Bugu::Service::DeleteArtifactMetadata(::grpc::ServerContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace bugu
}  // namespace service
}  // namespace v1


```

`api/bugu/service/v1/cpp/bugu.grpc.pb.h`:

```h
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bugu.proto
#ifndef GRPC_bugu_2eproto__INCLUDED
#define GRPC_bugu_2eproto__INCLUDED

#include "bugu.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace bugu {
namespace service {
namespace v1 {

class Bugu final {
 public:
  static constexpr char const* service_full_name() {
    return "bugu.service.v1.Bugu";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::bugu::service::v1::RegisterReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::RegisterReply>> AsyncRegister(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::RegisterReply>>(AsyncRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::RegisterReply>> PrepareAsyncRegister(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::RegisterReply>>(PrepareAsyncRegisterRaw(context, request, cq));
    }
    virtual ::grpc::Status Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::bugu::service::v1::LoginReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::LoginReply>> AsyncLogin(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::LoginReply>>(AsyncLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::LoginReply>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::LoginReply>>(PrepareAsyncLoginRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::bugu::service::v1::GetCurrentUserReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetCurrentUserReply>> AsyncGetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetCurrentUserReply>>(AsyncGetCurrentUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetCurrentUserReply>> PrepareAsyncGetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetCurrentUserReply>>(PrepareAsyncGetCurrentUserRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::bugu::service::v1::UpdateUserReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::UpdateUserReply>> AsyncUpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::UpdateUserReply>>(AsyncUpdateUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::UpdateUserReply>> PrepareAsyncUpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::UpdateUserReply>>(PrepareAsyncUpdateUserRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::bugu::service::v1::GetFileMetaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaReply>> AsyncGetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaReply>>(AsyncGetFileMetaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaReply>> PrepareAsyncGetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaReply>>(PrepareAsyncGetFileMetaRaw(context, request, cq));
    }
    virtual ::grpc::Status GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::bugu::service::v1::GetFileMetaByUserIdReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaByUserIdReply>> AsyncGetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaByUserIdReply>>(AsyncGetFileMetaByUserIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaByUserIdReply>> PrepareAsyncGetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaByUserIdReply>>(PrepareAsyncGetFileMetaByUserIdRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::bugu::service::v1::DeleteFileMetadataReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteFileMetadataReply>> AsyncDeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteFileMetadataReply>>(AsyncDeleteFileMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteFileMetadataReply>> PrepareAsyncDeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteFileMetadataReply>>(PrepareAsyncDeleteFileMetadataRaw(context, request, cq));
    }
    virtual ::grpc::Status Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::bugu::service::v1::DetectReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DetectReply>> AsyncDetect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DetectReply>>(AsyncDetectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DetectReply>> PrepareAsyncDetect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DetectReply>>(PrepareAsyncDetectRaw(context, request, cq));
    }
    virtual ::grpc::Status Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::bugu::service::v1::ConfusionReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::ConfusionReply>> AsyncConfusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::ConfusionReply>>(AsyncConfusionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::ConfusionReply>> PrepareAsyncConfusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::ConfusionReply>>(PrepareAsyncConfusionRaw(context, request, cq));
    }
    virtual ::grpc::Status Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::bugu::service::v1::PackerReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::PackerReply>> AsyncPacker(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::PackerReply>>(AsyncPackerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::PackerReply>> PrepareAsyncPacker(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::PackerReply>>(PrepareAsyncPackerRaw(context, request, cq));
    }
    virtual ::grpc::Status GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::bugu::service::v1::GetArtifactMetadataReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataReply>> AsyncGetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataReply>>(AsyncGetArtifactMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataReply>> PrepareAsyncGetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataReply>>(PrepareAsyncGetArtifactMetadataRaw(context, request, cq));
    }
    virtual ::grpc::Status GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>> AsyncGetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>>(AsyncGetArtifactMetadataByFileIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>> PrepareAsyncGetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>>(PrepareAsyncGetArtifactMetadataByFileIdRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::bugu::service::v1::DeleteArtifactMetadataReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteArtifactMetadataReply>> AsyncDeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteArtifactMetadataReply>>(AsyncDeleteArtifactMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteArtifactMetadataReply>> PrepareAsyncDeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteArtifactMetadataReply>>(PrepareAsyncDeleteArtifactMetadataRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::RegisterReply>* AsyncRegisterRaw(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::RegisterReply>* PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::LoginReply>* AsyncLoginRaw(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::LoginReply>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetCurrentUserReply>* AsyncGetCurrentUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetCurrentUserReply>* PrepareAsyncGetCurrentUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::UpdateUserReply>* AsyncUpdateUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::UpdateUserReply>* PrepareAsyncUpdateUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaReply>* AsyncGetFileMetaRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaReply>* PrepareAsyncGetFileMetaRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaByUserIdReply>* AsyncGetFileMetaByUserIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetFileMetaByUserIdReply>* PrepareAsyncGetFileMetaByUserIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteFileMetadataReply>* AsyncDeleteFileMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteFileMetadataReply>* PrepareAsyncDeleteFileMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DetectReply>* AsyncDetectRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DetectReply>* PrepareAsyncDetectRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::ConfusionReply>* AsyncConfusionRaw(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::ConfusionReply>* PrepareAsyncConfusionRaw(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::PackerReply>* AsyncPackerRaw(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::PackerReply>* PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataReply>* AsyncGetArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataReply>* PrepareAsyncGetArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* AsyncGetArtifactMetadataByFileIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* PrepareAsyncGetArtifactMetadataByFileIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteArtifactMetadataReply>* AsyncDeleteArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu::service::v1::DeleteArtifactMetadataReply>* PrepareAsyncDeleteArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::bugu::service::v1::RegisterReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::RegisterReply>> AsyncRegister(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::RegisterReply>>(AsyncRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::RegisterReply>> PrepareAsyncRegister(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::RegisterReply>>(PrepareAsyncRegisterRaw(context, request, cq));
    }
    ::grpc::Status Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::bugu::service::v1::LoginReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::LoginReply>> AsyncLogin(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::LoginReply>>(AsyncLoginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::LoginReply>> PrepareAsyncLogin(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::LoginReply>>(PrepareAsyncLoginRaw(context, request, cq));
    }
    ::grpc::Status GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::bugu::service::v1::GetCurrentUserReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetCurrentUserReply>> AsyncGetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetCurrentUserReply>>(AsyncGetCurrentUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetCurrentUserReply>> PrepareAsyncGetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetCurrentUserReply>>(PrepareAsyncGetCurrentUserRaw(context, request, cq));
    }
    ::grpc::Status UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::bugu::service::v1::UpdateUserReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::UpdateUserReply>> AsyncUpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::UpdateUserReply>>(AsyncUpdateUserRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::UpdateUserReply>> PrepareAsyncUpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::UpdateUserReply>>(PrepareAsyncUpdateUserRaw(context, request, cq));
    }
    ::grpc::Status GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::bugu::service::v1::GetFileMetaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaReply>> AsyncGetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaReply>>(AsyncGetFileMetaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaReply>> PrepareAsyncGetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaReply>>(PrepareAsyncGetFileMetaRaw(context, request, cq));
    }
    ::grpc::Status GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::bugu::service::v1::GetFileMetaByUserIdReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaByUserIdReply>> AsyncGetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaByUserIdReply>>(AsyncGetFileMetaByUserIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaByUserIdReply>> PrepareAsyncGetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaByUserIdReply>>(PrepareAsyncGetFileMetaByUserIdRaw(context, request, cq));
    }
    ::grpc::Status DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::bugu::service::v1::DeleteFileMetadataReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteFileMetadataReply>> AsyncDeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteFileMetadataReply>>(AsyncDeleteFileMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteFileMetadataReply>> PrepareAsyncDeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteFileMetadataReply>>(PrepareAsyncDeleteFileMetadataRaw(context, request, cq));
    }
    ::grpc::Status Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::bugu::service::v1::DetectReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DetectReply>> AsyncDetect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DetectReply>>(AsyncDetectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DetectReply>> PrepareAsyncDetect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DetectReply>>(PrepareAsyncDetectRaw(context, request, cq));
    }
    ::grpc::Status Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::bugu::service::v1::ConfusionReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::ConfusionReply>> AsyncConfusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::ConfusionReply>>(AsyncConfusionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::ConfusionReply>> PrepareAsyncConfusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::ConfusionReply>>(PrepareAsyncConfusionRaw(context, request, cq));
    }
    ::grpc::Status Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::bugu::service::v1::PackerReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::PackerReply>> AsyncPacker(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::PackerReply>>(AsyncPackerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::PackerReply>> PrepareAsyncPacker(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::PackerReply>>(PrepareAsyncPackerRaw(context, request, cq));
    }
    ::grpc::Status GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::bugu::service::v1::GetArtifactMetadataReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataReply>> AsyncGetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataReply>>(AsyncGetArtifactMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataReply>> PrepareAsyncGetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataReply>>(PrepareAsyncGetArtifactMetadataRaw(context, request, cq));
    }
    ::grpc::Status GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>> AsyncGetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>>(AsyncGetArtifactMetadataByFileIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>> PrepareAsyncGetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>>(PrepareAsyncGetArtifactMetadataByFileIdRaw(context, request, cq));
    }
    ::grpc::Status DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::bugu::service::v1::DeleteArtifactMetadataReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteArtifactMetadataReply>> AsyncDeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteArtifactMetadataReply>>(AsyncDeleteArtifactMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteArtifactMetadataReply>> PrepareAsyncDeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteArtifactMetadataReply>>(PrepareAsyncDeleteArtifactMetadataRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response, std::function<void(::grpc::Status)>) override;
      void Register(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response, std::function<void(::grpc::Status)>) override;
      void Login(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response, std::function<void(::grpc::Status)>) override;
      void GetCurrentUser(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response, std::function<void(::grpc::Status)>) override;
      void UpdateUser(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response, std::function<void(::grpc::Status)>) override;
      void GetFileMeta(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response, std::function<void(::grpc::Status)>) override;
      void GetFileMetaByUserId(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response, std::function<void(::grpc::Status)>) override;
      void DeleteFileMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response, std::function<void(::grpc::Status)>) override;
      void Detect(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response, std::function<void(::grpc::Status)>) override;
      void Confusion(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response, std::function<void(::grpc::Status)>) override;
      void Packer(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response, std::function<void(::grpc::Status)>) override;
      void GetArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response, std::function<void(::grpc::Status)>) override;
      void GetArtifactMetadataByFileId(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response, std::function<void(::grpc::Status)>) override;
      void DeleteArtifactMetadata(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::RegisterReply>* AsyncRegisterRaw(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::RegisterReply>* PrepareAsyncRegisterRaw(::grpc::ClientContext* context, const ::bugu::service::v1::RegisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::LoginReply>* AsyncLoginRaw(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::LoginReply>* PrepareAsyncLoginRaw(::grpc::ClientContext* context, const ::bugu::service::v1::LoginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetCurrentUserReply>* AsyncGetCurrentUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetCurrentUserReply>* PrepareAsyncGetCurrentUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetCurrentUserRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::UpdateUserReply>* AsyncUpdateUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::UpdateUserReply>* PrepareAsyncUpdateUserRaw(::grpc::ClientContext* context, const ::bugu::service::v1::UpdateUserRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaReply>* AsyncGetFileMetaRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaReply>* PrepareAsyncGetFileMetaRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaByUserIdReply>* AsyncGetFileMetaByUserIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetFileMetaByUserIdReply>* PrepareAsyncGetFileMetaByUserIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteFileMetadataReply>* AsyncDeleteFileMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteFileMetadataReply>* PrepareAsyncDeleteFileMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DetectReply>* AsyncDetectRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DetectReply>* PrepareAsyncDetectRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::ConfusionReply>* AsyncConfusionRaw(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::ConfusionReply>* PrepareAsyncConfusionRaw(::grpc::ClientContext* context, const ::bugu::service::v1::ConfusionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::PackerReply>* AsyncPackerRaw(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::PackerReply>* PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::bugu::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataReply>* AsyncGetArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataReply>* PrepareAsyncGetArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* AsyncGetArtifactMetadataByFileIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* PrepareAsyncGetArtifactMetadataByFileIdRaw(::grpc::ClientContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteArtifactMetadataReply>* AsyncDeleteArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu::service::v1::DeleteArtifactMetadataReply>* PrepareAsyncDeleteArtifactMetadataRaw(::grpc::ClientContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Register_;
    const ::grpc::internal::RpcMethod rpcmethod_Login_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCurrentUser_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateUser_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFileMeta_;
    const ::grpc::internal::RpcMethod rpcmethod_GetFileMetaByUserId_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteFileMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_Detect_;
    const ::grpc::internal::RpcMethod rpcmethod_Confusion_;
    const ::grpc::internal::RpcMethod rpcmethod_Packer_;
    const ::grpc::internal::RpcMethod rpcmethod_GetArtifactMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_GetArtifactMetadataByFileId_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteArtifactMetadata_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Register(::grpc::ServerContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response);
    virtual ::grpc::Status Login(::grpc::ServerContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response);
    virtual ::grpc::Status GetCurrentUser(::grpc::ServerContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response);
    virtual ::grpc::Status UpdateUser(::grpc::ServerContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response);
    virtual ::grpc::Status GetFileMeta(::grpc::ServerContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response);
    virtual ::grpc::Status GetFileMetaByUserId(::grpc::ServerContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response);
    virtual ::grpc::Status DeleteFileMetadata(::grpc::ServerContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response);
    virtual ::grpc::Status Detect(::grpc::ServerContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response);
    virtual ::grpc::Status Confusion(::grpc::ServerContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response);
    virtual ::grpc::Status Packer(::grpc::ServerContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response);
    virtual ::grpc::Status GetArtifactMetadata(::grpc::ServerContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response);
    virtual ::grpc::Status GetArtifactMetadataByFileId(::grpc::ServerContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response);
    virtual ::grpc::Status DeleteArtifactMetadata(::grpc::ServerContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Register() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::RegisterRequest* /*request*/, ::bugu::service::v1::RegisterReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegister(::grpc::ServerContext* context, ::bugu::service::v1::RegisterRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::RegisterReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Login() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::LoginRequest* /*request*/, ::bugu::service::v1::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::bugu::service::v1::LoginRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::LoginReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCurrentUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCurrentUser() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetCurrentUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCurrentUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetCurrentUserRequest* /*request*/, ::bugu::service::v1::GetCurrentUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCurrentUser(::grpc::ServerContext* context, ::bugu::service::v1::GetCurrentUserRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::GetCurrentUserReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateUser() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_UpdateUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::UpdateUserRequest* /*request*/, ::bugu::service::v1::UpdateUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateUser(::grpc::ServerContext* context, ::bugu::service::v1::UpdateUserRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::UpdateUserReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFileMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFileMeta() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetFileMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMeta(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaRequest* /*request*/, ::bugu::service::v1::GetFileMetaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFileMeta(::grpc::ServerContext* context, ::bugu::service::v1::GetFileMetaRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::GetFileMetaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetFileMetaByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetFileMetaByUserId() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetFileMetaByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMetaByUserId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaByUserIdRequest* /*request*/, ::bugu::service::v1::GetFileMetaByUserIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFileMetaByUserId(::grpc::ServerContext* context, ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::GetFileMetaByUserIdReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteFileMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteFileMetadata() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteFileMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFileMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteFileMetadataRequest* /*request*/, ::bugu::service::v1::DeleteFileMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteFileMetadata(::grpc::ServerContext* context, ::bugu::service::v1::DeleteFileMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::DeleteFileMetadataReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Detect() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DetectRequest* /*request*/, ::bugu::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetect(::grpc::ServerContext* context, ::bugu::service::v1::DetectRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::DetectReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Confusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Confusion() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Confusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Confusion(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::ConfusionRequest* /*request*/, ::bugu::service::v1::ConfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfusion(::grpc::ServerContext* context, ::bugu::service::v1::ConfusionRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::ConfusionReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Packer() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::PackerRequest* /*request*/, ::bugu::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPacker(::grpc::ServerContext* context, ::bugu::service::v1::PackerRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::PackerReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetArtifactMetadata() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetArtifactMetadata(::grpc::ServerContext* context, ::bugu::service::v1::GetArtifactMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::GetArtifactMetadataReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetArtifactMetadataByFileId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetArtifactMetadataByFileId() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetArtifactMetadataByFileId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadataByFileId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetArtifactMetadataByFileId(::grpc::ServerContext* context, ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteArtifactMetadata() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_DeleteArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteArtifactMetadataRequest* /*request*/, ::bugu::service::v1::DeleteArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteArtifactMetadata(::grpc::ServerContext* context, ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu::service::v1::DeleteArtifactMetadataReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Register<WithAsyncMethod_Login<WithAsyncMethod_GetCurrentUser<WithAsyncMethod_UpdateUser<WithAsyncMethod_GetFileMeta<WithAsyncMethod_GetFileMetaByUserId<WithAsyncMethod_DeleteFileMetadata<WithAsyncMethod_Detect<WithAsyncMethod_Confusion<WithAsyncMethod_Packer<WithAsyncMethod_GetArtifactMetadata<WithAsyncMethod_GetArtifactMetadataByFileId<WithAsyncMethod_DeleteArtifactMetadata<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Register() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::RegisterRequest, ::bugu::service::v1::RegisterReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::RegisterRequest* request, ::bugu::service::v1::RegisterReply* response) { return this->Register(context, request, response); }));}
    void SetMessageAllocatorFor_Register(
        ::grpc::MessageAllocator< ::bugu::service::v1::RegisterRequest, ::bugu::service::v1::RegisterReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::RegisterRequest, ::bugu::service::v1::RegisterReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::RegisterRequest* /*request*/, ::bugu::service::v1::RegisterReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Register(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::RegisterRequest* /*request*/, ::bugu::service::v1::RegisterReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Login() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::LoginRequest, ::bugu::service::v1::LoginReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::LoginRequest* request, ::bugu::service::v1::LoginReply* response) { return this->Login(context, request, response); }));}
    void SetMessageAllocatorFor_Login(
        ::grpc::MessageAllocator< ::bugu::service::v1::LoginRequest, ::bugu::service::v1::LoginReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::LoginRequest, ::bugu::service::v1::LoginReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::LoginRequest* /*request*/, ::bugu::service::v1::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Login(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::LoginRequest* /*request*/, ::bugu::service::v1::LoginReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCurrentUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCurrentUser() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetCurrentUserRequest, ::bugu::service::v1::GetCurrentUserReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::GetCurrentUserRequest* request, ::bugu::service::v1::GetCurrentUserReply* response) { return this->GetCurrentUser(context, request, response); }));}
    void SetMessageAllocatorFor_GetCurrentUser(
        ::grpc::MessageAllocator< ::bugu::service::v1::GetCurrentUserRequest, ::bugu::service::v1::GetCurrentUserReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetCurrentUserRequest, ::bugu::service::v1::GetCurrentUserReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCurrentUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCurrentUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetCurrentUserRequest* /*request*/, ::bugu::service::v1::GetCurrentUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCurrentUser(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::GetCurrentUserRequest* /*request*/, ::bugu::service::v1::GetCurrentUserReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateUser() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::UpdateUserRequest, ::bugu::service::v1::UpdateUserReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::UpdateUserRequest* request, ::bugu::service::v1::UpdateUserReply* response) { return this->UpdateUser(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateUser(
        ::grpc::MessageAllocator< ::bugu::service::v1::UpdateUserRequest, ::bugu::service::v1::UpdateUserReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::UpdateUserRequest, ::bugu::service::v1::UpdateUserReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::UpdateUserRequest* /*request*/, ::bugu::service::v1::UpdateUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateUser(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::UpdateUserRequest* /*request*/, ::bugu::service::v1::UpdateUserReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFileMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFileMeta() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetFileMetaRequest, ::bugu::service::v1::GetFileMetaReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::GetFileMetaRequest* request, ::bugu::service::v1::GetFileMetaReply* response) { return this->GetFileMeta(context, request, response); }));}
    void SetMessageAllocatorFor_GetFileMeta(
        ::grpc::MessageAllocator< ::bugu::service::v1::GetFileMetaRequest, ::bugu::service::v1::GetFileMetaReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetFileMetaRequest, ::bugu::service::v1::GetFileMetaReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFileMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMeta(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaRequest* /*request*/, ::bugu::service::v1::GetFileMetaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFileMeta(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaRequest* /*request*/, ::bugu::service::v1::GetFileMetaReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetFileMetaByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetFileMetaByUserId() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetFileMetaByUserIdRequest, ::bugu::service::v1::GetFileMetaByUserIdReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::GetFileMetaByUserIdRequest* request, ::bugu::service::v1::GetFileMetaByUserIdReply* response) { return this->GetFileMetaByUserId(context, request, response); }));}
    void SetMessageAllocatorFor_GetFileMetaByUserId(
        ::grpc::MessageAllocator< ::bugu::service::v1::GetFileMetaByUserIdRequest, ::bugu::service::v1::GetFileMetaByUserIdReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetFileMetaByUserIdRequest, ::bugu::service::v1::GetFileMetaByUserIdReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetFileMetaByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMetaByUserId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaByUserIdRequest* /*request*/, ::bugu::service::v1::GetFileMetaByUserIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFileMetaByUserId(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaByUserIdRequest* /*request*/, ::bugu::service::v1::GetFileMetaByUserIdReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteFileMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteFileMetadata() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::DeleteFileMetadataRequest, ::bugu::service::v1::DeleteFileMetadataReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::DeleteFileMetadataRequest* request, ::bugu::service::v1::DeleteFileMetadataReply* response) { return this->DeleteFileMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteFileMetadata(
        ::grpc::MessageAllocator< ::bugu::service::v1::DeleteFileMetadataRequest, ::bugu::service::v1::DeleteFileMetadataReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::DeleteFileMetadataRequest, ::bugu::service::v1::DeleteFileMetadataReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteFileMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFileMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteFileMetadataRequest* /*request*/, ::bugu::service::v1::DeleteFileMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteFileMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::DeleteFileMetadataRequest* /*request*/, ::bugu::service::v1::DeleteFileMetadataReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Detect() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::DetectRequest, ::bugu::service::v1::DetectReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::DetectRequest* request, ::bugu::service::v1::DetectReply* response) { return this->Detect(context, request, response); }));}
    void SetMessageAllocatorFor_Detect(
        ::grpc::MessageAllocator< ::bugu::service::v1::DetectRequest, ::bugu::service::v1::DetectReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::DetectRequest, ::bugu::service::v1::DetectReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DetectRequest* /*request*/, ::bugu::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Detect(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::DetectRequest* /*request*/, ::bugu::service::v1::DetectReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Confusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Confusion() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::ConfusionRequest, ::bugu::service::v1::ConfusionReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::ConfusionRequest* request, ::bugu::service::v1::ConfusionReply* response) { return this->Confusion(context, request, response); }));}
    void SetMessageAllocatorFor_Confusion(
        ::grpc::MessageAllocator< ::bugu::service::v1::ConfusionRequest, ::bugu::service::v1::ConfusionReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::ConfusionRequest, ::bugu::service::v1::ConfusionReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Confusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Confusion(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::ConfusionRequest* /*request*/, ::bugu::service::v1::ConfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Confusion(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::ConfusionRequest* /*request*/, ::bugu::service::v1::ConfusionReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Packer() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::PackerRequest, ::bugu::service::v1::PackerReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::PackerRequest* request, ::bugu::service::v1::PackerReply* response) { return this->Packer(context, request, response); }));}
    void SetMessageAllocatorFor_Packer(
        ::grpc::MessageAllocator< ::bugu::service::v1::PackerRequest, ::bugu::service::v1::PackerReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::PackerRequest, ::bugu::service::v1::PackerReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::PackerRequest* /*request*/, ::bugu::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Packer(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::PackerRequest* /*request*/, ::bugu::service::v1::PackerReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetArtifactMetadata() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetArtifactMetadataRequest, ::bugu::service::v1::GetArtifactMetadataReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::GetArtifactMetadataRequest* request, ::bugu::service::v1::GetArtifactMetadataReply* response) { return this->GetArtifactMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_GetArtifactMetadata(
        ::grpc::MessageAllocator< ::bugu::service::v1::GetArtifactMetadataRequest, ::bugu::service::v1::GetArtifactMetadataReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetArtifactMetadataRequest, ::bugu::service::v1::GetArtifactMetadataReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetArtifactMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetArtifactMetadataByFileId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetArtifactMetadataByFileId() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::bugu::service::v1::GetArtifactMetadataByFileIdReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* request, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* response) { return this->GetArtifactMetadataByFileId(context, request, response); }));}
    void SetMessageAllocatorFor_GetArtifactMetadataByFileId(
        ::grpc::MessageAllocator< ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::bugu::service::v1::GetArtifactMetadataByFileIdReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetArtifactMetadataByFileId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadataByFileId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetArtifactMetadataByFileId(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteArtifactMetadata() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::DeleteArtifactMetadataRequest, ::bugu::service::v1::DeleteArtifactMetadataReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu::service::v1::DeleteArtifactMetadataRequest* request, ::bugu::service::v1::DeleteArtifactMetadataReply* response) { return this->DeleteArtifactMetadata(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteArtifactMetadata(
        ::grpc::MessageAllocator< ::bugu::service::v1::DeleteArtifactMetadataRequest, ::bugu::service::v1::DeleteArtifactMetadataReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu::service::v1::DeleteArtifactMetadataRequest, ::bugu::service::v1::DeleteArtifactMetadataReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteArtifactMetadataRequest* /*request*/, ::bugu::service::v1::DeleteArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteArtifactMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu::service::v1::DeleteArtifactMetadataRequest* /*request*/, ::bugu::service::v1::DeleteArtifactMetadataReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Register<WithCallbackMethod_Login<WithCallbackMethod_GetCurrentUser<WithCallbackMethod_UpdateUser<WithCallbackMethod_GetFileMeta<WithCallbackMethod_GetFileMetaByUserId<WithCallbackMethod_DeleteFileMetadata<WithCallbackMethod_Detect<WithCallbackMethod_Confusion<WithCallbackMethod_Packer<WithCallbackMethod_GetArtifactMetadata<WithCallbackMethod_GetArtifactMetadataByFileId<WithCallbackMethod_DeleteArtifactMetadata<Service > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Register() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::RegisterRequest* /*request*/, ::bugu::service::v1::RegisterReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Login() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::LoginRequest* /*request*/, ::bugu::service::v1::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCurrentUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCurrentUser() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetCurrentUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCurrentUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetCurrentUserRequest* /*request*/, ::bugu::service::v1::GetCurrentUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateUser() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_UpdateUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::UpdateUserRequest* /*request*/, ::bugu::service::v1::UpdateUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFileMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFileMeta() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetFileMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMeta(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaRequest* /*request*/, ::bugu::service::v1::GetFileMetaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetFileMetaByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetFileMetaByUserId() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetFileMetaByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMetaByUserId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaByUserIdRequest* /*request*/, ::bugu::service::v1::GetFileMetaByUserIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteFileMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteFileMetadata() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteFileMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFileMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteFileMetadataRequest* /*request*/, ::bugu::service::v1::DeleteFileMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Detect() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DetectRequest* /*request*/, ::bugu::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Confusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Confusion() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Confusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Confusion(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::ConfusionRequest* /*request*/, ::bugu::service::v1::ConfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Packer() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::PackerRequest* /*request*/, ::bugu::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetArtifactMetadata() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetArtifactMetadataByFileId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetArtifactMetadataByFileId() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetArtifactMetadataByFileId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadataByFileId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteArtifactMetadata() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_DeleteArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteArtifactMetadataRequest* /*request*/, ::bugu::service::v1::DeleteArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Register() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::RegisterRequest* /*request*/, ::bugu::service::v1::RegisterReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Login() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::LoginRequest* /*request*/, ::bugu::service::v1::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCurrentUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCurrentUser() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetCurrentUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCurrentUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetCurrentUserRequest* /*request*/, ::bugu::service::v1::GetCurrentUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCurrentUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateUser() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_UpdateUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::UpdateUserRequest* /*request*/, ::bugu::service::v1::UpdateUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateUser(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFileMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFileMeta() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetFileMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMeta(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaRequest* /*request*/, ::bugu::service::v1::GetFileMetaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFileMeta(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetFileMetaByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetFileMetaByUserId() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetFileMetaByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMetaByUserId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaByUserIdRequest* /*request*/, ::bugu::service::v1::GetFileMetaByUserIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetFileMetaByUserId(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteFileMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteFileMetadata() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteFileMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFileMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteFileMetadataRequest* /*request*/, ::bugu::service::v1::DeleteFileMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteFileMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Detect() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DetectRequest* /*request*/, ::bugu::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Confusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Confusion() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Confusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Confusion(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::ConfusionRequest* /*request*/, ::bugu::service::v1::ConfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfusion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Packer() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::PackerRequest* /*request*/, ::bugu::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPacker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetArtifactMetadata() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetArtifactMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetArtifactMetadataByFileId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetArtifactMetadataByFileId() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetArtifactMetadataByFileId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadataByFileId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetArtifactMetadataByFileId(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteArtifactMetadata() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_DeleteArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteArtifactMetadataRequest* /*request*/, ::bugu::service::v1::DeleteArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteArtifactMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Register() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Register(context, request, response); }));
    }
    ~WithRawCallbackMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Register(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::RegisterRequest* /*request*/, ::bugu::service::v1::RegisterReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Register(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Login() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Login(context, request, response); }));
    }
    ~WithRawCallbackMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::LoginRequest* /*request*/, ::bugu::service::v1::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Login(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCurrentUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCurrentUser() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCurrentUser(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCurrentUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCurrentUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetCurrentUserRequest* /*request*/, ::bugu::service::v1::GetCurrentUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCurrentUser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateUser() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateUser(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::UpdateUserRequest* /*request*/, ::bugu::service::v1::UpdateUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateUser(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFileMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFileMeta() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFileMeta(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFileMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMeta(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaRequest* /*request*/, ::bugu::service::v1::GetFileMetaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFileMeta(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetFileMetaByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetFileMetaByUserId() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetFileMetaByUserId(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetFileMetaByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetFileMetaByUserId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaByUserIdRequest* /*request*/, ::bugu::service::v1::GetFileMetaByUserIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetFileMetaByUserId(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteFileMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteFileMetadata() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteFileMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteFileMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFileMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteFileMetadataRequest* /*request*/, ::bugu::service::v1::DeleteFileMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteFileMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Detect() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Detect(context, request, response); }));
    }
    ~WithRawCallbackMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DetectRequest* /*request*/, ::bugu::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Detect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Confusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Confusion() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Confusion(context, request, response); }));
    }
    ~WithRawCallbackMethod_Confusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Confusion(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::ConfusionRequest* /*request*/, ::bugu::service::v1::ConfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Confusion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Packer() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Packer(context, request, response); }));
    }
    ~WithRawCallbackMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::PackerRequest* /*request*/, ::bugu::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Packer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetArtifactMetadata() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetArtifactMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetArtifactMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetArtifactMetadataByFileId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetArtifactMetadataByFileId() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetArtifactMetadataByFileId(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetArtifactMetadataByFileId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetArtifactMetadataByFileId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetArtifactMetadataByFileId(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteArtifactMetadata() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteArtifactMetadata(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteArtifactMetadataRequest* /*request*/, ::bugu::service::v1::DeleteArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteArtifactMetadata(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Register() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::RegisterRequest, ::bugu::service::v1::RegisterReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::RegisterRequest, ::bugu::service::v1::RegisterReply>* streamer) {
                       return this->StreamedRegister(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Register(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::RegisterRequest* /*request*/, ::bugu::service::v1::RegisterReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRegister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::RegisterRequest,::bugu::service::v1::RegisterReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Login : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Login() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::LoginRequest, ::bugu::service::v1::LoginReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::LoginRequest, ::bugu::service::v1::LoginReply>* streamer) {
                       return this->StreamedLogin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Login() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Login(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::LoginRequest* /*request*/, ::bugu::service::v1::LoginReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::LoginRequest,::bugu::service::v1::LoginReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCurrentUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCurrentUser() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::GetCurrentUserRequest, ::bugu::service::v1::GetCurrentUserReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::GetCurrentUserRequest, ::bugu::service::v1::GetCurrentUserReply>* streamer) {
                       return this->StreamedGetCurrentUser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCurrentUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCurrentUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetCurrentUserRequest* /*request*/, ::bugu::service::v1::GetCurrentUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCurrentUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::GetCurrentUserRequest,::bugu::service::v1::GetCurrentUserReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateUser : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateUser() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::UpdateUserRequest, ::bugu::service::v1::UpdateUserReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::UpdateUserRequest, ::bugu::service::v1::UpdateUserReply>* streamer) {
                       return this->StreamedUpdateUser(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateUser() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateUser(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::UpdateUserRequest* /*request*/, ::bugu::service::v1::UpdateUserReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateUser(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::UpdateUserRequest,::bugu::service::v1::UpdateUserReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFileMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFileMeta() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::GetFileMetaRequest, ::bugu::service::v1::GetFileMetaReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::GetFileMetaRequest, ::bugu::service::v1::GetFileMetaReply>* streamer) {
                       return this->StreamedGetFileMeta(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFileMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFileMeta(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaRequest* /*request*/, ::bugu::service::v1::GetFileMetaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFileMeta(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::GetFileMetaRequest,::bugu::service::v1::GetFileMetaReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetFileMetaByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetFileMetaByUserId() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::GetFileMetaByUserIdRequest, ::bugu::service::v1::GetFileMetaByUserIdReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::GetFileMetaByUserIdRequest, ::bugu::service::v1::GetFileMetaByUserIdReply>* streamer) {
                       return this->StreamedGetFileMetaByUserId(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetFileMetaByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetFileMetaByUserId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetFileMetaByUserIdRequest* /*request*/, ::bugu::service::v1::GetFileMetaByUserIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetFileMetaByUserId(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::GetFileMetaByUserIdRequest,::bugu::service::v1::GetFileMetaByUserIdReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteFileMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteFileMetadata() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::DeleteFileMetadataRequest, ::bugu::service::v1::DeleteFileMetadataReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::DeleteFileMetadataRequest, ::bugu::service::v1::DeleteFileMetadataReply>* streamer) {
                       return this->StreamedDeleteFileMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteFileMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteFileMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteFileMetadataRequest* /*request*/, ::bugu::service::v1::DeleteFileMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteFileMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::DeleteFileMetadataRequest,::bugu::service::v1::DeleteFileMetadataReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Detect() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::DetectRequest, ::bugu::service::v1::DetectReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::DetectRequest, ::bugu::service::v1::DetectReply>* streamer) {
                       return this->StreamedDetect(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DetectRequest* /*request*/, ::bugu::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDetect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::DetectRequest,::bugu::service::v1::DetectReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Confusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Confusion() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::ConfusionRequest, ::bugu::service::v1::ConfusionReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::ConfusionRequest, ::bugu::service::v1::ConfusionReply>* streamer) {
                       return this->StreamedConfusion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Confusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Confusion(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::ConfusionRequest* /*request*/, ::bugu::service::v1::ConfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfusion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::ConfusionRequest,::bugu::service::v1::ConfusionReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Packer() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::PackerRequest, ::bugu::service::v1::PackerReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::PackerRequest, ::bugu::service::v1::PackerReply>* streamer) {
                       return this->StreamedPacker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::PackerRequest* /*request*/, ::bugu::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPacker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::PackerRequest,::bugu::service::v1::PackerReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetArtifactMetadata() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::GetArtifactMetadataRequest, ::bugu::service::v1::GetArtifactMetadataReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::GetArtifactMetadataRequest, ::bugu::service::v1::GetArtifactMetadataReply>* streamer) {
                       return this->StreamedGetArtifactMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetArtifactMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::GetArtifactMetadataRequest,::bugu::service::v1::GetArtifactMetadataReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetArtifactMetadataByFileId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetArtifactMetadataByFileId() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::bugu::service::v1::GetArtifactMetadataByFileIdReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::GetArtifactMetadataByFileIdRequest, ::bugu::service::v1::GetArtifactMetadataByFileIdReply>* streamer) {
                       return this->StreamedGetArtifactMetadataByFileId(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetArtifactMetadataByFileId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetArtifactMetadataByFileId(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* /*request*/, ::bugu::service::v1::GetArtifactMetadataByFileIdReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetArtifactMetadataByFileId(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::GetArtifactMetadataByFileIdRequest,::bugu::service::v1::GetArtifactMetadataByFileIdReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteArtifactMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteArtifactMetadata() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu::service::v1::DeleteArtifactMetadataRequest, ::bugu::service::v1::DeleteArtifactMetadataReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu::service::v1::DeleteArtifactMetadataRequest, ::bugu::service::v1::DeleteArtifactMetadataReply>* streamer) {
                       return this->StreamedDeleteArtifactMetadata(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteArtifactMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteArtifactMetadata(::grpc::ServerContext* /*context*/, const ::bugu::service::v1::DeleteArtifactMetadataRequest* /*request*/, ::bugu::service::v1::DeleteArtifactMetadataReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteArtifactMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu::service::v1::DeleteArtifactMetadataRequest,::bugu::service::v1::DeleteArtifactMetadataReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Register<WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_GetCurrentUser<WithStreamedUnaryMethod_UpdateUser<WithStreamedUnaryMethod_GetFileMeta<WithStreamedUnaryMethod_GetFileMetaByUserId<WithStreamedUnaryMethod_DeleteFileMetadata<WithStreamedUnaryMethod_Detect<WithStreamedUnaryMethod_Confusion<WithStreamedUnaryMethod_Packer<WithStreamedUnaryMethod_GetArtifactMetadata<WithStreamedUnaryMethod_GetArtifactMetadataByFileId<WithStreamedUnaryMethod_DeleteArtifactMetadata<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Register<WithStreamedUnaryMethod_Login<WithStreamedUnaryMethod_GetCurrentUser<WithStreamedUnaryMethod_UpdateUser<WithStreamedUnaryMethod_GetFileMeta<WithStreamedUnaryMethod_GetFileMetaByUserId<WithStreamedUnaryMethod_DeleteFileMetadata<WithStreamedUnaryMethod_Detect<WithStreamedUnaryMethod_Confusion<WithStreamedUnaryMethod_Packer<WithStreamedUnaryMethod_GetArtifactMetadata<WithStreamedUnaryMethod_GetArtifactMetadataByFileId<WithStreamedUnaryMethod_DeleteArtifactMetadata<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace service
}  // namespace bugu


#endif  // GRPC_bugu_2eproto__INCLUDED

```

`api/bugu/service/v1/cpp/bugu.pb.cc`:

```cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bugu.proto

#include "bugu.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace bugu {
namespace service {
namespace v1 {
constexpr RegisterRequest_User::RegisterRequest_User(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : username_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , email_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct RegisterRequest_UserDefaultTypeInternal {
  constexpr RegisterRequest_UserDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RegisterRequest_UserDefaultTypeInternal() {}
  union {
    RegisterRequest_User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RegisterRequest_UserDefaultTypeInternal _RegisterRequest_User_default_instance_;
constexpr RegisterRequest::RegisterRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_(nullptr){}
struct RegisterRequestDefaultTypeInternal {
  constexpr RegisterRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RegisterRequestDefaultTypeInternal() {}
  union {
    RegisterRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
constexpr RegisterReply::RegisterReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_(nullptr){}
struct RegisterReplyDefaultTypeInternal {
  constexpr RegisterReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RegisterReplyDefaultTypeInternal() {}
  union {
    RegisterReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RegisterReplyDefaultTypeInternal _RegisterReply_default_instance_;
constexpr LoginRequest_User::LoginRequest_User(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : email_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct LoginRequest_UserDefaultTypeInternal {
  constexpr LoginRequest_UserDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoginRequest_UserDefaultTypeInternal() {}
  union {
    LoginRequest_User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoginRequest_UserDefaultTypeInternal _LoginRequest_User_default_instance_;
constexpr LoginRequest::LoginRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_(nullptr){}
struct LoginRequestDefaultTypeInternal {
  constexpr LoginRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoginRequestDefaultTypeInternal() {}
  union {
    LoginRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
constexpr LoginReply::LoginReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_(nullptr){}
struct LoginReplyDefaultTypeInternal {
  constexpr LoginReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoginReplyDefaultTypeInternal() {}
  union {
    LoginReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
constexpr GetCurrentUserRequest::GetCurrentUserRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetCurrentUserRequestDefaultTypeInternal {
  constexpr GetCurrentUserRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetCurrentUserRequestDefaultTypeInternal() {}
  union {
    GetCurrentUserRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetCurrentUserRequestDefaultTypeInternal _GetCurrentUserRequest_default_instance_;
constexpr GetCurrentUserReply::GetCurrentUserReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_(nullptr){}
struct GetCurrentUserReplyDefaultTypeInternal {
  constexpr GetCurrentUserReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetCurrentUserReplyDefaultTypeInternal() {}
  union {
    GetCurrentUserReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetCurrentUserReplyDefaultTypeInternal _GetCurrentUserReply_default_instance_;
constexpr UpdateUserRequest_User::UpdateUserRequest_User(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , email_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , username_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct UpdateUserRequest_UserDefaultTypeInternal {
  constexpr UpdateUserRequest_UserDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateUserRequest_UserDefaultTypeInternal() {}
  union {
    UpdateUserRequest_User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateUserRequest_UserDefaultTypeInternal _UpdateUserRequest_User_default_instance_;
constexpr UpdateUserRequest::UpdateUserRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_(nullptr){}
struct UpdateUserRequestDefaultTypeInternal {
  constexpr UpdateUserRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateUserRequestDefaultTypeInternal() {}
  union {
    UpdateUserRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateUserRequestDefaultTypeInternal _UpdateUserRequest_default_instance_;
constexpr UpdateUserReply::UpdateUserReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_(nullptr){}
struct UpdateUserReplyDefaultTypeInternal {
  constexpr UpdateUserReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateUserReplyDefaultTypeInternal() {}
  union {
    UpdateUserReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateUserReplyDefaultTypeInternal _UpdateUserReply_default_instance_;
constexpr UserStruct::UserStruct(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , email_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , username_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct UserStructDefaultTypeInternal {
  constexpr UserStructDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserStructDefaultTypeInternal() {}
  union {
    UserStruct _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserStructDefaultTypeInternal _UserStruct_default_instance_;
constexpr GetFileMetaRequest::GetFileMetaRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetFileMetaRequestDefaultTypeInternal {
  constexpr GetFileMetaRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetFileMetaRequestDefaultTypeInternal() {}
  union {
    GetFileMetaRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetFileMetaRequestDefaultTypeInternal _GetFileMetaRequest_default_instance_;
constexpr GetFileMetaReply::GetFileMetaReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_sha_1_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_addr_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_size_(int64_t{0})
  , type_(0)
{}
struct GetFileMetaReplyDefaultTypeInternal {
  constexpr GetFileMetaReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetFileMetaReplyDefaultTypeInternal() {}
  union {
    GetFileMetaReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetFileMetaReplyDefaultTypeInternal _GetFileMetaReply_default_instance_;
constexpr GetFileMetaByUserIdRequest::GetFileMetaByUserIdRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetFileMetaByUserIdRequestDefaultTypeInternal {
  constexpr GetFileMetaByUserIdRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetFileMetaByUserIdRequestDefaultTypeInternal() {}
  union {
    GetFileMetaByUserIdRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetFileMetaByUserIdRequestDefaultTypeInternal _GetFileMetaByUserIdRequest_default_instance_;
constexpr GetFileMetaByUserIdReply::GetFileMetaByUserIdReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : file_metadata_(){}
struct GetFileMetaByUserIdReplyDefaultTypeInternal {
  constexpr GetFileMetaByUserIdReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetFileMetaByUserIdReplyDefaultTypeInternal() {}
  union {
    GetFileMetaByUserIdReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetFileMetaByUserIdReplyDefaultTypeInternal _GetFileMetaByUserIdReply_default_instance_;
constexpr DeleteFileMetadataRequest::DeleteFileMetadataRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct DeleteFileMetadataRequestDefaultTypeInternal {
  constexpr DeleteFileMetadataRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteFileMetadataRequestDefaultTypeInternal() {}
  union {
    DeleteFileMetadataRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteFileMetadataRequestDefaultTypeInternal _DeleteFileMetadataRequest_default_instance_;
constexpr DeleteFileMetadataReply::DeleteFileMetadataReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct DeleteFileMetadataReplyDefaultTypeInternal {
  constexpr DeleteFileMetadataReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteFileMetadataReplyDefaultTypeInternal() {}
  union {
    DeleteFileMetadataReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteFileMetadataReplyDefaultTypeInternal _DeleteFileMetadataReply_default_instance_;
constexpr DetectRequest::DetectRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct DetectRequestDefaultTypeInternal {
  constexpr DetectRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DetectRequestDefaultTypeInternal() {}
  union {
    DetectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DetectRequestDefaultTypeInternal _DetectRequest_default_instance_;
constexpr DetectReply::DetectReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : artifact_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct DetectReplyDefaultTypeInternal {
  constexpr DetectReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DetectReplyDefaultTypeInternal() {}
  union {
    DetectReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DetectReplyDefaultTypeInternal _DetectReply_default_instance_;
constexpr ConfusionRequest::ConfusionRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ConfusionRequestDefaultTypeInternal {
  constexpr ConfusionRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConfusionRequestDefaultTypeInternal() {}
  union {
    ConfusionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConfusionRequestDefaultTypeInternal _ConfusionRequest_default_instance_;
constexpr ConfusionReply::ConfusionReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : artifact_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , affiliated_file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , method_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct ConfusionReplyDefaultTypeInternal {
  constexpr ConfusionReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConfusionReplyDefaultTypeInternal() {}
  union {
    ConfusionReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConfusionReplyDefaultTypeInternal _ConfusionReply_default_instance_;
constexpr PackerRequest::PackerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct PackerRequestDefaultTypeInternal {
  constexpr PackerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PackerRequestDefaultTypeInternal() {}
  union {
    PackerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PackerRequestDefaultTypeInternal _PackerRequest_default_instance_;
constexpr PackerReply::PackerReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : artifact_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , affiliated_file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , method_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct PackerReplyDefaultTypeInternal {
  constexpr PackerReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PackerReplyDefaultTypeInternal() {}
  union {
    PackerReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PackerReplyDefaultTypeInternal _PackerReply_default_instance_;
constexpr GetArtifactMetadataRequest::GetArtifactMetadataRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , artifact_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetArtifactMetadataRequestDefaultTypeInternal {
  constexpr GetArtifactMetadataRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetArtifactMetadataRequestDefaultTypeInternal() {}
  union {
    GetArtifactMetadataRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetArtifactMetadataRequestDefaultTypeInternal _GetArtifactMetadataRequest_default_instance_;
constexpr GetArtifactMetadataReply::GetArtifactMetadataReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : artifact_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , affiliated_file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , method_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetArtifactMetadataReplyDefaultTypeInternal {
  constexpr GetArtifactMetadataReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetArtifactMetadataReplyDefaultTypeInternal() {}
  union {
    GetArtifactMetadataReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetArtifactMetadataReplyDefaultTypeInternal _GetArtifactMetadataReply_default_instance_;
constexpr GetArtifactMetadataByFileIdRequest::GetArtifactMetadataByFileIdRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GetArtifactMetadataByFileIdRequestDefaultTypeInternal {
  constexpr GetArtifactMetadataByFileIdRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetArtifactMetadataByFileIdRequestDefaultTypeInternal() {}
  union {
    GetArtifactMetadataByFileIdRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetArtifactMetadataByFileIdRequestDefaultTypeInternal _GetArtifactMetadataByFileIdRequest_default_instance_;
constexpr GetArtifactMetadataByFileIdReply::GetArtifactMetadataByFileIdReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : artifact_metadata_(){}
struct GetArtifactMetadataByFileIdReplyDefaultTypeInternal {
  constexpr GetArtifactMetadataByFileIdReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetArtifactMetadataByFileIdReplyDefaultTypeInternal() {}
  union {
    GetArtifactMetadataByFileIdReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetArtifactMetadataByFileIdReplyDefaultTypeInternal _GetArtifactMetadataByFileIdReply_default_instance_;
constexpr DeleteArtifactMetadataRequest::DeleteArtifactMetadataRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , artifact_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct DeleteArtifactMetadataRequestDefaultTypeInternal {
  constexpr DeleteArtifactMetadataRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteArtifactMetadataRequestDefaultTypeInternal() {}
  union {
    DeleteArtifactMetadataRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteArtifactMetadataRequestDefaultTypeInternal _DeleteArtifactMetadataRequest_default_instance_;
constexpr DeleteArtifactMetadataReply::DeleteArtifactMetadataReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct DeleteArtifactMetadataReplyDefaultTypeInternal {
  constexpr DeleteArtifactMetadataReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteArtifactMetadataReplyDefaultTypeInternal() {}
  union {
    DeleteArtifactMetadataReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteArtifactMetadataReplyDefaultTypeInternal _DeleteArtifactMetadataReply_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_bugu_2eproto[30];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_bugu_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_bugu_2eproto = nullptr;

const uint32_t TableStruct_bugu_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::RegisterRequest_User, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::RegisterRequest_User, username_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::RegisterRequest_User, email_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::RegisterRequest_User, password_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::RegisterRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::RegisterRequest, user_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::RegisterReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::RegisterReply, user_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::LoginRequest_User, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::LoginRequest_User, email_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::LoginRequest_User, password_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::LoginRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::LoginRequest, user_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::LoginReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::LoginReply, user_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::LoginReply, token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetCurrentUserRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetCurrentUserRequest, id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetCurrentUserReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetCurrentUserReply, user_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserRequest_User, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserRequest_User, id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserRequest_User, email_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserRequest_User, username_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserRequest_User, password_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserRequest, user_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UpdateUserReply, user_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UserStruct, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UserStruct, id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UserStruct, email_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::UserStruct, username_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaRequest, file_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaReply, file_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaReply, file_sha_1_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaReply, file_size_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaReply, file_addr_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaReply, type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaByUserIdRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaByUserIdRequest, user_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaByUserIdReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetFileMetaByUserIdReply, file_metadata_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DeleteFileMetadataRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DeleteFileMetadataRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DeleteFileMetadataRequest, file_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DeleteFileMetadataReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DetectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DetectRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DetectRequest, file_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DetectReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DetectReply, artifact_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::ConfusionRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::ConfusionRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::ConfusionRequest, file_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::ConfusionReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::ConfusionReply, artifact_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::ConfusionReply, file_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::ConfusionReply, affiliated_file_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::ConfusionReply, method_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::PackerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::PackerRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::PackerRequest, file_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::PackerReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::PackerReply, artifact_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::PackerReply, file_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::PackerReply, affiliated_file_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::PackerReply, method_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataRequest, artifact_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataReply, artifact_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataReply, file_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataReply, affiliated_file_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataReply, method_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataByFileIdRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataByFileIdRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataByFileIdRequest, file_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataByFileIdReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::GetArtifactMetadataByFileIdReply, artifact_metadata_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DeleteArtifactMetadataRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DeleteArtifactMetadataRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DeleteArtifactMetadataRequest, artifact_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu::service::v1::DeleteArtifactMetadataReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::bugu::service::v1::RegisterRequest_User)},
  { 9, -1, -1, sizeof(::bugu::service::v1::RegisterRequest)},
  { 16, -1, -1, sizeof(::bugu::service::v1::RegisterReply)},
  { 23, -1, -1, sizeof(::bugu::service::v1::LoginRequest_User)},
  { 31, -1, -1, sizeof(::bugu::service::v1::LoginRequest)},
  { 38, -1, -1, sizeof(::bugu::service::v1::LoginReply)},
  { 46, -1, -1, sizeof(::bugu::service::v1::GetCurrentUserRequest)},
  { 53, -1, -1, sizeof(::bugu::service::v1::GetCurrentUserReply)},
  { 60, -1, -1, sizeof(::bugu::service::v1::UpdateUserRequest_User)},
  { 70, -1, -1, sizeof(::bugu::service::v1::UpdateUserRequest)},
  { 77, -1, -1, sizeof(::bugu::service::v1::UpdateUserReply)},
  { 84, -1, -1, sizeof(::bugu::service::v1::UserStruct)},
  { 93, -1, -1, sizeof(::bugu::service::v1::GetFileMetaRequest)},
  { 101, -1, -1, sizeof(::bugu::service::v1::GetFileMetaReply)},
  { 112, -1, -1, sizeof(::bugu::service::v1::GetFileMetaByUserIdRequest)},
  { 119, -1, -1, sizeof(::bugu::service::v1::GetFileMetaByUserIdReply)},
  { 126, -1, -1, sizeof(::bugu::service::v1::DeleteFileMetadataRequest)},
  { 134, -1, -1, sizeof(::bugu::service::v1::DeleteFileMetadataReply)},
  { 140, -1, -1, sizeof(::bugu::service::v1::DetectRequest)},
  { 148, -1, -1, sizeof(::bugu::service::v1::DetectReply)},
  { 155, -1, -1, sizeof(::bugu::service::v1::ConfusionRequest)},
  { 163, -1, -1, sizeof(::bugu::service::v1::ConfusionReply)},
  { 173, -1, -1, sizeof(::bugu::service::v1::PackerRequest)},
  { 181, -1, -1, sizeof(::bugu::service::v1::PackerReply)},
  { 191, -1, -1, sizeof(::bugu::service::v1::GetArtifactMetadataRequest)},
  { 199, -1, -1, sizeof(::bugu::service::v1::GetArtifactMetadataReply)},
  { 209, -1, -1, sizeof(::bugu::service::v1::GetArtifactMetadataByFileIdRequest)},
  { 217, -1, -1, sizeof(::bugu::service::v1::GetArtifactMetadataByFileIdReply)},
  { 224, -1, -1, sizeof(::bugu::service::v1::DeleteArtifactMetadataRequest)},
  { 232, -1, -1, sizeof(::bugu::service::v1::DeleteArtifactMetadataReply)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_RegisterRequest_User_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_RegisterRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_RegisterReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_LoginRequest_User_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_LoginRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_LoginReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetCurrentUserRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetCurrentUserReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_UpdateUserRequest_User_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_UpdateUserRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_UpdateUserReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_UserStruct_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetFileMetaRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetFileMetaReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetFileMetaByUserIdRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetFileMetaByUserIdReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_DeleteFileMetadataRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_DeleteFileMetadataReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_DetectRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_DetectReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_ConfusionRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_ConfusionReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_PackerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_PackerReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetArtifactMetadataRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetArtifactMetadataReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetArtifactMetadataByFileIdRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_GetArtifactMetadataByFileIdReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_DeleteArtifactMetadataRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu::service::v1::_DeleteArtifactMetadataReply_default_instance_),
};

const char descriptor_table_protodef_bugu_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\nbugu.proto\022\017bugu.service.v1\032\034google/ap"
  "i/annotations.proto\032.protoc-gen-openapiv"
  "2/options/annotations.proto\032\027validate/va"
  "lidate.proto\"\201\001\n\017RegisterRequest\0223\n\004user"
  "\030\001 \001(\0132%.bugu.service.v1.RegisterRequest"
  ".User\0329\n\004User\022\020\n\010username\030\001 \001(\t\022\r\n\005email"
  "\030\002 \001(\t\022\020\n\010password\030\003 \001(\t\":\n\rRegisterRepl"
  "y\022)\n\004user\030\001 \001(\0132\033.bugu.service.v1.UserSt"
  "ruct\"i\n\014LoginRequest\0220\n\004user\030\001 \001(\0132\".bug"
  "u.service.v1.LoginRequest.User\032\'\n\004User\022\r"
  "\n\005email\030\001 \001(\t\022\020\n\010password\030\002 \001(\t\"F\n\nLogin"
  "Reply\022)\n\004user\030\001 \001(\0132\033.bugu.service.v1.Us"
  "erStruct\022\r\n\005token\030\002 \001(\t\"-\n\025GetCurrentUse"
  "rRequest\022\024\n\002id\030\001 \001(\tB\010\372B\005r\003\260\001\001\"@\n\023GetCur"
  "rentUserReply\022)\n\004user\030\001 \001(\0132\033.bugu.servi"
  "ce.v1.UserStruct\"\221\001\n\021UpdateUserRequest\0225"
  "\n\004user\030\001 \001(\0132\'.bugu.service.v1.UpdateUse"
  "rRequest.User\032E\n\004User\022\n\n\002id\030\001 \001(\t\022\r\n\005ema"
  "il\030\002 \001(\t\022\020\n\010username\030\004 \001(\t\022\020\n\010password\030\005"
  " \001(\t\"<\n\017UpdateUserReply\022)\n\004user\030\001 \001(\0132\033."
  "bugu.service.v1.UserStruct\"C\n\nUserStruct"
  "\022\024\n\002id\030\001 \001(\tB\010\372B\005r\003\260\001\001\022\r\n\005email\030\002 \001(\t\022\020\n"
  "\010username\030\003 \001(\t\"J\n\022GetFileMetaRequest\022\031\n"
  "\007user_id\030\001 \001(\tB\010\372B\005r\003\260\001\001\022\031\n\007file_id\030\002 \001("
  "\tB\010\372B\005r\003\260\001\001\"\214\001\n\020GetFileMetaReply\022\031\n\007file"
  "_id\030\001 \001(\tB\010\372B\005r\003\260\001\001\022\022\n\nfile_sha_1\030\002 \001(\t\022"
  "\021\n\tfile_size\030\003 \001(\003\022\021\n\tfile_addr\030\004 \001(\t\022#\n"
  "\004type\030\005 \001(\0162\025.bugu.service.v1.Type\"7\n\032Ge"
  "tFileMetaByUserIdRequest\022\031\n\007user_id\030\001 \001("
  "\tB\010\372B\005r\003\260\001\001\"T\n\030GetFileMetaByUserIdReply\022"
  "8\n\rfile_metadata\030\001 \003(\0132!.bugu.service.v1"
  ".GetFileMetaReply\"Q\n\031DeleteFileMetadataR"
  "equest\022\031\n\007user_id\030\001 \001(\tB\010\372B\005r\003\260\001\001\022\031\n\007fil"
  "e_id\030\002 \001(\tB\010\372B\005r\003\260\001\001\"\031\n\027DeleteFileMetada"
  "taReply\"E\n\rDetectRequest\022\031\n\007user_id\030\001 \001("
  "\tB\010\372B\005r\003\260\001\001\022\031\n\007file_id\030\002 \001(\tB\010\372B\005r\003\260\001\001\","
  "\n\013DetectReply\022\035\n\013artifact_id\030\001 \001(\tB\010\372B\005r"
  "\003\260\001\001\"H\n\020ConfusionRequest\022\031\n\007user_id\030\001 \001("
  "\tB\010\372B\005r\003\260\001\001\022\031\n\007file_id\030\002 \001(\tB\010\372B\005r\003\260\001\001\"\200"
  "\001\n\016ConfusionReply\022\035\n\013artifact_id\030\001 \001(\tB\010"
  "\372B\005r\003\260\001\001\022\031\n\007file_id\030\002 \001(\tB\010\372B\005r\003\260\001\001\022$\n\022a"
  "ffiliated_file_id\030\003 \001(\tB\010\372B\005r\003\260\001\001\022\016\n\006met"
  "hod\030\004 \001(\t\"E\n\rPackerRequest\022\031\n\007user_id\030\001 "
  "\001(\tB\010\372B\005r\003\260\001\001\022\031\n\007file_id\030\002 \001(\tB\010\372B\005r\003\260\001\001"
  "\"}\n\013PackerReply\022\035\n\013artifact_id\030\001 \001(\tB\010\372B"
  "\005r\003\260\001\001\022\031\n\007file_id\030\002 \001(\tB\010\372B\005r\003\260\001\001\022$\n\022aff"
  "iliated_file_id\030\003 \001(\tB\010\372B\005r\003\260\001\001\022\016\n\006metho"
  "d\030\004 \001(\t\"V\n\032GetArtifactMetadataRequest\022\031\n"
  "\007user_id\030\001 \001(\tB\010\372B\005r\003\260\001\001\022\035\n\013artifact_id\030"
  "\002 \001(\tB\010\372B\005r\003\260\001\001\"\212\001\n\030GetArtifactMetadataR"
  "eply\022\035\n\013artifact_id\030\001 \001(\tB\010\372B\005r\003\260\001\001\022\031\n\007f"
  "ile_id\030\002 \001(\tB\010\372B\005r\003\260\001\001\022$\n\022affiliated_fil"
  "e_id\030\003 \001(\tB\010\372B\005r\003\260\001\001\022\016\n\006method\030\004 \001(\t\"Z\n\""
  "GetArtifactMetadataByFileIdRequest\022\031\n\007us"
  "er_id\030\001 \001(\tB\010\372B\005r\003\260\001\001\022\031\n\007file_id\030\002 \001(\tB\010"
  "\372B\005r\003\260\001\001\"h\n GetArtifactMetadataByFileIdR"
  "eply\022D\n\021artifact_metadata\030\001 \003(\0132).bugu.s"
  "ervice.v1.GetArtifactMetadataReply\"Y\n\035De"
  "leteArtifactMetadataRequest\022\031\n\007user_id\030\001"
  " \001(\tB\010\372B\005r\003\260\001\001\022\035\n\013artifact_id\030\002 \001(\tB\010\372B\005"
  "r\003\260\001\001\"\035\n\033DeleteArtifactMetadataReply*\333\003\n"
  "\004Type\022\021\n\rTYPE_ADPOSHEL\020\000\022\016\n\nTYPE_AGENT\020\001"
  "\022\020\n\014TYPE_ALLAPLE\020\002\022\022\n\016TYPE_AMONETIZE\020\003\022\017"
  "\n\013TYPE_ANDROM\020\004\022\020\n\014TYPE_AUTORUN\020\005\022\023\n\017TYP"
  "E_BROWSE_FOX\020\006\022\017\n\013TYPE_DINWOD\020\007\022\r\n\tTYPE_"
  "ELEX\020\010\022\017\n\013TYPE_EXPIRO\020\t\022\017\n\013TYPE_FASONG\020\n"
  "\022\021\n\rTYPE_HACK_KMS\020\013\022\r\n\tTYPE_HLUX\020\014\022\021\n\rTY"
  "PE_INJECTOR\020\r\022\025\n\021TYPE_INSTALL_CORE\020\016\022\023\n\017"
  "TYPE_MULTI_Plug\020\017\022\023\n\017TYPE_NEOREKLAMI\020\020\022\017"
  "\n\013TYPE_NESHTA\020\021\022\016\n\nTYPE_OTHER\020\022\022\017\n\013TYPE_"
  "REGRUN\020\023\022\017\n\013TYPE_SALITY\020\024\022\022\n\016TYPE_SNARAS"
  "ITE\020\025\022\022\n\016TYPE_STABTINKO\020\026\022\014\n\010TYPE_VBA\020\027\022"
  "\020\n\014TYPE_VBKRYPT\020\030\022\017\n\013TYPE_VILSEL\020\0312\331\016\n\004B"
  "ugu\022b\n\010Register\022 .bugu.service.v1.Regist"
  "erRequest\032\036.bugu.service.v1.RegisterRepl"
  "y\"\024\202\323\344\223\002\016\"\t/v1/users:\001*\022_\n\005Login\022\035.bugu."
  "service.v1.LoginRequest\032\033.bugu.service.v"
  "1.LoginReply\"\032\202\323\344\223\002\024\"\017/v1/users/login:\001*"
  "\022u\n\016GetCurrentUser\022&.bugu.service.v1.Get"
  "CurrentUserRequest\032$.bugu.service.v1.Get"
  "CurrentUserReply\"\025\202\323\344\223\002\017\022\r/v1/user/{id}\022"
  "h\n\nUpdateUser\022\".bugu.service.v1.UpdateUs"
  "erRequest\032 .bugu.service.v1.UpdateUserRe"
  "ply\"\024\202\323\344\223\002\016\032\t/v1/users:\001*\022\211\001\n\013GetFileMet"
  "a\022#.bugu.service.v1.GetFileMetaRequest\032!"
  ".bugu.service.v1.GetFileMetaReply\"2\202\323\344\223\002"
  ",\022*/v1/user/{user_id}/file/{file_id}/met"
  "adata\022\217\001\n\023GetFileMetaByUserId\022+.bugu.ser"
  "vice.v1.GetFileMetaByUserIdRequest\032).bug"
  "u.service.v1.GetFileMetaByUserIdReply\" \202"
  "\323\344\223\002\032\022\030/v1/user/{user_id}/files\022\236\001\n\022Dele"
  "teFileMetadata\022*.bugu.service.v1.DeleteF"
  "ileMetadataRequest\032(.bugu.service.v1.Del"
  "eteFileMetadataReply\"2\202\323\344\223\002,**/v1/user/{"
  "user_id}/file/{file_id}/metadata\022\223\001\n\006Det"
  "ect\022\036.bugu.service.v1.DetectRequest\032\034.bu"
  "gu.service.v1.DetectReply\"K\202\323\344\223\002E\022(/v1/u"
  "ser/{user_id}/file/{file_id}/detectZ\031\"\024/"
  "v1/user/file/detect:\001*\022\242\001\n\tConfusion\022!.b"
  "ugu.service.v1.ConfusionRequest\032\037.bugu.s"
  "ervice.v1.ConfusionReply\"Q\202\323\344\223\002K\022+/v1/us"
  "er/{user_id}/file/{file_id}/confusionZ\034\""
  "\027/v1/user/file/confusion:\001*\022\223\001\n\006Packer\022\036"
  ".bugu.service.v1.PackerRequest\032\034.bugu.se"
  "rvice.v1.PackerReply\"K\202\323\344\223\002E\022(/v1/user/{"
  "user_id}/file/{file_id}/packerZ\031\"\024/v1/us"
  "er/file/packer:\001*\022\251\001\n\023GetArtifactMetadat"
  "a\022+.bugu.service.v1.GetArtifactMetadataR"
  "equest\032).bugu.service.v1.GetArtifactMeta"
  "dataReply\":\202\323\344\223\0024\0222/v1/user/{user_id}/ar"
  "tifact/{artifact_id}/metadata\022\271\001\n\033GetArt"
  "ifactMetadataByFileId\0223.bugu.service.v1."
  "GetArtifactMetadataByFileIdRequest\0321.bug"
  "u.service.v1.GetArtifactMetadataByFileId"
  "Reply\"2\202\323\344\223\002,\022*/v1/user/{user_id}/artifa"
  "ct/file/{file_id}\022\262\001\n\026DeleteArtifactMeta"
  "data\022..bugu.service.v1.DeleteArtifactMet"
  "adataRequest\032,.bugu.service.v1.DeleteArt"
  "ifactMetadataReply\":\202\323\344\223\0024*2/v1/user/{us"
  "er_id}/artifact/{artifact_id}/metadataB\264"
  "\001Z.github.com/hominsu/bugu/api/bugu/serv"
  "ice/v1;v1\222A\200\001\022W\n\nE-Code API\"D\n\014Bugu Back"
  "end\022\037https://github.com/hominsu/bugu\032\023ho"
  "minsu@foxmail.com2\0031.0*\001\0022\020application/j"
  "son:\020application/jsonb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_bugu_2eproto_deps[3] = {
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_protoc_2dgen_2dopenapiv2_2foptions_2fannotations_2eproto,
  &::descriptor_table_validate_2fvalidate_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_bugu_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bugu_2eproto = {
  false, false, 4989, descriptor_table_protodef_bugu_2eproto, "bugu.proto", 
  &descriptor_table_bugu_2eproto_once, descriptor_table_bugu_2eproto_deps, 3, 30,
  schemas, file_default_instances, TableStruct_bugu_2eproto::offsets,
  file_level_metadata_bugu_2eproto, file_level_enum_descriptors_bugu_2eproto, file_level_service_descriptors_bugu_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_bugu_2eproto_getter() {
  return &descriptor_table_bugu_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_bugu_2eproto(&descriptor_table_bugu_2eproto);
namespace bugu {
namespace service {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bugu_2eproto);
  return file_level_enum_descriptors_bugu_2eproto[0];
}
bool Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class RegisterRequest_User::_Internal {
 public:
};

RegisterRequest_User::RegisterRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.RegisterRequest.User)
}
RegisterRequest_User::RegisterRequest_User(const RegisterRequest_User& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_username(), 
      GetArenaForAllocation());
  }
  email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_email(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.RegisterRequest.User)
}

inline void RegisterRequest_User::SharedCtor() {
username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RegisterRequest_User::~RegisterRequest_User() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.RegisterRequest.User)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RegisterRequest_User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  username_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  email_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RegisterRequest_User::ArenaDtor(void* object) {
  RegisterRequest_User* _this = reinterpret_cast< RegisterRequest_User* >(object);
  (void)_this;
}
void RegisterRequest_User::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RegisterRequest_User::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegisterRequest_User::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.RegisterRequest.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  username_.ClearToEmpty();
  email_.ClearToEmpty();
  password_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegisterRequest_User::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string username = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_username();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.RegisterRequest.User.username"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_email();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.RegisterRequest.User.email"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.RegisterRequest.User.password"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterRequest_User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.RegisterRequest.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string username = 1;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.RegisterRequest.User.username");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_username(), target);
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.RegisterRequest.User.email");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_email(), target);
  }

  // string password = 3;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.RegisterRequest.User.password");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.RegisterRequest.User)
  return target;
}

size_t RegisterRequest_User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.RegisterRequest.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string username = 1;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string password = 3;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegisterRequest_User::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegisterRequest_User::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegisterRequest_User::GetClassData() const { return &_class_data_; }

void RegisterRequest_User::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegisterRequest_User *>(to)->MergeFrom(
      static_cast<const RegisterRequest_User &>(from));
}


void RegisterRequest_User::MergeFrom(const RegisterRequest_User& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.RegisterRequest.User)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_username().empty()) {
    _internal_set_username(from._internal_username());
  }
  if (!from._internal_email().empty()) {
    _internal_set_email(from._internal_email());
  }
  if (!from._internal_password().empty()) {
    _internal_set_password(from._internal_password());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegisterRequest_User::CopyFrom(const RegisterRequest_User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.RegisterRequest.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterRequest_User::IsInitialized() const {
  return true;
}

void RegisterRequest_User::InternalSwap(RegisterRequest_User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &username_, lhs_arena,
      &other->username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &email_, lhs_arena,
      &other->email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RegisterRequest_User::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[0]);
}

// ===================================================================

class RegisterRequest::_Internal {
 public:
  static const ::bugu::service::v1::RegisterRequest_User& user(const RegisterRequest* msg);
};

const ::bugu::service::v1::RegisterRequest_User&
RegisterRequest::_Internal::user(const RegisterRequest* msg) {
  return *msg->user_;
}
RegisterRequest::RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.RegisterRequest)
}
RegisterRequest::RegisterRequest(const RegisterRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    user_ = new ::bugu::service::v1::RegisterRequest_User(*from.user_);
  } else {
    user_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.RegisterRequest)
}

inline void RegisterRequest::SharedCtor() {
user_ = nullptr;
}

RegisterRequest::~RegisterRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.RegisterRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RegisterRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete user_;
}

void RegisterRequest::ArenaDtor(void* object) {
  RegisterRequest* _this = reinterpret_cast< RegisterRequest* >(object);
  (void)_this;
}
void RegisterRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RegisterRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegisterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.RegisterRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegisterRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .bugu.service.v1.RegisterRequest.User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.RegisterRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .bugu.service.v1.RegisterRequest.User user = 1;
  if (this->_internal_has_user()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::user(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.RegisterRequest)
  return target;
}

size_t RegisterRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.RegisterRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bugu.service.v1.RegisterRequest.User user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegisterRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegisterRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegisterRequest::GetClassData() const { return &_class_data_; }

void RegisterRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegisterRequest *>(to)->MergeFrom(
      static_cast<const RegisterRequest &>(from));
}


void RegisterRequest::MergeFrom(const RegisterRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.RegisterRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _internal_mutable_user()->::bugu::service::v1::RegisterRequest_User::MergeFrom(from._internal_user());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegisterRequest::CopyFrom(const RegisterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.RegisterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterRequest::IsInitialized() const {
  return true;
}

void RegisterRequest::InternalSwap(RegisterRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(user_, other->user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RegisterRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[1]);
}

// ===================================================================

class RegisterReply::_Internal {
 public:
  static const ::bugu::service::v1::UserStruct& user(const RegisterReply* msg);
};

const ::bugu::service::v1::UserStruct&
RegisterReply::_Internal::user(const RegisterReply* msg) {
  return *msg->user_;
}
RegisterReply::RegisterReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.RegisterReply)
}
RegisterReply::RegisterReply(const RegisterReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    user_ = new ::bugu::service::v1::UserStruct(*from.user_);
  } else {
    user_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.RegisterReply)
}

inline void RegisterReply::SharedCtor() {
user_ = nullptr;
}

RegisterReply::~RegisterReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.RegisterReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RegisterReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete user_;
}

void RegisterReply::ArenaDtor(void* object) {
  RegisterReply* _this = reinterpret_cast< RegisterReply* >(object);
  (void)_this;
}
void RegisterReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RegisterReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegisterReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.RegisterReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegisterReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .bugu.service.v1.UserStruct user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.RegisterReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .bugu.service.v1.UserStruct user = 1;
  if (this->_internal_has_user()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::user(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.RegisterReply)
  return target;
}

size_t RegisterReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.RegisterReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bugu.service.v1.UserStruct user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegisterReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegisterReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegisterReply::GetClassData() const { return &_class_data_; }

void RegisterReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegisterReply *>(to)->MergeFrom(
      static_cast<const RegisterReply &>(from));
}


void RegisterReply::MergeFrom(const RegisterReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.RegisterReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _internal_mutable_user()->::bugu::service::v1::UserStruct::MergeFrom(from._internal_user());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegisterReply::CopyFrom(const RegisterReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.RegisterReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterReply::IsInitialized() const {
  return true;
}

void RegisterReply::InternalSwap(RegisterReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(user_, other->user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RegisterReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[2]);
}

// ===================================================================

class LoginRequest_User::_Internal {
 public:
};

LoginRequest_User::LoginRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.LoginRequest.User)
}
LoginRequest_User::LoginRequest_User(const LoginRequest_User& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_email(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.LoginRequest.User)
}

inline void LoginRequest_User::SharedCtor() {
email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginRequest_User::~LoginRequest_User() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.LoginRequest.User)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LoginRequest_User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  email_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LoginRequest_User::ArenaDtor(void* object) {
  LoginRequest_User* _this = reinterpret_cast< LoginRequest_User* >(object);
  (void)_this;
}
void LoginRequest_User::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoginRequest_User::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginRequest_User::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.LoginRequest.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  email_.ClearToEmpty();
  password_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginRequest_User::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string email = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_email();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.LoginRequest.User.email"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.LoginRequest.User.password"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginRequest_User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.LoginRequest.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string email = 1;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.LoginRequest.User.email");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_email(), target);
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.LoginRequest.User.password");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.LoginRequest.User)
  return target;
}

size_t LoginRequest_User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.LoginRequest.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string email = 1;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginRequest_User::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LoginRequest_User::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginRequest_User::GetClassData() const { return &_class_data_; }

void LoginRequest_User::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LoginRequest_User *>(to)->MergeFrom(
      static_cast<const LoginRequest_User &>(from));
}


void LoginRequest_User::MergeFrom(const LoginRequest_User& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.LoginRequest.User)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_email().empty()) {
    _internal_set_email(from._internal_email());
  }
  if (!from._internal_password().empty()) {
    _internal_set_password(from._internal_password());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginRequest_User::CopyFrom(const LoginRequest_User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.LoginRequest.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRequest_User::IsInitialized() const {
  return true;
}

void LoginRequest_User::InternalSwap(LoginRequest_User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &email_, lhs_arena,
      &other->email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginRequest_User::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[3]);
}

// ===================================================================

class LoginRequest::_Internal {
 public:
  static const ::bugu::service::v1::LoginRequest_User& user(const LoginRequest* msg);
};

const ::bugu::service::v1::LoginRequest_User&
LoginRequest::_Internal::user(const LoginRequest* msg) {
  return *msg->user_;
}
LoginRequest::LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.LoginRequest)
}
LoginRequest::LoginRequest(const LoginRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    user_ = new ::bugu::service::v1::LoginRequest_User(*from.user_);
  } else {
    user_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.LoginRequest)
}

inline void LoginRequest::SharedCtor() {
user_ = nullptr;
}

LoginRequest::~LoginRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.LoginRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LoginRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete user_;
}

void LoginRequest::ArenaDtor(void* object) {
  LoginRequest* _this = reinterpret_cast< LoginRequest* >(object);
  (void)_this;
}
void LoginRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoginRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.LoginRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .bugu.service.v1.LoginRequest.User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.LoginRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .bugu.service.v1.LoginRequest.User user = 1;
  if (this->_internal_has_user()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::user(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.LoginRequest)
  return target;
}

size_t LoginRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.LoginRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bugu.service.v1.LoginRequest.User user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LoginRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginRequest::GetClassData() const { return &_class_data_; }

void LoginRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LoginRequest *>(to)->MergeFrom(
      static_cast<const LoginRequest &>(from));
}


void LoginRequest::MergeFrom(const LoginRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.LoginRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _internal_mutable_user()->::bugu::service::v1::LoginRequest_User::MergeFrom(from._internal_user());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginRequest::CopyFrom(const LoginRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.LoginRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRequest::IsInitialized() const {
  return true;
}

void LoginRequest::InternalSwap(LoginRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(user_, other->user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[4]);
}

// ===================================================================

class LoginReply::_Internal {
 public:
  static const ::bugu::service::v1::UserStruct& user(const LoginReply* msg);
};

const ::bugu::service::v1::UserStruct&
LoginReply::_Internal::user(const LoginReply* msg) {
  return *msg->user_;
}
LoginReply::LoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.LoginReply)
}
LoginReply::LoginReply(const LoginReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_token().empty()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_user()) {
    user_ = new ::bugu::service::v1::UserStruct(*from.user_);
  } else {
    user_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.LoginReply)
}

inline void LoginReply::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_ = nullptr;
}

LoginReply::~LoginReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.LoginReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LoginReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete user_;
}

void LoginReply::ArenaDtor(void* object) {
  LoginReply* _this = reinterpret_cast< LoginReply* >(object);
  (void)_this;
}
void LoginReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoginReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.LoginReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  token_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .bugu.service.v1.UserStruct user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.LoginReply.token"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.LoginReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .bugu.service.v1.UserStruct user = 1;
  if (this->_internal_has_user()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::user(this), target, stream);
  }

  // string token = 2;
  if (!this->_internal_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.LoginReply.token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.LoginReply)
  return target;
}

size_t LoginReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.LoginReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string token = 2;
  if (!this->_internal_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());
  }

  // .bugu.service.v1.UserStruct user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LoginReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginReply::GetClassData() const { return &_class_data_; }

void LoginReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LoginReply *>(to)->MergeFrom(
      static_cast<const LoginReply &>(from));
}


void LoginReply::MergeFrom(const LoginReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.LoginReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_token().empty()) {
    _internal_set_token(from._internal_token());
  }
  if (from._internal_has_user()) {
    _internal_mutable_user()->::bugu::service::v1::UserStruct::MergeFrom(from._internal_user());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginReply::CopyFrom(const LoginReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.LoginReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReply::IsInitialized() const {
  return true;
}

void LoginReply::InternalSwap(LoginReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  swap(user_, other->user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[5]);
}

// ===================================================================

class GetCurrentUserRequest::_Internal {
 public:
};

GetCurrentUserRequest::GetCurrentUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetCurrentUserRequest)
}
GetCurrentUserRequest::GetCurrentUserRequest(const GetCurrentUserRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetCurrentUserRequest)
}

inline void GetCurrentUserRequest::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetCurrentUserRequest::~GetCurrentUserRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetCurrentUserRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetCurrentUserRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetCurrentUserRequest::ArenaDtor(void* object) {
  GetCurrentUserRequest* _this = reinterpret_cast< GetCurrentUserRequest* >(object);
  (void)_this;
}
void GetCurrentUserRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetCurrentUserRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetCurrentUserRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetCurrentUserRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetCurrentUserRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetCurrentUserRequest.id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetCurrentUserRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetCurrentUserRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [(.validate.rules) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetCurrentUserRequest.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetCurrentUserRequest)
  return target;
}

size_t GetCurrentUserRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetCurrentUserRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [(.validate.rules) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetCurrentUserRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetCurrentUserRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetCurrentUserRequest::GetClassData() const { return &_class_data_; }

void GetCurrentUserRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetCurrentUserRequest *>(to)->MergeFrom(
      static_cast<const GetCurrentUserRequest &>(from));
}


void GetCurrentUserRequest::MergeFrom(const GetCurrentUserRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetCurrentUserRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetCurrentUserRequest::CopyFrom(const GetCurrentUserRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetCurrentUserRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCurrentUserRequest::IsInitialized() const {
  return true;
}

void GetCurrentUserRequest::InternalSwap(GetCurrentUserRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetCurrentUserRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[6]);
}

// ===================================================================

class GetCurrentUserReply::_Internal {
 public:
  static const ::bugu::service::v1::UserStruct& user(const GetCurrentUserReply* msg);
};

const ::bugu::service::v1::UserStruct&
GetCurrentUserReply::_Internal::user(const GetCurrentUserReply* msg) {
  return *msg->user_;
}
GetCurrentUserReply::GetCurrentUserReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetCurrentUserReply)
}
GetCurrentUserReply::GetCurrentUserReply(const GetCurrentUserReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    user_ = new ::bugu::service::v1::UserStruct(*from.user_);
  } else {
    user_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetCurrentUserReply)
}

inline void GetCurrentUserReply::SharedCtor() {
user_ = nullptr;
}

GetCurrentUserReply::~GetCurrentUserReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetCurrentUserReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetCurrentUserReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete user_;
}

void GetCurrentUserReply::ArenaDtor(void* object) {
  GetCurrentUserReply* _this = reinterpret_cast< GetCurrentUserReply* >(object);
  (void)_this;
}
void GetCurrentUserReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetCurrentUserReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetCurrentUserReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetCurrentUserReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetCurrentUserReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .bugu.service.v1.UserStruct user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetCurrentUserReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetCurrentUserReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .bugu.service.v1.UserStruct user = 1;
  if (this->_internal_has_user()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::user(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetCurrentUserReply)
  return target;
}

size_t GetCurrentUserReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetCurrentUserReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bugu.service.v1.UserStruct user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetCurrentUserReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetCurrentUserReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetCurrentUserReply::GetClassData() const { return &_class_data_; }

void GetCurrentUserReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetCurrentUserReply *>(to)->MergeFrom(
      static_cast<const GetCurrentUserReply &>(from));
}


void GetCurrentUserReply::MergeFrom(const GetCurrentUserReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetCurrentUserReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _internal_mutable_user()->::bugu::service::v1::UserStruct::MergeFrom(from._internal_user());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetCurrentUserReply::CopyFrom(const GetCurrentUserReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetCurrentUserReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCurrentUserReply::IsInitialized() const {
  return true;
}

void GetCurrentUserReply::InternalSwap(GetCurrentUserReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(user_, other->user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetCurrentUserReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[7]);
}

// ===================================================================

class UpdateUserRequest_User::_Internal {
 public:
};

UpdateUserRequest_User::UpdateUserRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.UpdateUserRequest.User)
}
UpdateUserRequest_User::UpdateUserRequest_User(const UpdateUserRequest_User& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_email(), 
      GetArenaForAllocation());
  }
  username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_username(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.UpdateUserRequest.User)
}

inline void UpdateUserRequest_User::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateUserRequest_User::~UpdateUserRequest_User() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.UpdateUserRequest.User)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateUserRequest_User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  email_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  username_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UpdateUserRequest_User::ArenaDtor(void* object) {
  UpdateUserRequest_User* _this = reinterpret_cast< UpdateUserRequest_User* >(object);
  (void)_this;
}
void UpdateUserRequest_User::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateUserRequest_User::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateUserRequest_User::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.UpdateUserRequest.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_.ClearToEmpty();
  email_.ClearToEmpty();
  username_.ClearToEmpty();
  password_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateUserRequest_User::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.UpdateUserRequest.User.id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_email();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.UpdateUserRequest.User.email"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string username = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_username();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.UpdateUserRequest.User.username"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string password = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.UpdateUserRequest.User.password"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateUserRequest_User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.UpdateUserRequest.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.UpdateUserRequest.User.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.UpdateUserRequest.User.email");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_email(), target);
  }

  // string username = 4;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.UpdateUserRequest.User.username");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_username(), target);
  }

  // string password = 5;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.UpdateUserRequest.User.password");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.UpdateUserRequest.User)
  return target;
}

size_t UpdateUserRequest_User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.UpdateUserRequest.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string username = 4;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  // string password = 5;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateUserRequest_User::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateUserRequest_User::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateUserRequest_User::GetClassData() const { return &_class_data_; }

void UpdateUserRequest_User::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateUserRequest_User *>(to)->MergeFrom(
      static_cast<const UpdateUserRequest_User &>(from));
}


void UpdateUserRequest_User::MergeFrom(const UpdateUserRequest_User& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.UpdateUserRequest.User)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _internal_set_id(from._internal_id());
  }
  if (!from._internal_email().empty()) {
    _internal_set_email(from._internal_email());
  }
  if (!from._internal_username().empty()) {
    _internal_set_username(from._internal_username());
  }
  if (!from._internal_password().empty()) {
    _internal_set_password(from._internal_password());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateUserRequest_User::CopyFrom(const UpdateUserRequest_User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.UpdateUserRequest.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateUserRequest_User::IsInitialized() const {
  return true;
}

void UpdateUserRequest_User::InternalSwap(UpdateUserRequest_User* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &email_, lhs_arena,
      &other->email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &username_, lhs_arena,
      &other->username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateUserRequest_User::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[8]);
}

// ===================================================================

class UpdateUserRequest::_Internal {
 public:
  static const ::bugu::service::v1::UpdateUserRequest_User& user(const UpdateUserRequest* msg);
};

const ::bugu::service::v1::UpdateUserRequest_User&
UpdateUserRequest::_Internal::user(const UpdateUserRequest* msg) {
  return *msg->user_;
}
UpdateUserRequest::UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.UpdateUserRequest)
}
UpdateUserRequest::UpdateUserRequest(const UpdateUserRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    user_ = new ::bugu::service::v1::UpdateUserRequest_User(*from.user_);
  } else {
    user_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.UpdateUserRequest)
}

inline void UpdateUserRequest::SharedCtor() {
user_ = nullptr;
}

UpdateUserRequest::~UpdateUserRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.UpdateUserRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateUserRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete user_;
}

void UpdateUserRequest::ArenaDtor(void* object) {
  UpdateUserRequest* _this = reinterpret_cast< UpdateUserRequest* >(object);
  (void)_this;
}
void UpdateUserRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateUserRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateUserRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.UpdateUserRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateUserRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .bugu.service.v1.UpdateUserRequest.User user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateUserRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.UpdateUserRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .bugu.service.v1.UpdateUserRequest.User user = 1;
  if (this->_internal_has_user()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::user(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.UpdateUserRequest)
  return target;
}

size_t UpdateUserRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.UpdateUserRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bugu.service.v1.UpdateUserRequest.User user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateUserRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateUserRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateUserRequest::GetClassData() const { return &_class_data_; }

void UpdateUserRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateUserRequest *>(to)->MergeFrom(
      static_cast<const UpdateUserRequest &>(from));
}


void UpdateUserRequest::MergeFrom(const UpdateUserRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.UpdateUserRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _internal_mutable_user()->::bugu::service::v1::UpdateUserRequest_User::MergeFrom(from._internal_user());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateUserRequest::CopyFrom(const UpdateUserRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.UpdateUserRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateUserRequest::IsInitialized() const {
  return true;
}

void UpdateUserRequest::InternalSwap(UpdateUserRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(user_, other->user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateUserRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[9]);
}

// ===================================================================

class UpdateUserReply::_Internal {
 public:
  static const ::bugu::service::v1::UserStruct& user(const UpdateUserReply* msg);
};

const ::bugu::service::v1::UserStruct&
UpdateUserReply::_Internal::user(const UpdateUserReply* msg) {
  return *msg->user_;
}
UpdateUserReply::UpdateUserReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.UpdateUserReply)
}
UpdateUserReply::UpdateUserReply(const UpdateUserReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user()) {
    user_ = new ::bugu::service::v1::UserStruct(*from.user_);
  } else {
    user_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.UpdateUserReply)
}

inline void UpdateUserReply::SharedCtor() {
user_ = nullptr;
}

UpdateUserReply::~UpdateUserReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.UpdateUserReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateUserReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete user_;
}

void UpdateUserReply::ArenaDtor(void* object) {
  UpdateUserReply* _this = reinterpret_cast< UpdateUserReply* >(object);
  (void)_this;
}
void UpdateUserReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateUserReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateUserReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.UpdateUserReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateUserReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .bugu.service.v1.UserStruct user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateUserReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.UpdateUserReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .bugu.service.v1.UserStruct user = 1;
  if (this->_internal_has_user()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::user(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.UpdateUserReply)
  return target;
}

size_t UpdateUserReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.UpdateUserReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bugu.service.v1.UserStruct user = 1;
  if (this->_internal_has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateUserReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateUserReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateUserReply::GetClassData() const { return &_class_data_; }

void UpdateUserReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateUserReply *>(to)->MergeFrom(
      static_cast<const UpdateUserReply &>(from));
}


void UpdateUserReply::MergeFrom(const UpdateUserReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.UpdateUserReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user()) {
    _internal_mutable_user()->::bugu::service::v1::UserStruct::MergeFrom(from._internal_user());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateUserReply::CopyFrom(const UpdateUserReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.UpdateUserReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateUserReply::IsInitialized() const {
  return true;
}

void UpdateUserReply::InternalSwap(UpdateUserReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(user_, other->user_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateUserReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[10]);
}

// ===================================================================

class UserStruct::_Internal {
 public:
};

UserStruct::UserStruct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.UserStruct)
}
UserStruct::UserStruct(const UserStruct& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_email(), 
      GetArenaForAllocation());
  }
  username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_username(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.UserStruct)
}

inline void UserStruct::SharedCtor() {
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
email_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserStruct::~UserStruct() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.UserStruct)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UserStruct::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  email_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  username_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UserStruct::ArenaDtor(void* object) {
  UserStruct* _this = reinterpret_cast< UserStruct* >(object);
  (void)_this;
}
void UserStruct::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserStruct::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserStruct::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.UserStruct)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_.ClearToEmpty();
  email_.ClearToEmpty();
  username_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserStruct::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.UserStruct.id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_email();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.UserStruct.email"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string username = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_username();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.UserStruct.username"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserStruct::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.UserStruct)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1 [(.validate.rules) = {
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.UserStruct.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.UserStruct.email");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_email(), target);
  }

  // string username = 3;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.UserStruct.username");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_username(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.UserStruct)
  return target;
}

size_t UserStruct::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.UserStruct)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1 [(.validate.rules) = {
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string username = 3;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserStruct::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserStruct::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserStruct::GetClassData() const { return &_class_data_; }

void UserStruct::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserStruct *>(to)->MergeFrom(
      static_cast<const UserStruct &>(from));
}


void UserStruct::MergeFrom(const UserStruct& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.UserStruct)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _internal_set_id(from._internal_id());
  }
  if (!from._internal_email().empty()) {
    _internal_set_email(from._internal_email());
  }
  if (!from._internal_username().empty()) {
    _internal_set_username(from._internal_username());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserStruct::CopyFrom(const UserStruct& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.UserStruct)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserStruct::IsInitialized() const {
  return true;
}

void UserStruct::InternalSwap(UserStruct* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &email_, lhs_arena,
      &other->email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &username_, lhs_arena,
      &other->username_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata UserStruct::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[11]);
}

// ===================================================================

class GetFileMetaRequest::_Internal {
 public:
};

GetFileMetaRequest::GetFileMetaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetFileMetaRequest)
}
GetFileMetaRequest::GetFileMetaRequest(const GetFileMetaRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetFileMetaRequest)
}

inline void GetFileMetaRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetFileMetaRequest::~GetFileMetaRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetFileMetaRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetFileMetaRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetFileMetaRequest::ArenaDtor(void* object) {
  GetFileMetaRequest* _this = reinterpret_cast< GetFileMetaRequest* >(object);
  (void)_this;
}
void GetFileMetaRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetFileMetaRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetFileMetaRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetFileMetaRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetFileMetaRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetFileMetaRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetFileMetaRequest.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetFileMetaRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetFileMetaRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetFileMetaRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetFileMetaRequest.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetFileMetaRequest)
  return target;
}

size_t GetFileMetaRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetFileMetaRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFileMetaRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetFileMetaRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFileMetaRequest::GetClassData() const { return &_class_data_; }

void GetFileMetaRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetFileMetaRequest *>(to)->MergeFrom(
      static_cast<const GetFileMetaRequest &>(from));
}


void GetFileMetaRequest::MergeFrom(const GetFileMetaRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetFileMetaRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetFileMetaRequest::CopyFrom(const GetFileMetaRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetFileMetaRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFileMetaRequest::IsInitialized() const {
  return true;
}

void GetFileMetaRequest::InternalSwap(GetFileMetaRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetFileMetaRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[12]);
}

// ===================================================================

class GetFileMetaReply::_Internal {
 public:
};

GetFileMetaReply::GetFileMetaReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetFileMetaReply)
}
GetFileMetaReply::GetFileMetaReply(const GetFileMetaReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  file_sha_1_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_sha_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_sha_1().empty()) {
    file_sha_1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_sha_1(), 
      GetArenaForAllocation());
  }
  file_addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_addr().empty()) {
    file_addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_addr(), 
      GetArenaForAllocation());
  }
  ::memcpy(&file_size_, &from.file_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&file_size_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetFileMetaReply)
}

inline void GetFileMetaReply::SharedCtor() {
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_sha_1_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_sha_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&file_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&file_size_)) + sizeof(type_));
}

GetFileMetaReply::~GetFileMetaReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetFileMetaReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetFileMetaReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_sha_1_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_addr_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetFileMetaReply::ArenaDtor(void* object) {
  GetFileMetaReply* _this = reinterpret_cast< GetFileMetaReply* >(object);
  (void)_this;
}
void GetFileMetaReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetFileMetaReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetFileMetaReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetFileMetaReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  file_id_.ClearToEmpty();
  file_sha_1_.ClearToEmpty();
  file_addr_.ClearToEmpty();
  ::memset(&file_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&file_size_)) + sizeof(type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetFileMetaReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string file_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetFileMetaReply.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_sha_1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_sha_1();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetFileMetaReply.file_sha_1"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 file_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_addr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_file_addr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetFileMetaReply.file_addr"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .bugu.service.v1.Type type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::bugu::service::v1::Type>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetFileMetaReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetFileMetaReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string file_id = 1 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetFileMetaReply.file_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_file_id(), target);
  }

  // string file_sha_1 = 2;
  if (!this->_internal_file_sha_1().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_sha_1().data(), static_cast<int>(this->_internal_file_sha_1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetFileMetaReply.file_sha_1");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_sha_1(), target);
  }

  // int64 file_size = 3;
  if (this->_internal_file_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_file_size(), target);
  }

  // string file_addr = 4;
  if (!this->_internal_file_addr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_addr().data(), static_cast<int>(this->_internal_file_addr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetFileMetaReply.file_addr");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_file_addr(), target);
  }

  // .bugu.service.v1.Type type = 5;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetFileMetaReply)
  return target;
}

size_t GetFileMetaReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetFileMetaReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string file_id = 1 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  // string file_sha_1 = 2;
  if (!this->_internal_file_sha_1().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_sha_1());
  }

  // string file_addr = 4;
  if (!this->_internal_file_addr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_addr());
  }

  // int64 file_size = 3;
  if (this->_internal_file_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_file_size());
  }

  // .bugu.service.v1.Type type = 5;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFileMetaReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetFileMetaReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFileMetaReply::GetClassData() const { return &_class_data_; }

void GetFileMetaReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetFileMetaReply *>(to)->MergeFrom(
      static_cast<const GetFileMetaReply &>(from));
}


void GetFileMetaReply::MergeFrom(const GetFileMetaReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetFileMetaReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  if (!from._internal_file_sha_1().empty()) {
    _internal_set_file_sha_1(from._internal_file_sha_1());
  }
  if (!from._internal_file_addr().empty()) {
    _internal_set_file_addr(from._internal_file_addr());
  }
  if (from._internal_file_size() != 0) {
    _internal_set_file_size(from._internal_file_size());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetFileMetaReply::CopyFrom(const GetFileMetaReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetFileMetaReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFileMetaReply::IsInitialized() const {
  return true;
}

void GetFileMetaReply::InternalSwap(GetFileMetaReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_sha_1_, lhs_arena,
      &other->file_sha_1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_addr_, lhs_arena,
      &other->file_addr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetFileMetaReply, type_)
      + sizeof(GetFileMetaReply::type_)
      - PROTOBUF_FIELD_OFFSET(GetFileMetaReply, file_size_)>(
          reinterpret_cast<char*>(&file_size_),
          reinterpret_cast<char*>(&other->file_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetFileMetaReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[13]);
}

// ===================================================================

class GetFileMetaByUserIdRequest::_Internal {
 public:
};

GetFileMetaByUserIdRequest::GetFileMetaByUserIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetFileMetaByUserIdRequest)
}
GetFileMetaByUserIdRequest::GetFileMetaByUserIdRequest(const GetFileMetaByUserIdRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetFileMetaByUserIdRequest)
}

inline void GetFileMetaByUserIdRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetFileMetaByUserIdRequest::~GetFileMetaByUserIdRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetFileMetaByUserIdRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetFileMetaByUserIdRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetFileMetaByUserIdRequest::ArenaDtor(void* object) {
  GetFileMetaByUserIdRequest* _this = reinterpret_cast< GetFileMetaByUserIdRequest* >(object);
  (void)_this;
}
void GetFileMetaByUserIdRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetFileMetaByUserIdRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetFileMetaByUserIdRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetFileMetaByUserIdRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetFileMetaByUserIdRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetFileMetaByUserIdRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetFileMetaByUserIdRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetFileMetaByUserIdRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetFileMetaByUserIdRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetFileMetaByUserIdRequest)
  return target;
}

size_t GetFileMetaByUserIdRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetFileMetaByUserIdRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFileMetaByUserIdRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetFileMetaByUserIdRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFileMetaByUserIdRequest::GetClassData() const { return &_class_data_; }

void GetFileMetaByUserIdRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetFileMetaByUserIdRequest *>(to)->MergeFrom(
      static_cast<const GetFileMetaByUserIdRequest &>(from));
}


void GetFileMetaByUserIdRequest::MergeFrom(const GetFileMetaByUserIdRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetFileMetaByUserIdRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetFileMetaByUserIdRequest::CopyFrom(const GetFileMetaByUserIdRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetFileMetaByUserIdRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFileMetaByUserIdRequest::IsInitialized() const {
  return true;
}

void GetFileMetaByUserIdRequest::InternalSwap(GetFileMetaByUserIdRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetFileMetaByUserIdRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[14]);
}

// ===================================================================

class GetFileMetaByUserIdReply::_Internal {
 public:
};

GetFileMetaByUserIdReply::GetFileMetaByUserIdReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  file_metadata_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetFileMetaByUserIdReply)
}
GetFileMetaByUserIdReply::GetFileMetaByUserIdReply(const GetFileMetaByUserIdReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      file_metadata_(from.file_metadata_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetFileMetaByUserIdReply)
}

inline void GetFileMetaByUserIdReply::SharedCtor() {
}

GetFileMetaByUserIdReply::~GetFileMetaByUserIdReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetFileMetaByUserIdReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetFileMetaByUserIdReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetFileMetaByUserIdReply::ArenaDtor(void* object) {
  GetFileMetaByUserIdReply* _this = reinterpret_cast< GetFileMetaByUserIdReply* >(object);
  (void)_this;
}
void GetFileMetaByUserIdReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetFileMetaByUserIdReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetFileMetaByUserIdReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetFileMetaByUserIdReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  file_metadata_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetFileMetaByUserIdReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .bugu.service.v1.GetFileMetaReply file_metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_file_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetFileMetaByUserIdReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetFileMetaByUserIdReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .bugu.service.v1.GetFileMetaReply file_metadata = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_file_metadata_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_file_metadata(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetFileMetaByUserIdReply)
  return target;
}

size_t GetFileMetaByUserIdReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetFileMetaByUserIdReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .bugu.service.v1.GetFileMetaReply file_metadata = 1;
  total_size += 1UL * this->_internal_file_metadata_size();
  for (const auto& msg : this->file_metadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetFileMetaByUserIdReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetFileMetaByUserIdReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetFileMetaByUserIdReply::GetClassData() const { return &_class_data_; }

void GetFileMetaByUserIdReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetFileMetaByUserIdReply *>(to)->MergeFrom(
      static_cast<const GetFileMetaByUserIdReply &>(from));
}


void GetFileMetaByUserIdReply::MergeFrom(const GetFileMetaByUserIdReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetFileMetaByUserIdReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  file_metadata_.MergeFrom(from.file_metadata_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetFileMetaByUserIdReply::CopyFrom(const GetFileMetaByUserIdReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetFileMetaByUserIdReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFileMetaByUserIdReply::IsInitialized() const {
  return true;
}

void GetFileMetaByUserIdReply::InternalSwap(GetFileMetaByUserIdReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  file_metadata_.InternalSwap(&other->file_metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetFileMetaByUserIdReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[15]);
}

// ===================================================================

class DeleteFileMetadataRequest::_Internal {
 public:
};

DeleteFileMetadataRequest::DeleteFileMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.DeleteFileMetadataRequest)
}
DeleteFileMetadataRequest::DeleteFileMetadataRequest(const DeleteFileMetadataRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.DeleteFileMetadataRequest)
}

inline void DeleteFileMetadataRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteFileMetadataRequest::~DeleteFileMetadataRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.DeleteFileMetadataRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteFileMetadataRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DeleteFileMetadataRequest::ArenaDtor(void* object) {
  DeleteFileMetadataRequest* _this = reinterpret_cast< DeleteFileMetadataRequest* >(object);
  (void)_this;
}
void DeleteFileMetadataRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteFileMetadataRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteFileMetadataRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.DeleteFileMetadataRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteFileMetadataRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.DeleteFileMetadataRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.DeleteFileMetadataRequest.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteFileMetadataRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.DeleteFileMetadataRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.DeleteFileMetadataRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.DeleteFileMetadataRequest.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.DeleteFileMetadataRequest)
  return target;
}

size_t DeleteFileMetadataRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.DeleteFileMetadataRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteFileMetadataRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteFileMetadataRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteFileMetadataRequest::GetClassData() const { return &_class_data_; }

void DeleteFileMetadataRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteFileMetadataRequest *>(to)->MergeFrom(
      static_cast<const DeleteFileMetadataRequest &>(from));
}


void DeleteFileMetadataRequest::MergeFrom(const DeleteFileMetadataRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.DeleteFileMetadataRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteFileMetadataRequest::CopyFrom(const DeleteFileMetadataRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.DeleteFileMetadataRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteFileMetadataRequest::IsInitialized() const {
  return true;
}

void DeleteFileMetadataRequest::InternalSwap(DeleteFileMetadataRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteFileMetadataRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[16]);
}

// ===================================================================

class DeleteFileMetadataReply::_Internal {
 public:
};

DeleteFileMetadataReply::DeleteFileMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.DeleteFileMetadataReply)
}
DeleteFileMetadataReply::DeleteFileMetadataReply(const DeleteFileMetadataReply& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.DeleteFileMetadataReply)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteFileMetadataReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteFileMetadataReply::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DeleteFileMetadataReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[17]);
}

// ===================================================================

class DetectRequest::_Internal {
 public:
};

DetectRequest::DetectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.DetectRequest)
}
DetectRequest::DetectRequest(const DetectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.DetectRequest)
}

inline void DetectRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DetectRequest::~DetectRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.DetectRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DetectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DetectRequest::ArenaDtor(void* object) {
  DetectRequest* _this = reinterpret_cast< DetectRequest* >(object);
  (void)_this;
}
void DetectRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DetectRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DetectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.DetectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DetectRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.DetectRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.DetectRequest.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.DetectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.DetectRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.DetectRequest.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.DetectRequest)
  return target;
}

size_t DetectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.DetectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DetectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DetectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DetectRequest::GetClassData() const { return &_class_data_; }

void DetectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DetectRequest *>(to)->MergeFrom(
      static_cast<const DetectRequest &>(from));
}


void DetectRequest::MergeFrom(const DetectRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.DetectRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DetectRequest::CopyFrom(const DetectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.DetectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetectRequest::IsInitialized() const {
  return true;
}

void DetectRequest::InternalSwap(DetectRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DetectRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[18]);
}

// ===================================================================

class DetectReply::_Internal {
 public:
};

DetectReply::DetectReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.DetectReply)
}
DetectReply::DetectReply(const DetectReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_artifact_id().empty()) {
    artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_artifact_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.DetectReply)
}

inline void DetectReply::SharedCtor() {
artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DetectReply::~DetectReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.DetectReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DetectReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  artifact_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DetectReply::ArenaDtor(void* object) {
  DetectReply* _this = reinterpret_cast< DetectReply* >(object);
  (void)_this;
}
void DetectReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DetectReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DetectReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.DetectReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  artifact_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DetectReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string artifact_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_artifact_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.DetectReply.artifact_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetectReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.DetectReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string artifact_id = 1 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_artifact_id().data(), static_cast<int>(this->_internal_artifact_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.DetectReply.artifact_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_artifact_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.DetectReply)
  return target;
}

size_t DetectReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.DetectReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string artifact_id = 1 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_artifact_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DetectReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DetectReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DetectReply::GetClassData() const { return &_class_data_; }

void DetectReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DetectReply *>(to)->MergeFrom(
      static_cast<const DetectReply &>(from));
}


void DetectReply::MergeFrom(const DetectReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.DetectReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_artifact_id().empty()) {
    _internal_set_artifact_id(from._internal_artifact_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DetectReply::CopyFrom(const DetectReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.DetectReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetectReply::IsInitialized() const {
  return true;
}

void DetectReply::InternalSwap(DetectReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &artifact_id_, lhs_arena,
      &other->artifact_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DetectReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[19]);
}

// ===================================================================

class ConfusionRequest::_Internal {
 public:
};

ConfusionRequest::ConfusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.ConfusionRequest)
}
ConfusionRequest::ConfusionRequest(const ConfusionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.ConfusionRequest)
}

inline void ConfusionRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConfusionRequest::~ConfusionRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.ConfusionRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ConfusionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ConfusionRequest::ArenaDtor(void* object) {
  ConfusionRequest* _this = reinterpret_cast< ConfusionRequest* >(object);
  (void)_this;
}
void ConfusionRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConfusionRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfusionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.ConfusionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfusionRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.ConfusionRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.ConfusionRequest.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfusionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.ConfusionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.ConfusionRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.ConfusionRequest.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.ConfusionRequest)
  return target;
}

size_t ConfusionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.ConfusionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfusionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConfusionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfusionRequest::GetClassData() const { return &_class_data_; }

void ConfusionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConfusionRequest *>(to)->MergeFrom(
      static_cast<const ConfusionRequest &>(from));
}


void ConfusionRequest::MergeFrom(const ConfusionRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.ConfusionRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfusionRequest::CopyFrom(const ConfusionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.ConfusionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfusionRequest::IsInitialized() const {
  return true;
}

void ConfusionRequest::InternalSwap(ConfusionRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfusionRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[20]);
}

// ===================================================================

class ConfusionReply::_Internal {
 public:
};

ConfusionReply::ConfusionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.ConfusionReply)
}
ConfusionReply::ConfusionReply(const ConfusionReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_artifact_id().empty()) {
    artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_artifact_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  affiliated_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_affiliated_file_id().empty()) {
    affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_affiliated_file_id(), 
      GetArenaForAllocation());
  }
  method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_method(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.ConfusionReply)
}

inline void ConfusionReply::SharedCtor() {
artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
affiliated_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ConfusionReply::~ConfusionReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.ConfusionReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ConfusionReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  artifact_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  affiliated_file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  method_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ConfusionReply::ArenaDtor(void* object) {
  ConfusionReply* _this = reinterpret_cast< ConfusionReply* >(object);
  (void)_this;
}
void ConfusionReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConfusionReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfusionReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.ConfusionReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  artifact_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  affiliated_file_id_.ClearToEmpty();
  method_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfusionReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string artifact_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_artifact_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.ConfusionReply.artifact_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.ConfusionReply.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string affiliated_file_id = 3 [(.validate.rules) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_affiliated_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.ConfusionReply.affiliated_file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string method = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_method();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.ConfusionReply.method"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfusionReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.ConfusionReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string artifact_id = 1 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_artifact_id().data(), static_cast<int>(this->_internal_artifact_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.ConfusionReply.artifact_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_artifact_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.ConfusionReply.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  // string affiliated_file_id = 3 [(.validate.rules) = {
  if (!this->_internal_affiliated_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_affiliated_file_id().data(), static_cast<int>(this->_internal_affiliated_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.ConfusionReply.affiliated_file_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_affiliated_file_id(), target);
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.ConfusionReply.method");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_method(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.ConfusionReply)
  return target;
}

size_t ConfusionReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.ConfusionReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string artifact_id = 1 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_artifact_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  // string affiliated_file_id = 3 [(.validate.rules) = {
  if (!this->_internal_affiliated_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_affiliated_file_id());
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfusionReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConfusionReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfusionReply::GetClassData() const { return &_class_data_; }

void ConfusionReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConfusionReply *>(to)->MergeFrom(
      static_cast<const ConfusionReply &>(from));
}


void ConfusionReply::MergeFrom(const ConfusionReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.ConfusionReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_artifact_id().empty()) {
    _internal_set_artifact_id(from._internal_artifact_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  if (!from._internal_affiliated_file_id().empty()) {
    _internal_set_affiliated_file_id(from._internal_affiliated_file_id());
  }
  if (!from._internal_method().empty()) {
    _internal_set_method(from._internal_method());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfusionReply::CopyFrom(const ConfusionReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.ConfusionReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfusionReply::IsInitialized() const {
  return true;
}

void ConfusionReply::InternalSwap(ConfusionReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &artifact_id_, lhs_arena,
      &other->artifact_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &affiliated_file_id_, lhs_arena,
      &other->affiliated_file_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &method_, lhs_arena,
      &other->method_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfusionReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[21]);
}

// ===================================================================

class PackerRequest::_Internal {
 public:
};

PackerRequest::PackerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.PackerRequest)
}
PackerRequest::PackerRequest(const PackerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.PackerRequest)
}

inline void PackerRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PackerRequest::~PackerRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.PackerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PackerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PackerRequest::ArenaDtor(void* object) {
  PackerRequest* _this = reinterpret_cast< PackerRequest* >(object);
  (void)_this;
}
void PackerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PackerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PackerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.PackerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PackerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.PackerRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.PackerRequest.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PackerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.PackerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.PackerRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.PackerRequest.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.PackerRequest)
  return target;
}

size_t PackerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.PackerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PackerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PackerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PackerRequest::GetClassData() const { return &_class_data_; }

void PackerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PackerRequest *>(to)->MergeFrom(
      static_cast<const PackerRequest &>(from));
}


void PackerRequest::MergeFrom(const PackerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.PackerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PackerRequest::CopyFrom(const PackerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.PackerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PackerRequest::IsInitialized() const {
  return true;
}

void PackerRequest::InternalSwap(PackerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PackerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[22]);
}

// ===================================================================

class PackerReply::_Internal {
 public:
};

PackerReply::PackerReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.PackerReply)
}
PackerReply::PackerReply(const PackerReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_artifact_id().empty()) {
    artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_artifact_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  affiliated_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_affiliated_file_id().empty()) {
    affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_affiliated_file_id(), 
      GetArenaForAllocation());
  }
  method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_method(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.PackerReply)
}

inline void PackerReply::SharedCtor() {
artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
affiliated_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PackerReply::~PackerReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.PackerReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PackerReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  artifact_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  affiliated_file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  method_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PackerReply::ArenaDtor(void* object) {
  PackerReply* _this = reinterpret_cast< PackerReply* >(object);
  (void)_this;
}
void PackerReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PackerReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PackerReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.PackerReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  artifact_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  affiliated_file_id_.ClearToEmpty();
  method_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PackerReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string artifact_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_artifact_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.PackerReply.artifact_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.PackerReply.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string affiliated_file_id = 3 [(.validate.rules) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_affiliated_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.PackerReply.affiliated_file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string method = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_method();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.PackerReply.method"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PackerReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.PackerReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string artifact_id = 1 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_artifact_id().data(), static_cast<int>(this->_internal_artifact_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.PackerReply.artifact_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_artifact_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.PackerReply.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  // string affiliated_file_id = 3 [(.validate.rules) = {
  if (!this->_internal_affiliated_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_affiliated_file_id().data(), static_cast<int>(this->_internal_affiliated_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.PackerReply.affiliated_file_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_affiliated_file_id(), target);
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.PackerReply.method");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_method(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.PackerReply)
  return target;
}

size_t PackerReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.PackerReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string artifact_id = 1 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_artifact_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  // string affiliated_file_id = 3 [(.validate.rules) = {
  if (!this->_internal_affiliated_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_affiliated_file_id());
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PackerReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PackerReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PackerReply::GetClassData() const { return &_class_data_; }

void PackerReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PackerReply *>(to)->MergeFrom(
      static_cast<const PackerReply &>(from));
}


void PackerReply::MergeFrom(const PackerReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.PackerReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_artifact_id().empty()) {
    _internal_set_artifact_id(from._internal_artifact_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  if (!from._internal_affiliated_file_id().empty()) {
    _internal_set_affiliated_file_id(from._internal_affiliated_file_id());
  }
  if (!from._internal_method().empty()) {
    _internal_set_method(from._internal_method());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PackerReply::CopyFrom(const PackerReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.PackerReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PackerReply::IsInitialized() const {
  return true;
}

void PackerReply::InternalSwap(PackerReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &artifact_id_, lhs_arena,
      &other->artifact_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &affiliated_file_id_, lhs_arena,
      &other->affiliated_file_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &method_, lhs_arena,
      &other->method_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PackerReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[23]);
}

// ===================================================================

class GetArtifactMetadataRequest::_Internal {
 public:
};

GetArtifactMetadataRequest::GetArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetArtifactMetadataRequest)
}
GetArtifactMetadataRequest::GetArtifactMetadataRequest(const GetArtifactMetadataRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_artifact_id().empty()) {
    artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_artifact_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetArtifactMetadataRequest)
}

inline void GetArtifactMetadataRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetArtifactMetadataRequest::~GetArtifactMetadataRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetArtifactMetadataRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetArtifactMetadataRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  artifact_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetArtifactMetadataRequest::ArenaDtor(void* object) {
  GetArtifactMetadataRequest* _this = reinterpret_cast< GetArtifactMetadataRequest* >(object);
  (void)_this;
}
void GetArtifactMetadataRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetArtifactMetadataRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetArtifactMetadataRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetArtifactMetadataRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  artifact_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetArtifactMetadataRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetArtifactMetadataRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string artifact_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_artifact_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetArtifactMetadataRequest.artifact_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetArtifactMetadataRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetArtifactMetadataRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetArtifactMetadataRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // string artifact_id = 2 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_artifact_id().data(), static_cast<int>(this->_internal_artifact_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetArtifactMetadataRequest.artifact_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_artifact_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetArtifactMetadataRequest)
  return target;
}

size_t GetArtifactMetadataRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetArtifactMetadataRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  // string artifact_id = 2 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_artifact_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetArtifactMetadataRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetArtifactMetadataRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetArtifactMetadataRequest::GetClassData() const { return &_class_data_; }

void GetArtifactMetadataRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetArtifactMetadataRequest *>(to)->MergeFrom(
      static_cast<const GetArtifactMetadataRequest &>(from));
}


void GetArtifactMetadataRequest::MergeFrom(const GetArtifactMetadataRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetArtifactMetadataRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_artifact_id().empty()) {
    _internal_set_artifact_id(from._internal_artifact_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetArtifactMetadataRequest::CopyFrom(const GetArtifactMetadataRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetArtifactMetadataRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetArtifactMetadataRequest::IsInitialized() const {
  return true;
}

void GetArtifactMetadataRequest::InternalSwap(GetArtifactMetadataRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &artifact_id_, lhs_arena,
      &other->artifact_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetArtifactMetadataRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[24]);
}

// ===================================================================

class GetArtifactMetadataReply::_Internal {
 public:
};

GetArtifactMetadataReply::GetArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetArtifactMetadataReply)
}
GetArtifactMetadataReply::GetArtifactMetadataReply(const GetArtifactMetadataReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_artifact_id().empty()) {
    artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_artifact_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  affiliated_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_affiliated_file_id().empty()) {
    affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_affiliated_file_id(), 
      GetArenaForAllocation());
  }
  method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_method(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetArtifactMetadataReply)
}

inline void GetArtifactMetadataReply::SharedCtor() {
artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
affiliated_file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
method_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetArtifactMetadataReply::~GetArtifactMetadataReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetArtifactMetadataReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetArtifactMetadataReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  artifact_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  affiliated_file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  method_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetArtifactMetadataReply::ArenaDtor(void* object) {
  GetArtifactMetadataReply* _this = reinterpret_cast< GetArtifactMetadataReply* >(object);
  (void)_this;
}
void GetArtifactMetadataReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetArtifactMetadataReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetArtifactMetadataReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetArtifactMetadataReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  artifact_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  affiliated_file_id_.ClearToEmpty();
  method_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetArtifactMetadataReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string artifact_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_artifact_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetArtifactMetadataReply.artifact_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetArtifactMetadataReply.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string affiliated_file_id = 3 [(.validate.rules) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_affiliated_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string method = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_method();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetArtifactMetadataReply.method"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetArtifactMetadataReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetArtifactMetadataReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string artifact_id = 1 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_artifact_id().data(), static_cast<int>(this->_internal_artifact_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetArtifactMetadataReply.artifact_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_artifact_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetArtifactMetadataReply.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  // string affiliated_file_id = 3 [(.validate.rules) = {
  if (!this->_internal_affiliated_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_affiliated_file_id().data(), static_cast<int>(this->_internal_affiliated_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_affiliated_file_id(), target);
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetArtifactMetadataReply.method");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_method(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetArtifactMetadataReply)
  return target;
}

size_t GetArtifactMetadataReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetArtifactMetadataReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string artifact_id = 1 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_artifact_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  // string affiliated_file_id = 3 [(.validate.rules) = {
  if (!this->_internal_affiliated_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_affiliated_file_id());
  }

  // string method = 4;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetArtifactMetadataReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetArtifactMetadataReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetArtifactMetadataReply::GetClassData() const { return &_class_data_; }

void GetArtifactMetadataReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetArtifactMetadataReply *>(to)->MergeFrom(
      static_cast<const GetArtifactMetadataReply &>(from));
}


void GetArtifactMetadataReply::MergeFrom(const GetArtifactMetadataReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetArtifactMetadataReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_artifact_id().empty()) {
    _internal_set_artifact_id(from._internal_artifact_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  if (!from._internal_affiliated_file_id().empty()) {
    _internal_set_affiliated_file_id(from._internal_affiliated_file_id());
  }
  if (!from._internal_method().empty()) {
    _internal_set_method(from._internal_method());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetArtifactMetadataReply::CopyFrom(const GetArtifactMetadataReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetArtifactMetadataReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetArtifactMetadataReply::IsInitialized() const {
  return true;
}

void GetArtifactMetadataReply::InternalSwap(GetArtifactMetadataReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &artifact_id_, lhs_arena,
      &other->artifact_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &affiliated_file_id_, lhs_arena,
      &other->affiliated_file_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &method_, lhs_arena,
      &other->method_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetArtifactMetadataReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[25]);
}

// ===================================================================

class GetArtifactMetadataByFileIdRequest::_Internal {
 public:
};

GetArtifactMetadataByFileIdRequest::GetArtifactMetadataByFileIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
}
GetArtifactMetadataByFileIdRequest::GetArtifactMetadataByFileIdRequest(const GetArtifactMetadataByFileIdRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_file_id().empty()) {
    file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
}

inline void GetArtifactMetadataByFileIdRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
file_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetArtifactMetadataByFileIdRequest::~GetArtifactMetadataByFileIdRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetArtifactMetadataByFileIdRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetArtifactMetadataByFileIdRequest::ArenaDtor(void* object) {
  GetArtifactMetadataByFileIdRequest* _this = reinterpret_cast< GetArtifactMetadataByFileIdRequest* >(object);
  (void)_this;
}
void GetArtifactMetadataByFileIdRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetArtifactMetadataByFileIdRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetArtifactMetadataByFileIdRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  file_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetArtifactMetadataByFileIdRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_file_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetArtifactMetadataByFileIdRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_file_id().data(), static_cast<int>(this->_internal_file_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_file_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
  return target;
}

size_t GetArtifactMetadataByFileIdRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  // string file_id = 2 [(.validate.rules) = {
  if (!this->_internal_file_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_file_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetArtifactMetadataByFileIdRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetArtifactMetadataByFileIdRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetArtifactMetadataByFileIdRequest::GetClassData() const { return &_class_data_; }

void GetArtifactMetadataByFileIdRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetArtifactMetadataByFileIdRequest *>(to)->MergeFrom(
      static_cast<const GetArtifactMetadataByFileIdRequest &>(from));
}


void GetArtifactMetadataByFileIdRequest::MergeFrom(const GetArtifactMetadataByFileIdRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_file_id().empty()) {
    _internal_set_file_id(from._internal_file_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetArtifactMetadataByFileIdRequest::CopyFrom(const GetArtifactMetadataByFileIdRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetArtifactMetadataByFileIdRequest::IsInitialized() const {
  return true;
}

void GetArtifactMetadataByFileIdRequest::InternalSwap(GetArtifactMetadataByFileIdRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_id_, lhs_arena,
      &other->file_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetArtifactMetadataByFileIdRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[26]);
}

// ===================================================================

class GetArtifactMetadataByFileIdReply::_Internal {
 public:
};

GetArtifactMetadataByFileIdReply::GetArtifactMetadataByFileIdReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  artifact_metadata_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.GetArtifactMetadataByFileIdReply)
}
GetArtifactMetadataByFileIdReply::GetArtifactMetadataByFileIdReply(const GetArtifactMetadataByFileIdReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      artifact_metadata_(from.artifact_metadata_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.GetArtifactMetadataByFileIdReply)
}

inline void GetArtifactMetadataByFileIdReply::SharedCtor() {
}

GetArtifactMetadataByFileIdReply::~GetArtifactMetadataByFileIdReply() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.GetArtifactMetadataByFileIdReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetArtifactMetadataByFileIdReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetArtifactMetadataByFileIdReply::ArenaDtor(void* object) {
  GetArtifactMetadataByFileIdReply* _this = reinterpret_cast< GetArtifactMetadataByFileIdReply* >(object);
  (void)_this;
}
void GetArtifactMetadataByFileIdReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetArtifactMetadataByFileIdReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetArtifactMetadataByFileIdReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.GetArtifactMetadataByFileIdReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  artifact_metadata_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetArtifactMetadataByFileIdReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .bugu.service.v1.GetArtifactMetadataReply artifact_metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_artifact_metadata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetArtifactMetadataByFileIdReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.GetArtifactMetadataByFileIdReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .bugu.service.v1.GetArtifactMetadataReply artifact_metadata = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_artifact_metadata_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_artifact_metadata(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.GetArtifactMetadataByFileIdReply)
  return target;
}

size_t GetArtifactMetadataByFileIdReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.GetArtifactMetadataByFileIdReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .bugu.service.v1.GetArtifactMetadataReply artifact_metadata = 1;
  total_size += 1UL * this->_internal_artifact_metadata_size();
  for (const auto& msg : this->artifact_metadata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetArtifactMetadataByFileIdReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetArtifactMetadataByFileIdReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetArtifactMetadataByFileIdReply::GetClassData() const { return &_class_data_; }

void GetArtifactMetadataByFileIdReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetArtifactMetadataByFileIdReply *>(to)->MergeFrom(
      static_cast<const GetArtifactMetadataByFileIdReply &>(from));
}


void GetArtifactMetadataByFileIdReply::MergeFrom(const GetArtifactMetadataByFileIdReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.GetArtifactMetadataByFileIdReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  artifact_metadata_.MergeFrom(from.artifact_metadata_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetArtifactMetadataByFileIdReply::CopyFrom(const GetArtifactMetadataByFileIdReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.GetArtifactMetadataByFileIdReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetArtifactMetadataByFileIdReply::IsInitialized() const {
  return true;
}

void GetArtifactMetadataByFileIdReply::InternalSwap(GetArtifactMetadataByFileIdReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  artifact_metadata_.InternalSwap(&other->artifact_metadata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetArtifactMetadataByFileIdReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[27]);
}

// ===================================================================

class DeleteArtifactMetadataRequest::_Internal {
 public:
};

DeleteArtifactMetadataRequest::DeleteArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.DeleteArtifactMetadataRequest)
}
DeleteArtifactMetadataRequest::DeleteArtifactMetadataRequest(const DeleteArtifactMetadataRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_id().empty()) {
    user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_id(), 
      GetArenaForAllocation());
  }
  artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_artifact_id().empty()) {
    artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_artifact_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.DeleteArtifactMetadataRequest)
}

inline void DeleteArtifactMetadataRequest::SharedCtor() {
user_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
artifact_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteArtifactMetadataRequest::~DeleteArtifactMetadataRequest() {
  // @@protoc_insertion_point(destructor:bugu.service.v1.DeleteArtifactMetadataRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteArtifactMetadataRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  artifact_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DeleteArtifactMetadataRequest::ArenaDtor(void* object) {
  DeleteArtifactMetadataRequest* _this = reinterpret_cast< DeleteArtifactMetadataRequest* >(object);
  (void)_this;
}
void DeleteArtifactMetadataRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteArtifactMetadataRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteArtifactMetadataRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu.service.v1.DeleteArtifactMetadataRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.ClearToEmpty();
  artifact_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteArtifactMetadataRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_id = 1 [(.validate.rules) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.DeleteArtifactMetadataRequest.user_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string artifact_id = 2 [(.validate.rules) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_artifact_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteArtifactMetadataRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu.service.v1.DeleteArtifactMetadataRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_id().data(), static_cast<int>(this->_internal_user_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.DeleteArtifactMetadataRequest.user_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_id(), target);
  }

  // string artifact_id = 2 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_artifact_id().data(), static_cast<int>(this->_internal_artifact_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_artifact_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu.service.v1.DeleteArtifactMetadataRequest)
  return target;
}

size_t DeleteArtifactMetadataRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu.service.v1.DeleteArtifactMetadataRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_id = 1 [(.validate.rules) = {
  if (!this->_internal_user_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_id());
  }

  // string artifact_id = 2 [(.validate.rules) = {
  if (!this->_internal_artifact_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_artifact_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteArtifactMetadataRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteArtifactMetadataRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteArtifactMetadataRequest::GetClassData() const { return &_class_data_; }

void DeleteArtifactMetadataRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteArtifactMetadataRequest *>(to)->MergeFrom(
      static_cast<const DeleteArtifactMetadataRequest &>(from));
}


void DeleteArtifactMetadataRequest::MergeFrom(const DeleteArtifactMetadataRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu.service.v1.DeleteArtifactMetadataRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_id().empty()) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (!from._internal_artifact_id().empty()) {
    _internal_set_artifact_id(from._internal_artifact_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteArtifactMetadataRequest::CopyFrom(const DeleteArtifactMetadataRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu.service.v1.DeleteArtifactMetadataRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteArtifactMetadataRequest::IsInitialized() const {
  return true;
}

void DeleteArtifactMetadataRequest::InternalSwap(DeleteArtifactMetadataRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_id_, lhs_arena,
      &other->user_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &artifact_id_, lhs_arena,
      &other->artifact_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteArtifactMetadataRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[28]);
}

// ===================================================================

class DeleteArtifactMetadataReply::_Internal {
 public:
};

DeleteArtifactMetadataReply::DeleteArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:bugu.service.v1.DeleteArtifactMetadataReply)
}
DeleteArtifactMetadataReply::DeleteArtifactMetadataReply(const DeleteArtifactMetadataReply& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:bugu.service.v1.DeleteArtifactMetadataReply)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteArtifactMetadataReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteArtifactMetadataReply::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DeleteArtifactMetadataReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_2eproto_getter, &descriptor_table_bugu_2eproto_once,
      file_level_metadata_bugu_2eproto[29]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace service
}  // namespace bugu
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::bugu::service::v1::RegisterRequest_User* Arena::CreateMaybeMessage< ::bugu::service::v1::RegisterRequest_User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::RegisterRequest_User >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::RegisterRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::RegisterRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::RegisterRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::RegisterReply* Arena::CreateMaybeMessage< ::bugu::service::v1::RegisterReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::RegisterReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::LoginRequest_User* Arena::CreateMaybeMessage< ::bugu::service::v1::LoginRequest_User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::LoginRequest_User >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::LoginRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::LoginRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::LoginRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::LoginReply* Arena::CreateMaybeMessage< ::bugu::service::v1::LoginReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::LoginReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetCurrentUserRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::GetCurrentUserRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetCurrentUserRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetCurrentUserReply* Arena::CreateMaybeMessage< ::bugu::service::v1::GetCurrentUserReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetCurrentUserReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::UpdateUserRequest_User* Arena::CreateMaybeMessage< ::bugu::service::v1::UpdateUserRequest_User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::UpdateUserRequest_User >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::UpdateUserRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::UpdateUserRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::UpdateUserRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::UpdateUserReply* Arena::CreateMaybeMessage< ::bugu::service::v1::UpdateUserReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::UpdateUserReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::UserStruct* Arena::CreateMaybeMessage< ::bugu::service::v1::UserStruct >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::UserStruct >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetFileMetaRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::GetFileMetaRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetFileMetaRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetFileMetaReply* Arena::CreateMaybeMessage< ::bugu::service::v1::GetFileMetaReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetFileMetaReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetFileMetaByUserIdRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::GetFileMetaByUserIdRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetFileMetaByUserIdRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetFileMetaByUserIdReply* Arena::CreateMaybeMessage< ::bugu::service::v1::GetFileMetaByUserIdReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetFileMetaByUserIdReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::DeleteFileMetadataRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::DeleteFileMetadataRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::DeleteFileMetadataRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::DeleteFileMetadataReply* Arena::CreateMaybeMessage< ::bugu::service::v1::DeleteFileMetadataReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::DeleteFileMetadataReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::DetectRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::DetectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::DetectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::DetectReply* Arena::CreateMaybeMessage< ::bugu::service::v1::DetectReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::DetectReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::ConfusionRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::ConfusionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::ConfusionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::ConfusionReply* Arena::CreateMaybeMessage< ::bugu::service::v1::ConfusionReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::ConfusionReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::PackerRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::PackerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::PackerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::PackerReply* Arena::CreateMaybeMessage< ::bugu::service::v1::PackerReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::PackerReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetArtifactMetadataRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::GetArtifactMetadataRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetArtifactMetadataRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetArtifactMetadataReply* Arena::CreateMaybeMessage< ::bugu::service::v1::GetArtifactMetadataReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetArtifactMetadataReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::GetArtifactMetadataByFileIdRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetArtifactMetadataByFileIdRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::GetArtifactMetadataByFileIdReply* Arena::CreateMaybeMessage< ::bugu::service::v1::GetArtifactMetadataByFileIdReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::GetArtifactMetadataByFileIdReply >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::DeleteArtifactMetadataRequest* Arena::CreateMaybeMessage< ::bugu::service::v1::DeleteArtifactMetadataRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::DeleteArtifactMetadataRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu::service::v1::DeleteArtifactMetadataReply* Arena::CreateMaybeMessage< ::bugu::service::v1::DeleteArtifactMetadataReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu::service::v1::DeleteArtifactMetadataReply >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

```

`api/bugu/service/v1/cpp/bugu.pb.h`:

```h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bugu.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bugu_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bugu_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bugu_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bugu_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[30]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bugu_2eproto;
namespace bugu {
namespace service {
namespace v1 {
class ConfusionReply;
struct ConfusionReplyDefaultTypeInternal;
extern ConfusionReplyDefaultTypeInternal _ConfusionReply_default_instance_;
class ConfusionRequest;
struct ConfusionRequestDefaultTypeInternal;
extern ConfusionRequestDefaultTypeInternal _ConfusionRequest_default_instance_;
class DeleteArtifactMetadataReply;
struct DeleteArtifactMetadataReplyDefaultTypeInternal;
extern DeleteArtifactMetadataReplyDefaultTypeInternal _DeleteArtifactMetadataReply_default_instance_;
class DeleteArtifactMetadataRequest;
struct DeleteArtifactMetadataRequestDefaultTypeInternal;
extern DeleteArtifactMetadataRequestDefaultTypeInternal _DeleteArtifactMetadataRequest_default_instance_;
class DeleteFileMetadataReply;
struct DeleteFileMetadataReplyDefaultTypeInternal;
extern DeleteFileMetadataReplyDefaultTypeInternal _DeleteFileMetadataReply_default_instance_;
class DeleteFileMetadataRequest;
struct DeleteFileMetadataRequestDefaultTypeInternal;
extern DeleteFileMetadataRequestDefaultTypeInternal _DeleteFileMetadataRequest_default_instance_;
class DetectReply;
struct DetectReplyDefaultTypeInternal;
extern DetectReplyDefaultTypeInternal _DetectReply_default_instance_;
class DetectRequest;
struct DetectRequestDefaultTypeInternal;
extern DetectRequestDefaultTypeInternal _DetectRequest_default_instance_;
class GetArtifactMetadataByFileIdReply;
struct GetArtifactMetadataByFileIdReplyDefaultTypeInternal;
extern GetArtifactMetadataByFileIdReplyDefaultTypeInternal _GetArtifactMetadataByFileIdReply_default_instance_;
class GetArtifactMetadataByFileIdRequest;
struct GetArtifactMetadataByFileIdRequestDefaultTypeInternal;
extern GetArtifactMetadataByFileIdRequestDefaultTypeInternal _GetArtifactMetadataByFileIdRequest_default_instance_;
class GetArtifactMetadataReply;
struct GetArtifactMetadataReplyDefaultTypeInternal;
extern GetArtifactMetadataReplyDefaultTypeInternal _GetArtifactMetadataReply_default_instance_;
class GetArtifactMetadataRequest;
struct GetArtifactMetadataRequestDefaultTypeInternal;
extern GetArtifactMetadataRequestDefaultTypeInternal _GetArtifactMetadataRequest_default_instance_;
class GetCurrentUserReply;
struct GetCurrentUserReplyDefaultTypeInternal;
extern GetCurrentUserReplyDefaultTypeInternal _GetCurrentUserReply_default_instance_;
class GetCurrentUserRequest;
struct GetCurrentUserRequestDefaultTypeInternal;
extern GetCurrentUserRequestDefaultTypeInternal _GetCurrentUserRequest_default_instance_;
class GetFileMetaByUserIdReply;
struct GetFileMetaByUserIdReplyDefaultTypeInternal;
extern GetFileMetaByUserIdReplyDefaultTypeInternal _GetFileMetaByUserIdReply_default_instance_;
class GetFileMetaByUserIdRequest;
struct GetFileMetaByUserIdRequestDefaultTypeInternal;
extern GetFileMetaByUserIdRequestDefaultTypeInternal _GetFileMetaByUserIdRequest_default_instance_;
class GetFileMetaReply;
struct GetFileMetaReplyDefaultTypeInternal;
extern GetFileMetaReplyDefaultTypeInternal _GetFileMetaReply_default_instance_;
class GetFileMetaRequest;
struct GetFileMetaRequestDefaultTypeInternal;
extern GetFileMetaRequestDefaultTypeInternal _GetFileMetaRequest_default_instance_;
class LoginReply;
struct LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginRequest_User;
struct LoginRequest_UserDefaultTypeInternal;
extern LoginRequest_UserDefaultTypeInternal _LoginRequest_User_default_instance_;
class PackerReply;
struct PackerReplyDefaultTypeInternal;
extern PackerReplyDefaultTypeInternal _PackerReply_default_instance_;
class PackerRequest;
struct PackerRequestDefaultTypeInternal;
extern PackerRequestDefaultTypeInternal _PackerRequest_default_instance_;
class RegisterReply;
struct RegisterReplyDefaultTypeInternal;
extern RegisterReplyDefaultTypeInternal _RegisterReply_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterRequest_User;
struct RegisterRequest_UserDefaultTypeInternal;
extern RegisterRequest_UserDefaultTypeInternal _RegisterRequest_User_default_instance_;
class UpdateUserReply;
struct UpdateUserReplyDefaultTypeInternal;
extern UpdateUserReplyDefaultTypeInternal _UpdateUserReply_default_instance_;
class UpdateUserRequest;
struct UpdateUserRequestDefaultTypeInternal;
extern UpdateUserRequestDefaultTypeInternal _UpdateUserRequest_default_instance_;
class UpdateUserRequest_User;
struct UpdateUserRequest_UserDefaultTypeInternal;
extern UpdateUserRequest_UserDefaultTypeInternal _UpdateUserRequest_User_default_instance_;
class UserStruct;
struct UserStructDefaultTypeInternal;
extern UserStructDefaultTypeInternal _UserStruct_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu
PROTOBUF_NAMESPACE_OPEN
template<> ::bugu::service::v1::ConfusionReply* Arena::CreateMaybeMessage<::bugu::service::v1::ConfusionReply>(Arena*);
template<> ::bugu::service::v1::ConfusionRequest* Arena::CreateMaybeMessage<::bugu::service::v1::ConfusionRequest>(Arena*);
template<> ::bugu::service::v1::DeleteArtifactMetadataReply* Arena::CreateMaybeMessage<::bugu::service::v1::DeleteArtifactMetadataReply>(Arena*);
template<> ::bugu::service::v1::DeleteArtifactMetadataRequest* Arena::CreateMaybeMessage<::bugu::service::v1::DeleteArtifactMetadataRequest>(Arena*);
template<> ::bugu::service::v1::DeleteFileMetadataReply* Arena::CreateMaybeMessage<::bugu::service::v1::DeleteFileMetadataReply>(Arena*);
template<> ::bugu::service::v1::DeleteFileMetadataRequest* Arena::CreateMaybeMessage<::bugu::service::v1::DeleteFileMetadataRequest>(Arena*);
template<> ::bugu::service::v1::DetectReply* Arena::CreateMaybeMessage<::bugu::service::v1::DetectReply>(Arena*);
template<> ::bugu::service::v1::DetectRequest* Arena::CreateMaybeMessage<::bugu::service::v1::DetectRequest>(Arena*);
template<> ::bugu::service::v1::GetArtifactMetadataByFileIdReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetArtifactMetadataByFileIdReply>(Arena*);
template<> ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetArtifactMetadataByFileIdRequest>(Arena*);
template<> ::bugu::service::v1::GetArtifactMetadataReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetArtifactMetadataReply>(Arena*);
template<> ::bugu::service::v1::GetArtifactMetadataRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetArtifactMetadataRequest>(Arena*);
template<> ::bugu::service::v1::GetCurrentUserReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetCurrentUserReply>(Arena*);
template<> ::bugu::service::v1::GetCurrentUserRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetCurrentUserRequest>(Arena*);
template<> ::bugu::service::v1::GetFileMetaByUserIdReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetFileMetaByUserIdReply>(Arena*);
template<> ::bugu::service::v1::GetFileMetaByUserIdRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetFileMetaByUserIdRequest>(Arena*);
template<> ::bugu::service::v1::GetFileMetaReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetFileMetaReply>(Arena*);
template<> ::bugu::service::v1::GetFileMetaRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetFileMetaRequest>(Arena*);
template<> ::bugu::service::v1::LoginReply* Arena::CreateMaybeMessage<::bugu::service::v1::LoginReply>(Arena*);
template<> ::bugu::service::v1::LoginRequest* Arena::CreateMaybeMessage<::bugu::service::v1::LoginRequest>(Arena*);
template<> ::bugu::service::v1::LoginRequest_User* Arena::CreateMaybeMessage<::bugu::service::v1::LoginRequest_User>(Arena*);
template<> ::bugu::service::v1::PackerReply* Arena::CreateMaybeMessage<::bugu::service::v1::PackerReply>(Arena*);
template<> ::bugu::service::v1::PackerRequest* Arena::CreateMaybeMessage<::bugu::service::v1::PackerRequest>(Arena*);
template<> ::bugu::service::v1::RegisterReply* Arena::CreateMaybeMessage<::bugu::service::v1::RegisterReply>(Arena*);
template<> ::bugu::service::v1::RegisterRequest* Arena::CreateMaybeMessage<::bugu::service::v1::RegisterRequest>(Arena*);
template<> ::bugu::service::v1::RegisterRequest_User* Arena::CreateMaybeMessage<::bugu::service::v1::RegisterRequest_User>(Arena*);
template<> ::bugu::service::v1::UpdateUserReply* Arena::CreateMaybeMessage<::bugu::service::v1::UpdateUserReply>(Arena*);
template<> ::bugu::service::v1::UpdateUserRequest* Arena::CreateMaybeMessage<::bugu::service::v1::UpdateUserRequest>(Arena*);
template<> ::bugu::service::v1::UpdateUserRequest_User* Arena::CreateMaybeMessage<::bugu::service::v1::UpdateUserRequest_User>(Arena*);
template<> ::bugu::service::v1::UserStruct* Arena::CreateMaybeMessage<::bugu::service::v1::UserStruct>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bugu {
namespace service {
namespace v1 {

enum Type : int {
  TYPE_ADPOSHEL = 0,
  TYPE_AGENT = 1,
  TYPE_ALLAPLE = 2,
  TYPE_AMONETIZE = 3,
  TYPE_ANDROM = 4,
  TYPE_AUTORUN = 5,
  TYPE_BROWSE_FOX = 6,
  TYPE_DINWOD = 7,
  TYPE_ELEX = 8,
  TYPE_EXPIRO = 9,
  TYPE_FASONG = 10,
  TYPE_HACK_KMS = 11,
  TYPE_HLUX = 12,
  TYPE_INJECTOR = 13,
  TYPE_INSTALL_CORE = 14,
  TYPE_MULTI_Plug = 15,
  TYPE_NEOREKLAMI = 16,
  TYPE_NESHTA = 17,
  TYPE_OTHER = 18,
  TYPE_REGRUN = 19,
  TYPE_SALITY = 20,
  TYPE_SNARASITE = 21,
  TYPE_STABTINKO = 22,
  TYPE_VBA = 23,
  TYPE_VBKRYPT = 24,
  TYPE_VILSEL = 25,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_IsValid(int value);
constexpr Type Type_MIN = TYPE_ADPOSHEL;
constexpr Type Type_MAX = TYPE_VILSEL;
constexpr int Type_ARRAYSIZE = Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor();
template<typename T>
inline const std::string& Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_descriptor(), enum_t_value);
}
inline bool Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class RegisterRequest_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.RegisterRequest.User) */ {
 public:
  inline RegisterRequest_User() : RegisterRequest_User(nullptr) {}
  ~RegisterRequest_User() override;
  explicit constexpr RegisterRequest_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest_User(const RegisterRequest_User& from);
  RegisterRequest_User(RegisterRequest_User&& from) noexcept
    : RegisterRequest_User() {
    *this = ::std::move(from);
  }

  inline RegisterRequest_User& operator=(const RegisterRequest_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest_User& operator=(RegisterRequest_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest_User* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest_User*>(
               &_RegisterRequest_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegisterRequest_User& a, RegisterRequest_User& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterRequest_User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.RegisterRequest.User";
  }
  protected:
  explicit RegisterRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kEmailFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.RegisterRequest.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit constexpr RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RegisterRequest_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.RegisterRequest.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::RegisterRequest_User& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::RegisterRequest_User* release_user();
  ::bugu::service::v1::RegisterRequest_User* mutable_user();
  void set_allocated_user(::bugu::service::v1::RegisterRequest_User* user);
  private:
  const ::bugu::service::v1::RegisterRequest_User& _internal_user() const;
  ::bugu::service::v1::RegisterRequest_User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::RegisterRequest_User* user);
  ::bugu::service::v1::RegisterRequest_User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::RegisterRequest_User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class RegisterReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.RegisterReply) */ {
 public:
  inline RegisterReply() : RegisterReply(nullptr) {}
  ~RegisterReply() override;
  explicit constexpr RegisterReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterReply(const RegisterReply& from);
  RegisterReply(RegisterReply&& from) noexcept
    : RegisterReply() {
    *this = ::std::move(from);
  }

  inline RegisterReply& operator=(const RegisterReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterReply& operator=(RegisterReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterReply* internal_default_instance() {
    return reinterpret_cast<const RegisterReply*>(
               &_RegisterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterReply& a, RegisterReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.RegisterReply";
  }
  protected:
  explicit RegisterReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.UserStruct user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UserStruct& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UserStruct* release_user();
  ::bugu::service::v1::UserStruct* mutable_user();
  void set_allocated_user(::bugu::service::v1::UserStruct* user);
  private:
  const ::bugu::service::v1::UserStruct& _internal_user() const;
  ::bugu::service::v1::UserStruct* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UserStruct* user);
  ::bugu::service::v1::UserStruct* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.RegisterReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::UserStruct* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.LoginRequest.User) */ {
 public:
  inline LoginRequest_User() : LoginRequest_User(nullptr) {}
  ~LoginRequest_User() override;
  explicit constexpr LoginRequest_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest_User(const LoginRequest_User& from);
  LoginRequest_User(LoginRequest_User&& from) noexcept
    : LoginRequest_User() {
    *this = ::std::move(from);
  }

  inline LoginRequest_User& operator=(const LoginRequest_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest_User& operator=(LoginRequest_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest_User* internal_default_instance() {
    return reinterpret_cast<const LoginRequest_User*>(
               &_LoginRequest_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginRequest_User& a, LoginRequest_User& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRequest_User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.LoginRequest.User";
  }
  protected:
  explicit LoginRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.LoginRequest.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit constexpr LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoginRequest_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.LoginRequest.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::LoginRequest_User& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::LoginRequest_User* release_user();
  ::bugu::service::v1::LoginRequest_User* mutable_user();
  void set_allocated_user(::bugu::service::v1::LoginRequest_User* user);
  private:
  const ::bugu::service::v1::LoginRequest_User& _internal_user() const;
  ::bugu::service::v1::LoginRequest_User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::LoginRequest_User* user);
  ::bugu::service::v1::LoginRequest_User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::LoginRequest_User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class LoginReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.LoginReply) */ {
 public:
  inline LoginReply() : LoginReply(nullptr) {}
  ~LoginReply() override;
  explicit constexpr LoginReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReply(const LoginReply& from);
  LoginReply(LoginReply&& from) noexcept
    : LoginReply() {
    *this = ::std::move(from);
  }

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
               &_LoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginReply& a, LoginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.LoginReply";
  }
  protected:
  explicit LoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // string token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // .bugu.service.v1.UserStruct user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UserStruct& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UserStruct* release_user();
  ::bugu::service::v1::UserStruct* mutable_user();
  void set_allocated_user(::bugu::service::v1::UserStruct* user);
  private:
  const ::bugu::service::v1::UserStruct& _internal_user() const;
  ::bugu::service::v1::UserStruct* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UserStruct* user);
  ::bugu::service::v1::UserStruct* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.LoginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::bugu::service::v1::UserStruct* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetCurrentUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetCurrentUserRequest) */ {
 public:
  inline GetCurrentUserRequest() : GetCurrentUserRequest(nullptr) {}
  ~GetCurrentUserRequest() override;
  explicit constexpr GetCurrentUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCurrentUserRequest(const GetCurrentUserRequest& from);
  GetCurrentUserRequest(GetCurrentUserRequest&& from) noexcept
    : GetCurrentUserRequest() {
    *this = ::std::move(from);
  }

  inline GetCurrentUserRequest& operator=(const GetCurrentUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCurrentUserRequest& operator=(GetCurrentUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCurrentUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCurrentUserRequest* internal_default_instance() {
    return reinterpret_cast<const GetCurrentUserRequest*>(
               &_GetCurrentUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetCurrentUserRequest& a, GetCurrentUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCurrentUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCurrentUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCurrentUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCurrentUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCurrentUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCurrentUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCurrentUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetCurrentUserRequest";
  }
  protected:
  explicit GetCurrentUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetCurrentUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetCurrentUserReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetCurrentUserReply) */ {
 public:
  inline GetCurrentUserReply() : GetCurrentUserReply(nullptr) {}
  ~GetCurrentUserReply() override;
  explicit constexpr GetCurrentUserReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCurrentUserReply(const GetCurrentUserReply& from);
  GetCurrentUserReply(GetCurrentUserReply&& from) noexcept
    : GetCurrentUserReply() {
    *this = ::std::move(from);
  }

  inline GetCurrentUserReply& operator=(const GetCurrentUserReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCurrentUserReply& operator=(GetCurrentUserReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCurrentUserReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCurrentUserReply* internal_default_instance() {
    return reinterpret_cast<const GetCurrentUserReply*>(
               &_GetCurrentUserReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetCurrentUserReply& a, GetCurrentUserReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCurrentUserReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCurrentUserReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCurrentUserReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCurrentUserReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCurrentUserReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCurrentUserReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCurrentUserReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetCurrentUserReply";
  }
  protected:
  explicit GetCurrentUserReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.UserStruct user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UserStruct& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UserStruct* release_user();
  ::bugu::service::v1::UserStruct* mutable_user();
  void set_allocated_user(::bugu::service::v1::UserStruct* user);
  private:
  const ::bugu::service::v1::UserStruct& _internal_user() const;
  ::bugu::service::v1::UserStruct* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UserStruct* user);
  ::bugu::service::v1::UserStruct* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetCurrentUserReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::UserStruct* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserRequest_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.UpdateUserRequest.User) */ {
 public:
  inline UpdateUserRequest_User() : UpdateUserRequest_User(nullptr) {}
  ~UpdateUserRequest_User() override;
  explicit constexpr UpdateUserRequest_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserRequest_User(const UpdateUserRequest_User& from);
  UpdateUserRequest_User(UpdateUserRequest_User&& from) noexcept
    : UpdateUserRequest_User() {
    *this = ::std::move(from);
  }

  inline UpdateUserRequest_User& operator=(const UpdateUserRequest_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserRequest_User& operator=(UpdateUserRequest_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserRequest_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserRequest_User* internal_default_instance() {
    return reinterpret_cast<const UpdateUserRequest_User*>(
               &_UpdateUserRequest_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateUserRequest_User& a, UpdateUserRequest_User& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserRequest_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserRequest_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserRequest_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserRequest_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserRequest_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateUserRequest_User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserRequest_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.UpdateUserRequest.User";
  }
  protected:
  explicit UpdateUserRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kUsernameFieldNumber = 4,
    kPasswordFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 5;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.UpdateUserRequest.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.UpdateUserRequest) */ {
 public:
  inline UpdateUserRequest() : UpdateUserRequest(nullptr) {}
  ~UpdateUserRequest() override;
  explicit constexpr UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserRequest(const UpdateUserRequest& from);
  UpdateUserRequest(UpdateUserRequest&& from) noexcept
    : UpdateUserRequest() {
    *this = ::std::move(from);
  }

  inline UpdateUserRequest& operator=(const UpdateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserRequest& operator=(UpdateUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserRequest*>(
               &_UpdateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateUserRequest& a, UpdateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.UpdateUserRequest";
  }
  protected:
  explicit UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateUserRequest_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.UpdateUserRequest.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UpdateUserRequest_User& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UpdateUserRequest_User* release_user();
  ::bugu::service::v1::UpdateUserRequest_User* mutable_user();
  void set_allocated_user(::bugu::service::v1::UpdateUserRequest_User* user);
  private:
  const ::bugu::service::v1::UpdateUserRequest_User& _internal_user() const;
  ::bugu::service::v1::UpdateUserRequest_User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UpdateUserRequest_User* user);
  ::bugu::service::v1::UpdateUserRequest_User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.UpdateUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::UpdateUserRequest_User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.UpdateUserReply) */ {
 public:
  inline UpdateUserReply() : UpdateUserReply(nullptr) {}
  ~UpdateUserReply() override;
  explicit constexpr UpdateUserReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserReply(const UpdateUserReply& from);
  UpdateUserReply(UpdateUserReply&& from) noexcept
    : UpdateUserReply() {
    *this = ::std::move(from);
  }

  inline UpdateUserReply& operator=(const UpdateUserReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserReply& operator=(UpdateUserReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserReply* internal_default_instance() {
    return reinterpret_cast<const UpdateUserReply*>(
               &_UpdateUserReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateUserReply& a, UpdateUserReply& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateUserReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.UpdateUserReply";
  }
  protected:
  explicit UpdateUserReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.UserStruct user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UserStruct& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UserStruct* release_user();
  ::bugu::service::v1::UserStruct* mutable_user();
  void set_allocated_user(::bugu::service::v1::UserStruct* user);
  private:
  const ::bugu::service::v1::UserStruct& _internal_user() const;
  ::bugu::service::v1::UserStruct* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UserStruct* user);
  ::bugu::service::v1::UserStruct* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.UpdateUserReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::UserStruct* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class UserStruct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.UserStruct) */ {
 public:
  inline UserStruct() : UserStruct(nullptr) {}
  ~UserStruct() override;
  explicit constexpr UserStruct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserStruct(const UserStruct& from);
  UserStruct(UserStruct&& from) noexcept
    : UserStruct() {
    *this = ::std::move(from);
  }

  inline UserStruct& operator=(const UserStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStruct& operator=(UserStruct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserStruct& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserStruct* internal_default_instance() {
    return reinterpret_cast<const UserStruct*>(
               &_UserStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserStruct& a, UserStruct& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStruct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStruct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStruct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserStruct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserStruct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserStruct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStruct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.UserStruct";
  }
  protected:
  explicit UserStruct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kUsernameFieldNumber = 3,
  };
  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.UserStruct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetFileMetaRequest) */ {
 public:
  inline GetFileMetaRequest() : GetFileMetaRequest(nullptr) {}
  ~GetFileMetaRequest() override;
  explicit constexpr GetFileMetaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaRequest(const GetFileMetaRequest& from);
  GetFileMetaRequest(GetFileMetaRequest&& from) noexcept
    : GetFileMetaRequest() {
    *this = ::std::move(from);
  }

  inline GetFileMetaRequest& operator=(const GetFileMetaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaRequest& operator=(GetFileMetaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaRequest* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaRequest*>(
               &_GetFileMetaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetFileMetaRequest& a, GetFileMetaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetFileMetaRequest";
  }
  protected:
  explicit GetFileMetaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetFileMetaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetFileMetaReply) */ {
 public:
  inline GetFileMetaReply() : GetFileMetaReply(nullptr) {}
  ~GetFileMetaReply() override;
  explicit constexpr GetFileMetaReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaReply(const GetFileMetaReply& from);
  GetFileMetaReply(GetFileMetaReply&& from) noexcept
    : GetFileMetaReply() {
    *this = ::std::move(from);
  }

  inline GetFileMetaReply& operator=(const GetFileMetaReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaReply& operator=(GetFileMetaReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaReply* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaReply*>(
               &_GetFileMetaReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetFileMetaReply& a, GetFileMetaReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetFileMetaReply";
  }
  protected:
  explicit GetFileMetaReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kFileSha1FieldNumber = 2,
    kFileAddrFieldNumber = 4,
    kFileSizeFieldNumber = 3,
    kTypeFieldNumber = 5,
  };
  // string file_id = 1 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string file_sha_1 = 2;
  void clear_file_sha_1();
  const std::string& file_sha_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_sha_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_sha_1();
  PROTOBUF_NODISCARD std::string* release_file_sha_1();
  void set_allocated_file_sha_1(std::string* file_sha_1);
  private:
  const std::string& _internal_file_sha_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_sha_1(const std::string& value);
  std::string* _internal_mutable_file_sha_1();
  public:

  // string file_addr = 4;
  void clear_file_addr();
  const std::string& file_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_addr();
  PROTOBUF_NODISCARD std::string* release_file_addr();
  void set_allocated_file_addr(std::string* file_addr);
  private:
  const std::string& _internal_file_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_addr(const std::string& value);
  std::string* _internal_mutable_file_addr();
  public:

  // int64 file_size = 3;
  void clear_file_size();
  int64_t file_size() const;
  void set_file_size(int64_t value);
  private:
  int64_t _internal_file_size() const;
  void _internal_set_file_size(int64_t value);
  public:

  // .bugu.service.v1.Type type = 5;
  void clear_type();
  ::bugu::service::v1::Type type() const;
  void set_type(::bugu::service::v1::Type value);
  private:
  ::bugu::service::v1::Type _internal_type() const;
  void _internal_set_type(::bugu::service::v1::Type value);
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetFileMetaReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_sha_1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_addr_;
  int64_t file_size_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaByUserIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetFileMetaByUserIdRequest) */ {
 public:
  inline GetFileMetaByUserIdRequest() : GetFileMetaByUserIdRequest(nullptr) {}
  ~GetFileMetaByUserIdRequest() override;
  explicit constexpr GetFileMetaByUserIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaByUserIdRequest(const GetFileMetaByUserIdRequest& from);
  GetFileMetaByUserIdRequest(GetFileMetaByUserIdRequest&& from) noexcept
    : GetFileMetaByUserIdRequest() {
    *this = ::std::move(from);
  }

  inline GetFileMetaByUserIdRequest& operator=(const GetFileMetaByUserIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaByUserIdRequest& operator=(GetFileMetaByUserIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaByUserIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaByUserIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaByUserIdRequest*>(
               &_GetFileMetaByUserIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetFileMetaByUserIdRequest& a, GetFileMetaByUserIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaByUserIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaByUserIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaByUserIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaByUserIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaByUserIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaByUserIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaByUserIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetFileMetaByUserIdRequest";
  }
  protected:
  explicit GetFileMetaByUserIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetFileMetaByUserIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaByUserIdReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetFileMetaByUserIdReply) */ {
 public:
  inline GetFileMetaByUserIdReply() : GetFileMetaByUserIdReply(nullptr) {}
  ~GetFileMetaByUserIdReply() override;
  explicit constexpr GetFileMetaByUserIdReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaByUserIdReply(const GetFileMetaByUserIdReply& from);
  GetFileMetaByUserIdReply(GetFileMetaByUserIdReply&& from) noexcept
    : GetFileMetaByUserIdReply() {
    *this = ::std::move(from);
  }

  inline GetFileMetaByUserIdReply& operator=(const GetFileMetaByUserIdReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaByUserIdReply& operator=(GetFileMetaByUserIdReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaByUserIdReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaByUserIdReply* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaByUserIdReply*>(
               &_GetFileMetaByUserIdReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetFileMetaByUserIdReply& a, GetFileMetaByUserIdReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaByUserIdReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaByUserIdReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaByUserIdReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaByUserIdReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaByUserIdReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaByUserIdReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaByUserIdReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetFileMetaByUserIdReply";
  }
  protected:
  explicit GetFileMetaByUserIdReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileMetadataFieldNumber = 1,
  };
  // repeated .bugu.service.v1.GetFileMetaReply file_metadata = 1;
  int file_metadata_size() const;
  private:
  int _internal_file_metadata_size() const;
  public:
  void clear_file_metadata();
  ::bugu::service::v1::GetFileMetaReply* mutable_file_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply >*
      mutable_file_metadata();
  private:
  const ::bugu::service::v1::GetFileMetaReply& _internal_file_metadata(int index) const;
  ::bugu::service::v1::GetFileMetaReply* _internal_add_file_metadata();
  public:
  const ::bugu::service::v1::GetFileMetaReply& file_metadata(int index) const;
  ::bugu::service::v1::GetFileMetaReply* add_file_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply >&
      file_metadata() const;

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetFileMetaByUserIdReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply > file_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.DeleteFileMetadataRequest) */ {
 public:
  inline DeleteFileMetadataRequest() : DeleteFileMetadataRequest(nullptr) {}
  ~DeleteFileMetadataRequest() override;
  explicit constexpr DeleteFileMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileMetadataRequest(const DeleteFileMetadataRequest& from);
  DeleteFileMetadataRequest(DeleteFileMetadataRequest&& from) noexcept
    : DeleteFileMetadataRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFileMetadataRequest& operator=(const DeleteFileMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileMetadataRequest& operator=(DeleteFileMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFileMetadataRequest*>(
               &_DeleteFileMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeleteFileMetadataRequest& a, DeleteFileMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFileMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFileMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFileMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DeleteFileMetadataRequest";
  }
  protected:
  explicit DeleteFileMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DeleteFileMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileMetadataReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bugu.service.v1.DeleteFileMetadataReply) */ {
 public:
  inline DeleteFileMetadataReply() : DeleteFileMetadataReply(nullptr) {}
  explicit constexpr DeleteFileMetadataReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileMetadataReply(const DeleteFileMetadataReply& from);
  DeleteFileMetadataReply(DeleteFileMetadataReply&& from) noexcept
    : DeleteFileMetadataReply() {
    *this = ::std::move(from);
  }

  inline DeleteFileMetadataReply& operator=(const DeleteFileMetadataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileMetadataReply& operator=(DeleteFileMetadataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileMetadataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileMetadataReply* internal_default_instance() {
    return reinterpret_cast<const DeleteFileMetadataReply*>(
               &_DeleteFileMetadataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteFileMetadataReply& a, DeleteFileMetadataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileMetadataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileMetadataReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileMetadataReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileMetadataReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteFileMetadataReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteFileMetadataReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DeleteFileMetadataReply";
  }
  protected:
  explicit DeleteFileMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DeleteFileMetadataReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DetectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.DetectRequest) */ {
 public:
  inline DetectRequest() : DetectRequest(nullptr) {}
  ~DetectRequest() override;
  explicit constexpr DetectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectRequest(const DetectRequest& from);
  DetectRequest(DetectRequest&& from) noexcept
    : DetectRequest() {
    *this = ::std::move(from);
  }

  inline DetectRequest& operator=(const DetectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectRequest& operator=(DetectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectRequest* internal_default_instance() {
    return reinterpret_cast<const DetectRequest*>(
               &_DetectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DetectRequest& a, DetectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DetectRequest";
  }
  protected:
  explicit DetectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DetectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DetectReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.DetectReply) */ {
 public:
  inline DetectReply() : DetectReply(nullptr) {}
  ~DetectReply() override;
  explicit constexpr DetectReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectReply(const DetectReply& from);
  DetectReply(DetectReply&& from) noexcept
    : DetectReply() {
    *this = ::std::move(from);
  }

  inline DetectReply& operator=(const DetectReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectReply& operator=(DetectReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectReply* internal_default_instance() {
    return reinterpret_cast<const DetectReply*>(
               &_DetectReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DetectReply& a, DetectReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DetectReply";
  }
  protected:
  explicit DetectReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactIdFieldNumber = 1,
  };
  // string artifact_id = 1 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DetectReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class ConfusionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.ConfusionRequest) */ {
 public:
  inline ConfusionRequest() : ConfusionRequest(nullptr) {}
  ~ConfusionRequest() override;
  explicit constexpr ConfusionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfusionRequest(const ConfusionRequest& from);
  ConfusionRequest(ConfusionRequest&& from) noexcept
    : ConfusionRequest() {
    *this = ::std::move(from);
  }

  inline ConfusionRequest& operator=(const ConfusionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfusionRequest& operator=(ConfusionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfusionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfusionRequest* internal_default_instance() {
    return reinterpret_cast<const ConfusionRequest*>(
               &_ConfusionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ConfusionRequest& a, ConfusionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfusionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfusionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfusionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfusionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfusionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfusionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfusionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.ConfusionRequest";
  }
  protected:
  explicit ConfusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.ConfusionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class ConfusionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.ConfusionReply) */ {
 public:
  inline ConfusionReply() : ConfusionReply(nullptr) {}
  ~ConfusionReply() override;
  explicit constexpr ConfusionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfusionReply(const ConfusionReply& from);
  ConfusionReply(ConfusionReply&& from) noexcept
    : ConfusionReply() {
    *this = ::std::move(from);
  }

  inline ConfusionReply& operator=(const ConfusionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfusionReply& operator=(ConfusionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfusionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfusionReply* internal_default_instance() {
    return reinterpret_cast<const ConfusionReply*>(
               &_ConfusionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ConfusionReply& a, ConfusionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfusionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfusionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfusionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfusionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfusionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfusionReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfusionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.ConfusionReply";
  }
  protected:
  explicit ConfusionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
    kAffiliatedFileIdFieldNumber = 3,
    kMethodFieldNumber = 4,
  };
  // string artifact_id = 1 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string affiliated_file_id = 3 [(.validate.rules) = {
  void clear_affiliated_file_id();
  const std::string& affiliated_file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_affiliated_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_affiliated_file_id();
  PROTOBUF_NODISCARD std::string* release_affiliated_file_id();
  void set_allocated_affiliated_file_id(std::string* affiliated_file_id);
  private:
  const std::string& _internal_affiliated_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affiliated_file_id(const std::string& value);
  std::string* _internal_mutable_affiliated_file_id();
  public:

  // string method = 4;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.ConfusionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr affiliated_file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class PackerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.PackerRequest) */ {
 public:
  inline PackerRequest() : PackerRequest(nullptr) {}
  ~PackerRequest() override;
  explicit constexpr PackerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackerRequest(const PackerRequest& from);
  PackerRequest(PackerRequest&& from) noexcept
    : PackerRequest() {
    *this = ::std::move(from);
  }

  inline PackerRequest& operator=(const PackerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackerRequest& operator=(PackerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackerRequest* internal_default_instance() {
    return reinterpret_cast<const PackerRequest*>(
               &_PackerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PackerRequest& a, PackerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PackerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PackerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.PackerRequest";
  }
  protected:
  explicit PackerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.PackerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class PackerReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.PackerReply) */ {
 public:
  inline PackerReply() : PackerReply(nullptr) {}
  ~PackerReply() override;
  explicit constexpr PackerReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackerReply(const PackerReply& from);
  PackerReply(PackerReply&& from) noexcept
    : PackerReply() {
    *this = ::std::move(from);
  }

  inline PackerReply& operator=(const PackerReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackerReply& operator=(PackerReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackerReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackerReply* internal_default_instance() {
    return reinterpret_cast<const PackerReply*>(
               &_PackerReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PackerReply& a, PackerReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PackerReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackerReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackerReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackerReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackerReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PackerReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackerReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.PackerReply";
  }
  protected:
  explicit PackerReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
    kAffiliatedFileIdFieldNumber = 3,
    kMethodFieldNumber = 4,
  };
  // string artifact_id = 1 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string affiliated_file_id = 3 [(.validate.rules) = {
  void clear_affiliated_file_id();
  const std::string& affiliated_file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_affiliated_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_affiliated_file_id();
  PROTOBUF_NODISCARD std::string* release_affiliated_file_id();
  void set_allocated_affiliated_file_id(std::string* affiliated_file_id);
  private:
  const std::string& _internal_affiliated_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affiliated_file_id(const std::string& value);
  std::string* _internal_mutable_affiliated_file_id();
  public:

  // string method = 4;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.PackerReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr affiliated_file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetArtifactMetadataRequest) */ {
 public:
  inline GetArtifactMetadataRequest() : GetArtifactMetadataRequest(nullptr) {}
  ~GetArtifactMetadataRequest() override;
  explicit constexpr GetArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactMetadataRequest(const GetArtifactMetadataRequest& from);
  GetArtifactMetadataRequest(GetArtifactMetadataRequest&& from) noexcept
    : GetArtifactMetadataRequest() {
    *this = ::std::move(from);
  }

  inline GetArtifactMetadataRequest& operator=(const GetArtifactMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactMetadataRequest& operator=(GetArtifactMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const GetArtifactMetadataRequest*>(
               &_GetArtifactMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetArtifactMetadataRequest& a, GetArtifactMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArtifactMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetArtifactMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetArtifactMetadataRequest";
  }
  protected:
  explicit GetArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kArtifactIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string artifact_id = 2 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetArtifactMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactMetadataReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetArtifactMetadataReply) */ {
 public:
  inline GetArtifactMetadataReply() : GetArtifactMetadataReply(nullptr) {}
  ~GetArtifactMetadataReply() override;
  explicit constexpr GetArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactMetadataReply(const GetArtifactMetadataReply& from);
  GetArtifactMetadataReply(GetArtifactMetadataReply&& from) noexcept
    : GetArtifactMetadataReply() {
    *this = ::std::move(from);
  }

  inline GetArtifactMetadataReply& operator=(const GetArtifactMetadataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactMetadataReply& operator=(GetArtifactMetadataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactMetadataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactMetadataReply* internal_default_instance() {
    return reinterpret_cast<const GetArtifactMetadataReply*>(
               &_GetArtifactMetadataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetArtifactMetadataReply& a, GetArtifactMetadataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactMetadataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactMetadataReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactMetadataReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactMetadataReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArtifactMetadataReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetArtifactMetadataReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactMetadataReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetArtifactMetadataReply";
  }
  protected:
  explicit GetArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
    kAffiliatedFileIdFieldNumber = 3,
    kMethodFieldNumber = 4,
  };
  // string artifact_id = 1 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string affiliated_file_id = 3 [(.validate.rules) = {
  void clear_affiliated_file_id();
  const std::string& affiliated_file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_affiliated_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_affiliated_file_id();
  PROTOBUF_NODISCARD std::string* release_affiliated_file_id();
  void set_allocated_affiliated_file_id(std::string* affiliated_file_id);
  private:
  const std::string& _internal_affiliated_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affiliated_file_id(const std::string& value);
  std::string* _internal_mutable_affiliated_file_id();
  public:

  // string method = 4;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetArtifactMetadataReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr affiliated_file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactMetadataByFileIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetArtifactMetadataByFileIdRequest) */ {
 public:
  inline GetArtifactMetadataByFileIdRequest() : GetArtifactMetadataByFileIdRequest(nullptr) {}
  ~GetArtifactMetadataByFileIdRequest() override;
  explicit constexpr GetArtifactMetadataByFileIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactMetadataByFileIdRequest(const GetArtifactMetadataByFileIdRequest& from);
  GetArtifactMetadataByFileIdRequest(GetArtifactMetadataByFileIdRequest&& from) noexcept
    : GetArtifactMetadataByFileIdRequest() {
    *this = ::std::move(from);
  }

  inline GetArtifactMetadataByFileIdRequest& operator=(const GetArtifactMetadataByFileIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactMetadataByFileIdRequest& operator=(GetArtifactMetadataByFileIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactMetadataByFileIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactMetadataByFileIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetArtifactMetadataByFileIdRequest*>(
               &_GetArtifactMetadataByFileIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetArtifactMetadataByFileIdRequest& a, GetArtifactMetadataByFileIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactMetadataByFileIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactMetadataByFileIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactMetadataByFileIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactMetadataByFileIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArtifactMetadataByFileIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetArtifactMetadataByFileIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactMetadataByFileIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetArtifactMetadataByFileIdRequest";
  }
  protected:
  explicit GetArtifactMetadataByFileIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactMetadataByFileIdReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetArtifactMetadataByFileIdReply) */ {
 public:
  inline GetArtifactMetadataByFileIdReply() : GetArtifactMetadataByFileIdReply(nullptr) {}
  ~GetArtifactMetadataByFileIdReply() override;
  explicit constexpr GetArtifactMetadataByFileIdReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactMetadataByFileIdReply(const GetArtifactMetadataByFileIdReply& from);
  GetArtifactMetadataByFileIdReply(GetArtifactMetadataByFileIdReply&& from) noexcept
    : GetArtifactMetadataByFileIdReply() {
    *this = ::std::move(from);
  }

  inline GetArtifactMetadataByFileIdReply& operator=(const GetArtifactMetadataByFileIdReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactMetadataByFileIdReply& operator=(GetArtifactMetadataByFileIdReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactMetadataByFileIdReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactMetadataByFileIdReply* internal_default_instance() {
    return reinterpret_cast<const GetArtifactMetadataByFileIdReply*>(
               &_GetArtifactMetadataByFileIdReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetArtifactMetadataByFileIdReply& a, GetArtifactMetadataByFileIdReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactMetadataByFileIdReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactMetadataByFileIdReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactMetadataByFileIdReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactMetadataByFileIdReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArtifactMetadataByFileIdReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetArtifactMetadataByFileIdReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactMetadataByFileIdReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetArtifactMetadataByFileIdReply";
  }
  protected:
  explicit GetArtifactMetadataByFileIdReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactMetadataFieldNumber = 1,
  };
  // repeated .bugu.service.v1.GetArtifactMetadataReply artifact_metadata = 1;
  int artifact_metadata_size() const;
  private:
  int _internal_artifact_metadata_size() const;
  public:
  void clear_artifact_metadata();
  ::bugu::service::v1::GetArtifactMetadataReply* mutable_artifact_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply >*
      mutable_artifact_metadata();
  private:
  const ::bugu::service::v1::GetArtifactMetadataReply& _internal_artifact_metadata(int index) const;
  ::bugu::service::v1::GetArtifactMetadataReply* _internal_add_artifact_metadata();
  public:
  const ::bugu::service::v1::GetArtifactMetadataReply& artifact_metadata(int index) const;
  ::bugu::service::v1::GetArtifactMetadataReply* add_artifact_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply >&
      artifact_metadata() const;

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetArtifactMetadataByFileIdReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply > artifact_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DeleteArtifactMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.DeleteArtifactMetadataRequest) */ {
 public:
  inline DeleteArtifactMetadataRequest() : DeleteArtifactMetadataRequest(nullptr) {}
  ~DeleteArtifactMetadataRequest() override;
  explicit constexpr DeleteArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteArtifactMetadataRequest(const DeleteArtifactMetadataRequest& from);
  DeleteArtifactMetadataRequest(DeleteArtifactMetadataRequest&& from) noexcept
    : DeleteArtifactMetadataRequest() {
    *this = ::std::move(from);
  }

  inline DeleteArtifactMetadataRequest& operator=(const DeleteArtifactMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteArtifactMetadataRequest& operator=(DeleteArtifactMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteArtifactMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteArtifactMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteArtifactMetadataRequest*>(
               &_DeleteArtifactMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DeleteArtifactMetadataRequest& a, DeleteArtifactMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteArtifactMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteArtifactMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteArtifactMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteArtifactMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteArtifactMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteArtifactMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteArtifactMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DeleteArtifactMetadataRequest";
  }
  protected:
  explicit DeleteArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kArtifactIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string artifact_id = 2 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DeleteArtifactMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DeleteArtifactMetadataReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bugu.service.v1.DeleteArtifactMetadataReply) */ {
 public:
  inline DeleteArtifactMetadataReply() : DeleteArtifactMetadataReply(nullptr) {}
  explicit constexpr DeleteArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteArtifactMetadataReply(const DeleteArtifactMetadataReply& from);
  DeleteArtifactMetadataReply(DeleteArtifactMetadataReply&& from) noexcept
    : DeleteArtifactMetadataReply() {
    *this = ::std::move(from);
  }

  inline DeleteArtifactMetadataReply& operator=(const DeleteArtifactMetadataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteArtifactMetadataReply& operator=(DeleteArtifactMetadataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteArtifactMetadataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteArtifactMetadataReply* internal_default_instance() {
    return reinterpret_cast<const DeleteArtifactMetadataReply*>(
               &_DeleteArtifactMetadataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DeleteArtifactMetadataReply& a, DeleteArtifactMetadataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteArtifactMetadataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteArtifactMetadataReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteArtifactMetadataReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteArtifactMetadataReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteArtifactMetadataReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteArtifactMetadataReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DeleteArtifactMetadataReply";
  }
  protected:
  explicit DeleteArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DeleteArtifactMetadataReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegisterRequest_User

// string username = 1;
inline void RegisterRequest_User::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& RegisterRequest_User::username() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterRequest.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest_User::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.RegisterRequest.User.username)
}
inline std::string* RegisterRequest_User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterRequest.User.username)
  return _s;
}
inline const std::string& RegisterRequest_User::_internal_username() const {
  return username_.Get();
}
inline void RegisterRequest_User::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::release_username() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterRequest.User.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterRequest_User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterRequest.User.username)
}

// string email = 2;
inline void RegisterRequest_User::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& RegisterRequest_User::email() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterRequest.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest_User::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.RegisterRequest.User.email)
}
inline std::string* RegisterRequest_User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterRequest.User.email)
  return _s;
}
inline const std::string& RegisterRequest_User::_internal_email() const {
  return email_.Get();
}
inline void RegisterRequest_User::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::release_email() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterRequest.User.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterRequest_User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterRequest.User.email)
}

// string password = 3;
inline void RegisterRequest_User::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& RegisterRequest_User::password() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterRequest.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest_User::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.RegisterRequest.User.password)
}
inline std::string* RegisterRequest_User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterRequest.User.password)
  return _s;
}
inline const std::string& RegisterRequest_User::_internal_password() const {
  return password_.Get();
}
inline void RegisterRequest_User::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::release_password() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterRequest.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterRequest_User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterRequest.User.password)
}

// -------------------------------------------------------------------

// RegisterRequest

// .bugu.service.v1.RegisterRequest.User user = 1;
inline bool RegisterRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool RegisterRequest::has_user() const {
  return _internal_has_user();
}
inline void RegisterRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::RegisterRequest_User& RegisterRequest::_internal_user() const {
  const ::bugu::service::v1::RegisterRequest_User* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::RegisterRequest_User&>(
      ::bugu::service::v1::_RegisterRequest_User_default_instance_);
}
inline const ::bugu::service::v1::RegisterRequest_User& RegisterRequest::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterRequest.user)
  return _internal_user();
}
inline void RegisterRequest::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::RegisterRequest_User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.RegisterRequest.user)
}
inline ::bugu::service::v1::RegisterRequest_User* RegisterRequest::release_user() {
  
  ::bugu::service::v1::RegisterRequest_User* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::RegisterRequest_User* RegisterRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterRequest.user)
  
  ::bugu::service::v1::RegisterRequest_User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::RegisterRequest_User* RegisterRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::RegisterRequest_User>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::RegisterRequest_User* RegisterRequest::mutable_user() {
  ::bugu::service::v1::RegisterRequest_User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterRequest.user)
  return _msg;
}
inline void RegisterRequest::set_allocated_user(::bugu::service::v1::RegisterRequest_User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::RegisterRequest_User>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterRequest.user)
}

// -------------------------------------------------------------------

// RegisterReply

// .bugu.service.v1.UserStruct user = 1;
inline bool RegisterReply::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool RegisterReply::has_user() const {
  return _internal_has_user();
}
inline void RegisterReply::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UserStruct& RegisterReply::_internal_user() const {
  const ::bugu::service::v1::UserStruct* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UserStruct&>(
      ::bugu::service::v1::_UserStruct_default_instance_);
}
inline const ::bugu::service::v1::UserStruct& RegisterReply::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterReply.user)
  return _internal_user();
}
inline void RegisterReply::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UserStruct* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.RegisterReply.user)
}
inline ::bugu::service::v1::UserStruct* RegisterReply::release_user() {
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UserStruct* RegisterReply::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterReply.user)
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UserStruct* RegisterReply::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UserStruct>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UserStruct* RegisterReply::mutable_user() {
  ::bugu::service::v1::UserStruct* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterReply.user)
  return _msg;
}
inline void RegisterReply::set_allocated_user(::bugu::service::v1::UserStruct* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UserStruct>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterReply.user)
}

// -------------------------------------------------------------------

// LoginRequest_User

// string email = 1;
inline void LoginRequest_User::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& LoginRequest_User::email() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginRequest.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest_User::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.LoginRequest.User.email)
}
inline std::string* LoginRequest_User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginRequest.User.email)
  return _s;
}
inline const std::string& LoginRequest_User::_internal_email() const {
  return email_.Get();
}
inline void LoginRequest_User::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest_User::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest_User::release_email() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginRequest.User.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest_User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginRequest.User.email)
}

// string password = 2;
inline void LoginRequest_User::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& LoginRequest_User::password() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginRequest.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest_User::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.LoginRequest.User.password)
}
inline std::string* LoginRequest_User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginRequest.User.password)
  return _s;
}
inline const std::string& LoginRequest_User::_internal_password() const {
  return password_.Get();
}
inline void LoginRequest_User::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest_User::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest_User::release_password() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginRequest.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest_User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginRequest.User.password)
}

// -------------------------------------------------------------------

// LoginRequest

// .bugu.service.v1.LoginRequest.User user = 1;
inline bool LoginRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool LoginRequest::has_user() const {
  return _internal_has_user();
}
inline void LoginRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::LoginRequest_User& LoginRequest::_internal_user() const {
  const ::bugu::service::v1::LoginRequest_User* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::LoginRequest_User&>(
      ::bugu::service::v1::_LoginRequest_User_default_instance_);
}
inline const ::bugu::service::v1::LoginRequest_User& LoginRequest::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginRequest.user)
  return _internal_user();
}
inline void LoginRequest::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::LoginRequest_User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.LoginRequest.user)
}
inline ::bugu::service::v1::LoginRequest_User* LoginRequest::release_user() {
  
  ::bugu::service::v1::LoginRequest_User* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::LoginRequest_User* LoginRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginRequest.user)
  
  ::bugu::service::v1::LoginRequest_User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::LoginRequest_User* LoginRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::LoginRequest_User>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::LoginRequest_User* LoginRequest::mutable_user() {
  ::bugu::service::v1::LoginRequest_User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginRequest.user)
  return _msg;
}
inline void LoginRequest::set_allocated_user(::bugu::service::v1::LoginRequest_User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::LoginRequest_User>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginRequest.user)
}

// -------------------------------------------------------------------

// LoginReply

// .bugu.service.v1.UserStruct user = 1;
inline bool LoginReply::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool LoginReply::has_user() const {
  return _internal_has_user();
}
inline void LoginReply::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UserStruct& LoginReply::_internal_user() const {
  const ::bugu::service::v1::UserStruct* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UserStruct&>(
      ::bugu::service::v1::_UserStruct_default_instance_);
}
inline const ::bugu::service::v1::UserStruct& LoginReply::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginReply.user)
  return _internal_user();
}
inline void LoginReply::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UserStruct* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.LoginReply.user)
}
inline ::bugu::service::v1::UserStruct* LoginReply::release_user() {
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UserStruct* LoginReply::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginReply.user)
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UserStruct* LoginReply::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UserStruct>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UserStruct* LoginReply::mutable_user() {
  ::bugu::service::v1::UserStruct* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginReply.user)
  return _msg;
}
inline void LoginReply::set_allocated_user(::bugu::service::v1::UserStruct* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UserStruct>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginReply.user)
}

// string token = 2;
inline void LoginReply::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& LoginReply::token() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginReply.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReply::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.LoginReply.token)
}
inline std::string* LoginReply::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginReply.token)
  return _s;
}
inline const std::string& LoginReply::_internal_token() const {
  return token_.Get();
}
inline void LoginReply::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReply::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReply::release_token() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginReply.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReply::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginReply.token)
}

// -------------------------------------------------------------------

// GetCurrentUserRequest

// string id = 1 [(.validate.rules) = {
inline void GetCurrentUserRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetCurrentUserRequest::id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetCurrentUserRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCurrentUserRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetCurrentUserRequest.id)
}
inline std::string* GetCurrentUserRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetCurrentUserRequest.id)
  return _s;
}
inline const std::string& GetCurrentUserRequest::_internal_id() const {
  return id_.Get();
}
inline void GetCurrentUserRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCurrentUserRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCurrentUserRequest::release_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetCurrentUserRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCurrentUserRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetCurrentUserRequest.id)
}

// -------------------------------------------------------------------

// GetCurrentUserReply

// .bugu.service.v1.UserStruct user = 1;
inline bool GetCurrentUserReply::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool GetCurrentUserReply::has_user() const {
  return _internal_has_user();
}
inline void GetCurrentUserReply::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UserStruct& GetCurrentUserReply::_internal_user() const {
  const ::bugu::service::v1::UserStruct* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UserStruct&>(
      ::bugu::service::v1::_UserStruct_default_instance_);
}
inline const ::bugu::service::v1::UserStruct& GetCurrentUserReply::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetCurrentUserReply.user)
  return _internal_user();
}
inline void GetCurrentUserReply::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UserStruct* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.GetCurrentUserReply.user)
}
inline ::bugu::service::v1::UserStruct* GetCurrentUserReply::release_user() {
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UserStruct* GetCurrentUserReply::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetCurrentUserReply.user)
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UserStruct* GetCurrentUserReply::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UserStruct>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UserStruct* GetCurrentUserReply::mutable_user() {
  ::bugu::service::v1::UserStruct* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetCurrentUserReply.user)
  return _msg;
}
inline void GetCurrentUserReply::set_allocated_user(::bugu::service::v1::UserStruct* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UserStruct>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetCurrentUserReply.user)
}

// -------------------------------------------------------------------

// UpdateUserRequest_User

// string id = 1;
inline void UpdateUserRequest_User::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateUserRequest_User::id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserRequest_User::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UpdateUserRequest.User.id)
}
inline std::string* UpdateUserRequest_User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.User.id)
  return _s;
}
inline const std::string& UpdateUserRequest_User::_internal_id() const {
  return id_.Get();
}
inline void UpdateUserRequest_User::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::release_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.User.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUserRequest_User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.User.id)
}

// string email = 2;
inline void UpdateUserRequest_User::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& UpdateUserRequest_User::email() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserRequest_User::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UpdateUserRequest.User.email)
}
inline std::string* UpdateUserRequest_User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.User.email)
  return _s;
}
inline const std::string& UpdateUserRequest_User::_internal_email() const {
  return email_.Get();
}
inline void UpdateUserRequest_User::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::release_email() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.User.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUserRequest_User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.User.email)
}

// string username = 4;
inline void UpdateUserRequest_User::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UpdateUserRequest_User::username() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserRequest_User::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UpdateUserRequest.User.username)
}
inline std::string* UpdateUserRequest_User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.User.username)
  return _s;
}
inline const std::string& UpdateUserRequest_User::_internal_username() const {
  return username_.Get();
}
inline void UpdateUserRequest_User::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::release_username() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.User.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUserRequest_User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.User.username)
}

// string password = 5;
inline void UpdateUserRequest_User::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& UpdateUserRequest_User::password() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserRequest_User::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UpdateUserRequest.User.password)
}
inline std::string* UpdateUserRequest_User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.User.password)
  return _s;
}
inline const std::string& UpdateUserRequest_User::_internal_password() const {
  return password_.Get();
}
inline void UpdateUserRequest_User::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::release_password() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUserRequest_User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.User.password)
}

// -------------------------------------------------------------------

// UpdateUserRequest

// .bugu.service.v1.UpdateUserRequest.User user = 1;
inline bool UpdateUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UpdateUserRequest::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UpdateUserRequest_User& UpdateUserRequest::_internal_user() const {
  const ::bugu::service::v1::UpdateUserRequest_User* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UpdateUserRequest_User&>(
      ::bugu::service::v1::_UpdateUserRequest_User_default_instance_);
}
inline const ::bugu::service::v1::UpdateUserRequest_User& UpdateUserRequest::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.user)
  return _internal_user();
}
inline void UpdateUserRequest::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UpdateUserRequest_User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.UpdateUserRequest.user)
}
inline ::bugu::service::v1::UpdateUserRequest_User* UpdateUserRequest::release_user() {
  
  ::bugu::service::v1::UpdateUserRequest_User* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UpdateUserRequest_User* UpdateUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.user)
  
  ::bugu::service::v1::UpdateUserRequest_User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UpdateUserRequest_User* UpdateUserRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UpdateUserRequest_User>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UpdateUserRequest_User* UpdateUserRequest::mutable_user() {
  ::bugu::service::v1::UpdateUserRequest_User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.user)
  return _msg;
}
inline void UpdateUserRequest::set_allocated_user(::bugu::service::v1::UpdateUserRequest_User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UpdateUserRequest_User>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.user)
}

// -------------------------------------------------------------------

// UpdateUserReply

// .bugu.service.v1.UserStruct user = 1;
inline bool UpdateUserReply::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UpdateUserReply::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserReply::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UserStruct& UpdateUserReply::_internal_user() const {
  const ::bugu::service::v1::UserStruct* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UserStruct&>(
      ::bugu::service::v1::_UserStruct_default_instance_);
}
inline const ::bugu::service::v1::UserStruct& UpdateUserReply::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserReply.user)
  return _internal_user();
}
inline void UpdateUserReply::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UserStruct* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.UpdateUserReply.user)
}
inline ::bugu::service::v1::UserStruct* UpdateUserReply::release_user() {
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UserStruct* UpdateUserReply::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserReply.user)
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UserStruct* UpdateUserReply::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UserStruct>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UserStruct* UpdateUserReply::mutable_user() {
  ::bugu::service::v1::UserStruct* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserReply.user)
  return _msg;
}
inline void UpdateUserReply::set_allocated_user(::bugu::service::v1::UserStruct* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UserStruct>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserReply.user)
}

// -------------------------------------------------------------------

// UserStruct

// string id = 1 [(.validate.rules) = {
inline void UserStruct::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UserStruct::id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UserStruct.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserStruct::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UserStruct.id)
}
inline std::string* UserStruct::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UserStruct.id)
  return _s;
}
inline const std::string& UserStruct::_internal_id() const {
  return id_.Get();
}
inline void UserStruct::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserStruct::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserStruct::release_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UserStruct.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserStruct::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UserStruct.id)
}

// string email = 2;
inline void UserStruct::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& UserStruct::email() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UserStruct.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserStruct::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UserStruct.email)
}
inline std::string* UserStruct::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UserStruct.email)
  return _s;
}
inline const std::string& UserStruct::_internal_email() const {
  return email_.Get();
}
inline void UserStruct::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserStruct::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserStruct::release_email() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UserStruct.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserStruct::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UserStruct.email)
}

// string username = 3;
inline void UserStruct::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UserStruct::username() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UserStruct.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserStruct::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UserStruct.username)
}
inline std::string* UserStruct::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UserStruct.username)
  return _s;
}
inline const std::string& UserStruct::_internal_username() const {
  return username_.Get();
}
inline void UserStruct::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserStruct::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserStruct::release_username() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UserStruct.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserStruct::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UserStruct.username)
}

// -------------------------------------------------------------------

// GetFileMetaRequest

// string user_id = 1 [(.validate.rules) = {
inline void GetFileMetaRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetFileMetaRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaRequest.user_id)
}
inline std::string* GetFileMetaRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaRequest.user_id)
  return _s;
}
inline const std::string& GetFileMetaRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetFileMetaRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void GetFileMetaRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& GetFileMetaRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaRequest.file_id)
}
inline std::string* GetFileMetaRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaRequest.file_id)
  return _s;
}
inline const std::string& GetFileMetaRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void GetFileMetaRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaRequest.file_id)
}

// -------------------------------------------------------------------

// GetFileMetaReply

// string file_id = 1 [(.validate.rules) = {
inline void GetFileMetaReply::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& GetFileMetaReply::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaReply::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.file_id)
}
inline std::string* GetFileMetaReply::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaReply.file_id)
  return _s;
}
inline const std::string& GetFileMetaReply::_internal_file_id() const {
  return file_id_.Get();
}
inline void GetFileMetaReply::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaReply.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaReply::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaReply.file_id)
}

// string file_sha_1 = 2;
inline void GetFileMetaReply::clear_file_sha_1() {
  file_sha_1_.ClearToEmpty();
}
inline const std::string& GetFileMetaReply::file_sha_1() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.file_sha_1)
  return _internal_file_sha_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaReply::set_file_sha_1(ArgT0&& arg0, ArgT... args) {
 
 file_sha_1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.file_sha_1)
}
inline std::string* GetFileMetaReply::mutable_file_sha_1() {
  std::string* _s = _internal_mutable_file_sha_1();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaReply.file_sha_1)
  return _s;
}
inline const std::string& GetFileMetaReply::_internal_file_sha_1() const {
  return file_sha_1_.Get();
}
inline void GetFileMetaReply::_internal_set_file_sha_1(const std::string& value) {
  
  file_sha_1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::_internal_mutable_file_sha_1() {
  
  return file_sha_1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::release_file_sha_1() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaReply.file_sha_1)
  return file_sha_1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaReply::set_allocated_file_sha_1(std::string* file_sha_1) {
  if (file_sha_1 != nullptr) {
    
  } else {
    
  }
  file_sha_1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_sha_1,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_sha_1_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_sha_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaReply.file_sha_1)
}

// int64 file_size = 3;
inline void GetFileMetaReply::clear_file_size() {
  file_size_ = int64_t{0};
}
inline int64_t GetFileMetaReply::_internal_file_size() const {
  return file_size_;
}
inline int64_t GetFileMetaReply::file_size() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.file_size)
  return _internal_file_size();
}
inline void GetFileMetaReply::_internal_set_file_size(int64_t value) {
  
  file_size_ = value;
}
inline void GetFileMetaReply::set_file_size(int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.file_size)
}

// string file_addr = 4;
inline void GetFileMetaReply::clear_file_addr() {
  file_addr_.ClearToEmpty();
}
inline const std::string& GetFileMetaReply::file_addr() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.file_addr)
  return _internal_file_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaReply::set_file_addr(ArgT0&& arg0, ArgT... args) {
 
 file_addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.file_addr)
}
inline std::string* GetFileMetaReply::mutable_file_addr() {
  std::string* _s = _internal_mutable_file_addr();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaReply.file_addr)
  return _s;
}
inline const std::string& GetFileMetaReply::_internal_file_addr() const {
  return file_addr_.Get();
}
inline void GetFileMetaReply::_internal_set_file_addr(const std::string& value) {
  
  file_addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::_internal_mutable_file_addr() {
  
  return file_addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::release_file_addr() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaReply.file_addr)
  return file_addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaReply::set_allocated_file_addr(std::string* file_addr) {
  if (file_addr != nullptr) {
    
  } else {
    
  }
  file_addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaReply.file_addr)
}

// .bugu.service.v1.Type type = 5;
inline void GetFileMetaReply::clear_type() {
  type_ = 0;
}
inline ::bugu::service::v1::Type GetFileMetaReply::_internal_type() const {
  return static_cast< ::bugu::service::v1::Type >(type_);
}
inline ::bugu::service::v1::Type GetFileMetaReply::type() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.type)
  return _internal_type();
}
inline void GetFileMetaReply::_internal_set_type(::bugu::service::v1::Type value) {
  
  type_ = value;
}
inline void GetFileMetaReply::set_type(::bugu::service::v1::Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.type)
}

// -------------------------------------------------------------------

// GetFileMetaByUserIdRequest

// string user_id = 1 [(.validate.rules) = {
inline void GetFileMetaByUserIdRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetFileMetaByUserIdRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaByUserIdRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
}
inline std::string* GetFileMetaByUserIdRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
  return _s;
}
inline const std::string& GetFileMetaByUserIdRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetFileMetaByUserIdRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaByUserIdRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaByUserIdRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaByUserIdRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
}

// -------------------------------------------------------------------

// GetFileMetaByUserIdReply

// repeated .bugu.service.v1.GetFileMetaReply file_metadata = 1;
inline int GetFileMetaByUserIdReply::_internal_file_metadata_size() const {
  return file_metadata_.size();
}
inline int GetFileMetaByUserIdReply::file_metadata_size() const {
  return _internal_file_metadata_size();
}
inline void GetFileMetaByUserIdReply::clear_file_metadata() {
  file_metadata_.Clear();
}
inline ::bugu::service::v1::GetFileMetaReply* GetFileMetaByUserIdReply::mutable_file_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return file_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply >*
GetFileMetaByUserIdReply::mutable_file_metadata() {
  // @@protoc_insertion_point(field_mutable_list:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return &file_metadata_;
}
inline const ::bugu::service::v1::GetFileMetaReply& GetFileMetaByUserIdReply::_internal_file_metadata(int index) const {
  return file_metadata_.Get(index);
}
inline const ::bugu::service::v1::GetFileMetaReply& GetFileMetaByUserIdReply::file_metadata(int index) const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return _internal_file_metadata(index);
}
inline ::bugu::service::v1::GetFileMetaReply* GetFileMetaByUserIdReply::_internal_add_file_metadata() {
  return file_metadata_.Add();
}
inline ::bugu::service::v1::GetFileMetaReply* GetFileMetaByUserIdReply::add_file_metadata() {
  ::bugu::service::v1::GetFileMetaReply* _add = _internal_add_file_metadata();
  // @@protoc_insertion_point(field_add:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply >&
GetFileMetaByUserIdReply::file_metadata() const {
  // @@protoc_insertion_point(field_list:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return file_metadata_;
}

// -------------------------------------------------------------------

// DeleteFileMetadataRequest

// string user_id = 1 [(.validate.rules) = {
inline void DeleteFileMetadataRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& DeleteFileMetadataRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DeleteFileMetadataRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileMetadataRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DeleteFileMetadataRequest.user_id)
}
inline std::string* DeleteFileMetadataRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DeleteFileMetadataRequest.user_id)
  return _s;
}
inline const std::string& DeleteFileMetadataRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void DeleteFileMetadataRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteFileMetadataRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteFileMetadataRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DeleteFileMetadataRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteFileMetadataRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DeleteFileMetadataRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void DeleteFileMetadataRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& DeleteFileMetadataRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DeleteFileMetadataRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileMetadataRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DeleteFileMetadataRequest.file_id)
}
inline std::string* DeleteFileMetadataRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DeleteFileMetadataRequest.file_id)
  return _s;
}
inline const std::string& DeleteFileMetadataRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void DeleteFileMetadataRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteFileMetadataRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteFileMetadataRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DeleteFileMetadataRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteFileMetadataRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DeleteFileMetadataRequest.file_id)
}

// -------------------------------------------------------------------

// DeleteFileMetadataReply

// -------------------------------------------------------------------

// DetectRequest

// string user_id = 1 [(.validate.rules) = {
inline void DetectRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& DetectRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DetectRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DetectRequest.user_id)
}
inline std::string* DetectRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DetectRequest.user_id)
  return _s;
}
inline const std::string& DetectRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void DetectRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DetectRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DetectRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void DetectRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& DetectRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DetectRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DetectRequest.file_id)
}
inline std::string* DetectRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DetectRequest.file_id)
  return _s;
}
inline const std::string& DetectRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void DetectRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DetectRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DetectRequest.file_id)
}

// -------------------------------------------------------------------

// DetectReply

// string artifact_id = 1 [(.validate.rules) = {
inline void DetectReply::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& DetectReply::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DetectReply.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectReply::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DetectReply.artifact_id)
}
inline std::string* DetectReply::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DetectReply.artifact_id)
  return _s;
}
inline const std::string& DetectReply::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void DetectReply::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectReply::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectReply::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DetectReply.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectReply::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DetectReply.artifact_id)
}

// -------------------------------------------------------------------

// ConfusionRequest

// string user_id = 1 [(.validate.rules) = {
inline void ConfusionRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ConfusionRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionRequest.user_id)
}
inline std::string* ConfusionRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionRequest.user_id)
  return _s;
}
inline const std::string& ConfusionRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ConfusionRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void ConfusionRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& ConfusionRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionRequest.file_id)
}
inline std::string* ConfusionRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionRequest.file_id)
  return _s;
}
inline const std::string& ConfusionRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void ConfusionRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionRequest.file_id)
}

// -------------------------------------------------------------------

// ConfusionReply

// string artifact_id = 1 [(.validate.rules) = {
inline void ConfusionReply::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& ConfusionReply::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionReply.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionReply::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionReply.artifact_id)
}
inline std::string* ConfusionReply::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionReply.artifact_id)
  return _s;
}
inline const std::string& ConfusionReply::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void ConfusionReply::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionReply::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionReply::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionReply.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionReply::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionReply.artifact_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void ConfusionReply::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& ConfusionReply::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionReply.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionReply::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionReply.file_id)
}
inline std::string* ConfusionReply::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionReply.file_id)
  return _s;
}
inline const std::string& ConfusionReply::_internal_file_id() const {
  return file_id_.Get();
}
inline void ConfusionReply::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionReply::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionReply::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionReply.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionReply::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionReply.file_id)
}

// string affiliated_file_id = 3 [(.validate.rules) = {
inline void ConfusionReply::clear_affiliated_file_id() {
  affiliated_file_id_.ClearToEmpty();
}
inline const std::string& ConfusionReply::affiliated_file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionReply.affiliated_file_id)
  return _internal_affiliated_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionReply::set_affiliated_file_id(ArgT0&& arg0, ArgT... args) {
 
 affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionReply.affiliated_file_id)
}
inline std::string* ConfusionReply::mutable_affiliated_file_id() {
  std::string* _s = _internal_mutable_affiliated_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionReply.affiliated_file_id)
  return _s;
}
inline const std::string& ConfusionReply::_internal_affiliated_file_id() const {
  return affiliated_file_id_.Get();
}
inline void ConfusionReply::_internal_set_affiliated_file_id(const std::string& value) {
  
  affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionReply::_internal_mutable_affiliated_file_id() {
  
  return affiliated_file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionReply::release_affiliated_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionReply.affiliated_file_id)
  return affiliated_file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionReply::set_allocated_affiliated_file_id(std::string* affiliated_file_id) {
  if (affiliated_file_id != nullptr) {
    
  } else {
    
  }
  affiliated_file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), affiliated_file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (affiliated_file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionReply.affiliated_file_id)
}

// string method = 4;
inline void ConfusionReply::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& ConfusionReply::method() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionReply.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionReply::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionReply.method)
}
inline std::string* ConfusionReply::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionReply.method)
  return _s;
}
inline const std::string& ConfusionReply::_internal_method() const {
  return method_.Get();
}
inline void ConfusionReply::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionReply::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionReply::release_method() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionReply.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionReply::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionReply.method)
}

// -------------------------------------------------------------------

// PackerRequest

// string user_id = 1 [(.validate.rules) = {
inline void PackerRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& PackerRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.PackerRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackerRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.PackerRequest.user_id)
}
inline std::string* PackerRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.PackerRequest.user_id)
  return _s;
}
inline const std::string& PackerRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void PackerRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PackerRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PackerRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.PackerRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PackerRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.PackerRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void PackerRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& PackerRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.PackerRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackerRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.PackerRequest.file_id)
}
inline std::string* PackerRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.PackerRequest.file_id)
  return _s;
}
inline const std::string& PackerRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void PackerRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PackerRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PackerRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.PackerRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PackerRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.PackerRequest.file_id)
}

// -------------------------------------------------------------------

// PackerReply

// string artifact_id = 1 [(.validate.rules) = {
inline void PackerReply::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& PackerReply::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.PackerReply.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackerReply::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.PackerReply.artifact_id)
}
inline std::string* PackerReply::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.PackerReply.artifact_id)
  return _s;
}
inline const std::string& PackerReply::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void PackerReply::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PackerReply::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PackerReply::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.PackerReply.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PackerReply::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.PackerReply.artifact_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void PackerReply::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& PackerReply::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.PackerReply.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackerReply::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.PackerReply.file_id)
}
inline std::string* PackerReply::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.PackerReply.file_id)
  return _s;
}
inline const std::string& PackerReply::_internal_file_id() const {
  return file_id_.Get();
}
inline void PackerReply::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PackerReply::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PackerReply::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.PackerReply.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PackerReply::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.PackerReply.file_id)
}

// string affiliated_file_id = 3 [(.validate.rules) = {
inline void PackerReply::clear_affiliated_file_id() {
  affiliated_file_id_.ClearToEmpty();
}
inline const std::string& PackerReply::affiliated_file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.PackerReply.affiliated_file_id)
  return _internal_affiliated_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackerReply::set_affiliated_file_id(ArgT0&& arg0, ArgT... args) {
 
 affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.PackerReply.affiliated_file_id)
}
inline std::string* PackerReply::mutable_affiliated_file_id() {
  std::string* _s = _internal_mutable_affiliated_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.PackerReply.affiliated_file_id)
  return _s;
}
inline const std::string& PackerReply::_internal_affiliated_file_id() const {
  return affiliated_file_id_.Get();
}
inline void PackerReply::_internal_set_affiliated_file_id(const std::string& value) {
  
  affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PackerReply::_internal_mutable_affiliated_file_id() {
  
  return affiliated_file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PackerReply::release_affiliated_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.PackerReply.affiliated_file_id)
  return affiliated_file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PackerReply::set_allocated_affiliated_file_id(std::string* affiliated_file_id) {
  if (affiliated_file_id != nullptr) {
    
  } else {
    
  }
  affiliated_file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), affiliated_file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (affiliated_file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.PackerReply.affiliated_file_id)
}

// string method = 4;
inline void PackerReply::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& PackerReply::method() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.PackerReply.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PackerReply::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.PackerReply.method)
}
inline std::string* PackerReply::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.PackerReply.method)
  return _s;
}
inline const std::string& PackerReply::_internal_method() const {
  return method_.Get();
}
inline void PackerReply::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PackerReply::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PackerReply::release_method() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.PackerReply.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PackerReply::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.PackerReply.method)
}

// -------------------------------------------------------------------

// GetArtifactMetadataRequest

// string user_id = 1 [(.validate.rules) = {
inline void GetArtifactMetadataRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataRequest.user_id)
}
inline std::string* GetArtifactMetadataRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataRequest.user_id)
  return _s;
}
inline const std::string& GetArtifactMetadataRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetArtifactMetadataRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataRequest.user_id)
}

// string artifact_id = 2 [(.validate.rules) = {
inline void GetArtifactMetadataRequest::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataRequest::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataRequest::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
}
inline std::string* GetArtifactMetadataRequest::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
  return _s;
}
inline const std::string& GetArtifactMetadataRequest::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void GetArtifactMetadataRequest::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataRequest::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataRequest::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataRequest::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
}

// -------------------------------------------------------------------

// GetArtifactMetadataReply

// string artifact_id = 1 [(.validate.rules) = {
inline void GetArtifactMetadataReply::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataReply::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataReply::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
}
inline std::string* GetArtifactMetadataReply::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
  return _s;
}
inline const std::string& GetArtifactMetadataReply::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void GetArtifactMetadataReply::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataReply::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void GetArtifactMetadataReply::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataReply::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataReply.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataReply::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataReply.file_id)
}
inline std::string* GetArtifactMetadataReply::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataReply.file_id)
  return _s;
}
inline const std::string& GetArtifactMetadataReply::_internal_file_id() const {
  return file_id_.Get();
}
inline void GetArtifactMetadataReply::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataReply.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataReply::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataReply.file_id)
}

// string affiliated_file_id = 3 [(.validate.rules) = {
inline void GetArtifactMetadataReply::clear_affiliated_file_id() {
  affiliated_file_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataReply::affiliated_file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
  return _internal_affiliated_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataReply::set_affiliated_file_id(ArgT0&& arg0, ArgT... args) {
 
 affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
}
inline std::string* GetArtifactMetadataReply::mutable_affiliated_file_id() {
  std::string* _s = _internal_mutable_affiliated_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
  return _s;
}
inline const std::string& GetArtifactMetadataReply::_internal_affiliated_file_id() const {
  return affiliated_file_id_.Get();
}
inline void GetArtifactMetadataReply::_internal_set_affiliated_file_id(const std::string& value) {
  
  affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::_internal_mutable_affiliated_file_id() {
  
  return affiliated_file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::release_affiliated_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
  return affiliated_file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataReply::set_allocated_affiliated_file_id(std::string* affiliated_file_id) {
  if (affiliated_file_id != nullptr) {
    
  } else {
    
  }
  affiliated_file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), affiliated_file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (affiliated_file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
}

// string method = 4;
inline void GetArtifactMetadataReply::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataReply::method() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataReply.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataReply::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataReply.method)
}
inline std::string* GetArtifactMetadataReply::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataReply.method)
  return _s;
}
inline const std::string& GetArtifactMetadataReply::_internal_method() const {
  return method_.Get();
}
inline void GetArtifactMetadataReply::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::release_method() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataReply.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataReply::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataReply.method)
}

// -------------------------------------------------------------------

// GetArtifactMetadataByFileIdRequest

// string user_id = 1 [(.validate.rules) = {
inline void GetArtifactMetadataByFileIdRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataByFileIdRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataByFileIdRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
}
inline std::string* GetArtifactMetadataByFileIdRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
  return _s;
}
inline const std::string& GetArtifactMetadataByFileIdRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetArtifactMetadataByFileIdRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataByFileIdRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataByFileIdRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataByFileIdRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void GetArtifactMetadataByFileIdRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataByFileIdRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataByFileIdRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
}
inline std::string* GetArtifactMetadataByFileIdRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
  return _s;
}
inline const std::string& GetArtifactMetadataByFileIdRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void GetArtifactMetadataByFileIdRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataByFileIdRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataByFileIdRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataByFileIdRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
}

// -------------------------------------------------------------------

// GetArtifactMetadataByFileIdReply

// repeated .bugu.service.v1.GetArtifactMetadataReply artifact_metadata = 1;
inline int GetArtifactMetadataByFileIdReply::_internal_artifact_metadata_size() const {
  return artifact_metadata_.size();
}
inline int GetArtifactMetadataByFileIdReply::artifact_metadata_size() const {
  return _internal_artifact_metadata_size();
}
inline void GetArtifactMetadataByFileIdReply::clear_artifact_metadata() {
  artifact_metadata_.Clear();
}
inline ::bugu::service::v1::GetArtifactMetadataReply* GetArtifactMetadataByFileIdReply::mutable_artifact_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return artifact_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply >*
GetArtifactMetadataByFileIdReply::mutable_artifact_metadata() {
  // @@protoc_insertion_point(field_mutable_list:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return &artifact_metadata_;
}
inline const ::bugu::service::v1::GetArtifactMetadataReply& GetArtifactMetadataByFileIdReply::_internal_artifact_metadata(int index) const {
  return artifact_metadata_.Get(index);
}
inline const ::bugu::service::v1::GetArtifactMetadataReply& GetArtifactMetadataByFileIdReply::artifact_metadata(int index) const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return _internal_artifact_metadata(index);
}
inline ::bugu::service::v1::GetArtifactMetadataReply* GetArtifactMetadataByFileIdReply::_internal_add_artifact_metadata() {
  return artifact_metadata_.Add();
}
inline ::bugu::service::v1::GetArtifactMetadataReply* GetArtifactMetadataByFileIdReply::add_artifact_metadata() {
  ::bugu::service::v1::GetArtifactMetadataReply* _add = _internal_add_artifact_metadata();
  // @@protoc_insertion_point(field_add:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply >&
GetArtifactMetadataByFileIdReply::artifact_metadata() const {
  // @@protoc_insertion_point(field_list:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return artifact_metadata_;
}

// -------------------------------------------------------------------

// DeleteArtifactMetadataRequest

// string user_id = 1 [(.validate.rules) = {
inline void DeleteArtifactMetadataRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& DeleteArtifactMetadataRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteArtifactMetadataRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
}
inline std::string* DeleteArtifactMetadataRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
  return _s;
}
inline const std::string& DeleteArtifactMetadataRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void DeleteArtifactMetadataRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteArtifactMetadataRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteArtifactMetadataRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteArtifactMetadataRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
}

// string artifact_id = 2 [(.validate.rules) = {
inline void DeleteArtifactMetadataRequest::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& DeleteArtifactMetadataRequest::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteArtifactMetadataRequest::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
}
inline std::string* DeleteArtifactMetadataRequest::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
  return _s;
}
inline const std::string& DeleteArtifactMetadataRequest::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void DeleteArtifactMetadataRequest::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteArtifactMetadataRequest::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteArtifactMetadataRequest::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteArtifactMetadataRequest::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
}

// -------------------------------------------------------------------

// DeleteArtifactMetadataReply

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace service
}  // namespace bugu

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bugu::service::v1::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bugu::service::v1::Type>() {
  return ::bugu::service::v1::Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bugu_2eproto

```

`api/detect/service/v1/cpp/detect.grpc.pb.cc`:

```cc
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: detect.proto

#include "detect.pb.h"
#include "detect.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace bugu_detect {
namespace service {
namespace v1 {

static const char* BuguDetect_method_names[] = {
  "/bugu_detect.service.v1.BuguDetect/Detect",
};

std::unique_ptr< BuguDetect::Stub> BuguDetect::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< BuguDetect::Stub> stub(new BuguDetect::Stub(channel, options));
  return stub;
}

BuguDetect::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Detect_(BuguDetect_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status BuguDetect::Stub::Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::bugu_detect::service::v1::DetectReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu_detect::service::v1::DetectRequest, ::bugu_detect::service::v1::DetectReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Detect_, context, request, response);
}

void BuguDetect::Stub::async::Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu_detect::service::v1::DetectRequest, ::bugu_detect::service::v1::DetectReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Detect_, context, request, response, std::move(f));
}

void BuguDetect::Stub::async::Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Detect_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu_detect::service::v1::DetectReply>* BuguDetect::Stub::PrepareAsyncDetectRaw(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu_detect::service::v1::DetectReply, ::bugu_detect::service::v1::DetectRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Detect_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu_detect::service::v1::DetectReply>* BuguDetect::Stub::AsyncDetectRaw(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncDetectRaw(context, request, cq);
  result->StartCall();
  return result;
}

BuguDetect::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      BuguDetect_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< BuguDetect::Service, ::bugu_detect::service::v1::DetectRequest, ::bugu_detect::service::v1::DetectReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](BuguDetect::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu_detect::service::v1::DetectRequest* req,
             ::bugu_detect::service::v1::DetectReply* resp) {
               return service->Detect(ctx, req, resp);
             }, this)));
}

BuguDetect::Service::~Service() {
}

::grpc::Status BuguDetect::Service::Detect(::grpc::ServerContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace bugu_detect
}  // namespace service
}  // namespace v1


```

`api/detect/service/v1/cpp/detect.grpc.pb.h`:

```h
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: detect.proto
#ifndef GRPC_detect_2eproto__INCLUDED
#define GRPC_detect_2eproto__INCLUDED

#include "detect.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace bugu_detect {
namespace service {
namespace v1 {

class BuguDetect final {
 public:
  static constexpr char const* service_full_name() {
    return "bugu_detect.service.v1.BuguDetect";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::bugu_detect::service::v1::DetectReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_detect::service::v1::DetectReply>> AsyncDetect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_detect::service::v1::DetectReply>>(AsyncDetectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_detect::service::v1::DetectReply>> PrepareAsyncDetect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_detect::service::v1::DetectReply>>(PrepareAsyncDetectRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu_detect::service::v1::DetectReply>* AsyncDetectRaw(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu_detect::service::v1::DetectReply>* PrepareAsyncDetectRaw(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::bugu_detect::service::v1::DetectReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_detect::service::v1::DetectReply>> AsyncDetect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_detect::service::v1::DetectReply>>(AsyncDetectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_detect::service::v1::DetectReply>> PrepareAsyncDetect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_detect::service::v1::DetectReply>>(PrepareAsyncDetectRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response, std::function<void(::grpc::Status)>) override;
      void Detect(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bugu_detect::service::v1::DetectReply>* AsyncDetectRaw(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu_detect::service::v1::DetectReply>* PrepareAsyncDetectRaw(::grpc::ClientContext* context, const ::bugu_detect::service::v1::DetectRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Detect_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Detect(::grpc::ServerContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Detect() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu_detect::service::v1::DetectRequest* /*request*/, ::bugu_detect::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetect(::grpc::ServerContext* context, ::bugu_detect::service::v1::DetectRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu_detect::service::v1::DetectReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Detect<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Detect() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu_detect::service::v1::DetectRequest, ::bugu_detect::service::v1::DetectReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu_detect::service::v1::DetectRequest* request, ::bugu_detect::service::v1::DetectReply* response) { return this->Detect(context, request, response); }));}
    void SetMessageAllocatorFor_Detect(
        ::grpc::MessageAllocator< ::bugu_detect::service::v1::DetectRequest, ::bugu_detect::service::v1::DetectReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu_detect::service::v1::DetectRequest, ::bugu_detect::service::v1::DetectReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu_detect::service::v1::DetectRequest* /*request*/, ::bugu_detect::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Detect(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu_detect::service::v1::DetectRequest* /*request*/, ::bugu_detect::service::v1::DetectReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Detect<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Detect() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu_detect::service::v1::DetectRequest* /*request*/, ::bugu_detect::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Detect() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu_detect::service::v1::DetectRequest* /*request*/, ::bugu_detect::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Detect() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Detect(context, request, response); }));
    }
    ~WithRawCallbackMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu_detect::service::v1::DetectRequest* /*request*/, ::bugu_detect::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Detect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Detect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Detect() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu_detect::service::v1::DetectRequest, ::bugu_detect::service::v1::DetectReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu_detect::service::v1::DetectRequest, ::bugu_detect::service::v1::DetectReply>* streamer) {
                       return this->StreamedDetect(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Detect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Detect(::grpc::ServerContext* /*context*/, const ::bugu_detect::service::v1::DetectRequest* /*request*/, ::bugu_detect::service::v1::DetectReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDetect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu_detect::service::v1::DetectRequest,::bugu_detect::service::v1::DetectReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Detect<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Detect<Service > StreamedService;
};

}  // namespace v1
}  // namespace service
}  // namespace bugu_detect


#endif  // GRPC_detect_2eproto__INCLUDED

```

`api/detect/service/v1/cpp/detect.pb.cc`:

```cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: detect.proto

#include "detect.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace bugu_detect {
namespace service {
namespace v1 {
constexpr DetectRequest::DetectRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_()
  , size_(0u){}
struct DetectRequestDefaultTypeInternal {
  constexpr DetectRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DetectRequestDefaultTypeInternal() {}
  union {
    DetectRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DetectRequestDefaultTypeInternal _DetectRequest_default_instance_;
constexpr DetectReply::DetectReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0)
{}
struct DetectReplyDefaultTypeInternal {
  constexpr DetectReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DetectReplyDefaultTypeInternal() {}
  union {
    DetectReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DetectReplyDefaultTypeInternal _DetectReply_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu_detect
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_detect_2eproto[2];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_detect_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_detect_2eproto = nullptr;

const uint32_t TableStruct_detect_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu_detect::service::v1::DetectRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu_detect::service::v1::DetectRequest, data_),
  PROTOBUF_FIELD_OFFSET(::bugu_detect::service::v1::DetectRequest, size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu_detect::service::v1::DetectReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu_detect::service::v1::DetectReply, type_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::bugu_detect::service::v1::DetectRequest)},
  { 8, -1, -1, sizeof(::bugu_detect::service::v1::DetectReply)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu_detect::service::v1::_DetectRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu_detect::service::v1::_DetectReply_default_instance_),
};

const char descriptor_table_protodef_detect_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014detect.proto\022\026bugu_detect.service.v1\"+"
  "\n\rDetectRequest\022\014\n\004data\030\001 \003(\014\022\014\n\004size\030\002 "
  "\001(\r\"9\n\013DetectReply\022*\n\004type\030\001 \001(\0162\034.bugu_"
  "detect.service.v1.Type*\333\003\n\004Type\022\021\n\rTYPE_"
  "ADPOSHEL\020\000\022\016\n\nTYPE_AGENT\020\001\022\020\n\014TYPE_ALLAP"
  "LE\020\002\022\022\n\016TYPE_AMONETIZE\020\003\022\017\n\013TYPE_ANDROM\020"
  "\004\022\020\n\014TYPE_AUTORUN\020\005\022\023\n\017TYPE_BROWSE_FOX\020\006"
  "\022\017\n\013TYPE_DINWOD\020\007\022\r\n\tTYPE_ELEX\020\010\022\017\n\013TYPE"
  "_EXPIRO\020\t\022\017\n\013TYPE_FASONG\020\n\022\021\n\rTYPE_HACK_"
  "KMS\020\013\022\r\n\tTYPE_HLUX\020\014\022\021\n\rTYPE_INJECTOR\020\r\022"
  "\025\n\021TYPE_INSTALL_CORE\020\016\022\023\n\017TYPE_MULTI_Plu"
  "g\020\017\022\023\n\017TYPE_NEOREKLAMI\020\020\022\017\n\013TYPE_NESHTA\020"
  "\021\022\016\n\nTYPE_OTHER\020\022\022\017\n\013TYPE_REGRUN\020\023\022\017\n\013TY"
  "PE_SALITY\020\024\022\022\n\016TYPE_SNARASITE\020\025\022\022\n\016TYPE_"
  "STABTINKO\020\026\022\014\n\010TYPE_VBA\020\027\022\020\n\014TYPE_VBKRYP"
  "T\020\030\022\017\n\013TYPE_VILSEL\020\0312d\n\nBuguDetect\022V\n\006De"
  "tect\022%.bugu_detect.service.v1.DetectRequ"
  "est\032#.bugu_detect.service.v1.DetectReply"
  "\"\000B2Z0github.com/hominsu/bugu/api/detect"
  "/service/v1;v1b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_detect_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_detect_2eproto = {
  false, false, 782, descriptor_table_protodef_detect_2eproto, "detect.proto", 
  &descriptor_table_detect_2eproto_once, nullptr, 0, 2,
  schemas, file_default_instances, TableStruct_detect_2eproto::offsets,
  file_level_metadata_detect_2eproto, file_level_enum_descriptors_detect_2eproto, file_level_service_descriptors_detect_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_detect_2eproto_getter() {
  return &descriptor_table_detect_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_detect_2eproto(&descriptor_table_detect_2eproto);
namespace bugu_detect {
namespace service {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_detect_2eproto);
  return file_level_enum_descriptors_detect_2eproto[0];
}
bool Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class DetectRequest::_Internal {
 public:
};

DetectRequest::DetectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu_detect.service.v1.DetectRequest)
}
DetectRequest::DetectRequest(const DetectRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:bugu_detect.service.v1.DetectRequest)
}

inline void DetectRequest::SharedCtor() {
size_ = 0u;
}

DetectRequest::~DetectRequest() {
  // @@protoc_insertion_point(destructor:bugu_detect.service.v1.DetectRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DetectRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DetectRequest::ArenaDtor(void* object) {
  DetectRequest* _this = reinterpret_cast< DetectRequest* >(object);
  (void)_this;
}
void DetectRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DetectRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DetectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu_detect.service.v1.DetectRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  size_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DetectRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_data();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetectRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu_detect.service.v1.DetectRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes data = 1;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    const auto& s = this->_internal_data(i);
    target = stream->WriteBytes(1, s, target);
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu_detect.service.v1.DetectRequest)
  return target;
}

size_t DetectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu_detect.service.v1.DetectRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes data = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(data_.size());
  for (int i = 0, n = data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      data_.Get(i));
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DetectRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DetectRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DetectRequest::GetClassData() const { return &_class_data_; }

void DetectRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DetectRequest *>(to)->MergeFrom(
      static_cast<const DetectRequest &>(from));
}


void DetectRequest::MergeFrom(const DetectRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu_detect.service.v1.DetectRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from._internal_size() != 0) {
    _internal_set_size(from._internal_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DetectRequest::CopyFrom(const DetectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu_detect.service.v1.DetectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetectRequest::IsInitialized() const {
  return true;
}

void DetectRequest::InternalSwap(DetectRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DetectRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_detect_2eproto_getter, &descriptor_table_detect_2eproto_once,
      file_level_metadata_detect_2eproto[0]);
}

// ===================================================================

class DetectReply::_Internal {
 public:
};

DetectReply::DetectReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu_detect.service.v1.DetectReply)
}
DetectReply::DetectReply(const DetectReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:bugu_detect.service.v1.DetectReply)
}

inline void DetectReply::SharedCtor() {
type_ = 0;
}

DetectReply::~DetectReply() {
  // @@protoc_insertion_point(destructor:bugu_detect.service.v1.DetectReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DetectReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DetectReply::ArenaDtor(void* object) {
  DetectReply* _this = reinterpret_cast< DetectReply* >(object);
  (void)_this;
}
void DetectReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DetectReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DetectReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu_detect.service.v1.DetectReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DetectReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .bugu_detect.service.v1.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::bugu_detect::service::v1::Type>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetectReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu_detect.service.v1.DetectReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .bugu_detect.service.v1.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu_detect.service.v1.DetectReply)
  return target;
}

size_t DetectReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu_detect.service.v1.DetectReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bugu_detect.service.v1.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DetectReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DetectReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DetectReply::GetClassData() const { return &_class_data_; }

void DetectReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DetectReply *>(to)->MergeFrom(
      static_cast<const DetectReply &>(from));
}


void DetectReply::MergeFrom(const DetectReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu_detect.service.v1.DetectReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DetectReply::CopyFrom(const DetectReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu_detect.service.v1.DetectReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetectReply::IsInitialized() const {
  return true;
}

void DetectReply::InternalSwap(DetectReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DetectReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_detect_2eproto_getter, &descriptor_table_detect_2eproto_once,
      file_level_metadata_detect_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace service
}  // namespace bugu_detect
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::bugu_detect::service::v1::DetectRequest* Arena::CreateMaybeMessage< ::bugu_detect::service::v1::DetectRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu_detect::service::v1::DetectRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu_detect::service::v1::DetectReply* Arena::CreateMaybeMessage< ::bugu_detect::service::v1::DetectReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu_detect::service::v1::DetectReply >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

```

`api/detect/service/v1/cpp/detect.pb.h`:

```h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: detect.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_detect_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_detect_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_detect_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_detect_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_detect_2eproto;
namespace bugu_detect {
namespace service {
namespace v1 {
class DetectReply;
struct DetectReplyDefaultTypeInternal;
extern DetectReplyDefaultTypeInternal _DetectReply_default_instance_;
class DetectRequest;
struct DetectRequestDefaultTypeInternal;
extern DetectRequestDefaultTypeInternal _DetectRequest_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu_detect
PROTOBUF_NAMESPACE_OPEN
template<> ::bugu_detect::service::v1::DetectReply* Arena::CreateMaybeMessage<::bugu_detect::service::v1::DetectReply>(Arena*);
template<> ::bugu_detect::service::v1::DetectRequest* Arena::CreateMaybeMessage<::bugu_detect::service::v1::DetectRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bugu_detect {
namespace service {
namespace v1 {

enum Type : int {
  TYPE_ADPOSHEL = 0,
  TYPE_AGENT = 1,
  TYPE_ALLAPLE = 2,
  TYPE_AMONETIZE = 3,
  TYPE_ANDROM = 4,
  TYPE_AUTORUN = 5,
  TYPE_BROWSE_FOX = 6,
  TYPE_DINWOD = 7,
  TYPE_ELEX = 8,
  TYPE_EXPIRO = 9,
  TYPE_FASONG = 10,
  TYPE_HACK_KMS = 11,
  TYPE_HLUX = 12,
  TYPE_INJECTOR = 13,
  TYPE_INSTALL_CORE = 14,
  TYPE_MULTI_Plug = 15,
  TYPE_NEOREKLAMI = 16,
  TYPE_NESHTA = 17,
  TYPE_OTHER = 18,
  TYPE_REGRUN = 19,
  TYPE_SALITY = 20,
  TYPE_SNARASITE = 21,
  TYPE_STABTINKO = 22,
  TYPE_VBA = 23,
  TYPE_VBKRYPT = 24,
  TYPE_VILSEL = 25,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_IsValid(int value);
constexpr Type Type_MIN = TYPE_ADPOSHEL;
constexpr Type Type_MAX = TYPE_VILSEL;
constexpr int Type_ARRAYSIZE = Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor();
template<typename T>
inline const std::string& Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_descriptor(), enum_t_value);
}
inline bool Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class DetectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu_detect.service.v1.DetectRequest) */ {
 public:
  inline DetectRequest() : DetectRequest(nullptr) {}
  ~DetectRequest() override;
  explicit constexpr DetectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectRequest(const DetectRequest& from);
  DetectRequest(DetectRequest&& from) noexcept
    : DetectRequest() {
    *this = ::std::move(from);
  }

  inline DetectRequest& operator=(const DetectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectRequest& operator=(DetectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectRequest* internal_default_instance() {
    return reinterpret_cast<const DetectRequest*>(
               &_DetectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DetectRequest& a, DetectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu_detect.service.v1.DetectRequest";
  }
  protected:
  explicit DetectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated bytes data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // uint32 size = 2;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bugu_detect.service.v1.DetectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
  uint32_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_detect_2eproto;
};
// -------------------------------------------------------------------

class DetectReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu_detect.service.v1.DetectReply) */ {
 public:
  inline DetectReply() : DetectReply(nullptr) {}
  ~DetectReply() override;
  explicit constexpr DetectReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectReply(const DetectReply& from);
  DetectReply(DetectReply&& from) noexcept
    : DetectReply() {
    *this = ::std::move(from);
  }

  inline DetectReply& operator=(const DetectReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectReply& operator=(DetectReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectReply* internal_default_instance() {
    return reinterpret_cast<const DetectReply*>(
               &_DetectReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DetectReply& a, DetectReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu_detect.service.v1.DetectReply";
  }
  protected:
  explicit DetectReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .bugu_detect.service.v1.Type type = 1;
  void clear_type();
  ::bugu_detect::service::v1::Type type() const;
  void set_type(::bugu_detect::service::v1::Type value);
  private:
  ::bugu_detect::service::v1::Type _internal_type() const;
  void _internal_set_type(::bugu_detect::service::v1::Type value);
  public:

  // @@protoc_insertion_point(class_scope:bugu_detect.service.v1.DetectReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_detect_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DetectRequest

// repeated bytes data = 1;
inline int DetectRequest::_internal_data_size() const {
  return data_.size();
}
inline int DetectRequest::data_size() const {
  return _internal_data_size();
}
inline void DetectRequest::clear_data() {
  data_.Clear();
}
inline std::string* DetectRequest::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:bugu_detect.service.v1.DetectRequest.data)
  return _s;
}
inline const std::string& DetectRequest::_internal_data(int index) const {
  return data_.Get(index);
}
inline const std::string& DetectRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:bugu_detect.service.v1.DetectRequest.data)
  return _internal_data(index);
}
inline std::string* DetectRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:bugu_detect.service.v1.DetectRequest.data)
  return data_.Mutable(index);
}
inline void DetectRequest::set_data(int index, const std::string& value) {
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bugu_detect.service.v1.DetectRequest.data)
}
inline void DetectRequest::set_data(int index, std::string&& value) {
  data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bugu_detect.service.v1.DetectRequest.data)
}
inline void DetectRequest::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bugu_detect.service.v1.DetectRequest.data)
}
inline void DetectRequest::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bugu_detect.service.v1.DetectRequest.data)
}
inline std::string* DetectRequest::_internal_add_data() {
  return data_.Add();
}
inline void DetectRequest::add_data(const std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bugu_detect.service.v1.DetectRequest.data)
}
inline void DetectRequest::add_data(std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bugu_detect.service.v1.DetectRequest.data)
}
inline void DetectRequest::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bugu_detect.service.v1.DetectRequest.data)
}
inline void DetectRequest::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bugu_detect.service.v1.DetectRequest.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DetectRequest::data() const {
  // @@protoc_insertion_point(field_list:bugu_detect.service.v1.DetectRequest.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DetectRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:bugu_detect.service.v1.DetectRequest.data)
  return &data_;
}

// uint32 size = 2;
inline void DetectRequest::clear_size() {
  size_ = 0u;
}
inline uint32_t DetectRequest::_internal_size() const {
  return size_;
}
inline uint32_t DetectRequest::size() const {
  // @@protoc_insertion_point(field_get:bugu_detect.service.v1.DetectRequest.size)
  return _internal_size();
}
inline void DetectRequest::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void DetectRequest::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:bugu_detect.service.v1.DetectRequest.size)
}

// -------------------------------------------------------------------

// DetectReply

// .bugu_detect.service.v1.Type type = 1;
inline void DetectReply::clear_type() {
  type_ = 0;
}
inline ::bugu_detect::service::v1::Type DetectReply::_internal_type() const {
  return static_cast< ::bugu_detect::service::v1::Type >(type_);
}
inline ::bugu_detect::service::v1::Type DetectReply::type() const {
  // @@protoc_insertion_point(field_get:bugu_detect.service.v1.DetectReply.type)
  return _internal_type();
}
inline void DetectReply::_internal_set_type(::bugu_detect::service::v1::Type value) {
  
  type_ = value;
}
inline void DetectReply::set_type(::bugu_detect::service::v1::Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bugu_detect.service.v1.DetectReply.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace service
}  // namespace bugu_detect

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bugu_detect::service::v1::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bugu_detect::service::v1::Type>() {
  return ::bugu_detect::service::v1::Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_detect_2eproto

```

`api/detect/service/v1/detect.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: v1/detect.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Type int32

const (
	Type_TYPE_ADPOSHEL     Type = 0
	Type_TYPE_AGENT        Type = 1
	Type_TYPE_ALLAPLE      Type = 2
	Type_TYPE_AMONETIZE    Type = 3
	Type_TYPE_ANDROM       Type = 4
	Type_TYPE_AUTORUN      Type = 5
	Type_TYPE_BROWSE_FOX   Type = 6
	Type_TYPE_DINWOD       Type = 7
	Type_TYPE_ELEX         Type = 8
	Type_TYPE_EXPIRO       Type = 9
	Type_TYPE_FASONG       Type = 10
	Type_TYPE_HACK_KMS     Type = 11
	Type_TYPE_HLUX         Type = 12
	Type_TYPE_INJECTOR     Type = 13
	Type_TYPE_INSTALL_CORE Type = 14
	Type_TYPE_MULTI_Plug   Type = 15
	Type_TYPE_NEOREKLAMI   Type = 16
	Type_TYPE_NESHTA       Type = 17
	Type_TYPE_OTHER        Type = 18
	Type_TYPE_REGRUN       Type = 19
	Type_TYPE_SALITY       Type = 20
	Type_TYPE_SNARASITE    Type = 21
	Type_TYPE_STABTINKO    Type = 22
	Type_TYPE_VBA          Type = 23
	Type_TYPE_VBKRYPT      Type = 24
	Type_TYPE_VILSEL       Type = 25
)

// Enum value maps for Type.
var (
	Type_name = map[int32]string{
		0:  "TYPE_ADPOSHEL",
		1:  "TYPE_AGENT",
		2:  "TYPE_ALLAPLE",
		3:  "TYPE_AMONETIZE",
		4:  "TYPE_ANDROM",
		5:  "TYPE_AUTORUN",
		6:  "TYPE_BROWSE_FOX",
		7:  "TYPE_DINWOD",
		8:  "TYPE_ELEX",
		9:  "TYPE_EXPIRO",
		10: "TYPE_FASONG",
		11: "TYPE_HACK_KMS",
		12: "TYPE_HLUX",
		13: "TYPE_INJECTOR",
		14: "TYPE_INSTALL_CORE",
		15: "TYPE_MULTI_Plug",
		16: "TYPE_NEOREKLAMI",
		17: "TYPE_NESHTA",
		18: "TYPE_OTHER",
		19: "TYPE_REGRUN",
		20: "TYPE_SALITY",
		21: "TYPE_SNARASITE",
		22: "TYPE_STABTINKO",
		23: "TYPE_VBA",
		24: "TYPE_VBKRYPT",
		25: "TYPE_VILSEL",
	}
	Type_value = map[string]int32{
		"TYPE_ADPOSHEL":     0,
		"TYPE_AGENT":        1,
		"TYPE_ALLAPLE":      2,
		"TYPE_AMONETIZE":    3,
		"TYPE_ANDROM":       4,
		"TYPE_AUTORUN":      5,
		"TYPE_BROWSE_FOX":   6,
		"TYPE_DINWOD":       7,
		"TYPE_ELEX":         8,
		"TYPE_EXPIRO":       9,
		"TYPE_FASONG":       10,
		"TYPE_HACK_KMS":     11,
		"TYPE_HLUX":         12,
		"TYPE_INJECTOR":     13,
		"TYPE_INSTALL_CORE": 14,
		"TYPE_MULTI_Plug":   15,
		"TYPE_NEOREKLAMI":   16,
		"TYPE_NESHTA":       17,
		"TYPE_OTHER":        18,
		"TYPE_REGRUN":       19,
		"TYPE_SALITY":       20,
		"TYPE_SNARASITE":    21,
		"TYPE_STABTINKO":    22,
		"TYPE_VBA":          23,
		"TYPE_VBKRYPT":      24,
		"TYPE_VILSEL":       25,
	}
)

func (x Type) Enum() *Type {
	p := new(Type)
	*p = x
	return p
}

func (x Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Type) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_detect_proto_enumTypes[0].Descriptor()
}

func (Type) Type() protoreflect.EnumType {
	return &file_v1_detect_proto_enumTypes[0]
}

func (x Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Type.Descriptor instead.
func (Type) EnumDescriptor() ([]byte, []int) {
	return file_v1_detect_proto_rawDescGZIP(), []int{0}
}

type DetectRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data [][]byte `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	Size uint32   `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (x *DetectRequest) Reset() {
	*x = DetectRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_detect_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DetectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetectRequest) ProtoMessage() {}

func (x *DetectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_detect_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetectRequest.ProtoReflect.Descriptor instead.
func (*DetectRequest) Descriptor() ([]byte, []int) {
	return file_v1_detect_proto_rawDescGZIP(), []int{0}
}

func (x *DetectRequest) GetData() [][]byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *DetectRequest) GetSize() uint32 {
	if x != nil {
		return x.Size
	}
	return 0
}

type DetectReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type Type `protobuf:"varint,1,opt,name=type,proto3,enum=bugu_detect.service.v1.Type" json:"type,omitempty"`
}

func (x *DetectReply) Reset() {
	*x = DetectReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_detect_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DetectReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetectReply) ProtoMessage() {}

func (x *DetectReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_detect_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetectReply.ProtoReflect.Descriptor instead.
func (*DetectReply) Descriptor() ([]byte, []int) {
	return file_v1_detect_proto_rawDescGZIP(), []int{1}
}

func (x *DetectReply) GetType() Type {
	if x != nil {
		return x.Type
	}
	return Type_TYPE_ADPOSHEL
}

var File_v1_detect_proto protoreflect.FileDescriptor

var file_v1_detect_proto_rawDesc = []byte{
	0x0a, 0x0f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x16, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x22, 0x37, 0x0a, 0x0d, 0x44, 0x65, 0x74,
	0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61,
	0x74, 0x61, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x12,
	0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x73, 0x69,
	0x7a, 0x65, 0x22, 0x3f, 0x0a, 0x0b, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x52, 0x65, 0x70, 0x6c,
	0x79, 0x12, 0x30, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x1c, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74,
	0x79, 0x70, 0x65, 0x2a, 0xdb, 0x03, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x11, 0x0a, 0x0d,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x44, 0x50, 0x4f, 0x53, 0x48, 0x45, 0x4c, 0x10, 0x00, 0x12,
	0x0e, 0x0a, 0x0a, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x47, 0x45, 0x4e, 0x54, 0x10, 0x01, 0x12,
	0x10, 0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x4c, 0x4c, 0x41, 0x50, 0x4c, 0x45, 0x10,
	0x02, 0x12, 0x12, 0x0a, 0x0e, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x4d, 0x4f, 0x4e, 0x45, 0x54,
	0x49, 0x5a, 0x45, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x4e,
	0x44, 0x52, 0x4f, 0x4d, 0x10, 0x04, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41,
	0x55, 0x54, 0x4f, 0x52, 0x55, 0x4e, 0x10, 0x05, 0x12, 0x13, 0x0a, 0x0f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x42, 0x52, 0x4f, 0x57, 0x53, 0x45, 0x5f, 0x46, 0x4f, 0x58, 0x10, 0x06, 0x12, 0x0f, 0x0a,
	0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x44, 0x49, 0x4e, 0x57, 0x4f, 0x44, 0x10, 0x07, 0x12, 0x0d,
	0x0a, 0x09, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x45, 0x4c, 0x45, 0x58, 0x10, 0x08, 0x12, 0x0f, 0x0a,
	0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x45, 0x58, 0x50, 0x49, 0x52, 0x4f, 0x10, 0x09, 0x12, 0x0f,
	0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46, 0x41, 0x53, 0x4f, 0x4e, 0x47, 0x10, 0x0a, 0x12,
	0x11, 0x0a, 0x0d, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x48, 0x41, 0x43, 0x4b, 0x5f, 0x4b, 0x4d, 0x53,
	0x10, 0x0b, 0x12, 0x0d, 0x0a, 0x09, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x48, 0x4c, 0x55, 0x58, 0x10,
	0x0c, 0x12, 0x11, 0x0a, 0x0d, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x4a, 0x45, 0x43, 0x54,
	0x4f, 0x52, 0x10, 0x0d, 0x12, 0x15, 0x0a, 0x11, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x53,
	0x54, 0x41, 0x4c, 0x4c, 0x5f, 0x43, 0x4f, 0x52, 0x45, 0x10, 0x0e, 0x12, 0x13, 0x0a, 0x0f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x4d, 0x55, 0x4c, 0x54, 0x49, 0x5f, 0x50, 0x6c, 0x75, 0x67, 0x10, 0x0f,
	0x12, 0x13, 0x0a, 0x0f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4e, 0x45, 0x4f, 0x52, 0x45, 0x4b, 0x4c,
	0x41, 0x4d, 0x49, 0x10, 0x10, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4e, 0x45,
	0x53, 0x48, 0x54, 0x41, 0x10, 0x11, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f,
	0x54, 0x48, 0x45, 0x52, 0x10, 0x12, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52,
	0x45, 0x47, 0x52, 0x55, 0x4e, 0x10, 0x13, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x53, 0x41, 0x4c, 0x49, 0x54, 0x59, 0x10, 0x14, 0x12, 0x12, 0x0a, 0x0e, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x53, 0x4e, 0x41, 0x52, 0x41, 0x53, 0x49, 0x54, 0x45, 0x10, 0x15, 0x12, 0x12, 0x0a, 0x0e,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x53, 0x54, 0x41, 0x42, 0x54, 0x49, 0x4e, 0x4b, 0x4f, 0x10, 0x16,
	0x12, 0x0c, 0x0a, 0x08, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x42, 0x41, 0x10, 0x17, 0x12, 0x10,
	0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x42, 0x4b, 0x52, 0x59, 0x50, 0x54, 0x10, 0x18,
	0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x49, 0x4c, 0x53, 0x45, 0x4c, 0x10,
	0x19, 0x32, 0x64, 0x0a, 0x0a, 0x42, 0x75, 0x67, 0x75, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x12,
	0x56, 0x0a, 0x06, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x12, 0x25, 0x2e, 0x62, 0x75, 0x67, 0x75,
	0x5f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e,
	0x76, 0x31, 0x2e, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x23, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x2e, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x74, 0x65, 0x63, 0x74,
	0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x42, 0x32, 0x5a, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x73, 0x75, 0x2f, 0x62, 0x75,
	0x67, 0x75, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x2f, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x33,
}

var (
	file_v1_detect_proto_rawDescOnce sync.Once
	file_v1_detect_proto_rawDescData = file_v1_detect_proto_rawDesc
)

func file_v1_detect_proto_rawDescGZIP() []byte {
	file_v1_detect_proto_rawDescOnce.Do(func() {
		file_v1_detect_proto_rawDescData = protoimpl.X.CompressGZIP(file_v1_detect_proto_rawDescData)
	})
	return file_v1_detect_proto_rawDescData
}

var file_v1_detect_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_v1_detect_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_v1_detect_proto_goTypes = []interface{}{
	(Type)(0),             // 0: bugu_detect.service.v1.Type
	(*DetectRequest)(nil), // 1: bugu_detect.service.v1.DetectRequest
	(*DetectReply)(nil),   // 2: bugu_detect.service.v1.DetectReply
}
var file_v1_detect_proto_depIdxs = []int32{
	0, // 0: bugu_detect.service.v1.DetectReply.type:type_name -> bugu_detect.service.v1.Type
	1, // 1: bugu_detect.service.v1.BuguDetect.Detect:input_type -> bugu_detect.service.v1.DetectRequest
	2, // 2: bugu_detect.service.v1.BuguDetect.Detect:output_type -> bugu_detect.service.v1.DetectReply
	2, // [2:3] is the sub-list for method output_type
	1, // [1:2] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_v1_detect_proto_init() }
func file_v1_detect_proto_init() {
	if File_v1_detect_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_v1_detect_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DetectRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_detect_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DetectReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_v1_detect_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_detect_proto_goTypes,
		DependencyIndexes: file_v1_detect_proto_depIdxs,
		EnumInfos:         file_v1_detect_proto_enumTypes,
		MessageInfos:      file_v1_detect_proto_msgTypes,
	}.Build()
	File_v1_detect_proto = out.File
	file_v1_detect_proto_rawDesc = nil
	file_v1_detect_proto_goTypes = nil
	file_v1_detect_proto_depIdxs = nil
}

```

`api/detect/service/v1/detect.pb.validate.go`:

```go
// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: v1/detect.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DetectRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DetectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DetectRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DetectRequestMultiError, or
// nil if none found.
func (m *DetectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DetectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	if len(errors) > 0 {
		return DetectRequestMultiError(errors)
	}

	return nil
}

// DetectRequestMultiError is an error wrapping multiple validation errors
// returned by DetectRequest.ValidateAll() if the designated constraints
// aren't met.
type DetectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DetectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DetectRequestMultiError) AllErrors() []error { return m }

// DetectRequestValidationError is the validation error returned by
// DetectRequest.Validate if the designated constraints aren't met.
type DetectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DetectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DetectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DetectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DetectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DetectRequestValidationError) ErrorName() string { return "DetectRequestValidationError" }

// Error satisfies the builtin error interface
func (e DetectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDetectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DetectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DetectRequestValidationError{}

// Validate checks the field values on DetectReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DetectReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DetectReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DetectReplyMultiError, or
// nil if none found.
func (m *DetectReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DetectReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if len(errors) > 0 {
		return DetectReplyMultiError(errors)
	}

	return nil
}

// DetectReplyMultiError is an error wrapping multiple validation errors
// returned by DetectReply.ValidateAll() if the designated constraints aren't met.
type DetectReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DetectReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DetectReplyMultiError) AllErrors() []error { return m }

// DetectReplyValidationError is the validation error returned by
// DetectReply.Validate if the designated constraints aren't met.
type DetectReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DetectReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DetectReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DetectReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DetectReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DetectReplyValidationError) ErrorName() string { return "DetectReplyValidationError" }

// Error satisfies the builtin error interface
func (e DetectReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDetectReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DetectReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DetectReplyValidationError{}

```

`api/detect/service/v1/detect.proto`:

```proto
syntax = "proto3";

package bugu_detect.service.v1;

option go_package = "github.com/hominsu/bugu/api/detect/service/v1;v1";

service BuguDetect {
  rpc Detect (DetectRequest) returns (DetectReply) {};
};

message DetectRequest {
  repeated bytes data = 1;
  uint32 size = 2;
}

enum Type {
  TYPE_ADPOSHEL = 0;
  TYPE_AGENT = 1;
  TYPE_ALLAPLE = 2;
  TYPE_AMONETIZE = 3;
  TYPE_ANDROM = 4;
  TYPE_AUTORUN = 5;
  TYPE_BROWSE_FOX = 6;
  TYPE_DINWOD = 7;
  TYPE_ELEX = 8;
  TYPE_EXPIRO = 9;
  TYPE_FASONG = 10;
  TYPE_HACK_KMS = 11;
  TYPE_HLUX = 12;
  TYPE_INJECTOR = 13;
  TYPE_INSTALL_CORE = 14;
  TYPE_MULTI_Plug = 15;
  TYPE_NEOREKLAMI = 16;
  TYPE_NESHTA = 17;
  TYPE_OTHER = 18;
  TYPE_REGRUN = 19;
  TYPE_SALITY = 20;
  TYPE_SNARASITE = 21;
  TYPE_STABTINKO = 22;
  TYPE_VBA = 23;
  TYPE_VBKRYPT = 24;
  TYPE_VILSEL = 25;
}

message DetectReply {
  Type type = 1;
}
```

`api/detect/service/v1/detect.swagger.json`:

```json
{
  "swagger": "2.0",
  "info": {
    "title": "v1/detect.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "BuguDetect"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1DetectReply": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1Type"
        }
      }
    },
    "v1Type": {
      "type": "string",
      "enum": [
        "TYPE_ADPOSHEL",
        "TYPE_AGENT",
        "TYPE_ALLAPLE",
        "TYPE_AMONETIZE",
        "TYPE_ANDROM",
        "TYPE_AUTORUN",
        "TYPE_BROWSE_FOX",
        "TYPE_DINWOD",
        "TYPE_ELEX",
        "TYPE_EXPIRO",
        "TYPE_FASONG",
        "TYPE_HACK_KMS",
        "TYPE_HLUX",
        "TYPE_INJECTOR",
        "TYPE_INSTALL_CORE",
        "TYPE_MULTI_Plug",
        "TYPE_NEOREKLAMI",
        "TYPE_NESHTA",
        "TYPE_OTHER",
        "TYPE_REGRUN",
        "TYPE_SALITY",
        "TYPE_SNARASITE",
        "TYPE_STABTINKO",
        "TYPE_VBA",
        "TYPE_VBKRYPT",
        "TYPE_VILSEL"
      ],
      "default": "TYPE_ADPOSHEL"
    }
  }
}

```

`api/detect/service/v1/detect_grpc.pb.go`:

```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: v1/detect.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BuguDetectClient is the client API for BuguDetect service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuguDetectClient interface {
	Detect(ctx context.Context, in *DetectRequest, opts ...grpc.CallOption) (*DetectReply, error)
}

type buguDetectClient struct {
	cc grpc.ClientConnInterface
}

func NewBuguDetectClient(cc grpc.ClientConnInterface) BuguDetectClient {
	return &buguDetectClient{cc}
}

func (c *buguDetectClient) Detect(ctx context.Context, in *DetectRequest, opts ...grpc.CallOption) (*DetectReply, error) {
	out := new(DetectReply)
	err := c.cc.Invoke(ctx, "/bugu_detect.service.v1.BuguDetect/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuguDetectServer is the server API for BuguDetect service.
// All implementations must embed UnimplementedBuguDetectServer
// for forward compatibility
type BuguDetectServer interface {
	Detect(context.Context, *DetectRequest) (*DetectReply, error)
	mustEmbedUnimplementedBuguDetectServer()
}

// UnimplementedBuguDetectServer must be embedded to have forward compatible implementations.
type UnimplementedBuguDetectServer struct {
}

func (UnimplementedBuguDetectServer) Detect(context.Context, *DetectRequest) (*DetectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}
func (UnimplementedBuguDetectServer) mustEmbedUnimplementedBuguDetectServer() {}

// UnsafeBuguDetectServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuguDetectServer will
// result in compilation errors.
type UnsafeBuguDetectServer interface {
	mustEmbedUnimplementedBuguDetectServer()
}

func RegisterBuguDetectServer(s grpc.ServiceRegistrar, srv BuguDetectServer) {
	s.RegisterService(&BuguDetect_ServiceDesc, srv)
}

func _BuguDetect_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguDetectServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu_detect.service.v1.BuguDetect/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguDetectServer).Detect(ctx, req.(*DetectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BuguDetect_ServiceDesc is the grpc.ServiceDesc for BuguDetect service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BuguDetect_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bugu_detect.service.v1.BuguDetect",
	HandlerType: (*BuguDetectServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Detect",
			Handler:    _BuguDetect_Detect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/detect.proto",
}

```

`api/obfusion/service/v1/bugu_obfusion.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: v1/bugu_obfusion.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ObfusionRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data [][]byte `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	Size uint32   `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (x *ObfusionRequest) Reset() {
	*x = ObfusionRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_obfusion_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ObfusionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObfusionRequest) ProtoMessage() {}

func (x *ObfusionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_obfusion_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObfusionRequest.ProtoReflect.Descriptor instead.
func (*ObfusionRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_obfusion_proto_rawDescGZIP(), []int{0}
}

func (x *ObfusionRequest) GetData() [][]byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *ObfusionRequest) GetSize() uint32 {
	if x != nil {
		return x.Size
	}
	return 0
}

type ObfusionReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data [][]byte `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	Size uint32   `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (x *ObfusionReply) Reset() {
	*x = ObfusionReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_obfusion_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ObfusionReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObfusionReply) ProtoMessage() {}

func (x *ObfusionReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_obfusion_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObfusionReply.ProtoReflect.Descriptor instead.
func (*ObfusionReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_obfusion_proto_rawDescGZIP(), []int{1}
}

func (x *ObfusionReply) GetData() [][]byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *ObfusionReply) GetSize() uint32 {
	if x != nil {
		return x.Size
	}
	return 0
}

var File_v1_bugu_obfusion_proto protoreflect.FileDescriptor

var file_v1_bugu_obfusion_proto_rawDesc = []byte{
	0x0a, 0x16, 0x76, 0x31, 0x2f, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x6f, 0x62, 0x66, 0x75, 0x73, 0x69,
	0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x18, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x6f,
	0x62, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e,
	0x76, 0x31, 0x22, 0x39, 0x0a, 0x0f, 0x4f, 0x62, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x22, 0x37, 0x0a,
	0x0d, 0x4f, 0x62, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x12,
	0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61,
	0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x32, 0x70, 0x0a, 0x0c, 0x42, 0x75, 0x67, 0x75, 0x4f, 0x62,
	0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x60, 0x0a, 0x08, 0x4f, 0x62, 0x66, 0x75, 0x73, 0x69,
	0x6f, 0x6e, 0x12, 0x29, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x6f, 0x62, 0x66, 0x75, 0x73, 0x69,
	0x6f, 0x6e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62,
	0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x27, 0x2e,
	0x62, 0x75, 0x67, 0x75, 0x5f, 0x6f, 0x62, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x73, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x62, 0x66, 0x75, 0x73, 0x69, 0x6f,
	0x6e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x42, 0x34, 0x5a, 0x32, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x73, 0x75, 0x2f, 0x62,
	0x75, 0x67, 0x75, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x6f, 0x62, 0x66, 0x75, 0x73, 0x69, 0x6f, 0x6e,
	0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x76, 0x31, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_v1_bugu_obfusion_proto_rawDescOnce sync.Once
	file_v1_bugu_obfusion_proto_rawDescData = file_v1_bugu_obfusion_proto_rawDesc
)

func file_v1_bugu_obfusion_proto_rawDescGZIP() []byte {
	file_v1_bugu_obfusion_proto_rawDescOnce.Do(func() {
		file_v1_bugu_obfusion_proto_rawDescData = protoimpl.X.CompressGZIP(file_v1_bugu_obfusion_proto_rawDescData)
	})
	return file_v1_bugu_obfusion_proto_rawDescData
}

var file_v1_bugu_obfusion_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_v1_bugu_obfusion_proto_goTypes = []interface{}{
	(*ObfusionRequest)(nil), // 0: bugu_obfusion.service.v1.ObfusionRequest
	(*ObfusionReply)(nil),   // 1: bugu_obfusion.service.v1.ObfusionReply
}
var file_v1_bugu_obfusion_proto_depIdxs = []int32{
	0, // 0: bugu_obfusion.service.v1.BuguObfusion.Obfusion:input_type -> bugu_obfusion.service.v1.ObfusionRequest
	1, // 1: bugu_obfusion.service.v1.BuguObfusion.Obfusion:output_type -> bugu_obfusion.service.v1.ObfusionReply
	1, // [1:2] is the sub-list for method output_type
	0, // [0:1] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_v1_bugu_obfusion_proto_init() }
func file_v1_bugu_obfusion_proto_init() {
	if File_v1_bugu_obfusion_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_v1_bugu_obfusion_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ObfusionRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_obfusion_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ObfusionReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_v1_bugu_obfusion_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_bugu_obfusion_proto_goTypes,
		DependencyIndexes: file_v1_bugu_obfusion_proto_depIdxs,
		MessageInfos:      file_v1_bugu_obfusion_proto_msgTypes,
	}.Build()
	File_v1_bugu_obfusion_proto = out.File
	file_v1_bugu_obfusion_proto_rawDesc = nil
	file_v1_bugu_obfusion_proto_goTypes = nil
	file_v1_bugu_obfusion_proto_depIdxs = nil
}

```

`api/obfusion/service/v1/bugu_obfusion.pb.validate.go`:

```go
// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: v1/bugu_obfusion.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ObfusionRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ObfusionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObfusionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObfusionRequestMultiError, or nil if none found.
func (m *ObfusionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ObfusionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	if len(errors) > 0 {
		return ObfusionRequestMultiError(errors)
	}

	return nil
}

// ObfusionRequestMultiError is an error wrapping multiple validation errors
// returned by ObfusionRequest.ValidateAll() if the designated constraints
// aren't met.
type ObfusionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObfusionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObfusionRequestMultiError) AllErrors() []error { return m }

// ObfusionRequestValidationError is the validation error returned by
// ObfusionRequest.Validate if the designated constraints aren't met.
type ObfusionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObfusionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObfusionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObfusionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObfusionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObfusionRequestValidationError) ErrorName() string { return "ObfusionRequestValidationError" }

// Error satisfies the builtin error interface
func (e ObfusionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObfusionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObfusionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObfusionRequestValidationError{}

// Validate checks the field values on ObfusionReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ObfusionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObfusionReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ObfusionReplyMultiError, or
// nil if none found.
func (m *ObfusionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ObfusionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	if len(errors) > 0 {
		return ObfusionReplyMultiError(errors)
	}

	return nil
}

// ObfusionReplyMultiError is an error wrapping multiple validation errors
// returned by ObfusionReply.ValidateAll() if the designated constraints
// aren't met.
type ObfusionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObfusionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObfusionReplyMultiError) AllErrors() []error { return m }

// ObfusionReplyValidationError is the validation error returned by
// ObfusionReply.Validate if the designated constraints aren't met.
type ObfusionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObfusionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObfusionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObfusionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObfusionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObfusionReplyValidationError) ErrorName() string { return "ObfusionReplyValidationError" }

// Error satisfies the builtin error interface
func (e ObfusionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObfusionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObfusionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObfusionReplyValidationError{}

```

`api/obfusion/service/v1/bugu_obfusion.proto`:

```proto
syntax = "proto3";

package bugu_obfusion.service.v1;

option go_package = "github.com/hominsu/bugu/api/obfusion/service/v1;v1";

service BuguObfusion {
  rpc Obfusion (ObfusionRequest) returns (ObfusionReply) {};
};

message ObfusionRequest {
  repeated bytes data = 1;
  uint32 size = 2;
}

message ObfusionReply {
  repeated bytes data = 1;
  uint32 size = 2;
}
```

`api/obfusion/service/v1/bugu_obfusion.swagger.json`:

```json
{
  "swagger": "2.0",
  "info": {
    "title": "v1/bugu_obfusion.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "BuguObfusion"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1ObfusionReply": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "size": {
          "type": "integer",
          "format": "int64"
        }
      }
    }
  }
}

```

`api/obfusion/service/v1/bugu_obfusion_grpc.pb.go`:

```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: v1/bugu_obfusion.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BuguObfusionClient is the client API for BuguObfusion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuguObfusionClient interface {
	Obfusion(ctx context.Context, in *ObfusionRequest, opts ...grpc.CallOption) (*ObfusionReply, error)
}

type buguObfusionClient struct {
	cc grpc.ClientConnInterface
}

func NewBuguObfusionClient(cc grpc.ClientConnInterface) BuguObfusionClient {
	return &buguObfusionClient{cc}
}

func (c *buguObfusionClient) Obfusion(ctx context.Context, in *ObfusionRequest, opts ...grpc.CallOption) (*ObfusionReply, error) {
	out := new(ObfusionReply)
	err := c.cc.Invoke(ctx, "/bugu_obfusion.service.v1.BuguObfusion/Obfusion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuguObfusionServer is the server API for BuguObfusion service.
// All implementations must embed UnimplementedBuguObfusionServer
// for forward compatibility
type BuguObfusionServer interface {
	Obfusion(context.Context, *ObfusionRequest) (*ObfusionReply, error)
	mustEmbedUnimplementedBuguObfusionServer()
}

// UnimplementedBuguObfusionServer must be embedded to have forward compatible implementations.
type UnimplementedBuguObfusionServer struct {
}

func (UnimplementedBuguObfusionServer) Obfusion(context.Context, *ObfusionRequest) (*ObfusionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Obfusion not implemented")
}
func (UnimplementedBuguObfusionServer) mustEmbedUnimplementedBuguObfusionServer() {}

// UnsafeBuguObfusionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuguObfusionServer will
// result in compilation errors.
type UnsafeBuguObfusionServer interface {
	mustEmbedUnimplementedBuguObfusionServer()
}

func RegisterBuguObfusionServer(s grpc.ServiceRegistrar, srv BuguObfusionServer) {
	s.RegisterService(&BuguObfusion_ServiceDesc, srv)
}

func _BuguObfusion_Obfusion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObfusionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguObfusionServer).Obfusion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu_obfusion.service.v1.BuguObfusion/Obfusion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguObfusionServer).Obfusion(ctx, req.(*ObfusionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BuguObfusion_ServiceDesc is the grpc.ServiceDesc for BuguObfusion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BuguObfusion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bugu_obfusion.service.v1.BuguObfusion",
	HandlerType: (*BuguObfusionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Obfusion",
			Handler:    _BuguObfusion_Obfusion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/bugu_obfusion.proto",
}

```

`api/obfusion/service/v1/cpp/bugu_obfusion.grpc.pb.cc`:

```cc
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bugu_obfusion.proto

#include "bugu_obfusion.pb.h"
#include "bugu_obfusion.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace bugu_obfusion {
namespace service {
namespace v1 {

static const char* BuguObfusion_method_names[] = {
  "/bugu_obfusion.service.v1.BuguObfusion/Obfusion",
};

std::unique_ptr< BuguObfusion::Stub> BuguObfusion::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< BuguObfusion::Stub> stub(new BuguObfusion::Stub(channel, options));
  return stub;
}

BuguObfusion::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Obfusion_(BuguObfusion_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status BuguObfusion::Stub::Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::bugu_obfusion::service::v1::ObfusionReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu_obfusion::service::v1::ObfusionRequest, ::bugu_obfusion::service::v1::ObfusionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Obfusion_, context, request, response);
}

void BuguObfusion::Stub::async::Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu_obfusion::service::v1::ObfusionRequest, ::bugu_obfusion::service::v1::ObfusionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Obfusion_, context, request, response, std::move(f));
}

void BuguObfusion::Stub::async::Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Obfusion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu_obfusion::service::v1::ObfusionReply>* BuguObfusion::Stub::PrepareAsyncObfusionRaw(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu_obfusion::service::v1::ObfusionReply, ::bugu_obfusion::service::v1::ObfusionRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Obfusion_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu_obfusion::service::v1::ObfusionReply>* BuguObfusion::Stub::AsyncObfusionRaw(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncObfusionRaw(context, request, cq);
  result->StartCall();
  return result;
}

BuguObfusion::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      BuguObfusion_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< BuguObfusion::Service, ::bugu_obfusion::service::v1::ObfusionRequest, ::bugu_obfusion::service::v1::ObfusionReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](BuguObfusion::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu_obfusion::service::v1::ObfusionRequest* req,
             ::bugu_obfusion::service::v1::ObfusionReply* resp) {
               return service->Obfusion(ctx, req, resp);
             }, this)));
}

BuguObfusion::Service::~Service() {
}

::grpc::Status BuguObfusion::Service::Obfusion(::grpc::ServerContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace bugu_obfusion
}  // namespace service
}  // namespace v1


```

`api/obfusion/service/v1/cpp/bugu_obfusion.grpc.pb.h`:

```h
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bugu_obfusion.proto
#ifndef GRPC_bugu_5fobfusion_2eproto__INCLUDED
#define GRPC_bugu_5fobfusion_2eproto__INCLUDED

#include "bugu_obfusion.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace bugu_obfusion {
namespace service {
namespace v1 {

class BuguObfusion final {
 public:
  static constexpr char const* service_full_name() {
    return "bugu_obfusion.service.v1.BuguObfusion";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::bugu_obfusion::service::v1::ObfusionReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_obfusion::service::v1::ObfusionReply>> AsyncObfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_obfusion::service::v1::ObfusionReply>>(AsyncObfusionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_obfusion::service::v1::ObfusionReply>> PrepareAsyncObfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_obfusion::service::v1::ObfusionReply>>(PrepareAsyncObfusionRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu_obfusion::service::v1::ObfusionReply>* AsyncObfusionRaw(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu_obfusion::service::v1::ObfusionReply>* PrepareAsyncObfusionRaw(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::bugu_obfusion::service::v1::ObfusionReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_obfusion::service::v1::ObfusionReply>> AsyncObfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_obfusion::service::v1::ObfusionReply>>(AsyncObfusionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_obfusion::service::v1::ObfusionReply>> PrepareAsyncObfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_obfusion::service::v1::ObfusionReply>>(PrepareAsyncObfusionRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response, std::function<void(::grpc::Status)>) override;
      void Obfusion(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bugu_obfusion::service::v1::ObfusionReply>* AsyncObfusionRaw(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu_obfusion::service::v1::ObfusionReply>* PrepareAsyncObfusionRaw(::grpc::ClientContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Obfusion_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Obfusion(::grpc::ServerContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Obfusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Obfusion() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Obfusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Obfusion(::grpc::ServerContext* /*context*/, const ::bugu_obfusion::service::v1::ObfusionRequest* /*request*/, ::bugu_obfusion::service::v1::ObfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObfusion(::grpc::ServerContext* context, ::bugu_obfusion::service::v1::ObfusionRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu_obfusion::service::v1::ObfusionReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Obfusion<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Obfusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Obfusion() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu_obfusion::service::v1::ObfusionRequest, ::bugu_obfusion::service::v1::ObfusionReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu_obfusion::service::v1::ObfusionRequest* request, ::bugu_obfusion::service::v1::ObfusionReply* response) { return this->Obfusion(context, request, response); }));}
    void SetMessageAllocatorFor_Obfusion(
        ::grpc::MessageAllocator< ::bugu_obfusion::service::v1::ObfusionRequest, ::bugu_obfusion::service::v1::ObfusionReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu_obfusion::service::v1::ObfusionRequest, ::bugu_obfusion::service::v1::ObfusionReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Obfusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Obfusion(::grpc::ServerContext* /*context*/, const ::bugu_obfusion::service::v1::ObfusionRequest* /*request*/, ::bugu_obfusion::service::v1::ObfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Obfusion(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu_obfusion::service::v1::ObfusionRequest* /*request*/, ::bugu_obfusion::service::v1::ObfusionReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Obfusion<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Obfusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Obfusion() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Obfusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Obfusion(::grpc::ServerContext* /*context*/, const ::bugu_obfusion::service::v1::ObfusionRequest* /*request*/, ::bugu_obfusion::service::v1::ObfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Obfusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Obfusion() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Obfusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Obfusion(::grpc::ServerContext* /*context*/, const ::bugu_obfusion::service::v1::ObfusionRequest* /*request*/, ::bugu_obfusion::service::v1::ObfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObfusion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Obfusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Obfusion() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Obfusion(context, request, response); }));
    }
    ~WithRawCallbackMethod_Obfusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Obfusion(::grpc::ServerContext* /*context*/, const ::bugu_obfusion::service::v1::ObfusionRequest* /*request*/, ::bugu_obfusion::service::v1::ObfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Obfusion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Obfusion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Obfusion() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu_obfusion::service::v1::ObfusionRequest, ::bugu_obfusion::service::v1::ObfusionReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu_obfusion::service::v1::ObfusionRequest, ::bugu_obfusion::service::v1::ObfusionReply>* streamer) {
                       return this->StreamedObfusion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Obfusion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Obfusion(::grpc::ServerContext* /*context*/, const ::bugu_obfusion::service::v1::ObfusionRequest* /*request*/, ::bugu_obfusion::service::v1::ObfusionReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedObfusion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu_obfusion::service::v1::ObfusionRequest,::bugu_obfusion::service::v1::ObfusionReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Obfusion<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Obfusion<Service > StreamedService;
};

}  // namespace v1
}  // namespace service
}  // namespace bugu_obfusion


#endif  // GRPC_bugu_5fobfusion_2eproto__INCLUDED

```

`api/obfusion/service/v1/cpp/bugu_obfusion.pb.cc`:

```cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bugu_obfusion.proto

#include "bugu_obfusion.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace bugu_obfusion {
namespace service {
namespace v1 {
constexpr ObfusionRequest::ObfusionRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_()
  , size_(0u){}
struct ObfusionRequestDefaultTypeInternal {
  constexpr ObfusionRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObfusionRequestDefaultTypeInternal() {}
  union {
    ObfusionRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObfusionRequestDefaultTypeInternal _ObfusionRequest_default_instance_;
constexpr ObfusionReply::ObfusionReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_()
  , size_(0u){}
struct ObfusionReplyDefaultTypeInternal {
  constexpr ObfusionReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ObfusionReplyDefaultTypeInternal() {}
  union {
    ObfusionReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ObfusionReplyDefaultTypeInternal _ObfusionReply_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu_obfusion
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_bugu_5fobfusion_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_bugu_5fobfusion_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_bugu_5fobfusion_2eproto = nullptr;

const uint32_t TableStruct_bugu_5fobfusion_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu_obfusion::service::v1::ObfusionRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu_obfusion::service::v1::ObfusionRequest, data_),
  PROTOBUF_FIELD_OFFSET(::bugu_obfusion::service::v1::ObfusionRequest, size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu_obfusion::service::v1::ObfusionReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu_obfusion::service::v1::ObfusionReply, data_),
  PROTOBUF_FIELD_OFFSET(::bugu_obfusion::service::v1::ObfusionReply, size_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::bugu_obfusion::service::v1::ObfusionRequest)},
  { 8, -1, -1, sizeof(::bugu_obfusion::service::v1::ObfusionReply)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu_obfusion::service::v1::_ObfusionRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu_obfusion::service::v1::_ObfusionReply_default_instance_),
};

const char descriptor_table_protodef_bugu_5fobfusion_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023bugu_obfusion.proto\022\030bugu_obfusion.ser"
  "vice.v1\"-\n\017ObfusionRequest\022\014\n\004data\030\001 \003(\014"
  "\022\014\n\004size\030\002 \001(\r\"+\n\rObfusionReply\022\014\n\004data\030"
  "\001 \003(\014\022\014\n\004size\030\002 \001(\r2p\n\014BuguObfusion\022`\n\010O"
  "bfusion\022).bugu_obfusion.service.v1.Obfus"
  "ionRequest\032\'.bugu_obfusion.service.v1.Ob"
  "fusionReply\"\000B4Z2github.com/hominsu/bugu"
  "/api/obfusion/service/v1;v1b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_bugu_5fobfusion_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bugu_5fobfusion_2eproto = {
  false, false, 315, descriptor_table_protodef_bugu_5fobfusion_2eproto, "bugu_obfusion.proto", 
  &descriptor_table_bugu_5fobfusion_2eproto_once, nullptr, 0, 2,
  schemas, file_default_instances, TableStruct_bugu_5fobfusion_2eproto::offsets,
  file_level_metadata_bugu_5fobfusion_2eproto, file_level_enum_descriptors_bugu_5fobfusion_2eproto, file_level_service_descriptors_bugu_5fobfusion_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_bugu_5fobfusion_2eproto_getter() {
  return &descriptor_table_bugu_5fobfusion_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_bugu_5fobfusion_2eproto(&descriptor_table_bugu_5fobfusion_2eproto);
namespace bugu_obfusion {
namespace service {
namespace v1 {

// ===================================================================

class ObfusionRequest::_Internal {
 public:
};

ObfusionRequest::ObfusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu_obfusion.service.v1.ObfusionRequest)
}
ObfusionRequest::ObfusionRequest(const ObfusionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:bugu_obfusion.service.v1.ObfusionRequest)
}

inline void ObfusionRequest::SharedCtor() {
size_ = 0u;
}

ObfusionRequest::~ObfusionRequest() {
  // @@protoc_insertion_point(destructor:bugu_obfusion.service.v1.ObfusionRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObfusionRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ObfusionRequest::ArenaDtor(void* object) {
  ObfusionRequest* _this = reinterpret_cast< ObfusionRequest* >(object);
  (void)_this;
}
void ObfusionRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObfusionRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObfusionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu_obfusion.service.v1.ObfusionRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  size_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObfusionRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_data();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObfusionRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu_obfusion.service.v1.ObfusionRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes data = 1;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    const auto& s = this->_internal_data(i);
    target = stream->WriteBytes(1, s, target);
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu_obfusion.service.v1.ObfusionRequest)
  return target;
}

size_t ObfusionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu_obfusion.service.v1.ObfusionRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes data = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(data_.size());
  for (int i = 0, n = data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      data_.Get(i));
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObfusionRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObfusionRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObfusionRequest::GetClassData() const { return &_class_data_; }

void ObfusionRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObfusionRequest *>(to)->MergeFrom(
      static_cast<const ObfusionRequest &>(from));
}


void ObfusionRequest::MergeFrom(const ObfusionRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu_obfusion.service.v1.ObfusionRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from._internal_size() != 0) {
    _internal_set_size(from._internal_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObfusionRequest::CopyFrom(const ObfusionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu_obfusion.service.v1.ObfusionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObfusionRequest::IsInitialized() const {
  return true;
}

void ObfusionRequest::InternalSwap(ObfusionRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObfusionRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_5fobfusion_2eproto_getter, &descriptor_table_bugu_5fobfusion_2eproto_once,
      file_level_metadata_bugu_5fobfusion_2eproto[0]);
}

// ===================================================================

class ObfusionReply::_Internal {
 public:
};

ObfusionReply::ObfusionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu_obfusion.service.v1.ObfusionReply)
}
ObfusionReply::ObfusionReply(const ObfusionReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:bugu_obfusion.service.v1.ObfusionReply)
}

inline void ObfusionReply::SharedCtor() {
size_ = 0u;
}

ObfusionReply::~ObfusionReply() {
  // @@protoc_insertion_point(destructor:bugu_obfusion.service.v1.ObfusionReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ObfusionReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ObfusionReply::ArenaDtor(void* object) {
  ObfusionReply* _this = reinterpret_cast< ObfusionReply* >(object);
  (void)_this;
}
void ObfusionReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ObfusionReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ObfusionReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu_obfusion.service.v1.ObfusionReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  size_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObfusionReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_data();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObfusionReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu_obfusion.service.v1.ObfusionReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes data = 1;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    const auto& s = this->_internal_data(i);
    target = stream->WriteBytes(1, s, target);
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu_obfusion.service.v1.ObfusionReply)
  return target;
}

size_t ObfusionReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu_obfusion.service.v1.ObfusionReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes data = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(data_.size());
  for (int i = 0, n = data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      data_.Get(i));
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObfusionReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ObfusionReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObfusionReply::GetClassData() const { return &_class_data_; }

void ObfusionReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ObfusionReply *>(to)->MergeFrom(
      static_cast<const ObfusionReply &>(from));
}


void ObfusionReply::MergeFrom(const ObfusionReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu_obfusion.service.v1.ObfusionReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from._internal_size() != 0) {
    _internal_set_size(from._internal_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObfusionReply::CopyFrom(const ObfusionReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu_obfusion.service.v1.ObfusionReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObfusionReply::IsInitialized() const {
  return true;
}

void ObfusionReply::InternalSwap(ObfusionReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ObfusionReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_5fobfusion_2eproto_getter, &descriptor_table_bugu_5fobfusion_2eproto_once,
      file_level_metadata_bugu_5fobfusion_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace service
}  // namespace bugu_obfusion
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::bugu_obfusion::service::v1::ObfusionRequest* Arena::CreateMaybeMessage< ::bugu_obfusion::service::v1::ObfusionRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu_obfusion::service::v1::ObfusionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu_obfusion::service::v1::ObfusionReply* Arena::CreateMaybeMessage< ::bugu_obfusion::service::v1::ObfusionReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu_obfusion::service::v1::ObfusionReply >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

```

`api/obfusion/service/v1/cpp/bugu_obfusion.pb.h`:

```h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bugu_obfusion.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bugu_5fobfusion_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bugu_5fobfusion_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bugu_5fobfusion_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bugu_5fobfusion_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bugu_5fobfusion_2eproto;
namespace bugu_obfusion {
namespace service {
namespace v1 {
class ObfusionReply;
struct ObfusionReplyDefaultTypeInternal;
extern ObfusionReplyDefaultTypeInternal _ObfusionReply_default_instance_;
class ObfusionRequest;
struct ObfusionRequestDefaultTypeInternal;
extern ObfusionRequestDefaultTypeInternal _ObfusionRequest_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu_obfusion
PROTOBUF_NAMESPACE_OPEN
template<> ::bugu_obfusion::service::v1::ObfusionReply* Arena::CreateMaybeMessage<::bugu_obfusion::service::v1::ObfusionReply>(Arena*);
template<> ::bugu_obfusion::service::v1::ObfusionRequest* Arena::CreateMaybeMessage<::bugu_obfusion::service::v1::ObfusionRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bugu_obfusion {
namespace service {
namespace v1 {

// ===================================================================

class ObfusionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu_obfusion.service.v1.ObfusionRequest) */ {
 public:
  inline ObfusionRequest() : ObfusionRequest(nullptr) {}
  ~ObfusionRequest() override;
  explicit constexpr ObfusionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObfusionRequest(const ObfusionRequest& from);
  ObfusionRequest(ObfusionRequest&& from) noexcept
    : ObfusionRequest() {
    *this = ::std::move(from);
  }

  inline ObfusionRequest& operator=(const ObfusionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObfusionRequest& operator=(ObfusionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObfusionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObfusionRequest* internal_default_instance() {
    return reinterpret_cast<const ObfusionRequest*>(
               &_ObfusionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ObfusionRequest& a, ObfusionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ObfusionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObfusionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObfusionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObfusionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObfusionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObfusionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObfusionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu_obfusion.service.v1.ObfusionRequest";
  }
  protected:
  explicit ObfusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated bytes data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // uint32 size = 2;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bugu_obfusion.service.v1.ObfusionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
  uint32_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_5fobfusion_2eproto;
};
// -------------------------------------------------------------------

class ObfusionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu_obfusion.service.v1.ObfusionReply) */ {
 public:
  inline ObfusionReply() : ObfusionReply(nullptr) {}
  ~ObfusionReply() override;
  explicit constexpr ObfusionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObfusionReply(const ObfusionReply& from);
  ObfusionReply(ObfusionReply&& from) noexcept
    : ObfusionReply() {
    *this = ::std::move(from);
  }

  inline ObfusionReply& operator=(const ObfusionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObfusionReply& operator=(ObfusionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObfusionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObfusionReply* internal_default_instance() {
    return reinterpret_cast<const ObfusionReply*>(
               &_ObfusionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ObfusionReply& a, ObfusionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ObfusionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObfusionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObfusionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObfusionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObfusionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ObfusionReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObfusionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu_obfusion.service.v1.ObfusionReply";
  }
  protected:
  explicit ObfusionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated bytes data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // uint32 size = 2;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bugu_obfusion.service.v1.ObfusionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
  uint32_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_5fobfusion_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObfusionRequest

// repeated bytes data = 1;
inline int ObfusionRequest::_internal_data_size() const {
  return data_.size();
}
inline int ObfusionRequest::data_size() const {
  return _internal_data_size();
}
inline void ObfusionRequest::clear_data() {
  data_.Clear();
}
inline std::string* ObfusionRequest::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:bugu_obfusion.service.v1.ObfusionRequest.data)
  return _s;
}
inline const std::string& ObfusionRequest::_internal_data(int index) const {
  return data_.Get(index);
}
inline const std::string& ObfusionRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:bugu_obfusion.service.v1.ObfusionRequest.data)
  return _internal_data(index);
}
inline std::string* ObfusionRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:bugu_obfusion.service.v1.ObfusionRequest.data)
  return data_.Mutable(index);
}
inline void ObfusionRequest::set_data(int index, const std::string& value) {
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bugu_obfusion.service.v1.ObfusionRequest.data)
}
inline void ObfusionRequest::set_data(int index, std::string&& value) {
  data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bugu_obfusion.service.v1.ObfusionRequest.data)
}
inline void ObfusionRequest::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bugu_obfusion.service.v1.ObfusionRequest.data)
}
inline void ObfusionRequest::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bugu_obfusion.service.v1.ObfusionRequest.data)
}
inline std::string* ObfusionRequest::_internal_add_data() {
  return data_.Add();
}
inline void ObfusionRequest::add_data(const std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bugu_obfusion.service.v1.ObfusionRequest.data)
}
inline void ObfusionRequest::add_data(std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bugu_obfusion.service.v1.ObfusionRequest.data)
}
inline void ObfusionRequest::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bugu_obfusion.service.v1.ObfusionRequest.data)
}
inline void ObfusionRequest::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bugu_obfusion.service.v1.ObfusionRequest.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObfusionRequest::data() const {
  // @@protoc_insertion_point(field_list:bugu_obfusion.service.v1.ObfusionRequest.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObfusionRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:bugu_obfusion.service.v1.ObfusionRequest.data)
  return &data_;
}

// uint32 size = 2;
inline void ObfusionRequest::clear_size() {
  size_ = 0u;
}
inline uint32_t ObfusionRequest::_internal_size() const {
  return size_;
}
inline uint32_t ObfusionRequest::size() const {
  // @@protoc_insertion_point(field_get:bugu_obfusion.service.v1.ObfusionRequest.size)
  return _internal_size();
}
inline void ObfusionRequest::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void ObfusionRequest::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:bugu_obfusion.service.v1.ObfusionRequest.size)
}

// -------------------------------------------------------------------

// ObfusionReply

// repeated bytes data = 1;
inline int ObfusionReply::_internal_data_size() const {
  return data_.size();
}
inline int ObfusionReply::data_size() const {
  return _internal_data_size();
}
inline void ObfusionReply::clear_data() {
  data_.Clear();
}
inline std::string* ObfusionReply::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:bugu_obfusion.service.v1.ObfusionReply.data)
  return _s;
}
inline const std::string& ObfusionReply::_internal_data(int index) const {
  return data_.Get(index);
}
inline const std::string& ObfusionReply::data(int index) const {
  // @@protoc_insertion_point(field_get:bugu_obfusion.service.v1.ObfusionReply.data)
  return _internal_data(index);
}
inline std::string* ObfusionReply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:bugu_obfusion.service.v1.ObfusionReply.data)
  return data_.Mutable(index);
}
inline void ObfusionReply::set_data(int index, const std::string& value) {
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bugu_obfusion.service.v1.ObfusionReply.data)
}
inline void ObfusionReply::set_data(int index, std::string&& value) {
  data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bugu_obfusion.service.v1.ObfusionReply.data)
}
inline void ObfusionReply::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bugu_obfusion.service.v1.ObfusionReply.data)
}
inline void ObfusionReply::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bugu_obfusion.service.v1.ObfusionReply.data)
}
inline std::string* ObfusionReply::_internal_add_data() {
  return data_.Add();
}
inline void ObfusionReply::add_data(const std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bugu_obfusion.service.v1.ObfusionReply.data)
}
inline void ObfusionReply::add_data(std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bugu_obfusion.service.v1.ObfusionReply.data)
}
inline void ObfusionReply::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bugu_obfusion.service.v1.ObfusionReply.data)
}
inline void ObfusionReply::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bugu_obfusion.service.v1.ObfusionReply.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObfusionReply::data() const {
  // @@protoc_insertion_point(field_list:bugu_obfusion.service.v1.ObfusionReply.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObfusionReply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:bugu_obfusion.service.v1.ObfusionReply.data)
  return &data_;
}

// uint32 size = 2;
inline void ObfusionReply::clear_size() {
  size_ = 0u;
}
inline uint32_t ObfusionReply::_internal_size() const {
  return size_;
}
inline uint32_t ObfusionReply::size() const {
  // @@protoc_insertion_point(field_get:bugu_obfusion.service.v1.ObfusionReply.size)
  return _internal_size();
}
inline void ObfusionReply::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void ObfusionReply::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:bugu_obfusion.service.v1.ObfusionReply.size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace service
}  // namespace bugu_obfusion

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bugu_5fobfusion_2eproto

```

`api/packer/service/v1/bugu_packer.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: v1/bugu_packer.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PackerRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data [][]byte `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	Size uint32   `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (x *PackerRequest) Reset() {
	*x = PackerRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_packer_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PackerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackerRequest) ProtoMessage() {}

func (x *PackerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_packer_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackerRequest.ProtoReflect.Descriptor instead.
func (*PackerRequest) Descriptor() ([]byte, []int) {
	return file_v1_bugu_packer_proto_rawDescGZIP(), []int{0}
}

func (x *PackerRequest) GetData() [][]byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *PackerRequest) GetSize() uint32 {
	if x != nil {
		return x.Size
	}
	return 0
}

type PackerReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data [][]byte `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	Size uint32   `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (x *PackerReply) Reset() {
	*x = PackerReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_v1_bugu_packer_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PackerReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackerReply) ProtoMessage() {}

func (x *PackerReply) ProtoReflect() protoreflect.Message {
	mi := &file_v1_bugu_packer_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackerReply.ProtoReflect.Descriptor instead.
func (*PackerReply) Descriptor() ([]byte, []int) {
	return file_v1_bugu_packer_proto_rawDescGZIP(), []int{1}
}

func (x *PackerReply) GetData() [][]byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *PackerReply) GetSize() uint32 {
	if x != nil {
		return x.Size
	}
	return 0
}

var File_v1_bugu_packer_proto protoreflect.FileDescriptor

var file_v1_bugu_packer_proto_rawDesc = []byte{
	0x0a, 0x14, 0x76, 0x31, 0x2f, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x72,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x70, 0x61, 0x63,
	0x6b, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x22, 0x37,
	0x0a, 0x0d, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x04, 0x64,
	0x61, 0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x22, 0x35, 0x0a, 0x0b, 0x50, 0x61, 0x63, 0x6b, 0x65,
	0x72, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69,
	0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x32, 0x64,
	0x0a, 0x0a, 0x42, 0x75, 0x67, 0x75, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x12, 0x56, 0x0a, 0x06,
	0x50, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x12, 0x25, 0x2e, 0x62, 0x75, 0x67, 0x75, 0x5f, 0x70, 0x61,
	0x63, 0x6b, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e,
	0x50, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e,
	0x62, 0x75, 0x67, 0x75, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x2e, 0x73, 0x65, 0x72, 0x76,
	0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x52, 0x65, 0x70,
	0x6c, 0x79, 0x22, 0x00, 0x42, 0x32, 0x5a, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x73, 0x75, 0x2f, 0x62, 0x75, 0x67, 0x75, 0x2f,
	0x61, 0x70, 0x69, 0x2f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x2f, 0x76, 0x31, 0x3b, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_v1_bugu_packer_proto_rawDescOnce sync.Once
	file_v1_bugu_packer_proto_rawDescData = file_v1_bugu_packer_proto_rawDesc
)

func file_v1_bugu_packer_proto_rawDescGZIP() []byte {
	file_v1_bugu_packer_proto_rawDescOnce.Do(func() {
		file_v1_bugu_packer_proto_rawDescData = protoimpl.X.CompressGZIP(file_v1_bugu_packer_proto_rawDescData)
	})
	return file_v1_bugu_packer_proto_rawDescData
}

var file_v1_bugu_packer_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_v1_bugu_packer_proto_goTypes = []interface{}{
	(*PackerRequest)(nil), // 0: bugu_packer.service.v1.PackerRequest
	(*PackerReply)(nil),   // 1: bugu_packer.service.v1.PackerReply
}
var file_v1_bugu_packer_proto_depIdxs = []int32{
	0, // 0: bugu_packer.service.v1.BuguPacker.Packer:input_type -> bugu_packer.service.v1.PackerRequest
	1, // 1: bugu_packer.service.v1.BuguPacker.Packer:output_type -> bugu_packer.service.v1.PackerReply
	1, // [1:2] is the sub-list for method output_type
	0, // [0:1] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_v1_bugu_packer_proto_init() }
func file_v1_bugu_packer_proto_init() {
	if File_v1_bugu_packer_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_v1_bugu_packer_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PackerRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_v1_bugu_packer_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PackerReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_v1_bugu_packer_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_bugu_packer_proto_goTypes,
		DependencyIndexes: file_v1_bugu_packer_proto_depIdxs,
		MessageInfos:      file_v1_bugu_packer_proto_msgTypes,
	}.Build()
	File_v1_bugu_packer_proto = out.File
	file_v1_bugu_packer_proto_rawDesc = nil
	file_v1_bugu_packer_proto_goTypes = nil
	file_v1_bugu_packer_proto_depIdxs = nil
}

```

`api/packer/service/v1/bugu_packer.pb.validate.go`:

```go
// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: v1/bugu_packer.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PackerRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PackerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PackerRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PackerRequestMultiError, or
// nil if none found.
func (m *PackerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PackerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	if len(errors) > 0 {
		return PackerRequestMultiError(errors)
	}

	return nil
}

// PackerRequestMultiError is an error wrapping multiple validation errors
// returned by PackerRequest.ValidateAll() if the designated constraints
// aren't met.
type PackerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PackerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PackerRequestMultiError) AllErrors() []error { return m }

// PackerRequestValidationError is the validation error returned by
// PackerRequest.Validate if the designated constraints aren't met.
type PackerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PackerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PackerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PackerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PackerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PackerRequestValidationError) ErrorName() string { return "PackerRequestValidationError" }

// Error satisfies the builtin error interface
func (e PackerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPackerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PackerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PackerRequestValidationError{}

// Validate checks the field values on PackerReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PackerReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PackerReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PackerReplyMultiError, or
// nil if none found.
func (m *PackerReply) ValidateAll() error {
	return m.validate(true)
}

func (m *PackerReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	if len(errors) > 0 {
		return PackerReplyMultiError(errors)
	}

	return nil
}

// PackerReplyMultiError is an error wrapping multiple validation errors
// returned by PackerReply.ValidateAll() if the designated constraints aren't met.
type PackerReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PackerReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PackerReplyMultiError) AllErrors() []error { return m }

// PackerReplyValidationError is the validation error returned by
// PackerReply.Validate if the designated constraints aren't met.
type PackerReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PackerReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PackerReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PackerReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PackerReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PackerReplyValidationError) ErrorName() string { return "PackerReplyValidationError" }

// Error satisfies the builtin error interface
func (e PackerReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPackerReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PackerReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PackerReplyValidationError{}

```

`api/packer/service/v1/bugu_packer.proto`:

```proto
syntax = "proto3";

package bugu_packer.service.v1;

option go_package = "github.com/hominsu/bugu/api/packer/service/v1;v1";

service BuguPacker {
  rpc Packer (PackerRequest) returns (PackerReply) {};
};

message PackerRequest {
  repeated bytes data = 1;
  uint32 size = 2;
}

message PackerReply {
  repeated bytes data = 1;
  uint32 size = 2;
}
```

`api/packer/service/v1/bugu_packer.swagger.json`:

```json
{
  "swagger": "2.0",
  "info": {
    "title": "v1/bugu_packer.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "BuguPacker"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1PackerReply": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        },
        "size": {
          "type": "integer",
          "format": "int64"
        }
      }
    }
  }
}

```

`api/packer/service/v1/bugu_packer_grpc.pb.go`:

```go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: v1/bugu_packer.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BuguPackerClient is the client API for BuguPacker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuguPackerClient interface {
	Packer(ctx context.Context, in *PackerRequest, opts ...grpc.CallOption) (*PackerReply, error)
}

type buguPackerClient struct {
	cc grpc.ClientConnInterface
}

func NewBuguPackerClient(cc grpc.ClientConnInterface) BuguPackerClient {
	return &buguPackerClient{cc}
}

func (c *buguPackerClient) Packer(ctx context.Context, in *PackerRequest, opts ...grpc.CallOption) (*PackerReply, error) {
	out := new(PackerReply)
	err := c.cc.Invoke(ctx, "/bugu_packer.service.v1.BuguPacker/Packer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuguPackerServer is the server API for BuguPacker service.
// All implementations must embed UnimplementedBuguPackerServer
// for forward compatibility
type BuguPackerServer interface {
	Packer(context.Context, *PackerRequest) (*PackerReply, error)
	mustEmbedUnimplementedBuguPackerServer()
}

// UnimplementedBuguPackerServer must be embedded to have forward compatible implementations.
type UnimplementedBuguPackerServer struct {
}

func (UnimplementedBuguPackerServer) Packer(context.Context, *PackerRequest) (*PackerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Packer not implemented")
}
func (UnimplementedBuguPackerServer) mustEmbedUnimplementedBuguPackerServer() {}

// UnsafeBuguPackerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuguPackerServer will
// result in compilation errors.
type UnsafeBuguPackerServer interface {
	mustEmbedUnimplementedBuguPackerServer()
}

func RegisterBuguPackerServer(s grpc.ServiceRegistrar, srv BuguPackerServer) {
	s.RegisterService(&BuguPacker_ServiceDesc, srv)
}

func _BuguPacker_Packer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuguPackerServer).Packer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bugu_packer.service.v1.BuguPacker/Packer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuguPackerServer).Packer(ctx, req.(*PackerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BuguPacker_ServiceDesc is the grpc.ServiceDesc for BuguPacker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BuguPacker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bugu_packer.service.v1.BuguPacker",
	HandlerType: (*BuguPackerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Packer",
			Handler:    _BuguPacker_Packer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/bugu_packer.proto",
}

```

`api/packer/service/v1/cpp/bugu_packer.grpc.pb.cc`:

```cc
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bugu_packer.proto

#include "bugu_packer.pb.h"
#include "bugu_packer.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace bugu_packer {
namespace service {
namespace v1 {

static const char* BuguPacker_method_names[] = {
  "/bugu_packer.service.v1.BuguPacker/Packer",
};

std::unique_ptr< BuguPacker::Stub> BuguPacker::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< BuguPacker::Stub> stub(new BuguPacker::Stub(channel, options));
  return stub;
}

BuguPacker::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Packer_(BuguPacker_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status BuguPacker::Stub::Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::bugu_packer::service::v1::PackerReply* response) {
  return ::grpc::internal::BlockingUnaryCall< ::bugu_packer::service::v1::PackerRequest, ::bugu_packer::service::v1::PackerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Packer_, context, request, response);
}

void BuguPacker::Stub::async::Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::bugu_packer::service::v1::PackerRequest, ::bugu_packer::service::v1::PackerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Packer_, context, request, response, std::move(f));
}

void BuguPacker::Stub::async::Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Packer_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::bugu_packer::service::v1::PackerReply>* BuguPacker::Stub::PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::bugu_packer::service::v1::PackerReply, ::bugu_packer::service::v1::PackerRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Packer_, context, request);
}

::grpc::ClientAsyncResponseReader< ::bugu_packer::service::v1::PackerReply>* BuguPacker::Stub::AsyncPackerRaw(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPackerRaw(context, request, cq);
  result->StartCall();
  return result;
}

BuguPacker::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      BuguPacker_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< BuguPacker::Service, ::bugu_packer::service::v1::PackerRequest, ::bugu_packer::service::v1::PackerReply, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](BuguPacker::Service* service,
             ::grpc::ServerContext* ctx,
             const ::bugu_packer::service::v1::PackerRequest* req,
             ::bugu_packer::service::v1::PackerReply* resp) {
               return service->Packer(ctx, req, resp);
             }, this)));
}

BuguPacker::Service::~Service() {
}

::grpc::Status BuguPacker::Service::Packer(::grpc::ServerContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace bugu_packer
}  // namespace service
}  // namespace v1


```

`api/packer/service/v1/cpp/bugu_packer.grpc.pb.h`:

```h
// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bugu_packer.proto
#ifndef GRPC_bugu_5fpacker_2eproto__INCLUDED
#define GRPC_bugu_5fpacker_2eproto__INCLUDED

#include "bugu_packer.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace bugu_packer {
namespace service {
namespace v1 {

class BuguPacker final {
 public:
  static constexpr char const* service_full_name() {
    return "bugu_packer.service.v1.BuguPacker";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::bugu_packer::service::v1::PackerReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_packer::service::v1::PackerReply>> AsyncPacker(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_packer::service::v1::PackerReply>>(AsyncPackerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_packer::service::v1::PackerReply>> PrepareAsyncPacker(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bugu_packer::service::v1::PackerReply>>(PrepareAsyncPackerRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu_packer::service::v1::PackerReply>* AsyncPackerRaw(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bugu_packer::service::v1::PackerReply>* PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::bugu_packer::service::v1::PackerReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_packer::service::v1::PackerReply>> AsyncPacker(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_packer::service::v1::PackerReply>>(AsyncPackerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_packer::service::v1::PackerReply>> PrepareAsyncPacker(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bugu_packer::service::v1::PackerReply>>(PrepareAsyncPackerRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response, std::function<void(::grpc::Status)>) override;
      void Packer(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bugu_packer::service::v1::PackerReply>* AsyncPackerRaw(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bugu_packer::service::v1::PackerReply>* PrepareAsyncPackerRaw(::grpc::ClientContext* context, const ::bugu_packer::service::v1::PackerRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Packer_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Packer(::grpc::ServerContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Packer() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu_packer::service::v1::PackerRequest* /*request*/, ::bugu_packer::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPacker(::grpc::ServerContext* context, ::bugu_packer::service::v1::PackerRequest* request, ::grpc::ServerAsyncResponseWriter< ::bugu_packer::service::v1::PackerReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Packer<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Packer() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bugu_packer::service::v1::PackerRequest, ::bugu_packer::service::v1::PackerReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bugu_packer::service::v1::PackerRequest* request, ::bugu_packer::service::v1::PackerReply* response) { return this->Packer(context, request, response); }));}
    void SetMessageAllocatorFor_Packer(
        ::grpc::MessageAllocator< ::bugu_packer::service::v1::PackerRequest, ::bugu_packer::service::v1::PackerReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bugu_packer::service::v1::PackerRequest, ::bugu_packer::service::v1::PackerReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu_packer::service::v1::PackerRequest* /*request*/, ::bugu_packer::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Packer(
      ::grpc::CallbackServerContext* /*context*/, const ::bugu_packer::service::v1::PackerRequest* /*request*/, ::bugu_packer::service::v1::PackerReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Packer<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Packer() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu_packer::service::v1::PackerRequest* /*request*/, ::bugu_packer::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Packer() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu_packer::service::v1::PackerRequest* /*request*/, ::bugu_packer::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPacker(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Packer() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Packer(context, request, response); }));
    }
    ~WithRawCallbackMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu_packer::service::v1::PackerRequest* /*request*/, ::bugu_packer::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Packer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Packer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Packer() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bugu_packer::service::v1::PackerRequest, ::bugu_packer::service::v1::PackerReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bugu_packer::service::v1::PackerRequest, ::bugu_packer::service::v1::PackerReply>* streamer) {
                       return this->StreamedPacker(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Packer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Packer(::grpc::ServerContext* /*context*/, const ::bugu_packer::service::v1::PackerRequest* /*request*/, ::bugu_packer::service::v1::PackerReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPacker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bugu_packer::service::v1::PackerRequest,::bugu_packer::service::v1::PackerReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Packer<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Packer<Service > StreamedService;
};

}  // namespace v1
}  // namespace service
}  // namespace bugu_packer


#endif  // GRPC_bugu_5fpacker_2eproto__INCLUDED

```

`api/packer/service/v1/cpp/bugu_packer.pb.cc`:

```cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bugu_packer.proto

#include "bugu_packer.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace bugu_packer {
namespace service {
namespace v1 {
constexpr PackerRequest::PackerRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_()
  , size_(0u){}
struct PackerRequestDefaultTypeInternal {
  constexpr PackerRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PackerRequestDefaultTypeInternal() {}
  union {
    PackerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PackerRequestDefaultTypeInternal _PackerRequest_default_instance_;
constexpr PackerReply::PackerReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_()
  , size_(0u){}
struct PackerReplyDefaultTypeInternal {
  constexpr PackerReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PackerReplyDefaultTypeInternal() {}
  union {
    PackerReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PackerReplyDefaultTypeInternal _PackerReply_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu_packer
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_bugu_5fpacker_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_bugu_5fpacker_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_bugu_5fpacker_2eproto = nullptr;

const uint32_t TableStruct_bugu_5fpacker_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu_packer::service::v1::PackerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu_packer::service::v1::PackerRequest, data_),
  PROTOBUF_FIELD_OFFSET(::bugu_packer::service::v1::PackerRequest, size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bugu_packer::service::v1::PackerReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::bugu_packer::service::v1::PackerReply, data_),
  PROTOBUF_FIELD_OFFSET(::bugu_packer::service::v1::PackerReply, size_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::bugu_packer::service::v1::PackerRequest)},
  { 8, -1, -1, sizeof(::bugu_packer::service::v1::PackerReply)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu_packer::service::v1::_PackerRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bugu_packer::service::v1::_PackerReply_default_instance_),
};

const char descriptor_table_protodef_bugu_5fpacker_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021bugu_packer.proto\022\026bugu_packer.service"
  ".v1\"+\n\rPackerRequest\022\014\n\004data\030\001 \003(\014\022\014\n\004si"
  "ze\030\002 \001(\r\")\n\013PackerReply\022\014\n\004data\030\001 \003(\014\022\014\n"
  "\004size\030\002 \001(\r2d\n\nBuguPacker\022V\n\006Packer\022%.bu"
  "gu_packer.service.v1.PackerRequest\032#.bug"
  "u_packer.service.v1.PackerReply\"\000B2Z0git"
  "hub.com/hominsu/bugu/api/packer/service/"
  "v1;v1b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_bugu_5fpacker_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bugu_5fpacker_2eproto = {
  false, false, 293, descriptor_table_protodef_bugu_5fpacker_2eproto, "bugu_packer.proto", 
  &descriptor_table_bugu_5fpacker_2eproto_once, nullptr, 0, 2,
  schemas, file_default_instances, TableStruct_bugu_5fpacker_2eproto::offsets,
  file_level_metadata_bugu_5fpacker_2eproto, file_level_enum_descriptors_bugu_5fpacker_2eproto, file_level_service_descriptors_bugu_5fpacker_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_bugu_5fpacker_2eproto_getter() {
  return &descriptor_table_bugu_5fpacker_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_bugu_5fpacker_2eproto(&descriptor_table_bugu_5fpacker_2eproto);
namespace bugu_packer {
namespace service {
namespace v1 {

// ===================================================================

class PackerRequest::_Internal {
 public:
};

PackerRequest::PackerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu_packer.service.v1.PackerRequest)
}
PackerRequest::PackerRequest(const PackerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:bugu_packer.service.v1.PackerRequest)
}

inline void PackerRequest::SharedCtor() {
size_ = 0u;
}

PackerRequest::~PackerRequest() {
  // @@protoc_insertion_point(destructor:bugu_packer.service.v1.PackerRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PackerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PackerRequest::ArenaDtor(void* object) {
  PackerRequest* _this = reinterpret_cast< PackerRequest* >(object);
  (void)_this;
}
void PackerRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PackerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PackerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu_packer.service.v1.PackerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  size_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PackerRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_data();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PackerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu_packer.service.v1.PackerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes data = 1;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    const auto& s = this->_internal_data(i);
    target = stream->WriteBytes(1, s, target);
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu_packer.service.v1.PackerRequest)
  return target;
}

size_t PackerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu_packer.service.v1.PackerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes data = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(data_.size());
  for (int i = 0, n = data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      data_.Get(i));
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PackerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PackerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PackerRequest::GetClassData() const { return &_class_data_; }

void PackerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PackerRequest *>(to)->MergeFrom(
      static_cast<const PackerRequest &>(from));
}


void PackerRequest::MergeFrom(const PackerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu_packer.service.v1.PackerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from._internal_size() != 0) {
    _internal_set_size(from._internal_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PackerRequest::CopyFrom(const PackerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu_packer.service.v1.PackerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PackerRequest::IsInitialized() const {
  return true;
}

void PackerRequest::InternalSwap(PackerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PackerRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_5fpacker_2eproto_getter, &descriptor_table_bugu_5fpacker_2eproto_once,
      file_level_metadata_bugu_5fpacker_2eproto[0]);
}

// ===================================================================

class PackerReply::_Internal {
 public:
};

PackerReply::PackerReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:bugu_packer.service.v1.PackerReply)
}
PackerReply::PackerReply(const PackerReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      data_(from.data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:bugu_packer.service.v1.PackerReply)
}

inline void PackerReply::SharedCtor() {
size_ = 0u;
}

PackerReply::~PackerReply() {
  // @@protoc_insertion_point(destructor:bugu_packer.service.v1.PackerReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PackerReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PackerReply::ArenaDtor(void* object) {
  PackerReply* _this = reinterpret_cast< PackerReply* >(object);
  (void)_this;
}
void PackerReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PackerReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PackerReply::Clear() {
// @@protoc_insertion_point(message_clear_start:bugu_packer.service.v1.PackerReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  size_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PackerReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_data();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PackerReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bugu_packer.service.v1.PackerReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes data = 1;
  for (int i = 0, n = this->_internal_data_size(); i < n; i++) {
    const auto& s = this->_internal_data(i);
    target = stream->WriteBytes(1, s, target);
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bugu_packer.service.v1.PackerReply)
  return target;
}

size_t PackerReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bugu_packer.service.v1.PackerReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes data = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(data_.size());
  for (int i = 0, n = data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      data_.Get(i));
  }

  // uint32 size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PackerReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PackerReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PackerReply::GetClassData() const { return &_class_data_; }

void PackerReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PackerReply *>(to)->MergeFrom(
      static_cast<const PackerReply &>(from));
}


void PackerReply::MergeFrom(const PackerReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bugu_packer.service.v1.PackerReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  if (from._internal_size() != 0) {
    _internal_set_size(from._internal_size());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PackerReply::CopyFrom(const PackerReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bugu_packer.service.v1.PackerReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PackerReply::IsInitialized() const {
  return true;
}

void PackerReply::InternalSwap(PackerReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PackerReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bugu_5fpacker_2eproto_getter, &descriptor_table_bugu_5fpacker_2eproto_once,
      file_level_metadata_bugu_5fpacker_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace service
}  // namespace bugu_packer
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::bugu_packer::service::v1::PackerRequest* Arena::CreateMaybeMessage< ::bugu_packer::service::v1::PackerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu_packer::service::v1::PackerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bugu_packer::service::v1::PackerReply* Arena::CreateMaybeMessage< ::bugu_packer::service::v1::PackerReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bugu_packer::service::v1::PackerReply >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

```

`api/packer/service/v1/cpp/bugu_packer.pb.h`:

```h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bugu_packer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bugu_5fpacker_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bugu_5fpacker_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bugu_5fpacker_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bugu_5fpacker_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bugu_5fpacker_2eproto;
namespace bugu_packer {
namespace service {
namespace v1 {
class PackerReply;
struct PackerReplyDefaultTypeInternal;
extern PackerReplyDefaultTypeInternal _PackerReply_default_instance_;
class PackerRequest;
struct PackerRequestDefaultTypeInternal;
extern PackerRequestDefaultTypeInternal _PackerRequest_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu_packer
PROTOBUF_NAMESPACE_OPEN
template<> ::bugu_packer::service::v1::PackerReply* Arena::CreateMaybeMessage<::bugu_packer::service::v1::PackerReply>(Arena*);
template<> ::bugu_packer::service::v1::PackerRequest* Arena::CreateMaybeMessage<::bugu_packer::service::v1::PackerRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bugu_packer {
namespace service {
namespace v1 {

// ===================================================================

class PackerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu_packer.service.v1.PackerRequest) */ {
 public:
  inline PackerRequest() : PackerRequest(nullptr) {}
  ~PackerRequest() override;
  explicit constexpr PackerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackerRequest(const PackerRequest& from);
  PackerRequest(PackerRequest&& from) noexcept
    : PackerRequest() {
    *this = ::std::move(from);
  }

  inline PackerRequest& operator=(const PackerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackerRequest& operator=(PackerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackerRequest* internal_default_instance() {
    return reinterpret_cast<const PackerRequest*>(
               &_PackerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PackerRequest& a, PackerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PackerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PackerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu_packer.service.v1.PackerRequest";
  }
  protected:
  explicit PackerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated bytes data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // uint32 size = 2;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bugu_packer.service.v1.PackerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
  uint32_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_5fpacker_2eproto;
};
// -------------------------------------------------------------------

class PackerReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu_packer.service.v1.PackerReply) */ {
 public:
  inline PackerReply() : PackerReply(nullptr) {}
  ~PackerReply() override;
  explicit constexpr PackerReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PackerReply(const PackerReply& from);
  PackerReply(PackerReply&& from) noexcept
    : PackerReply() {
    *this = ::std::move(from);
  }

  inline PackerReply& operator=(const PackerReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PackerReply& operator=(PackerReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PackerReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const PackerReply* internal_default_instance() {
    return reinterpret_cast<const PackerReply*>(
               &_PackerReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PackerReply& a, PackerReply& b) {
    a.Swap(&b);
  }
  inline void Swap(PackerReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PackerReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PackerReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PackerReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PackerReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PackerReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PackerReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu_packer.service.v1.PackerReply";
  }
  protected:
  explicit PackerReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated bytes data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // uint32 size = 2;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bugu_packer.service.v1.PackerReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
  uint32_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_5fpacker_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PackerRequest

// repeated bytes data = 1;
inline int PackerRequest::_internal_data_size() const {
  return data_.size();
}
inline int PackerRequest::data_size() const {
  return _internal_data_size();
}
inline void PackerRequest::clear_data() {
  data_.Clear();
}
inline std::string* PackerRequest::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:bugu_packer.service.v1.PackerRequest.data)
  return _s;
}
inline const std::string& PackerRequest::_internal_data(int index) const {
  return data_.Get(index);
}
inline const std::string& PackerRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:bugu_packer.service.v1.PackerRequest.data)
  return _internal_data(index);
}
inline std::string* PackerRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:bugu_packer.service.v1.PackerRequest.data)
  return data_.Mutable(index);
}
inline void PackerRequest::set_data(int index, const std::string& value) {
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bugu_packer.service.v1.PackerRequest.data)
}
inline void PackerRequest::set_data(int index, std::string&& value) {
  data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bugu_packer.service.v1.PackerRequest.data)
}
inline void PackerRequest::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bugu_packer.service.v1.PackerRequest.data)
}
inline void PackerRequest::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bugu_packer.service.v1.PackerRequest.data)
}
inline std::string* PackerRequest::_internal_add_data() {
  return data_.Add();
}
inline void PackerRequest::add_data(const std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bugu_packer.service.v1.PackerRequest.data)
}
inline void PackerRequest::add_data(std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bugu_packer.service.v1.PackerRequest.data)
}
inline void PackerRequest::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bugu_packer.service.v1.PackerRequest.data)
}
inline void PackerRequest::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bugu_packer.service.v1.PackerRequest.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PackerRequest::data() const {
  // @@protoc_insertion_point(field_list:bugu_packer.service.v1.PackerRequest.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PackerRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:bugu_packer.service.v1.PackerRequest.data)
  return &data_;
}

// uint32 size = 2;
inline void PackerRequest::clear_size() {
  size_ = 0u;
}
inline uint32_t PackerRequest::_internal_size() const {
  return size_;
}
inline uint32_t PackerRequest::size() const {
  // @@protoc_insertion_point(field_get:bugu_packer.service.v1.PackerRequest.size)
  return _internal_size();
}
inline void PackerRequest::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void PackerRequest::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:bugu_packer.service.v1.PackerRequest.size)
}

// -------------------------------------------------------------------

// PackerReply

// repeated bytes data = 1;
inline int PackerReply::_internal_data_size() const {
  return data_.size();
}
inline int PackerReply::data_size() const {
  return _internal_data_size();
}
inline void PackerReply::clear_data() {
  data_.Clear();
}
inline std::string* PackerReply::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:bugu_packer.service.v1.PackerReply.data)
  return _s;
}
inline const std::string& PackerReply::_internal_data(int index) const {
  return data_.Get(index);
}
inline const std::string& PackerReply::data(int index) const {
  // @@protoc_insertion_point(field_get:bugu_packer.service.v1.PackerReply.data)
  return _internal_data(index);
}
inline std::string* PackerReply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:bugu_packer.service.v1.PackerReply.data)
  return data_.Mutable(index);
}
inline void PackerReply::set_data(int index, const std::string& value) {
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bugu_packer.service.v1.PackerReply.data)
}
inline void PackerReply::set_data(int index, std::string&& value) {
  data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bugu_packer.service.v1.PackerReply.data)
}
inline void PackerReply::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bugu_packer.service.v1.PackerReply.data)
}
inline void PackerReply::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bugu_packer.service.v1.PackerReply.data)
}
inline std::string* PackerReply::_internal_add_data() {
  return data_.Add();
}
inline void PackerReply::add_data(const std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bugu_packer.service.v1.PackerReply.data)
}
inline void PackerReply::add_data(std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bugu_packer.service.v1.PackerReply.data)
}
inline void PackerReply::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bugu_packer.service.v1.PackerReply.data)
}
inline void PackerReply::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bugu_packer.service.v1.PackerReply.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PackerReply::data() const {
  // @@protoc_insertion_point(field_list:bugu_packer.service.v1.PackerReply.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PackerReply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:bugu_packer.service.v1.PackerReply.data)
  return &data_;
}

// uint32 size = 2;
inline void PackerReply::clear_size() {
  size_ = 0u;
}
inline uint32_t PackerReply::_internal_size() const {
  return size_;
}
inline uint32_t PackerReply::size() const {
  // @@protoc_insertion_point(field_get:bugu_packer.service.v1.PackerReply.size)
  return _internal_size();
}
inline void PackerReply::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void PackerReply::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:bugu_packer.service.v1.PackerReply.size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace service
}  // namespace bugu_packer

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bugu_5fpacker_2eproto

```

`app/bugu/service/Dockerfile`:

```
# build stage
FROM golang:1.18 AS builder
# app dir
ARG APP_RELATIVE_PATH
# build app
COPY . /src
WORKDIR /src/app/${APP_RELATIVE_PATH}
RUN make build

# final stage
FROM debian:stable-slim
# image info
ARG AUTHOR_NAME
ARG AUTHOR_EMAIL
ARG VERSION
# label
LABEL author=$AUTHOR_NAME email=${AUTHOR_EMAIL} version=$VERSION
# app dir
ARG APP_RELATIVE_PATH
# install: ca-certificates netbase
RUN apt-get update && apt-get install -y --no-install-recommends \
		ca-certificates  \
        netbase \
        && rm -rf /var/lib/apt/lists/ \
        && apt-get autoremove -y && apt-get autoclean -y
# cpoy the app from builder
COPY --from=builder /src/app/${APP_RELATIVE_PATH}/bin /app
WORKDIR /app
EXPOSE 8000
VOLUME /data/conf
VOLUME /data/file
CMD ["./server", "-conf", "/data/conf"]

```

`app/bugu/service/Makefile`:

```
include ../../../app_makefile
```

`app/bugu/service/cmd/server/main.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package main

import (
	"flag"
	"os"

	"github.com/hominsu/bugu/app/bugu/service/internal/conf"

	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/config"
	"github.com/go-kratos/kratos/v2/config/file"
	"github.com/go-kratos/kratos/v2/log"
	"github.com/go-kratos/kratos/v2/middleware/tracing"
	"github.com/go-kratos/kratos/v2/registry"
	"github.com/go-kratos/kratos/v2/transport/http"
)

// go build -ldflags "-X main.Version=x.y.z"
var (
	// Name is the name of the compiled software.
	Name = "bugu.bugu.service"
	// Version is the version of the compiled software.
	Version string
	// flagconf is the config flag.
	flagconf string

	id, _ = os.Hostname()
)

func init() {
	flag.StringVar(&flagconf, "conf", "../../configs", "config path, eg: -conf config.yaml")
}

func newApp(logger log.Logger, hs *http.Server, rr registry.Registrar) *kratos.App {
	return kratos.New(
		kratos.Name(Name),
		kratos.Version(Version),
		kratos.Metadata(map[string]string{}),
		kratos.Logger(logger),
		kratos.Server(
			hs,
		),
		kratos.Registrar(rr),
	)
}

func main() {
	flag.Parse()

	c := config.New(
		config.WithSource(
			file.NewSource(flagconf),
		),
	)
	defer func(c config.Config) {
		err := c.Close()
		if err != nil {
			panic(err)
		}
	}(c)
	if err := c.Load(); err != nil {
		panic(err)
	}

	var bc conf.Bootstrap
	if err := c.Scan(&bc); err != nil {
		panic(err)
	}

	var rc conf.Registry
	if err := c.Scan(&rc); err != nil {
		panic(err)
	}

	var tc conf.Tracer
	if err := c.Scan(&tc); err != nil {
		panic(err)
	}

	var lc conf.Log
	if err := c.Scan(&lc); err != nil {
		panic(err)
	}

	logger := log.With(log.NewStdLogger(os.Stdout),
		"service.id", id,
		"service.name", Name,
		"service.version", Version,
		"ts", log.DefaultTimestamp,
		"caller", log.DefaultCaller,
		"trace_id", tracing.TraceID(),
		"span_id", tracing.SpanID(),
	)

	app, cleanup, err := initApp(&rc, bc.Server, bc.Data, bc.Jwt, logger)
	if err != nil {
		panic(err)
	}
	defer cleanup()

	// start and wait for stop signal
	if err := app.Run(); err != nil {
		panic(err)
	}
}

```

`app/bugu/service/cmd/server/wire.go`:

```go
//go:build wireinject
// +build wireinject

/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

// The build tag makes sure the stub is not built in the final build.

package main

import (
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"github.com/google/wire"
	"github.com/hominsu/bugu/app/bugu/service/internal/biz"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
	"github.com/hominsu/bugu/app/bugu/service/internal/data"
	"github.com/hominsu/bugu/app/bugu/service/internal/server"
	"github.com/hominsu/bugu/app/bugu/service/internal/service"
)

// initApp init kratos application.
func initApp(*conf.Registry, *conf.Server, *conf.Data, *conf.Jwt, log.Logger) (*kratos.App, func(), error) {
	panic(wire.Build(server.ProviderSet, data.ProviderSet, biz.ProviderSet, service.ProviderSet, newApp))
}

```

`app/bugu/service/cmd/server/wire_gen.go`:

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"github.com/hominsu/bugu/app/bugu/service/internal/biz"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
	"github.com/hominsu/bugu/app/bugu/service/internal/data"
	"github.com/hominsu/bugu/app/bugu/service/internal/server"
	"github.com/hominsu/bugu/app/bugu/service/internal/service"
)

// Injectors from wire.go:

// initApp init kratos application.
func initApp(registry *conf.Registry, confServer *conf.Server, confData *conf.Data, jwt *conf.Jwt, logger log.Logger) (*kratos.App, func(), error) {
	client := data.NewEntClient(confData, logger)
	cmdable := data.NewRedisCmd(confData, logger)
	buguObfusionClient := data.NewOubfusionServiceClient(confServer)
	dataData, cleanup, err := data.NewData(client, cmdable, buguObfusionClient, confData, logger)
	if err != nil {
		return nil, nil, err
	}
	userRepo := data.NewUserRepo(dataData, logger)
	userUsecase := biz.NewUserUsecase(userRepo, jwt, logger)
	fileRepo := data.NewFileRepo(dataData, logger)
	fileUsecase := biz.NewFileUsecase(fileRepo, logger)
	artifactRepo := data.NewArtifactRepo(dataData, logger)
	obfusionRepo := data.NewObfusionRepo(dataData, logger)
	artifactUsecase := biz.NewArtifactUsecase(artifactRepo, obfusionRepo, fileRepo, confData, logger)
	buguService := service.NewBuguService(userUsecase, fileUsecase, artifactUsecase, logger)
	buguFileService := service.NewBuguFileService(fileUsecase, confData, logger)
	httpServer := server.NewHTTPServer(confServer, jwt, buguService, buguFileService, logger)
	registrar := server.NewRegistrar(registry)
	app := newApp(logger, httpServer, registrar)
	return app, func() {
		cleanup()
	}, nil
}

```

`app/bugu/service/configs/config.yaml`:

```yaml
server:
  http:
    addr: 0.0.0.0:8000
    timeout: 60s
data:
  database:
    driver: mysql
    source: root:dangerous@tcp(docker.for.mac.host.internal:3306)/test?charset=utf8mb4&parseTime=True&loc=Local
  redis:
    addr: docker.for.mac.host.internal:6379
    db: 0
    cache_expiration: 1800s
    read_timeout: 0.2s
    write_timeout: 0.2s
  file:
    path: "/data/file"
jwt:
  secret: "hello"
```

`app/bugu/service/configs/registry.yaml`:

```yaml
consul:
  address: "docker.for.mac.host.internal:8500"
  scheme: http
```

`app/bugu/service/go.mod`:

```mod
module github.com/hominsu/bugu/app/bugu/service

go 1.18

require (
	entgo.io/ent v0.10.1
	github.com/go-kratos/kratos/contrib/registry/consul/v2 v2.0.0-20220604031450-874d4c3edcf5
	github.com/go-kratos/kratos/v2 v2.3.1
	github.com/go-redis/redis/v8 v8.11.5
	github.com/go-sql-driver/mysql v1.6.0
	github.com/golang-jwt/jwt/v4 v4.4.1
	github.com/google/uuid v1.3.0
	github.com/google/wire v0.5.0
	github.com/gorilla/handlers v1.5.1
	github.com/hashicorp/consul/api v1.13.0
	github.com/hominsu/bugu v1.0.0
	github.com/hominsu/bugu/pkg v0.0.0-20220608071005-03611bdc29ab
	google.golang.org/grpc v1.47.0
	google.golang.org/protobuf v1.28.0
)

require (
	ariga.io/atlas v0.3.7-0.20220303204946-787354f533c3 // indirect
	github.com/StackExchange/wmi v1.2.1 // indirect
	github.com/agext/levenshtein v1.2.1 // indirect
	github.com/apparentlymart/go-textseg/v13 v13.0.0 // indirect
	github.com/armon/go-metrics v0.3.10 // indirect
	github.com/cespare/xxhash/v2 v2.1.2 // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/envoyproxy/protoc-gen-validate v0.6.7 // indirect
	github.com/fatih/color v1.13.0 // indirect
	github.com/felixge/httpsnoop v1.0.1 // indirect
	github.com/fsnotify/fsnotify v1.5.4 // indirect
	github.com/go-kratos/aegis v0.1.2 // indirect
	github.com/go-logr/logr v1.2.3 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-ole/go-ole v1.2.5 // indirect
	github.com/go-openapi/inflect v0.19.0 // indirect
	github.com/go-playground/form/v4 v4.2.0 // indirect
	github.com/golang/protobuf v1.5.2 // indirect
	github.com/google/btree v1.0.0 // indirect
	github.com/google/go-cmp v0.5.8 // indirect
	github.com/gorilla/mux v1.8.0 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.10.3 // indirect
	github.com/hashicorp/go-cleanhttp v0.5.2 // indirect
	github.com/hashicorp/go-hclog v1.0.0 // indirect
	github.com/hashicorp/go-immutable-radix v1.3.1 // indirect
	github.com/hashicorp/go-rootcerts v1.0.2 // indirect
	github.com/hashicorp/golang-lru v0.5.4 // indirect
	github.com/hashicorp/hcl/v2 v2.10.0 // indirect
	github.com/hashicorp/serf v0.9.6 // indirect
	github.com/imdario/mergo v0.3.12 // indirect
	github.com/mattn/go-colorable v0.1.12 // indirect
	github.com/mattn/go-isatty v0.0.14 // indirect
	github.com/mitchellh/go-homedir v1.1.0 // indirect
	github.com/mitchellh/go-wordwrap v0.0.0-20150314170334-ad45545899c7 // indirect
	github.com/mitchellh/mapstructure v1.4.3 // indirect
	github.com/shirou/gopsutil/v3 v3.21.8 // indirect
	github.com/tklauser/go-sysconf v0.3.9 // indirect
	github.com/tklauser/numcpus v0.3.0 // indirect
	github.com/zclconf/go-cty v1.8.0 // indirect
	go.opentelemetry.io/otel v1.7.0 // indirect
	go.opentelemetry.io/otel/trace v1.7.0 // indirect
	golang.org/x/crypto v0.0.0-20220525230936-793ad666bf5e // indirect
	golang.org/x/mod v0.5.1 // indirect
	golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd // indirect
	golang.org/x/sync v0.0.0-20220513210516-0976fa681c29 // indirect
	golang.org/x/sys v0.0.0-20220412211240-33da011f77ad // indirect
	golang.org/x/text v0.3.7 // indirect
	google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

replace (
	github.com/hominsu/bugu => ../../../
	github.com/hominsu/bugu/pkg => ../../../pkg
)

```

`app/bugu/service/go.sum`:

```sum
ariga.io/atlas v0.3.7-0.20220303204946-787354f533c3 h1:fjG4oFCQEfGrRi0QoxWcH2OO28CE6VYa6DkIr3yDySU=
ariga.io/atlas v0.3.7-0.20220303204946-787354f533c3/go.mod h1:yWGf4VPiD4SW83+kAqzD624txN9VKoJC+bpVXr2pKJA=
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
entgo.io/ent v0.10.1 h1:dM5h4Zk6yHGIgw4dCqVzGw3nWgpGYJiV4/kyHEF6PFo=
entgo.io/ent v0.10.1/go.mod h1:YPgxeLnoQ/YdpVORRtqjBF+wCy9NX9IR7veTv3Bffus=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/DATA-DOG/go-sqlmock v1.5.0 h1:Shsta01QNfFxHCfpW6YH2STWB0MudeXXEWMr20OEh60=
github.com/DataDog/datadog-go v3.2.0+incompatible/go.mod h1:LButxg5PwREeZtORoXG3tL4fMGNddJ+vMq1mwgfaqoQ=
github.com/StackExchange/wmi v1.2.1 h1:VIkavFPXSjcnS+O8yTq7NI32k0R5Aj+v39y29VYDOSA=
github.com/StackExchange/wmi v1.2.1/go.mod h1:rcmrprowKIVzvc+NUiLncP2uuArMWLCbu9SBzvHz7e8=
github.com/agext/levenshtein v1.2.1 h1:QmvMAjj2aEICytGiWzmxoE0x2KZvE0fvmqMOfy2tjT8=
github.com/agext/levenshtein v1.2.1/go.mod h1:JEDfjyjHDjOF/1e4FlBE/PkbqA9OfWu2ki2W0IB5558=
github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
github.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=
github.com/apparentlymart/go-dump v0.0.0-20180507223929-23540a00eaa3/go.mod h1:oL81AME2rN47vu18xqj1S1jPIPuN7afo62yKTNn3XMM=
github.com/apparentlymart/go-textseg v1.0.0/go.mod h1:z96Txxhf3xSFMPmb5X/1W05FF/Nj9VFpLOpjS5yuumk=
github.com/apparentlymart/go-textseg/v13 v13.0.0 h1:Y+KvPE1NYz0xl601PVImeQfFyEy6iT90AvPUL1NNfNw=
github.com/apparentlymart/go-textseg/v13 v13.0.0/go.mod h1:ZK2fH7c4NqDTLtiYLvIkEghdlcqw7yxLeM89kiTRPUo=
github.com/armon/circbuf v0.0.0-20150827004946-bbbad097214e/go.mod h1:3U/XgcO3hCbHZ8TKRvWD2dDTCfh9M9ya+I9JpbB7O8o=
github.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da/go.mod h1:Q73ZrmVTwzkszR9V5SSuryQ31EELlFMUz1kKyl939pY=
github.com/armon/go-metrics v0.3.10 h1:FR+drcQStOe+32sYyJYyZ7FIdgoGGBnwLl+flodp8Uo=
github.com/armon/go-metrics v0.3.10/go.mod h1:4O98XIr/9W0sxpJ8UaYkvjk10Iff7SnFrb4QAOwNTFc=
github.com/armon/go-radix v0.0.0-20180808171621-7fddfc383310/go.mod h1:ufUuZ+zHj4x4TnLV4JWEpy2hxWSpsRywHrMgIH9cCH8=
github.com/armon/go-radix v1.0.0/go.mod h1:ufUuZ+zHj4x4TnLV4JWEpy2hxWSpsRywHrMgIH9cCH8=
github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=
github.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=
github.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=
github.com/bgentry/speakeasy v0.1.0/go.mod h1:+zsyZBPWlz7T6j88CTgSN5bM796AkVf0kBD4zp0CCIs=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/cespare/xxhash/v2 v2.1.2 h1:YRXhKfTDauu4ajMg1TPgFO5jnlC2HCbmLXMcTG5cbYE=
github.com/cespare/xxhash/v2 v2.1.2/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/circonus-labs/circonus-gometrics v2.3.1+incompatible/go.mod h1:nmEj6Dob7S7YxXgwXpfOuvO54S+tGdZdw9fuRZt25Ag=
github.com/circonus-labs/circonusllhist v0.1.3/go.mod h1:kMXHVDlOchFAehlya5ePtbp5jckzBHf4XRpQvBOLI+I=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=
github.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20211001041855-01bcc9b48dfe/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/go-control-plane v0.10.2-0.20220325020618-49ff273808a1/go.mod h1:KJwIaB5Mv44NWtYuAOFCVOjcI94vtpEz2JU/D2v6IjE=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/envoyproxy/protoc-gen-validate v0.6.7 h1:qcZcULcd/abmQg6dwigimCNEyi4gg31M/xaciQlDml8=
github.com/envoyproxy/protoc-gen-validate v0.6.7/go.mod h1:dyJXwwfPK2VSqiB9Klm1J6romD608Ba7Hij42vrOBCo=
github.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=
github.com/fatih/color v1.9.0/go.mod h1:eQcE1qtQxscV5RaZvpXrrb8Drkc3/DdQ+uUYCNjL+zU=
github.com/fatih/color v1.13.0 h1:8LOYc1KYPPmyKMuN8QV2DNRWNbLo6LZ0iLs8+mlH53w=
github.com/fatih/color v1.13.0/go.mod h1:kLAiJbzzSOZDVNGyDpeOxJ47H46qBXwg5ILebYFFOfk=
github.com/felixge/httpsnoop v1.0.1 h1:lvB5Jl89CsZtGIWuTcDM1E/vkVs49/Ml7JJe07l8SPQ=
github.com/felixge/httpsnoop v1.0.1/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/fsnotify/fsnotify v1.5.4 h1:jRbGcIw6P2Meqdwuo0H1p6JVLbL5DHKAKlYndzMwVZI=
github.com/fsnotify/fsnotify v1.5.4/go.mod h1:OVB6XrOHzAwXMpEM7uPOzcehqUV2UqJxmVXmkdnm1bU=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=
github.com/go-kit/kit v0.9.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=
github.com/go-kratos/aegis v0.1.2 h1:4yJlFEmty8kRO9wHWLsbE65CS5ffUdglZk9YHo0NMD4=
github.com/go-kratos/aegis v0.1.2/go.mod h1:jYeSQ3Gesba478zEnujOiG5QdsyF3Xk/8owFUeKcHxw=
github.com/go-kratos/kratos/contrib/registry/consul/v2 v2.0.0-20220604031450-874d4c3edcf5 h1:AehAY7Js8Pn7xFnPb7aCqylxnfpyOKLF/8GqceI55oQ=
github.com/go-kratos/kratos/contrib/registry/consul/v2 v2.0.0-20220604031450-874d4c3edcf5/go.mod h1:oMQ4Mm6G9L6m7Rk2FS2NdgjaYbIEgKyZJVRWzcs0My8=
github.com/go-kratos/kratos/v2 v2.3.1 h1:Qfx3JSEIrfZl0f8mXvbeGv3tRIZ2L/ArhcKwxAr3uMo=
github.com/go-kratos/kratos/v2 v2.3.1/go.mod h1:5acyLj4EgY428AJnZl2EwCrMV1OVlttQFBum+SghMiA=
github.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=
github.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.2.3 h1:2DntVwHkVopvECVRSlL5PSo9eG+cAkDCuckLubN+rq0=
github.com/go-logr/logr v1.2.3/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-ole/go-ole v1.2.5 h1:t4MGB5xEDZvXI+0rMjjsfBsD7yAgp/s9ZDkL1JndXwY=
github.com/go-ole/go-ole v1.2.5/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
github.com/go-openapi/inflect v0.19.0 h1:9jCH9scKIbHeV9m12SmPilScz6krDxKRasNNSNPXu/4=
github.com/go-openapi/inflect v0.19.0/go.mod h1:lHpZVlpIQqLyKwJ4N+YSc9hchQy/i12fJykb83CRBH4=
github.com/go-playground/assert/v2 v2.0.1 h1:MsBgLAaY856+nPRTKrp3/OZK38U/wa0CcBYNjji3q3A=
github.com/go-playground/assert/v2 v2.0.1/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/form/v4 v4.2.0 h1:N1wh+Goz61e6w66vo8vJkQt+uwZSoLz50kZPJWR8eic=
github.com/go-playground/form/v4 v4.2.0/go.mod h1:q1a2BY+AQUUzhl6xA/6hBetay6dEIhMHjgvJiGo6K7U=
github.com/go-redis/redis/v8 v8.11.5 h1:AcZZR7igkdvfVmQTPnu9WE37LRrO/YrBH5zWyjDC0oI=
github.com/go-redis/redis/v8 v8.11.5/go.mod h1:gREzHqY1hg6oD9ngVRbLStwAWKhA0FEgq8Jd4h5lpwo=
github.com/go-sql-driver/mysql v1.6.0 h1:BCTh4TKNUYmOmMUcQ3IipzF5prigylS7XXjEkfCHuOE=
github.com/go-sql-driver/mysql v1.6.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=
github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=
github.com/go-test/deep v1.0.3 h1:ZrJSEWsXzPOxaZnFteGEfooLba+ju3FYIbOrS+rQd68=
github.com/go-test/deep v1.0.3/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=
github.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=
github.com/golang-jwt/jwt/v4 v4.4.1 h1:pC5DB52sCeK48Wlb9oPcdhnjkz1TKt1D/P7WKJ0kUcQ=
github.com/golang-jwt/jwt/v4 v4.4.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/protobuf v1.1.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
github.com/golang/protobuf v1.5.2 h1:ROPKBNFfQgOUMifHyP+KYbvpjbdoFNs+aK7DXlji0Tw=
github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/btree v1.0.0 h1:0udJVsspx3VBr5FwtLhQQtuAsVc79tTq0ocGIPAU6qo=
github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.7/go.mod h1:n+brtR0CgQNWTVd5ZUFpTBC8YFBDLK/h/bpaJ8/DtOE=
github.com/google/go-cmp v0.5.8 h1:e6P7q2lk1O+qJJb4BtCQXlK8vWEO8V1ZeuEdJNOqZyg=
github.com/google/go-cmp v0.5.8/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/subcommands v1.0.1/go.mod h1:ZjhPrFU+Olkh9WazFPsl27BQ4UPiG37m3yTrtFlrHVk=
github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.3.0 h1:t6JiXgmwXMjEs8VusXIJk2BXHsn+wx8BZdTaoZ5fu7I=
github.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/wire v0.5.0 h1:I7ELFeVBr3yfPIcc8+MWvrjk+3VjbcSzoXm3JVa+jD8=
github.com/google/wire v0.5.0/go.mod h1:ngWDr9Qvq3yZA10YrxfyGELY/AFWGVpy9c1LTRi1EoU=
github.com/gorilla/handlers v1.5.1 h1:9lRY6j8DEeeBT10CvO9hGW0gmky0BprnvDI5vfhUHH4=
github.com/gorilla/handlers v1.5.1/go.mod h1:t8XrUpc4KVXb7HGyJ4/cEnwQiaxrX/hz1Zv/4g96P1Q=
github.com/gorilla/mux v1.8.0 h1:i40aqfkR1h2SlN9hojwV5ZA91wcXFOvkdNIeFDP5koI=
github.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=
github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.10.3 h1:BGNSrTRW4rwfhJiFwvwF4XQ0Y72Jj9YEgxVrtovbD5o=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.10.3/go.mod h1:VHn7KgNsRriXa4mcgtkpR00OXyQY6g67JWMvn+R27A4=
github.com/hashicorp/consul/api v1.12.0/go.mod h1:6pVBMo0ebnYdt2S3H87XhekM/HHrUoTD2XXb/VrZVy0=
github.com/hashicorp/consul/api v1.13.0 h1:2hnLQ0GjQvw7f3O61jMO8gbasZviZTrt9R8WzgiirHc=
github.com/hashicorp/consul/api v1.13.0/go.mod h1:ZlVrynguJKcYr54zGaDbaL3fOvKC9m72FhPvA8T35KQ=
github.com/hashicorp/consul/sdk v0.8.0 h1:OJtKBtEjboEZvG6AOUdh4Z1Zbyu0WcxQ0qatRrZHTVU=
github.com/hashicorp/consul/sdk v0.8.0/go.mod h1:GBvyrGALthsZObzUGsfgHZQDXjg4lOjagTIwIR1vPms=
github.com/hashicorp/errwrap v1.0.0 h1:hLrqtEDnRye3+sgx6z4qVLNuviH3MR5aQ0ykNJa/UYA=
github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/go-cleanhttp v0.5.0/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=
github.com/hashicorp/go-cleanhttp v0.5.1/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=
github.com/hashicorp/go-cleanhttp v0.5.2 h1:035FKYIWjmULyFRBKPs8TBQoi0x6d9G4xc9neXJWAZQ=
github.com/hashicorp/go-cleanhttp v0.5.2/go.mod h1:kO/YDlP8L1346E6Sodw+PrpBSV4/SoxCXGY6BqNFT48=
github.com/hashicorp/go-hclog v0.12.0/go.mod h1:whpDNt7SSdeAju8AWKIWsul05p54N/39EeqMAyrmvFQ=
github.com/hashicorp/go-hclog v1.0.0 h1:bkKf0BeBXcSYa7f5Fyi9gMuQ8gNsxeiNpZjR6VxNZeo=
github.com/hashicorp/go-hclog v1.0.0/go.mod h1:whpDNt7SSdeAju8AWKIWsul05p54N/39EeqMAyrmvFQ=
github.com/hashicorp/go-immutable-radix v1.0.0/go.mod h1:0y9vanUI8NX6FsYoO3zeMjhV/C5i9g4Q3DwcSNZ4P60=
github.com/hashicorp/go-immutable-radix v1.3.1 h1:DKHmCUm2hRBK510BaiZlwvpD40f8bJFeZnpfm2KLowc=
github.com/hashicorp/go-immutable-radix v1.3.1/go.mod h1:0y9vanUI8NX6FsYoO3zeMjhV/C5i9g4Q3DwcSNZ4P60=
github.com/hashicorp/go-msgpack v0.5.3 h1:zKjpN5BK/P5lMYrLmBHdBULWbJ0XpYR+7NGzqkZzoD4=
github.com/hashicorp/go-msgpack v0.5.3/go.mod h1:ahLV/dePpqEmjfWmKiqvPkv/twdG7iPBM1vqhUKIvfM=
github.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=
github.com/hashicorp/go-multierror v1.1.0 h1:B9UzwGQJehnUY1yNrnwREHc3fGbC2xefo8g4TbElacI=
github.com/hashicorp/go-multierror v1.1.0/go.mod h1:spPvp8C1qA32ftKqdAHm4hHTbPw+vmowP0z+KUhOZdA=
github.com/hashicorp/go-retryablehttp v0.5.3/go.mod h1:9B5zBasrRhHXnJnui7y6sL7es7NDiJgTc6Er0maI1Xs=
github.com/hashicorp/go-rootcerts v1.0.2 h1:jzhAVGtqPKbwpyCPELlgNWhE1znq+qwJtW5Oi2viEzc=
github.com/hashicorp/go-rootcerts v1.0.2/go.mod h1:pqUvnprVnM5bf7AOirdbb01K4ccR319Vf4pU3K5EGc8=
github.com/hashicorp/go-sockaddr v1.0.0 h1:GeH6tui99pF4NJgfnhp+L6+FfobzVW3Ah46sLo0ICXs=
github.com/hashicorp/go-sockaddr v1.0.0/go.mod h1:7Xibr9yA9JjQq1JpNB2Vw7kxv8xerXegt+ozgdvDeDU=
github.com/hashicorp/go-syslog v1.0.0/go.mod h1:qPfqrKkXGihmCqbJM2mZgkZGvKG1dFdvsLplgctolz4=
github.com/hashicorp/go-uuid v1.0.0/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=
github.com/hashicorp/go-uuid v1.0.1 h1:fv1ep09latC32wFoVwnqcnKJGnMSdBanPczbHAYm1BE=
github.com/hashicorp/go-uuid v1.0.1/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=
github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/hashicorp/golang-lru v0.5.4 h1:YDjusn29QI/Das2iO9M0BHnIbxPeyuCHsjMW+lJfyTc=
github.com/hashicorp/golang-lru v0.5.4/go.mod h1:iADmTwqILo4mZ8BN3D2Q6+9jd8WM5uGBxy+E8yxSoD4=
github.com/hashicorp/hcl/v2 v2.10.0 h1:1S1UnuhDGlv3gRFV4+0EdwB+znNP5HmcGbIqwnSCByg=
github.com/hashicorp/hcl/v2 v2.10.0/go.mod h1:FwWsfWEjyV/CMj8s/gqAuiviY72rJ1/oayI9WftqcKg=
github.com/hashicorp/logutils v1.0.0/go.mod h1:QIAnNjmIWmVIIkWDTG1z5v++HQmx9WQRO+LraFDTW64=
github.com/hashicorp/mdns v1.0.4/go.mod h1:mtBihi+LeNXGtG8L9dX59gAEa12BDtBQSp4v/YAJqrc=
github.com/hashicorp/memberlist v0.3.0 h1:8+567mCcFDnS5ADl7lrpxPMWiFCElyUEeW0gtj34fMA=
github.com/hashicorp/memberlist v0.3.0/go.mod h1:MS2lj3INKhZjWNqd3N0m3J+Jxf3DAOnAH9VT3Sh9MUE=
github.com/hashicorp/serf v0.9.6 h1:uuEX1kLR6aoda1TBttmJQKDLZE1Ob7KN0NPdE7EtCDc=
github.com/hashicorp/serf v0.9.6/go.mod h1:TXZNMjZQijwlDvp+r0b63xZ45H7JmCmgg4gpTwn9UV4=
github.com/iancoleman/strcase v0.2.0/go.mod h1:iwCmte+B7n89clKwxIoIXy/HfoL7AsD47ZCWhYzw7ho=
github.com/imdario/mergo v0.3.12 h1:b6R2BslTbIEToALKP7LxUvijTsNI9TAe80pLWN2g/HU=
github.com/imdario/mergo v0.3.12/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=
github.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=
github.com/json-iterator/go v1.1.9/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=
github.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=
github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=
github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.2.0/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kylelemons/godebug v0.0.0-20170820004349-d65d576e9348 h1:MtvEpTB6LX3vkb4ax0b5D2DHbNAUsen0Gx5wZoq3lV4=
github.com/kylelemons/godebug v0.0.0-20170820004349-d65d576e9348/go.mod h1:B69LEHPfb2qLo0BaaOLcbitczOKLWTsrBG9LczfCD4k=
github.com/lyft/protoc-gen-star v0.6.0/go.mod h1:TGAoBVkt8w7MPG72TrKIu85MIdXwDuzJYeZuUPFPNwA=
github.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=
github.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=
github.com/mattn/go-colorable v0.1.6/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=
github.com/mattn/go-colorable v0.1.9/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=
github.com/mattn/go-colorable v0.1.12 h1:jF+Du6AlPIjs2BiUiQlKOX0rt3SujHxPnksPKZbaA40=
github.com/mattn/go-colorable v0.1.12/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=
github.com/mattn/go-isatty v0.0.3/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=
github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-isatty v0.0.10/go.mod h1:qgIWMr58cqv1PHHyhnkY9lrL7etaEgOFcMEpPG5Rm84=
github.com/mattn/go-isatty v0.0.11/go.mod h1:PhnuNfih5lzO57/f3n+odYbM4JtupLOxQOAqxQCu2WE=
github.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=
github.com/mattn/go-isatty v0.0.14 h1:yVuAays6BHfxijgZPzw+3Zlu5yQgKGP2/hcQbHb7S9Y=
github.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=
github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
github.com/miekg/dns v1.1.26/go.mod h1:bPDLeHnStXmXAq1m/Ch/hvfNHr14JKNPMBo3VZKjuso=
github.com/miekg/dns v1.1.41 h1:WMszZWJG0XmzbK9FEmzH2TVcqYzFesusSIB41b8KHxY=
github.com/miekg/dns v1.1.41/go.mod h1:p6aan82bvRIyn+zDIv9xYNUpwa73JcSh9BKwknJysuI=
github.com/mitchellh/cli v1.1.0/go.mod h1:xcISNoH86gajksDmfB23e/pu+B+GeFRMYmoHXxx3xhI=
github.com/mitchellh/go-homedir v1.1.0 h1:lukF9ziXFxDFPkA1vsr5zpc1XuPDn/wFntq5mG+4E0Y=
github.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
github.com/mitchellh/go-testing-interface v1.0.0 h1:fzU/JVNcaqHQEcVFAKeR41fkiLdIPrefOvVG1VZ96U0=
github.com/mitchellh/go-testing-interface v1.0.0/go.mod h1:kRemZodwjscx+RGhAo8eIhFbs2+BFgRtFPeD/KE+zxI=
github.com/mitchellh/go-wordwrap v0.0.0-20150314170334-ad45545899c7 h1:DpOJ2HYzCv8LZP15IdmG+YdwD2luVPHITV96TkirNBM=
github.com/mitchellh/go-wordwrap v0.0.0-20150314170334-ad45545899c7/go.mod h1:ZXFpozHsX6DPmq2I0TCekCxypsnAUbP2oI0UX1GXzOo=
github.com/mitchellh/mapstructure v0.0.0-20160808181253-ca63d7c062ee/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=
github.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=
github.com/mitchellh/mapstructure v1.4.3 h1:OVowDSCllw/YjdLkam3/sm7wEtOy59d8ndGgCcyj8cs=
github.com/mitchellh/mapstructure v1.4.3/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=
github.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=
github.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
github.com/nxadm/tail v1.4.8 h1:nPr65rt6Y5JFSKQO7qToXr7pePgD6Gwiw05lkbyAQTE=
github.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=
github.com/onsi/gomega v1.18.1 h1:M1GfJqGRrBrrGGsbxzV5dqM2U2ApXefZCQpkukxYRLE=
github.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=
github.com/pascaldekloe/goe v0.1.0 h1:cBOtyMzM9HTpWjXfbbunk26uA6nG3a8n06Wieeh0MwY=
github.com/pascaldekloe/goe v0.1.0/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=
github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=
github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/sftp v1.10.1/go.mod h1:lYOWFsE0bwd1+KfKJaKeuokY15vzFx25BLbzYYoAxZI=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/posener/complete v1.1.1/go.mod h1:em0nMJCgc9GFtwrmVmEMR/ZL6WyhyjMBndrE9hABlRI=
github.com/posener/complete v1.2.3/go.mod h1:WZIdtGGp+qx0sLrYKtIRAruyNpv6hFCicSgv7Sy7s/s=
github.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=
github.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=
github.com/prometheus/client_golang v1.4.0/go.mod h1:e9GMxYsXl05ICDXkRhurwBS4Q3OK1iX/F2sw+iXX5zU=
github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
github.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=
github.com/prometheus/common v0.9.1/go.mod h1:yhUN8i9wzaXS3w1O07YhxHEBxD+W35wd8bs7vj7HSQ4=
github.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=
github.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=
github.com/prometheus/procfs v0.0.8/go.mod h1:7Qr8sr6344vo1JqZ6HhLceV9o3AJ1Ff+GxbHq6oeK9A=
github.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=
github.com/rogpeppe/go-internal v1.8.0 h1:FCbCCtXNOY3UtUuHUYaghJg4y7Fd14rXifAYUAtL9R8=
github.com/ryanuber/columnize v0.0.0-20160712163229-9b3edd62028f/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=
github.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529 h1:nn5Wsu0esKSJiIVhscUtVbo7ada43DJhG55ua/hjS5I=
github.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529/go.mod h1:DxrIzT+xaE7yg65j358z/aeFdxmN0P9QXhEzd20vsDc=
github.com/sergi/go-diff v1.0.0 h1:Kpca3qRNrduNnOQeazBd0ysaKrUJiIuISHxogkT9RPQ=
github.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=
github.com/shirou/gopsutil/v3 v3.21.8 h1:nKct+uP0TV8DjjNiHanKf8SAuub+GNsbrOtM9Nl9biA=
github.com/shirou/gopsutil/v3 v3.21.8/go.mod h1:YWp/H8Qs5fVmf17v7JNZzA0mPJ+mS2e9JdiUF9LlKzQ=
github.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=
github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=
github.com/spf13/afero v1.3.3/go.mod h1:5KUK8ByomD5Ti5Artl0RtHeI5pTF7MIDuXL3yY520V4=
github.com/spf13/afero v1.6.0/go.mod h1:Ai8FlHk4v/PARR026UzYexafAt9roJ7LcLMAmO6Z93I=
github.com/spf13/pflag v1.0.2/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.2.0 h1:Hbg2NidpLE8veEBkEZTL3CvlkUIVzuU9jDplZO54c48=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1 h1:5TQK59W5E3v0r2duFAb7P95B6hEeOyEnHRa8MjYSMTY=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/tklauser/go-sysconf v0.3.9 h1:JeUVdAOWhhxVcU6Eqr/ATFHgXk/mmiItdKeJPev3vTo=
github.com/tklauser/go-sysconf v0.3.9/go.mod h1:11DU/5sG7UexIrp/O6g35hrWzu0JxlwQ3LSFUzyeuhs=
github.com/tklauser/numcpus v0.3.0 h1:ILuRUQBtssgnxw0XXIjKUC56fgnOrFoQQ/4+DeU2biQ=
github.com/tklauser/numcpus v0.3.0/go.mod h1:yFGUr7TUHQRAhyqBcEg0Ge34zDBAsIvJJcyE6boqnA8=
github.com/tv42/httpunix v0.0.0-20150427012821-b75d8614f926/go.mod h1:9ESjWnEqriFuLhtthL60Sar/7RFoluCcXsuvEwTV5KM=
github.com/vmihailenco/msgpack v3.3.3+incompatible/go.mod h1:fy3FlTQTDXWkZ7Bh6AcGMlsjHatGryHQYUTf1ShIgkk=
github.com/vmihailenco/msgpack/v4 v4.3.12/go.mod h1:gborTTJjAo/GWTqqRjrLCn9pgNN+NXzzngzBKDPIqw4=
github.com/vmihailenco/tagparser v0.1.1/go.mod h1:OeAg3pn3UbLjkWt+rN9oFYB6u/cQgqMEUPoW2WPyhdI=
github.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=
github.com/zclconf/go-cty v1.2.0/go.mod h1:hOPWgoHbaTUnI5k4D2ld+GRpFJSCe6bCM7m1q/N4PQ8=
github.com/zclconf/go-cty v1.8.0 h1:s4AvqaeQzJIu3ndv4gVIhplVD0krU+bgrcLSVUnaWuA=
github.com/zclconf/go-cty v1.8.0/go.mod h1:vVKLxnk3puL4qRAv72AO+W99LUD4da90g3uUAzyuvAk=
github.com/zclconf/go-cty-debug v0.0.0-20191215020915-b22d67c1ba0b/go.mod h1:ZRKQfBXbGkpdV6QMzT3rU1kSTAnfu1dO8dPKjYprgj8=
go.opentelemetry.io/otel v1.7.0 h1:Z2lA3Tdch0iDcrhJXDIlC94XE+bxok1F9B+4Lz/lGsM=
go.opentelemetry.io/otel v1.7.0/go.mod h1:5BdUoMIz5WEs0vt0CUEMtSSaTSHBBVwrhnz7+nrD5xk=
go.opentelemetry.io/otel/sdk v1.7.0 h1:4OmStpcKVOfvDOgCt7UriAPtKolwIhxpnSNI/yK+1B0=
go.opentelemetry.io/otel/sdk v1.7.0/go.mod h1:uTEOTwaqIVuTGiJN7ii13Ibp75wJmYUDe374q6cZwUU=
go.opentelemetry.io/otel/trace v1.7.0 h1:O37Iogk1lEkMRXewVtZ1BBTVn5JEp8GrJvP92bJqC6o=
go.opentelemetry.io/otel/trace v1.7.0/go.mod h1:fzLSB9nqR2eXzxPXb2JW9IKE+ScyXA48yyE4TNvoHqU=
go.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=
golang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190426145343-a29dc8fdc734/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190923035154-9ee001bba392/go.mod h1:/lpIB1dKB+9EgE3H3cr1v9wB50oz8l4C4h62xy7jSTY=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20220525230936-793ad666bf5e h1:T8NU3HyQ8ClP4SEE+KbFlg6n0NhuTsN4MyznaarGsZM=
golang.org/x/crypto v0.0.0-20220525230936-793ad666bf5e/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20210508222113-6edffad5e616/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.5.0/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=
golang.org/x/mod v0.5.1 h1:OJxoQ/rynoF0dcCdI7cLPktw/hR2cueqYfjm43oqK38=
golang.org/x/mod v0.5.1/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180811021610-c39426892332/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
golang.org/x/net v0.0.0-20190613194153-d28f0bde5980/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190923162816-aa69164e4478/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=
golang.org/x/net v0.0.0-20210410081132-afb366fc7cd1/go.mod h1:9tjilg8BloeKEkVJvy7fQ90B1CfIiPueXVOjqfkSzI8=
golang.org/x/net v0.0.0-20210813160813-60bc85c4be6d/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd h1:O7DYs+zxREGLKzKoMQrtrEacpb0ZVXA5rIwylE2Xchk=
golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220513210516-0976fa681c29 h1:w8s32wxx3sY+OjLlv9qltkLU5yvJzxjjgiHWLjdIcw4=
golang.org/x/sync v0.0.0-20220513210516-0976fa681c29/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20180823144017-11551d06cbcc/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190502175342-a43fa875dd82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190922100055-0a153f010e69/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190924154521-2837fb4f24fe/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191008105621-543471e840be/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200124204421-9fbb57f87de9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210303074136-134d130e1a04/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423185535-09eb48e85fd7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210816074244-15123e1e1f71/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210816183151-1e6c022a8912/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220412211240-33da011f77ad h1:ntjMns5wyP/fN65tdBD4g8J5w8n015+iIIs9rtjXkY0=
golang.org/x/sys v0.0.0-20220412211240-33da011f77ad/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190422233926-fe54fb35175b/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190907020128-2ca718005c18/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd h1:e0TwkXOdbnH/1x5rc5MZ/VYyiZ4v+RdVfrGMqEwT68I=
google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTpR3n0=
google.golang.org/grpc v1.36.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/grpc v1.46.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.46.2/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.47.0 h1:9n77onPX5F3qfFCqjy9dhn8PbNQsIKeVU04J9G7umt8=
google.golang.org/grpc v1.47.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.28.0 h1:w43yiav+6bVFTBQFZX0r7ipe9JQ1QsbMgHwbBziscLw=
google.golang.org/protobuf v1.28.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=
gopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.5/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=

```

`app/bugu/service/internal/biz/artifact.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package biz

import (
	"context"
	"io/ioutil"
	"os"
	"path/filepath"

	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
	"github.com/hominsu/bugu/pkg"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/google/uuid"
)

// Artifact is the model entity for the Artifact schema.
type Artifact struct {
	ID               uuid.UUID `json:"id,omitempty"`
	FileID           uuid.UUID `json:"file_id,omitempty"`
	AffiliatedFileID uuid.UUID `json:"affiliated_file_id,omitempty"`
	Method           string    `json:"method,omitempty"`
}

type ArtifactRepo interface {
	CreateArtifactMetadata(ctx context.Context, userId uuid.UUID, artifact *Artifact) (*Artifact, error)
	UpdateArtifactMetadata(ctx context.Context, artifact *Artifact) (*Artifact, error)
	AppendArtifactMetadataByArtifactFileIdToUser(ctx context.Context, userId, fileId uuid.UUID) (*Artifact, error)
	AppendArtifactMetadataToUser(ctx context.Context, userId, artifactId uuid.UUID) (*Artifact, error)
	GetArtifactMetadata(ctx context.Context, userId, artifactId uuid.UUID) (*Artifact, error)
	GetArtifactMetadataByFileId(ctx context.Context, userId, fileId uuid.UUID) ([]*Artifact, error)
	DeleteArtifactMetadata(ctx context.Context, userId, artifactId uuid.UUID) error
}

type ArtifactUsecase struct {
	ar ArtifactRepo
	or ObfusionRepo
	fr FileRepo

	dc  *conf.Data
	log *log.Helper
}

func NewArtifactUsecase(ar ArtifactRepo, or ObfusionRepo, fr FileRepo, dc *conf.Data, logger log.Logger) *ArtifactUsecase {
	return &ArtifactUsecase{
		ar:  ar,
		or:  or,
		fr:  fr,
		dc:  dc,
		log: log.NewHelper(logger),
	}
}

func (uc *ArtifactUsecase) Confusion(ctx context.Context, userId, fileId string) (*Artifact, error) {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	fid, err := uuid.Parse(fileId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse fileId failed, err: %v", fileId)
	}

	f, cleanup, err := uc.getFile(ctx, userid, fid)
	if err != nil {
		return nil, err
	}
	defer cleanup()

	data, err := ioutil.ReadAll(f)
	if err != nil {
		return nil, err
	}

	dto, err := uc.or.Obfusion(ctx, &Obfusion{
		Data: data,
		Size: uint32(len(data)),
	})
	if err != nil {
		return nil, err
	}

	var artifactMetadata *Artifact

	fileMetadata, ok, err := uc.saveFile(ctx, userid, dto, uc.dc.File.Path)
	if err != nil {
		return nil, err
	}
	if ok {
		artifactMetadata, err = uc.ar.AppendArtifactMetadataByArtifactFileIdToUser(ctx, userid, fileMetadata.ID)
		if err != nil {
			return nil, err
		}
	} else {
		u, err := uuid.NewRandom()
		if err != nil {
			return nil, buguV1.ErrorUuidGenerateFailed("create file uuid failed, err: %v", err)
		}

		artifactMetadata, err = uc.ar.CreateArtifactMetadata(ctx, userid, &Artifact{
			ID:               u,
			FileID:           fileMetadata.ID,
			AffiliatedFileID: fid,
		})
		if err != nil {
			return nil, err
		}
	}

	return artifactMetadata, nil
}

func (uc *ArtifactUsecase) saveFile(ctx context.Context, userId uuid.UUID, oData *Obfusion, dir string) (*File, bool, error) {
	sha1, size, err := pkg.Sha1(oData.Data)
	if err != nil {
		uc.log.Error(err)
		return nil, false, buguV1.ErrorInternalServerError("Internal Server Error")
	}

	var ret *File
	ok := false

	ret, err = uc.fr.QueryByFileSha1(ctx, sha1)
	if err == nil {
		ret, err = uc.fr.AppendFileMetadataToUser(ctx, userId, ret.ID)
		if err != nil {
			return nil, false, err
		}
		ok = true
	} else if err != nil && buguV1.IsNotFoundError(err) {
		u, err := uuid.NewRandom()
		if err != nil {
			return nil, false, buguV1.ErrorUuidGenerateFailed("create file uuid failed, err: %v", err)
		}

		dir = filepath.Join(dir, u.String())

		ok, err := pkg.PathExists(dir)
		if err != nil {
			return nil, false, buguV1.ErrorUnknownError("check file failed, err: %v", err)
		}
		if ok {
			return nil, false, buguV1.ErrorCreateConflict("create file conflict")
		}

		ret, ok, err = uc.fr.CreateFileMetadata(ctx, userId, &File{
			ID:       u,
			FileSha1: sha1,
			FileSize: size,
			FileAddr: dir,
		})
		if err != nil {
			return nil, false, err
		}

		if ok {
			return ret, false, nil
		}

		f, err := os.OpenFile(dir, os.O_RDWR|os.O_CREATE, 0o666)
		if err != nil {
			return nil, false, err
		}
		defer func(f *os.File) {
			err = f.Close()
			if err != nil {
				uc.log.Error(err)
			}
		}(f)

		_, err = f.Write(oData.Data)
		if err != nil {
			return nil, false, err
		}
	} else if err != nil {
		return nil, false, err
	}

	return ret, ok, nil
}

func (uc *ArtifactUsecase) getFile(ctx context.Context, userId, fileId uuid.UUID) (*os.File, func(), error) {
	dto, err := uc.fr.GetFileMetadata(ctx, userId, fileId)
	if err != nil {
		return nil, nil, err
	}

	ok, err := pkg.PathExists(dto.FileAddr)
	if err != nil {
		return nil, nil, buguV1.ErrorUnknownError("check file failed, err: %v", err)
	}
	if !ok {
		return nil, nil, buguV1.ErrorCreateConflict("file not exist")
	}

	f, err := os.OpenFile(dto.FileAddr, os.O_RDONLY, 0)
	if err != nil {
		return nil, nil, err
	}
	return f, func() {
		err := f.Close()
		if err != nil {
			uc.log.Error(err)
		}
	}, nil
}

func (uc *ArtifactUsecase) GetArtifactMetadata(ctx context.Context, userId, artifactId string) (*Artifact, error) {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	aid, err := uuid.Parse(artifactId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse artifactId failed, err: %v", artifactId)
	}

	return uc.ar.GetArtifactMetadata(ctx, userid, aid)
}

func (uc *ArtifactUsecase) GetArtifactMetadataByFileId(ctx context.Context, userId, fileId string) ([]*Artifact, error) {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	fid, err := uuid.Parse(fileId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse fileId failed, err: %v", fileId)
	}

	return uc.ar.GetArtifactMetadataByFileId(ctx, userid, fid)
}

func (uc *ArtifactUsecase) DeleteArtifactMetadata(ctx context.Context, userId, artifactId string) error {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	aid, err := uuid.Parse(artifactId)
	if err != nil {
		return buguV1.ErrorUuidParseFailed("parse artifactId failed, err: %v", artifactId)
	}

	return uc.ar.DeleteArtifactMetadata(ctx, userid, aid)
}

```

`app/bugu/service/internal/biz/biz.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package biz

import "github.com/google/wire"

// ProviderSet is biz providers.
var ProviderSet = wire.NewSet(NewUserUsecase, NewFileUsecase, NewArtifactUsecase, NewObfusionUsecase)

```

`app/bugu/service/internal/biz/file.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package biz

import (
	"context"
	"io"
	"mime/multipart"
	"os"
	"path/filepath"

	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/pkg"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/google/uuid"
)

// File is the model entity for the File schema.
type File struct {
	ID       uuid.UUID  `json:"fileId,omitempty"`
	FileSha1 string     `json:"fileSha1,omitempty"`
	FileSize int64      `json:"fileSize,omitempty"`
	FileAddr string     `json:"fileAddr,omitempty"`
	Type     *file.Type `json:"type,omitempty"`
}

var (
	TypeName = map[int32]file.Type{
		0:  file.TypeAdposhel,
		1:  file.TypeAgent,
		2:  file.TypeAllaple,
		3:  file.TypeAmonetize,
		4:  file.TypeAndrom,
		5:  file.TypeAutorun,
		6:  file.TypeBrowseFox,
		7:  file.TypeDinwod,
		8:  file.TypeElex,
		9:  file.TypeExpiro,
		10: file.TypeFasong,
		11: file.TypeHackKMS,
		12: file.TypeHlux,
		13: file.TypeInjector,
		14: file.TypeInstallCore,
		15: file.TypeMultiPlug,
		16: file.TypeNeoreklami,
		17: file.TypeNeshta,
		18: file.TypeOther,
		19: file.TypeRegrun,
		20: file.TypeSality,
		21: file.TypeSnarasite,
		22: file.TypeStantinko,
		23: file.TypeVBA,
		24: file.TypeVBKrypt,
		25: file.TypeVilsel,
	}

	TypeValue = map[file.Type]int32{
		file.TypeAdposhel:    0,
		file.TypeAgent:       1,
		file.TypeAllaple:     2,
		file.TypeAmonetize:   3,
		file.TypeAndrom:      4,
		file.TypeAutorun:     5,
		file.TypeBrowseFox:   6,
		file.TypeDinwod:      7,
		file.TypeElex:        8,
		file.TypeExpiro:      9,
		file.TypeFasong:      10,
		file.TypeHackKMS:     11,
		file.TypeHlux:        12,
		file.TypeInjector:    13,
		file.TypeInstallCore: 14,
		file.TypeMultiPlug:   15,
		file.TypeNeoreklami:  16,
		file.TypeNeshta:      17,
		file.TypeOther:       18,
		file.TypeRegrun:      19,
		file.TypeSality:      20,
		file.TypeSnarasite:   21,
		file.TypeStantinko:   22,
		file.TypeVBA:         23,
		file.TypeVBKrypt:     24,
		file.TypeVilsel:      25,
	}
)

type FileRepo interface {
	CreateFileMetadata(ctx context.Context, userId uuid.UUID, file *File) (*File, bool, error)
	UpdateFileMetadata(ctx context.Context, file *File) (*File, error)
	AppendFileMetadataToUser(ctx context.Context, userId, fileId uuid.UUID) (*File, error)
	GetFileMetadata(ctx context.Context, userId, fileId uuid.UUID) (*File, error)
	GetFileMetadataByUserId(ctx context.Context, userId uuid.UUID) ([]*File, error)
	DeleteFileMetadata(ctx context.Context, userId, fileId uuid.UUID) error
	QueryByFileSha1(ctx context.Context, sha1 string) (*File, error)
}

type FileUsecase struct {
	repo FileRepo

	log *log.Helper
}

func NewFileUsecase(repo FileRepo, logger log.Logger) *FileUsecase {
	return &FileUsecase{
		repo: repo,
		log:  log.NewHelper(logger),
	}
}

func (uc *FileUsecase) SaveFile(ctx context.Context, userId string, metaFile multipart.File, dir string) (*File, error) {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	u, err := uuid.NewRandom()
	if err != nil {
		return nil, buguV1.ErrorUuidGenerateFailed("create file uuid failed, err: %v", err)
	}

	dir = filepath.Join(dir, u.String())

	ok, err := pkg.PathExists(dir)
	if err != nil {
		return nil, buguV1.ErrorUnknownError("check file failed, err: %v", err)
	}
	if ok {
		return nil, buguV1.ErrorCreateConflict("create file conflict")
	}

	sha1, size, err := pkg.IOSha1(metaFile)
	if err != nil {
		uc.log.Error(err)
		return nil, buguV1.ErrorInternalServerError("Internal Server Error")
	}

	_, err = metaFile.Seek(0, 0)
	if err != nil {
		uc.log.Error(err)
		return nil, buguV1.ErrorInternalServerError("Internal Server Error")
	}

	dto, ok, err := uc.repo.CreateFileMetadata(ctx, userid, &File{
		ID:       u,
		FileSha1: sha1,
		FileSize: size,
		FileAddr: dir,
	})
	if err != nil {
		return nil, err
	}

	if ok {
		return dto, nil
	}

	f, err := os.OpenFile(dir, os.O_RDWR|os.O_CREATE, 0o666)
	if err != nil {
		return nil, err
	}
	defer func(f *os.File) {
		err = f.Close()
		if err != nil {
			uc.log.Error(err)
		}
	}(f)

	_, err = io.Copy(f, metaFile)
	if err != nil {
		return nil, err
	}

	return dto, nil
}

func (uc *FileUsecase) GetFile(ctx context.Context, userId, fileId string) (*os.File, func(), error) {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return nil, nil, buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	fid, err := uuid.Parse(fileId)
	if err != nil {
		return nil, nil, buguV1.ErrorUuidParseFailed("parse fileId failed, err: %v", fileId)
	}

	dto, err := uc.repo.GetFileMetadata(ctx, userid, fid)
	if err != nil {
		return nil, nil, err
	}

	ok, err := pkg.PathExists(dto.FileAddr)
	if err != nil {
		return nil, nil, buguV1.ErrorUnknownError("check file failed, err: %v", err)
	}
	if !ok {
		return nil, nil, buguV1.ErrorCreateConflict("file not exist")
	}

	f, err := os.OpenFile(dto.FileAddr, os.O_RDONLY, 0)
	if err != nil {
		return nil, nil, err
	}
	return f, func() {
		err := f.Close()
		if err != nil {
			uc.log.Error(err)
		}
	}, nil
}

func (uc *FileUsecase) GetFileMetadata(ctx context.Context, userId, fileId string) (*File, error) {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	fid, err := uuid.Parse(fileId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse fileId failed, err: %v", fileId)
	}

	return uc.repo.GetFileMetadata(ctx, userid, fid)
}

func (uc *FileUsecase) GetFileMetadataByUserId(ctx context.Context, userId string) ([]*File, error) {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	return uc.repo.GetFileMetadataByUserId(ctx, userid)
}

func (uc *FileUsecase) DeleteFileMetadata(ctx context.Context, userId, fileId string) error {
	userid, err := uuid.Parse(userId)
	if err != nil {
		return buguV1.ErrorUuidParseFailed("parse userId failed, err: %v", userId)
	}

	fid, err := uuid.Parse(fileId)
	if err != nil {
		return buguV1.ErrorUuidParseFailed("parse fileId failed, err: %v", fileId)
	}

	return uc.repo.DeleteFileMetadata(ctx, userid, fid)
}

```

`app/bugu/service/internal/biz/obfusion.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package biz

import (
	"context"

	"github.com/go-kratos/kratos/v2/log"
)

type Obfusion struct {
	Data []byte `json:"data,omitempty"`
	Size uint32 `json:"size,omitempty"`
}

type ObfusionRepo interface {
	Obfusion(ctx context.Context, data *Obfusion) (*Obfusion, error)
}

type ObfusionUsecase struct {
	repo ObfusionRepo

	log *log.Helper
}

func NewObfusionUsecase(repo ObfusionRepo, logger log.Logger) *ObfusionUsecase {
	return &ObfusionUsecase{
		repo: repo,
		log:  log.NewHelper(logger),
	}
}

func (uc *ObfusionUsecase) Obfusion(ctx context.Context, data *Obfusion) (*Obfusion, error) {
	return uc.repo.Obfusion(ctx, data)
}

```

`app/bugu/service/internal/biz/packer.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package biz

import (
	"context"

	"github.com/go-kratos/kratos/v2/log"
)

type Packer struct {
	Data []byte `json:"data,omitempty"`
	Size uint32 `json:"size,omitempty"`
}

type PackerRepo interface {
	Packer(ctx context.Context, data *Packer) (*Packer, error)
}

type PackerUsecase struct {
	repo PackerRepo

	log *log.Helper
}

func NewPackerUsecase(repo PackerRepo, loggger log.Logger) *PackerUsecase {
	return &PackerUsecase{
		repo: repo,
		log:  log.NewHelper(loggger),
	}
}

func (uc *PackerUsecase) Packer(ctx context.Context, data *Packer) (*Packer, error) {
	return uc.repo.Packer(ctx, data)
}

```

`app/bugu/service/internal/biz/user.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package biz

import (
	"context"

	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
	"github.com/hominsu/bugu/app/bugu/service/internal/pkg/middleware/auth"
	"github.com/hominsu/bugu/pkg"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/google/uuid"
)

// User is the model entity for the User schema.
type User struct {
	ID           uuid.UUID `json:"id,omitempty"`
	Email        string    `json:"email,omitempty"`
	Username     string    `json:"username,omitempty"`
	PasswordHash string    `json:"password_hash,omitempty"`
	Token        string    `json:"token,omitempty"`
}

type UserRepo interface {
	CreateUser(ctx context.Context, user *User) (*User, error)
	UpdateUser(ctx context.Context, user *User) (*User, error)
	GetUserByID(ctx context.Context, id uuid.UUID) (*User, error)
	FineUserByEmail(ctx context.Context, email string) (*User, error)
}

type UserUsecase struct {
	repo UserRepo
	jc   *conf.Jwt

	log *log.Helper
}

func NewUserUsecase(repo UserRepo, jc *conf.Jwt, logger log.Logger) *UserUsecase {
	return &UserUsecase{
		repo: repo,
		jc:   jc,
		log:  log.NewHelper(logger),
	}
}

func (uc *UserUsecase) Login(ctx context.Context, email, password string) (*User, error) {
	dto, err := uc.repo.FineUserByEmail(ctx, email)
	if err != nil {
		return nil, err
	}

	if !pkg.VerifyPassword(dto.PasswordHash, password) {
		return nil, buguV1.ErrorLoginFailed("Verify password failed")
	}

	token, err := auth.GenerateToken(uc.jc.Secret, dto.ID.String())
	if err != nil {
		return nil, err
	}
	dto.Token = token

	return dto, err
}

func (uc *UserUsecase) Register(ctx context.Context, email, username, password string) (*User, error) {
	ph, err := pkg.HashPassword(password)
	if err != nil {
		return nil, err
	}

	user := &User{
		Email:        email,
		Username:     username,
		PasswordHash: ph,
	}

	a, err := uc.repo.CreateUser(ctx, user)
	if err != nil {
		return nil, err
	}

	return a, nil
}

func (uc *UserUsecase) UpdateUser(ctx context.Context, id, email, username, password string) (*User, error) {
	u, err := uuid.Parse(id)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse userid failed, id: %s", id)
	}

	user := &User{
		ID:       u,
		Email:    email,
		Username: username,
	}

	if password != "" {
		ph, err := pkg.HashPassword(password)
		if err != nil {
			return nil, err
		}
		user.PasswordHash = ph
	}

	return uc.repo.UpdateUser(ctx, user)
}

func (uc *UserUsecase) GetUserByID(ctx context.Context, id uuid.UUID) (*User, error) {
	return uc.repo.GetUserByID(ctx, id)
}

```

`app/bugu/service/internal/conf/conf.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.19.4
// source: internal/conf/conf.proto

package conf

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Bootstrap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Server *Server `protobuf:"bytes,1,opt,name=server,proto3" json:"server,omitempty"`
	Data   *Data   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Jwt    *Jwt    `protobuf:"bytes,3,opt,name=jwt,proto3" json:"jwt,omitempty"`
}

func (x *Bootstrap) Reset() {
	*x = Bootstrap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Bootstrap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Bootstrap) ProtoMessage() {}

func (x *Bootstrap) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Bootstrap.ProtoReflect.Descriptor instead.
func (*Bootstrap) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{0}
}

func (x *Bootstrap) GetServer() *Server {
	if x != nil {
		return x.Server
	}
	return nil
}

func (x *Bootstrap) GetData() *Data {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *Bootstrap) GetJwt() *Jwt {
	if x != nil {
		return x.Jwt
	}
	return nil
}

type Server struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Http *Server_HTTP `protobuf:"bytes,1,opt,name=http,proto3" json:"http,omitempty"`
}

func (x *Server) Reset() {
	*x = Server{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Server) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Server) ProtoMessage() {}

func (x *Server) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Server.ProtoReflect.Descriptor instead.
func (*Server) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{1}
}

func (x *Server) GetHttp() *Server_HTTP {
	if x != nil {
		return x.Http
	}
	return nil
}

type Data struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Database *Data_Database `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Redis    *Data_Redis    `protobuf:"bytes,2,opt,name=redis,proto3" json:"redis,omitempty"`
	File     *Data_File     `protobuf:"bytes,3,opt,name=file,proto3" json:"file,omitempty"`
}

func (x *Data) Reset() {
	*x = Data{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data) ProtoMessage() {}

func (x *Data) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{2}
}

func (x *Data) GetDatabase() *Data_Database {
	if x != nil {
		return x.Database
	}
	return nil
}

func (x *Data) GetRedis() *Data_Redis {
	if x != nil {
		return x.Redis
	}
	return nil
}

func (x *Data) GetFile() *Data_File {
	if x != nil {
		return x.File
	}
	return nil
}

type Jwt struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Secret string `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (x *Jwt) Reset() {
	*x = Jwt{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Jwt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Jwt) ProtoMessage() {}

func (x *Jwt) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Jwt.ProtoReflect.Descriptor instead.
func (*Jwt) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{3}
}

func (x *Jwt) GetSecret() string {
	if x != nil {
		return x.Secret
	}
	return ""
}

type Registry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Consul *Registry_Consul `protobuf:"bytes,1,opt,name=consul,proto3" json:"consul,omitempty"`
}

func (x *Registry) Reset() {
	*x = Registry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Registry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Registry) ProtoMessage() {}

func (x *Registry) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Registry.ProtoReflect.Descriptor instead.
func (*Registry) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{4}
}

func (x *Registry) GetConsul() *Registry_Consul {
	if x != nil {
		return x.Consul
	}
	return nil
}

type Tracer struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Aliyun *Tracer_Aliyun `protobuf:"bytes,1,opt,name=aliyun,proto3" json:"aliyun,omitempty"`
}

func (x *Tracer) Reset() {
	*x = Tracer{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Tracer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tracer) ProtoMessage() {}

func (x *Tracer) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tracer.ProtoReflect.Descriptor instead.
func (*Tracer) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{5}
}

func (x *Tracer) GetAliyun() *Tracer_Aliyun {
	if x != nil {
		return x.Aliyun
	}
	return nil
}

type Log struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Aliyun *Log_Aliyun `protobuf:"bytes,1,opt,name=aliyun,proto3" json:"aliyun,omitempty"`
}

func (x *Log) Reset() {
	*x = Log{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Log) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Log) ProtoMessage() {}

func (x *Log) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Log.ProtoReflect.Descriptor instead.
func (*Log) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{6}
}

func (x *Log) GetAliyun() *Log_Aliyun {
	if x != nil {
		return x.Aliyun
	}
	return nil
}

type Server_HTTP struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Network string               `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Addr    string               `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	Timeout *durationpb.Duration `protobuf:"bytes,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (x *Server_HTTP) Reset() {
	*x = Server_HTTP{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Server_HTTP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Server_HTTP) ProtoMessage() {}

func (x *Server_HTTP) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Server_HTTP.ProtoReflect.Descriptor instead.
func (*Server_HTTP) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{1, 0}
}

func (x *Server_HTTP) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *Server_HTTP) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *Server_HTTP) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

type Server_GRPC struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Network string               `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Addr    string               `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	Timeout *durationpb.Duration `protobuf:"bytes,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (x *Server_GRPC) Reset() {
	*x = Server_GRPC{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Server_GRPC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Server_GRPC) ProtoMessage() {}

func (x *Server_GRPC) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Server_GRPC.ProtoReflect.Descriptor instead.
func (*Server_GRPC) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{1, 1}
}

func (x *Server_GRPC) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *Server_GRPC) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *Server_GRPC) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

type Data_Database struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Driver string `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
	Source string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
}

func (x *Data_Database) Reset() {
	*x = Data_Database{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data_Database) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data_Database) ProtoMessage() {}

func (x *Data_Database) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data_Database.ProtoReflect.Descriptor instead.
func (*Data_Database) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{2, 0}
}

func (x *Data_Database) GetDriver() string {
	if x != nil {
		return x.Driver
	}
	return ""
}

func (x *Data_Database) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

type Data_Redis struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Network         string               `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Addr            string               `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	Password        string               `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Db              int32                `protobuf:"varint,4,opt,name=db,proto3" json:"db,omitempty"`
	CacheExpiration *durationpb.Duration `protobuf:"bytes,5,opt,name=cache_expiration,json=cacheExpiration,proto3" json:"cache_expiration,omitempty"`
	ReadTimeout     *durationpb.Duration `protobuf:"bytes,6,opt,name=read_timeout,json=readTimeout,proto3" json:"read_timeout,omitempty"`
	WriteTimeout    *durationpb.Duration `protobuf:"bytes,7,opt,name=write_timeout,json=writeTimeout,proto3" json:"write_timeout,omitempty"`
}

func (x *Data_Redis) Reset() {
	*x = Data_Redis{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data_Redis) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data_Redis) ProtoMessage() {}

func (x *Data_Redis) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data_Redis.ProtoReflect.Descriptor instead.
func (*Data_Redis) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{2, 1}
}

func (x *Data_Redis) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *Data_Redis) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

func (x *Data_Redis) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *Data_Redis) GetDb() int32 {
	if x != nil {
		return x.Db
	}
	return 0
}

func (x *Data_Redis) GetCacheExpiration() *durationpb.Duration {
	if x != nil {
		return x.CacheExpiration
	}
	return nil
}

func (x *Data_Redis) GetReadTimeout() *durationpb.Duration {
	if x != nil {
		return x.ReadTimeout
	}
	return nil
}

func (x *Data_Redis) GetWriteTimeout() *durationpb.Duration {
	if x != nil {
		return x.WriteTimeout
	}
	return nil
}

type Data_File struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
}

func (x *Data_File) Reset() {
	*x = Data_File{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data_File) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data_File) ProtoMessage() {}

func (x *Data_File) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data_File.ProtoReflect.Descriptor instead.
func (*Data_File) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{2, 2}
}

func (x *Data_File) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type Registry_Consul struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Scheme  string `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
}

func (x *Registry_Consul) Reset() {
	*x = Registry_Consul{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Registry_Consul) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Registry_Consul) ProtoMessage() {}

func (x *Registry_Consul) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Registry_Consul.ProtoReflect.Descriptor instead.
func (*Registry_Consul) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{4, 0}
}

func (x *Registry_Consul) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Registry_Consul) GetScheme() string {
	if x != nil {
		return x.Scheme
	}
	return ""
}

type Registry_Polaris struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Addresses []string `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
	Namespace string   `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Token     string   `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *Registry_Polaris) Reset() {
	*x = Registry_Polaris{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Registry_Polaris) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Registry_Polaris) ProtoMessage() {}

func (x *Registry_Polaris) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Registry_Polaris.ProtoReflect.Descriptor instead.
func (*Registry_Polaris) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{4, 1}
}

func (x *Registry_Polaris) GetAddresses() []string {
	if x != nil {
		return x.Addresses
	}
	return nil
}

func (x *Registry_Polaris) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *Registry_Polaris) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type Tracer_Aliyun struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TraceEndpoint   string `protobuf:"bytes,1,opt,name=trace_endpoint,json=traceEndpoint,proto3" json:"trace_endpoint,omitempty"`
	MetricEndpoint  string `protobuf:"bytes,2,opt,name=metric_endpoint,json=metricEndpoint,proto3" json:"metric_endpoint,omitempty"`
	Project         string `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty"`
	InstanceId      string `protobuf:"bytes,4,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	AccessKeyId     string `protobuf:"bytes,5,opt,name=access_key_id,json=accessKeyId,proto3" json:"access_key_id,omitempty"`
	AccessKeySecret string `protobuf:"bytes,6,opt,name=access_key_secret,json=accessKeySecret,proto3" json:"access_key_secret,omitempty"`
}

func (x *Tracer_Aliyun) Reset() {
	*x = Tracer_Aliyun{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Tracer_Aliyun) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tracer_Aliyun) ProtoMessage() {}

func (x *Tracer_Aliyun) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tracer_Aliyun.ProtoReflect.Descriptor instead.
func (*Tracer_Aliyun) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{5, 0}
}

func (x *Tracer_Aliyun) GetTraceEndpoint() string {
	if x != nil {
		return x.TraceEndpoint
	}
	return ""
}

func (x *Tracer_Aliyun) GetMetricEndpoint() string {
	if x != nil {
		return x.MetricEndpoint
	}
	return ""
}

func (x *Tracer_Aliyun) GetProject() string {
	if x != nil {
		return x.Project
	}
	return ""
}

func (x *Tracer_Aliyun) GetInstanceId() string {
	if x != nil {
		return x.InstanceId
	}
	return ""
}

func (x *Tracer_Aliyun) GetAccessKeyId() string {
	if x != nil {
		return x.AccessKeyId
	}
	return ""
}

func (x *Tracer_Aliyun) GetAccessKeySecret() string {
	if x != nil {
		return x.AccessKeySecret
	}
	return ""
}

type Log_Aliyun struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Endpoint        string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Project         string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
	Logstore        string `protobuf:"bytes,3,opt,name=logstore,proto3" json:"logstore,omitempty"`
	AccessKeyId     string `protobuf:"bytes,4,opt,name=access_key_id,json=accessKeyId,proto3" json:"access_key_id,omitempty"`
	AccessKeySecret string `protobuf:"bytes,5,opt,name=access_key_secret,json=accessKeySecret,proto3" json:"access_key_secret,omitempty"`
}

func (x *Log_Aliyun) Reset() {
	*x = Log_Aliyun{}
	if protoimpl.UnsafeEnabled {
		mi := &file_internal_conf_conf_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Log_Aliyun) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Log_Aliyun) ProtoMessage() {}

func (x *Log_Aliyun) ProtoReflect() protoreflect.Message {
	mi := &file_internal_conf_conf_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Log_Aliyun.ProtoReflect.Descriptor instead.
func (*Log_Aliyun) Descriptor() ([]byte, []int) {
	return file_internal_conf_conf_proto_rawDescGZIP(), []int{6, 0}
}

func (x *Log_Aliyun) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Log_Aliyun) GetProject() string {
	if x != nil {
		return x.Project
	}
	return ""
}

func (x *Log_Aliyun) GetLogstore() string {
	if x != nil {
		return x.Logstore
	}
	return ""
}

func (x *Log_Aliyun) GetAccessKeyId() string {
	if x != nil {
		return x.AccessKeyId
	}
	return ""
}

func (x *Log_Aliyun) GetAccessKeySecret() string {
	if x != nil {
		return x.AccessKeySecret
	}
	return ""
}

var File_internal_conf_conf_proto protoreflect.FileDescriptor

var file_internal_conf_conf_proto_rawDesc = []byte{
	0x0a, 0x18, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x2f,
	0x63, 0x6f, 0x6e, 0x66, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x6b, 0x72, 0x61, 0x74,
	0x6f, 0x73, 0x2e, 0x61, 0x70, 0x69, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x80, 0x01, 0x0a, 0x09, 0x42, 0x6f, 0x6f, 0x74, 0x73,
	0x74, 0x72, 0x61, 0x70, 0x12, 0x2a, 0x0a, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x52, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
	0x12, 0x24, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10,
	0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x44, 0x61, 0x74, 0x61,
	0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12, 0x21, 0x0a, 0x03, 0x6a, 0x77, 0x74, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x4a, 0x77, 0x74, 0x52, 0x03, 0x6a, 0x77, 0x74, 0x22, 0x8b, 0x02, 0x0a, 0x06, 0x53, 0x65,
	0x72, 0x76, 0x65, 0x72, 0x12, 0x2b, 0x0a, 0x04, 0x68, 0x74, 0x74, 0x70, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2e, 0x48, 0x54, 0x54, 0x50, 0x52, 0x04, 0x68, 0x74, 0x74,
	0x70, 0x1a, 0x69, 0x0a, 0x04, 0x48, 0x54, 0x54, 0x50, 0x12, 0x18, 0x0a, 0x07, 0x6e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x64, 0x64, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x04, 0x61, 0x64, 0x64, 0x72, 0x12, 0x33, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f,
	0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x1a, 0x69, 0x0a, 0x04,
	0x47, 0x52, 0x50, 0x43, 0x12, 0x18, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x12,
	0x0a, 0x04, 0x61, 0x64, 0x64, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x61, 0x64,
	0x64, 0x72, 0x12, 0x33, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x07,
	0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x22, 0x96, 0x04, 0x0a, 0x04, 0x44, 0x61, 0x74, 0x61,
	0x12, 0x35, 0x0a, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x44, 0x61, 0x74, 0x61, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x52, 0x08, 0x64,
	0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x05, 0x72, 0x65, 0x64, 0x69, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x2e, 0x52, 0x65, 0x64, 0x69, 0x73, 0x52, 0x05,
	0x72, 0x65, 0x64, 0x69, 0x73, 0x12, 0x29, 0x0a, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x44, 0x61, 0x74, 0x61, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x04, 0x66, 0x69, 0x6c, 0x65,
	0x1a, 0x3a, 0x0a, 0x08, 0x44, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06,
	0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x64, 0x72,
	0x69, 0x76, 0x65, 0x72, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x1a, 0xa5, 0x02, 0x0a,
	0x05, 0x52, 0x65, 0x64, 0x69, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x12, 0x12, 0x0a, 0x04, 0x61, 0x64, 0x64, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x61, 0x64, 0x64, 0x72, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64,
	0x12, 0x0e, 0x0a, 0x02, 0x64, 0x62, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x64, 0x62,
	0x12, 0x44, 0x0a, 0x10, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x45, 0x78, 0x70, 0x69,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3c, 0x0a, 0x0c, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74,
	0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x72, 0x65, 0x61, 0x64, 0x54, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x12, 0x3e, 0x0a, 0x0d, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x77, 0x72, 0x69, 0x74, 0x65, 0x54, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x1a, 0x1a, 0x0a, 0x04, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x12, 0x0a, 0x04,
	0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68,
	0x22, 0x1d, 0x0a, 0x03, 0x4a, 0x77, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x65, 0x63, 0x72, 0x65,
	0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22,
	0xd8, 0x01, 0x0a, 0x08, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x12, 0x33, 0x0a, 0x06,
	0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6b,
	0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74,
	0x72, 0x79, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6c, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x73, 0x75,
	0x6c, 0x1a, 0x3a, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x73, 0x75, 0x6c, 0x12, 0x18, 0x0a, 0x07, 0x61,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x1a, 0x5b, 0x0a,
	0x07, 0x50, 0x6f, 0x6c, 0x61, 0x72, 0x69, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70,
	0x61, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73,
	0x70, 0x61, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0xa1, 0x02, 0x0a, 0x06, 0x54,
	0x72, 0x61, 0x63, 0x65, 0x72, 0x12, 0x31, 0x0a, 0x06, 0x61, 0x6c, 0x69, 0x79, 0x75, 0x6e, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x54, 0x72, 0x61, 0x63, 0x65, 0x72, 0x2e, 0x41, 0x6c, 0x69, 0x79, 0x75, 0x6e,
	0x52, 0x06, 0x61, 0x6c, 0x69, 0x79, 0x75, 0x6e, 0x1a, 0xe3, 0x01, 0x0a, 0x06, 0x41, 0x6c, 0x69,
	0x79, 0x75, 0x6e, 0x12, 0x25, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x65, 0x6e, 0x64,
	0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x74, 0x72, 0x61,
	0x63, 0x65, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x27, 0x0a, 0x0f, 0x6d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x45, 0x6e, 0x64, 0x70, 0x6f,
	0x69, 0x6e, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x1f, 0x0a,
	0x0b, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0a, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x49, 0x64, 0x12, 0x22,
	0x0a, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x69, 0x64, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4b, 0x65, 0x79,
	0x49, 0x64, 0x12, 0x2a, 0x0a, 0x11, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x6b, 0x65, 0x79,
	0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x61,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x4b, 0x65, 0x79, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0xe2,
	0x01, 0x0a, 0x03, 0x4c, 0x6f, 0x67, 0x12, 0x2e, 0x0a, 0x06, 0x61, 0x6c, 0x69, 0x79, 0x75, 0x6e,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6b, 0x72, 0x61, 0x74, 0x6f, 0x73, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x4c, 0x6f, 0x67, 0x2e, 0x41, 0x6c, 0x69, 0x79, 0x75, 0x6e, 0x52, 0x06,
	0x61, 0x6c, 0x69, 0x79, 0x75, 0x6e, 0x1a, 0xaa, 0x01, 0x0a, 0x06, 0x41, 0x6c, 0x69, 0x79, 0x75,
	0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x12, 0x18, 0x0a,
	0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x6f, 0x67, 0x73, 0x74,
	0x6f, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6c, 0x6f, 0x67, 0x73, 0x74,
	0x6f, 0x72, 0x65, 0x12, 0x22, 0x0a, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x6b, 0x65,
	0x79, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x63, 0x63, 0x65,
	0x73, 0x73, 0x4b, 0x65, 0x79, 0x49, 0x64, 0x12, 0x2a, 0x0a, 0x11, 0x61, 0x63, 0x63, 0x65, 0x73,
	0x73, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0f, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4b, 0x65, 0x79, 0x53, 0x65, 0x63,
	0x72, 0x65, 0x74, 0x42, 0x22, 0x5a, 0x20, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x2f, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x63, 0x6f,
	0x6e, 0x66, 0x3b, 0x63, 0x6f, 0x6e, 0x66, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_internal_conf_conf_proto_rawDescOnce sync.Once
	file_internal_conf_conf_proto_rawDescData = file_internal_conf_conf_proto_rawDesc
)

func file_internal_conf_conf_proto_rawDescGZIP() []byte {
	file_internal_conf_conf_proto_rawDescOnce.Do(func() {
		file_internal_conf_conf_proto_rawDescData = protoimpl.X.CompressGZIP(file_internal_conf_conf_proto_rawDescData)
	})
	return file_internal_conf_conf_proto_rawDescData
}

var file_internal_conf_conf_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_internal_conf_conf_proto_goTypes = []interface{}{
	(*Bootstrap)(nil),           // 0: kratos.api.Bootstrap
	(*Server)(nil),              // 1: kratos.api.Server
	(*Data)(nil),                // 2: kratos.api.Data
	(*Jwt)(nil),                 // 3: kratos.api.Jwt
	(*Registry)(nil),            // 4: kratos.api.Registry
	(*Tracer)(nil),              // 5: kratos.api.Tracer
	(*Log)(nil),                 // 6: kratos.api.Log
	(*Server_HTTP)(nil),         // 7: kratos.api.Server.HTTP
	(*Server_GRPC)(nil),         // 8: kratos.api.Server.GRPC
	(*Data_Database)(nil),       // 9: kratos.api.Data.Database
	(*Data_Redis)(nil),          // 10: kratos.api.Data.Redis
	(*Data_File)(nil),           // 11: kratos.api.Data.File
	(*Registry_Consul)(nil),     // 12: kratos.api.Registry.Consul
	(*Registry_Polaris)(nil),    // 13: kratos.api.Registry.Polaris
	(*Tracer_Aliyun)(nil),       // 14: kratos.api.Tracer.Aliyun
	(*Log_Aliyun)(nil),          // 15: kratos.api.Log.Aliyun
	(*durationpb.Duration)(nil), // 16: google.protobuf.Duration
}
var file_internal_conf_conf_proto_depIdxs = []int32{
	1,  // 0: kratos.api.Bootstrap.server:type_name -> kratos.api.Server
	2,  // 1: kratos.api.Bootstrap.data:type_name -> kratos.api.Data
	3,  // 2: kratos.api.Bootstrap.jwt:type_name -> kratos.api.Jwt
	7,  // 3: kratos.api.Server.http:type_name -> kratos.api.Server.HTTP
	9,  // 4: kratos.api.Data.database:type_name -> kratos.api.Data.Database
	10, // 5: kratos.api.Data.redis:type_name -> kratos.api.Data.Redis
	11, // 6: kratos.api.Data.file:type_name -> kratos.api.Data.File
	12, // 7: kratos.api.Registry.consul:type_name -> kratos.api.Registry.Consul
	14, // 8: kratos.api.Tracer.aliyun:type_name -> kratos.api.Tracer.Aliyun
	15, // 9: kratos.api.Log.aliyun:type_name -> kratos.api.Log.Aliyun
	16, // 10: kratos.api.Server.HTTP.timeout:type_name -> google.protobuf.Duration
	16, // 11: kratos.api.Server.GRPC.timeout:type_name -> google.protobuf.Duration
	16, // 12: kratos.api.Data.Redis.cache_expiration:type_name -> google.protobuf.Duration
	16, // 13: kratos.api.Data.Redis.read_timeout:type_name -> google.protobuf.Duration
	16, // 14: kratos.api.Data.Redis.write_timeout:type_name -> google.protobuf.Duration
	15, // [15:15] is the sub-list for method output_type
	15, // [15:15] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_internal_conf_conf_proto_init() }
func file_internal_conf_conf_proto_init() {
	if File_internal_conf_conf_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_internal_conf_conf_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Bootstrap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Server); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Jwt); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Registry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Tracer); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Log); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Server_HTTP); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Server_GRPC); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data_Database); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data_Redis); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data_File); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Registry_Consul); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Registry_Polaris); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Tracer_Aliyun); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_internal_conf_conf_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Log_Aliyun); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_internal_conf_conf_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_internal_conf_conf_proto_goTypes,
		DependencyIndexes: file_internal_conf_conf_proto_depIdxs,
		MessageInfos:      file_internal_conf_conf_proto_msgTypes,
	}.Build()
	File_internal_conf_conf_proto = out.File
	file_internal_conf_conf_proto_rawDesc = nil
	file_internal_conf_conf_proto_goTypes = nil
	file_internal_conf_conf_proto_depIdxs = nil
}

```

`app/bugu/service/internal/conf/conf.proto`:

```proto
syntax = "proto3";

package kratos.api;

import "google/protobuf/duration.proto";

option go_package = "ecode/service/internal/conf;conf";

message Bootstrap {
  Server server = 1;
  Data data = 2;
  Jwt jwt = 3;
}

message Server {
  message HTTP {
    string network = 1;
    string addr = 2;
    google.protobuf.Duration timeout = 3;
  }
  message GRPC {
    string network = 1;
    string addr = 2;
    google.protobuf.Duration timeout = 3;
  }
  HTTP http = 1;
}

message Data {
  message Database {
    string driver = 1;
    string source = 2;
  }
  message Redis {
    string network = 1;
    string addr = 2;
    string password = 3;
    int32 db = 4;
    google.protobuf.Duration cache_expiration = 5;
    google.protobuf.Duration read_timeout = 6;
    google.protobuf.Duration write_timeout = 7;
  }
  message File {
    string path = 1;
  }
  Database database = 1;
  Redis redis = 2;
  File file = 3;
}

message Jwt {
  string secret = 1;
}

message Registry {
  message Consul {
    string address = 1;
    string scheme = 2;
  }
  message Polaris {
    repeated string addresses = 1;
    string namespace = 2;
    string token = 3;
  }
  Consul consul = 1;
}

message Tracer {
  message Aliyun {
    string trace_endpoint = 1;
    string metric_endpoint = 2;
    string project = 3;
    string instance_id = 4;
    string access_key_id = 5;
    string access_key_secret = 6;
  }
  Aliyun aliyun = 1;
}

message Log {
  message Aliyun {
    string endpoint = 1;
    string project = 2;
    string logstore = 3;
    string access_key_id = 4;
    string access_key_secret = 5;
  }
  Aliyun aliyun = 1;
}
```

`app/bugu/service/internal/data/artifact.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package data

import (
	"context"

	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/biz"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/google/uuid"
)

var _ biz.ArtifactRepo = (*artifactRepo)(nil)

type artifactRepo struct {
	data *Data
	log  *log.Helper
}

// NewArtifactRepo .
func NewArtifactRepo(data *Data, logger log.Logger) biz.ArtifactRepo {
	return &artifactRepo{
		data: data,
		log:  log.NewHelper(log.With(logger, "module", "data/artifact")),
	}
}

func (r *artifactRepo) CreateArtifactMetadata(ctx context.Context, userId uuid.UUID, a *biz.Artifact) (*biz.Artifact, error) {
	po, err := r.data.db.Artifact.Create().
		SetAffiliatedFileID(a.AffiliatedFileID).
		SetFileID(a.FileID).
		SetID(a.ID).
		SetMethod(a.Method).
		AddAffiliatedUserIDs(userId).
		Save(ctx)
	if err != nil && ent.IsConstraintError(err) {
		return nil, buguV1.ErrorCreateConflict("create conflict, err: %v", err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.Artifact{
		ID:               po.ID,
		FileID:           po.FileID,
		AffiliatedFileID: po.AffiliatedFileID,
		Method:           po.Method,
	}, nil
}

func (r *artifactRepo) UpdateArtifactMetadata(ctx context.Context, artifact *biz.Artifact) (*biz.Artifact, error) {
	po, err := r.data.db.Artifact.UpdateOneID(artifact.ID).
		SetMethod(artifact.Method).
		Save(ctx)
	if err != nil && ent.IsConstraintError(err) {
		return nil, buguV1.ErrorCreateConflict("update conflict, err: %v", err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.Artifact{
		ID:               po.ID,
		FileID:           po.FileID,
		AffiliatedFileID: po.AffiliatedFileID,
		Method:           po.Method,
	}, nil
}

func (r *artifactRepo) AppendArtifactMetadataByArtifactFileIdToUser(ctx context.Context, userId, fileId uuid.UUID) (*biz.Artifact, error) {
	err := r.data.db.Artifact.Update().
		Where(artifact.FileIDEQ(fileId)).
		AddAffiliatedUserIDs(userId).
		Exec(ctx)
	if err != nil && ent.IsConstraintError(err) {
		return nil, buguV1.ErrorCreateConflict("update conflict, err: %v", err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	target, err := r.data.db.Artifact.Query().
		Where(artifact.FileIDEQ(fileId)).
		Only(ctx)
	if err != nil && ent.IsNotFound(err) {
		return nil, buguV1.ErrorNotFoundError("find fileId: %s not found, err: %v", fileId.String(), err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.Artifact{
		ID:               target.ID,
		FileID:           target.FileID,
		AffiliatedFileID: target.AffiliatedFileID,
		Method:           target.Method,
	}, nil
}

func (r *artifactRepo) AppendArtifactMetadataToUser(ctx context.Context, userId, artifactId uuid.UUID) (*biz.Artifact, error) {
	po, err := r.data.db.Artifact.UpdateOneID(artifactId).
		AddAffiliatedUserIDs(userId).
		Save(ctx)
	if err != nil && ent.IsConstraintError(err) {
		return nil, buguV1.ErrorCreateConflict("update conflict, err: %v", err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.Artifact{
		ID:               po.ID,
		FileID:           po.FileID,
		AffiliatedFileID: po.AffiliatedFileID,
		Method:           po.Method,
	}, nil
}

func (r *artifactRepo) GetArtifactMetadata(ctx context.Context, userId, artifactId uuid.UUID) (*biz.Artifact, error) {
	target, err := r.data.db.Artifact.Query().
		Where(artifact.And(
			artifact.HasAffiliatedUserWith(user.IDEQ(userId)),
			artifact.IDEQ(artifactId),
		)).
		Only(ctx)
	if err != nil && ent.IsNotFound(err) {
		return nil, buguV1.ErrorNotFoundError("find artifactId: %s not found, err: %v", artifactId.String(), err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.Artifact{
		ID:               target.ID,
		FileID:           target.FileID,
		AffiliatedFileID: target.AffiliatedFileID,
		Method:           target.Method,
	}, nil
}

func (r *artifactRepo) GetArtifactMetadataByFileId(ctx context.Context, userId, fileId uuid.UUID) ([]*biz.Artifact, error) {
	targets, err := r.data.db.Artifact.Query().
		Where(artifact.And(
			artifact.HasAffiliatedUserWith(user.IDEQ(userId)),
			artifact.HasAffiliatedFileWith(file.IDEQ(fileId)),
		)).
		All(ctx)
	if err != nil && ent.IsNotFound(err) {
		return nil, buguV1.ErrorNotFoundError("find fileId: %s not found, err: %v", fileId.String(), err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	var rets []*biz.Artifact
	for _, target := range targets {
		rets = append(rets, &biz.Artifact{
			ID:               target.ID,
			FileID:           target.FileID,
			AffiliatedFileID: target.AffiliatedFileID,
			Method:           target.Method,
		})
	}

	return rets, nil
}

func (r *artifactRepo) DeleteArtifactMetadata(ctx context.Context, userId, artifactId uuid.UUID) error {
	po, err := r.data.db.Artifact.UpdateOneID(artifactId).
		RemoveAffiliatedUserIDs(userId).
		Save(ctx)
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	err = r.data.db.File.Update().
		Where(file.And(
			file.HasAffiliatedUserWith(user.IDEQ(userId)),
			file.IDEQ(po.FileID),
		)).
		RemoveAffiliatedUserIDs(userId).
		Exec(ctx)
	if err != nil && !ent.IsNotFound(err) {
		r.log.Errorf("unknown err: %v", err)
		return buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return nil
}

```

`app/bugu/service/internal/data/data.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package data

import (
	"context"
	"time"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/go-kratos/kratos/v2/middleware/recovery"
	"github.com/go-kratos/kratos/v2/transport/grpc"
	"github.com/go-redis/redis/v8"
	"github.com/google/wire"
	obfusionV1 "github.com/hominsu/bugu/api/obfusion/service/v1"
	packerV1 "github.com/hominsu/bugu/api/packer/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/migrate"

	// init mysql driver
	_ "github.com/go-sql-driver/mysql"
)

// ProviderSet is data providers.
var ProviderSet = wire.NewSet(
	NewData,
	NewEntClient,
	NewRedisCmd,
	NewOubfusionServiceClient,
	NewUserRepo,
	NewFileRepo,
	NewArtifactRepo,
	NewObfusionRepo,
)

// Data .
type Data struct {
	db    *ent.Client
	rdCmd redis.Cmdable

	oc obfusionV1.BuguObfusionClient
	pc packerV1.BuguPackerClient

	conf *conf.Data
}

// NewData .
func NewData(entClient *ent.Client,
	rdCmd redis.Cmdable,
	oc obfusionV1.BuguObfusionClient,
	conf *conf.Data,
	logger log.Logger,
) (*Data, func(), error) {
	helper := log.NewHelper(log.With(logger, "module", "ecode-service/data"))

	d := &Data{
		db:    entClient,
		rdCmd: rdCmd,
		oc:    oc,
		conf:  conf,
	}
	return d, func() {
		if err := d.db.Close(); err != nil {
			helper.Error(err)
		}
	}, nil
}

func NewEntClient(conf *conf.Data, logger log.Logger) *ent.Client {
	helper := log.NewHelper(log.With(logger, "module", "ecode-service/data/ent"))

	client, err := ent.Open(
		conf.Database.Driver,
		conf.Database.Source,
	)
	if err != nil {
		helper.Fatalf("failed opening connection to db: %v", err)
	}
	// Run the auto migration tool.
	if err := client.Schema.Create(context.Background(), migrate.WithForeignKeys(false)); err != nil {
		helper.Fatalf("failed creating schema resources: %v", err)
	}
	return client
}

func NewRedisCmd(conf *conf.Data, logger log.Logger) redis.Cmdable {
	helper := log.NewHelper(log.With(logger, "module", "ecode-service/data/redis"))

	client := redis.NewClient(&redis.Options{
		Addr:         conf.Redis.Addr,
		DB:           int(conf.Redis.Db),
		ReadTimeout:  conf.Redis.ReadTimeout.AsDuration(),
		WriteTimeout: conf.Redis.WriteTimeout.AsDuration(),
		DialTimeout:  time.Second * 2,
		PoolSize:     10,
	})
	timeout, cancelFunc := context.WithTimeout(context.Background(), time.Second*2)
	defer cancelFunc()
	err := client.Ping(timeout).Err()
	if err != nil {
		helper.Fatalf("redis connect error: %v", err)
	}
	return client
}

func NewOubfusionServiceClient(conf *conf.Server) obfusionV1.BuguObfusionClient {
	opts := []grpc.ClientOption{
		grpc.WithEndpoint("bugu-obfusion-service:9000"),
		grpc.WithMiddleware(
			recovery.Recovery(),
		),
	}
	if conf.Http.Timeout != nil {
		opts = append(opts, grpc.WithTimeout(conf.Http.Timeout.AsDuration()))
	}

	conn, err := grpc.DialInsecure(context.Background(), opts...)
	if err != nil {
		panic(err)
	}

	c := obfusionV1.NewBuguObfusionClient(conn)
	return c
}

func NewPackerServiceClient(conf *conf.Server) packerV1.BuguPackerClient {
	opts := []grpc.ClientOption{
		grpc.WithEndpoint("bugu-packer-service:9000"),
		grpc.WithMiddleware(
			recovery.Recovery(),
		),
	}
	if conf.Http.Timeout != nil {
		opts = append(opts, grpc.WithTimeout(conf.Http.Timeout.AsDuration()))
	}

	conn, err := grpc.DialInsecure(context.Background(), opts...)
	if err != nil {
		panic(err)
	}

	c := packerV1.NewBuguPackerClient(conn)
	return c
}

```

`app/bugu/service/internal/data/data_test.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package data

import (
	"os"
	"testing"
	"time"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
	"google.golang.org/protobuf/types/known/durationpb"
)

var (
	c = &conf.Data{
		Database: &conf.Data_Database{
			Driver: "mysql",
			Source: "root:dangerous@tcp(127.0.0.1:3306)/test?charset=utf8mb4&parseTime=True&loc=Local",
		},
		Redis: &conf.Data_Redis{
			Addr:            "127.0.0.1:6379",
			Db:              1,
			CacheExpiration: durationpb.New(time.Second * 1800),
			ReadTimeout:     durationpb.New(time.Millisecond * 200),
			WriteTimeout:    durationpb.New(time.Millisecond * 200),
		},
	}

	data *Data
)

func TestNewData(t *testing.T) {
}

func TestMain(m *testing.M) {
	var err error
	var cleanup func()

	logger := log.With(log.NewStdLogger(os.Stdout))
	helper := log.NewHelper(logger)

	entClient := NewEntClient(c, logger)
	redisCmd := NewRedisCmd(c, logger)

	data, cleanup, err = NewData(entClient, redisCmd, nil, c, logger)
	if err != nil {
		helper.Fatal(err)
	}
	defer cleanup()

	ret := m.Run()
	os.Exit(ret)
}

```

`app/bugu/service/internal/data/ent/artifact.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
)

// Artifact is the model entity for the Artifact schema.
type Artifact struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// FileID holds the value of the "file_id" field.
	FileID uuid.UUID `json:"file_id,omitempty"`
	// AffiliatedFileID holds the value of the "affiliated_file_id" field.
	AffiliatedFileID uuid.UUID `json:"affiliated_file_id,omitempty"`
	// Method holds the value of the "method" field.
	Method string `json:"method,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ArtifactQuery when eager-loading is set.
	Edges ArtifactEdges `json:"edges"`
}

// ArtifactEdges holds the relations/edges for other nodes in the graph.
type ArtifactEdges struct {
	// AffiliatedFile holds the value of the affiliated_file edge.
	AffiliatedFile []*File `json:"affiliated_file,omitempty"`
	// AffiliatedUser holds the value of the affiliated_user edge.
	AffiliatedUser []*User `json:"affiliated_user,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// AffiliatedFileOrErr returns the AffiliatedFile value or an error if the edge
// was not loaded in eager-loading.
func (e ArtifactEdges) AffiliatedFileOrErr() ([]*File, error) {
	if e.loadedTypes[0] {
		return e.AffiliatedFile, nil
	}
	return nil, &NotLoadedError{edge: "affiliated_file"}
}

// AffiliatedUserOrErr returns the AffiliatedUser value or an error if the edge
// was not loaded in eager-loading.
func (e ArtifactEdges) AffiliatedUserOrErr() ([]*User, error) {
	if e.loadedTypes[1] {
		return e.AffiliatedUser, nil
	}
	return nil, &NotLoadedError{edge: "affiliated_user"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Artifact) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case artifact.FieldMethod:
			values[i] = new(sql.NullString)
		case artifact.FieldCreatedAt, artifact.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case artifact.FieldID, artifact.FieldFileID, artifact.FieldAffiliatedFileID:
			values[i] = new(uuid.UUID)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Artifact", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Artifact fields.
func (a *Artifact) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case artifact.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				a.ID = *value
			}
		case artifact.FieldFileID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field file_id", values[i])
			} else if value != nil {
				a.FileID = *value
			}
		case artifact.FieldAffiliatedFileID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field affiliated_file_id", values[i])
			} else if value != nil {
				a.AffiliatedFileID = *value
			}
		case artifact.FieldMethod:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field method", values[i])
			} else if value.Valid {
				a.Method = value.String
			}
		case artifact.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				a.CreatedAt = value.Time
			}
		case artifact.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				a.UpdatedAt = value.Time
			}
		}
	}
	return nil
}

// QueryAffiliatedFile queries the "affiliated_file" edge of the Artifact entity.
func (a *Artifact) QueryAffiliatedFile() *FileQuery {
	return (&ArtifactClient{config: a.config}).QueryAffiliatedFile(a)
}

// QueryAffiliatedUser queries the "affiliated_user" edge of the Artifact entity.
func (a *Artifact) QueryAffiliatedUser() *UserQuery {
	return (&ArtifactClient{config: a.config}).QueryAffiliatedUser(a)
}

// Update returns a builder for updating this Artifact.
// Note that you need to call Artifact.Unwrap() before calling this method if this Artifact
// was returned from a transaction, and the transaction was committed or rolled back.
func (a *Artifact) Update() *ArtifactUpdateOne {
	return (&ArtifactClient{config: a.config}).UpdateOne(a)
}

// Unwrap unwraps the Artifact entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (a *Artifact) Unwrap() *Artifact {
	tx, ok := a.config.driver.(*txDriver)
	if !ok {
		panic("ent: Artifact is not a transactional entity")
	}
	a.config.driver = tx.drv
	return a
}

// String implements the fmt.Stringer.
func (a *Artifact) String() string {
	var builder strings.Builder
	builder.WriteString("Artifact(")
	builder.WriteString(fmt.Sprintf("id=%v", a.ID))
	builder.WriteString(", file_id=")
	builder.WriteString(fmt.Sprintf("%v", a.FileID))
	builder.WriteString(", affiliated_file_id=")
	builder.WriteString(fmt.Sprintf("%v", a.AffiliatedFileID))
	builder.WriteString(", method=")
	builder.WriteString(a.Method)
	builder.WriteString(", created_at=")
	builder.WriteString(a.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updated_at=")
	builder.WriteString(a.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Artifacts is a parsable slice of Artifact.
type Artifacts []*Artifact

func (a Artifacts) config(cfg config) {
	for _i := range a {
		a[_i].config = cfg
	}
}

```

`app/bugu/service/internal/data/ent/artifact/artifact.go`:

```go
// Code generated by entc, DO NOT EDIT.

package artifact

import (
	"time"
)

const (
	// Label holds the string label denoting the artifact type in the database.
	Label = "artifact"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldFileID holds the string denoting the file_id field in the database.
	FieldFileID = "file_id"
	// FieldAffiliatedFileID holds the string denoting the affiliated_file_id field in the database.
	FieldAffiliatedFileID = "affiliated_file_id"
	// FieldMethod holds the string denoting the method field in the database.
	FieldMethod = "method"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// EdgeAffiliatedFile holds the string denoting the affiliated_file edge name in mutations.
	EdgeAffiliatedFile = "affiliated_file"
	// EdgeAffiliatedUser holds the string denoting the affiliated_user edge name in mutations.
	EdgeAffiliatedUser = "affiliated_user"
	// Table holds the table name of the artifact in the database.
	Table = "artifacts"
	// AffiliatedFileTable is the table that holds the affiliated_file relation/edge.
	AffiliatedFileTable = "files"
	// AffiliatedFileInverseTable is the table name for the File entity.
	// It exists in this package in order to avoid circular dependency with the "file" package.
	AffiliatedFileInverseTable = "files"
	// AffiliatedFileColumn is the table column denoting the affiliated_file relation/edge.
	AffiliatedFileColumn = "file_artifact"
	// AffiliatedUserTable is the table that holds the affiliated_user relation/edge. The primary key declared below.
	AffiliatedUserTable = "user_user_artifact"
	// AffiliatedUserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	AffiliatedUserInverseTable = "users"
)

// Columns holds all SQL columns for artifact fields.
var Columns = []string{
	FieldID,
	FieldFileID,
	FieldAffiliatedFileID,
	FieldMethod,
	FieldCreatedAt,
	FieldUpdatedAt,
}

var (
	// AffiliatedUserPrimaryKey and AffiliatedUserColumn2 are the table columns denoting the
	// primary key for the affiliated_user relation (M2M).
	AffiliatedUserPrimaryKey = []string{"user_id", "artifact_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
)

```

`app/bugu/service/internal/data/ent/artifact/where.go`:

```go
// Code generated by entc, DO NOT EDIT.

package artifact

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// FileID applies equality check predicate on the "file_id" field. It's identical to FileIDEQ.
func FileID(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileID), v))
	})
}

// AffiliatedFileID applies equality check predicate on the "affiliated_file_id" field. It's identical to AffiliatedFileIDEQ.
func AffiliatedFileID(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAffiliatedFileID), v))
	})
}

// Method applies equality check predicate on the "method" field. It's identical to MethodEQ.
func Method(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMethod), v))
	})
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// FileIDEQ applies the EQ predicate on the "file_id" field.
func FileIDEQ(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileID), v))
	})
}

// FileIDNEQ applies the NEQ predicate on the "file_id" field.
func FileIDNEQ(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFileID), v))
	})
}

// FileIDIn applies the In predicate on the "file_id" field.
func FileIDIn(vs ...uuid.UUID) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFileID), v...))
	})
}

// FileIDNotIn applies the NotIn predicate on the "file_id" field.
func FileIDNotIn(vs ...uuid.UUID) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFileID), v...))
	})
}

// FileIDGT applies the GT predicate on the "file_id" field.
func FileIDGT(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFileID), v))
	})
}

// FileIDGTE applies the GTE predicate on the "file_id" field.
func FileIDGTE(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFileID), v))
	})
}

// FileIDLT applies the LT predicate on the "file_id" field.
func FileIDLT(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFileID), v))
	})
}

// FileIDLTE applies the LTE predicate on the "file_id" field.
func FileIDLTE(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFileID), v))
	})
}

// AffiliatedFileIDEQ applies the EQ predicate on the "affiliated_file_id" field.
func AffiliatedFileIDEQ(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAffiliatedFileID), v))
	})
}

// AffiliatedFileIDNEQ applies the NEQ predicate on the "affiliated_file_id" field.
func AffiliatedFileIDNEQ(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAffiliatedFileID), v))
	})
}

// AffiliatedFileIDIn applies the In predicate on the "affiliated_file_id" field.
func AffiliatedFileIDIn(vs ...uuid.UUID) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAffiliatedFileID), v...))
	})
}

// AffiliatedFileIDNotIn applies the NotIn predicate on the "affiliated_file_id" field.
func AffiliatedFileIDNotIn(vs ...uuid.UUID) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAffiliatedFileID), v...))
	})
}

// AffiliatedFileIDGT applies the GT predicate on the "affiliated_file_id" field.
func AffiliatedFileIDGT(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAffiliatedFileID), v))
	})
}

// AffiliatedFileIDGTE applies the GTE predicate on the "affiliated_file_id" field.
func AffiliatedFileIDGTE(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAffiliatedFileID), v))
	})
}

// AffiliatedFileIDLT applies the LT predicate on the "affiliated_file_id" field.
func AffiliatedFileIDLT(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAffiliatedFileID), v))
	})
}

// AffiliatedFileIDLTE applies the LTE predicate on the "affiliated_file_id" field.
func AffiliatedFileIDLTE(v uuid.UUID) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAffiliatedFileID), v))
	})
}

// MethodEQ applies the EQ predicate on the "method" field.
func MethodEQ(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMethod), v))
	})
}

// MethodNEQ applies the NEQ predicate on the "method" field.
func MethodNEQ(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMethod), v))
	})
}

// MethodIn applies the In predicate on the "method" field.
func MethodIn(vs ...string) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMethod), v...))
	})
}

// MethodNotIn applies the NotIn predicate on the "method" field.
func MethodNotIn(vs ...string) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMethod), v...))
	})
}

// MethodGT applies the GT predicate on the "method" field.
func MethodGT(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMethod), v))
	})
}

// MethodGTE applies the GTE predicate on the "method" field.
func MethodGTE(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMethod), v))
	})
}

// MethodLT applies the LT predicate on the "method" field.
func MethodLT(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMethod), v))
	})
}

// MethodLTE applies the LTE predicate on the "method" field.
func MethodLTE(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMethod), v))
	})
}

// MethodContains applies the Contains predicate on the "method" field.
func MethodContains(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMethod), v))
	})
}

// MethodHasPrefix applies the HasPrefix predicate on the "method" field.
func MethodHasPrefix(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMethod), v))
	})
}

// MethodHasSuffix applies the HasSuffix predicate on the "method" field.
func MethodHasSuffix(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMethod), v))
	})
}

// MethodIsNil applies the IsNil predicate on the "method" field.
func MethodIsNil() predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldMethod)))
	})
}

// MethodNotNil applies the NotNil predicate on the "method" field.
func MethodNotNil() predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldMethod)))
	})
}

// MethodEqualFold applies the EqualFold predicate on the "method" field.
func MethodEqualFold(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMethod), v))
	})
}

// MethodContainsFold applies the ContainsFold predicate on the "method" field.
func MethodContainsFold(v string) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMethod), v))
	})
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.Artifact {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Artifact(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedAt), v))
	})
}

// HasAffiliatedFile applies the HasEdge predicate on the "affiliated_file" edge.
func HasAffiliatedFile() predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AffiliatedFileTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, AffiliatedFileTable, AffiliatedFileColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAffiliatedFileWith applies the HasEdge predicate on the "affiliated_file" edge with a given conditions (other predicates).
func HasAffiliatedFileWith(preds ...predicate.File) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AffiliatedFileInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, AffiliatedFileTable, AffiliatedFileColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAffiliatedUser applies the HasEdge predicate on the "affiliated_user" edge.
func HasAffiliatedUser() predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AffiliatedUserTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, AffiliatedUserTable, AffiliatedUserPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAffiliatedUserWith applies the HasEdge predicate on the "affiliated_user" edge with a given conditions (other predicates).
func HasAffiliatedUserWith(preds ...predicate.User) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AffiliatedUserInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, AffiliatedUserTable, AffiliatedUserPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Artifact) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Artifact) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Artifact) predicate.Artifact {
	return predicate.Artifact(func(s *sql.Selector) {
		p(s.Not())
	})
}

```

`app/bugu/service/internal/data/ent/artifact_create.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// ArtifactCreate is the builder for creating a Artifact entity.
type ArtifactCreate struct {
	config
	mutation *ArtifactMutation
	hooks    []Hook
}

// SetFileID sets the "file_id" field.
func (ac *ArtifactCreate) SetFileID(u uuid.UUID) *ArtifactCreate {
	ac.mutation.SetFileID(u)
	return ac
}

// SetAffiliatedFileID sets the "affiliated_file_id" field.
func (ac *ArtifactCreate) SetAffiliatedFileID(u uuid.UUID) *ArtifactCreate {
	ac.mutation.SetAffiliatedFileID(u)
	return ac
}

// SetMethod sets the "method" field.
func (ac *ArtifactCreate) SetMethod(s string) *ArtifactCreate {
	ac.mutation.SetMethod(s)
	return ac
}

// SetNillableMethod sets the "method" field if the given value is not nil.
func (ac *ArtifactCreate) SetNillableMethod(s *string) *ArtifactCreate {
	if s != nil {
		ac.SetMethod(*s)
	}
	return ac
}

// SetCreatedAt sets the "created_at" field.
func (ac *ArtifactCreate) SetCreatedAt(t time.Time) *ArtifactCreate {
	ac.mutation.SetCreatedAt(t)
	return ac
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (ac *ArtifactCreate) SetNillableCreatedAt(t *time.Time) *ArtifactCreate {
	if t != nil {
		ac.SetCreatedAt(*t)
	}
	return ac
}

// SetUpdatedAt sets the "updated_at" field.
func (ac *ArtifactCreate) SetUpdatedAt(t time.Time) *ArtifactCreate {
	ac.mutation.SetUpdatedAt(t)
	return ac
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (ac *ArtifactCreate) SetNillableUpdatedAt(t *time.Time) *ArtifactCreate {
	if t != nil {
		ac.SetUpdatedAt(*t)
	}
	return ac
}

// SetID sets the "id" field.
func (ac *ArtifactCreate) SetID(u uuid.UUID) *ArtifactCreate {
	ac.mutation.SetID(u)
	return ac
}

// AddAffiliatedFileIDs adds the "affiliated_file" edge to the File entity by IDs.
func (ac *ArtifactCreate) AddAffiliatedFileIDs(ids ...uuid.UUID) *ArtifactCreate {
	ac.mutation.AddAffiliatedFileIDs(ids...)
	return ac
}

// AddAffiliatedFile adds the "affiliated_file" edges to the File entity.
func (ac *ArtifactCreate) AddAffiliatedFile(f ...*File) *ArtifactCreate {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return ac.AddAffiliatedFileIDs(ids...)
}

// AddAffiliatedUserIDs adds the "affiliated_user" edge to the User entity by IDs.
func (ac *ArtifactCreate) AddAffiliatedUserIDs(ids ...uuid.UUID) *ArtifactCreate {
	ac.mutation.AddAffiliatedUserIDs(ids...)
	return ac
}

// AddAffiliatedUser adds the "affiliated_user" edges to the User entity.
func (ac *ArtifactCreate) AddAffiliatedUser(u ...*User) *ArtifactCreate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return ac.AddAffiliatedUserIDs(ids...)
}

// Mutation returns the ArtifactMutation object of the builder.
func (ac *ArtifactCreate) Mutation() *ArtifactMutation {
	return ac.mutation
}

// Save creates the Artifact in the database.
func (ac *ArtifactCreate) Save(ctx context.Context) (*Artifact, error) {
	var (
		err  error
		node *Artifact
	)
	ac.defaults()
	if len(ac.hooks) == 0 {
		if err = ac.check(); err != nil {
			return nil, err
		}
		node, err = ac.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ArtifactMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = ac.check(); err != nil {
				return nil, err
			}
			ac.mutation = mutation
			if node, err = ac.sqlSave(ctx); err != nil {
				return nil, err
			}
			mutation.id = &node.ID
			mutation.done = true
			return node, err
		})
		for i := len(ac.hooks) - 1; i >= 0; i-- {
			if ac.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = ac.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, ac.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX calls Save and panics if Save returns an error.
func (ac *ArtifactCreate) SaveX(ctx context.Context) *Artifact {
	v, err := ac.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (ac *ArtifactCreate) Exec(ctx context.Context) error {
	_, err := ac.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ac *ArtifactCreate) ExecX(ctx context.Context) {
	if err := ac.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ac *ArtifactCreate) defaults() {
	if _, ok := ac.mutation.CreatedAt(); !ok {
		v := artifact.DefaultCreatedAt()
		ac.mutation.SetCreatedAt(v)
	}
	if _, ok := ac.mutation.UpdatedAt(); !ok {
		v := artifact.DefaultUpdatedAt()
		ac.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ac *ArtifactCreate) check() error {
	if _, ok := ac.mutation.FileID(); !ok {
		return &ValidationError{Name: "file_id", err: errors.New(`ent: missing required field "Artifact.file_id"`)}
	}
	if _, ok := ac.mutation.AffiliatedFileID(); !ok {
		return &ValidationError{Name: "affiliated_file_id", err: errors.New(`ent: missing required field "Artifact.affiliated_file_id"`)}
	}
	if _, ok := ac.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "Artifact.created_at"`)}
	}
	if _, ok := ac.mutation.UpdatedAt(); !ok {
		return &ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "Artifact.updated_at"`)}
	}
	return nil
}

func (ac *ArtifactCreate) sqlSave(ctx context.Context) (*Artifact, error) {
	_node, _spec := ac.createSpec()
	if err := sqlgraph.CreateNode(ctx, ac.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(*uuid.UUID); ok {
			_node.ID = *id
		} else if err := _node.ID.Scan(_spec.ID.Value); err != nil {
			return nil, err
		}
	}
	return _node, nil
}

func (ac *ArtifactCreate) createSpec() (*Artifact, *sqlgraph.CreateSpec) {
	var (
		_node = &Artifact{config: ac.config}
		_spec = &sqlgraph.CreateSpec{
			Table: artifact.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: artifact.FieldID,
			},
		}
	)
	if id, ok := ac.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = &id
	}
	if value, ok := ac.mutation.FileID(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUUID,
			Value:  value,
			Column: artifact.FieldFileID,
		})
		_node.FileID = value
	}
	if value, ok := ac.mutation.AffiliatedFileID(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeUUID,
			Value:  value,
			Column: artifact.FieldAffiliatedFileID,
		})
		_node.AffiliatedFileID = value
	}
	if value, ok := ac.mutation.Method(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: artifact.FieldMethod,
		})
		_node.Method = value
	}
	if value, ok := ac.mutation.CreatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: artifact.FieldCreatedAt,
		})
		_node.CreatedAt = value
	}
	if value, ok := ac.mutation.UpdatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: artifact.FieldUpdatedAt,
		})
		_node.UpdatedAt = value
	}
	if nodes := ac.mutation.AffiliatedFileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   artifact.AffiliatedFileTable,
			Columns: []string{artifact.AffiliatedFileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ac.mutation.AffiliatedUserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   artifact.AffiliatedUserTable,
			Columns: artifact.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// ArtifactCreateBulk is the builder for creating many Artifact entities in bulk.
type ArtifactCreateBulk struct {
	config
	builders []*ArtifactCreate
}

// Save creates the Artifact entities in the database.
func (acb *ArtifactCreateBulk) Save(ctx context.Context) ([]*Artifact, error) {
	specs := make([]*sqlgraph.CreateSpec, len(acb.builders))
	nodes := make([]*Artifact, len(acb.builders))
	mutators := make([]Mutator, len(acb.builders))
	for i := range acb.builders {
		func(i int, root context.Context) {
			builder := acb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*ArtifactMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, acb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, acb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{err.Error(), err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, acb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (acb *ArtifactCreateBulk) SaveX(ctx context.Context) []*Artifact {
	v, err := acb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (acb *ArtifactCreateBulk) Exec(ctx context.Context) error {
	_, err := acb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (acb *ArtifactCreateBulk) ExecX(ctx context.Context) {
	if err := acb.Exec(ctx); err != nil {
		panic(err)
	}
}

```

`app/bugu/service/internal/data/ent/artifact_delete.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
)

// ArtifactDelete is the builder for deleting a Artifact entity.
type ArtifactDelete struct {
	config
	hooks    []Hook
	mutation *ArtifactMutation
}

// Where appends a list predicates to the ArtifactDelete builder.
func (ad *ArtifactDelete) Where(ps ...predicate.Artifact) *ArtifactDelete {
	ad.mutation.Where(ps...)
	return ad
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (ad *ArtifactDelete) Exec(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(ad.hooks) == 0 {
		affected, err = ad.sqlExec(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ArtifactMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			ad.mutation = mutation
			affected, err = ad.sqlExec(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(ad.hooks) - 1; i >= 0; i-- {
			if ad.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = ad.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, ad.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// ExecX is like Exec, but panics if an error occurs.
func (ad *ArtifactDelete) ExecX(ctx context.Context) int {
	n, err := ad.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (ad *ArtifactDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := &sqlgraph.DeleteSpec{
		Node: &sqlgraph.NodeSpec{
			Table: artifact.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: artifact.FieldID,
			},
		},
	}
	if ps := ad.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return sqlgraph.DeleteNodes(ctx, ad.driver, _spec)
}

// ArtifactDeleteOne is the builder for deleting a single Artifact entity.
type ArtifactDeleteOne struct {
	ad *ArtifactDelete
}

// Exec executes the deletion query.
func (ado *ArtifactDeleteOne) Exec(ctx context.Context) error {
	n, err := ado.ad.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{artifact.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (ado *ArtifactDeleteOne) ExecX(ctx context.Context) {
	ado.ad.ExecX(ctx)
}

```

`app/bugu/service/internal/data/ent/artifact_query.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// ArtifactQuery is the builder for querying Artifact entities.
type ArtifactQuery struct {
	config
	limit      *int
	offset     *int
	unique     *bool
	order      []OrderFunc
	fields     []string
	predicates []predicate.Artifact
	// eager-loading edges.
	withAffiliatedFile *FileQuery
	withAffiliatedUser *UserQuery
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the ArtifactQuery builder.
func (aq *ArtifactQuery) Where(ps ...predicate.Artifact) *ArtifactQuery {
	aq.predicates = append(aq.predicates, ps...)
	return aq
}

// Limit adds a limit step to the query.
func (aq *ArtifactQuery) Limit(limit int) *ArtifactQuery {
	aq.limit = &limit
	return aq
}

// Offset adds an offset step to the query.
func (aq *ArtifactQuery) Offset(offset int) *ArtifactQuery {
	aq.offset = &offset
	return aq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (aq *ArtifactQuery) Unique(unique bool) *ArtifactQuery {
	aq.unique = &unique
	return aq
}

// Order adds an order step to the query.
func (aq *ArtifactQuery) Order(o ...OrderFunc) *ArtifactQuery {
	aq.order = append(aq.order, o...)
	return aq
}

// QueryAffiliatedFile chains the current query on the "affiliated_file" edge.
func (aq *ArtifactQuery) QueryAffiliatedFile() *FileQuery {
	query := &FileQuery{config: aq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := aq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := aq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, selector),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.AffiliatedFileTable, artifact.AffiliatedFileColumn),
		)
		fromU = sqlgraph.SetNeighbors(aq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAffiliatedUser chains the current query on the "affiliated_user" edge.
func (aq *ArtifactQuery) QueryAffiliatedUser() *UserQuery {
	query := &UserQuery{config: aq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := aq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := aq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.AffiliatedUserTable, artifact.AffiliatedUserPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(aq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first Artifact entity from the query.
// Returns a *NotFoundError when no Artifact was found.
func (aq *ArtifactQuery) First(ctx context.Context) (*Artifact, error) {
	nodes, err := aq.Limit(1).All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{artifact.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (aq *ArtifactQuery) FirstX(ctx context.Context) *Artifact {
	node, err := aq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first Artifact ID from the query.
// Returns a *NotFoundError when no Artifact ID was found.
func (aq *ArtifactQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = aq.Limit(1).IDs(ctx); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{artifact.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (aq *ArtifactQuery) FirstIDX(ctx context.Context) uuid.UUID {
	id, err := aq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single Artifact entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Artifact entity is found.
// Returns a *NotFoundError when no Artifact entities are found.
func (aq *ArtifactQuery) Only(ctx context.Context) (*Artifact, error) {
	nodes, err := aq.Limit(2).All(ctx)
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{artifact.Label}
	default:
		return nil, &NotSingularError{artifact.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (aq *ArtifactQuery) OnlyX(ctx context.Context) *Artifact {
	node, err := aq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only Artifact ID in the query.
// Returns a *NotSingularError when more than one Artifact ID is found.
// Returns a *NotFoundError when no entities are found.
func (aq *ArtifactQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = aq.Limit(2).IDs(ctx); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = &NotSingularError{artifact.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (aq *ArtifactQuery) OnlyIDX(ctx context.Context) uuid.UUID {
	id, err := aq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Artifacts.
func (aq *ArtifactQuery) All(ctx context.Context) ([]*Artifact, error) {
	if err := aq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	return aq.sqlAll(ctx)
}

// AllX is like All, but panics if an error occurs.
func (aq *ArtifactQuery) AllX(ctx context.Context) []*Artifact {
	nodes, err := aq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of Artifact IDs.
func (aq *ArtifactQuery) IDs(ctx context.Context) ([]uuid.UUID, error) {
	var ids []uuid.UUID
	if err := aq.Select(artifact.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (aq *ArtifactQuery) IDsX(ctx context.Context) []uuid.UUID {
	ids, err := aq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (aq *ArtifactQuery) Count(ctx context.Context) (int, error) {
	if err := aq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return aq.sqlCount(ctx)
}

// CountX is like Count, but panics if an error occurs.
func (aq *ArtifactQuery) CountX(ctx context.Context) int {
	count, err := aq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (aq *ArtifactQuery) Exist(ctx context.Context) (bool, error) {
	if err := aq.prepareQuery(ctx); err != nil {
		return false, err
	}
	return aq.sqlExist(ctx)
}

// ExistX is like Exist, but panics if an error occurs.
func (aq *ArtifactQuery) ExistX(ctx context.Context) bool {
	exist, err := aq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the ArtifactQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (aq *ArtifactQuery) Clone() *ArtifactQuery {
	if aq == nil {
		return nil
	}
	return &ArtifactQuery{
		config:             aq.config,
		limit:              aq.limit,
		offset:             aq.offset,
		order:              append([]OrderFunc{}, aq.order...),
		predicates:         append([]predicate.Artifact{}, aq.predicates...),
		withAffiliatedFile: aq.withAffiliatedFile.Clone(),
		withAffiliatedUser: aq.withAffiliatedUser.Clone(),
		// clone intermediate query.
		sql:    aq.sql.Clone(),
		path:   aq.path,
		unique: aq.unique,
	}
}

// WithAffiliatedFile tells the query-builder to eager-load the nodes that are connected to
// the "affiliated_file" edge. The optional arguments are used to configure the query builder of the edge.
func (aq *ArtifactQuery) WithAffiliatedFile(opts ...func(*FileQuery)) *ArtifactQuery {
	query := &FileQuery{config: aq.config}
	for _, opt := range opts {
		opt(query)
	}
	aq.withAffiliatedFile = query
	return aq
}

// WithAffiliatedUser tells the query-builder to eager-load the nodes that are connected to
// the "affiliated_user" edge. The optional arguments are used to configure the query builder of the edge.
func (aq *ArtifactQuery) WithAffiliatedUser(opts ...func(*UserQuery)) *ArtifactQuery {
	query := &UserQuery{config: aq.config}
	for _, opt := range opts {
		opt(query)
	}
	aq.withAffiliatedUser = query
	return aq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		FileID uuid.UUID `json:"file_id,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.Artifact.Query().
//		GroupBy(artifact.FieldFileID).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
//
func (aq *ArtifactQuery) GroupBy(field string, fields ...string) *ArtifactGroupBy {
	group := &ArtifactGroupBy{config: aq.config}
	group.fields = append([]string{field}, fields...)
	group.path = func(ctx context.Context) (prev *sql.Selector, err error) {
		if err := aq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		return aq.sqlQuery(ctx), nil
	}
	return group
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		FileID uuid.UUID `json:"file_id,omitempty"`
//	}
//
//	client.Artifact.Query().
//		Select(artifact.FieldFileID).
//		Scan(ctx, &v)
//
func (aq *ArtifactQuery) Select(fields ...string) *ArtifactSelect {
	aq.fields = append(aq.fields, fields...)
	return &ArtifactSelect{ArtifactQuery: aq}
}

func (aq *ArtifactQuery) prepareQuery(ctx context.Context) error {
	for _, f := range aq.fields {
		if !artifact.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if aq.path != nil {
		prev, err := aq.path(ctx)
		if err != nil {
			return err
		}
		aq.sql = prev
	}
	return nil
}

func (aq *ArtifactQuery) sqlAll(ctx context.Context) ([]*Artifact, error) {
	var (
		nodes       = []*Artifact{}
		_spec       = aq.querySpec()
		loadedTypes = [2]bool{
			aq.withAffiliatedFile != nil,
			aq.withAffiliatedUser != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]interface{}, error) {
		node := &Artifact{config: aq.config}
		nodes = append(nodes, node)
		return node.scanValues(columns)
	}
	_spec.Assign = func(columns []string, values []interface{}) error {
		if len(nodes) == 0 {
			return fmt.Errorf("ent: Assign called without calling ScanValues")
		}
		node := nodes[len(nodes)-1]
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	if err := sqlgraph.QueryNodes(ctx, aq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}

	if query := aq.withAffiliatedFile; query != nil {
		fks := make([]driver.Value, 0, len(nodes))
		nodeids := make(map[uuid.UUID]*Artifact)
		for i := range nodes {
			fks = append(fks, nodes[i].ID)
			nodeids[nodes[i].ID] = nodes[i]
			nodes[i].Edges.AffiliatedFile = []*File{}
		}
		query.withFKs = true
		query.Where(predicate.File(func(s *sql.Selector) {
			s.Where(sql.InValues(artifact.AffiliatedFileColumn, fks...))
		}))
		neighbors, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, n := range neighbors {
			fk := n.file_artifact
			if fk == nil {
				return nil, fmt.Errorf(`foreign-key "file_artifact" is nil for node %v`, n.ID)
			}
			node, ok := nodeids[*fk]
			if !ok {
				return nil, fmt.Errorf(`unexpected foreign-key "file_artifact" returned %v for node %v`, *fk, n.ID)
			}
			node.Edges.AffiliatedFile = append(node.Edges.AffiliatedFile, n)
		}
	}

	if query := aq.withAffiliatedUser; query != nil {
		fks := make([]driver.Value, 0, len(nodes))
		ids := make(map[uuid.UUID]*Artifact, len(nodes))
		for _, node := range nodes {
			ids[node.ID] = node
			fks = append(fks, node.ID)
			node.Edges.AffiliatedUser = []*User{}
		}
		var (
			edgeids []uuid.UUID
			edges   = make(map[uuid.UUID][]*Artifact)
		)
		_spec := &sqlgraph.EdgeQuerySpec{
			Edge: &sqlgraph.EdgeSpec{
				Inverse: true,
				Table:   artifact.AffiliatedUserTable,
				Columns: artifact.AffiliatedUserPrimaryKey,
			},
			Predicate: func(s *sql.Selector) {
				s.Where(sql.InValues(artifact.AffiliatedUserPrimaryKey[1], fks...))
			},
			ScanValues: func() [2]interface{} {
				return [2]interface{}{new(uuid.UUID), new(uuid.UUID)}
			},
			Assign: func(out, in interface{}) error {
				eout, ok := out.(*uuid.UUID)
				if !ok || eout == nil {
					return fmt.Errorf("unexpected id value for edge-out")
				}
				ein, ok := in.(*uuid.UUID)
				if !ok || ein == nil {
					return fmt.Errorf("unexpected id value for edge-in")
				}
				outValue := *eout
				inValue := *ein
				node, ok := ids[outValue]
				if !ok {
					return fmt.Errorf("unexpected node id in edges: %v", outValue)
				}
				if _, ok := edges[inValue]; !ok {
					edgeids = append(edgeids, inValue)
				}
				edges[inValue] = append(edges[inValue], node)
				return nil
			},
		}
		if err := sqlgraph.QueryEdges(ctx, aq.driver, _spec); err != nil {
			return nil, fmt.Errorf(`query edges "affiliated_user": %w`, err)
		}
		query.Where(user.IDIn(edgeids...))
		neighbors, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, n := range neighbors {
			nodes, ok := edges[n.ID]
			if !ok {
				return nil, fmt.Errorf(`unexpected "affiliated_user" node returned %v`, n.ID)
			}
			for i := range nodes {
				nodes[i].Edges.AffiliatedUser = append(nodes[i].Edges.AffiliatedUser, n)
			}
		}
	}

	return nodes, nil
}

func (aq *ArtifactQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := aq.querySpec()
	_spec.Node.Columns = aq.fields
	if len(aq.fields) > 0 {
		_spec.Unique = aq.unique != nil && *aq.unique
	}
	return sqlgraph.CountNodes(ctx, aq.driver, _spec)
}

func (aq *ArtifactQuery) sqlExist(ctx context.Context) (bool, error) {
	n, err := aq.sqlCount(ctx)
	if err != nil {
		return false, fmt.Errorf("ent: check existence: %w", err)
	}
	return n > 0, nil
}

func (aq *ArtifactQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := &sqlgraph.QuerySpec{
		Node: &sqlgraph.NodeSpec{
			Table:   artifact.Table,
			Columns: artifact.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: artifact.FieldID,
			},
		},
		From:   aq.sql,
		Unique: true,
	}
	if unique := aq.unique; unique != nil {
		_spec.Unique = *unique
	}
	if fields := aq.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, artifact.FieldID)
		for i := range fields {
			if fields[i] != artifact.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := aq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := aq.limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := aq.offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := aq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (aq *ArtifactQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(aq.driver.Dialect())
	t1 := builder.Table(artifact.Table)
	columns := aq.fields
	if len(columns) == 0 {
		columns = artifact.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if aq.sql != nil {
		selector = aq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if aq.unique != nil && *aq.unique {
		selector.Distinct()
	}
	for _, p := range aq.predicates {
		p(selector)
	}
	for _, p := range aq.order {
		p(selector)
	}
	if offset := aq.offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := aq.limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// ArtifactGroupBy is the group-by builder for Artifact entities.
type ArtifactGroupBy struct {
	config
	fields []string
	fns    []AggregateFunc
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Aggregate adds the given aggregation functions to the group-by query.
func (agb *ArtifactGroupBy) Aggregate(fns ...AggregateFunc) *ArtifactGroupBy {
	agb.fns = append(agb.fns, fns...)
	return agb
}

// Scan applies the group-by query and scans the result into the given value.
func (agb *ArtifactGroupBy) Scan(ctx context.Context, v interface{}) error {
	query, err := agb.path(ctx)
	if err != nil {
		return err
	}
	agb.sql = query
	return agb.sqlScan(ctx, v)
}

// ScanX is like Scan, but panics if an error occurs.
func (agb *ArtifactGroupBy) ScanX(ctx context.Context, v interface{}) {
	if err := agb.Scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from group-by.
// It is only allowed when executing a group-by query with one field.
func (agb *ArtifactGroupBy) Strings(ctx context.Context) ([]string, error) {
	if len(agb.fields) > 1 {
		return nil, errors.New("ent: ArtifactGroupBy.Strings is not achievable when grouping more than 1 field")
	}
	var v []string
	if err := agb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (agb *ArtifactGroupBy) StringsX(ctx context.Context) []string {
	v, err := agb.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (agb *ArtifactGroupBy) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = agb.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = fmt.Errorf("ent: ArtifactGroupBy.Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (agb *ArtifactGroupBy) StringX(ctx context.Context) string {
	v, err := agb.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from group-by.
// It is only allowed when executing a group-by query with one field.
func (agb *ArtifactGroupBy) Ints(ctx context.Context) ([]int, error) {
	if len(agb.fields) > 1 {
		return nil, errors.New("ent: ArtifactGroupBy.Ints is not achievable when grouping more than 1 field")
	}
	var v []int
	if err := agb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (agb *ArtifactGroupBy) IntsX(ctx context.Context) []int {
	v, err := agb.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (agb *ArtifactGroupBy) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = agb.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = fmt.Errorf("ent: ArtifactGroupBy.Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (agb *ArtifactGroupBy) IntX(ctx context.Context) int {
	v, err := agb.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from group-by.
// It is only allowed when executing a group-by query with one field.
func (agb *ArtifactGroupBy) Float64s(ctx context.Context) ([]float64, error) {
	if len(agb.fields) > 1 {
		return nil, errors.New("ent: ArtifactGroupBy.Float64s is not achievable when grouping more than 1 field")
	}
	var v []float64
	if err := agb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (agb *ArtifactGroupBy) Float64sX(ctx context.Context) []float64 {
	v, err := agb.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (agb *ArtifactGroupBy) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = agb.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = fmt.Errorf("ent: ArtifactGroupBy.Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (agb *ArtifactGroupBy) Float64X(ctx context.Context) float64 {
	v, err := agb.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from group-by.
// It is only allowed when executing a group-by query with one field.
func (agb *ArtifactGroupBy) Bools(ctx context.Context) ([]bool, error) {
	if len(agb.fields) > 1 {
		return nil, errors.New("ent: ArtifactGroupBy.Bools is not achievable when grouping more than 1 field")
	}
	var v []bool
	if err := agb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (agb *ArtifactGroupBy) BoolsX(ctx context.Context) []bool {
	v, err := agb.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (agb *ArtifactGroupBy) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = agb.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = fmt.Errorf("ent: ArtifactGroupBy.Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (agb *ArtifactGroupBy) BoolX(ctx context.Context) bool {
	v, err := agb.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (agb *ArtifactGroupBy) sqlScan(ctx context.Context, v interface{}) error {
	for _, f := range agb.fields {
		if !artifact.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("invalid field %q for group-by", f)}
		}
	}
	selector := agb.sqlQuery()
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := agb.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

func (agb *ArtifactGroupBy) sqlQuery() *sql.Selector {
	selector := agb.sql.Select()
	aggregation := make([]string, 0, len(agb.fns))
	for _, fn := range agb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	// If no columns were selected in a custom aggregation function, the default
	// selection is the fields used for "group-by", and the aggregation functions.
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(agb.fields)+len(agb.fns))
		for _, f := range agb.fields {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	return selector.GroupBy(selector.Columns(agb.fields...)...)
}

// ArtifactSelect is the builder for selecting fields of Artifact entities.
type ArtifactSelect struct {
	*ArtifactQuery
	// intermediate query (i.e. traversal path).
	sql *sql.Selector
}

// Scan applies the selector query and scans the result into the given value.
func (as *ArtifactSelect) Scan(ctx context.Context, v interface{}) error {
	if err := as.prepareQuery(ctx); err != nil {
		return err
	}
	as.sql = as.ArtifactQuery.sqlQuery(ctx)
	return as.sqlScan(ctx, v)
}

// ScanX is like Scan, but panics if an error occurs.
func (as *ArtifactSelect) ScanX(ctx context.Context, v interface{}) {
	if err := as.Scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (as *ArtifactSelect) Strings(ctx context.Context) ([]string, error) {
	if len(as.fields) > 1 {
		return nil, errors.New("ent: ArtifactSelect.Strings is not achievable when selecting more than 1 field")
	}
	var v []string
	if err := as.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (as *ArtifactSelect) StringsX(ctx context.Context) []string {
	v, err := as.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (as *ArtifactSelect) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = as.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = fmt.Errorf("ent: ArtifactSelect.Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (as *ArtifactSelect) StringX(ctx context.Context) string {
	v, err := as.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (as *ArtifactSelect) Ints(ctx context.Context) ([]int, error) {
	if len(as.fields) > 1 {
		return nil, errors.New("ent: ArtifactSelect.Ints is not achievable when selecting more than 1 field")
	}
	var v []int
	if err := as.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (as *ArtifactSelect) IntsX(ctx context.Context) []int {
	v, err := as.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (as *ArtifactSelect) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = as.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = fmt.Errorf("ent: ArtifactSelect.Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (as *ArtifactSelect) IntX(ctx context.Context) int {
	v, err := as.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (as *ArtifactSelect) Float64s(ctx context.Context) ([]float64, error) {
	if len(as.fields) > 1 {
		return nil, errors.New("ent: ArtifactSelect.Float64s is not achievable when selecting more than 1 field")
	}
	var v []float64
	if err := as.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (as *ArtifactSelect) Float64sX(ctx context.Context) []float64 {
	v, err := as.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (as *ArtifactSelect) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = as.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = fmt.Errorf("ent: ArtifactSelect.Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (as *ArtifactSelect) Float64X(ctx context.Context) float64 {
	v, err := as.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (as *ArtifactSelect) Bools(ctx context.Context) ([]bool, error) {
	if len(as.fields) > 1 {
		return nil, errors.New("ent: ArtifactSelect.Bools is not achievable when selecting more than 1 field")
	}
	var v []bool
	if err := as.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (as *ArtifactSelect) BoolsX(ctx context.Context) []bool {
	v, err := as.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (as *ArtifactSelect) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = as.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{artifact.Label}
	default:
		err = fmt.Errorf("ent: ArtifactSelect.Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (as *ArtifactSelect) BoolX(ctx context.Context) bool {
	v, err := as.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (as *ArtifactSelect) sqlScan(ctx context.Context, v interface{}) error {
	rows := &sql.Rows{}
	query, args := as.sql.Query()
	if err := as.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

```

`app/bugu/service/internal/data/ent/artifact_update.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// ArtifactUpdate is the builder for updating Artifact entities.
type ArtifactUpdate struct {
	config
	hooks    []Hook
	mutation *ArtifactMutation
}

// Where appends a list predicates to the ArtifactUpdate builder.
func (au *ArtifactUpdate) Where(ps ...predicate.Artifact) *ArtifactUpdate {
	au.mutation.Where(ps...)
	return au
}

// SetFileID sets the "file_id" field.
func (au *ArtifactUpdate) SetFileID(u uuid.UUID) *ArtifactUpdate {
	au.mutation.SetFileID(u)
	return au
}

// SetAffiliatedFileID sets the "affiliated_file_id" field.
func (au *ArtifactUpdate) SetAffiliatedFileID(u uuid.UUID) *ArtifactUpdate {
	au.mutation.SetAffiliatedFileID(u)
	return au
}

// SetMethod sets the "method" field.
func (au *ArtifactUpdate) SetMethod(s string) *ArtifactUpdate {
	au.mutation.SetMethod(s)
	return au
}

// SetNillableMethod sets the "method" field if the given value is not nil.
func (au *ArtifactUpdate) SetNillableMethod(s *string) *ArtifactUpdate {
	if s != nil {
		au.SetMethod(*s)
	}
	return au
}

// ClearMethod clears the value of the "method" field.
func (au *ArtifactUpdate) ClearMethod() *ArtifactUpdate {
	au.mutation.ClearMethod()
	return au
}

// SetUpdatedAt sets the "updated_at" field.
func (au *ArtifactUpdate) SetUpdatedAt(t time.Time) *ArtifactUpdate {
	au.mutation.SetUpdatedAt(t)
	return au
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (au *ArtifactUpdate) SetNillableUpdatedAt(t *time.Time) *ArtifactUpdate {
	if t != nil {
		au.SetUpdatedAt(*t)
	}
	return au
}

// AddAffiliatedFileIDs adds the "affiliated_file" edge to the File entity by IDs.
func (au *ArtifactUpdate) AddAffiliatedFileIDs(ids ...uuid.UUID) *ArtifactUpdate {
	au.mutation.AddAffiliatedFileIDs(ids...)
	return au
}

// AddAffiliatedFile adds the "affiliated_file" edges to the File entity.
func (au *ArtifactUpdate) AddAffiliatedFile(f ...*File) *ArtifactUpdate {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return au.AddAffiliatedFileIDs(ids...)
}

// AddAffiliatedUserIDs adds the "affiliated_user" edge to the User entity by IDs.
func (au *ArtifactUpdate) AddAffiliatedUserIDs(ids ...uuid.UUID) *ArtifactUpdate {
	au.mutation.AddAffiliatedUserIDs(ids...)
	return au
}

// AddAffiliatedUser adds the "affiliated_user" edges to the User entity.
func (au *ArtifactUpdate) AddAffiliatedUser(u ...*User) *ArtifactUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return au.AddAffiliatedUserIDs(ids...)
}

// Mutation returns the ArtifactMutation object of the builder.
func (au *ArtifactUpdate) Mutation() *ArtifactMutation {
	return au.mutation
}

// ClearAffiliatedFile clears all "affiliated_file" edges to the File entity.
func (au *ArtifactUpdate) ClearAffiliatedFile() *ArtifactUpdate {
	au.mutation.ClearAffiliatedFile()
	return au
}

// RemoveAffiliatedFileIDs removes the "affiliated_file" edge to File entities by IDs.
func (au *ArtifactUpdate) RemoveAffiliatedFileIDs(ids ...uuid.UUID) *ArtifactUpdate {
	au.mutation.RemoveAffiliatedFileIDs(ids...)
	return au
}

// RemoveAffiliatedFile removes "affiliated_file" edges to File entities.
func (au *ArtifactUpdate) RemoveAffiliatedFile(f ...*File) *ArtifactUpdate {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return au.RemoveAffiliatedFileIDs(ids...)
}

// ClearAffiliatedUser clears all "affiliated_user" edges to the User entity.
func (au *ArtifactUpdate) ClearAffiliatedUser() *ArtifactUpdate {
	au.mutation.ClearAffiliatedUser()
	return au
}

// RemoveAffiliatedUserIDs removes the "affiliated_user" edge to User entities by IDs.
func (au *ArtifactUpdate) RemoveAffiliatedUserIDs(ids ...uuid.UUID) *ArtifactUpdate {
	au.mutation.RemoveAffiliatedUserIDs(ids...)
	return au
}

// RemoveAffiliatedUser removes "affiliated_user" edges to User entities.
func (au *ArtifactUpdate) RemoveAffiliatedUser(u ...*User) *ArtifactUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return au.RemoveAffiliatedUserIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (au *ArtifactUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(au.hooks) == 0 {
		affected, err = au.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ArtifactMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			au.mutation = mutation
			affected, err = au.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(au.hooks) - 1; i >= 0; i-- {
			if au.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = au.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, au.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (au *ArtifactUpdate) SaveX(ctx context.Context) int {
	affected, err := au.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (au *ArtifactUpdate) Exec(ctx context.Context) error {
	_, err := au.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (au *ArtifactUpdate) ExecX(ctx context.Context) {
	if err := au.Exec(ctx); err != nil {
		panic(err)
	}
}

func (au *ArtifactUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   artifact.Table,
			Columns: artifact.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: artifact.FieldID,
			},
		},
	}
	if ps := au.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := au.mutation.FileID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUUID,
			Value:  value,
			Column: artifact.FieldFileID,
		})
	}
	if value, ok := au.mutation.AffiliatedFileID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUUID,
			Value:  value,
			Column: artifact.FieldAffiliatedFileID,
		})
	}
	if value, ok := au.mutation.Method(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: artifact.FieldMethod,
		})
	}
	if au.mutation.MethodCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: artifact.FieldMethod,
		})
	}
	if value, ok := au.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: artifact.FieldUpdatedAt,
		})
	}
	if au.mutation.AffiliatedFileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   artifact.AffiliatedFileTable,
			Columns: []string{artifact.AffiliatedFileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedAffiliatedFileIDs(); len(nodes) > 0 && !au.mutation.AffiliatedFileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   artifact.AffiliatedFileTable,
			Columns: []string{artifact.AffiliatedFileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.AffiliatedFileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   artifact.AffiliatedFileTable,
			Columns: []string{artifact.AffiliatedFileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.AffiliatedUserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   artifact.AffiliatedUserTable,
			Columns: artifact.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedAffiliatedUserIDs(); len(nodes) > 0 && !au.mutation.AffiliatedUserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   artifact.AffiliatedUserTable,
			Columns: artifact.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.AffiliatedUserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   artifact.AffiliatedUserTable,
			Columns: artifact.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, au.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{artifact.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return 0, err
	}
	return n, nil
}

// ArtifactUpdateOne is the builder for updating a single Artifact entity.
type ArtifactUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ArtifactMutation
}

// SetFileID sets the "file_id" field.
func (auo *ArtifactUpdateOne) SetFileID(u uuid.UUID) *ArtifactUpdateOne {
	auo.mutation.SetFileID(u)
	return auo
}

// SetAffiliatedFileID sets the "affiliated_file_id" field.
func (auo *ArtifactUpdateOne) SetAffiliatedFileID(u uuid.UUID) *ArtifactUpdateOne {
	auo.mutation.SetAffiliatedFileID(u)
	return auo
}

// SetMethod sets the "method" field.
func (auo *ArtifactUpdateOne) SetMethod(s string) *ArtifactUpdateOne {
	auo.mutation.SetMethod(s)
	return auo
}

// SetNillableMethod sets the "method" field if the given value is not nil.
func (auo *ArtifactUpdateOne) SetNillableMethod(s *string) *ArtifactUpdateOne {
	if s != nil {
		auo.SetMethod(*s)
	}
	return auo
}

// ClearMethod clears the value of the "method" field.
func (auo *ArtifactUpdateOne) ClearMethod() *ArtifactUpdateOne {
	auo.mutation.ClearMethod()
	return auo
}

// SetUpdatedAt sets the "updated_at" field.
func (auo *ArtifactUpdateOne) SetUpdatedAt(t time.Time) *ArtifactUpdateOne {
	auo.mutation.SetUpdatedAt(t)
	return auo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (auo *ArtifactUpdateOne) SetNillableUpdatedAt(t *time.Time) *ArtifactUpdateOne {
	if t != nil {
		auo.SetUpdatedAt(*t)
	}
	return auo
}

// AddAffiliatedFileIDs adds the "affiliated_file" edge to the File entity by IDs.
func (auo *ArtifactUpdateOne) AddAffiliatedFileIDs(ids ...uuid.UUID) *ArtifactUpdateOne {
	auo.mutation.AddAffiliatedFileIDs(ids...)
	return auo
}

// AddAffiliatedFile adds the "affiliated_file" edges to the File entity.
func (auo *ArtifactUpdateOne) AddAffiliatedFile(f ...*File) *ArtifactUpdateOne {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return auo.AddAffiliatedFileIDs(ids...)
}

// AddAffiliatedUserIDs adds the "affiliated_user" edge to the User entity by IDs.
func (auo *ArtifactUpdateOne) AddAffiliatedUserIDs(ids ...uuid.UUID) *ArtifactUpdateOne {
	auo.mutation.AddAffiliatedUserIDs(ids...)
	return auo
}

// AddAffiliatedUser adds the "affiliated_user" edges to the User entity.
func (auo *ArtifactUpdateOne) AddAffiliatedUser(u ...*User) *ArtifactUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return auo.AddAffiliatedUserIDs(ids...)
}

// Mutation returns the ArtifactMutation object of the builder.
func (auo *ArtifactUpdateOne) Mutation() *ArtifactMutation {
	return auo.mutation
}

// ClearAffiliatedFile clears all "affiliated_file" edges to the File entity.
func (auo *ArtifactUpdateOne) ClearAffiliatedFile() *ArtifactUpdateOne {
	auo.mutation.ClearAffiliatedFile()
	return auo
}

// RemoveAffiliatedFileIDs removes the "affiliated_file" edge to File entities by IDs.
func (auo *ArtifactUpdateOne) RemoveAffiliatedFileIDs(ids ...uuid.UUID) *ArtifactUpdateOne {
	auo.mutation.RemoveAffiliatedFileIDs(ids...)
	return auo
}

// RemoveAffiliatedFile removes "affiliated_file" edges to File entities.
func (auo *ArtifactUpdateOne) RemoveAffiliatedFile(f ...*File) *ArtifactUpdateOne {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return auo.RemoveAffiliatedFileIDs(ids...)
}

// ClearAffiliatedUser clears all "affiliated_user" edges to the User entity.
func (auo *ArtifactUpdateOne) ClearAffiliatedUser() *ArtifactUpdateOne {
	auo.mutation.ClearAffiliatedUser()
	return auo
}

// RemoveAffiliatedUserIDs removes the "affiliated_user" edge to User entities by IDs.
func (auo *ArtifactUpdateOne) RemoveAffiliatedUserIDs(ids ...uuid.UUID) *ArtifactUpdateOne {
	auo.mutation.RemoveAffiliatedUserIDs(ids...)
	return auo
}

// RemoveAffiliatedUser removes "affiliated_user" edges to User entities.
func (auo *ArtifactUpdateOne) RemoveAffiliatedUser(u ...*User) *ArtifactUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return auo.RemoveAffiliatedUserIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (auo *ArtifactUpdateOne) Select(field string, fields ...string) *ArtifactUpdateOne {
	auo.fields = append([]string{field}, fields...)
	return auo
}

// Save executes the query and returns the updated Artifact entity.
func (auo *ArtifactUpdateOne) Save(ctx context.Context) (*Artifact, error) {
	var (
		err  error
		node *Artifact
	)
	if len(auo.hooks) == 0 {
		node, err = auo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ArtifactMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			auo.mutation = mutation
			node, err = auo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(auo.hooks) - 1; i >= 0; i-- {
			if auo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = auo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, auo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (auo *ArtifactUpdateOne) SaveX(ctx context.Context) *Artifact {
	node, err := auo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (auo *ArtifactUpdateOne) Exec(ctx context.Context) error {
	_, err := auo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (auo *ArtifactUpdateOne) ExecX(ctx context.Context) {
	if err := auo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (auo *ArtifactUpdateOne) sqlSave(ctx context.Context) (_node *Artifact, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   artifact.Table,
			Columns: artifact.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: artifact.FieldID,
			},
		},
	}
	id, ok := auo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Artifact.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := auo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, artifact.FieldID)
		for _, f := range fields {
			if !artifact.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != artifact.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := auo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := auo.mutation.FileID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUUID,
			Value:  value,
			Column: artifact.FieldFileID,
		})
	}
	if value, ok := auo.mutation.AffiliatedFileID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUUID,
			Value:  value,
			Column: artifact.FieldAffiliatedFileID,
		})
	}
	if value, ok := auo.mutation.Method(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: artifact.FieldMethod,
		})
	}
	if auo.mutation.MethodCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: artifact.FieldMethod,
		})
	}
	if value, ok := auo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: artifact.FieldUpdatedAt,
		})
	}
	if auo.mutation.AffiliatedFileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   artifact.AffiliatedFileTable,
			Columns: []string{artifact.AffiliatedFileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedAffiliatedFileIDs(); len(nodes) > 0 && !auo.mutation.AffiliatedFileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   artifact.AffiliatedFileTable,
			Columns: []string{artifact.AffiliatedFileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.AffiliatedFileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   artifact.AffiliatedFileTable,
			Columns: []string{artifact.AffiliatedFileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.AffiliatedUserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   artifact.AffiliatedUserTable,
			Columns: artifact.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedAffiliatedUserIDs(); len(nodes) > 0 && !auo.mutation.AffiliatedUserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   artifact.AffiliatedUserTable,
			Columns: artifact.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.AffiliatedUserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   artifact.AffiliatedUserTable,
			Columns: artifact.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Artifact{config: auo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, auo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{artifact.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	return _node, nil
}

```

`app/bugu/service/internal/data/ent/client.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/migrate"

	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artifact = NewArtifactClient(c.config)
	c.File = NewFileClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:      ctx,
		config:   cfg,
		Artifact: NewArtifactClient(cfg),
		File:     NewFileClient(cfg),
		User:     NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:      ctx,
		config:   cfg,
		Artifact: NewArtifactClient(cfg),
		File:     NewFileClient(cfg),
		User:     NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artifact.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Artifact.Use(hooks...)
	c.File.Use(hooks...)
	c.User.Use(hooks...)
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Create returns a create builder for Artifact.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id uuid.UUID) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ArtifactClient) DeleteOneID(id uuid.UUID) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id uuid.UUID) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id uuid.UUID) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAffiliatedFile queries the affiliated_file edge of a Artifact.
func (c *ArtifactClient) QueryAffiliatedFile(a *Artifact) *FileQuery {
	query := &FileQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, artifact.AffiliatedFileTable, artifact.AffiliatedFileColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAffiliatedUser queries the affiliated_user edge of a Artifact.
func (c *ArtifactClient) QueryAffiliatedUser(a *Artifact) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, artifact.AffiliatedUserTable, artifact.AffiliatedUserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	return c.hooks.Artifact
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Create returns a create builder for File.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(f *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(f))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id uuid.UUID) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *FileClient) DeleteOne(f *File) *FileDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *FileClient) DeleteOneID(id uuid.UUID) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id uuid.UUID) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id uuid.UUID) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifact queries the artifact edge of a File.
func (c *FileClient) QueryArtifact(f *File) *ArtifactQuery {
	query := &ArtifactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, file.ArtifactTable, file.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAffiliatedUser queries the affiliated_user edge of a File.
func (c *FileClient) QueryAffiliatedUser(f *File) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.AffiliatedUserTable, file.AffiliatedUserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	return c.hooks.File
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserFile queries the user_file edge of a User.
func (c *UserClient) QueryUserFile(u *User) *FileQuery {
	query := &FileQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.UserFileTable, user.UserFilePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserArtifact queries the user_artifact edge of a User.
func (c *UserClient) QueryUserArtifact(u *User) *ArtifactQuery {
	query := &ArtifactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.UserArtifactTable, user.UserArtifactPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

```

`app/bugu/service/internal/data/ent/config.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect"
)

// Option function to configure the client.
type Option func(*config)

// Config is the configuration for the client and its builder.
type config struct {
	// driver used for executing database requests.
	driver dialect.Driver
	// debug enable a debug logging.
	debug bool
	// log used for logging on debug mode.
	log func(...interface{})
	// hooks to execute on mutations.
	hooks *hooks
}

// hooks per client, for fast access.
type hooks struct {
	Artifact []ent.Hook
	File     []ent.Hook
	User     []ent.Hook
}

// Options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...interface{})) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

```

`app/bugu/service/internal/data/ent/context.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
)

type clientCtxKey struct{}

// FromContext returns a Client stored inside a context, or nil if there isn't one.
func FromContext(ctx context.Context) *Client {
	c, _ := ctx.Value(clientCtxKey{}).(*Client)
	return c
}

// NewContext returns a new context with the given Client attached.
func NewContext(parent context.Context, c *Client) context.Context {
	return context.WithValue(parent, clientCtxKey{}, c)
}

type txCtxKey struct{}

// TxFromContext returns a Tx stored inside a context, or nil if there isn't one.
func TxFromContext(ctx context.Context) *Tx {
	tx, _ := ctx.Value(txCtxKey{}).(*Tx)
	return tx
}

// NewTxContext returns a new context with the given Tx attached.
func NewTxContext(parent context.Context, tx *Tx) context.Context {
	return context.WithValue(parent, txCtxKey{}, tx)
}

```

`app/bugu/service/internal/data/ent/ent.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// ent aliases to avoid import conflicts in user's code.
type (
	Op         = ent.Op
	Hook       = ent.Hook
	Value      = ent.Value
	Query      = ent.Query
	Policy     = ent.Policy
	Mutator    = ent.Mutator
	Mutation   = ent.Mutation
	MutateFunc = ent.MutateFunc
)

// OrderFunc applies an ordering on the sql selector.
type OrderFunc func(*sql.Selector)

// columnChecker returns a function indicates if the column exists in the given column.
func columnChecker(table string) func(string) error {
	checks := map[string]func(string) bool{
		artifact.Table: artifact.ValidColumn,
		file.Table:     file.ValidColumn,
		user.Table:     user.ValidColumn,
	}
	check, ok := checks[table]
	if !ok {
		return func(string) error {
			return fmt.Errorf("unknown table %q", table)
		}
	}
	return func(column string) error {
		if !check(column) {
			return fmt.Errorf("unknown column %q for table %q", column, table)
		}
		return nil
	}
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
			}
			s.OrderBy(sql.Asc(s.C(f)))
		}
	}
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
			}
			s.OrderBy(sql.Desc(s.C(f)))
		}
	}
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//	GroupBy(field1, field2).
//	Aggregate(ent.As(ent.Sum(field1), "sum_field1"), (ent.As(ent.Sum(field2), "sum_field2")).
//	Scan(ctx, &v)
//
func As(fn AggregateFunc, end string) AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.As(fn(s), end)
	}
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.Count("*")
	}
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
			return ""
		}
		return sql.Max(s.C(field))
	}
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
			return ""
		}
		return sql.Avg(s.C(field))
	}
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
			return ""
		}
		return sql.Min(s.C(field))
	}
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
			return ""
		}
		return sql.Sum(s.C(field))
	}
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
	Name string // Field or edge name.
	err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string {
	return e.err.Error()
}

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error {
	return e.err
}

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool {
	if err == nil {
		return false
	}
	var e *ValidationError
	return errors.As(err, &e)
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
	label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string {
	return "ent: " + e.label + " not found"
}

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	var e *NotFoundError
	return errors.As(err, &e)
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error {
	if IsNotFound(err) {
		return nil
	}
	return err
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
	label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string {
	return "ent: " + e.label + " not singular"
}

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool {
	if err == nil {
		return false
	}
	var e *NotSingularError
	return errors.As(err, &e)
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
	edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string {
	return "ent: " + e.edge + " edge was not loaded"
}

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool {
	if err == nil {
		return false
	}
	var e *NotLoadedError
	return errors.As(err, &e)
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
	msg  string
	wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string {
	return "ent: constraint failed: " + e.msg
}

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error {
	return e.wrap
}

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool {
	if err == nil {
		return false
	}
	var e *ConstraintError
	return errors.As(err, &e)
}

```

`app/bugu/service/internal/data/ent/enttest/enttest.go`:

```go
// Code generated by entc, DO NOT EDIT.

package enttest

import (
	"context"

	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent"
	// required by schema hooks.
	_ "github.com/hominsu/bugu/app/bugu/service/internal/data/ent/runtime"

	"entgo.io/ent/dialect/sql/schema"
)

type (
	// TestingT is the interface that is shared between
	// testing.T and testing.B and used by enttest.
	TestingT interface {
		FailNow()
		Error(...interface{})
	}

	// Option configures client creation.
	Option func(*options)

	options struct {
		opts        []ent.Option
		migrateOpts []schema.MigrateOption
	}
)

// WithOptions forwards options to client creation.
func WithOptions(opts ...ent.Option) Option {
	return func(o *options) {
		o.opts = append(o.opts, opts...)
	}
}

// WithMigrateOptions forwards options to auto migration.
func WithMigrateOptions(opts ...schema.MigrateOption) Option {
	return func(o *options) {
		o.migrateOpts = append(o.migrateOpts, opts...)
	}
}

func newOptions(opts []Option) *options {
	o := &options{}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

// Open calls ent.Open and auto-run migration.
func Open(t TestingT, driverName, dataSourceName string, opts ...Option) *ent.Client {
	o := newOptions(opts)
	c, err := ent.Open(driverName, dataSourceName, o.opts...)
	if err != nil {
		t.Error(err)
		t.FailNow()
	}
	if err := c.Schema.Create(context.Background(), o.migrateOpts...); err != nil {
		t.Error(err)
		t.FailNow()
	}
	return c
}

// NewClient calls ent.NewClient and auto-run migration.
func NewClient(t TestingT, opts ...Option) *ent.Client {
	o := newOptions(opts)
	c := ent.NewClient(o.opts...)
	if err := c.Schema.Create(context.Background(), o.migrateOpts...); err != nil {
		t.Error(err)
		t.FailNow()
	}
	return c
}

```

`app/bugu/service/internal/data/ent/file.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
)

// File is the model entity for the File schema.
type File struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// FileSha1 holds the value of the "file_sha_1" field.
	FileSha1 string `json:"file_sha_1,omitempty"`
	// FileSize holds the value of the "file_size" field.
	FileSize int64 `json:"file_size,omitempty"`
	// FileAddr holds the value of the "file_addr" field.
	FileAddr string `json:"file_addr,omitempty"`
	// Type holds the value of the "type" field.
	Type file.Type `json:"type,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the FileQuery when eager-loading is set.
	Edges         FileEdges `json:"edges"`
	file_artifact *uuid.UUID
}

// FileEdges holds the relations/edges for other nodes in the graph.
type FileEdges struct {
	// Artifact holds the value of the artifact edge.
	Artifact *Artifact `json:"artifact,omitempty"`
	// AffiliatedUser holds the value of the affiliated_user edge.
	AffiliatedUser []*User `json:"affiliated_user,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// ArtifactOrErr returns the Artifact value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e FileEdges) ArtifactOrErr() (*Artifact, error) {
	if e.loadedTypes[0] {
		if e.Artifact == nil {
			// The edge artifact was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: artifact.Label}
		}
		return e.Artifact, nil
	}
	return nil, &NotLoadedError{edge: "artifact"}
}

// AffiliatedUserOrErr returns the AffiliatedUser value or an error if the edge
// was not loaded in eager-loading.
func (e FileEdges) AffiliatedUserOrErr() ([]*User, error) {
	if e.loadedTypes[1] {
		return e.AffiliatedUser, nil
	}
	return nil, &NotLoadedError{edge: "affiliated_user"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*File) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case file.FieldFileSize:
			values[i] = new(sql.NullInt64)
		case file.FieldFileSha1, file.FieldFileAddr, file.FieldType:
			values[i] = new(sql.NullString)
		case file.FieldCreatedAt, file.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case file.FieldID:
			values[i] = new(uuid.UUID)
		case file.ForeignKeys[0]: // file_artifact
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		default:
			return nil, fmt.Errorf("unexpected column %q for type File", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the File fields.
func (f *File) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case file.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				f.ID = *value
			}
		case file.FieldFileSha1:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_sha_1", values[i])
			} else if value.Valid {
				f.FileSha1 = value.String
			}
		case file.FieldFileSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field file_size", values[i])
			} else if value.Valid {
				f.FileSize = value.Int64
			}
		case file.FieldFileAddr:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_addr", values[i])
			} else if value.Valid {
				f.FileAddr = value.String
			}
		case file.FieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[i])
			} else if value.Valid {
				f.Type = file.Type(value.String)
			}
		case file.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				f.CreatedAt = value.Time
			}
		case file.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				f.UpdatedAt = value.Time
			}
		case file.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field file_artifact", values[i])
			} else if value.Valid {
				f.file_artifact = new(uuid.UUID)
				*f.file_artifact = *value.S.(*uuid.UUID)
			}
		}
	}
	return nil
}

// QueryArtifact queries the "artifact" edge of the File entity.
func (f *File) QueryArtifact() *ArtifactQuery {
	return (&FileClient{config: f.config}).QueryArtifact(f)
}

// QueryAffiliatedUser queries the "affiliated_user" edge of the File entity.
func (f *File) QueryAffiliatedUser() *UserQuery {
	return (&FileClient{config: f.config}).QueryAffiliatedUser(f)
}

// Update returns a builder for updating this File.
// Note that you need to call File.Unwrap() before calling this method if this File
// was returned from a transaction, and the transaction was committed or rolled back.
func (f *File) Update() *FileUpdateOne {
	return (&FileClient{config: f.config}).UpdateOne(f)
}

// Unwrap unwraps the File entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (f *File) Unwrap() *File {
	tx, ok := f.config.driver.(*txDriver)
	if !ok {
		panic("ent: File is not a transactional entity")
	}
	f.config.driver = tx.drv
	return f
}

// String implements the fmt.Stringer.
func (f *File) String() string {
	var builder strings.Builder
	builder.WriteString("File(")
	builder.WriteString(fmt.Sprintf("id=%v", f.ID))
	builder.WriteString(", file_sha_1=")
	builder.WriteString(f.FileSha1)
	builder.WriteString(", file_size=")
	builder.WriteString(fmt.Sprintf("%v", f.FileSize))
	builder.WriteString(", file_addr=")
	builder.WriteString(f.FileAddr)
	builder.WriteString(", type=")
	builder.WriteString(fmt.Sprintf("%v", f.Type))
	builder.WriteString(", created_at=")
	builder.WriteString(f.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updated_at=")
	builder.WriteString(f.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Files is a parsable slice of File.
type Files []*File

func (f Files) config(cfg config) {
	for _i := range f {
		f[_i].config = cfg
	}
}

```

`app/bugu/service/internal/data/ent/file/file.go`:

```go
// Code generated by entc, DO NOT EDIT.

package file

import (
	"fmt"
	"time"
)

const (
	// Label holds the string label denoting the file type in the database.
	Label = "file"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldFileSha1 holds the string denoting the file_sha_1 field in the database.
	FieldFileSha1 = "file_sha_1"
	// FieldFileSize holds the string denoting the file_size field in the database.
	FieldFileSize = "file_size"
	// FieldFileAddr holds the string denoting the file_addr field in the database.
	FieldFileAddr = "file_addr"
	// FieldType holds the string denoting the type field in the database.
	FieldType = "type"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// EdgeArtifact holds the string denoting the artifact edge name in mutations.
	EdgeArtifact = "artifact"
	// EdgeAffiliatedUser holds the string denoting the affiliated_user edge name in mutations.
	EdgeAffiliatedUser = "affiliated_user"
	// Table holds the table name of the file in the database.
	Table = "files"
	// ArtifactTable is the table that holds the artifact relation/edge.
	ArtifactTable = "files"
	// ArtifactInverseTable is the table name for the Artifact entity.
	// It exists in this package in order to avoid circular dependency with the "artifact" package.
	ArtifactInverseTable = "artifacts"
	// ArtifactColumn is the table column denoting the artifact relation/edge.
	ArtifactColumn = "file_artifact"
	// AffiliatedUserTable is the table that holds the affiliated_user relation/edge. The primary key declared below.
	AffiliatedUserTable = "user_user_file"
	// AffiliatedUserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	AffiliatedUserInverseTable = "users"
)

// Columns holds all SQL columns for file fields.
var Columns = []string{
	FieldID,
	FieldFileSha1,
	FieldFileSize,
	FieldFileAddr,
	FieldType,
	FieldCreatedAt,
	FieldUpdatedAt,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "files"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"file_artifact",
}

var (
	// AffiliatedUserPrimaryKey and AffiliatedUserColumn2 are the table columns denoting the
	// primary key for the affiliated_user relation (M2M).
	AffiliatedUserPrimaryKey = []string{"user_id", "file_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
)

// Type defines the type for the "type" enum field.
type Type string

// TypeOther is the default value of the Type enum.
const DefaultType = TypeOther

// Type values.
const (
	TypeAdposhel    Type = "Adposhel"
	TypeAgent       Type = "Agent"
	TypeAllaple     Type = "Allaple"
	TypeAmonetize   Type = "Amonetize"
	TypeAndrom      Type = "Androm"
	TypeAutorun     Type = "Autorun"
	TypeBrowseFox   Type = "BrowseFox"
	TypeDinwod      Type = "Dinwod"
	TypeElex        Type = "Elex"
	TypeExpiro      Type = "Expiro"
	TypeFasong      Type = "Fasong"
	TypeHackKMS     Type = "HackKMS"
	TypeHlux        Type = "Hlux"
	TypeInjector    Type = "Injector"
	TypeInstallCore Type = "InstallCore"
	TypeMultiPlug   Type = "MultiPlug"
	TypeNeoreklami  Type = "Neoreklami"
	TypeNeshta      Type = "Neshta"
	TypeOther       Type = "Other"
	TypeRegrun      Type = "Regrun"
	TypeSality      Type = "Sality"
	TypeSnarasite   Type = "Snarasite"
	TypeStantinko   Type = "Stantinko"
	TypeVBA         Type = "VBA"
	TypeVBKrypt     Type = "VBKrypt"
	TypeVilsel      Type = "Vilsel"
)

func (_type Type) String() string {
	return string(_type)
}

// TypeValidator is a validator for the "type" field enum values. It is called by the builders before save.
func TypeValidator(_type Type) error {
	switch _type {
	case TypeAdposhel, TypeAgent, TypeAllaple, TypeAmonetize, TypeAndrom, TypeAutorun, TypeBrowseFox, TypeDinwod, TypeElex, TypeExpiro, TypeFasong, TypeHackKMS, TypeHlux, TypeInjector, TypeInstallCore, TypeMultiPlug, TypeNeoreklami, TypeNeshta, TypeOther, TypeRegrun, TypeSality, TypeSnarasite, TypeStantinko, TypeVBA, TypeVBKrypt, TypeVilsel:
		return nil
	default:
		return fmt.Errorf("file: invalid enum value for type field: %q", _type)
	}
}

```

`app/bugu/service/internal/data/ent/file/where.go`:

```go
// Code generated by entc, DO NOT EDIT.

package file

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// FileSha1 applies equality check predicate on the "file_sha_1" field. It's identical to FileSha1EQ.
func FileSha1(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileSha1), v))
	})
}

// FileSize applies equality check predicate on the "file_size" field. It's identical to FileSizeEQ.
func FileSize(v int64) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileSize), v))
	})
}

// FileAddr applies equality check predicate on the "file_addr" field. It's identical to FileAddrEQ.
func FileAddr(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileAddr), v))
	})
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// FileSha1EQ applies the EQ predicate on the "file_sha_1" field.
func FileSha1EQ(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileSha1), v))
	})
}

// FileSha1NEQ applies the NEQ predicate on the "file_sha_1" field.
func FileSha1NEQ(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFileSha1), v))
	})
}

// FileSha1In applies the In predicate on the "file_sha_1" field.
func FileSha1In(vs ...string) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFileSha1), v...))
	})
}

// FileSha1NotIn applies the NotIn predicate on the "file_sha_1" field.
func FileSha1NotIn(vs ...string) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFileSha1), v...))
	})
}

// FileSha1GT applies the GT predicate on the "file_sha_1" field.
func FileSha1GT(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFileSha1), v))
	})
}

// FileSha1GTE applies the GTE predicate on the "file_sha_1" field.
func FileSha1GTE(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFileSha1), v))
	})
}

// FileSha1LT applies the LT predicate on the "file_sha_1" field.
func FileSha1LT(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFileSha1), v))
	})
}

// FileSha1LTE applies the LTE predicate on the "file_sha_1" field.
func FileSha1LTE(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFileSha1), v))
	})
}

// FileSha1Contains applies the Contains predicate on the "file_sha_1" field.
func FileSha1Contains(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFileSha1), v))
	})
}

// FileSha1HasPrefix applies the HasPrefix predicate on the "file_sha_1" field.
func FileSha1HasPrefix(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFileSha1), v))
	})
}

// FileSha1HasSuffix applies the HasSuffix predicate on the "file_sha_1" field.
func FileSha1HasSuffix(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFileSha1), v))
	})
}

// FileSha1EqualFold applies the EqualFold predicate on the "file_sha_1" field.
func FileSha1EqualFold(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFileSha1), v))
	})
}

// FileSha1ContainsFold applies the ContainsFold predicate on the "file_sha_1" field.
func FileSha1ContainsFold(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFileSha1), v))
	})
}

// FileSizeEQ applies the EQ predicate on the "file_size" field.
func FileSizeEQ(v int64) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileSize), v))
	})
}

// FileSizeNEQ applies the NEQ predicate on the "file_size" field.
func FileSizeNEQ(v int64) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFileSize), v))
	})
}

// FileSizeIn applies the In predicate on the "file_size" field.
func FileSizeIn(vs ...int64) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFileSize), v...))
	})
}

// FileSizeNotIn applies the NotIn predicate on the "file_size" field.
func FileSizeNotIn(vs ...int64) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFileSize), v...))
	})
}

// FileSizeGT applies the GT predicate on the "file_size" field.
func FileSizeGT(v int64) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFileSize), v))
	})
}

// FileSizeGTE applies the GTE predicate on the "file_size" field.
func FileSizeGTE(v int64) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFileSize), v))
	})
}

// FileSizeLT applies the LT predicate on the "file_size" field.
func FileSizeLT(v int64) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFileSize), v))
	})
}

// FileSizeLTE applies the LTE predicate on the "file_size" field.
func FileSizeLTE(v int64) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFileSize), v))
	})
}

// FileAddrEQ applies the EQ predicate on the "file_addr" field.
func FileAddrEQ(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileAddr), v))
	})
}

// FileAddrNEQ applies the NEQ predicate on the "file_addr" field.
func FileAddrNEQ(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFileAddr), v))
	})
}

// FileAddrIn applies the In predicate on the "file_addr" field.
func FileAddrIn(vs ...string) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFileAddr), v...))
	})
}

// FileAddrNotIn applies the NotIn predicate on the "file_addr" field.
func FileAddrNotIn(vs ...string) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFileAddr), v...))
	})
}

// FileAddrGT applies the GT predicate on the "file_addr" field.
func FileAddrGT(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFileAddr), v))
	})
}

// FileAddrGTE applies the GTE predicate on the "file_addr" field.
func FileAddrGTE(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFileAddr), v))
	})
}

// FileAddrLT applies the LT predicate on the "file_addr" field.
func FileAddrLT(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFileAddr), v))
	})
}

// FileAddrLTE applies the LTE predicate on the "file_addr" field.
func FileAddrLTE(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFileAddr), v))
	})
}

// FileAddrContains applies the Contains predicate on the "file_addr" field.
func FileAddrContains(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFileAddr), v))
	})
}

// FileAddrHasPrefix applies the HasPrefix predicate on the "file_addr" field.
func FileAddrHasPrefix(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFileAddr), v))
	})
}

// FileAddrHasSuffix applies the HasSuffix predicate on the "file_addr" field.
func FileAddrHasSuffix(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFileAddr), v))
	})
}

// FileAddrEqualFold applies the EqualFold predicate on the "file_addr" field.
func FileAddrEqualFold(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFileAddr), v))
	})
}

// FileAddrContainsFold applies the ContainsFold predicate on the "file_addr" field.
func FileAddrContainsFold(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFileAddr), v))
	})
}

// TypeEQ applies the EQ predicate on the "type" field.
func TypeEQ(v Type) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// TypeNEQ applies the NEQ predicate on the "type" field.
func TypeNEQ(v Type) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldType), v))
	})
}

// TypeIn applies the In predicate on the "type" field.
func TypeIn(vs ...Type) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldType), v...))
	})
}

// TypeNotIn applies the NotIn predicate on the "type" field.
func TypeNotIn(vs ...Type) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldType), v...))
	})
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.File {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.File(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedAt), v))
	})
}

// HasArtifact applies the HasEdge predicate on the "artifact" edge.
func HasArtifact() predicate.File {
	return predicate.File(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ArtifactTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, ArtifactTable, ArtifactColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasArtifactWith applies the HasEdge predicate on the "artifact" edge with a given conditions (other predicates).
func HasArtifactWith(preds ...predicate.Artifact) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ArtifactInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, ArtifactTable, ArtifactColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAffiliatedUser applies the HasEdge predicate on the "affiliated_user" edge.
func HasAffiliatedUser() predicate.File {
	return predicate.File(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AffiliatedUserTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, AffiliatedUserTable, AffiliatedUserPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAffiliatedUserWith applies the HasEdge predicate on the "affiliated_user" edge with a given conditions (other predicates).
func HasAffiliatedUserWith(preds ...predicate.User) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AffiliatedUserInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, AffiliatedUserTable, AffiliatedUserPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.File) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.File) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.File) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		p(s.Not())
	})
}

```

`app/bugu/service/internal/data/ent/file_create.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// FileCreate is the builder for creating a File entity.
type FileCreate struct {
	config
	mutation *FileMutation
	hooks    []Hook
}

// SetFileSha1 sets the "file_sha_1" field.
func (fc *FileCreate) SetFileSha1(s string) *FileCreate {
	fc.mutation.SetFileSha1(s)
	return fc
}

// SetFileSize sets the "file_size" field.
func (fc *FileCreate) SetFileSize(i int64) *FileCreate {
	fc.mutation.SetFileSize(i)
	return fc
}

// SetFileAddr sets the "file_addr" field.
func (fc *FileCreate) SetFileAddr(s string) *FileCreate {
	fc.mutation.SetFileAddr(s)
	return fc
}

// SetType sets the "type" field.
func (fc *FileCreate) SetType(f file.Type) *FileCreate {
	fc.mutation.SetType(f)
	return fc
}

// SetNillableType sets the "type" field if the given value is not nil.
func (fc *FileCreate) SetNillableType(f *file.Type) *FileCreate {
	if f != nil {
		fc.SetType(*f)
	}
	return fc
}

// SetCreatedAt sets the "created_at" field.
func (fc *FileCreate) SetCreatedAt(t time.Time) *FileCreate {
	fc.mutation.SetCreatedAt(t)
	return fc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (fc *FileCreate) SetNillableCreatedAt(t *time.Time) *FileCreate {
	if t != nil {
		fc.SetCreatedAt(*t)
	}
	return fc
}

// SetUpdatedAt sets the "updated_at" field.
func (fc *FileCreate) SetUpdatedAt(t time.Time) *FileCreate {
	fc.mutation.SetUpdatedAt(t)
	return fc
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (fc *FileCreate) SetNillableUpdatedAt(t *time.Time) *FileCreate {
	if t != nil {
		fc.SetUpdatedAt(*t)
	}
	return fc
}

// SetID sets the "id" field.
func (fc *FileCreate) SetID(u uuid.UUID) *FileCreate {
	fc.mutation.SetID(u)
	return fc
}

// SetArtifactID sets the "artifact" edge to the Artifact entity by ID.
func (fc *FileCreate) SetArtifactID(id uuid.UUID) *FileCreate {
	fc.mutation.SetArtifactID(id)
	return fc
}

// SetNillableArtifactID sets the "artifact" edge to the Artifact entity by ID if the given value is not nil.
func (fc *FileCreate) SetNillableArtifactID(id *uuid.UUID) *FileCreate {
	if id != nil {
		fc = fc.SetArtifactID(*id)
	}
	return fc
}

// SetArtifact sets the "artifact" edge to the Artifact entity.
func (fc *FileCreate) SetArtifact(a *Artifact) *FileCreate {
	return fc.SetArtifactID(a.ID)
}

// AddAffiliatedUserIDs adds the "affiliated_user" edge to the User entity by IDs.
func (fc *FileCreate) AddAffiliatedUserIDs(ids ...uuid.UUID) *FileCreate {
	fc.mutation.AddAffiliatedUserIDs(ids...)
	return fc
}

// AddAffiliatedUser adds the "affiliated_user" edges to the User entity.
func (fc *FileCreate) AddAffiliatedUser(u ...*User) *FileCreate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return fc.AddAffiliatedUserIDs(ids...)
}

// Mutation returns the FileMutation object of the builder.
func (fc *FileCreate) Mutation() *FileMutation {
	return fc.mutation
}

// Save creates the File in the database.
func (fc *FileCreate) Save(ctx context.Context) (*File, error) {
	var (
		err  error
		node *File
	)
	fc.defaults()
	if len(fc.hooks) == 0 {
		if err = fc.check(); err != nil {
			return nil, err
		}
		node, err = fc.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*FileMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = fc.check(); err != nil {
				return nil, err
			}
			fc.mutation = mutation
			if node, err = fc.sqlSave(ctx); err != nil {
				return nil, err
			}
			mutation.id = &node.ID
			mutation.done = true
			return node, err
		})
		for i := len(fc.hooks) - 1; i >= 0; i-- {
			if fc.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = fc.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, fc.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX calls Save and panics if Save returns an error.
func (fc *FileCreate) SaveX(ctx context.Context) *File {
	v, err := fc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (fc *FileCreate) Exec(ctx context.Context) error {
	_, err := fc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fc *FileCreate) ExecX(ctx context.Context) {
	if err := fc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (fc *FileCreate) defaults() {
	if _, ok := fc.mutation.GetType(); !ok {
		v := file.DefaultType
		fc.mutation.SetType(v)
	}
	if _, ok := fc.mutation.CreatedAt(); !ok {
		v := file.DefaultCreatedAt()
		fc.mutation.SetCreatedAt(v)
	}
	if _, ok := fc.mutation.UpdatedAt(); !ok {
		v := file.DefaultUpdatedAt()
		fc.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (fc *FileCreate) check() error {
	if _, ok := fc.mutation.FileSha1(); !ok {
		return &ValidationError{Name: "file_sha_1", err: errors.New(`ent: missing required field "File.file_sha_1"`)}
	}
	if _, ok := fc.mutation.FileSize(); !ok {
		return &ValidationError{Name: "file_size", err: errors.New(`ent: missing required field "File.file_size"`)}
	}
	if _, ok := fc.mutation.FileAddr(); !ok {
		return &ValidationError{Name: "file_addr", err: errors.New(`ent: missing required field "File.file_addr"`)}
	}
	if _, ok := fc.mutation.GetType(); !ok {
		return &ValidationError{Name: "type", err: errors.New(`ent: missing required field "File.type"`)}
	}
	if v, ok := fc.mutation.GetType(); ok {
		if err := file.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "File.type": %w`, err)}
		}
	}
	if _, ok := fc.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "File.created_at"`)}
	}
	if _, ok := fc.mutation.UpdatedAt(); !ok {
		return &ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "File.updated_at"`)}
	}
	return nil
}

func (fc *FileCreate) sqlSave(ctx context.Context) (*File, error) {
	_node, _spec := fc.createSpec()
	if err := sqlgraph.CreateNode(ctx, fc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(*uuid.UUID); ok {
			_node.ID = *id
		} else if err := _node.ID.Scan(_spec.ID.Value); err != nil {
			return nil, err
		}
	}
	return _node, nil
}

func (fc *FileCreate) createSpec() (*File, *sqlgraph.CreateSpec) {
	var (
		_node = &File{config: fc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: file.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: file.FieldID,
			},
		}
	)
	if id, ok := fc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = &id
	}
	if value, ok := fc.mutation.FileSha1(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: file.FieldFileSha1,
		})
		_node.FileSha1 = value
	}
	if value, ok := fc.mutation.FileSize(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: file.FieldFileSize,
		})
		_node.FileSize = value
	}
	if value, ok := fc.mutation.FileAddr(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: file.FieldFileAddr,
		})
		_node.FileAddr = value
	}
	if value, ok := fc.mutation.GetType(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: file.FieldType,
		})
		_node.Type = value
	}
	if value, ok := fc.mutation.CreatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: file.FieldCreatedAt,
		})
		_node.CreatedAt = value
	}
	if value, ok := fc.mutation.UpdatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: file.FieldUpdatedAt,
		})
		_node.UpdatedAt = value
	}
	if nodes := fc.mutation.ArtifactIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   file.ArtifactTable,
			Columns: []string{file.ArtifactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.file_artifact = &nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := fc.mutation.AffiliatedUserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   file.AffiliatedUserTable,
			Columns: file.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// FileCreateBulk is the builder for creating many File entities in bulk.
type FileCreateBulk struct {
	config
	builders []*FileCreate
}

// Save creates the File entities in the database.
func (fcb *FileCreateBulk) Save(ctx context.Context) ([]*File, error) {
	specs := make([]*sqlgraph.CreateSpec, len(fcb.builders))
	nodes := make([]*File, len(fcb.builders))
	mutators := make([]Mutator, len(fcb.builders))
	for i := range fcb.builders {
		func(i int, root context.Context) {
			builder := fcb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*FileMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, fcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, fcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{err.Error(), err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, fcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (fcb *FileCreateBulk) SaveX(ctx context.Context) []*File {
	v, err := fcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (fcb *FileCreateBulk) Exec(ctx context.Context) error {
	_, err := fcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fcb *FileCreateBulk) ExecX(ctx context.Context) {
	if err := fcb.Exec(ctx); err != nil {
		panic(err)
	}
}

```

`app/bugu/service/internal/data/ent/file_delete.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
)

// FileDelete is the builder for deleting a File entity.
type FileDelete struct {
	config
	hooks    []Hook
	mutation *FileMutation
}

// Where appends a list predicates to the FileDelete builder.
func (fd *FileDelete) Where(ps ...predicate.File) *FileDelete {
	fd.mutation.Where(ps...)
	return fd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (fd *FileDelete) Exec(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(fd.hooks) == 0 {
		affected, err = fd.sqlExec(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*FileMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			fd.mutation = mutation
			affected, err = fd.sqlExec(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(fd.hooks) - 1; i >= 0; i-- {
			if fd.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = fd.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, fd.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// ExecX is like Exec, but panics if an error occurs.
func (fd *FileDelete) ExecX(ctx context.Context) int {
	n, err := fd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (fd *FileDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := &sqlgraph.DeleteSpec{
		Node: &sqlgraph.NodeSpec{
			Table: file.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: file.FieldID,
			},
		},
	}
	if ps := fd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return sqlgraph.DeleteNodes(ctx, fd.driver, _spec)
}

// FileDeleteOne is the builder for deleting a single File entity.
type FileDeleteOne struct {
	fd *FileDelete
}

// Exec executes the deletion query.
func (fdo *FileDeleteOne) Exec(ctx context.Context) error {
	n, err := fdo.fd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{file.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (fdo *FileDeleteOne) ExecX(ctx context.Context) {
	fdo.fd.ExecX(ctx)
}

```

`app/bugu/service/internal/data/ent/file_query.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// FileQuery is the builder for querying File entities.
type FileQuery struct {
	config
	limit      *int
	offset     *int
	unique     *bool
	order      []OrderFunc
	fields     []string
	predicates []predicate.File
	// eager-loading edges.
	withArtifact       *ArtifactQuery
	withAffiliatedUser *UserQuery
	withFKs            bool
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the FileQuery builder.
func (fq *FileQuery) Where(ps ...predicate.File) *FileQuery {
	fq.predicates = append(fq.predicates, ps...)
	return fq
}

// Limit adds a limit step to the query.
func (fq *FileQuery) Limit(limit int) *FileQuery {
	fq.limit = &limit
	return fq
}

// Offset adds an offset step to the query.
func (fq *FileQuery) Offset(offset int) *FileQuery {
	fq.offset = &offset
	return fq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (fq *FileQuery) Unique(unique bool) *FileQuery {
	fq.unique = &unique
	return fq
}

// Order adds an order step to the query.
func (fq *FileQuery) Order(o ...OrderFunc) *FileQuery {
	fq.order = append(fq.order, o...)
	return fq
}

// QueryArtifact chains the current query on the "artifact" edge.
func (fq *FileQuery) QueryArtifact() *ArtifactQuery {
	query := &ArtifactQuery{config: fq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := fq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := fq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, selector),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, file.ArtifactTable, file.ArtifactColumn),
		)
		fromU = sqlgraph.SetNeighbors(fq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAffiliatedUser chains the current query on the "affiliated_user" edge.
func (fq *FileQuery) QueryAffiliatedUser() *UserQuery {
	query := &UserQuery{config: fq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := fq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := fq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, file.AffiliatedUserTable, file.AffiliatedUserPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(fq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first File entity from the query.
// Returns a *NotFoundError when no File was found.
func (fq *FileQuery) First(ctx context.Context) (*File, error) {
	nodes, err := fq.Limit(1).All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{file.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (fq *FileQuery) FirstX(ctx context.Context) *File {
	node, err := fq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first File ID from the query.
// Returns a *NotFoundError when no File ID was found.
func (fq *FileQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = fq.Limit(1).IDs(ctx); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{file.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (fq *FileQuery) FirstIDX(ctx context.Context) uuid.UUID {
	id, err := fq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single File entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one File entity is found.
// Returns a *NotFoundError when no File entities are found.
func (fq *FileQuery) Only(ctx context.Context) (*File, error) {
	nodes, err := fq.Limit(2).All(ctx)
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{file.Label}
	default:
		return nil, &NotSingularError{file.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (fq *FileQuery) OnlyX(ctx context.Context) *File {
	node, err := fq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only File ID in the query.
// Returns a *NotSingularError when more than one File ID is found.
// Returns a *NotFoundError when no entities are found.
func (fq *FileQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = fq.Limit(2).IDs(ctx); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = &NotSingularError{file.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (fq *FileQuery) OnlyIDX(ctx context.Context) uuid.UUID {
	id, err := fq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Files.
func (fq *FileQuery) All(ctx context.Context) ([]*File, error) {
	if err := fq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	return fq.sqlAll(ctx)
}

// AllX is like All, but panics if an error occurs.
func (fq *FileQuery) AllX(ctx context.Context) []*File {
	nodes, err := fq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of File IDs.
func (fq *FileQuery) IDs(ctx context.Context) ([]uuid.UUID, error) {
	var ids []uuid.UUID
	if err := fq.Select(file.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (fq *FileQuery) IDsX(ctx context.Context) []uuid.UUID {
	ids, err := fq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (fq *FileQuery) Count(ctx context.Context) (int, error) {
	if err := fq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return fq.sqlCount(ctx)
}

// CountX is like Count, but panics if an error occurs.
func (fq *FileQuery) CountX(ctx context.Context) int {
	count, err := fq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (fq *FileQuery) Exist(ctx context.Context) (bool, error) {
	if err := fq.prepareQuery(ctx); err != nil {
		return false, err
	}
	return fq.sqlExist(ctx)
}

// ExistX is like Exist, but panics if an error occurs.
func (fq *FileQuery) ExistX(ctx context.Context) bool {
	exist, err := fq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the FileQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (fq *FileQuery) Clone() *FileQuery {
	if fq == nil {
		return nil
	}
	return &FileQuery{
		config:             fq.config,
		limit:              fq.limit,
		offset:             fq.offset,
		order:              append([]OrderFunc{}, fq.order...),
		predicates:         append([]predicate.File{}, fq.predicates...),
		withArtifact:       fq.withArtifact.Clone(),
		withAffiliatedUser: fq.withAffiliatedUser.Clone(),
		// clone intermediate query.
		sql:    fq.sql.Clone(),
		path:   fq.path,
		unique: fq.unique,
	}
}

// WithArtifact tells the query-builder to eager-load the nodes that are connected to
// the "artifact" edge. The optional arguments are used to configure the query builder of the edge.
func (fq *FileQuery) WithArtifact(opts ...func(*ArtifactQuery)) *FileQuery {
	query := &ArtifactQuery{config: fq.config}
	for _, opt := range opts {
		opt(query)
	}
	fq.withArtifact = query
	return fq
}

// WithAffiliatedUser tells the query-builder to eager-load the nodes that are connected to
// the "affiliated_user" edge. The optional arguments are used to configure the query builder of the edge.
func (fq *FileQuery) WithAffiliatedUser(opts ...func(*UserQuery)) *FileQuery {
	query := &UserQuery{config: fq.config}
	for _, opt := range opts {
		opt(query)
	}
	fq.withAffiliatedUser = query
	return fq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		FileSha1 string `json:"file_sha_1,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.File.Query().
//		GroupBy(file.FieldFileSha1).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
//
func (fq *FileQuery) GroupBy(field string, fields ...string) *FileGroupBy {
	group := &FileGroupBy{config: fq.config}
	group.fields = append([]string{field}, fields...)
	group.path = func(ctx context.Context) (prev *sql.Selector, err error) {
		if err := fq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		return fq.sqlQuery(ctx), nil
	}
	return group
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		FileSha1 string `json:"file_sha_1,omitempty"`
//	}
//
//	client.File.Query().
//		Select(file.FieldFileSha1).
//		Scan(ctx, &v)
//
func (fq *FileQuery) Select(fields ...string) *FileSelect {
	fq.fields = append(fq.fields, fields...)
	return &FileSelect{FileQuery: fq}
}

func (fq *FileQuery) prepareQuery(ctx context.Context) error {
	for _, f := range fq.fields {
		if !file.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if fq.path != nil {
		prev, err := fq.path(ctx)
		if err != nil {
			return err
		}
		fq.sql = prev
	}
	return nil
}

func (fq *FileQuery) sqlAll(ctx context.Context) ([]*File, error) {
	var (
		nodes       = []*File{}
		withFKs     = fq.withFKs
		_spec       = fq.querySpec()
		loadedTypes = [2]bool{
			fq.withArtifact != nil,
			fq.withAffiliatedUser != nil,
		}
	)
	if fq.withArtifact != nil {
		withFKs = true
	}
	if withFKs {
		_spec.Node.Columns = append(_spec.Node.Columns, file.ForeignKeys...)
	}
	_spec.ScanValues = func(columns []string) ([]interface{}, error) {
		node := &File{config: fq.config}
		nodes = append(nodes, node)
		return node.scanValues(columns)
	}
	_spec.Assign = func(columns []string, values []interface{}) error {
		if len(nodes) == 0 {
			return fmt.Errorf("ent: Assign called without calling ScanValues")
		}
		node := nodes[len(nodes)-1]
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	if err := sqlgraph.QueryNodes(ctx, fq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}

	if query := fq.withArtifact; query != nil {
		ids := make([]uuid.UUID, 0, len(nodes))
		nodeids := make(map[uuid.UUID][]*File)
		for i := range nodes {
			if nodes[i].file_artifact == nil {
				continue
			}
			fk := *nodes[i].file_artifact
			if _, ok := nodeids[fk]; !ok {
				ids = append(ids, fk)
			}
			nodeids[fk] = append(nodeids[fk], nodes[i])
		}
		query.Where(artifact.IDIn(ids...))
		neighbors, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, n := range neighbors {
			nodes, ok := nodeids[n.ID]
			if !ok {
				return nil, fmt.Errorf(`unexpected foreign-key "file_artifact" returned %v`, n.ID)
			}
			for i := range nodes {
				nodes[i].Edges.Artifact = n
			}
		}
	}

	if query := fq.withAffiliatedUser; query != nil {
		fks := make([]driver.Value, 0, len(nodes))
		ids := make(map[uuid.UUID]*File, len(nodes))
		for _, node := range nodes {
			ids[node.ID] = node
			fks = append(fks, node.ID)
			node.Edges.AffiliatedUser = []*User{}
		}
		var (
			edgeids []uuid.UUID
			edges   = make(map[uuid.UUID][]*File)
		)
		_spec := &sqlgraph.EdgeQuerySpec{
			Edge: &sqlgraph.EdgeSpec{
				Inverse: true,
				Table:   file.AffiliatedUserTable,
				Columns: file.AffiliatedUserPrimaryKey,
			},
			Predicate: func(s *sql.Selector) {
				s.Where(sql.InValues(file.AffiliatedUserPrimaryKey[1], fks...))
			},
			ScanValues: func() [2]interface{} {
				return [2]interface{}{new(uuid.UUID), new(uuid.UUID)}
			},
			Assign: func(out, in interface{}) error {
				eout, ok := out.(*uuid.UUID)
				if !ok || eout == nil {
					return fmt.Errorf("unexpected id value for edge-out")
				}
				ein, ok := in.(*uuid.UUID)
				if !ok || ein == nil {
					return fmt.Errorf("unexpected id value for edge-in")
				}
				outValue := *eout
				inValue := *ein
				node, ok := ids[outValue]
				if !ok {
					return fmt.Errorf("unexpected node id in edges: %v", outValue)
				}
				if _, ok := edges[inValue]; !ok {
					edgeids = append(edgeids, inValue)
				}
				edges[inValue] = append(edges[inValue], node)
				return nil
			},
		}
		if err := sqlgraph.QueryEdges(ctx, fq.driver, _spec); err != nil {
			return nil, fmt.Errorf(`query edges "affiliated_user": %w`, err)
		}
		query.Where(user.IDIn(edgeids...))
		neighbors, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, n := range neighbors {
			nodes, ok := edges[n.ID]
			if !ok {
				return nil, fmt.Errorf(`unexpected "affiliated_user" node returned %v`, n.ID)
			}
			for i := range nodes {
				nodes[i].Edges.AffiliatedUser = append(nodes[i].Edges.AffiliatedUser, n)
			}
		}
	}

	return nodes, nil
}

func (fq *FileQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := fq.querySpec()
	_spec.Node.Columns = fq.fields
	if len(fq.fields) > 0 {
		_spec.Unique = fq.unique != nil && *fq.unique
	}
	return sqlgraph.CountNodes(ctx, fq.driver, _spec)
}

func (fq *FileQuery) sqlExist(ctx context.Context) (bool, error) {
	n, err := fq.sqlCount(ctx)
	if err != nil {
		return false, fmt.Errorf("ent: check existence: %w", err)
	}
	return n > 0, nil
}

func (fq *FileQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := &sqlgraph.QuerySpec{
		Node: &sqlgraph.NodeSpec{
			Table:   file.Table,
			Columns: file.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: file.FieldID,
			},
		},
		From:   fq.sql,
		Unique: true,
	}
	if unique := fq.unique; unique != nil {
		_spec.Unique = *unique
	}
	if fields := fq.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, file.FieldID)
		for i := range fields {
			if fields[i] != file.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := fq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := fq.limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := fq.offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := fq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (fq *FileQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(fq.driver.Dialect())
	t1 := builder.Table(file.Table)
	columns := fq.fields
	if len(columns) == 0 {
		columns = file.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if fq.sql != nil {
		selector = fq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if fq.unique != nil && *fq.unique {
		selector.Distinct()
	}
	for _, p := range fq.predicates {
		p(selector)
	}
	for _, p := range fq.order {
		p(selector)
	}
	if offset := fq.offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := fq.limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// FileGroupBy is the group-by builder for File entities.
type FileGroupBy struct {
	config
	fields []string
	fns    []AggregateFunc
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Aggregate adds the given aggregation functions to the group-by query.
func (fgb *FileGroupBy) Aggregate(fns ...AggregateFunc) *FileGroupBy {
	fgb.fns = append(fgb.fns, fns...)
	return fgb
}

// Scan applies the group-by query and scans the result into the given value.
func (fgb *FileGroupBy) Scan(ctx context.Context, v interface{}) error {
	query, err := fgb.path(ctx)
	if err != nil {
		return err
	}
	fgb.sql = query
	return fgb.sqlScan(ctx, v)
}

// ScanX is like Scan, but panics if an error occurs.
func (fgb *FileGroupBy) ScanX(ctx context.Context, v interface{}) {
	if err := fgb.Scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from group-by.
// It is only allowed when executing a group-by query with one field.
func (fgb *FileGroupBy) Strings(ctx context.Context) ([]string, error) {
	if len(fgb.fields) > 1 {
		return nil, errors.New("ent: FileGroupBy.Strings is not achievable when grouping more than 1 field")
	}
	var v []string
	if err := fgb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (fgb *FileGroupBy) StringsX(ctx context.Context) []string {
	v, err := fgb.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (fgb *FileGroupBy) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = fgb.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = fmt.Errorf("ent: FileGroupBy.Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (fgb *FileGroupBy) StringX(ctx context.Context) string {
	v, err := fgb.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from group-by.
// It is only allowed when executing a group-by query with one field.
func (fgb *FileGroupBy) Ints(ctx context.Context) ([]int, error) {
	if len(fgb.fields) > 1 {
		return nil, errors.New("ent: FileGroupBy.Ints is not achievable when grouping more than 1 field")
	}
	var v []int
	if err := fgb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (fgb *FileGroupBy) IntsX(ctx context.Context) []int {
	v, err := fgb.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (fgb *FileGroupBy) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = fgb.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = fmt.Errorf("ent: FileGroupBy.Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (fgb *FileGroupBy) IntX(ctx context.Context) int {
	v, err := fgb.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from group-by.
// It is only allowed when executing a group-by query with one field.
func (fgb *FileGroupBy) Float64s(ctx context.Context) ([]float64, error) {
	if len(fgb.fields) > 1 {
		return nil, errors.New("ent: FileGroupBy.Float64s is not achievable when grouping more than 1 field")
	}
	var v []float64
	if err := fgb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (fgb *FileGroupBy) Float64sX(ctx context.Context) []float64 {
	v, err := fgb.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (fgb *FileGroupBy) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = fgb.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = fmt.Errorf("ent: FileGroupBy.Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (fgb *FileGroupBy) Float64X(ctx context.Context) float64 {
	v, err := fgb.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from group-by.
// It is only allowed when executing a group-by query with one field.
func (fgb *FileGroupBy) Bools(ctx context.Context) ([]bool, error) {
	if len(fgb.fields) > 1 {
		return nil, errors.New("ent: FileGroupBy.Bools is not achievable when grouping more than 1 field")
	}
	var v []bool
	if err := fgb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (fgb *FileGroupBy) BoolsX(ctx context.Context) []bool {
	v, err := fgb.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (fgb *FileGroupBy) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = fgb.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = fmt.Errorf("ent: FileGroupBy.Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (fgb *FileGroupBy) BoolX(ctx context.Context) bool {
	v, err := fgb.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (fgb *FileGroupBy) sqlScan(ctx context.Context, v interface{}) error {
	for _, f := range fgb.fields {
		if !file.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("invalid field %q for group-by", f)}
		}
	}
	selector := fgb.sqlQuery()
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := fgb.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

func (fgb *FileGroupBy) sqlQuery() *sql.Selector {
	selector := fgb.sql.Select()
	aggregation := make([]string, 0, len(fgb.fns))
	for _, fn := range fgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	// If no columns were selected in a custom aggregation function, the default
	// selection is the fields used for "group-by", and the aggregation functions.
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(fgb.fields)+len(fgb.fns))
		for _, f := range fgb.fields {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	return selector.GroupBy(selector.Columns(fgb.fields...)...)
}

// FileSelect is the builder for selecting fields of File entities.
type FileSelect struct {
	*FileQuery
	// intermediate query (i.e. traversal path).
	sql *sql.Selector
}

// Scan applies the selector query and scans the result into the given value.
func (fs *FileSelect) Scan(ctx context.Context, v interface{}) error {
	if err := fs.prepareQuery(ctx); err != nil {
		return err
	}
	fs.sql = fs.FileQuery.sqlQuery(ctx)
	return fs.sqlScan(ctx, v)
}

// ScanX is like Scan, but panics if an error occurs.
func (fs *FileSelect) ScanX(ctx context.Context, v interface{}) {
	if err := fs.Scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (fs *FileSelect) Strings(ctx context.Context) ([]string, error) {
	if len(fs.fields) > 1 {
		return nil, errors.New("ent: FileSelect.Strings is not achievable when selecting more than 1 field")
	}
	var v []string
	if err := fs.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (fs *FileSelect) StringsX(ctx context.Context) []string {
	v, err := fs.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (fs *FileSelect) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = fs.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = fmt.Errorf("ent: FileSelect.Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (fs *FileSelect) StringX(ctx context.Context) string {
	v, err := fs.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (fs *FileSelect) Ints(ctx context.Context) ([]int, error) {
	if len(fs.fields) > 1 {
		return nil, errors.New("ent: FileSelect.Ints is not achievable when selecting more than 1 field")
	}
	var v []int
	if err := fs.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (fs *FileSelect) IntsX(ctx context.Context) []int {
	v, err := fs.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (fs *FileSelect) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = fs.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = fmt.Errorf("ent: FileSelect.Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (fs *FileSelect) IntX(ctx context.Context) int {
	v, err := fs.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (fs *FileSelect) Float64s(ctx context.Context) ([]float64, error) {
	if len(fs.fields) > 1 {
		return nil, errors.New("ent: FileSelect.Float64s is not achievable when selecting more than 1 field")
	}
	var v []float64
	if err := fs.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (fs *FileSelect) Float64sX(ctx context.Context) []float64 {
	v, err := fs.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (fs *FileSelect) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = fs.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = fmt.Errorf("ent: FileSelect.Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (fs *FileSelect) Float64X(ctx context.Context) float64 {
	v, err := fs.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (fs *FileSelect) Bools(ctx context.Context) ([]bool, error) {
	if len(fs.fields) > 1 {
		return nil, errors.New("ent: FileSelect.Bools is not achievable when selecting more than 1 field")
	}
	var v []bool
	if err := fs.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (fs *FileSelect) BoolsX(ctx context.Context) []bool {
	v, err := fs.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (fs *FileSelect) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = fs.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{file.Label}
	default:
		err = fmt.Errorf("ent: FileSelect.Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (fs *FileSelect) BoolX(ctx context.Context) bool {
	v, err := fs.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (fs *FileSelect) sqlScan(ctx context.Context, v interface{}) error {
	rows := &sql.Rows{}
	query, args := fs.sql.Query()
	if err := fs.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

```

`app/bugu/service/internal/data/ent/file_update.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// FileUpdate is the builder for updating File entities.
type FileUpdate struct {
	config
	hooks    []Hook
	mutation *FileMutation
}

// Where appends a list predicates to the FileUpdate builder.
func (fu *FileUpdate) Where(ps ...predicate.File) *FileUpdate {
	fu.mutation.Where(ps...)
	return fu
}

// SetFileSha1 sets the "file_sha_1" field.
func (fu *FileUpdate) SetFileSha1(s string) *FileUpdate {
	fu.mutation.SetFileSha1(s)
	return fu
}

// SetFileSize sets the "file_size" field.
func (fu *FileUpdate) SetFileSize(i int64) *FileUpdate {
	fu.mutation.ResetFileSize()
	fu.mutation.SetFileSize(i)
	return fu
}

// AddFileSize adds i to the "file_size" field.
func (fu *FileUpdate) AddFileSize(i int64) *FileUpdate {
	fu.mutation.AddFileSize(i)
	return fu
}

// SetFileAddr sets the "file_addr" field.
func (fu *FileUpdate) SetFileAddr(s string) *FileUpdate {
	fu.mutation.SetFileAddr(s)
	return fu
}

// SetType sets the "type" field.
func (fu *FileUpdate) SetType(f file.Type) *FileUpdate {
	fu.mutation.SetType(f)
	return fu
}

// SetNillableType sets the "type" field if the given value is not nil.
func (fu *FileUpdate) SetNillableType(f *file.Type) *FileUpdate {
	if f != nil {
		fu.SetType(*f)
	}
	return fu
}

// SetUpdatedAt sets the "updated_at" field.
func (fu *FileUpdate) SetUpdatedAt(t time.Time) *FileUpdate {
	fu.mutation.SetUpdatedAt(t)
	return fu
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (fu *FileUpdate) SetNillableUpdatedAt(t *time.Time) *FileUpdate {
	if t != nil {
		fu.SetUpdatedAt(*t)
	}
	return fu
}

// SetArtifactID sets the "artifact" edge to the Artifact entity by ID.
func (fu *FileUpdate) SetArtifactID(id uuid.UUID) *FileUpdate {
	fu.mutation.SetArtifactID(id)
	return fu
}

// SetNillableArtifactID sets the "artifact" edge to the Artifact entity by ID if the given value is not nil.
func (fu *FileUpdate) SetNillableArtifactID(id *uuid.UUID) *FileUpdate {
	if id != nil {
		fu = fu.SetArtifactID(*id)
	}
	return fu
}

// SetArtifact sets the "artifact" edge to the Artifact entity.
func (fu *FileUpdate) SetArtifact(a *Artifact) *FileUpdate {
	return fu.SetArtifactID(a.ID)
}

// AddAffiliatedUserIDs adds the "affiliated_user" edge to the User entity by IDs.
func (fu *FileUpdate) AddAffiliatedUserIDs(ids ...uuid.UUID) *FileUpdate {
	fu.mutation.AddAffiliatedUserIDs(ids...)
	return fu
}

// AddAffiliatedUser adds the "affiliated_user" edges to the User entity.
func (fu *FileUpdate) AddAffiliatedUser(u ...*User) *FileUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return fu.AddAffiliatedUserIDs(ids...)
}

// Mutation returns the FileMutation object of the builder.
func (fu *FileUpdate) Mutation() *FileMutation {
	return fu.mutation
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (fu *FileUpdate) ClearArtifact() *FileUpdate {
	fu.mutation.ClearArtifact()
	return fu
}

// ClearAffiliatedUser clears all "affiliated_user" edges to the User entity.
func (fu *FileUpdate) ClearAffiliatedUser() *FileUpdate {
	fu.mutation.ClearAffiliatedUser()
	return fu
}

// RemoveAffiliatedUserIDs removes the "affiliated_user" edge to User entities by IDs.
func (fu *FileUpdate) RemoveAffiliatedUserIDs(ids ...uuid.UUID) *FileUpdate {
	fu.mutation.RemoveAffiliatedUserIDs(ids...)
	return fu
}

// RemoveAffiliatedUser removes "affiliated_user" edges to User entities.
func (fu *FileUpdate) RemoveAffiliatedUser(u ...*User) *FileUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return fu.RemoveAffiliatedUserIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (fu *FileUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(fu.hooks) == 0 {
		if err = fu.check(); err != nil {
			return 0, err
		}
		affected, err = fu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*FileMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = fu.check(); err != nil {
				return 0, err
			}
			fu.mutation = mutation
			affected, err = fu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(fu.hooks) - 1; i >= 0; i-- {
			if fu.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = fu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, fu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (fu *FileUpdate) SaveX(ctx context.Context) int {
	affected, err := fu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (fu *FileUpdate) Exec(ctx context.Context) error {
	_, err := fu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fu *FileUpdate) ExecX(ctx context.Context) {
	if err := fu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (fu *FileUpdate) check() error {
	if v, ok := fu.mutation.GetType(); ok {
		if err := file.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "File.type": %w`, err)}
		}
	}
	return nil
}

func (fu *FileUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   file.Table,
			Columns: file.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: file.FieldID,
			},
		},
	}
	if ps := fu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := fu.mutation.FileSha1(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: file.FieldFileSha1,
		})
	}
	if value, ok := fu.mutation.FileSize(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: file.FieldFileSize,
		})
	}
	if value, ok := fu.mutation.AddedFileSize(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: file.FieldFileSize,
		})
	}
	if value, ok := fu.mutation.FileAddr(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: file.FieldFileAddr,
		})
	}
	if value, ok := fu.mutation.GetType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: file.FieldType,
		})
	}
	if value, ok := fu.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: file.FieldUpdatedAt,
		})
	}
	if fu.mutation.ArtifactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   file.ArtifactTable,
			Columns: []string{file.ArtifactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fu.mutation.ArtifactIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   file.ArtifactTable,
			Columns: []string{file.ArtifactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if fu.mutation.AffiliatedUserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   file.AffiliatedUserTable,
			Columns: file.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fu.mutation.RemovedAffiliatedUserIDs(); len(nodes) > 0 && !fu.mutation.AffiliatedUserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   file.AffiliatedUserTable,
			Columns: file.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fu.mutation.AffiliatedUserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   file.AffiliatedUserTable,
			Columns: file.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, fu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{file.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return 0, err
	}
	return n, nil
}

// FileUpdateOne is the builder for updating a single File entity.
type FileUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *FileMutation
}

// SetFileSha1 sets the "file_sha_1" field.
func (fuo *FileUpdateOne) SetFileSha1(s string) *FileUpdateOne {
	fuo.mutation.SetFileSha1(s)
	return fuo
}

// SetFileSize sets the "file_size" field.
func (fuo *FileUpdateOne) SetFileSize(i int64) *FileUpdateOne {
	fuo.mutation.ResetFileSize()
	fuo.mutation.SetFileSize(i)
	return fuo
}

// AddFileSize adds i to the "file_size" field.
func (fuo *FileUpdateOne) AddFileSize(i int64) *FileUpdateOne {
	fuo.mutation.AddFileSize(i)
	return fuo
}

// SetFileAddr sets the "file_addr" field.
func (fuo *FileUpdateOne) SetFileAddr(s string) *FileUpdateOne {
	fuo.mutation.SetFileAddr(s)
	return fuo
}

// SetType sets the "type" field.
func (fuo *FileUpdateOne) SetType(f file.Type) *FileUpdateOne {
	fuo.mutation.SetType(f)
	return fuo
}

// SetNillableType sets the "type" field if the given value is not nil.
func (fuo *FileUpdateOne) SetNillableType(f *file.Type) *FileUpdateOne {
	if f != nil {
		fuo.SetType(*f)
	}
	return fuo
}

// SetUpdatedAt sets the "updated_at" field.
func (fuo *FileUpdateOne) SetUpdatedAt(t time.Time) *FileUpdateOne {
	fuo.mutation.SetUpdatedAt(t)
	return fuo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (fuo *FileUpdateOne) SetNillableUpdatedAt(t *time.Time) *FileUpdateOne {
	if t != nil {
		fuo.SetUpdatedAt(*t)
	}
	return fuo
}

// SetArtifactID sets the "artifact" edge to the Artifact entity by ID.
func (fuo *FileUpdateOne) SetArtifactID(id uuid.UUID) *FileUpdateOne {
	fuo.mutation.SetArtifactID(id)
	return fuo
}

// SetNillableArtifactID sets the "artifact" edge to the Artifact entity by ID if the given value is not nil.
func (fuo *FileUpdateOne) SetNillableArtifactID(id *uuid.UUID) *FileUpdateOne {
	if id != nil {
		fuo = fuo.SetArtifactID(*id)
	}
	return fuo
}

// SetArtifact sets the "artifact" edge to the Artifact entity.
func (fuo *FileUpdateOne) SetArtifact(a *Artifact) *FileUpdateOne {
	return fuo.SetArtifactID(a.ID)
}

// AddAffiliatedUserIDs adds the "affiliated_user" edge to the User entity by IDs.
func (fuo *FileUpdateOne) AddAffiliatedUserIDs(ids ...uuid.UUID) *FileUpdateOne {
	fuo.mutation.AddAffiliatedUserIDs(ids...)
	return fuo
}

// AddAffiliatedUser adds the "affiliated_user" edges to the User entity.
func (fuo *FileUpdateOne) AddAffiliatedUser(u ...*User) *FileUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return fuo.AddAffiliatedUserIDs(ids...)
}

// Mutation returns the FileMutation object of the builder.
func (fuo *FileUpdateOne) Mutation() *FileMutation {
	return fuo.mutation
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (fuo *FileUpdateOne) ClearArtifact() *FileUpdateOne {
	fuo.mutation.ClearArtifact()
	return fuo
}

// ClearAffiliatedUser clears all "affiliated_user" edges to the User entity.
func (fuo *FileUpdateOne) ClearAffiliatedUser() *FileUpdateOne {
	fuo.mutation.ClearAffiliatedUser()
	return fuo
}

// RemoveAffiliatedUserIDs removes the "affiliated_user" edge to User entities by IDs.
func (fuo *FileUpdateOne) RemoveAffiliatedUserIDs(ids ...uuid.UUID) *FileUpdateOne {
	fuo.mutation.RemoveAffiliatedUserIDs(ids...)
	return fuo
}

// RemoveAffiliatedUser removes "affiliated_user" edges to User entities.
func (fuo *FileUpdateOne) RemoveAffiliatedUser(u ...*User) *FileUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return fuo.RemoveAffiliatedUserIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (fuo *FileUpdateOne) Select(field string, fields ...string) *FileUpdateOne {
	fuo.fields = append([]string{field}, fields...)
	return fuo
}

// Save executes the query and returns the updated File entity.
func (fuo *FileUpdateOne) Save(ctx context.Context) (*File, error) {
	var (
		err  error
		node *File
	)
	if len(fuo.hooks) == 0 {
		if err = fuo.check(); err != nil {
			return nil, err
		}
		node, err = fuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*FileMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = fuo.check(); err != nil {
				return nil, err
			}
			fuo.mutation = mutation
			node, err = fuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(fuo.hooks) - 1; i >= 0; i-- {
			if fuo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = fuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, fuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (fuo *FileUpdateOne) SaveX(ctx context.Context) *File {
	node, err := fuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (fuo *FileUpdateOne) Exec(ctx context.Context) error {
	_, err := fuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fuo *FileUpdateOne) ExecX(ctx context.Context) {
	if err := fuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (fuo *FileUpdateOne) check() error {
	if v, ok := fuo.mutation.GetType(); ok {
		if err := file.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "File.type": %w`, err)}
		}
	}
	return nil
}

func (fuo *FileUpdateOne) sqlSave(ctx context.Context) (_node *File, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   file.Table,
			Columns: file.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: file.FieldID,
			},
		},
	}
	id, ok := fuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "File.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := fuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, file.FieldID)
		for _, f := range fields {
			if !file.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != file.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := fuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := fuo.mutation.FileSha1(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: file.FieldFileSha1,
		})
	}
	if value, ok := fuo.mutation.FileSize(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: file.FieldFileSize,
		})
	}
	if value, ok := fuo.mutation.AddedFileSize(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  value,
			Column: file.FieldFileSize,
		})
	}
	if value, ok := fuo.mutation.FileAddr(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: file.FieldFileAddr,
		})
	}
	if value, ok := fuo.mutation.GetType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: file.FieldType,
		})
	}
	if value, ok := fuo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: file.FieldUpdatedAt,
		})
	}
	if fuo.mutation.ArtifactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   file.ArtifactTable,
			Columns: []string{file.ArtifactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuo.mutation.ArtifactIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   file.ArtifactTable,
			Columns: []string{file.ArtifactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if fuo.mutation.AffiliatedUserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   file.AffiliatedUserTable,
			Columns: file.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuo.mutation.RemovedAffiliatedUserIDs(); len(nodes) > 0 && !fuo.mutation.AffiliatedUserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   file.AffiliatedUserTable,
			Columns: file.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuo.mutation.AffiliatedUserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   file.AffiliatedUserTable,
			Columns: file.AffiliatedUserPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &File{config: fuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, fuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{file.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	return _node, nil
}

```

`app/bugu/service/internal/data/ent/generate.go`:

```go
package ent

//go:generate go run -mod=mod entgo.io/ent/cmd/ent generate ./schema

```

`app/bugu/service/internal/data/ent/hook/hook.go`:

```go
// Code generated by entc, DO NOT EDIT.

package hook

import (
	"context"
	"fmt"

	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent"
)

// The ArtifactFunc type is an adapter to allow the use of ordinary
// function as Artifact mutator.
type ArtifactFunc func(context.Context, *ent.ArtifactMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f ArtifactFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.ArtifactMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.ArtifactMutation", m)
	}
	return f(ctx, mv)
}

// The FileFunc type is an adapter to allow the use of ordinary
// function as File mutator.
type FileFunc func(context.Context, *ent.FileMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f FileFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.FileMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.FileMutation", m)
	}
	return f(ctx, mv)
}

// The UserFunc type is an adapter to allow the use of ordinary
// function as User mutator.
type UserFunc func(context.Context, *ent.UserMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f UserFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	mv, ok := m.(*ent.UserMutation)
	if !ok {
		return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.UserMutation", m)
	}
	return f(ctx, mv)
}

// Condition is a hook condition function.
type Condition func(context.Context, ent.Mutation) bool

// And groups conditions with the AND operator.
func And(first, second Condition, rest ...Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		if !first(ctx, m) || !second(ctx, m) {
			return false
		}
		for _, cond := range rest {
			if !cond(ctx, m) {
				return false
			}
		}
		return true
	}
}

// Or groups conditions with the OR operator.
func Or(first, second Condition, rest ...Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		if first(ctx, m) || second(ctx, m) {
			return true
		}
		for _, cond := range rest {
			if cond(ctx, m) {
				return true
			}
		}
		return false
	}
}

// Not negates a given condition.
func Not(cond Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		return !cond(ctx, m)
	}
}

// HasOp is a condition testing mutation operation.
func HasOp(op ent.Op) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		return m.Op().Is(op)
	}
}

// HasAddedFields is a condition validating `.AddedField` on fields.
func HasAddedFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if _, exists := m.AddedField(field); !exists {
			return false
		}
		for _, field := range fields {
			if _, exists := m.AddedField(field); !exists {
				return false
			}
		}
		return true
	}
}

// HasClearedFields is a condition validating `.FieldCleared` on fields.
func HasClearedFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if exists := m.FieldCleared(field); !exists {
			return false
		}
		for _, field := range fields {
			if exists := m.FieldCleared(field); !exists {
				return false
			}
		}
		return true
	}
}

// HasFields is a condition validating `.Field` on fields.
func HasFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if _, exists := m.Field(field); !exists {
			return false
		}
		for _, field := range fields {
			if _, exists := m.Field(field); !exists {
				return false
			}
		}
		return true
	}
}

// If executes the given hook under condition.
//
//	hook.If(ComputeAverage, And(HasFields(...), HasAddedFields(...)))
//
func If(hk ent.Hook, cond Condition) ent.Hook {
	return func(next ent.Mutator) ent.Mutator {
		return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
			if cond(ctx, m) {
				return hk(next).Mutate(ctx, m)
			}
			return next.Mutate(ctx, m)
		})
	}
}

// On executes the given hook only for the given operation.
//
//	hook.On(Log, ent.Delete|ent.Create)
//
func On(hk ent.Hook, op ent.Op) ent.Hook {
	return If(hk, HasOp(op))
}

// Unless skips the given hook only for the given operation.
//
//	hook.Unless(Log, ent.Update|ent.UpdateOne)
//
func Unless(hk ent.Hook, op ent.Op) ent.Hook {
	return If(hk, Not(HasOp(op)))
}

// FixedError is a hook returning a fixed error.
func FixedError(err error) ent.Hook {
	return func(ent.Mutator) ent.Mutator {
		return ent.MutateFunc(func(context.Context, ent.Mutation) (ent.Value, error) {
			return nil, err
		})
	}
}

// Reject returns a hook that rejects all operations that match op.
//
//	func (T) Hooks() []ent.Hook {
//		return []ent.Hook{
//			Reject(ent.Delete|ent.Update),
//		}
//	}
//
func Reject(op ent.Op) ent.Hook {
	hk := FixedError(fmt.Errorf("%s operation is not allowed", op))
	return On(hk, op)
}

// Chain acts as a list of hooks and is effectively immutable.
// Once created, it will always hold the same set of hooks in the same order.
type Chain struct {
	hooks []ent.Hook
}

// NewChain creates a new chain of hooks.
func NewChain(hooks ...ent.Hook) Chain {
	return Chain{append([]ent.Hook(nil), hooks...)}
}

// Hook chains the list of hooks and returns the final hook.
func (c Chain) Hook() ent.Hook {
	return func(mutator ent.Mutator) ent.Mutator {
		for i := len(c.hooks) - 1; i >= 0; i-- {
			mutator = c.hooks[i](mutator)
		}
		return mutator
	}
}

// Append extends a chain, adding the specified hook
// as the last ones in the mutation flow.
func (c Chain) Append(hooks ...ent.Hook) Chain {
	newHooks := make([]ent.Hook, 0, len(c.hooks)+len(hooks))
	newHooks = append(newHooks, c.hooks...)
	newHooks = append(newHooks, hooks...)
	return Chain{newHooks}
}

// Extend extends a chain, adding the specified chain
// as the last ones in the mutation flow.
func (c Chain) Extend(chain Chain) Chain {
	return c.Append(chain.hooks...)
}

```

`app/bugu/service/internal/data/ent/migrate/migrate.go`:

```go
// Code generated by entc, DO NOT EDIT.

package migrate

import (
	"context"
	"fmt"
	"io"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql/schema"
)

var (
	// WithGlobalUniqueID sets the universal ids options to the migration.
	// If this option is enabled, ent migration will allocate a 1<<32 range
	// for the ids of each entity (table).
	// Note that this option cannot be applied on tables that already exist.
	WithGlobalUniqueID = schema.WithGlobalUniqueID
	// WithDropColumn sets the drop column option to the migration.
	// If this option is enabled, ent migration will drop old columns
	// that were used for both fields and edges. This defaults to false.
	WithDropColumn = schema.WithDropColumn
	// WithDropIndex sets the drop index option to the migration.
	// If this option is enabled, ent migration will drop old indexes
	// that were defined in the schema. This defaults to false.
	// Note that unique constraints are defined using `UNIQUE INDEX`,
	// and therefore, it's recommended to enable this option to get more
	// flexibility in the schema changes.
	WithDropIndex = schema.WithDropIndex
	// WithFixture sets the foreign-key renaming option to the migration when upgrading
	// ent from v0.1.0 (issue-#285). Defaults to false.
	WithFixture = schema.WithFixture
	// WithForeignKeys enables creating foreign-key in schema DDL. This defaults to true.
	WithForeignKeys = schema.WithForeignKeys
)

// Schema is the API for creating, migrating and dropping a schema.
type Schema struct {
	drv dialect.Driver
}

// NewSchema creates a new schema client.
func NewSchema(drv dialect.Driver) *Schema { return &Schema{drv: drv} }

// Create creates all schema resources.
func (s *Schema) Create(ctx context.Context, opts ...schema.MigrateOption) error {
	migrate, err := schema.NewMigrate(s.drv, opts...)
	if err != nil {
		return fmt.Errorf("ent/migrate: %w", err)
	}
	return migrate.Create(ctx, Tables...)
}

// WriteTo writes the schema changes to w instead of running them against the database.
//
// 	if err := client.Schema.WriteTo(context.Background(), os.Stdout); err != nil {
//		log.Fatal(err)
// 	}
//
func (s *Schema) WriteTo(ctx context.Context, w io.Writer, opts ...schema.MigrateOption) error {
	drv := &schema.WriteDriver{
		Writer: w,
		Driver: s.drv,
	}
	migrate, err := schema.NewMigrate(drv, opts...)
	if err != nil {
		return fmt.Errorf("ent/migrate: %w", err)
	}
	return migrate.Create(ctx, Tables...)
}

```

`app/bugu/service/internal/data/ent/migrate/schema.go`:

```go
// Code generated by entc, DO NOT EDIT.

package migrate

import (
	"entgo.io/ent/dialect/sql/schema"
	"entgo.io/ent/schema/field"
)

var (
	// ArtifactsColumns holds the columns for the "artifacts" table.
	ArtifactsColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUUID},
		{Name: "file_id", Type: field.TypeUUID},
		{Name: "affiliated_file_id", Type: field.TypeUUID},
		{Name: "method", Type: field.TypeString, Nullable: true},
		{Name: "created_at", Type: field.TypeTime, SchemaType: map[string]string{"mysql": "datetime"}},
		{Name: "updated_at", Type: field.TypeTime, SchemaType: map[string]string{"mysql": "datetime"}},
	}
	// ArtifactsTable holds the schema information for the "artifacts" table.
	ArtifactsTable = &schema.Table{
		Name:       "artifacts",
		Columns:    ArtifactsColumns,
		PrimaryKey: []*schema.Column{ArtifactsColumns[0]},
	}
	// FilesColumns holds the columns for the "files" table.
	FilesColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUUID},
		{Name: "file_sha_1", Type: field.TypeString, Unique: true},
		{Name: "file_size", Type: field.TypeInt64},
		{Name: "file_addr", Type: field.TypeString},
		{Name: "type", Type: field.TypeEnum, Enums: []string{"Adposhel", "Agent", "Allaple", "Amonetize", "Androm", "Autorun", "BrowseFox", "Dinwod", "Elex", "Expiro", "Fasong", "HackKMS", "Hlux", "Injector", "InstallCore", "MultiPlug", "Neoreklami", "Neshta", "Other", "Regrun", "Sality", "Snarasite", "Stantinko", "VBA", "VBKrypt", "Vilsel"}, Default: "Other"},
		{Name: "created_at", Type: field.TypeTime, SchemaType: map[string]string{"mysql": "datetime"}},
		{Name: "updated_at", Type: field.TypeTime, SchemaType: map[string]string{"mysql": "datetime"}},
		{Name: "file_artifact", Type: field.TypeUUID, Nullable: true},
	}
	// FilesTable holds the schema information for the "files" table.
	FilesTable = &schema.Table{
		Name:       "files",
		Columns:    FilesColumns,
		PrimaryKey: []*schema.Column{FilesColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "files_artifacts_artifact",
				Columns:    []*schema.Column{FilesColumns[7]},
				RefColumns: []*schema.Column{ArtifactsColumns[0]},
				OnDelete:   schema.SetNull,
			},
		},
	}
	// UsersColumns holds the columns for the "users" table.
	UsersColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUUID},
		{Name: "email", Type: field.TypeString, Unique: true},
		{Name: "username", Type: field.TypeString},
		{Name: "password_hash", Type: field.TypeString},
		{Name: "created_at", Type: field.TypeTime, SchemaType: map[string]string{"mysql": "datetime"}},
		{Name: "updated_at", Type: field.TypeTime, SchemaType: map[string]string{"mysql": "datetime"}},
	}
	// UsersTable holds the schema information for the "users" table.
	UsersTable = &schema.Table{
		Name:       "users",
		Columns:    UsersColumns,
		PrimaryKey: []*schema.Column{UsersColumns[0]},
	}
	// UserUserFileColumns holds the columns for the "user_user_file" table.
	UserUserFileColumns = []*schema.Column{
		{Name: "user_id", Type: field.TypeUUID},
		{Name: "file_id", Type: field.TypeUUID},
	}
	// UserUserFileTable holds the schema information for the "user_user_file" table.
	UserUserFileTable = &schema.Table{
		Name:       "user_user_file",
		Columns:    UserUserFileColumns,
		PrimaryKey: []*schema.Column{UserUserFileColumns[0], UserUserFileColumns[1]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "user_user_file_user_id",
				Columns:    []*schema.Column{UserUserFileColumns[0]},
				RefColumns: []*schema.Column{UsersColumns[0]},
				OnDelete:   schema.Cascade,
			},
			{
				Symbol:     "user_user_file_file_id",
				Columns:    []*schema.Column{UserUserFileColumns[1]},
				RefColumns: []*schema.Column{FilesColumns[0]},
				OnDelete:   schema.Cascade,
			},
		},
	}
	// UserUserArtifactColumns holds the columns for the "user_user_artifact" table.
	UserUserArtifactColumns = []*schema.Column{
		{Name: "user_id", Type: field.TypeUUID},
		{Name: "artifact_id", Type: field.TypeUUID},
	}
	// UserUserArtifactTable holds the schema information for the "user_user_artifact" table.
	UserUserArtifactTable = &schema.Table{
		Name:       "user_user_artifact",
		Columns:    UserUserArtifactColumns,
		PrimaryKey: []*schema.Column{UserUserArtifactColumns[0], UserUserArtifactColumns[1]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "user_user_artifact_user_id",
				Columns:    []*schema.Column{UserUserArtifactColumns[0]},
				RefColumns: []*schema.Column{UsersColumns[0]},
				OnDelete:   schema.Cascade,
			},
			{
				Symbol:     "user_user_artifact_artifact_id",
				Columns:    []*schema.Column{UserUserArtifactColumns[1]},
				RefColumns: []*schema.Column{ArtifactsColumns[0]},
				OnDelete:   schema.Cascade,
			},
		},
	}
	// Tables holds all the tables in the schema.
	Tables = []*schema.Table{
		ArtifactsTable,
		FilesTable,
		UsersTable,
		UserUserFileTable,
		UserUserArtifactTable,
	}
)

func init() {
	FilesTable.ForeignKeys[0].RefTable = ArtifactsTable
	UserUserFileTable.ForeignKeys[0].RefTable = UsersTable
	UserUserFileTable.ForeignKeys[1].RefTable = FilesTable
	UserUserArtifactTable.ForeignKeys[0].RefTable = UsersTable
	UserUserArtifactTable.ForeignKeys[1].RefTable = ArtifactsTable
}

```

`app/bugu/service/internal/data/ent/mutation.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtifact = "Artifact"
	TypeFile     = "File"
	TypeUser     = "User"
)

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	file_id                *uuid.UUID
	affiliated_file_id     *uuid.UUID
	method                 *string
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	affiliated_file        map[uuid.UUID]struct{}
	removedaffiliated_file map[uuid.UUID]struct{}
	clearedaffiliated_file bool
	affiliated_user        map[uuid.UUID]struct{}
	removedaffiliated_user map[uuid.UUID]struct{}
	clearedaffiliated_user bool
	done                   bool
	oldValue               func(context.Context) (*Artifact, error)
	predicates             []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id uuid.UUID) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Artifact entities.
func (m *ArtifactMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artifact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFileID sets the "file_id" field.
func (m *ArtifactMutation) SetFileID(u uuid.UUID) {
	m.file_id = &u
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *ArtifactMutation) FileID() (r uuid.UUID, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldFileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *ArtifactMutation) ResetFileID() {
	m.file_id = nil
}

// SetAffiliatedFileID sets the "affiliated_file_id" field.
func (m *ArtifactMutation) SetAffiliatedFileID(u uuid.UUID) {
	m.affiliated_file_id = &u
}

// AffiliatedFileID returns the value of the "affiliated_file_id" field in the mutation.
func (m *ArtifactMutation) AffiliatedFileID() (r uuid.UUID, exists bool) {
	v := m.affiliated_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliatedFileID returns the old "affiliated_file_id" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldAffiliatedFileID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliatedFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliatedFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliatedFileID: %w", err)
	}
	return oldValue.AffiliatedFileID, nil
}

// ResetAffiliatedFileID resets all changes to the "affiliated_file_id" field.
func (m *ArtifactMutation) ResetAffiliatedFileID() {
	m.affiliated_file_id = nil
}

// SetMethod sets the "method" field.
func (m *ArtifactMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *ArtifactMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *ArtifactMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[artifact.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *ArtifactMutation) MethodCleared() bool {
	_, ok := m.clearedFields[artifact.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *ArtifactMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, artifact.FieldMethod)
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtifactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtifactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtifactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtifactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtifactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtifactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAffiliatedFileIDs adds the "affiliated_file" edge to the File entity by ids.
func (m *ArtifactMutation) AddAffiliatedFileIDs(ids ...uuid.UUID) {
	if m.affiliated_file == nil {
		m.affiliated_file = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.affiliated_file[ids[i]] = struct{}{}
	}
}

// ClearAffiliatedFile clears the "affiliated_file" edge to the File entity.
func (m *ArtifactMutation) ClearAffiliatedFile() {
	m.clearedaffiliated_file = true
}

// AffiliatedFileCleared reports if the "affiliated_file" edge to the File entity was cleared.
func (m *ArtifactMutation) AffiliatedFileCleared() bool {
	return m.clearedaffiliated_file
}

// RemoveAffiliatedFileIDs removes the "affiliated_file" edge to the File entity by IDs.
func (m *ArtifactMutation) RemoveAffiliatedFileIDs(ids ...uuid.UUID) {
	if m.removedaffiliated_file == nil {
		m.removedaffiliated_file = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.affiliated_file, ids[i])
		m.removedaffiliated_file[ids[i]] = struct{}{}
	}
}

// RemovedAffiliatedFile returns the removed IDs of the "affiliated_file" edge to the File entity.
func (m *ArtifactMutation) RemovedAffiliatedFileIDs() (ids []uuid.UUID) {
	for id := range m.removedaffiliated_file {
		ids = append(ids, id)
	}
	return
}

// AffiliatedFileIDs returns the "affiliated_file" edge IDs in the mutation.
func (m *ArtifactMutation) AffiliatedFileIDs() (ids []uuid.UUID) {
	for id := range m.affiliated_file {
		ids = append(ids, id)
	}
	return
}

// ResetAffiliatedFile resets all changes to the "affiliated_file" edge.
func (m *ArtifactMutation) ResetAffiliatedFile() {
	m.affiliated_file = nil
	m.clearedaffiliated_file = false
	m.removedaffiliated_file = nil
}

// AddAffiliatedUserIDs adds the "affiliated_user" edge to the User entity by ids.
func (m *ArtifactMutation) AddAffiliatedUserIDs(ids ...uuid.UUID) {
	if m.affiliated_user == nil {
		m.affiliated_user = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.affiliated_user[ids[i]] = struct{}{}
	}
}

// ClearAffiliatedUser clears the "affiliated_user" edge to the User entity.
func (m *ArtifactMutation) ClearAffiliatedUser() {
	m.clearedaffiliated_user = true
}

// AffiliatedUserCleared reports if the "affiliated_user" edge to the User entity was cleared.
func (m *ArtifactMutation) AffiliatedUserCleared() bool {
	return m.clearedaffiliated_user
}

// RemoveAffiliatedUserIDs removes the "affiliated_user" edge to the User entity by IDs.
func (m *ArtifactMutation) RemoveAffiliatedUserIDs(ids ...uuid.UUID) {
	if m.removedaffiliated_user == nil {
		m.removedaffiliated_user = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.affiliated_user, ids[i])
		m.removedaffiliated_user[ids[i]] = struct{}{}
	}
}

// RemovedAffiliatedUser returns the removed IDs of the "affiliated_user" edge to the User entity.
func (m *ArtifactMutation) RemovedAffiliatedUserIDs() (ids []uuid.UUID) {
	for id := range m.removedaffiliated_user {
		ids = append(ids, id)
	}
	return
}

// AffiliatedUserIDs returns the "affiliated_user" edge IDs in the mutation.
func (m *ArtifactMutation) AffiliatedUserIDs() (ids []uuid.UUID) {
	for id := range m.affiliated_user {
		ids = append(ids, id)
	}
	return
}

// ResetAffiliatedUser resets all changes to the "affiliated_user" edge.
func (m *ArtifactMutation) ResetAffiliatedUser() {
	m.affiliated_user = nil
	m.clearedaffiliated_user = false
	m.removedaffiliated_user = nil
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.file_id != nil {
		fields = append(fields, artifact.FieldFileID)
	}
	if m.affiliated_file_id != nil {
		fields = append(fields, artifact.FieldAffiliatedFileID)
	}
	if m.method != nil {
		fields = append(fields, artifact.FieldMethod)
	}
	if m.created_at != nil {
		fields = append(fields, artifact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, artifact.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldFileID:
		return m.FileID()
	case artifact.FieldAffiliatedFileID:
		return m.AffiliatedFileID()
	case artifact.FieldMethod:
		return m.Method()
	case artifact.FieldCreatedAt:
		return m.CreatedAt()
	case artifact.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldFileID:
		return m.OldFileID(ctx)
	case artifact.FieldAffiliatedFileID:
		return m.OldAffiliatedFileID(ctx)
	case artifact.FieldMethod:
		return m.OldMethod(ctx)
	case artifact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artifact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldFileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case artifact.FieldAffiliatedFileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliatedFileID(v)
		return nil
	case artifact.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case artifact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artifact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artifact.FieldMethod) {
		fields = append(fields, artifact.FieldMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	switch name {
	case artifact.FieldMethod:
		m.ClearMethod()
		return nil
	}
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldFileID:
		m.ResetFileID()
		return nil
	case artifact.FieldAffiliatedFileID:
		m.ResetAffiliatedFileID()
		return nil
	case artifact.FieldMethod:
		m.ResetMethod()
		return nil
	case artifact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artifact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.affiliated_file != nil {
		edges = append(edges, artifact.EdgeAffiliatedFile)
	}
	if m.affiliated_user != nil {
		edges = append(edges, artifact.EdgeAffiliatedUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeAffiliatedFile:
		ids := make([]ent.Value, 0, len(m.affiliated_file))
		for id := range m.affiliated_file {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAffiliatedUser:
		ids := make([]ent.Value, 0, len(m.affiliated_user))
		for id := range m.affiliated_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaffiliated_file != nil {
		edges = append(edges, artifact.EdgeAffiliatedFile)
	}
	if m.removedaffiliated_user != nil {
		edges = append(edges, artifact.EdgeAffiliatedUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeAffiliatedFile:
		ids := make([]ent.Value, 0, len(m.removedaffiliated_file))
		for id := range m.removedaffiliated_file {
			ids = append(ids, id)
		}
		return ids
	case artifact.EdgeAffiliatedUser:
		ids := make([]ent.Value, 0, len(m.removedaffiliated_user))
		for id := range m.removedaffiliated_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaffiliated_file {
		edges = append(edges, artifact.EdgeAffiliatedFile)
	}
	if m.clearedaffiliated_user {
		edges = append(edges, artifact.EdgeAffiliatedUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeAffiliatedFile:
		return m.clearedaffiliated_file
	case artifact.EdgeAffiliatedUser:
		return m.clearedaffiliated_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeAffiliatedFile:
		m.ResetAffiliatedFile()
		return nil
	case artifact.EdgeAffiliatedUser:
		m.ResetAffiliatedUser()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	file_sha_1             *string
	file_size              *int64
	addfile_size           *int64
	file_addr              *string
	_type                  *file.Type
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	artifact               *uuid.UUID
	clearedartifact        bool
	affiliated_user        map[uuid.UUID]struct{}
	removedaffiliated_user map[uuid.UUID]struct{}
	clearedaffiliated_user bool
	done                   bool
	oldValue               func(context.Context) (*File, error)
	predicates             []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id uuid.UUID) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFileSha1 sets the "file_sha_1" field.
func (m *FileMutation) SetFileSha1(s string) {
	m.file_sha_1 = &s
}

// FileSha1 returns the value of the "file_sha_1" field in the mutation.
func (m *FileMutation) FileSha1() (r string, exists bool) {
	v := m.file_sha_1
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSha1 returns the old "file_sha_1" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileSha1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSha1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSha1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSha1: %w", err)
	}
	return oldValue.FileSha1, nil
}

// ResetFileSha1 resets all changes to the "file_sha_1" field.
func (m *FileMutation) ResetFileSha1() {
	m.file_sha_1 = nil
}

// SetFileSize sets the "file_size" field.
func (m *FileMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *FileMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *FileMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *FileMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *FileMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetFileAddr sets the "file_addr" field.
func (m *FileMutation) SetFileAddr(s string) {
	m.file_addr = &s
}

// FileAddr returns the value of the "file_addr" field in the mutation.
func (m *FileMutation) FileAddr() (r string, exists bool) {
	v := m.file_addr
	if v == nil {
		return
	}
	return *v, true
}

// OldFileAddr returns the old "file_addr" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileAddr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileAddr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileAddr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileAddr: %w", err)
	}
	return oldValue.FileAddr, nil
}

// ResetFileAddr resets all changes to the "file_addr" field.
func (m *FileMutation) ResetFileAddr() {
	m.file_addr = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(f file.Type) {
	m._type = &f
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r file.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v file.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetArtifactID sets the "artifact" edge to the Artifact entity by id.
func (m *FileMutation) SetArtifactID(id uuid.UUID) {
	m.artifact = &id
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *FileMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *FileMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactID returns the "artifact" edge ID in the mutation.
func (m *FileMutation) ArtifactID() (id uuid.UUID, exists bool) {
	if m.artifact != nil {
		return *m.artifact, true
	}
	return
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ArtifactIDs() (ids []uuid.UUID) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *FileMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// AddAffiliatedUserIDs adds the "affiliated_user" edge to the User entity by ids.
func (m *FileMutation) AddAffiliatedUserIDs(ids ...uuid.UUID) {
	if m.affiliated_user == nil {
		m.affiliated_user = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.affiliated_user[ids[i]] = struct{}{}
	}
}

// ClearAffiliatedUser clears the "affiliated_user" edge to the User entity.
func (m *FileMutation) ClearAffiliatedUser() {
	m.clearedaffiliated_user = true
}

// AffiliatedUserCleared reports if the "affiliated_user" edge to the User entity was cleared.
func (m *FileMutation) AffiliatedUserCleared() bool {
	return m.clearedaffiliated_user
}

// RemoveAffiliatedUserIDs removes the "affiliated_user" edge to the User entity by IDs.
func (m *FileMutation) RemoveAffiliatedUserIDs(ids ...uuid.UUID) {
	if m.removedaffiliated_user == nil {
		m.removedaffiliated_user = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.affiliated_user, ids[i])
		m.removedaffiliated_user[ids[i]] = struct{}{}
	}
}

// RemovedAffiliatedUser returns the removed IDs of the "affiliated_user" edge to the User entity.
func (m *FileMutation) RemovedAffiliatedUserIDs() (ids []uuid.UUID) {
	for id := range m.removedaffiliated_user {
		ids = append(ids, id)
	}
	return
}

// AffiliatedUserIDs returns the "affiliated_user" edge IDs in the mutation.
func (m *FileMutation) AffiliatedUserIDs() (ids []uuid.UUID) {
	for id := range m.affiliated_user {
		ids = append(ids, id)
	}
	return
}

// ResetAffiliatedUser resets all changes to the "affiliated_user" edge.
func (m *FileMutation) ResetAffiliatedUser() {
	m.affiliated_user = nil
	m.clearedaffiliated_user = false
	m.removedaffiliated_user = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.file_sha_1 != nil {
		fields = append(fields, file.FieldFileSha1)
	}
	if m.file_size != nil {
		fields = append(fields, file.FieldFileSize)
	}
	if m.file_addr != nil {
		fields = append(fields, file.FieldFileAddr)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldFileSha1:
		return m.FileSha1()
	case file.FieldFileSize:
		return m.FileSize()
	case file.FieldFileAddr:
		return m.FileAddr()
	case file.FieldType:
		return m.GetType()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldFileSha1:
		return m.OldFileSha1(ctx)
	case file.FieldFileSize:
		return m.OldFileSize(ctx)
	case file.FieldFileAddr:
		return m.OldFileAddr(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldFileSha1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSha1(v)
		return nil
	case file.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case file.FieldFileAddr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileAddr(v)
		return nil
	case file.FieldType:
		v, ok := value.(file.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, file.FieldFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldFileSize:
		return m.AddedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldFileSha1:
		m.ResetFileSha1()
		return nil
	case file.FieldFileSize:
		m.ResetFileSize()
		return nil
	case file.FieldFileAddr:
		m.ResetFileAddr()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artifact != nil {
		edges = append(edges, file.EdgeArtifact)
	}
	if m.affiliated_user != nil {
		edges = append(edges, file.EdgeAffiliatedUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeAffiliatedUser:
		ids := make([]ent.Value, 0, len(m.affiliated_user))
		for id := range m.affiliated_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaffiliated_user != nil {
		edges = append(edges, file.EdgeAffiliatedUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeAffiliatedUser:
		ids := make([]ent.Value, 0, len(m.removedaffiliated_user))
		for id := range m.removedaffiliated_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartifact {
		edges = append(edges, file.EdgeArtifact)
	}
	if m.clearedaffiliated_user {
		edges = append(edges, file.EdgeAffiliatedUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeArtifact:
		return m.clearedartifact
	case file.EdgeAffiliatedUser:
		return m.clearedaffiliated_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeArtifact:
		m.ClearArtifact()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case file.EdgeAffiliatedUser:
		m.ResetAffiliatedUser()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	email                *string
	username             *string
	password_hash        *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	user_file            map[uuid.UUID]struct{}
	removeduser_file     map[uuid.UUID]struct{}
	cleareduser_file     bool
	user_artifact        map[uuid.UUID]struct{}
	removeduser_artifact map[uuid.UUID]struct{}
	cleareduser_artifact bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserFileIDs adds the "user_file" edge to the File entity by ids.
func (m *UserMutation) AddUserFileIDs(ids ...uuid.UUID) {
	if m.user_file == nil {
		m.user_file = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_file[ids[i]] = struct{}{}
	}
}

// ClearUserFile clears the "user_file" edge to the File entity.
func (m *UserMutation) ClearUserFile() {
	m.cleareduser_file = true
}

// UserFileCleared reports if the "user_file" edge to the File entity was cleared.
func (m *UserMutation) UserFileCleared() bool {
	return m.cleareduser_file
}

// RemoveUserFileIDs removes the "user_file" edge to the File entity by IDs.
func (m *UserMutation) RemoveUserFileIDs(ids ...uuid.UUID) {
	if m.removeduser_file == nil {
		m.removeduser_file = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_file, ids[i])
		m.removeduser_file[ids[i]] = struct{}{}
	}
}

// RemovedUserFile returns the removed IDs of the "user_file" edge to the File entity.
func (m *UserMutation) RemovedUserFileIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_file {
		ids = append(ids, id)
	}
	return
}

// UserFileIDs returns the "user_file" edge IDs in the mutation.
func (m *UserMutation) UserFileIDs() (ids []uuid.UUID) {
	for id := range m.user_file {
		ids = append(ids, id)
	}
	return
}

// ResetUserFile resets all changes to the "user_file" edge.
func (m *UserMutation) ResetUserFile() {
	m.user_file = nil
	m.cleareduser_file = false
	m.removeduser_file = nil
}

// AddUserArtifactIDs adds the "user_artifact" edge to the Artifact entity by ids.
func (m *UserMutation) AddUserArtifactIDs(ids ...uuid.UUID) {
	if m.user_artifact == nil {
		m.user_artifact = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_artifact[ids[i]] = struct{}{}
	}
}

// ClearUserArtifact clears the "user_artifact" edge to the Artifact entity.
func (m *UserMutation) ClearUserArtifact() {
	m.cleareduser_artifact = true
}

// UserArtifactCleared reports if the "user_artifact" edge to the Artifact entity was cleared.
func (m *UserMutation) UserArtifactCleared() bool {
	return m.cleareduser_artifact
}

// RemoveUserArtifactIDs removes the "user_artifact" edge to the Artifact entity by IDs.
func (m *UserMutation) RemoveUserArtifactIDs(ids ...uuid.UUID) {
	if m.removeduser_artifact == nil {
		m.removeduser_artifact = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_artifact, ids[i])
		m.removeduser_artifact[ids[i]] = struct{}{}
	}
}

// RemovedUserArtifact returns the removed IDs of the "user_artifact" edge to the Artifact entity.
func (m *UserMutation) RemovedUserArtifactIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_artifact {
		ids = append(ids, id)
	}
	return
}

// UserArtifactIDs returns the "user_artifact" edge IDs in the mutation.
func (m *UserMutation) UserArtifactIDs() (ids []uuid.UUID) {
	for id := range m.user_artifact {
		ids = append(ids, id)
	}
	return
}

// ResetUserArtifact resets all changes to the "user_artifact" edge.
func (m *UserMutation) ResetUserArtifact() {
	m.user_artifact = nil
	m.cleareduser_artifact = false
	m.removeduser_artifact = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_file != nil {
		edges = append(edges, user.EdgeUserFile)
	}
	if m.user_artifact != nil {
		edges = append(edges, user.EdgeUserArtifact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserFile:
		ids := make([]ent.Value, 0, len(m.user_file))
		for id := range m.user_file {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserArtifact:
		ids := make([]ent.Value, 0, len(m.user_artifact))
		for id := range m.user_artifact {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_file != nil {
		edges = append(edges, user.EdgeUserFile)
	}
	if m.removeduser_artifact != nil {
		edges = append(edges, user.EdgeUserArtifact)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserFile:
		ids := make([]ent.Value, 0, len(m.removeduser_file))
		for id := range m.removeduser_file {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserArtifact:
		ids := make([]ent.Value, 0, len(m.removeduser_artifact))
		for id := range m.removeduser_artifact {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_file {
		edges = append(edges, user.EdgeUserFile)
	}
	if m.cleareduser_artifact {
		edges = append(edges, user.EdgeUserArtifact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserFile:
		return m.cleareduser_file
	case user.EdgeUserArtifact:
		return m.cleareduser_artifact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserFile:
		m.ResetUserFile()
		return nil
	case user.EdgeUserArtifact:
		m.ResetUserArtifact()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

```

`app/bugu/service/internal/data/ent/predicate/predicate.go`:

```go
// Code generated by entc, DO NOT EDIT.

package predicate

import (
	"entgo.io/ent/dialect/sql"
)

// Artifact is the predicate function for artifact builders.
type Artifact func(*sql.Selector)

// File is the predicate function for file builders.
type File func(*sql.Selector)

// User is the predicate function for user builders.
type User func(*sql.Selector)

```

`app/bugu/service/internal/data/ent/runtime.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"time"

	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/schema"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// The init function reads all schema descriptors with runtime code
// (default values, validators, hooks and policies) and stitches it
// to their package variables.
func init() {
	artifactFields := schema.Artifact{}.Fields()
	_ = artifactFields
	// artifactDescCreatedAt is the schema descriptor for created_at field.
	artifactDescCreatedAt := artifactFields[4].Descriptor()
	// artifact.DefaultCreatedAt holds the default value on creation for the created_at field.
	artifact.DefaultCreatedAt = artifactDescCreatedAt.Default.(func() time.Time)
	// artifactDescUpdatedAt is the schema descriptor for updated_at field.
	artifactDescUpdatedAt := artifactFields[5].Descriptor()
	// artifact.DefaultUpdatedAt holds the default value on creation for the updated_at field.
	artifact.DefaultUpdatedAt = artifactDescUpdatedAt.Default.(func() time.Time)
	fileFields := schema.File{}.Fields()
	_ = fileFields
	// fileDescCreatedAt is the schema descriptor for created_at field.
	fileDescCreatedAt := fileFields[5].Descriptor()
	// file.DefaultCreatedAt holds the default value on creation for the created_at field.
	file.DefaultCreatedAt = fileDescCreatedAt.Default.(func() time.Time)
	// fileDescUpdatedAt is the schema descriptor for updated_at field.
	fileDescUpdatedAt := fileFields[6].Descriptor()
	// file.DefaultUpdatedAt holds the default value on creation for the updated_at field.
	file.DefaultUpdatedAt = fileDescUpdatedAt.Default.(func() time.Time)
	userFields := schema.User{}.Fields()
	_ = userFields
	// userDescCreatedAt is the schema descriptor for created_at field.
	userDescCreatedAt := userFields[4].Descriptor()
	// user.DefaultCreatedAt holds the default value on creation for the created_at field.
	user.DefaultCreatedAt = userDescCreatedAt.Default.(func() time.Time)
	// userDescUpdatedAt is the schema descriptor for updated_at field.
	userDescUpdatedAt := userFields[5].Descriptor()
	// user.DefaultUpdatedAt holds the default value on creation for the updated_at field.
	user.DefaultUpdatedAt = userDescUpdatedAt.Default.(func() time.Time)
}

```

`app/bugu/service/internal/data/ent/runtime/runtime.go`:

```go
// Code generated by entc, DO NOT EDIT.

package runtime

// The schema-stitching logic is generated in github.com/hominsu/bugu/app/bugu/service/internal/data/ent/runtime.go

const (
	Version = "v0.10.1"                                         // Version of ent codegen.
	Sum     = "h1:dM5h4Zk6yHGIgw4dCqVzGw3nWgpGYJiV4/kyHEF6PFo=" // Sum of ent codegen.
)

```

`app/bugu/service/internal/data/ent/schema/artifact.go`:

```go
package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

// Artifact holds the schema definition for the Artifact entity.
type Artifact struct {
	ent.Schema
}

// Fields of the Artifact.
func (Artifact) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}),
		field.UUID("file_id", uuid.UUID{}),
		field.UUID("affiliated_file_id", uuid.UUID{}),
		field.String("method").Optional(),
		field.Time("created_at").
			Default(time.Now).
			Immutable().
			SchemaType(map[string]string{
				dialect.MySQL: "datetime",
			}),
		field.Time("updated_at").
			Default(time.Now).
			SchemaType(map[string]string{
				dialect.MySQL: "datetime",
			}),
	}
}

// Edges of the Artifact.
func (Artifact) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("affiliated_file", File.Type).
			Ref("artifact"),
		edge.From("affiliated_user", User.Type).
			Ref("user_artifact"),
	}
}

```

`app/bugu/service/internal/data/ent/schema/file.go`:

```go
package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

// File holds the schema definition for the File entity.
type File struct {
	ent.Schema
}

// Fields of the File.
func (File) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}),
		field.String("file_sha_1").Unique(),
		field.Int64("file_size"),
		field.String("file_addr"),
		field.Enum("type").
			Values("Adposhel", "Agent", "Allaple", "Amonetize", "Androm",
				"Autorun", "BrowseFox", "Dinwod", "Elex", "Expiro",
				"Fasong", "HackKMS", "Hlux", "Injector", "InstallCore",
				"MultiPlug", "Neoreklami", "Neshta", "Other", "Regrun",
				"Sality", "Snarasite", "Stantinko", "VBA", "VBKrypt",
				"Vilsel").
			Default("Other"),
		field.Time("created_at").
			Default(time.Now).
			Immutable().
			SchemaType(map[string]string{
				dialect.MySQL: "datetime",
			}),
		field.Time("updated_at").
			Default(time.Now).
			SchemaType(map[string]string{
				dialect.MySQL: "datetime",
			}),
	}
}

// Edges of the File.
func (File) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("artifact", Artifact.Type).
			Unique(),
		edge.From("affiliated_user", User.Type).
			Ref("user_file"),
	}
}

```

`app/bugu/service/internal/data/ent/schema/user.go`:

```go
package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}),
		field.String("email").Unique(),
		field.String("username"),
		field.String("password_hash"),
		field.Time("created_at").
			Default(time.Now).
			Immutable().
			SchemaType(map[string]string{
				dialect.MySQL: "datetime",
			}),
		field.Time("updated_at").
			Default(time.Now).
			SchemaType(map[string]string{
				dialect.MySQL: "datetime",
			}),
	}
}

// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("user_file", File.Type),
		edge.To("user_artifact", Artifact.Type),
	}
}

```

`app/bugu/service/internal/data/ent/tx.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"sync"

	"entgo.io/ent/dialect"
)

// Tx is a transactional client that is created by calling Client.Tx().
type Tx struct {
	config
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// User is the client for interacting with the User builders.
	User *UserClient

	// lazily loaded.
	client     *Client
	clientOnce sync.Once

	// completion callbacks.
	mu         sync.Mutex
	onCommit   []CommitHook
	onRollback []RollbackHook

	// ctx lives for the life of the transaction. It is
	// the same context used by the underlying connection.
	ctx context.Context
}

type (
	// Committer is the interface that wraps the Commit method.
	Committer interface {
		Commit(context.Context, *Tx) error
	}

	// The CommitFunc type is an adapter to allow the use of ordinary
	// function as a Committer. If f is a function with the appropriate
	// signature, CommitFunc(f) is a Committer that calls f.
	CommitFunc func(context.Context, *Tx) error

	// CommitHook defines the "commit middleware". A function that gets a Committer
	// and returns a Committer. For example:
	//
	//	hook := func(next ent.Committer) ent.Committer {
	//		return ent.CommitFunc(func(ctx context.Context, tx *ent.Tx) error {
	//			// Do some stuff before.
	//			if err := next.Commit(ctx, tx); err != nil {
	//				return err
	//			}
	//			// Do some stuff after.
	//			return nil
	//		})
	//	}
	//
	CommitHook func(Committer) Committer
)

// Commit calls f(ctx, m).
func (f CommitFunc) Commit(ctx context.Context, tx *Tx) error {
	return f(ctx, tx)
}

// Commit commits the transaction.
func (tx *Tx) Commit() error {
	txDriver := tx.config.driver.(*txDriver)
	var fn Committer = CommitFunc(func(context.Context, *Tx) error {
		return txDriver.tx.Commit()
	})
	tx.mu.Lock()
	hooks := append([]CommitHook(nil), tx.onCommit...)
	tx.mu.Unlock()
	for i := len(hooks) - 1; i >= 0; i-- {
		fn = hooks[i](fn)
	}
	return fn.Commit(tx.ctx, tx)
}

// OnCommit adds a hook to call on commit.
func (tx *Tx) OnCommit(f CommitHook) {
	tx.mu.Lock()
	defer tx.mu.Unlock()
	tx.onCommit = append(tx.onCommit, f)
}

type (
	// Rollbacker is the interface that wraps the Rollback method.
	Rollbacker interface {
		Rollback(context.Context, *Tx) error
	}

	// The RollbackFunc type is an adapter to allow the use of ordinary
	// function as a Rollbacker. If f is a function with the appropriate
	// signature, RollbackFunc(f) is a Rollbacker that calls f.
	RollbackFunc func(context.Context, *Tx) error

	// RollbackHook defines the "rollback middleware". A function that gets a Rollbacker
	// and returns a Rollbacker. For example:
	//
	//	hook := func(next ent.Rollbacker) ent.Rollbacker {
	//		return ent.RollbackFunc(func(ctx context.Context, tx *ent.Tx) error {
	//			// Do some stuff before.
	//			if err := next.Rollback(ctx, tx); err != nil {
	//				return err
	//			}
	//			// Do some stuff after.
	//			return nil
	//		})
	//	}
	//
	RollbackHook func(Rollbacker) Rollbacker
)

// Rollback calls f(ctx, m).
func (f RollbackFunc) Rollback(ctx context.Context, tx *Tx) error {
	return f(ctx, tx)
}

// Rollback rollbacks the transaction.
func (tx *Tx) Rollback() error {
	txDriver := tx.config.driver.(*txDriver)
	var fn Rollbacker = RollbackFunc(func(context.Context, *Tx) error {
		return txDriver.tx.Rollback()
	})
	tx.mu.Lock()
	hooks := append([]RollbackHook(nil), tx.onRollback...)
	tx.mu.Unlock()
	for i := len(hooks) - 1; i >= 0; i-- {
		fn = hooks[i](fn)
	}
	return fn.Rollback(tx.ctx, tx)
}

// OnRollback adds a hook to call on rollback.
func (tx *Tx) OnRollback(f RollbackHook) {
	tx.mu.Lock()
	defer tx.mu.Unlock()
	tx.onRollback = append(tx.onRollback, f)
}

// Client returns a Client that binds to current transaction.
func (tx *Tx) Client() *Client {
	tx.clientOnce.Do(func() {
		tx.client = &Client{config: tx.config}
		tx.client.init()
	})
	return tx.client
}

func (tx *Tx) init() {
	tx.Artifact = NewArtifactClient(tx.config)
	tx.File = NewFileClient(tx.config)
	tx.User = NewUserClient(tx.config)
}

// txDriver wraps the given dialect.Tx with a nop dialect.Driver implementation.
// The idea is to support transactions without adding any extra code to the builders.
// When a builder calls to driver.Tx(), it gets the same dialect.Tx instance.
// Commit and Rollback are nop for the internal builders and the user must call one
// of them in order to commit or rollback the transaction.
//
// If a closed transaction is embedded in one of the generated entities, and the entity
// applies a query, for example: Artifact.QueryXXX(), the query will be executed
// through the driver which created this transaction.
//
// Note that txDriver is not goroutine safe.
type txDriver struct {
	// the driver we started the transaction from.
	drv dialect.Driver
	// tx is the underlying transaction.
	tx dialect.Tx
}

// newTx creates a new transactional driver.
func newTx(ctx context.Context, drv dialect.Driver) (*txDriver, error) {
	tx, err := drv.Tx(ctx)
	if err != nil {
		return nil, err
	}
	return &txDriver{tx: tx, drv: drv}, nil
}

// Tx returns the transaction wrapper (txDriver) to avoid Commit or Rollback calls
// from the internal builders. Should be called only by the internal builders.
func (tx *txDriver) Tx(context.Context) (dialect.Tx, error) { return tx, nil }

// Dialect returns the dialect of the driver we started the transaction from.
func (tx *txDriver) Dialect() string { return tx.drv.Dialect() }

// Close is a nop close.
func (*txDriver) Close() error { return nil }

// Commit is a nop commit for the internal builders.
// User must call `Tx.Commit` in order to commit the transaction.
func (*txDriver) Commit() error { return nil }

// Rollback is a nop rollback for the internal builders.
// User must call `Tx.Rollback` in order to rollback the transaction.
func (*txDriver) Rollback() error { return nil }

// Exec calls tx.Exec.
func (tx *txDriver) Exec(ctx context.Context, query string, args, v interface{}) error {
	return tx.tx.Exec(ctx, query, args, v)
}

// Query calls tx.Query.
func (tx *txDriver) Query(ctx context.Context, query string, args, v interface{}) error {
	return tx.tx.Query(ctx, query, args, v)
}

var _ dialect.Driver = (*txDriver)(nil)

```

`app/bugu/service/internal/data/ent/user.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// User is the model entity for the User schema.
type User struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// Email holds the value of the "email" field.
	Email string `json:"email,omitempty"`
	// Username holds the value of the "username" field.
	Username string `json:"username,omitempty"`
	// PasswordHash holds the value of the "password_hash" field.
	PasswordHash string `json:"password_hash,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the UserQuery when eager-loading is set.
	Edges UserEdges `json:"edges"`
}

// UserEdges holds the relations/edges for other nodes in the graph.
type UserEdges struct {
	// UserFile holds the value of the user_file edge.
	UserFile []*File `json:"user_file,omitempty"`
	// UserArtifact holds the value of the user_artifact edge.
	UserArtifact []*Artifact `json:"user_artifact,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// UserFileOrErr returns the UserFile value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) UserFileOrErr() ([]*File, error) {
	if e.loadedTypes[0] {
		return e.UserFile, nil
	}
	return nil, &NotLoadedError{edge: "user_file"}
}

// UserArtifactOrErr returns the UserArtifact value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) UserArtifactOrErr() ([]*Artifact, error) {
	if e.loadedTypes[1] {
		return e.UserArtifact, nil
	}
	return nil, &NotLoadedError{edge: "user_artifact"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*User) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case user.FieldEmail, user.FieldUsername, user.FieldPasswordHash:
			values[i] = new(sql.NullString)
		case user.FieldCreatedAt, user.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case user.FieldID:
			values[i] = new(uuid.UUID)
		default:
			return nil, fmt.Errorf("unexpected column %q for type User", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the User fields.
func (u *User) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case user.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				u.ID = *value
			}
		case user.FieldEmail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field email", values[i])
			} else if value.Valid {
				u.Email = value.String
			}
		case user.FieldUsername:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field username", values[i])
			} else if value.Valid {
				u.Username = value.String
			}
		case user.FieldPasswordHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field password_hash", values[i])
			} else if value.Valid {
				u.PasswordHash = value.String
			}
		case user.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				u.CreatedAt = value.Time
			}
		case user.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				u.UpdatedAt = value.Time
			}
		}
	}
	return nil
}

// QueryUserFile queries the "user_file" edge of the User entity.
func (u *User) QueryUserFile() *FileQuery {
	return (&UserClient{config: u.config}).QueryUserFile(u)
}

// QueryUserArtifact queries the "user_artifact" edge of the User entity.
func (u *User) QueryUserArtifact() *ArtifactQuery {
	return (&UserClient{config: u.config}).QueryUserArtifact(u)
}

// Update returns a builder for updating this User.
// Note that you need to call User.Unwrap() before calling this method if this User
// was returned from a transaction, and the transaction was committed or rolled back.
func (u *User) Update() *UserUpdateOne {
	return (&UserClient{config: u.config}).UpdateOne(u)
}

// Unwrap unwraps the User entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (u *User) Unwrap() *User {
	tx, ok := u.config.driver.(*txDriver)
	if !ok {
		panic("ent: User is not a transactional entity")
	}
	u.config.driver = tx.drv
	return u
}

// String implements the fmt.Stringer.
func (u *User) String() string {
	var builder strings.Builder
	builder.WriteString("User(")
	builder.WriteString(fmt.Sprintf("id=%v", u.ID))
	builder.WriteString(", email=")
	builder.WriteString(u.Email)
	builder.WriteString(", username=")
	builder.WriteString(u.Username)
	builder.WriteString(", password_hash=")
	builder.WriteString(u.PasswordHash)
	builder.WriteString(", created_at=")
	builder.WriteString(u.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updated_at=")
	builder.WriteString(u.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Users is a parsable slice of User.
type Users []*User

func (u Users) config(cfg config) {
	for _i := range u {
		u[_i].config = cfg
	}
}

```

`app/bugu/service/internal/data/ent/user/user.go`:

```go
// Code generated by entc, DO NOT EDIT.

package user

import (
	"time"
)

const (
	// Label holds the string label denoting the user type in the database.
	Label = "user"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldEmail holds the string denoting the email field in the database.
	FieldEmail = "email"
	// FieldUsername holds the string denoting the username field in the database.
	FieldUsername = "username"
	// FieldPasswordHash holds the string denoting the password_hash field in the database.
	FieldPasswordHash = "password_hash"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// EdgeUserFile holds the string denoting the user_file edge name in mutations.
	EdgeUserFile = "user_file"
	// EdgeUserArtifact holds the string denoting the user_artifact edge name in mutations.
	EdgeUserArtifact = "user_artifact"
	// Table holds the table name of the user in the database.
	Table = "users"
	// UserFileTable is the table that holds the user_file relation/edge. The primary key declared below.
	UserFileTable = "user_user_file"
	// UserFileInverseTable is the table name for the File entity.
	// It exists in this package in order to avoid circular dependency with the "file" package.
	UserFileInverseTable = "files"
	// UserArtifactTable is the table that holds the user_artifact relation/edge. The primary key declared below.
	UserArtifactTable = "user_user_artifact"
	// UserArtifactInverseTable is the table name for the Artifact entity.
	// It exists in this package in order to avoid circular dependency with the "artifact" package.
	UserArtifactInverseTable = "artifacts"
)

// Columns holds all SQL columns for user fields.
var Columns = []string{
	FieldID,
	FieldEmail,
	FieldUsername,
	FieldPasswordHash,
	FieldCreatedAt,
	FieldUpdatedAt,
}

var (
	// UserFilePrimaryKey and UserFileColumn2 are the table columns denoting the
	// primary key for the user_file relation (M2M).
	UserFilePrimaryKey = []string{"user_id", "file_id"}
	// UserArtifactPrimaryKey and UserArtifactColumn2 are the table columns denoting the
	// primary key for the user_artifact relation (M2M).
	UserArtifactPrimaryKey = []string{"user_id", "artifact_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
)

```

`app/bugu/service/internal/data/ent/user/where.go`:

```go
// Code generated by entc, DO NOT EDIT.

package user

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Email applies equality check predicate on the "email" field. It's identical to EmailEQ.
func Email(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEmail), v))
	})
}

// Username applies equality check predicate on the "username" field. It's identical to UsernameEQ.
func Username(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUsername), v))
	})
}

// PasswordHash applies equality check predicate on the "password_hash" field. It's identical to PasswordHashEQ.
func PasswordHash(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPasswordHash), v))
	})
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// EmailEQ applies the EQ predicate on the "email" field.
func EmailEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEmail), v))
	})
}

// EmailNEQ applies the NEQ predicate on the "email" field.
func EmailNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEmail), v))
	})
}

// EmailIn applies the In predicate on the "email" field.
func EmailIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEmail), v...))
	})
}

// EmailNotIn applies the NotIn predicate on the "email" field.
func EmailNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEmail), v...))
	})
}

// EmailGT applies the GT predicate on the "email" field.
func EmailGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldEmail), v))
	})
}

// EmailGTE applies the GTE predicate on the "email" field.
func EmailGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldEmail), v))
	})
}

// EmailLT applies the LT predicate on the "email" field.
func EmailLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldEmail), v))
	})
}

// EmailLTE applies the LTE predicate on the "email" field.
func EmailLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldEmail), v))
	})
}

// EmailContains applies the Contains predicate on the "email" field.
func EmailContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldEmail), v))
	})
}

// EmailHasPrefix applies the HasPrefix predicate on the "email" field.
func EmailHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldEmail), v))
	})
}

// EmailHasSuffix applies the HasSuffix predicate on the "email" field.
func EmailHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldEmail), v))
	})
}

// EmailEqualFold applies the EqualFold predicate on the "email" field.
func EmailEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldEmail), v))
	})
}

// EmailContainsFold applies the ContainsFold predicate on the "email" field.
func EmailContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldEmail), v))
	})
}

// UsernameEQ applies the EQ predicate on the "username" field.
func UsernameEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUsername), v))
	})
}

// UsernameNEQ applies the NEQ predicate on the "username" field.
func UsernameNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUsername), v))
	})
}

// UsernameIn applies the In predicate on the "username" field.
func UsernameIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUsername), v...))
	})
}

// UsernameNotIn applies the NotIn predicate on the "username" field.
func UsernameNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUsername), v...))
	})
}

// UsernameGT applies the GT predicate on the "username" field.
func UsernameGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUsername), v))
	})
}

// UsernameGTE applies the GTE predicate on the "username" field.
func UsernameGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUsername), v))
	})
}

// UsernameLT applies the LT predicate on the "username" field.
func UsernameLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUsername), v))
	})
}

// UsernameLTE applies the LTE predicate on the "username" field.
func UsernameLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUsername), v))
	})
}

// UsernameContains applies the Contains predicate on the "username" field.
func UsernameContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUsername), v))
	})
}

// UsernameHasPrefix applies the HasPrefix predicate on the "username" field.
func UsernameHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUsername), v))
	})
}

// UsernameHasSuffix applies the HasSuffix predicate on the "username" field.
func UsernameHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUsername), v))
	})
}

// UsernameEqualFold applies the EqualFold predicate on the "username" field.
func UsernameEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUsername), v))
	})
}

// UsernameContainsFold applies the ContainsFold predicate on the "username" field.
func UsernameContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUsername), v))
	})
}

// PasswordHashEQ applies the EQ predicate on the "password_hash" field.
func PasswordHashEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashNEQ applies the NEQ predicate on the "password_hash" field.
func PasswordHashNEQ(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashIn applies the In predicate on the "password_hash" field.
func PasswordHashIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPasswordHash), v...))
	})
}

// PasswordHashNotIn applies the NotIn predicate on the "password_hash" field.
func PasswordHashNotIn(vs ...string) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPasswordHash), v...))
	})
}

// PasswordHashGT applies the GT predicate on the "password_hash" field.
func PasswordHashGT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashGTE applies the GTE predicate on the "password_hash" field.
func PasswordHashGTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashLT applies the LT predicate on the "password_hash" field.
func PasswordHashLT(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashLTE applies the LTE predicate on the "password_hash" field.
func PasswordHashLTE(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashContains applies the Contains predicate on the "password_hash" field.
func PasswordHashContains(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashHasPrefix applies the HasPrefix predicate on the "password_hash" field.
func PasswordHashHasPrefix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashHasSuffix applies the HasSuffix predicate on the "password_hash" field.
func PasswordHashHasSuffix(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashEqualFold applies the EqualFold predicate on the "password_hash" field.
func PasswordHashEqualFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPasswordHash), v))
	})
}

// PasswordHashContainsFold applies the ContainsFold predicate on the "password_hash" field.
func PasswordHashContainsFold(v string) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPasswordHash), v))
	})
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.User {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.User(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatedAt), v...))
	})
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatedAt), v))
	})
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatedAt), v))
	})
}

// HasUserFile applies the HasEdge predicate on the "user_file" edge.
func HasUserFile() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserFileTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, UserFileTable, UserFilePrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserFileWith applies the HasEdge predicate on the "user_file" edge with a given conditions (other predicates).
func HasUserFileWith(preds ...predicate.File) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserFileInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, UserFileTable, UserFilePrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUserArtifact applies the HasEdge predicate on the "user_artifact" edge.
func HasUserArtifact() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserArtifactTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, UserArtifactTable, UserArtifactPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserArtifactWith applies the HasEdge predicate on the "user_artifact" edge with a given conditions (other predicates).
func HasUserArtifactWith(preds ...predicate.Artifact) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserArtifactInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, UserArtifactTable, UserArtifactPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.User) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		p(s.Not())
	})
}

```

`app/bugu/service/internal/data/ent/user_create.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// UserCreate is the builder for creating a User entity.
type UserCreate struct {
	config
	mutation *UserMutation
	hooks    []Hook
}

// SetEmail sets the "email" field.
func (uc *UserCreate) SetEmail(s string) *UserCreate {
	uc.mutation.SetEmail(s)
	return uc
}

// SetUsername sets the "username" field.
func (uc *UserCreate) SetUsername(s string) *UserCreate {
	uc.mutation.SetUsername(s)
	return uc
}

// SetPasswordHash sets the "password_hash" field.
func (uc *UserCreate) SetPasswordHash(s string) *UserCreate {
	uc.mutation.SetPasswordHash(s)
	return uc
}

// SetCreatedAt sets the "created_at" field.
func (uc *UserCreate) SetCreatedAt(t time.Time) *UserCreate {
	uc.mutation.SetCreatedAt(t)
	return uc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (uc *UserCreate) SetNillableCreatedAt(t *time.Time) *UserCreate {
	if t != nil {
		uc.SetCreatedAt(*t)
	}
	return uc
}

// SetUpdatedAt sets the "updated_at" field.
func (uc *UserCreate) SetUpdatedAt(t time.Time) *UserCreate {
	uc.mutation.SetUpdatedAt(t)
	return uc
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (uc *UserCreate) SetNillableUpdatedAt(t *time.Time) *UserCreate {
	if t != nil {
		uc.SetUpdatedAt(*t)
	}
	return uc
}

// SetID sets the "id" field.
func (uc *UserCreate) SetID(u uuid.UUID) *UserCreate {
	uc.mutation.SetID(u)
	return uc
}

// AddUserFileIDs adds the "user_file" edge to the File entity by IDs.
func (uc *UserCreate) AddUserFileIDs(ids ...uuid.UUID) *UserCreate {
	uc.mutation.AddUserFileIDs(ids...)
	return uc
}

// AddUserFile adds the "user_file" edges to the File entity.
func (uc *UserCreate) AddUserFile(f ...*File) *UserCreate {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uc.AddUserFileIDs(ids...)
}

// AddUserArtifactIDs adds the "user_artifact" edge to the Artifact entity by IDs.
func (uc *UserCreate) AddUserArtifactIDs(ids ...uuid.UUID) *UserCreate {
	uc.mutation.AddUserArtifactIDs(ids...)
	return uc
}

// AddUserArtifact adds the "user_artifact" edges to the Artifact entity.
func (uc *UserCreate) AddUserArtifact(a ...*Artifact) *UserCreate {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uc.AddUserArtifactIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uc *UserCreate) Mutation() *UserMutation {
	return uc.mutation
}

// Save creates the User in the database.
func (uc *UserCreate) Save(ctx context.Context) (*User, error) {
	var (
		err  error
		node *User
	)
	uc.defaults()
	if len(uc.hooks) == 0 {
		if err = uc.check(); err != nil {
			return nil, err
		}
		node, err = uc.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*UserMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = uc.check(); err != nil {
				return nil, err
			}
			uc.mutation = mutation
			if node, err = uc.sqlSave(ctx); err != nil {
				return nil, err
			}
			mutation.id = &node.ID
			mutation.done = true
			return node, err
		})
		for i := len(uc.hooks) - 1; i >= 0; i-- {
			if uc.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = uc.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, uc.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX calls Save and panics if Save returns an error.
func (uc *UserCreate) SaveX(ctx context.Context) *User {
	v, err := uc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (uc *UserCreate) Exec(ctx context.Context) error {
	_, err := uc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uc *UserCreate) ExecX(ctx context.Context) {
	if err := uc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (uc *UserCreate) defaults() {
	if _, ok := uc.mutation.CreatedAt(); !ok {
		v := user.DefaultCreatedAt()
		uc.mutation.SetCreatedAt(v)
	}
	if _, ok := uc.mutation.UpdatedAt(); !ok {
		v := user.DefaultUpdatedAt()
		uc.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (uc *UserCreate) check() error {
	if _, ok := uc.mutation.Email(); !ok {
		return &ValidationError{Name: "email", err: errors.New(`ent: missing required field "User.email"`)}
	}
	if _, ok := uc.mutation.Username(); !ok {
		return &ValidationError{Name: "username", err: errors.New(`ent: missing required field "User.username"`)}
	}
	if _, ok := uc.mutation.PasswordHash(); !ok {
		return &ValidationError{Name: "password_hash", err: errors.New(`ent: missing required field "User.password_hash"`)}
	}
	if _, ok := uc.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "User.created_at"`)}
	}
	if _, ok := uc.mutation.UpdatedAt(); !ok {
		return &ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "User.updated_at"`)}
	}
	return nil
}

func (uc *UserCreate) sqlSave(ctx context.Context) (*User, error) {
	_node, _spec := uc.createSpec()
	if err := sqlgraph.CreateNode(ctx, uc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(*uuid.UUID); ok {
			_node.ID = *id
		} else if err := _node.ID.Scan(_spec.ID.Value); err != nil {
			return nil, err
		}
	}
	return _node, nil
}

func (uc *UserCreate) createSpec() (*User, *sqlgraph.CreateSpec) {
	var (
		_node = &User{config: uc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: user.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: user.FieldID,
			},
		}
	)
	if id, ok := uc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = &id
	}
	if value, ok := uc.mutation.Email(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldEmail,
		})
		_node.Email = value
	}
	if value, ok := uc.mutation.Username(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldUsername,
		})
		_node.Username = value
	}
	if value, ok := uc.mutation.PasswordHash(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldPasswordHash,
		})
		_node.PasswordHash = value
	}
	if value, ok := uc.mutation.CreatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: user.FieldCreatedAt,
		})
		_node.CreatedAt = value
	}
	if value, ok := uc.mutation.UpdatedAt(); ok {
		_spec.Fields = append(_spec.Fields, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: user.FieldUpdatedAt,
		})
		_node.UpdatedAt = value
	}
	if nodes := uc.mutation.UserFileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserFileTable,
			Columns: user.UserFilePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := uc.mutation.UserArtifactIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserArtifactTable,
			Columns: user.UserArtifactPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// UserCreateBulk is the builder for creating many User entities in bulk.
type UserCreateBulk struct {
	config
	builders []*UserCreate
}

// Save creates the User entities in the database.
func (ucb *UserCreateBulk) Save(ctx context.Context) ([]*User, error) {
	specs := make([]*sqlgraph.CreateSpec, len(ucb.builders))
	nodes := make([]*User, len(ucb.builders))
	mutators := make([]Mutator, len(ucb.builders))
	for i := range ucb.builders {
		func(i int, root context.Context) {
			builder := ucb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*UserMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, ucb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, ucb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{err.Error(), err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, ucb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (ucb *UserCreateBulk) SaveX(ctx context.Context) []*User {
	v, err := ucb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (ucb *UserCreateBulk) Exec(ctx context.Context) error {
	_, err := ucb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ucb *UserCreateBulk) ExecX(ctx context.Context) {
	if err := ucb.Exec(ctx); err != nil {
		panic(err)
	}
}

```

`app/bugu/service/internal/data/ent/user_delete.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// UserDelete is the builder for deleting a User entity.
type UserDelete struct {
	config
	hooks    []Hook
	mutation *UserMutation
}

// Where appends a list predicates to the UserDelete builder.
func (ud *UserDelete) Where(ps ...predicate.User) *UserDelete {
	ud.mutation.Where(ps...)
	return ud
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (ud *UserDelete) Exec(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(ud.hooks) == 0 {
		affected, err = ud.sqlExec(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*UserMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			ud.mutation = mutation
			affected, err = ud.sqlExec(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(ud.hooks) - 1; i >= 0; i-- {
			if ud.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = ud.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, ud.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// ExecX is like Exec, but panics if an error occurs.
func (ud *UserDelete) ExecX(ctx context.Context) int {
	n, err := ud.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (ud *UserDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := &sqlgraph.DeleteSpec{
		Node: &sqlgraph.NodeSpec{
			Table: user.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: user.FieldID,
			},
		},
	}
	if ps := ud.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return sqlgraph.DeleteNodes(ctx, ud.driver, _spec)
}

// UserDeleteOne is the builder for deleting a single User entity.
type UserDeleteOne struct {
	ud *UserDelete
}

// Exec executes the deletion query.
func (udo *UserDeleteOne) Exec(ctx context.Context) error {
	n, err := udo.ud.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{user.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (udo *UserDeleteOne) ExecX(ctx context.Context) {
	udo.ud.ExecX(ctx)
}

```

`app/bugu/service/internal/data/ent/user_query.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// UserQuery is the builder for querying User entities.
type UserQuery struct {
	config
	limit      *int
	offset     *int
	unique     *bool
	order      []OrderFunc
	fields     []string
	predicates []predicate.User
	// eager-loading edges.
	withUserFile     *FileQuery
	withUserArtifact *ArtifactQuery
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the UserQuery builder.
func (uq *UserQuery) Where(ps ...predicate.User) *UserQuery {
	uq.predicates = append(uq.predicates, ps...)
	return uq
}

// Limit adds a limit step to the query.
func (uq *UserQuery) Limit(limit int) *UserQuery {
	uq.limit = &limit
	return uq
}

// Offset adds an offset step to the query.
func (uq *UserQuery) Offset(offset int) *UserQuery {
	uq.offset = &offset
	return uq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (uq *UserQuery) Unique(unique bool) *UserQuery {
	uq.unique = &unique
	return uq
}

// Order adds an order step to the query.
func (uq *UserQuery) Order(o ...OrderFunc) *UserQuery {
	uq.order = append(uq.order, o...)
	return uq
}

// QueryUserFile chains the current query on the "user_file" edge.
func (uq *UserQuery) QueryUserFile() *FileQuery {
	query := &FileQuery{config: uq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.UserFileTable, user.UserFilePrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryUserArtifact chains the current query on the "user_artifact" edge.
func (uq *UserQuery) QueryUserArtifact() *ArtifactQuery {
	query := &ArtifactQuery{config: uq.config}
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.UserArtifactTable, user.UserArtifactPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first User entity from the query.
// Returns a *NotFoundError when no User was found.
func (uq *UserQuery) First(ctx context.Context) (*User, error) {
	nodes, err := uq.Limit(1).All(ctx)
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{user.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (uq *UserQuery) FirstX(ctx context.Context) *User {
	node, err := uq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first User ID from the query.
// Returns a *NotFoundError when no User ID was found.
func (uq *UserQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = uq.Limit(1).IDs(ctx); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{user.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (uq *UserQuery) FirstIDX(ctx context.Context) uuid.UUID {
	id, err := uq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single User entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one User entity is found.
// Returns a *NotFoundError when no User entities are found.
func (uq *UserQuery) Only(ctx context.Context) (*User, error) {
	nodes, err := uq.Limit(2).All(ctx)
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{user.Label}
	default:
		return nil, &NotSingularError{user.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (uq *UserQuery) OnlyX(ctx context.Context) *User {
	node, err := uq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only User ID in the query.
// Returns a *NotSingularError when more than one User ID is found.
// Returns a *NotFoundError when no entities are found.
func (uq *UserQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = uq.Limit(2).IDs(ctx); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = &NotSingularError{user.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (uq *UserQuery) OnlyIDX(ctx context.Context) uuid.UUID {
	id, err := uq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Users.
func (uq *UserQuery) All(ctx context.Context) ([]*User, error) {
	if err := uq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	return uq.sqlAll(ctx)
}

// AllX is like All, but panics if an error occurs.
func (uq *UserQuery) AllX(ctx context.Context) []*User {
	nodes, err := uq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of User IDs.
func (uq *UserQuery) IDs(ctx context.Context) ([]uuid.UUID, error) {
	var ids []uuid.UUID
	if err := uq.Select(user.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (uq *UserQuery) IDsX(ctx context.Context) []uuid.UUID {
	ids, err := uq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (uq *UserQuery) Count(ctx context.Context) (int, error) {
	if err := uq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return uq.sqlCount(ctx)
}

// CountX is like Count, but panics if an error occurs.
func (uq *UserQuery) CountX(ctx context.Context) int {
	count, err := uq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (uq *UserQuery) Exist(ctx context.Context) (bool, error) {
	if err := uq.prepareQuery(ctx); err != nil {
		return false, err
	}
	return uq.sqlExist(ctx)
}

// ExistX is like Exist, but panics if an error occurs.
func (uq *UserQuery) ExistX(ctx context.Context) bool {
	exist, err := uq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the UserQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (uq *UserQuery) Clone() *UserQuery {
	if uq == nil {
		return nil
	}
	return &UserQuery{
		config:           uq.config,
		limit:            uq.limit,
		offset:           uq.offset,
		order:            append([]OrderFunc{}, uq.order...),
		predicates:       append([]predicate.User{}, uq.predicates...),
		withUserFile:     uq.withUserFile.Clone(),
		withUserArtifact: uq.withUserArtifact.Clone(),
		// clone intermediate query.
		sql:    uq.sql.Clone(),
		path:   uq.path,
		unique: uq.unique,
	}
}

// WithUserFile tells the query-builder to eager-load the nodes that are connected to
// the "user_file" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithUserFile(opts ...func(*FileQuery)) *UserQuery {
	query := &FileQuery{config: uq.config}
	for _, opt := range opts {
		opt(query)
	}
	uq.withUserFile = query
	return uq
}

// WithUserArtifact tells the query-builder to eager-load the nodes that are connected to
// the "user_artifact" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithUserArtifact(opts ...func(*ArtifactQuery)) *UserQuery {
	query := &ArtifactQuery{config: uq.config}
	for _, opt := range opts {
		opt(query)
	}
	uq.withUserArtifact = query
	return uq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		Email string `json:"email,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.User.Query().
//		GroupBy(user.FieldEmail).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
//
func (uq *UserQuery) GroupBy(field string, fields ...string) *UserGroupBy {
	group := &UserGroupBy{config: uq.config}
	group.fields = append([]string{field}, fields...)
	group.path = func(ctx context.Context) (prev *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		return uq.sqlQuery(ctx), nil
	}
	return group
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		Email string `json:"email,omitempty"`
//	}
//
//	client.User.Query().
//		Select(user.FieldEmail).
//		Scan(ctx, &v)
//
func (uq *UserQuery) Select(fields ...string) *UserSelect {
	uq.fields = append(uq.fields, fields...)
	return &UserSelect{UserQuery: uq}
}

func (uq *UserQuery) prepareQuery(ctx context.Context) error {
	for _, f := range uq.fields {
		if !user.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if uq.path != nil {
		prev, err := uq.path(ctx)
		if err != nil {
			return err
		}
		uq.sql = prev
	}
	return nil
}

func (uq *UserQuery) sqlAll(ctx context.Context) ([]*User, error) {
	var (
		nodes       = []*User{}
		_spec       = uq.querySpec()
		loadedTypes = [2]bool{
			uq.withUserFile != nil,
			uq.withUserArtifact != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]interface{}, error) {
		node := &User{config: uq.config}
		nodes = append(nodes, node)
		return node.scanValues(columns)
	}
	_spec.Assign = func(columns []string, values []interface{}) error {
		if len(nodes) == 0 {
			return fmt.Errorf("ent: Assign called without calling ScanValues")
		}
		node := nodes[len(nodes)-1]
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	if err := sqlgraph.QueryNodes(ctx, uq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}

	if query := uq.withUserFile; query != nil {
		fks := make([]driver.Value, 0, len(nodes))
		ids := make(map[uuid.UUID]*User, len(nodes))
		for _, node := range nodes {
			ids[node.ID] = node
			fks = append(fks, node.ID)
			node.Edges.UserFile = []*File{}
		}
		var (
			edgeids []uuid.UUID
			edges   = make(map[uuid.UUID][]*User)
		)
		_spec := &sqlgraph.EdgeQuerySpec{
			Edge: &sqlgraph.EdgeSpec{
				Inverse: false,
				Table:   user.UserFileTable,
				Columns: user.UserFilePrimaryKey,
			},
			Predicate: func(s *sql.Selector) {
				s.Where(sql.InValues(user.UserFilePrimaryKey[0], fks...))
			},
			ScanValues: func() [2]interface{} {
				return [2]interface{}{new(uuid.UUID), new(uuid.UUID)}
			},
			Assign: func(out, in interface{}) error {
				eout, ok := out.(*uuid.UUID)
				if !ok || eout == nil {
					return fmt.Errorf("unexpected id value for edge-out")
				}
				ein, ok := in.(*uuid.UUID)
				if !ok || ein == nil {
					return fmt.Errorf("unexpected id value for edge-in")
				}
				outValue := *eout
				inValue := *ein
				node, ok := ids[outValue]
				if !ok {
					return fmt.Errorf("unexpected node id in edges: %v", outValue)
				}
				if _, ok := edges[inValue]; !ok {
					edgeids = append(edgeids, inValue)
				}
				edges[inValue] = append(edges[inValue], node)
				return nil
			},
		}
		if err := sqlgraph.QueryEdges(ctx, uq.driver, _spec); err != nil {
			return nil, fmt.Errorf(`query edges "user_file": %w`, err)
		}
		query.Where(file.IDIn(edgeids...))
		neighbors, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, n := range neighbors {
			nodes, ok := edges[n.ID]
			if !ok {
				return nil, fmt.Errorf(`unexpected "user_file" node returned %v`, n.ID)
			}
			for i := range nodes {
				nodes[i].Edges.UserFile = append(nodes[i].Edges.UserFile, n)
			}
		}
	}

	if query := uq.withUserArtifact; query != nil {
		fks := make([]driver.Value, 0, len(nodes))
		ids := make(map[uuid.UUID]*User, len(nodes))
		for _, node := range nodes {
			ids[node.ID] = node
			fks = append(fks, node.ID)
			node.Edges.UserArtifact = []*Artifact{}
		}
		var (
			edgeids []uuid.UUID
			edges   = make(map[uuid.UUID][]*User)
		)
		_spec := &sqlgraph.EdgeQuerySpec{
			Edge: &sqlgraph.EdgeSpec{
				Inverse: false,
				Table:   user.UserArtifactTable,
				Columns: user.UserArtifactPrimaryKey,
			},
			Predicate: func(s *sql.Selector) {
				s.Where(sql.InValues(user.UserArtifactPrimaryKey[0], fks...))
			},
			ScanValues: func() [2]interface{} {
				return [2]interface{}{new(uuid.UUID), new(uuid.UUID)}
			},
			Assign: func(out, in interface{}) error {
				eout, ok := out.(*uuid.UUID)
				if !ok || eout == nil {
					return fmt.Errorf("unexpected id value for edge-out")
				}
				ein, ok := in.(*uuid.UUID)
				if !ok || ein == nil {
					return fmt.Errorf("unexpected id value for edge-in")
				}
				outValue := *eout
				inValue := *ein
				node, ok := ids[outValue]
				if !ok {
					return fmt.Errorf("unexpected node id in edges: %v", outValue)
				}
				if _, ok := edges[inValue]; !ok {
					edgeids = append(edgeids, inValue)
				}
				edges[inValue] = append(edges[inValue], node)
				return nil
			},
		}
		if err := sqlgraph.QueryEdges(ctx, uq.driver, _spec); err != nil {
			return nil, fmt.Errorf(`query edges "user_artifact": %w`, err)
		}
		query.Where(artifact.IDIn(edgeids...))
		neighbors, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, n := range neighbors {
			nodes, ok := edges[n.ID]
			if !ok {
				return nil, fmt.Errorf(`unexpected "user_artifact" node returned %v`, n.ID)
			}
			for i := range nodes {
				nodes[i].Edges.UserArtifact = append(nodes[i].Edges.UserArtifact, n)
			}
		}
	}

	return nodes, nil
}

func (uq *UserQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := uq.querySpec()
	_spec.Node.Columns = uq.fields
	if len(uq.fields) > 0 {
		_spec.Unique = uq.unique != nil && *uq.unique
	}
	return sqlgraph.CountNodes(ctx, uq.driver, _spec)
}

func (uq *UserQuery) sqlExist(ctx context.Context) (bool, error) {
	n, err := uq.sqlCount(ctx)
	if err != nil {
		return false, fmt.Errorf("ent: check existence: %w", err)
	}
	return n > 0, nil
}

func (uq *UserQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := &sqlgraph.QuerySpec{
		Node: &sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: user.FieldID,
			},
		},
		From:   uq.sql,
		Unique: true,
	}
	if unique := uq.unique; unique != nil {
		_spec.Unique = *unique
	}
	if fields := uq.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
		for i := range fields {
			if fields[i] != user.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := uq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := uq.limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := uq.offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := uq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (uq *UserQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(uq.driver.Dialect())
	t1 := builder.Table(user.Table)
	columns := uq.fields
	if len(columns) == 0 {
		columns = user.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if uq.sql != nil {
		selector = uq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if uq.unique != nil && *uq.unique {
		selector.Distinct()
	}
	for _, p := range uq.predicates {
		p(selector)
	}
	for _, p := range uq.order {
		p(selector)
	}
	if offset := uq.offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := uq.limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// UserGroupBy is the group-by builder for User entities.
type UserGroupBy struct {
	config
	fields []string
	fns    []AggregateFunc
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Aggregate adds the given aggregation functions to the group-by query.
func (ugb *UserGroupBy) Aggregate(fns ...AggregateFunc) *UserGroupBy {
	ugb.fns = append(ugb.fns, fns...)
	return ugb
}

// Scan applies the group-by query and scans the result into the given value.
func (ugb *UserGroupBy) Scan(ctx context.Context, v interface{}) error {
	query, err := ugb.path(ctx)
	if err != nil {
		return err
	}
	ugb.sql = query
	return ugb.sqlScan(ctx, v)
}

// ScanX is like Scan, but panics if an error occurs.
func (ugb *UserGroupBy) ScanX(ctx context.Context, v interface{}) {
	if err := ugb.Scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from group-by.
// It is only allowed when executing a group-by query with one field.
func (ugb *UserGroupBy) Strings(ctx context.Context) ([]string, error) {
	if len(ugb.fields) > 1 {
		return nil, errors.New("ent: UserGroupBy.Strings is not achievable when grouping more than 1 field")
	}
	var v []string
	if err := ugb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (ugb *UserGroupBy) StringsX(ctx context.Context) []string {
	v, err := ugb.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (ugb *UserGroupBy) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = ugb.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = fmt.Errorf("ent: UserGroupBy.Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (ugb *UserGroupBy) StringX(ctx context.Context) string {
	v, err := ugb.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from group-by.
// It is only allowed when executing a group-by query with one field.
func (ugb *UserGroupBy) Ints(ctx context.Context) ([]int, error) {
	if len(ugb.fields) > 1 {
		return nil, errors.New("ent: UserGroupBy.Ints is not achievable when grouping more than 1 field")
	}
	var v []int
	if err := ugb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (ugb *UserGroupBy) IntsX(ctx context.Context) []int {
	v, err := ugb.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (ugb *UserGroupBy) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = ugb.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = fmt.Errorf("ent: UserGroupBy.Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (ugb *UserGroupBy) IntX(ctx context.Context) int {
	v, err := ugb.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from group-by.
// It is only allowed when executing a group-by query with one field.
func (ugb *UserGroupBy) Float64s(ctx context.Context) ([]float64, error) {
	if len(ugb.fields) > 1 {
		return nil, errors.New("ent: UserGroupBy.Float64s is not achievable when grouping more than 1 field")
	}
	var v []float64
	if err := ugb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (ugb *UserGroupBy) Float64sX(ctx context.Context) []float64 {
	v, err := ugb.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (ugb *UserGroupBy) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = ugb.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = fmt.Errorf("ent: UserGroupBy.Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (ugb *UserGroupBy) Float64X(ctx context.Context) float64 {
	v, err := ugb.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from group-by.
// It is only allowed when executing a group-by query with one field.
func (ugb *UserGroupBy) Bools(ctx context.Context) ([]bool, error) {
	if len(ugb.fields) > 1 {
		return nil, errors.New("ent: UserGroupBy.Bools is not achievable when grouping more than 1 field")
	}
	var v []bool
	if err := ugb.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (ugb *UserGroupBy) BoolsX(ctx context.Context) []bool {
	v, err := ugb.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a group-by query.
// It is only allowed when executing a group-by query with one field.
func (ugb *UserGroupBy) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = ugb.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = fmt.Errorf("ent: UserGroupBy.Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (ugb *UserGroupBy) BoolX(ctx context.Context) bool {
	v, err := ugb.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (ugb *UserGroupBy) sqlScan(ctx context.Context, v interface{}) error {
	for _, f := range ugb.fields {
		if !user.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("invalid field %q for group-by", f)}
		}
	}
	selector := ugb.sqlQuery()
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ugb.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

func (ugb *UserGroupBy) sqlQuery() *sql.Selector {
	selector := ugb.sql.Select()
	aggregation := make([]string, 0, len(ugb.fns))
	for _, fn := range ugb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	// If no columns were selected in a custom aggregation function, the default
	// selection is the fields used for "group-by", and the aggregation functions.
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(ugb.fields)+len(ugb.fns))
		for _, f := range ugb.fields {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	return selector.GroupBy(selector.Columns(ugb.fields...)...)
}

// UserSelect is the builder for selecting fields of User entities.
type UserSelect struct {
	*UserQuery
	// intermediate query (i.e. traversal path).
	sql *sql.Selector
}

// Scan applies the selector query and scans the result into the given value.
func (us *UserSelect) Scan(ctx context.Context, v interface{}) error {
	if err := us.prepareQuery(ctx); err != nil {
		return err
	}
	us.sql = us.UserQuery.sqlQuery(ctx)
	return us.sqlScan(ctx, v)
}

// ScanX is like Scan, but panics if an error occurs.
func (us *UserSelect) ScanX(ctx context.Context, v interface{}) {
	if err := us.Scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (us *UserSelect) Strings(ctx context.Context) ([]string, error) {
	if len(us.fields) > 1 {
		return nil, errors.New("ent: UserSelect.Strings is not achievable when selecting more than 1 field")
	}
	var v []string
	if err := us.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (us *UserSelect) StringsX(ctx context.Context) []string {
	v, err := us.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (us *UserSelect) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = us.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = fmt.Errorf("ent: UserSelect.Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (us *UserSelect) StringX(ctx context.Context) string {
	v, err := us.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (us *UserSelect) Ints(ctx context.Context) ([]int, error) {
	if len(us.fields) > 1 {
		return nil, errors.New("ent: UserSelect.Ints is not achievable when selecting more than 1 field")
	}
	var v []int
	if err := us.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (us *UserSelect) IntsX(ctx context.Context) []int {
	v, err := us.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (us *UserSelect) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = us.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = fmt.Errorf("ent: UserSelect.Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (us *UserSelect) IntX(ctx context.Context) int {
	v, err := us.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (us *UserSelect) Float64s(ctx context.Context) ([]float64, error) {
	if len(us.fields) > 1 {
		return nil, errors.New("ent: UserSelect.Float64s is not achievable when selecting more than 1 field")
	}
	var v []float64
	if err := us.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (us *UserSelect) Float64sX(ctx context.Context) []float64 {
	v, err := us.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (us *UserSelect) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = us.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = fmt.Errorf("ent: UserSelect.Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (us *UserSelect) Float64X(ctx context.Context) float64 {
	v, err := us.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (us *UserSelect) Bools(ctx context.Context) ([]bool, error) {
	if len(us.fields) > 1 {
		return nil, errors.New("ent: UserSelect.Bools is not achievable when selecting more than 1 field")
	}
	var v []bool
	if err := us.Scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (us *UserSelect) BoolsX(ctx context.Context) []bool {
	v, err := us.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (us *UserSelect) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = us.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = fmt.Errorf("ent: UserSelect.Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (us *UserSelect) BoolX(ctx context.Context) bool {
	v, err := us.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (us *UserSelect) sqlScan(ctx context.Context, v interface{}) error {
	rows := &sql.Rows{}
	query, args := us.sql.Query()
	if err := us.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

```

`app/bugu/service/internal/data/ent/user_update.go`:

```go
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/predicate"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

// UserUpdate is the builder for updating User entities.
type UserUpdate struct {
	config
	hooks    []Hook
	mutation *UserMutation
}

// Where appends a list predicates to the UserUpdate builder.
func (uu *UserUpdate) Where(ps ...predicate.User) *UserUpdate {
	uu.mutation.Where(ps...)
	return uu
}

// SetEmail sets the "email" field.
func (uu *UserUpdate) SetEmail(s string) *UserUpdate {
	uu.mutation.SetEmail(s)
	return uu
}

// SetUsername sets the "username" field.
func (uu *UserUpdate) SetUsername(s string) *UserUpdate {
	uu.mutation.SetUsername(s)
	return uu
}

// SetPasswordHash sets the "password_hash" field.
func (uu *UserUpdate) SetPasswordHash(s string) *UserUpdate {
	uu.mutation.SetPasswordHash(s)
	return uu
}

// SetUpdatedAt sets the "updated_at" field.
func (uu *UserUpdate) SetUpdatedAt(t time.Time) *UserUpdate {
	uu.mutation.SetUpdatedAt(t)
	return uu
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (uu *UserUpdate) SetNillableUpdatedAt(t *time.Time) *UserUpdate {
	if t != nil {
		uu.SetUpdatedAt(*t)
	}
	return uu
}

// AddUserFileIDs adds the "user_file" edge to the File entity by IDs.
func (uu *UserUpdate) AddUserFileIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.AddUserFileIDs(ids...)
	return uu
}

// AddUserFile adds the "user_file" edges to the File entity.
func (uu *UserUpdate) AddUserFile(f ...*File) *UserUpdate {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uu.AddUserFileIDs(ids...)
}

// AddUserArtifactIDs adds the "user_artifact" edge to the Artifact entity by IDs.
func (uu *UserUpdate) AddUserArtifactIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.AddUserArtifactIDs(ids...)
	return uu
}

// AddUserArtifact adds the "user_artifact" edges to the Artifact entity.
func (uu *UserUpdate) AddUserArtifact(a ...*Artifact) *UserUpdate {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uu.AddUserArtifactIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uu *UserUpdate) Mutation() *UserMutation {
	return uu.mutation
}

// ClearUserFile clears all "user_file" edges to the File entity.
func (uu *UserUpdate) ClearUserFile() *UserUpdate {
	uu.mutation.ClearUserFile()
	return uu
}

// RemoveUserFileIDs removes the "user_file" edge to File entities by IDs.
func (uu *UserUpdate) RemoveUserFileIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.RemoveUserFileIDs(ids...)
	return uu
}

// RemoveUserFile removes "user_file" edges to File entities.
func (uu *UserUpdate) RemoveUserFile(f ...*File) *UserUpdate {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uu.RemoveUserFileIDs(ids...)
}

// ClearUserArtifact clears all "user_artifact" edges to the Artifact entity.
func (uu *UserUpdate) ClearUserArtifact() *UserUpdate {
	uu.mutation.ClearUserArtifact()
	return uu
}

// RemoveUserArtifactIDs removes the "user_artifact" edge to Artifact entities by IDs.
func (uu *UserUpdate) RemoveUserArtifactIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.RemoveUserArtifactIDs(ids...)
	return uu
}

// RemoveUserArtifact removes "user_artifact" edges to Artifact entities.
func (uu *UserUpdate) RemoveUserArtifact(a ...*Artifact) *UserUpdate {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uu.RemoveUserArtifactIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (uu *UserUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if len(uu.hooks) == 0 {
		affected, err = uu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*UserMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			uu.mutation = mutation
			affected, err = uu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(uu.hooks) - 1; i >= 0; i-- {
			if uu.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = uu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, uu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (uu *UserUpdate) SaveX(ctx context.Context) int {
	affected, err := uu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (uu *UserUpdate) Exec(ctx context.Context) error {
	_, err := uu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uu *UserUpdate) ExecX(ctx context.Context) {
	if err := uu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (uu *UserUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: user.FieldID,
			},
		},
	}
	if ps := uu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := uu.mutation.Email(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldEmail,
		})
	}
	if value, ok := uu.mutation.Username(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldUsername,
		})
	}
	if value, ok := uu.mutation.PasswordHash(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldPasswordHash,
		})
	}
	if value, ok := uu.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: user.FieldUpdatedAt,
		})
	}
	if uu.mutation.UserFileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserFileTable,
			Columns: user.UserFilePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedUserFileIDs(); len(nodes) > 0 && !uu.mutation.UserFileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserFileTable,
			Columns: user.UserFilePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.UserFileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserFileTable,
			Columns: user.UserFilePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.UserArtifactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserArtifactTable,
			Columns: user.UserArtifactPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedUserArtifactIDs(); len(nodes) > 0 && !uu.mutation.UserArtifactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserArtifactTable,
			Columns: user.UserArtifactPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.UserArtifactIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserArtifactTable,
			Columns: user.UserArtifactPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, uu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return 0, err
	}
	return n, nil
}

// UserUpdateOne is the builder for updating a single User entity.
type UserUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *UserMutation
}

// SetEmail sets the "email" field.
func (uuo *UserUpdateOne) SetEmail(s string) *UserUpdateOne {
	uuo.mutation.SetEmail(s)
	return uuo
}

// SetUsername sets the "username" field.
func (uuo *UserUpdateOne) SetUsername(s string) *UserUpdateOne {
	uuo.mutation.SetUsername(s)
	return uuo
}

// SetPasswordHash sets the "password_hash" field.
func (uuo *UserUpdateOne) SetPasswordHash(s string) *UserUpdateOne {
	uuo.mutation.SetPasswordHash(s)
	return uuo
}

// SetUpdatedAt sets the "updated_at" field.
func (uuo *UserUpdateOne) SetUpdatedAt(t time.Time) *UserUpdateOne {
	uuo.mutation.SetUpdatedAt(t)
	return uuo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableUpdatedAt(t *time.Time) *UserUpdateOne {
	if t != nil {
		uuo.SetUpdatedAt(*t)
	}
	return uuo
}

// AddUserFileIDs adds the "user_file" edge to the File entity by IDs.
func (uuo *UserUpdateOne) AddUserFileIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.AddUserFileIDs(ids...)
	return uuo
}

// AddUserFile adds the "user_file" edges to the File entity.
func (uuo *UserUpdateOne) AddUserFile(f ...*File) *UserUpdateOne {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uuo.AddUserFileIDs(ids...)
}

// AddUserArtifactIDs adds the "user_artifact" edge to the Artifact entity by IDs.
func (uuo *UserUpdateOne) AddUserArtifactIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.AddUserArtifactIDs(ids...)
	return uuo
}

// AddUserArtifact adds the "user_artifact" edges to the Artifact entity.
func (uuo *UserUpdateOne) AddUserArtifact(a ...*Artifact) *UserUpdateOne {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uuo.AddUserArtifactIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uuo *UserUpdateOne) Mutation() *UserMutation {
	return uuo.mutation
}

// ClearUserFile clears all "user_file" edges to the File entity.
func (uuo *UserUpdateOne) ClearUserFile() *UserUpdateOne {
	uuo.mutation.ClearUserFile()
	return uuo
}

// RemoveUserFileIDs removes the "user_file" edge to File entities by IDs.
func (uuo *UserUpdateOne) RemoveUserFileIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.RemoveUserFileIDs(ids...)
	return uuo
}

// RemoveUserFile removes "user_file" edges to File entities.
func (uuo *UserUpdateOne) RemoveUserFile(f ...*File) *UserUpdateOne {
	ids := make([]uuid.UUID, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uuo.RemoveUserFileIDs(ids...)
}

// ClearUserArtifact clears all "user_artifact" edges to the Artifact entity.
func (uuo *UserUpdateOne) ClearUserArtifact() *UserUpdateOne {
	uuo.mutation.ClearUserArtifact()
	return uuo
}

// RemoveUserArtifactIDs removes the "user_artifact" edge to Artifact entities by IDs.
func (uuo *UserUpdateOne) RemoveUserArtifactIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.RemoveUserArtifactIDs(ids...)
	return uuo
}

// RemoveUserArtifact removes "user_artifact" edges to Artifact entities.
func (uuo *UserUpdateOne) RemoveUserArtifact(a ...*Artifact) *UserUpdateOne {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uuo.RemoveUserArtifactIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (uuo *UserUpdateOne) Select(field string, fields ...string) *UserUpdateOne {
	uuo.fields = append([]string{field}, fields...)
	return uuo
}

// Save executes the query and returns the updated User entity.
func (uuo *UserUpdateOne) Save(ctx context.Context) (*User, error) {
	var (
		err  error
		node *User
	)
	if len(uuo.hooks) == 0 {
		node, err = uuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*UserMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			uuo.mutation = mutation
			node, err = uuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(uuo.hooks) - 1; i >= 0; i-- {
			if uuo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = uuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, uuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (uuo *UserUpdateOne) SaveX(ctx context.Context) *User {
	node, err := uuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (uuo *UserUpdateOne) Exec(ctx context.Context) error {
	_, err := uuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uuo *UserUpdateOne) ExecX(ctx context.Context) {
	if err := uuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (uuo *UserUpdateOne) sqlSave(ctx context.Context) (_node *User, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: user.FieldID,
			},
		},
	}
	id, ok := uuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "User.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := uuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
		for _, f := range fields {
			if !user.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != user.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := uuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := uuo.mutation.Email(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldEmail,
		})
	}
	if value, ok := uuo.mutation.Username(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldUsername,
		})
	}
	if value, ok := uuo.mutation.PasswordHash(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: user.FieldPasswordHash,
		})
	}
	if value, ok := uuo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: user.FieldUpdatedAt,
		})
	}
	if uuo.mutation.UserFileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserFileTable,
			Columns: user.UserFilePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedUserFileIDs(); len(nodes) > 0 && !uuo.mutation.UserFileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserFileTable,
			Columns: user.UserFilePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.UserFileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserFileTable,
			Columns: user.UserFilePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: file.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.UserArtifactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserArtifactTable,
			Columns: user.UserArtifactPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedUserArtifactIDs(); len(nodes) > 0 && !uuo.mutation.UserArtifactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserArtifactTable,
			Columns: user.UserArtifactPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.UserArtifactIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.UserArtifactTable,
			Columns: user.UserArtifactPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: artifact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &User{config: uuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, uuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{err.Error(), err}
		}
		return nil, err
	}
	return _node, nil
}

```

`app/bugu/service/internal/data/file.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package data

import (
	"context"

	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/artifact"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/google/uuid"
	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/biz"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/file"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"
)

var _ biz.FileRepo = (*fileRepo)(nil)

type fileRepo struct {
	data *Data
	log  *log.Helper
}

// NewFileRepo .
func NewFileRepo(data *Data, logger log.Logger) biz.FileRepo {
	return &fileRepo{
		data: data,
		log:  log.NewHelper(log.With(logger, "module", "data/file")),
	}
}

func (r *fileRepo) CreateFileMetadata(ctx context.Context, userId uuid.UUID, f *biz.File) (*biz.File, bool, error) {
	ok := false
	po, err := r.data.db.File.Create().
		SetID(f.ID).
		SetFileSha1(f.FileSha1).
		SetFileSize(f.FileSize).
		SetFileAddr(f.FileAddr).
		AddAffiliatedUserIDs(userId).
		Save(ctx)
	if err != nil && ent.IsConstraintError(err) {
		err = r.data.db.File.Update().
			Where(file.FileSha1EQ(f.FileSha1)).
			AddAffiliatedUserIDs(userId).
			Exec(ctx)
		if err != nil && ent.IsConstraintError(err) {
			return nil, false, buguV1.ErrorCreateConflict("create conflict, err: %v", err)
		}
		po, err = r.data.db.File.Query().
			Where(file.FileSha1EQ(f.FileSha1)).
			Only(ctx)
		ok = true
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, false, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.File{
		ID:       po.ID,
		FileSha1: po.FileSha1,
		FileSize: po.FileSize,
		FileAddr: po.FileAddr,
		Type:     &po.Type,
	}, ok, nil
}

func (r *fileRepo) UpdateFileMetadata(ctx context.Context, file *biz.File) (*biz.File, error) {
	po, err := r.data.db.File.UpdateOneID(file.ID).
		SetFileSize(file.FileSize).
		SetFileAddr(file.FileAddr).
		SetNillableType(file.Type).
		Save(ctx)
	if err != nil && ent.IsConstraintError(err) {
		return nil, buguV1.ErrorCreateConflict("update conflict, err: %v", err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.File{
		ID:       po.ID,
		FileSha1: po.FileSha1,
		FileSize: po.FileSize,
		FileAddr: po.FileAddr,
		Type:     &po.Type,
	}, nil
}

func (r *fileRepo) AppendFileMetadataToUser(ctx context.Context, userId, fileId uuid.UUID) (*biz.File, error) {
	po, err := r.data.db.File.UpdateOneID(fileId).
		AddAffiliatedUserIDs(userId).
		Save(ctx)
	if err != nil && ent.IsConstraintError(err) {
		return nil, buguV1.ErrorCreateConflict("update conflict, err: %v", err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.File{
		ID:       po.ID,
		FileSha1: po.FileSha1,
		FileSize: po.FileSize,
		FileAddr: po.FileAddr,
		Type:     &po.Type,
	}, nil
}

func (r *fileRepo) GetFileMetadata(ctx context.Context, userId, fileId uuid.UUID) (*biz.File, error) {
	target, err := r.data.db.File.Query().
		Where(file.And(
			file.HasAffiliatedUserWith(user.IDEQ(userId)),
			file.IDEQ(fileId),
		)).
		Only(ctx)
	if err != nil && ent.IsNotFound(err) {
		return nil, buguV1.ErrorNotFoundError("find fileId: %s not found, err: %v", fileId.String(), err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.File{
		ID:       target.ID,
		FileSha1: target.FileSha1,
		FileSize: target.FileSize,
		FileAddr: target.FileAddr,
		Type:     &target.Type,
	}, nil
}

func (r *fileRepo) GetFileMetadataByUserId(ctx context.Context, userId uuid.UUID) ([]*biz.File, error) {
	targets, err := r.data.db.File.Query().
		Where(file.And(
			file.HasAffiliatedUserWith(user.IDEQ(userId)),
		)).
		All(ctx)
	if err != nil && ent.IsNotFound(err) {
		return nil, buguV1.ErrorNotFoundError("find userId: %s not found, err: %v", userId.String(), err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	var rets []*biz.File
	for _, target := range targets {
		rets = append(rets, &biz.File{
			ID:       target.ID,
			FileSha1: target.FileSha1,
			FileSize: target.FileSize,
			FileAddr: target.FileAddr,
			Type:     &target.Type,
		})
	}

	return rets, nil
}

func (r *fileRepo) DeleteFileMetadata(ctx context.Context, userId, fileId uuid.UUID) error {
	err := r.data.db.File.UpdateOneID(fileId).
		RemoveAffiliatedUserIDs(userId).
		Exec(ctx)
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	err = r.data.db.Artifact.Update().
		Where(artifact.And(
			artifact.AffiliatedFileID(fileId),
			artifact.HasAffiliatedUserWith(user.IDEQ(userId)),
		)).
		RemoveAffiliatedUserIDs(userId).
		Exec(ctx)
	if err != nil && !ent.IsNotFound(err) {
		r.log.Errorf("unknown err: %v", err)
		return buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return nil
}

func (r *fileRepo) QueryByFileSha1(ctx context.Context, sha1 string) (*biz.File, error) {
	po, err := r.data.db.File.Query().
		Where(file.FileSha1EQ(sha1)).
		Only(ctx)
	if err != nil && ent.IsNotFound(err) {
		return nil, buguV1.ErrorNotFoundError("find sha1: %s not found, err: %v", sha1, err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.File{
		ID:       po.ID,
		FileSha1: po.FileSha1,
		FileSize: po.FileSize,
		FileAddr: po.FileAddr,
		Type:     &po.Type,
	}, nil
}

```

`app/bugu/service/internal/data/obfusion.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package data

import (
	"context"

	obfusionV1 "github.com/hominsu/bugu/api/obfusion/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/biz"

	"github.com/go-kratos/kratos/v2/log"
)

var _ biz.ObfusionRepo = (*obfusionRepo)(nil)

type obfusionRepo struct {
	data *Data
	log  *log.Helper
}

// NewObfusionRepo .
func NewObfusionRepo(data *Data, logger log.Logger) biz.ObfusionRepo {
	return &obfusionRepo{
		data: data,
		log:  log.NewHelper(log.With(logger, "module", "data/file")),
	}
}

func (r *obfusionRepo) Obfusion(ctx context.Context, data *biz.Obfusion) (*biz.Obfusion, error) {
	reply, err := r.data.oc.Obfusion(ctx, &obfusionV1.ObfusionRequest{
		Data: [][]byte{data.Data},
		Size: data.Size,
	})
	if err != nil {
		return nil, err
	}

	rd := []byte{}
	for _, datum := range reply.Data {
		rd = append(rd, datum...)
	}

	return &biz.Obfusion{
		Data: rd,
		Size: reply.Size,
	}, nil
}

```

`app/bugu/service/internal/data/packer.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package data

import (
	"context"

	"github.com/go-kratos/kratos/v2/log"
	packerV1 "github.com/hominsu/bugu/api/packer/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/biz"
)

var _ biz.PackerRepo = (*packerRepo)(nil)

type packerRepo struct {
	data *Data
	log  *log.Helper
}

// NewPackerRepo .
func NewPackerRepo(data *Data, logger log.Logger) biz.PackerRepo {
	return &packerRepo{
		data: data,
		log:  log.NewHelper(log.With(logger, "module", "data/file")),
	}
}

func (r *packerRepo) Packer(ctx context.Context, data *biz.Packer) (*biz.Packer, error) {
	reply, err := r.data.pc.Packer(ctx, &packerV1.PackerRequest{
		Data: [][]byte{data.Data},
		Size: data.Size,
	})
	if err != nil {
		return nil, err
	}

	rd := []byte{}
	for _, datum := range reply.Data {
		rd = append(rd, datum...)
	}

	return &biz.Packer{
		Data: rd,
		Size: reply.Size,
	}, nil
}

```

`app/bugu/service/internal/data/user.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package data

import (
	"context"
	"time"

	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/biz"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent"
	"github.com/hominsu/bugu/app/bugu/service/internal/data/ent/user"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/google/uuid"
)

var _ biz.UserRepo = (*userRepo)(nil)

type userRepo struct {
	data *Data
	log  *log.Helper
}

// NewUserRepo .
func NewUserRepo(data *Data, logger log.Logger) biz.UserRepo {
	return &userRepo{
		data: data,
		log:  log.NewHelper(log.With(logger, "module", "data/user")),
	}
}

func (r *userRepo) CreateUser(ctx context.Context, user *biz.User) (*biz.User, error) {
	u, err := uuid.NewRandom()
	if err != nil {
		return nil, buguV1.ErrorUuidGenerateFailed("create follow uuid failed, err: %v", err)
	}

	po, err := r.data.db.User.Create().
		SetID(u).
		SetEmail(user.Email).
		SetUsername(user.Username).
		SetPasswordHash(user.PasswordHash).
		Save(ctx)
	if err != nil && ent.IsConstraintError(err) {
		return nil, buguV1.ErrorCreateConflict("create conflict, err: %v", err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.User{
		ID:           po.ID,
		Email:        po.Email,
		Username:     po.Username,
		PasswordHash: po.PasswordHash,
	}, nil
}

func (r *userRepo) UpdateUser(ctx context.Context, user *biz.User) (*biz.User, error) {
	po, err := r.data.db.User.UpdateOneID(user.ID).
		SetUsername(user.Username).
		SetPasswordHash(user.PasswordHash).
		SetUpdatedAt(time.Now()).
		Save(ctx)
	if err != nil && ent.IsConstraintError(err) {
		return nil, buguV1.ErrorCreateConflict("update conflict, err: %v", err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.User{
		ID:           po.ID,
		Email:        po.Email,
		Username:     po.Username,
		PasswordHash: po.PasswordHash,
	}, nil
}

func (r *userRepo) GetUserByID(ctx context.Context, id uuid.UUID) (*biz.User, error) {
	po, err := r.data.db.User.Get(ctx, id)
	if err != nil && ent.IsNotFound(err) {
		return nil, buguV1.ErrorNotFoundError("find user id: %s not found, err: %v", id.String(), err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.User{
		ID:           po.ID,
		Email:        po.Email,
		Username:     po.Username,
		PasswordHash: po.PasswordHash,
	}, nil
}

func (r *userRepo) FineUserByEmail(ctx context.Context, email string) (*biz.User, error) {
	target, err := r.data.db.User.Query().
		Where(user.EmailEQ(email)).
		Only(ctx)
	if err != nil && ent.IsNotFound(err) {
		return nil, buguV1.ErrorNotFoundError("find user email: %s not found, err: %v", email, err)
	}
	if err != nil {
		r.log.Errorf("unknown err: %v", err)
		return nil, buguV1.ErrorUnknownError("unknown err: %v", err)
	}

	return &biz.User{
		ID:           target.ID,
		Email:        target.Email,
		Username:     target.Username,
		PasswordHash: target.PasswordHash,
	}, nil
}

```

`app/bugu/service/internal/pkg/http/error/error.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package pkg

import (
	"fmt"
	nethttp "net/http"

	"github.com/go-kratos/kratos/v2/errors"
	"github.com/go-kratos/kratos/v2/transport/http"
)

// HTTPError is an HTTP error.
type HTTPError struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

func (e *HTTPError) Error() string {
	return fmt.Sprintf("HTTPError code: %d message: %s", e.Code, e.Message)
}

// FromError try to convert an error to *HTTPError.
func FromError(err error) *HTTPError {
	if err == nil {
		return nil
	}
	if se := new(HTTPError); errors.As(err, &se) {
		return se
	}
	return &HTTPError{Code: 500}
}

func ErrorEncoder(w nethttp.ResponseWriter, r *nethttp.Request, err error) {
	se := FromError(err)
	codec, _ := http.CodecForRequest(r, "Accept")
	body, err := codec.Marshal(se)
	if err != nil {
		w.WriteHeader(500)
		return
	}
	w.Header().Set("Content-Type", "application/"+codec.Name())
	w.WriteHeader(se.Code)
	_, _ = w.Write(body)
}

```

`app/bugu/service/internal/pkg/middleware/auth/auth.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package auth

import (
	"context"
	nethttp "net/http"
	"strings"
	"time"

	pkg "github.com/hominsu/bugu/app/bugu/service/internal/pkg/http/error"

	"github.com/go-kratos/kratos/v2/errors"
	"github.com/go-kratos/kratos/v2/metadata"
	"github.com/go-kratos/kratos/v2/middleware"
	"github.com/go-kratos/kratos/v2/transport"
	"github.com/golang-jwt/jwt/v4"
)

const (

	// bearerWord the bearer key word for authorization
	bearerWord string = "Token"

	// authorizationKey holds the key used to store the JWT Token in the request tokenHeader.
	authorizationKey string = "Authorization"

	// reason holds the error reason.
	reason string = "UNAUTHORIZED"
)

var (
	ErrMissingJwtToken        = errors.Unauthorized(reason, "JWT token is missing")
	ErrMissingKeyFunc         = errors.Unauthorized(reason, "keyFunc is missing")
	ErrTokenInvalid           = errors.Unauthorized(reason, "Token is invalid")
	ErrTokenExpired           = errors.Unauthorized(reason, "JWT token has expired")
	ErrTokenParseFail         = errors.Unauthorized(reason, "Fail to parse JWT token")
	ErrUnSupportSigningMethod = errors.Unauthorized(reason, "Wrong signing method")
	ErrWrongContext           = errors.Unauthorized(reason, "Wrong context for middleware")
	ErrNeedTokenProvider      = errors.Unauthorized(reason, "Token provider is missing")
	ErrSignToken              = errors.Unauthorized(reason, "Can not sign token.Is the key correct?")
	ErrGetKey                 = errors.Unauthorized(reason, "Can not get key while signing token")
)

type Claims struct {
	UserID string
	jwt.RegisteredClaims
}

func GenerateToken(secret, userid string) (string, error) {
	expireTime := jwt.NewNumericDate(time.Now().Add(time.Hour * 24 * 30))
	claims := &Claims{
		UserID: userid,
		RegisteredClaims: jwt.RegisteredClaims{
			Issuer:    "bugu.cn",
			Subject:   "bugu user token",
			ExpiresAt: expireTime,
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString([]byte(secret))
	if err != nil {
		panic(err)
	}

	return tokenString, nil
}

func JwtAuthServiceMiddleware(secret string) middleware.Middleware {
	return func(handler middleware.Handler) middleware.Handler {
		return func(ctx context.Context, req interface{}) (interface{}, error) {
			if header, ok := transport.FromServerContext(ctx); ok {
				jwtToken, err := getJwtTokenFromTrans(header)
				if err != nil {
					return nil, err
				}

				claims := &Claims{}
				tokenInfo, err := jwt.ParseWithClaims(jwtToken, claims, func(token *jwt.Token) (interface{}, error) {
					if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
						return nil, ErrUnSupportSigningMethod
					}
					return []byte(secret), nil
				})
				if err != nil {
					if ve, ok := err.(*jwt.ValidationError); ok {
						if ve.Errors&jwt.ValidationErrorMalformed != 0 {
							return nil, ErrTokenInvalid
						} else if ve.Errors&(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 {
							return nil, ErrTokenExpired
						} else {
							return nil, ErrTokenParseFail
						}
					}
					return nil, errors.Unauthorized(reason, err.Error())
				} else if !tokenInfo.Valid {
					return nil, ErrTokenInvalid
				}

				// append the userid to ctx for next service
				ctx = metadata.AppendToClientContext(ctx, "x-md-global-userid", claims.UserID)
			}
			return handler(ctx, req)
		}
	}
}

func getJwtTokenFromTrans(tr transport.Transporter) (string, error) {
	auths := strings.SplitN(tr.RequestHeader().Get(authorizationKey), " ", 2)
	if len(auths) != 2 || !strings.EqualFold(auths[0], bearerWord) {
		return "", ErrMissingJwtToken
	}
	return auths[1], nil
}

func JwtAuthRouteFilter(secret string) func(nethttp.Handler) nethttp.Handler {
	return func(next nethttp.Handler) nethttp.Handler {
		return nethttp.HandlerFunc(func(w nethttp.ResponseWriter, r *nethttp.Request) {
			jwtToken, err := getJwtTokenFromReq(r)
			if err != nil {
				pkg.ErrorEncoder(w, r, &pkg.HTTPError{Code: 401, Message: "JWT token is missing"})
				return
			}

			claims := &Claims{}
			tokenInfo, err := jwt.ParseWithClaims(jwtToken, claims, func(token *jwt.Token) (interface{}, error) {
				if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
					return nil, ErrUnSupportSigningMethod
				}
				return []byte(secret), nil
			})
			if err != nil {
				if ve, ok := err.(*jwt.ValidationError); ok {
					if ve.Errors&jwt.ValidationErrorMalformed != 0 {
						pkg.ErrorEncoder(w, r, &pkg.HTTPError{Code: 401, Message: "Token is invalid"})
						return
					} else if ve.Errors&(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 {
						pkg.ErrorEncoder(w, r, &pkg.HTTPError{Code: 401, Message: "JWT token has expired"})
						return
					} else {
						pkg.ErrorEncoder(w, r, &pkg.HTTPError{Code: 401, Message: "Fail to parse JWT token"})
						return
					}
				}
				pkg.ErrorEncoder(w, r, &pkg.HTTPError{Code: 401, Message: err.Error()})
				return
			} else if !tokenInfo.Valid {
				pkg.ErrorEncoder(w, r, &pkg.HTTPError{Code: 401, Message: "Token is invalid"})
			}

			// append the userid to ctx for next service
			r.Header.Set("x-md-global-userid", claims.UserID)

			next.ServeHTTP(w, r)
		})
	}
}

func getJwtTokenFromReq(r *nethttp.Request) (string, error) {
	auths := strings.SplitN(r.Header.Get(authorizationKey), " ", 2)
	if len(auths) != 2 || !strings.EqualFold(auths[0], bearerWord) {
		return "", ErrMissingJwtToken
	}
	return auths[1], nil
}

```

`app/bugu/service/internal/server/http.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package server

import (
	"context"

	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
	"github.com/hominsu/bugu/app/bugu/service/internal/pkg/middleware/auth"
	"github.com/hominsu/bugu/app/bugu/service/internal/service"

	"github.com/go-kratos/kratos/v2/log"
	"github.com/go-kratos/kratos/v2/middleware/logging"
	"github.com/go-kratos/kratos/v2/middleware/ratelimit"
	"github.com/go-kratos/kratos/v2/middleware/recovery"
	"github.com/go-kratos/kratos/v2/middleware/selector"
	"github.com/go-kratos/kratos/v2/middleware/validate"
	"github.com/go-kratos/kratos/v2/transport/http"
	"github.com/gorilla/handlers"
)

func NewSkipRoutersMatcher() selector.MatchFunc {
	skipList := make(map[string]struct{})
	skipList["/bugu.service.v1.Bugu/Login"] = struct{}{}
	skipList["/bugu.service.v1.Bugu/Register"] = struct{}{}

	return func(ctx context.Context, operation string) bool {
		if _, ok := skipList[operation]; ok {
			return false
		}
		return true
	}
}

// NewHTTPServer new an HTTP server.
func NewHTTPServer(
	c *conf.Server,
	sc *conf.Jwt,
	bs *service.BuguService,
	bfs *service.BuguFileService,
	logger log.Logger,
) *http.Server {
	opts := []http.ServerOption{
		http.Middleware(
			recovery.Recovery(),
			logging.Server(logger),
			ratelimit.Server(),
			selector.Server(
				auth.JwtAuthServiceMiddleware(sc.GetSecret()),
			).Match(NewSkipRoutersMatcher()).
				Build(),
			validate.Validator(),
		),
		http.Filter(
			handlers.CORS(
				handlers.AllowedHeaders([]string{"X-Requested-With", "Content-Type", "Authorization"}),
				handlers.AllowedMethods([]string{"GET", "POST", "PUT", "HEAD", "OPTIONS"}),
				handlers.AllowedOrigins([]string{"*"}),
			),
		),
	}
	if c.Http.Network != "" {
		opts = append(opts, http.Network(c.Http.Network))
	}
	if c.Http.Addr != "" {
		opts = append(opts, http.Address(c.Http.Addr))
	}
	if c.Http.Timeout != nil {
		opts = append(opts, http.Timeout(c.Http.Timeout.AsDuration()))
	}
	srv := http.NewServer(opts...)

	buguV1.RegisterBuguHTTPServer(srv, bs)
	buguV1.RegisterBuguFileHTTPServer(srv, bfs,
		auth.JwtAuthRouteFilter(sc.GetSecret()),
	)

	return srv
}

```

`app/bugu/service/internal/server/server.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package server

import (
	"github.com/go-kratos/kratos/contrib/registry/consul/v2"
	"github.com/go-kratos/kratos/v2/registry"
	"github.com/google/wire"
	consulAPI "github.com/hashicorp/consul/api"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
)

// ProviderSet is server providers.
var ProviderSet = wire.NewSet(NewHTTPServer, NewRegistrar)

func NewRegistrar(conf *conf.Registry) registry.Registrar {
	c := consulAPI.DefaultConfig()
	c.Address = conf.Consul.Address
	c.Scheme = conf.Consul.Scheme

	cli, err := consulAPI.NewClient(c)
	if err != nil {
		panic(err)
	}

	r := consul.New(
		cli,
		consul.WithHealthCheck(true),
		consul.WithHeartbeat(true),
	)

	return r
}

```

`app/bugu/service/internal/service/artifact.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package service

import (
	"context"

	"github.com/go-kratos/kratos/v2/errors"
	"github.com/go-kratos/kratos/v2/metadata"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
)

func (s *BuguService) Confusion(ctx context.Context, in *buguV1.ConfusionRequest) (*buguV1.ConfusionReply, error) {
	userId := in.GetUserId()

	md, ok := metadata.FromClientContext(ctx)
	if !ok {
		return nil, buguV1.ErrorInternalServerError("Openid does not exist in context")
	}
	if md.Get("x-md-global-userid") != userId {
		return nil, errors.Unauthorized("UNAUTHORIZED", "userid is inconsistent")
	}

	fileId := in.GetFileId()

	dto, err := s.au.Confusion(ctx, userId, fileId)
	if err != nil {
		return nil, err
	}

	return &buguV1.ConfusionReply{
		ArtifactId:       dto.ID.String(),
		FileId:           dto.FileID.String(),
		AffiliatedFileId: dto.AffiliatedFileID.String(),
		Method:           dto.Method,
	}, nil
}

func (s *BuguService) Detect(ctx context.Context, in *buguV1.DetectRequest) (*buguV1.DetectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detect not implemented")
}

func (s *BuguService) Packer(ctx context.Context, in *buguV1.PackerRequest) (*buguV1.PackerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Packer not implemented")
}

func (s *BuguService) GetArtifactMetadata(ctx context.Context, in *buguV1.GetArtifactMetadataRequest) (*buguV1.GetArtifactMetadataReply, error) {
	userId := in.GetUserId()

	md, ok := metadata.FromClientContext(ctx)
	if !ok {
		return nil, buguV1.ErrorInternalServerError("Openid does not exist in context")
	}
	if md.Get("x-md-global-userid") != userId {
		return nil, errors.Unauthorized("UNAUTHORIZED", "userid is inconsistent")
	}

	artifactId := in.GetArtifactId()

	dto, err := s.au.GetArtifactMetadata(ctx, userId, artifactId)
	if err != nil {
		return nil, err
	}

	return &buguV1.GetArtifactMetadataReply{
		ArtifactId:       dto.ID.String(),
		FileId:           dto.FileID.String(),
		AffiliatedFileId: dto.AffiliatedFileID.String(),
		Method:           dto.Method,
	}, nil
}

func (s *BuguService) GetArtifactMetadataByFileId(ctx context.Context, in *buguV1.GetArtifactMetadataByFileIdRequest) (*buguV1.GetArtifactMetadataByFileIdReply, error) {
	userId := in.GetUserId()

	md, ok := metadata.FromClientContext(ctx)
	if !ok {
		return nil, buguV1.ErrorInternalServerError("Openid does not exist in context")
	}
	if md.Get("x-md-global-userid") != userId {
		return nil, errors.Unauthorized("UNAUTHORIZED", "userid is inconsistent")
	}

	fileId := in.GetFileId()

	artifacts, err := s.au.GetArtifactMetadataByFileId(ctx, userId, fileId)
	if err != nil {
		return nil, err
	}

	var metadataReplies []*buguV1.GetArtifactMetadataReply
	for _, artifact := range artifacts {
		metadataReplies = append(metadataReplies, &buguV1.GetArtifactMetadataReply{
			ArtifactId:       artifact.ID.String(),
			FileId:           artifact.FileID.String(),
			AffiliatedFileId: artifact.AffiliatedFileID.String(),
			Method:           artifact.Method,
		})
	}

	return &buguV1.GetArtifactMetadataByFileIdReply{ArtifactMetadata: metadataReplies}, nil
}

func (s *BuguService) DeleteArtifactMetadata(ctx context.Context, in *buguV1.DeleteArtifactMetadataRequest) (*buguV1.DeleteArtifactMetadataReply, error) {
	userId := in.GetUserId()

	md, ok := metadata.FromClientContext(ctx)
	if !ok {
		return nil, buguV1.ErrorInternalServerError("Openid does not exist in context")
	}
	if md.Get("x-md-global-userid") != userId {
		return nil, errors.Unauthorized("UNAUTHORIZED", "userid is inconsistent")
	}

	artifactId := in.GetArtifactId()

	err := s.au.DeleteArtifactMetadata(ctx, userId, artifactId)
	if err != nil {
		return nil, err
	}

	return &buguV1.DeleteArtifactMetadataReply{}, nil
}

```

`app/bugu/service/internal/service/file.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package service

import (
	"context"
	"mime/multipart"
	nethttp "net/http"

	"github.com/hominsu/bugu/app/bugu/service/internal/biz"

	"github.com/go-kratos/kratos/v2/metadata"
	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"

	"github.com/go-kratos/kratos/v2/errors"
	"github.com/go-kratos/kratos/v2/transport/http"
)

func (s *BuguFileService) UploadFile(ctx http.Context) error {
	userId := ctx.Vars().Get("userId")
	if userId == "" {
		return errors.Unauthorized("UNAUTHORIZED", "userId is inconsistent")
	}

	if ctx.Header().Get("x-md-global-userid") != userId {
		return errors.Unauthorized("UNAUTHORIZED", "userId is inconsistent")
	}

	req := ctx.Request()
	file, handler, err := req.FormFile("file")
	if err != nil {
		return err
	}
	defer func(file multipart.File) {
		err = file.Close()
		if err != nil {
			s.log.Error(err)
		}
	}(file)

	// 4MB
	if handler.Size > 1024*1024*4 {
		return ctx.String(nethttp.StatusBadRequest, "The file size exceeds the limit")
	}

	dto, err := s.fu.SaveFile(ctx, userId, file, s.dc.File.Path)
	if err != nil {
		return err
	}

	return ctx.JSON(nethttp.StatusOK, dto)
}

func (s *BuguFileService) DownloadFile(ctx http.Context) error {
	vars := ctx.Vars()

	userId := vars.Get("userId")
	if userId == "" {
		return errors.Unauthorized("UNAUTHORIZED", "userId is inconsistent")
	}

	if ctx.Header().Get("x-md-global-userid") != userId {
		return errors.Unauthorized("UNAUTHORIZED", "userId is inconsistent")
	}

	fileId := vars.Get("fileId")
	if fileId == "" {
		return errors.BadRequest("FILE_ID_EMPTY", "file id params empty")
	}

	f, cleanup, err := s.fu.GetFile(ctx, userId, fileId)
	if err != nil {
		return err
	}
	defer cleanup()

	ctx.Response().Header().Set("Content-Type", "application/octect-stream")
	ctx.Response().Header().Set("Content-Description", "attachment;filename=\""+f.Name()+"\"")
	return ctx.Stream(nethttp.StatusOK, "application/octect-stream", f)
}

func (s *BuguService) GetFileMeta(ctx context.Context, in *buguV1.GetFileMetaRequest) (*buguV1.GetFileMetaReply, error) {
	userId := in.GetUserId()

	md, ok := metadata.FromClientContext(ctx)
	if !ok {
		return nil, buguV1.ErrorInternalServerError("Openid does not exist in context")
	}
	if md.Get("x-md-global-userid") != userId {
		return nil, errors.Unauthorized("UNAUTHORIZED", "userid is inconsistent")
	}

	fileId := in.GetFileId()

	dto, err := s.fu.GetFileMetadata(ctx, userId, fileId)
	if err != nil {
		return nil, err
	}

	return &buguV1.GetFileMetaReply{
		FileId:    dto.ID.String(),
		FileSha_1: dto.FileSha1,
		FileSize:  dto.FileSize,
		FileAddr:  dto.FileAddr,
		Type:      buguV1.Type(biz.TypeValue[*dto.Type]),
	}, nil
}

func (s *BuguService) GetFileMetaByUserId(ctx context.Context, in *buguV1.GetFileMetaByUserIdRequest) (*buguV1.GetFileMetaByUserIdReply, error) {
	userId := in.GetUserId()

	md, ok := metadata.FromClientContext(ctx)
	if !ok {
		return nil, buguV1.ErrorInternalServerError("Openid does not exist in context")
	}
	if md.Get("x-md-global-userid") != userId {
		return nil, errors.Unauthorized("UNAUTHORIZED", "userid is inconsistent")
	}

	dtos, err := s.fu.GetFileMetadataByUserId(ctx, userId)
	if err != nil {
		return nil, err
	}

	var rets []*buguV1.GetFileMetaReply
	for _, dto := range dtos {
		rets = append(rets, &buguV1.GetFileMetaReply{
			FileId:    dto.ID.String(),
			FileSha_1: dto.FileSha1,
			FileSize:  dto.FileSize,
			FileAddr:  dto.FileAddr,
			Type:      buguV1.Type(biz.TypeValue[*dto.Type]),
		})
	}

	return &buguV1.GetFileMetaByUserIdReply{FileMetadata: rets}, nil
}

func (s *BuguService) DeleteFileMetadata(ctx context.Context, in *buguV1.DeleteFileMetadataRequest) (*buguV1.DeleteFileMetadataReply, error) {
	userId := in.GetUserId()

	md, ok := metadata.FromClientContext(ctx)
	if !ok {
		return nil, buguV1.ErrorInternalServerError("Openid does not exist in context")
	}
	if md.Get("x-md-global-userid") != userId {
		return nil, errors.Unauthorized("UNAUTHORIZED", "userid is inconsistent")
	}

	fileId := in.GetFileId()

	err := s.fu.DeleteFileMetadata(ctx, userId, fileId)
	if err != nil {
		return nil, err
	}

	return &buguV1.DeleteFileMetadataReply{}, nil
}

```

`app/bugu/service/internal/service/service.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package service

import (
	"github.com/go-kratos/kratos/v2/log"
	"github.com/google/wire"
	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
	"github.com/hominsu/bugu/app/bugu/service/internal/biz"
	"github.com/hominsu/bugu/app/bugu/service/internal/conf"
)

// ProviderSet is service providers.
var ProviderSet = wire.NewSet(NewBuguService, NewBuguFileService)

type BuguService struct {
	buguV1.UnimplementedBuguServer

	uu  *biz.UserUsecase
	fu  *biz.FileUsecase
	au  *biz.ArtifactUsecase
	log *log.Helper
}

func NewBuguService(uu *biz.UserUsecase, fu *biz.FileUsecase, au *biz.ArtifactUsecase, logger log.Logger) *BuguService {
	return &BuguService{
		uu:  uu,
		fu:  fu,
		au:  au,
		log: log.NewHelper(log.With(logger, "module", "service/bugu")),
	}
}

type BuguFileService struct {
	buguV1.UnimplementedBuguFileServer

	fu  *biz.FileUsecase
	dc  *conf.Data
	log *log.Helper
}

func NewBuguFileService(fu *biz.FileUsecase, dc *conf.Data, logger log.Logger) *BuguFileService {
	return &BuguFileService{
		fu:  fu,
		dc:  dc,
		log: log.NewHelper(log.With(logger, "module", "service/bugu-file")),
	}
}

```

`app/bugu/service/internal/service/user.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package service

import (
	"context"

	"github.com/google/uuid"

	buguV1 "github.com/hominsu/bugu/api/bugu/service/v1"
)

func (s *BuguService) Register(ctx context.Context, in *buguV1.RegisterRequest) (*buguV1.RegisterReply, error) {
	user := in.GetUser()

	dto, err := s.uu.Register(ctx, user.Email, user.Username, user.Password)
	if err != nil {
		return nil, err
	}

	return &buguV1.RegisterReply{User: &buguV1.UserStruct{
		Id:       dto.ID.String(),
		Email:    dto.Email,
		Username: dto.Username,
	}}, nil
}

func (s *BuguService) Login(ctx context.Context, in *buguV1.LoginRequest) (*buguV1.LoginReply, error) {
	user := in.GetUser()

	dto, err := s.uu.Login(ctx, user.Email, user.Password)
	if err != nil {
		return nil, err
	}

	return &buguV1.LoginReply{
		User: &buguV1.UserStruct{
			Id:       dto.ID.String(),
			Email:    dto.Email,
			Username: dto.Username,
		},
		Token: dto.Token,
	}, nil
}

func (s *BuguService) GetCurrentUser(ctx context.Context, in *buguV1.GetCurrentUserRequest) (*buguV1.GetCurrentUserReply, error) {
	u, err := uuid.Parse(in.Id)
	if err != nil {
		return nil, buguV1.ErrorUuidParseFailed("parse userid failed, id: %s", in.Id)
	}

	dto, err := s.uu.GetUserByID(ctx, u)
	if err != nil {
		return nil, err
	}

	return &buguV1.GetCurrentUserReply{User: &buguV1.UserStruct{
		Id:       dto.ID.String(),
		Email:    dto.Email,
		Username: dto.Username,
	}}, nil
}

func (s *BuguService) UpdateUser(ctx context.Context, in *buguV1.UpdateUserRequest) (*buguV1.UpdateUserReply, error) {
	user := in.GetUser()

	dto, err := s.uu.UpdateUser(ctx, user.Id, user.Email, user.Username, user.Password)
	if err != nil {
		return nil, err
	}

	return &buguV1.UpdateUserReply{User: &buguV1.UserStruct{
		Id:       dto.ID.String(),
		Email:    dto.Email,
		Username: dto.Username,
	}}, nil
}

```

`app/detect/service/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.11)

set(LIB_MAJOR_VERSION "1")
set(LIB_MINOR_VERSION "0")
set(LIB_PATCH_VERSION "0")
set(LIB_VERSION_STRING "${LIB_MAJOR_VERSION}.${LIB_MINOR_VERSION}.${LIB_PATCH_VERSION}")

project(bugu.detect.service
        VERSION "${LIB_VERSION_STRING}"
        LANGUAGES C CXX
        HOMEPAGE_URL "https://github.com/hominsu/bugu")

set(CMAKE_CXX_STANDARD 17)

message("")
message("Operation system is ${CMAKE_SYSTEM}")
message("Current compiler: ${CMAKE_CXX_COMPILER_ID}")
message("Current compiler version: ${CMAKE_CXX_COMPILER_VERSION}")
message("Current compiler directory: ${CMAKE_CXX_COMPILER}")
if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
    link_directories(/opt/homebrew/lib)
    include_directories(/opt/homebrew/include)
    set(OPENSSL_ROOT_DIR /opt/homebrew/opt/openssl@1.1/)
    set(OPENSSL_INCLUDE_DIR /opt/homebrew/opt/openssl@1.1/include)
elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
    link_directories(/usr/local/lib)
    include_directories(/usr/local/include)
elseif (${CMAKE_SYSTEM_NAME} MATCHES "Windows")
    if (MSVC)   # if msvc
        add_compile_options("$<$<C_COMPILER_ID:MSVC>:/utf-8>")
        add_compile_options("$<$<CXX_COMPILER_ID:MSVC>:/utf-8>")
    endif ()
else ()
    message(FATAL_ERROR "Platform ${CMAKE_SYSTEM} is not support for this project")
endif ()

if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel." FORCE)
endif ()

if (CMAKE_BUILD_TYPE STREQUAL Debug)
    ADD_DEFINITIONS(-DBUGU_DEBUG)
    message(STATUS "CMake Build Type: Debug")
    message("")
elseif (CMAKE_BUILD_TYPE STREQUAL Release)
    ADD_DEFINITIONS(-DBUGU_RELEASE)
    message(STATUS "CMake Build Type: Release")
    message("")
endif ()

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror -Wno-unused-parameter")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g")
#set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3")

find_program(CCACHE_FOUND ccache)
if (CCACHE_FOUND)
    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)
    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)
    if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Qunused-arguments -fcolor-diagnostics")
    endif ()
endif (CCACHE_FOUND)

if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    if (NUEJSON_ENABLE_INSTRUMENTATION_OPT AND NOT CMAKE_CROSSCOMPILING)
        if (CMAKE_SYSTEM_PROCESSOR STREQUAL "powerpc" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64le")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mcpu=native")
        elseif (NOT CMAKE_SYSTEM_PROCESSOR STREQUAL "arm64" AND NOT CMAKE_SYSTEM_NAME MATCHES "Darwin")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native")
        endif ()
    endif ()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror")
    set(EXTRA_CXX_FLAGS -Weffc++ -Wswitch-default -Wfloat-equal -Wconversion -Wsign-conversion)
elseif (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    if (NOT CMAKE_CROSSCOMPILING)
        if (CMAKE_SYSTEM_PROCESSOR STREQUAL "powerpc" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64le")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mcpu=native")
        elseif (NOT CMAKE_SYSTEM_PROCESSOR STREQUAL "arm64" AND NOT CMAKE_SYSTEM_NAME MATCHES "Darwin")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native")
        endif ()
    endif ()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror -Wno-missing-field-initializers -Wno-register")
    set(EXTRA_CXX_FLAGS -Weffc++ -Wswitch-default -Wfloat-equal -Wconversion -Wimplicit-fallthrough)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    add_definitions(-D_CRT_SECURE_NO_WARNINGS=1)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /EHsc")
    # Always compile with /WX
    if (CMAKE_CXX_FLAGS MATCHES "/WX-")
        string(REGEX REPLACE "/WX-" "/WX" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
    else ()
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /WX")
    endif ()
elseif (CMAKE_CXX_COMPILER_ID MATCHES "XL")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -qarch=auto")
endif ()

add_subdirectory(src)
add_subdirectory(resnet)
```

`app/detect/service/Makefile`:

```
include ../../../cpp_makefile
```

`app/detect/service/configs/config.json`:

```json
{
  "server": {
    "grpc": {
      "addr": "0.0.0.0:9000"
    }
  }
}
```

`app/detect/service/include/bugu_dectet/bugu_detect.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_INCLUDE_BUGU_DECTET_BUGU_DETECT_H_
#define BUGU_DETECT_SERVICE_INCLUDE_BUGU_DECTET_BUGU_DETECT_H_

#if defined(__has_builtin)
#define BUGU_HAS_BUILTIN(x) __has_builtin(x)
#else
#define BUGU_HAS_BUILTIN(x) 0
#endif

#ifndef BUGU_ASSERT
#include <cassert>
#define BUGU_ASSERT(x) assert(x)
#endif // BUGU_ASSERT

#if defined(_WIN64) || defined(WIN64) || defined(_WIN32) || defined(WIN32)
#if defined(_WIN64) || defined(WIN64)
#define BUGU_ARCH_64 1
#else
#define BUGU_ARCH_32 1
#endif
#define BUGU_PLATFORM_STRING "windows"
#define BUGU_WINDOWS 1
#elif defined(__linux__)
#define BUGU_PLATFORM_STRING "linux"
#define BUGU_LINUX 1
#ifdef _LP64
#define BUGU_ARCH_64 1
#else /* _LP64 */
#define BUGU_ARCH_32 1
#endif /* _LP64 */
#elif defined(__APPLE__)
#define BUGU_PLATFORM_STRING "osx"
#define BUGU_APPLE 1
#ifdef _LP64
#define BUGU_ARCH_64 1
#else /* _LP64 */
#define BUGU_ARCH_32 1
#endif /* _LP64 */
#endif

#ifndef BUGU_WINDOWS
#define BUGU_WINDOWS 0
#endif
#ifndef BUGU_LINUX
#define BUGU_LINUX 0
#endif
#ifndef BUGU_APPLE
#define BUGU_APPLE 0
#endif

#ifdef _MSC_VER
#if _MSC_VER < 1700
typedef __int8 int8_t;
typedef __int16 int16_t;
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int8 uint8_t;
typedef unsigned __int16 uint16_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif /* _MSC_VER < 1700 */
#else
#include <stdint.h>
#endif /* _MSC_VER */

#ifdef _MSC_VER
#if _MSC_VER < 1400
#define PRIdS __PRIS_PREFIX "d"
#define PRIxS __PRIS_PREFIX "x"
#define PRIuS __PRIS_PREFIX "u"
#define PRIXS __PRIS_PREFIX "X"
#define PRIoS __PRIS_PREFIX "o"
#else
#include <inttypes.h>
#endif /* _MSC_VER < 1400 */
#else
#include <inttypes.h>
#endif /* _MSC_VER */

#endif //BUGU_DETECT_SERVICE_INCLUDE_BUGU_DECTET_BUGU_DETECT_H_

```

`app/detect/service/resnet/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.11)

project(resnet
        LANGUAGES C CXX)
option(CUDA_USE_STATIC_CUDA_RUNTIME OFF)
set(CMAKE_CXX_STANDARD 17)

# Cuda
include_directories(/usr/local/cuda/include)
link_directories(/usr/local/cuda/lib64)

# Tensorrt
include_directories(/usr/include/x86_64-linux-gnu/)
link_directories(/usr/lib/x86_64-linux-gnu/)

if (CMAKE_BUILD_TYPE STREQUAL Debug)
    ADD_DEFINITIONS(-DDEBUG)
    message(STATUS "CMake Build Type: Debug")
    message("")
elseif (CMAKE_BUILD_TYPE STREQUAL Release)
    ADD_DEFINITIONS(-DRELEASE)
    message(STATUS "CMake Build Type: Release")
    message("")
endif ()

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror -Wno-unused-parameter")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O2")

# Threads
find_package(Threads REQUIRED)
if (Threads_FOUND)
    message("")
endif ()

include_directories(../include)
include_directories(include)
file(GLOB ProjectSRC
        "src/*.cc")

add_executable(${PROJECT_NAME} ${ProjectSRC})
target_link_libraries(${PROJECT_NAME}
        Threads::Threads
        nvinfer
        cudart)

```

`app/detect/service/resnet/include/resnet/resnet_18.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/31.
//

#ifndef BUGU_DETECT_SERVICE_RESNET_INCLUDE_RESNET_RESNET_18_H_
#define BUGU_DETECT_SERVICE_RESNET_INCLUDE_RESNET_RESNET_18_H_

#include "g_logging.h"

#include <map>
#include <memory>
#include <string>

namespace bugu::Resnet {

static const int INPUT_H = 224;
static const int INPUT_W = 224;
static const int OUTPUT_SIZE = 1000;
static const int BATCH_SIZE = 1;

inline namespace v18 {

class Resnet {
 public:
  static const int INPUT_H = ::bugu::Resnet::INPUT_H;
  static const int INPUT_W = ::bugu::Resnet::INPUT_W;
  static const int OUTPUT_SIZE = ::bugu::Resnet::OUTPUT_SIZE;

  const char *INPUT_BLOB_NAME = "data";
  const char *OUTPUT_BLOB_NAME = "prob";

 private:
  bool is_prepared_ = false;
  nvinfer1::IRuntime *runtime_{};
  nvinfer1::ICudaEngine *engine_{};
  nvinfer1::IExecutionContext *context_{};
  int input_index_{};
  int output_index_{};
  void *gpu_buffers_[2]{};
  cudaStream_t stream_{};

  Logger g_logger_;

  ::std::string engine_name_ = "resnet18.engine";
  long model_size_{};
  ::std::shared_ptr<char[]> trtModelStream_{};

 public:
  ~Resnet();
  static Resnet *Get() {
    static Resnet r;
    return &r;
  }
 private:
  Resnet() = default;

 public:
  void Init();
  void GenEngine();
  void LoadEngine();
  void Inference(float *_input, float *_output);

 private:
  void APIToModel(unsigned int _max_batch_size, IHostMemory **_model_stream);
  void BuildEngine(unsigned int _max_batch_size,
                   IBuilder *_builder,
                   IBuilderConfig *_config,
                   DataType _data_type);
  ::std::map<::std::string, Weights> LoadWeights(const ::std::string _file_name);
  IScaleLayer *AddBatchNorm2d(INetworkDefinition *_network,
                              ::std::map<::std::string, Weights> &_weight_map,
                              ITensor &_input,
                              ::std::string _layer_name,
                              float _eps);
  IActivationLayer *BasicBlock(INetworkDefinition *_network,
                               ::std::map<::std::string, Weights> &_weight_map,
                               ITensor &_input,
                               int _in_ch,
                               int _out_ch,
                               int _stride,
                               ::std::string _layer_name);

};

} // inline namespace v18

} // namespace bugu::Resnet

#endif //BUGU_DETECT_SERVICE_RESNET_INCLUDE_RESNET_RESNET_18_H_

```

`app/detect/service/resnet/src/g_logging.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/31.
//

#ifndef BUGU_DETECT_SERVICE_RESNET_G_LOGGING_H_
#define BUGU_DETECT_SERVICE_RESNET_G_LOGGING_H_

#include "NvInferRuntimeCommon.h"
#include <cassert>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <ostream>
#include <sstream>
#include <string>

using Severity = nvinfer1::ILogger::Severity;

class LogStreamConsumerBuffer : public std::stringbuf {
 public:
  LogStreamConsumerBuffer(std::ostream &stream, const std::string &prefix, bool shouldLog)
      : mOutput(stream), mPrefix(prefix), mShouldLog(shouldLog) {
  }

  LogStreamConsumerBuffer(LogStreamConsumerBuffer &&other)
      : mOutput(other.mOutput) {
  }

  ~LogStreamConsumerBuffer() {
    // std::streambuf::pbase() gives a pointer to the beginning of the buffered part of the output sequence
    // std::streambuf::pptr() gives a pointer to the current position of the output sequence
    // if the pointer to the beginning is not equal to the pointer to the current position,
    // call putOutput() to log the output to the stream
    if (pbase() != pptr()) {
      putOutput();
    }
  }

  // synchronizes the stream buffer and returns 0 on success
  // synchronizing the stream buffer consists of inserting the buffer contents into the stream,
  // resetting the buffer and flushing the stream
  virtual int sync() {
    putOutput();
    return 0;
  }

  void putOutput() {
    if (mShouldLog) {
      // prepend timestamp
      std::time_t timestamp = std::time(nullptr);
      tm *tm_local = std::localtime(&timestamp);
      std::cout << "[";
      std::cout << std::setw(2) << std::setfill('0') << 1 + tm_local->tm_mon << "/";
      std::cout << std::setw(2) << std::setfill('0') << tm_local->tm_mday << "/";
      std::cout << std::setw(4) << std::setfill('0') << 1900 + tm_local->tm_year << "-";
      std::cout << std::setw(2) << std::setfill('0') << tm_local->tm_hour << ":";
      std::cout << std::setw(2) << std::setfill('0') << tm_local->tm_min << ":";
      std::cout << std::setw(2) << std::setfill('0') << tm_local->tm_sec << "] ";
      // std::stringbuf::str() gets the string contents of the buffer
      // insert the buffer contents pre-appended by the appropriate prefix into the stream
      mOutput << mPrefix << str();
      // set the buffer to empty
      str("");
      // flush the stream
      mOutput.flush();
    }
  }

  void setShouldLog(bool shouldLog) {
    mShouldLog = shouldLog;
  }

 private:
  std::ostream &mOutput;
  std::string mPrefix;
  bool mShouldLog;
};

//!
//! \class LogStreamConsumerBase
//! \brief Convenience object used to initialize LogStreamConsumerBuffer before std::ostream in LogStreamConsumer
//!
class LogStreamConsumerBase {
 public:
  LogStreamConsumerBase(std::ostream &stream, const std::string &prefix, bool shouldLog)
      : mBuffer(stream, prefix, shouldLog) {
  }

 protected:
  LogStreamConsumerBuffer mBuffer;
};

//!
//! \class LogStreamConsumer
//! \brief Convenience object used to facilitate use of C++ stream syntax when logging messages.
//!  Order of base classes is LogStreamConsumerBase and then std::ostream.
//!  This is because the LogStreamConsumerBase class is used to initialize the LogStreamConsumerBuffer member field
//!  in LogStreamConsumer and then the address of the buffer is passed to std::ostream.
//!  This is necessary to prevent the address of an uninitialized buffer from being passed to std::ostream.
//!  Please do not change the order of the parent classes.
//!
class LogStreamConsumer : protected LogStreamConsumerBase, public std::ostream {
 public:
  //! \brief Creates a LogStreamConsumer which logs messages with level severity.
  //!  Reportable severity determines if the messages are severe enough to be logged.
  LogStreamConsumer(Severity reportableSeverity, Severity severity)
      : LogStreamConsumerBase(severityOstream(severity), severityPrefix(severity), severity <= reportableSeverity),
        std::ostream(&mBuffer) // links the stream buffer with the stream
      ,
        mShouldLog(severity <= reportableSeverity),
        mSeverity(severity) {
  }

  LogStreamConsumer(LogStreamConsumer &&other)
      : LogStreamConsumerBase(severityOstream(other.mSeverity), severityPrefix(other.mSeverity), other.mShouldLog),
        std::ostream(&mBuffer) // links the stream buffer with the stream
      ,
        mShouldLog(other.mShouldLog),
        mSeverity(other.mSeverity) {
  }

  void setReportableSeverity(Severity reportableSeverity) {
    mShouldLog = mSeverity <= reportableSeverity;
    mBuffer.setShouldLog(mShouldLog);
  }

 private:
  static std::ostream &severityOstream(Severity severity) {
    return severity >= Severity::kINFO ? std::cout : std::cerr;
  }

  static std::string severityPrefix(Severity severity) {
    switch (severity) {
      case Severity::kINTERNAL_ERROR: return "[F] ";
      case Severity::kERROR: return "[E] ";
      case Severity::kWARNING: return "[W] ";
      case Severity::kINFO: return "[I] ";
      case Severity::kVERBOSE: return "[V] ";
      default: assert(0);
        return "";
    }
  }

  bool mShouldLog;
  Severity mSeverity;
};

//! \class Logger
//!
//! \brief Class which manages logging of TensorRT tools and samples
//!
//! \details This class provides a common interface for TensorRT tools and samples to log information to the console,
//! and supports logging two types of messages:
//!
//! - Debugging messages with an associated severity (info, warning, error, or internal error/fatal)
//! - Test pass/fail messages
//!
//! The advantage of having all samples use this class for logging as opposed to emitting directly to stdout/stderr is
//! that the logic for controlling the verbosity and formatting of sample output is centralized in one location.
//!
//! In the future, this class could be extended to support dumping test results to a file in some standard format
//! (for example, JUnit XML), and providing additional metadata (e.g. timing the duration of a test run).
//!
//! TODO: For backwards compatibility with existing samples, this class inherits directly from the nvinfer1::ILogger
//! interface, which is problematic since there isn't a clean separation between messages coming from the TensorRT
//! library and messages coming from the sample.
//!
//! In the future (once all samples are updated to use Logger::getTRTLogger() to access the ILogger) we can refactor the
//! class to eliminate the inheritance and instead make the nvinfer1::ILogger implementation a member of the Logger
//! object.

class Logger : public nvinfer1::ILogger {
 public:
  Logger(Severity severity = Severity::kWARNING)
      : mReportableSeverity(severity) {
  }

  //!
  //! \enum TestResult
  //! \brief Represents the state of a given test
  //!
  enum class TestResult {
    kRUNNING, //!< The test is running
    kPASSED,  //!< The test passed
    kFAILED,  //!< The test failed
    kWAIVED   //!< The test was waived
  };

  //!
  //! \brief Forward-compatible method for retrieving the nvinfer::ILogger associated with this Logger
  //! \return The nvinfer1::ILogger associated with this Logger
  //!
  //! TODO Once all samples are updated to use this method to register the logger with TensorRT,
  //! we can eliminate the inheritance of Logger from ILogger
  //!
  nvinfer1::ILogger &getTRTLogger() {
    return *this;
  }

  //!
  //! \brief Implementation of the nvinfer1::ILogger::log() virtual method
  //!
  //! Note samples should not be calling this function directly; it will eventually go away once we eliminate the
  //! inheritance from nvinfer1::ILogger
  //!
  void log(Severity severity, const char *msg) override {
    LogStreamConsumer(mReportableSeverity, severity) << "[TRT] " << std::string(msg) << std::endl;
  }

  //!
  //! \brief Method for controlling the verbosity of logging output
  //!
  //! \param severity The logger will only emit messages that have severity of this level or higher.
  //!
  void setReportableSeverity(Severity severity) {
    mReportableSeverity = severity;
  }

  //!
  //! \brief Opaque handle that holds logging information for a particular test
  //!
  //! This object is an opaque handle to information used by the Logger to print test results.
  //! The sample must call Logger::defineTest() in order to obtain a TestAtom that can be used
  //! with Logger::reportTest{Start,End}().
  //!
  class TestAtom {
   public:
    TestAtom(TestAtom &&) = default;

   private:
    friend class Logger;

    TestAtom(bool started, const std::string &name, const std::string &cmdline)
        : mStarted(started), mName(name), mCmdline(cmdline) {
    }

    bool mStarted;
    std::string mName;
    std::string mCmdline;
  };

  //!
  //! \brief Define a test for logging
  //!
  //! \param[in] name The name of the test.  This should be a string starting with
  //!                  "TensorRT" and containing dot-separated strings containing
  //!                  the characters [A-Za-z0-9_].
  //!                  For example, "TensorRT.sample_googlenet"
  //! \param[in] cmdline The command line used to reproduce the test
  //
  //! \return a TestAtom that can be used in Logger::reportTest{Start,End}().
  //!
  static TestAtom defineTest(const std::string &name, const std::string &cmdline) {
    return TestAtom(false, name, cmdline);
  }

  //!
  //! \brief A convenience overloaded version of defineTest() that accepts an array of command-line arguments
  //!        as input
  //!
  //! \param[in] name The name of the test
  //! \param[in] argc The number of command-line arguments
  //! \param[in] argv The array of command-line arguments (given as C strings)
  //!
  //! \return a TestAtom that can be used in Logger::reportTest{Start,End}().
  static TestAtom defineTest(const std::string &name, int argc, char const *const *argv) {
    auto cmdline = genCmdlineString(argc, argv);
    return defineTest(name, cmdline);
  }

  //!
  //! \brief Report that a test has started.
  //!
  //! \pre reportTestStart() has not been called yet for the given testAtom
  //!
  //! \param[in] testAtom The handle to the test that has started
  //!
  static void reportTestStart(TestAtom &testAtom) {
    reportTestResult(testAtom, TestResult::kRUNNING);
    assert(!testAtom.mStarted);
    testAtom.mStarted = true;
  }

  //!
  //! \brief Report that a test has ended.
  //!
  //! \pre reportTestStart() has been called for the given testAtom
  //!
  //! \param[in] testAtom The handle to the test that has ended
  //! \param[in] result The result of the test. Should be one of TestResult::kPASSED,
  //!                   TestResult::kFAILED, TestResult::kWAIVED
  //!
  static void reportTestEnd(const TestAtom &testAtom, TestResult result) {
    assert(result != TestResult::kRUNNING);
    assert(testAtom.mStarted);
    reportTestResult(testAtom, result);
  }

  static int reportPass(const TestAtom &testAtom) {
    reportTestEnd(testAtom, TestResult::kPASSED);
    return EXIT_SUCCESS;
  }

  static int reportFail(const TestAtom &testAtom) {
    reportTestEnd(testAtom, TestResult::kFAILED);
    return EXIT_FAILURE;
  }

  static int reportWaive(const TestAtom &testAtom) {
    reportTestEnd(testAtom, TestResult::kWAIVED);
    return EXIT_SUCCESS;
  }

  static int reportTest(const TestAtom &testAtom, bool pass) {
    return pass ? reportPass(testAtom) : reportFail(testAtom);
  }

  Severity getReportableSeverity() const {
    return mReportableSeverity;
  }

 private:
  //!
  //! \brief returns an appropriate string for prefixing a log message with the given severity
  //!
  static const char *severityPrefix(Severity severity) {
    switch (severity) {
      case Severity::kINTERNAL_ERROR: return "[F] ";
      case Severity::kERROR: return "[E] ";
      case Severity::kWARNING: return "[W] ";
      case Severity::kINFO: return "[I] ";
      case Severity::kVERBOSE: return "[V] ";
      default: assert(0);
        return "";
    }
  }

  //!
  //! \brief returns an appropriate string for prefixing a test result message with the given result
  //!
  static const char *testResultString(TestResult result) {
    switch (result) {
      case TestResult::kRUNNING: return "RUNNING";
      case TestResult::kPASSED: return "PASSED";
      case TestResult::kFAILED: return "FAILED";
      case TestResult::kWAIVED: return "WAIVED";
      default: assert(0);
        return "";
    }
  }

  //!
  //! \brief returns an appropriate output stream (cout or cerr) to use with the given severity
  //!
  static std::ostream &severityOstream(Severity severity) {
    return severity >= Severity::kINFO ? std::cout : std::cerr;
  }

  //!
  //! \brief method that implements logging test results
  //!
  static void reportTestResult(const TestAtom &testAtom, TestResult result) {
    severityOstream(Severity::kINFO) << "&&&& " << testResultString(result) << " " << testAtom.mName << " # "
                                     << testAtom.mCmdline << std::endl;
  }

  //!
  //! \brief generate a command line string from the given (argc, argv) values
  //!
  static std::string genCmdlineString(int argc, char const *const *argv) {
    std::stringstream ss;
    for (int i = 0; i < argc; i++) {
      if (i > 0)
        ss << " ";
      ss << argv[i];
    }
    return ss.str();
  }

  Severity mReportableSeverity;
};

namespace {

//!
//! \brief produces a LogStreamConsumer object that can be used to log messages of severity kVERBOSE
//!
//! Example usage:
//!
//!     LOG_VERBOSE(logger) << "hello world" << std::endl;
//!
inline LogStreamConsumer LOG_VERBOSE(const Logger &logger) {
  return LogStreamConsumer(logger.getReportableSeverity(), Severity::kVERBOSE);
}

//!
//! \brief produces a LogStreamConsumer object that can be used to log messages of severity kINFO
//!
//! Example usage:
//!
//!     LOG_INFO(logger) << "hello world" << std::endl;
//!
inline LogStreamConsumer LOG_INFO(const Logger &logger) {
  return LogStreamConsumer(logger.getReportableSeverity(), Severity::kINFO);
}

//!
//! \brief produces a LogStreamConsumer object that can be used to log messages of severity kWARNING
//!
//! Example usage:
//!
//!     LOG_WARN(logger) << "hello world" << std::endl;
//!
inline LogStreamConsumer LOG_WARN(const Logger &logger) {
  return LogStreamConsumer(logger.getReportableSeverity(), Severity::kWARNING);
}

//!
//! \brief produces a LogStreamConsumer object that can be used to log messages of severity kERROR
//!
//! Example usage:
//!
//!     LOG_ERROR(logger) << "hello world" << std::endl;
//!
inline LogStreamConsumer LOG_ERROR(const Logger &logger) {
  return LogStreamConsumer(logger.getReportableSeverity(), Severity::kERROR);
}

//!
//! \brief produces a LogStreamConsumer object that can be used to log messages of severity kINTERNAL_ERROR
//         ("fatal" severity)
//!
//! Example usage:
//!
//!     LOG_FATAL(logger) << "hello world" << std::endl;
//!
inline LogStreamConsumer LOG_FATAL(const Logger &logger) {
  return LogStreamConsumer(logger.getReportableSeverity(), Severity::kINTERNAL_ERROR);
}

} // anonymous namespace

#endif //BUGU_DETECT_SERVICE_RESNET_G_LOGGING_H_

```

`app/detect/service/resnet/src/resnet_18.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/31.
//

#include "bugu_dectet/bugu_detect.h"
#include "resnet/resnet_18.h"

#include "NvInfer.h"
#include "cuda_runtime_api.h"

#include <cmath>

#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <sstream>
#include <exception>
#include <vector>
#include <chrono>

#define CHECK(status) \
    do {\
        auto ret = (status);\
        if (ret != 0)\
        {\
            ::std::clog << "Cuda failure: " << ret << ::std::endl;\
            abort();\
        }\
    } while (0)

using namespace nvinfer1;

bugu::Resnet::v18::Resnet::~Resnet() {
  if (is_prepared_) {
    // Release stream and gpu_buffers_
    cudaStreamDestroy(stream_);
    CHECK(cudaFree(gpu_buffers_[input_index_]));
    CHECK(cudaFree(gpu_buffers_[output_index_]));

    // Destroy the engine
    if (nullptr != context_) {
      context_->destroy();
      context_ = nullptr;
      std::cout << "context_->destroy();" << std::endl;
    }
    if (nullptr != engine_) {
      engine_->destroy();
      engine_ = nullptr;
      std::cout << "engine_->destroy();" << std::endl;
    }
    if (nullptr != runtime_) {
      runtime_->destroy();
      runtime_ = nullptr;
      std::cout << "runtime_->destroy();" << std::endl;
    }
  }
}

void bugu::Resnet::v18::Resnet::Init() {
  runtime_ = createInferRuntime(g_logger_);
  assert(runtime_ != nullptr);

  engine_ = runtime_->deserializeCudaEngine(trtModelStream_.get(), model_size_, nullptr);
  assert(engine_ != nullptr);

  context_ = engine_->createExecutionContext();
  assert(context_ != nullptr);

  // Pointers to input and output device buffers to pass to engine.
  // Engine requires exactly IEngine::getNbBindings() number of buffers.
  assert(engine_.getNbBindings() == 2);

  // In order to bind the buffers, we need to know the names of the input and output tensors.
  // Note that indices are guaranteed to be less than IEngine::getNbBindings()
  input_index_ = engine_.getBindingIndex(INPUT_BLOB_NAME);
  output_index_ = engine_.getBindingIndex(OUTPUT_BLOB_NAME);
  assert(input_index_ == 0);
  assert(output_index_ == 1);

  // Create GPU buffers on device
  CHECK(cudaMalloc(&gpu_buffers_[input_index_], BATCH_SIZE * 3 * INPUT_H * INPUT_W * sizeof(float)));
  CHECK(cudaMalloc(&gpu_buffers_[output_index_], BATCH_SIZE * OUTPUT_SIZE * sizeof(float)));

  // Check stream
  CHECK(cudaStreamCreate(&stream_));

  is_prepared_ = true;
}

void bugu::Resnet::v18::Resnet::GenEngine() {
  assert(!engine_name_.empty() && "engine name should not be empty");

  // create a model using the API directly and serialize it to a stream
  ::std::clog << "Gen Engine ..." << ::std::endl;

  IHostMemory *model_stream{nullptr};
  APIToModel(1, &model_stream);
  assert(model_stream != nullptr);

  ::std::ofstream p(engine_name_, ::std::ios::binary);
  if (!p) {
    throw ::std::runtime_error("could not open plan output file");
  }
  p.write(reinterpret_cast<const char *>(model_stream->data()), model_stream->size());

  model_stream->destroy();
}

void bugu::Resnet::v18::Resnet::LoadEngine() {
  // deserialize the .engine
  ::std::ifstream file(engine_name_, ::std::ios::binary);
  if (file.good()) {
    // get the file size
    file.seekg(0, ::std::ifstream::end);
    model_size_ = file.tellg();
    file.seekg(0, ::std::ifstream::beg);

    trtModelStream_ = ::std::shared_ptr<char[]>(new char[model_size_]());
    assert(trtModelStream_);

    // load the model data
    file.read(trtModelStream_.get(), model_size_);
    file.close();
  }
}

void bugu::Resnet::v18::Resnet::Inference(float *_input, float *_output) {
  // DMA input batch data to device, infer on the batch asynchronously, and DMA output back to host
  CHECK(cudaMemcpyAsync(gpu_buffers_[inputIndex],
                        _input,
                        BATCH_SIZE * 3 * INPUT_H * INPUT_W * sizeof(float),
                        cudaMemcpyHostToDevice,
                        stream_));

  context_.enqueue(_batch_size, gpu_buffers_, stream_, nullptr);

  CHECK(cudaMemcpyAsync(_output,
                        gpu_buffers_[outputIndex],
                        BATCH_SIZE * OUTPUT_SIZE * sizeof(float),
                        cudaMemcpyDeviceToHost,
                        stream_));

  cudaStreamSynchronize(stream_);
}

void bugu::Resnet::v18::Resnet::APIToModel(unsigned int _max_batch_size, IHostMemory **_model_stream) {
  // Create builder
  IBuilder *builder = createInferBuilder(g_logger_);
  IBuilderConfig *config = builder->createBuilderConfig();

  // Create model to populate the network, then set the outputs and create an engine
  ICudaEngine *engine = BuildEngine(_max_batch_size, builder, config, DataType::kFLOAT);
  assert(engine != nullptr);

  // Serialize the engine
  (*_model_stream) = engine->serialize();

  // Close everything down
  engine->destroy();
  builder->destroy();
  config->destroy();
}

void bugu::Resnet::v18::Resnet::BuildEngine(unsigned int _max_batch_size,
                                            IBuilder *_builder,
                                            IBuilderConfig *_config,
                                            DataType _data_type) {
  INetworkDefinition *network = _builder->createNetworkV2(0U);

  // Create input tensor of shape { 3, INPUT_H, INPUT_W } with name INPUT_BLOB_NAME
  ITensor *data = network->addInput(INPUT_BLOB_NAME, _data_type, Dims3{3, INPUT_H, INPUT_W});
  assert(data);

  ::std::map<::std::string, Weights> weight_map = loadWeights("../resnet18.wts");
  Weights empty_wts{DataType::kFLOAT, nullptr, 0};

  IConvolutionLayer *conv1 = network->addConvolutionNd(*data, 64, DimsHW{7, 7}, weight_map["conv1.weight"], empty_wts);
  assert(conv1);
  conv1->setStrideNd(DimsHW{2, 2});
  conv1->setPaddingNd(DimsHW{3, 3});

  IScaleLayer *bn1 = AddBatchNorm2d(network, weight_map, *conv1->getOutput(0), "bn1", 1e-5);

  IActivationLayer *relu1 = network->addActivation(*bn1->getOutput(0), ActivationType::kRELU);
  assert(relu1);

  IPoolingLayer *pool1 = network->addPoolingNd(*relu1->getOutput(0), PoolingType::kMAX, DimsHW{3, 3});
  assert(pool1);
  pool1->setStrideNd(DimsHW{2, 2});
  pool1->setPaddingNd(DimsHW{1, 1});

  IActivationLayer *relu2 = BasicBlock(network, weight_map, *pool1->getOutput(0), 64, 64, 1, "layer1.0.");
  IActivationLayer *relu3 = BasicBlock(network, weight_map, *relu2->getOutput(0), 64, 64, 1, "layer1.1.");

  IActivationLayer *relu4 = BasicBlock(network, weight_map, *relu3->getOutput(0), 64, 128, 2, "layer2.0.");
  IActivationLayer *relu5 = BasicBlock(network, weight_map, *relu4->getOutput(0), 128, 128, 1, "layer2.1.");

  IActivationLayer *relu6 = BasicBlock(network, weight_map, *relu5->getOutput(0), 128, 256, 2, "layer3.0.");
  IActivationLayer *relu7 = BasicBlock(network, weight_map, *relu6->getOutput(0), 256, 256, 1, "layer3.1.");

  IActivationLayer *relu8 = BasicBlock(network, weight_map, *relu7->getOutput(0), 256, 512, 2, "layer4.0.");
  IActivationLayer *relu9 = BasicBlock(network, weight_map, *relu8->getOutput(0), 512, 512, 1, "layer4.1.");

  IPoolingLayer *pool2 = network->addPoolingNd(*relu9->getOutput(0), PoolingType::kAVERAGE, DimsHW{7, 7});
  assert(pool2);
  pool2->setStrideNd(DimsHW{1, 1});

  IFullyConnectedLayer
      *fc1 = network->addFullyConnected(*pool2->getOutput(0), 1000, weight_map["fc.weight"], weight_map["fc.bias"]);
  assert(fc1);

  fc1->getOutput(0)->setName(OUTPUT_BLOB_NAME);
  ::std::clog << "set name out" << ::std::endl;
  network->markOutput(*fc1->getOutput(0));

  // Build engine
  _builder->setMaxBatchSize(_max_batch_size);
  _config->setMaxWorkspaceSize(1 << 20);
  ICudaEngine *engine = _builder->buildEngineWithConfig(*network, *_config);
  ::std::clog << "build out" << ::std::endl;

  // Don't need the network anymore
  network->destroy();

  // Release host memory
  for (auto &mem: weight_map) {
    free((void *) (mem.second.values));
  }

  return engine;
}

// Load weights from files shared with TensorRT samples.
// TensorRT weight files have a simple space delimited format:
// [type] [size] <data x size in hex>
::std::map<::std::string, Weights> bugu::Resnet::v18::Resnet::LoadWeights(const ::std::string _file_name) {
  ::std::clog << "Loading weights: " << _file_name << ::std::endl;
  ::std::map<::std::string, Weights> weight_map;

  // Open weights file
  ::std::ifstream input(_file_name);
  assert(input.is_open() && "Unable to load weight file.");

  // Read number of weight blobs
  int32_t count;
  input >> count;
  assert(count > 0 && "Invalid weight map file.");

  while (count--) {
    Weights wt{DataType::kFLOAT, nullptr, 0};
    uint32_t size;

    // Read name and type of blob
    ::std::string name;
    input >> name >> ::std::dec >> size;
    wt.type = DataType::kFLOAT;

    // Load blob
    auto *val = reinterpret_cast<uint32_t *>(malloc(sizeof(val) * size));
    for (uint32_t x = 0, y = size; x < y; ++x) {
      input >> ::std::hex >> val[x];
    }
    wt.values = val;

    wt.count = size;
    weight_map[name] = wt;
  }

  return weight_map;
}

IScaleLayer *bugu::Resnet::v18::Resnet::AddBatchNorm2d(INetworkDefinition *_network,
                                                       ::std::map<::std::string, Weights> &_weight_map,
                                                       ITensor &_input,
                                                       ::std::string _layer_name,
                                                       float _eps) {
  float *gamma = (float *) _weight_map[_layer_name + ".weight"].values;
  float *beta = (float *) _weight_map[_layer_name + ".bias"].values;
  float *mean = (float *) _weight_map[_layer_name + ".running_mean"].values;
  float *var = (float *) _weight_map[_layer_name + ".running_var"].values;
  int len = _weight_map[_layer_name + ".running_var"].count;
  ::std::clog << "len " << len << ::std::endl;

  auto scval = reinterpret_cast<float *>(malloc(sizeof(float) * len));
  for (int i = 0; i < len; i++) {
    scval[i] = gamma[i] / ::std::sqrt(var[i] + _eps);
  }
  Weights scale{DataType::kFLOAT, scval, len};

  auto shval = reinterpret_cast<float *>(malloc(sizeof(float) * len));
  for (int i = 0; i < len; i++) {
    shval[i] = beta[i] - mean[i] * gamma[i] / ::std::sqrt(var[i] + _eps);
  }
  Weights shift{DataType::kFLOAT, shval, len};

  auto pval = reinterpret_cast<float *>(malloc(sizeof(float) * len));
  for (int i = 0; i < len; i++) {
    pval[i] = 1.0;
  }
  Weights power{DataType::kFLOAT, pval, len};

  _weight_map[_layer_name + ".scale"] = scale;
  _weight_map[_layer_name + ".shift"] = shift;
  _weight_map[_layer_name + ".power"] = power;
  IScaleLayer *scale_1 = _network->addScale(_input, ScaleMode::kCHANNEL, shift, scale, power);
  assert(scale_1);
  return scale_1;
}

IActivationLayer *bugu::Resnet::v18::Resnet::BasicBlock(INetworkDefinition *_network,
                                                        ::std::map<::std::string, Weights> &_weight_map,
                                                        ITensor &_input,
                                                        int _in_ch,
                                                        int _out_ch,
                                                        int _stride,
                                                        ::std::string _layer_name) {
  Weights empty_wts{DataType::kFLOAT, nullptr, 0};

  IConvolutionLayer *conv1 =
      _network->addConvolutionNd(_input, _out_ch, DimsHW{3, 3}, _weight_map[_layer_name + "conv1.weight"], empty_wts);
  assert(conv1);
  conv1->setStrideNd(DimsHW{_stride, _stride});
  conv1->setPaddingNd(DimsHW{1, 1});

  IScaleLayer *bn1 = AddBatchNorm2d(_network, _weight_map, *conv1->getOutput(0), _layer_name + "bn1", 1e-5);

  IActivationLayer *relu1 = _network->addActivation(*bn1->getOutput(0), ActivationType::kRELU);
  assert(relu1);

  IConvolutionLayer *conv2 = _network->addConvolutionNd(*relu1->getOutput(0),
                                                        _out_ch,
                                                        DimsHW{3, 3},
                                                        _weight_map[_layer_name + "conv2.weight"],
                                                        empty_wts);
  assert(conv2);
  conv2->setPaddingNd(DimsHW{1, 1});

  IScaleLayer *bn2 = AddBatchNorm2d(_network, _weight_map, *conv2->getOutput(0), _layer_name + "bn2", 1e-5);

  IElementWiseLayer *ew1;
  if (_in_ch != _out_ch) {
    IConvolutionLayer *conv3 = _network->addConvolutionNd(_input,
                                                          _out_ch,
                                                          DimsHW{1, 1},
                                                          _weight_map[_layer_name + "downsample.0.weight"],
                                                          empty_wts);
    assert(conv3);
    conv3->setStrideNd(DimsHW{_stride, _stride});

    IScaleLayer *bn3 = AddBatchNorm2d(_network, _weight_map, *conv3->getOutput(0), _layer_name + "downsample.1", 1e-5);

    ew1 = _network->addElementWise(*bn3->getOutput(0), *bn2->getOutput(0), ElementWiseOperation::kSUM);
  } else {
    ew1 = _network->addElementWise(_input, *bn2->getOutput(0), ElementWiseOperation::kSUM);
  }

  IActivationLayer *relu2 = _network->addActivation(*ew1->getOutput(0), ActivationType::kRELU);
  assert(relu2);
  return relu2;
}

int main(int argc, char **argv) {
  if (argc != 2) {
    std::cerr << "arguments not right!" << std::endl;
    std::cerr << "./resnet18 -s   // serialize model to plan file" << std::endl;
    std::cerr << "./resnet18 -d   // deserialize plan file and run inference" << std::endl;
    return -1;
  }

  // create a model using the API directly and serialize it to a stream
  char *trtModelStream{nullptr};
  size_t size{0};

  if (std::string(argv[1]) == "-s") {
    IHostMemory *modelStream{nullptr};
    APIToModel(1, &modelStream);
    assert(modelStream != nullptr);

    std::ofstream p("resnet18.engine", std::ios::binary);
    if (!p) {
      std::cerr << "could not open plan output file" << std::endl;
      return -1;
    }
    p.write(reinterpret_cast<const char *>(modelStream->data()), modelStream->size());
    modelStream->destroy();
    return 1;
  } else if (std::string(argv[1]) == "-d") {
    std::ifstream file("resnet18.engine", std::ios::binary);
    if (file.good()) {
      file.seekg(0, file.end);
      size = file.tellg();
      file.seekg(0, file.beg);
      trtModelStream = new char[size];
      assert(trtModelStream);
      file.read(trtModelStream, size);
      file.close();
    }
  } else {
    return -1;
  }


  // Subtract mean from image
  static float data[3 * INPUT_H * INPUT_W];
  for (int i = 0; i < 3 * INPUT_H * INPUT_W; i++)
    data[i] = 1.0;

  IRuntime *runtime = createInferRuntime(gLogger);
  assert(runtime != nullptr);
  ICudaEngine *engine = runtime->deserializeCudaEngine(trtModelStream, size, nullptr);
  assert(engine != nullptr);
  IExecutionContext *context = engine->createExecutionContext();
  assert(context != nullptr);
  delete[] trtModelStream;

  // Run inference
  static float prob[OUTPUT_SIZE];
  for (int i = 0; i < 100; i++) {
    auto start = std::chrono::system_clock::now();
    doInference(*context, data, prob, 1);
    auto end = std::chrono::system_clock::now();
    std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;
  }

  // Destroy the engine
  context->destroy();
  engine->destroy();
  runtime->destroy();

  // Print histogram of the output distribution
  std::cout << "\nOutput:\n\n";
  for (unsigned int i = 0; i < 10; i++) {
    std::cout << prob[i] << ", ";
  }
  std::cout << std::endl;
  for (unsigned int i = 0; i < 10; i++) {
    std::cout << prob[OUTPUT_SIZE - 10 + i] << ", ";
  }
  std::cout << std::endl;

  return 0;
}

```

`app/detect/service/src/CMakeLists.txt`:

```txt
# Threads
find_package(Threads REQUIRED)
if (Threads_FOUND)
    message("")
endif ()

# OpenSSL
set(OPENSSL_USE_STATIC_LIBS true)
find_package(OpenSSL REQUIRED)
if (OPENSSL_FOUND)
    message(STATUS "OPENSSL_VERSION = ${OPENSSL_VERSION}")
    message(STATUS "OPENSSL_INCLUDE_DIR = ${OPENSSL_INCLUDE_DIR}")
    message(STATUS "OPENSSL_LIBRARIES = ${OPENSSL_LIBRARIES}")
endif ()

# Protobuf
set(protobuf_MODULE_COMPATIBLE TRUE)
find_package(Protobuf REQUIRED)
if (Protobuf_FOUND)
    message(STATUS "Protobuf_VERSION = ${Protobuf_VERSION}")
    message(STATUS "Protobuf_INCLUDE_DIRS = ${Protobuf_INCLUDE_DIRS}")
    message(STATUS "Protobuf_LIBRARY = ${Protobuf_LIBRARY}")
endif ()

# gRPC
find_package(gRPC CONFIG REQUIRED)
if (gRPC_FOUND)
    message(STATUS "gRPC_VERSION = ${gRPC_VERSION}")
endif ()

include_directories(../include)
include_directories(${PROJECT_SOURCE_DIR}/resnet/include)
include_directories(../../../..)
file(GLOB ProjectSRC
        "../../../../api/detect/service/v1/cpp/*.cc"
        "../../../../api/detect/service/v1/cpp/*.h"
        "thread_pool/*.cc"
        "thread/*.cc"
        "utils/*.cc"
        "data/*.cc"
        "conf/*.cc"
        "*.cc")

add_executable(${PROJECT_NAME} ${ProjectSRC})
target_link_libraries(${PROJECT_NAME}
        Threads::Threads
        protobuf::libprotobuf
        gRPC::grpc++_reflection
        gRPC::grpc++
        obfusion-static)

```

`app/detect/service/src/bugu_detect_impl.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#include "bugu_dectet/bugu_detect.h"
#include "bugu_detect_impl.h"
#include "data/data.h"
#include "thread_pool/x_thread_pool.h"

#include <cstring>
#include <string>

::grpc::Status bugu::BuguDetectImpl::Detect(::grpc::ServerContext *_ctx,
                                            const ::bugu_detect::service::v1::DetectRequest *_request,
                                            ::bugu_detect::service::v1::DetectReply *_response) {
  auto size = _request->size();

  auto data = ::bugu::Data::Make(memory_resource_);
  auto buffer = static_cast<char *>(data->New(size));

  ::std::size_t read_bytes;
  ::std::size_t total_read_bytes = 0;

  // Copy the data from request to buffer
  for (auto &d: _request->data()) {
    read_bytes = d.size();
    memcpy(buffer + total_read_bytes, d.data(), read_bytes);
    total_read_bytes += read_bytes;
  }
  BUGU_ASSERT(total_read_bytes == size && "total_read_bytes != size");

//  return {::grpc::StatusCode::UNIMPLEMENTED, "method Obfusion not implemented"};
  return ::grpc::Status::OK;
}

```

`app/detect/service/src/bugu_detect_impl.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_BUGU_DETECT_IMPL_H_
#define BUGU_DETECT_SERVICE_SRC_BUGU_DETECT_IMPL_H_

#include "api/detect/service/v1/cpp/detect.grpc.pb.h"

#include <grpc++/grpc++.h>
#include <memory_resource>
#include <memory>
#include <thread>

namespace bugu {

class XThreadPool;

class BuguDetectImpl final : public bugu_detect::service::v1::BuguDetect::Service {
 private:
  ::bugu::XThreadPool *thread_pool_;  ///< 线程池
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

 public:
  explicit BuguDetectImpl(::bugu::XThreadPool *_thread_pool,
                          ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource)
      : thread_pool_(_thread_pool), memory_resource_(::std::move(_memory_resource)) {};

  ::grpc::Status Detect(::grpc::ServerContext *_ctx,
                        const ::bugu_detect::service::v1::DetectRequest *_request,
                        ::bugu_detect::service::v1::DetectReply *_response) override;
};

} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_BUGU_DETECT_IMPL_H_

```

`app/detect/service/src/bugu_detect_server.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#include "bugu_detect_server.h"
#include "bugu_detect_impl.h"
#include "thread_pool/x_thread_pool.h"
//#include "utils/credentials.h"

#if BUGU_DEBUG
#include <string>
#endif
#include <utility>

bugu::BuguDetectServer::~BuguDetectServer() {
  if (IsRunning()) { Stop(); }
}

bugu::BuguDetectServer *bugu::BuguDetectServer::Init(::std::string _local_address,
                                                     ::bugu::XThreadPool *_thread_pool,
                                                     ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource) {
  // The thread pool and Grpc service are initialized only once
  if (!init_flag()) {
    local_address_ = ::std::move(_local_address);
    thread_pool_ = _thread_pool;
    memory_resource_ = ::std::move(_memory_resource);
    set_init_flag(true);
  }

  return this;
}

void bugu::BuguDetectServer::Start() {
  BUGU_ASSERT(init_flag() && "BuguDetectServer should init first");
  XThread::Start();
}

void bugu::BuguDetectServer::Stop() {
  ::std::function<void()> func = [this]() {
    server_->Shutdown();
  };
  StopWith(func);
}

void bugu::BuguDetectServer::Main() {
  BuguDetectImpl bugu_obfusion_service(thread_pool_, memory_resource_);

  ::grpc::ServerBuilder builder;
  builder.AddListeningPort(local_address_, ::grpc::InsecureServerCredentials());
  builder.RegisterService(&bugu_obfusion_service);

  ::std::unique_ptr<::grpc::Server> server(builder.BuildAndStart());
  server_ = ::std::move(server);

  ::std::clog << "BuguDetectServer listening on " << local_address_ << ::std::endl;

  server_->Wait();

  ::std::clog << "BuguDetectServer Shut Down" << ::std::endl;
}

void bugu::BuguDetectServer::set_init_flag(bool _init_flag) {
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);
  init_flag_ = _init_flag;
}

bool bugu::BuguDetectServer::init_flag() {
  ::std::shared_lock<::std::shared_mutex> lock(mutex_);
  return init_flag_;
}

```

`app/detect/service/src/bugu_detect_server.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_BUGU_DETECT_SERVER_H_
#define BUGU_DETECT_SERVICE_SRC_BUGU_DETECT_SERVER_H_

#include "bugu_dectet/bugu_detect.h"
#include "thread/x_thread.h"

#include <grpc++/grpc++.h>

#include <condition_variable>
#include <memory>
#include <memory_resource>
#include <mutex>
#include <utility>

namespace bugu {

class XThreadPool;

class BuguDetectServer final : public XThread {
 private:
  bool init_flag_ = false;

  ::std::string local_address_{};  ///< rpc 服务地址：ip+端口
  ::std::unique_ptr<::grpc::Server> server_{};  ///< rpc 服务句柄，用智能指针管理

  ::bugu::XThreadPool *thread_pool_ = nullptr;  ///< 线程池
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

  ::std::shared_mutex mutex_;

 public:
  ~BuguDetectServer();
  static BuguDetectServer *Get() {
    static BuguDetectServer s;
    return &s;
  }

 private:
  BuguDetectServer() = default;

 public:
  BuguDetectServer *Init(::std::string _local_address,
                         ::bugu::XThreadPool *_thread_pool,
                         ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource);

  void Start() override;

  void Main() override;

  void Stop() override;

  void set_init_flag(bool _init_flag);

  bool init_flag();
};

} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_BUGU_DETECT_SERVER_H_

```

`app/detect/service/src/conf/conf.pb.cc`:

```cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conf.proto

#include "conf.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace config {
constexpr Bootstrap::Bootstrap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : server_(nullptr){}
struct BootstrapDefaultTypeInternal {
  constexpr BootstrapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BootstrapDefaultTypeInternal() {}
  union {
    Bootstrap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
constexpr Server_GRPC::Server_GRPC(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : network_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , addr_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , timeout_(nullptr){}
struct Server_GRPCDefaultTypeInternal {
  constexpr Server_GRPCDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Server_GRPCDefaultTypeInternal() {}
  union {
    Server_GRPC _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Server_GRPCDefaultTypeInternal _Server_GRPC_default_instance_;
constexpr Server::Server(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : grpc_(nullptr){}
struct ServerDefaultTypeInternal {
  constexpr ServerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServerDefaultTypeInternal() {}
  union {
    Server _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServerDefaultTypeInternal _Server_default_instance_;
}  // namespace config
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_conf_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_conf_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_conf_2eproto = nullptr;

const uint32_t TableStruct_conf_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Bootstrap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Bootstrap, server_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, network_),
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, addr_),
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, timeout_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Server, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Server, grpc_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::config::Bootstrap)},
  { 7, -1, -1, sizeof(::config::Server_GRPC)},
  { 16, -1, -1, sizeof(::config::Server)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Bootstrap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Server_GRPC_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Server_default_instance_),
};

const char descriptor_table_protodef_conf_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\nconf.proto\022\006config\032\036google/protobuf/du"
  "ration.proto\"+\n\tBootstrap\022\036\n\006server\030\001 \001("
  "\0132\016.config.Server\"~\n\006Server\022!\n\004grpc\030\001 \001("
  "\0132\023.config.Server.GRPC\032Q\n\004GRPC\022\017\n\007networ"
  "k\030\001 \001(\t\022\014\n\004addr\030\002 \001(\t\022*\n\007timeout\030\003 \001(\0132\031"
  ".google.protobuf.Durationb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_conf_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_conf_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_conf_2eproto = {
  false, false, 233, descriptor_table_protodef_conf_2eproto, "conf.proto", 
  &descriptor_table_conf_2eproto_once, descriptor_table_conf_2eproto_deps, 1, 3,
  schemas, file_default_instances, TableStruct_conf_2eproto::offsets,
  file_level_metadata_conf_2eproto, file_level_enum_descriptors_conf_2eproto, file_level_service_descriptors_conf_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_conf_2eproto_getter() {
  return &descriptor_table_conf_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_conf_2eproto(&descriptor_table_conf_2eproto);
namespace config {

// ===================================================================

class Bootstrap::_Internal {
 public:
  static const ::config::Server& server(const Bootstrap* msg);
};

const ::config::Server&
Bootstrap::_Internal::server(const Bootstrap* msg) {
  return *msg->server_;
}
Bootstrap::Bootstrap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Bootstrap)
}
Bootstrap::Bootstrap(const Bootstrap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_server()) {
    server_ = new ::config::Server(*from.server_);
  } else {
    server_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Bootstrap)
}

inline void Bootstrap::SharedCtor() {
server_ = nullptr;
}

Bootstrap::~Bootstrap() {
  // @@protoc_insertion_point(destructor:config.Bootstrap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Bootstrap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete server_;
}

void Bootstrap::ArenaDtor(void* object) {
  Bootstrap* _this = reinterpret_cast< Bootstrap* >(object);
  (void)_this;
}
void Bootstrap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Bootstrap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Bootstrap::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Bootstrap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && server_ != nullptr) {
    delete server_;
  }
  server_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bootstrap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .config.Server server = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_server(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Bootstrap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Bootstrap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .config.Server server = 1;
  if (this->_internal_has_server()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::server(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Bootstrap)
  return target;
}

size_t Bootstrap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Bootstrap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .config.Server server = 1;
  if (this->_internal_has_server()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *server_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bootstrap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Bootstrap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bootstrap::GetClassData() const { return &_class_data_; }

void Bootstrap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Bootstrap *>(to)->MergeFrom(
      static_cast<const Bootstrap &>(from));
}


void Bootstrap::MergeFrom(const Bootstrap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Bootstrap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_server()) {
    _internal_mutable_server()->::config::Server::MergeFrom(from._internal_server());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bootstrap::CopyFrom(const Bootstrap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Bootstrap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bootstrap::IsInitialized() const {
  return true;
}

void Bootstrap::InternalSwap(Bootstrap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(server_, other->server_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Bootstrap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[0]);
}

// ===================================================================

class Server_GRPC::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Duration& timeout(const Server_GRPC* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Duration&
Server_GRPC::_Internal::timeout(const Server_GRPC* msg) {
  return *msg->timeout_;
}
void Server_GRPC::clear_timeout() {
  if (GetArenaForAllocation() == nullptr && timeout_ != nullptr) {
    delete timeout_;
  }
  timeout_ = nullptr;
}
Server_GRPC::Server_GRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Server.GRPC)
}
Server_GRPC::Server_GRPC(const Server_GRPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_network().empty()) {
    network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_network(), 
      GetArenaForAllocation());
  }
  addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_addr().empty()) {
    addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_addr(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_timeout()) {
    timeout_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from.timeout_);
  } else {
    timeout_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Server.GRPC)
}

inline void Server_GRPC::SharedCtor() {
network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
timeout_ = nullptr;
}

Server_GRPC::~Server_GRPC() {
  // @@protoc_insertion_point(destructor:config.Server.GRPC)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Server_GRPC::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  network_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  addr_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete timeout_;
}

void Server_GRPC::ArenaDtor(void* object) {
  Server_GRPC* _this = reinterpret_cast< Server_GRPC* >(object);
  (void)_this;
}
void Server_GRPC::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Server_GRPC::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Server_GRPC::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Server.GRPC)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  network_.ClearToEmpty();
  addr_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && timeout_ != nullptr) {
    delete timeout_;
  }
  timeout_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Server_GRPC::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string network = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_network();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "config.Server.GRPC.network"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string addr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_addr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "config.Server.GRPC.addr"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Duration timeout = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timeout(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Server_GRPC::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Server.GRPC)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string network = 1;
  if (!this->_internal_network().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_network().data(), static_cast<int>(this->_internal_network().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "config.Server.GRPC.network");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_network(), target);
  }

  // string addr = 2;
  if (!this->_internal_addr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_addr().data(), static_cast<int>(this->_internal_addr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "config.Server.GRPC.addr");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_addr(), target);
  }

  // .google.protobuf.Duration timeout = 3;
  if (this->_internal_has_timeout()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::timeout(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Server.GRPC)
  return target;
}

size_t Server_GRPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Server.GRPC)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string network = 1;
  if (!this->_internal_network().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_network());
  }

  // string addr = 2;
  if (!this->_internal_addr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_addr());
  }

  // .google.protobuf.Duration timeout = 3;
  if (this->_internal_has_timeout()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *timeout_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Server_GRPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Server_GRPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Server_GRPC::GetClassData() const { return &_class_data_; }

void Server_GRPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Server_GRPC *>(to)->MergeFrom(
      static_cast<const Server_GRPC &>(from));
}


void Server_GRPC::MergeFrom(const Server_GRPC& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Server.GRPC)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_network().empty()) {
    _internal_set_network(from._internal_network());
  }
  if (!from._internal_addr().empty()) {
    _internal_set_addr(from._internal_addr());
  }
  if (from._internal_has_timeout()) {
    _internal_mutable_timeout()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_timeout());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Server_GRPC::CopyFrom(const Server_GRPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Server.GRPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Server_GRPC::IsInitialized() const {
  return true;
}

void Server_GRPC::InternalSwap(Server_GRPC* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &network_, lhs_arena,
      &other->network_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &addr_, lhs_arena,
      &other->addr_, rhs_arena
  );
  swap(timeout_, other->timeout_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Server_GRPC::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[1]);
}

// ===================================================================

class Server::_Internal {
 public:
  static const ::config::Server_GRPC& grpc(const Server* msg);
};

const ::config::Server_GRPC&
Server::_Internal::grpc(const Server* msg) {
  return *msg->grpc_;
}
Server::Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Server)
}
Server::Server(const Server& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_grpc()) {
    grpc_ = new ::config::Server_GRPC(*from.grpc_);
  } else {
    grpc_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Server)
}

inline void Server::SharedCtor() {
grpc_ = nullptr;
}

Server::~Server() {
  // @@protoc_insertion_point(destructor:config.Server)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Server::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete grpc_;
}

void Server::ArenaDtor(void* object) {
  Server* _this = reinterpret_cast< Server* >(object);
  (void)_this;
}
void Server::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Server::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Server::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Server)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && grpc_ != nullptr) {
    delete grpc_;
  }
  grpc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Server::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .config.Server.GRPC grpc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_grpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Server::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Server)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .config.Server.GRPC grpc = 1;
  if (this->_internal_has_grpc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::grpc(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Server)
  return target;
}

size_t Server::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Server)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .config.Server.GRPC grpc = 1;
  if (this->_internal_has_grpc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *grpc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Server::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Server::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Server::GetClassData() const { return &_class_data_; }

void Server::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Server *>(to)->MergeFrom(
      static_cast<const Server &>(from));
}


void Server::MergeFrom(const Server& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Server)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_grpc()) {
    _internal_mutable_grpc()->::config::Server_GRPC::MergeFrom(from._internal_grpc());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Server::CopyFrom(const Server& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Server)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Server::IsInitialized() const {
  return true;
}

void Server::InternalSwap(Server* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(grpc_, other->grpc_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Server::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[2]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace config
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::config::Bootstrap* Arena::CreateMaybeMessage< ::config::Bootstrap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Bootstrap >(arena);
}
template<> PROTOBUF_NOINLINE ::config::Server_GRPC* Arena::CreateMaybeMessage< ::config::Server_GRPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Server_GRPC >(arena);
}
template<> PROTOBUF_NOINLINE ::config::Server* Arena::CreateMaybeMessage< ::config::Server >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Server >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

```

`app/detect/service/src/conf/conf.pb.h`:

```h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_conf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_conf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_conf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_conf_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_conf_2eproto;
namespace config {
class Bootstrap;
struct BootstrapDefaultTypeInternal;
extern BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
class Server;
struct ServerDefaultTypeInternal;
extern ServerDefaultTypeInternal _Server_default_instance_;
class Server_GRPC;
struct Server_GRPCDefaultTypeInternal;
extern Server_GRPCDefaultTypeInternal _Server_GRPC_default_instance_;
}  // namespace config
PROTOBUF_NAMESPACE_OPEN
template<> ::config::Bootstrap* Arena::CreateMaybeMessage<::config::Bootstrap>(Arena*);
template<> ::config::Server* Arena::CreateMaybeMessage<::config::Server>(Arena*);
template<> ::config::Server_GRPC* Arena::CreateMaybeMessage<::config::Server_GRPC>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace config {

// ===================================================================

class Bootstrap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Bootstrap) */ {
 public:
  inline Bootstrap() : Bootstrap(nullptr) {}
  ~Bootstrap() override;
  explicit constexpr Bootstrap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bootstrap(const Bootstrap& from);
  Bootstrap(Bootstrap&& from) noexcept
    : Bootstrap() {
    *this = ::std::move(from);
  }

  inline Bootstrap& operator=(const Bootstrap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bootstrap& operator=(Bootstrap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bootstrap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bootstrap* internal_default_instance() {
    return reinterpret_cast<const Bootstrap*>(
               &_Bootstrap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Bootstrap& a, Bootstrap& b) {
    a.Swap(&b);
  }
  inline void Swap(Bootstrap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bootstrap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bootstrap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bootstrap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bootstrap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bootstrap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bootstrap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Bootstrap";
  }
  protected:
  explicit Bootstrap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 1,
  };
  // .config.Server server = 1;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::config::Server& server() const;
  PROTOBUF_NODISCARD ::config::Server* release_server();
  ::config::Server* mutable_server();
  void set_allocated_server(::config::Server* server);
  private:
  const ::config::Server& _internal_server() const;
  ::config::Server* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::config::Server* server);
  ::config::Server* unsafe_arena_release_server();

  // @@protoc_insertion_point(class_scope:config.Bootstrap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::config::Server* server_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server_GRPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Server.GRPC) */ {
 public:
  inline Server_GRPC() : Server_GRPC(nullptr) {}
  ~Server_GRPC() override;
  explicit constexpr Server_GRPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server_GRPC(const Server_GRPC& from);
  Server_GRPC(Server_GRPC&& from) noexcept
    : Server_GRPC() {
    *this = ::std::move(from);
  }

  inline Server_GRPC& operator=(const Server_GRPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server_GRPC& operator=(Server_GRPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server_GRPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server_GRPC* internal_default_instance() {
    return reinterpret_cast<const Server_GRPC*>(
               &_Server_GRPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Server_GRPC& a, Server_GRPC& b) {
    a.Swap(&b);
  }
  inline void Swap(Server_GRPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server_GRPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server_GRPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server_GRPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server_GRPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Server_GRPC& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server_GRPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Server.GRPC";
  }
  protected:
  explicit Server_GRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkFieldNumber = 1,
    kAddrFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string network = 1;
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // .google.protobuf.Duration timeout = 3;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // @@protoc_insertion_point(class_scope:config.Server.GRPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::Duration* timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Server) */ {
 public:
  inline Server() : Server(nullptr) {}
  ~Server() override;
  explicit constexpr Server(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server(const Server& from);
  Server(Server&& from) noexcept
    : Server() {
    *this = ::std::move(from);
  }

  inline Server& operator=(const Server& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server& operator=(Server&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server* internal_default_instance() {
    return reinterpret_cast<const Server*>(
               &_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Server& a, Server& b) {
    a.Swap(&b);
  }
  inline void Swap(Server* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Server& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Server";
  }
  protected:
  explicit Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Server_GRPC GRPC;

  // accessors -------------------------------------------------------

  enum : int {
    kGrpcFieldNumber = 1,
  };
  // .config.Server.GRPC grpc = 1;
  bool has_grpc() const;
  private:
  bool _internal_has_grpc() const;
  public:
  void clear_grpc();
  const ::config::Server_GRPC& grpc() const;
  PROTOBUF_NODISCARD ::config::Server_GRPC* release_grpc();
  ::config::Server_GRPC* mutable_grpc();
  void set_allocated_grpc(::config::Server_GRPC* grpc);
  private:
  const ::config::Server_GRPC& _internal_grpc() const;
  ::config::Server_GRPC* _internal_mutable_grpc();
  public:
  void unsafe_arena_set_allocated_grpc(
      ::config::Server_GRPC* grpc);
  ::config::Server_GRPC* unsafe_arena_release_grpc();

  // @@protoc_insertion_point(class_scope:config.Server)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::config::Server_GRPC* grpc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Bootstrap

// .config.Server server = 1;
inline bool Bootstrap::_internal_has_server() const {
  return this != internal_default_instance() && server_ != nullptr;
}
inline bool Bootstrap::has_server() const {
  return _internal_has_server();
}
inline void Bootstrap::clear_server() {
  if (GetArenaForAllocation() == nullptr && server_ != nullptr) {
    delete server_;
  }
  server_ = nullptr;
}
inline const ::config::Server& Bootstrap::_internal_server() const {
  const ::config::Server* p = server_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Server&>(
      ::config::_Server_default_instance_);
}
inline const ::config::Server& Bootstrap::server() const {
  // @@protoc_insertion_point(field_get:config.Bootstrap.server)
  return _internal_server();
}
inline void Bootstrap::unsafe_arena_set_allocated_server(
    ::config::Server* server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_);
  }
  server_ = server;
  if (server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Bootstrap.server)
}
inline ::config::Server* Bootstrap::release_server() {
  
  ::config::Server* temp = server_;
  server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Server* Bootstrap::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:config.Bootstrap.server)
  
  ::config::Server* temp = server_;
  server_ = nullptr;
  return temp;
}
inline ::config::Server* Bootstrap::_internal_mutable_server() {
  
  if (server_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Server>(GetArenaForAllocation());
    server_ = p;
  }
  return server_;
}
inline ::config::Server* Bootstrap::mutable_server() {
  ::config::Server* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:config.Bootstrap.server)
  return _msg;
}
inline void Bootstrap::set_allocated_server(::config::Server* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::config::Server>::GetOwningArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    
  } else {
    
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:config.Bootstrap.server)
}

// -------------------------------------------------------------------

// Server_GRPC

// string network = 1;
inline void Server_GRPC::clear_network() {
  network_.ClearToEmpty();
}
inline const std::string& Server_GRPC::network() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server_GRPC::set_network(ArgT0&& arg0, ArgT... args) {
 
 network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Server.GRPC.network)
}
inline std::string* Server_GRPC::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.network)
  return _s;
}
inline const std::string& Server_GRPC::_internal_network() const {
  return network_.Get();
}
inline void Server_GRPC::_internal_set_network(const std::string& value) {
  
  network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Server_GRPC::_internal_mutable_network() {
  
  return network_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Server_GRPC::release_network() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.network)
  return network_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Server_GRPC::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  network_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), network,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.network)
}

// string addr = 2;
inline void Server_GRPC::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& Server_GRPC::addr() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server_GRPC::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Server.GRPC.addr)
}
inline std::string* Server_GRPC::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.addr)
  return _s;
}
inline const std::string& Server_GRPC::_internal_addr() const {
  return addr_.Get();
}
inline void Server_GRPC::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Server_GRPC::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Server_GRPC::release_addr() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Server_GRPC::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.addr)
}

// .google.protobuf.Duration timeout = 3;
inline bool Server_GRPC::_internal_has_timeout() const {
  return this != internal_default_instance() && timeout_ != nullptr;
}
inline bool Server_GRPC::has_timeout() const {
  return _internal_has_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Server_GRPC::_internal_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Server_GRPC::timeout() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.timeout)
  return _internal_timeout();
}
inline void Server_GRPC::unsafe_arena_set_allocated_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Server.GRPC.timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::release_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::_internal_mutable_timeout() {
  
  if (timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    timeout_ = p;
  }
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::mutable_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.timeout)
  return _msg;
}
inline void Server_GRPC::set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout));
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.timeout)
}

// -------------------------------------------------------------------

// Server

// .config.Server.GRPC grpc = 1;
inline bool Server::_internal_has_grpc() const {
  return this != internal_default_instance() && grpc_ != nullptr;
}
inline bool Server::has_grpc() const {
  return _internal_has_grpc();
}
inline void Server::clear_grpc() {
  if (GetArenaForAllocation() == nullptr && grpc_ != nullptr) {
    delete grpc_;
  }
  grpc_ = nullptr;
}
inline const ::config::Server_GRPC& Server::_internal_grpc() const {
  const ::config::Server_GRPC* p = grpc_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Server_GRPC&>(
      ::config::_Server_GRPC_default_instance_);
}
inline const ::config::Server_GRPC& Server::grpc() const {
  // @@protoc_insertion_point(field_get:config.Server.grpc)
  return _internal_grpc();
}
inline void Server::unsafe_arena_set_allocated_grpc(
    ::config::Server_GRPC* grpc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grpc_);
  }
  grpc_ = grpc;
  if (grpc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Server.grpc)
}
inline ::config::Server_GRPC* Server::release_grpc() {
  
  ::config::Server_GRPC* temp = grpc_;
  grpc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Server_GRPC* Server::unsafe_arena_release_grpc() {
  // @@protoc_insertion_point(field_release:config.Server.grpc)
  
  ::config::Server_GRPC* temp = grpc_;
  grpc_ = nullptr;
  return temp;
}
inline ::config::Server_GRPC* Server::_internal_mutable_grpc() {
  
  if (grpc_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Server_GRPC>(GetArenaForAllocation());
    grpc_ = p;
  }
  return grpc_;
}
inline ::config::Server_GRPC* Server::mutable_grpc() {
  ::config::Server_GRPC* _msg = _internal_mutable_grpc();
  // @@protoc_insertion_point(field_mutable:config.Server.grpc)
  return _msg;
}
inline void Server::set_allocated_grpc(::config::Server_GRPC* grpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete grpc_;
  }
  if (grpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::config::Server_GRPC>::GetOwningArena(grpc);
    if (message_arena != submessage_arena) {
      grpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grpc, submessage_arena);
    }
    
  } else {
    
  }
  grpc_ = grpc;
  // @@protoc_insertion_point(field_set_allocated:config.Server.grpc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_conf_2eproto

```

`app/detect/service/src/conf/conf.proto`:

```proto
syntax = "proto3";

package config;

import "google/protobuf/duration.proto";

message Bootstrap {
  Server server = 1;
}

message Server {
  message GRPC {
    string network = 1;
    string addr = 2;
    google.protobuf.Duration timeout = 3;
  }
  GRPC grpc = 1;
}

```

`app/detect/service/src/conf/config.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_CONF_CONFIG_H_
#define BUGU_DETECT_SERVICE_SRC_CONF_CONFIG_H_

#include "bugu_dectet//bugu_detect.h"
#include "conf.pb.h"

#include "google/protobuf/message.h"
#include "google/protobuf/util/json_util.h"

#include <cstdio>

#include <exception>

namespace bugu {

class Config {
 public:
  void Load(const char *_path);
  void Scan(::google::protobuf::Message *_message);

 private:
  void read(FILE *_in);

  ::std::string get_str() {
    return {buffer_.begin(), buffer_.end()};
  }

 private:
  std::vector<char> buffer_;
};

inline void Config::Load(const char *_path) {
  FILE *input;
#if BUGU_WINDOWS
  fopen_s(&input, _path, "r");
#elif BUGU_LINUX || BUGU_APPLE
  input = fopen(_path, "r");
#endif
  if (input == nullptr) { exit(EXIT_FAILURE); }
  read(input);
  fclose(input);
}

inline void Config::read(FILE *_in) {
  char buf[65536];
  if (!buffer_.empty()) { buffer_.clear(); }
  while (true) {
    size_t n = fread(buf, 1, sizeof(buf), _in);
    if (n == 0) { break; }
    buffer_.insert(buffer_.end(), buf, buf + n);
  }
}

void Config::Scan(::google::protobuf::Message *_message) {
  if (!google::protobuf::util::JsonStringToMessage(get_str(), _message).ok()) {
    throw ::std::runtime_error("Parse json data to message failed");
  }
}

} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_CONF_CONFIG_H_

```

`app/detect/service/src/data/data.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#include "bugu_dectet/bugu_detect.h"
#include "data.h"

bugu::Data::Data() = default;

bugu::Data::~Data() {
  // 内存池未定义或没有数据就不用释放
  if (nullptr == memory_resource_ || nullptr == data_) {
    return;
  }

  // 释放分配的内存
  memory_resource_->deallocate(data_, memory_size_);
  data_ = nullptr;
  memory_size_ = 0;
  size_ = 0;
}

/**
 * @brief 创建 Data 对象
 * @param _memory_resource 内存池对象
 * @return Data 的智能指针对象
 */
::std::shared_ptr<bugu::Data> bugu::Data::Make(::std::shared_ptr<::std::pmr::memory_resource> _memory_resource) {
  // 创建 Data 的智能指针对象
  ::std::shared_ptr<Data> data_ptr(new bugu::Data());
  data_ptr->memory_resource_ = ::std::move(_memory_resource);

  return data_ptr;
}

/**
 * @brief 创建内存空间
 * @param _memory_size 占用内存字节数
 * @return 创建的内存空间的指针，创建失败为空 nullptr
 */
void *bugu::Data::New(::std::size_t _memory_size) {
  BUGU_ASSERT(_memory_size > 0 && "Data::New _memory_size <= 0");

  // 异常处理
  if (nullptr == memory_resource_) {
    return nullptr;
  }

  // 申请空间
  data_ = memory_resource_->allocate(_memory_size);

  memory_size_ = _memory_size;
  size_ = _memory_size;

  return data_;
}

/**
 * @brief 获取数据块的指针
 * @return 数据块的指针
 */
void *bugu::Data::data() const {
  return data_;
}

/**
 * @brief 获取实际数据的字节数
 * @return 实际数据的字节数
 */
::std::size_t bugu::Data::size() const {
  return size_;
}

/**
 * @brief 设置实际数据字节数
 * @param size 实际数据字节数
 */
void bugu::Data::set_size(::std::size_t _size) {
  size_ = _size;
}

/**
 * @brief 获取分配的内存大小
 * @return ::std::size_t 分配的内存大小
 */
::std::size_t bugu::Data::memory_size() const {
  return memory_size_;
}

/**
 * @brief 是否是文件结尾
 * @return true or false
 */
bool bugu::Data::end() const {
  return end_;
}

/**
 * @brief 设置为文件结尾
 * @param _end true or false
 */
void bugu::Data::set_end(bool _end) {
  end_ = _end;
}


```

`app/detect/service/src/data/data.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_DATA_DATA_H_
#define BUGU_DETECT_SERVICE_SRC_DATA_DATA_H_

#include <memory>
#include <memory_resource>

namespace bugu {

/**
 * @brief 内存池数据块
 */
class Data {
 private:
  void *data_ = nullptr;
  bool end_ = false;        ///< 是否是文件结尾
  ::std::size_t size_ = 0;         ///< 数据字节数
  ::std::size_t memory_size_ = 0;  ///< 申请内存空间字节数
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

 private:
  Data();

 public:
  ~Data();

  /**
   * @brief 创建 Data 对象
   * @param _memory_resource
   * @return Data 的智能指针对象
   */
  static ::std::shared_ptr<Data> Make(::std::shared_ptr<::std::pmr::memory_resource> _memory_resource);

  /**
   * @brief 创建内存空间
   * @param _memory_size 占用内存字节数
   * @return 创建的内存空间的指针，创建失败为空 nullptr
   */
  void *New(::std::size_t _memory_size);

  /**
   * @brief 获取数据块的指针
   * @return 数据块的指针
   */
  [[nodiscard]] void *data() const;

  /**
   * @brief 获取实际数据的字节数
   * @return 实际数据的字节数
   */
  [[nodiscard]] ::std::size_t size() const;

  /**
   * @brief 设置实际数据字节数
   * @param size 实际数据字节数
   */
  void set_size(::std::size_t _size);

  /**
   * @brief 获取分配的内存大小
   * @return ::std::size_t 分配的内存大小
   */
  [[nodiscard]] ::std::size_t memory_size() const;

  /**
   * @brief 是否是文件结尾
   * @return
   */
  [[nodiscard]] bool end() const;

  /**
   * @brief 设置为文件结尾
   * @param _end true or false
   */
  void set_end(bool _end);
};

/**
 * @brief 定义了 Byte、KB、MB、GB 的大小
 */
enum class Unit : ::std::size_t {
  Byte = 1, KB = 1024 * Byte, MB = 1024 * KB, GB = 1024 * MB
};

/**
 * @brief 将字节的大小换算成对应单位的大小
 * @tparam size_type 输入类型，只能为算术类型
 * @param _size 字节大小
 * @param _unit 转换的单位
 * @return 转换后的数值
 */
template<typename size_type,
    class = typename ::std::enable_if<
        ::std::is_arithmetic<size_type>::value>::type
>
double UnitConvert(size_type _size, Unit _unit) {
  return _size / static_cast<double>(_unit);
}

constexpr ::std::size_t KB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::KB) * _size;
}

constexpr ::std::size_t MB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::MB) * _size;
}

constexpr ::std::size_t GB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::GB) * _size;
}

} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_DATA_DATA_H_

```

`app/detect/service/src/main.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#include "bugu_dectet/bugu_detect.h"
#include "bugu_detect_server.h"
#include "conf/config.h"
#include "thread_pool/x_thread_pool.h"
#include "utils/interrupt_sleeper.h"

#include <cstdio>
#include <csignal>

#include <memory_resource>
#include <memory>
#include <mutex>

::bugu::InterruptSleeper interrupt_sleeper;

void handler(int signal) {
  fprintf(stdout, "terminate with signal: %" PRId32 "\n", signal);
  interrupt_sleeper.interrupt();
}

int main() {
  auto bootstrap = ::std::make_shared<config::Bootstrap>();

  ::bugu::Config conf;

  conf.Load("/data/conf/config.json");
  conf.Scan(bootstrap.get());

  // Init the threadpool and memory-resource
  auto thread_pool = ::bugu::XThreadPool::Get();
  thread_pool->Init(::std::thread::hardware_concurrency());
  auto memory_resource = ::std::make_shared<::std::pmr::synchronized_pool_resource>();

  // Init Grpc server
  auto server = ::bugu::BuguDetectServer::Get();
  server->Init(bootstrap->server().grpc().addr(), thread_pool, memory_resource);
  server->Start();

  // capture the int and term signal
  struct sigaction sa{};
  sa.sa_handler = handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  sigaction(SIGINT, &sa, nullptr);
  sigaction(SIGTERM, &sa, nullptr);

  // block to wait the exit
  interrupt_sleeper.wait();

  ::bugu::BuguDetectServer::Get()->Stop();
  ::bugu::XThreadPool::Get()->Stop();

  return 0;
}


```

`app/detect/service/src/thread/x_thread.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#include "x_thread.h"

/**
 * @brief 线程开始函数
 * @details 该函数是多线程的开始函数，会将 Main 函数放入一个线程中运行
 */
void bugu::XThread::Start() {
  if (!this->IsRunning()) {
    this->SetIsRunning(true);
    this->thread_ = ::std::thread(&XThread::Main, this);
  }
}

/**
 * @brief 等待线程完成
 */
void bugu::XThread::Wait() {
  if (this->thread_.joinable()) {
    this->thread_.join();
  }
}

/**
 * @brief 停止线程
 */
void bugu::XThread::Stop() {
  if (this->IsRunning()) {
    this->SetIsRunning(false);
  }
  Wait();
}

void bugu::XThread::StopWith(::std::function<void()> &_do) {
  _do();
  Stop();
}

/**
 * @brief 休眠该线程若干毫秒
 * @details 接收一个 ::std::chrono::milliseconds 的时间戳，调用 ::std::this_thread::sleep_for() 休眠该线程指定时间
 * @param _time ::std::chrono::milliseconds 时间戳
 */
void bugu::XThread::ThreadSleep(::std::chrono::milliseconds _time) {
  ::std::this_thread::sleep_for(_time);
}

/**
 * @brief 获取 isRunning_ 状态
 * @return bool 返回值为 true，说明线程当前处于运行状态
 */
bool bugu::XThread::IsRunning() const {
  ::std::shared_lock<::std::shared_mutex> lock(is_running_mutex_);
  return is_running_;
}

/**
 * @brief 设置线程运行状态
 * @param is_running 运行状态
 */
void bugu::XThread::SetIsRunning(bool is_running) {
  ::std::unique_lock<::std::shared_mutex> lock(is_running_mutex_);
  is_running_ = is_running;
}


```

`app/detect/service/src/thread/x_thread.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_THREAD_X_THREAD_H_
#define BUGU_DETECT_SERVICE_SRC_THREAD_X_THREAD_H_

#include <mutex>
#include <thread>
#include <shared_mutex>
#include <functional>

namespace bugu {
/**
 * @brief 线程基类
 * @details Start() 启动服务，Stop() 关闭服务
 */
class XThread {
 private:
  ::std::thread thread_;  ///< 线程句柄
  bool is_running_ = false;  ///< 当前线程运行状态
  mutable ::std::shared_mutex is_running_mutex_;  ///< 线程运行状态互斥量

 public:
  virtual void Start();
  virtual void Wait();
  virtual void Stop();
  virtual void StopWith(::std::function<void()> &_do);
  virtual void ThreadSleep(::std::chrono::milliseconds _time);

  bool IsRunning() const;

 private:
  void SetIsRunning(bool is_running);

  /**
   * @brief 该纯虚函数必须在子类中实现，用于线程函数的主函数
   */
  virtual void Main() = 0;
};

} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_THREAD_X_THREAD_H_

```

`app/detect/service/src/thread_pool/x_task.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_THREAD_POOL_X_TASK_H_
#define BUGU_DETECT_SERVICE_SRC_THREAD_POOL_X_TASK_H_

#include <functional>
#include <future>

namespace bugu {
/**
 * @brief 线程池任务基类
 */
class XTaskBase {
 public:
  ::std::function<bool()> is_running = nullptr; ///< 线程池运行状态函数指针

 public:
  virtual ~XTaskBase() = default;
  virtual void Main() = 0;
};

/**
 * @brief 线程池任务模版类，ret_type 设定值类型
 * @tparam ret_type 值类型，不允许为 ::std::thread
 */
template<class ret_type,
    class = typename ::std::enable_if
        <!::std::is_same<ret_type, ::std::thread>::value>::type
>
class XTask : public XTaskBase {
 private:
  ::std::promise<ret_type> p_; ///< 接收返回值

 public:
  /**
   * @brief 设置 future 的值
   * @param ret_type int value
   */
  void set_return(ret_type &&_value) {
    p_.set_value(::std::forward<ret_type>(_value));
  }

  void set_return(const ret_type &_value) {
    p_.set_value(_value);
  }

  /**
   * @brief 阻塞等待 set_value
   * @return decltype(auto)
   */
  decltype(auto) get_return() {
    return p_.get_future().get();
  }
};
} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_THREAD_POOL_X_TASK_H_

```

`app/detect/service/src/thread_pool/x_thread_pool.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#include "bugu_dectet/bugu_detect.h"
#include "x_thread_pool.h"
#include "x_task.h"

#include <iostream>
#include <sstream>
#include <thread>

bugu::XThreadPool::~XThreadPool() {
  // 检查是否停止
  if (is_running_) {
    Stop();
  }
}

/**
 * @brief 初始化所有线程，并启动线程
 * @param _thread_nums 线程数量
 */
::std::size_t bugu::XThreadPool::Init(::std::size_t _thread_nums) {
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  thread_nums_ = _thread_nums;

  BUGU_ASSERT(thread_nums_ > 0 && "thread_nums_ <= 0");
  if (thread_nums_ <= 0) {
    throw ::std::runtime_error("thread_nums_ <= 0");
  }

  BUGU_ASSERT(threads_.empty() && "threads should be empty");
  if (!threads_.empty()) {
    throw ::std::runtime_error("!threads_.empty()");
  }

  // 创建线程对象
  for (::std::size_t i = 0; i < thread_nums_; ++i) {
    threads_.push_back(::std::make_unique<::std::thread>(&bugu::XThreadPool::Run, this));
  }

  // 设置线程池运行状态
  is_running_ = true;

  return thread_nums_;
}

/**
 * @brief 线程池退出
 */
void bugu::XThreadPool::Stop() {
  // 设置退出状态
  is_running_ = false;

  // 通知全部线程
  cv_.notify_all();

  // 等待线程结束任务退出
  for (auto &th: threads_) {
    th->join();
  }

  // 独占锁
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  // 清理线程池中的线程对象
  threads_.clear();
}

/**
 * @brief 线程池线程的入口函数
 */
void bugu::XThreadPool::Run() {
#ifdef BUGU_DEBUG
  ::std::stringstream str_info;
  str_info << "Run: " << ::std::this_thread::get_id() << ::std::endl;
  ::std::cout << str_info.str();
#endif

  while (is_running_) {
    // 获取任务
    auto task = GetTask();
    // 获取到空指针, continue之后然后继续获取或退出线程
    if (nullptr == task) {
      continue;
    }

    ++task_run_count_;  // 设置运行中的任务个数
    try {
      // 执行任务
      task->Main();
    } catch (::std::exception &e) {
      ::std::stringstream str_e;
      str_e << "Failure in thread " << ::std::this_thread::get_id() << ", Exception: " << e.what() << ::std::endl;
      ::std::cerr << str_e.str();
    } catch (...) {
      ::std::stringstream str_e;
      str_e << "Unknown failure in thread " << ::std::this_thread::get_id() << ::std::endl;
      ::std::cerr << str_e.str();
    }
    --task_run_count_;
#ifdef BUGU_DEBUG
    ::std::cout << "run: " << task_run_count_ << ::std::endl;
#endif
  }
}

/**
 * @brief 插入任务
 * @param _x_task 任务指针
 */
void bugu::XThreadPool::AddTask(::std::shared_ptr<XTaskBase> &&_x_task) {
  // 将任务插入到队列
  {
    // 独占锁
    ::std::unique_lock<::std::shared_mutex> lock(mutex_);
    // 将线程池运行状态函数的函数指针传入任务中
    _x_task->is_running = [this] {
      return is_running();
    };
    x_tasks_.push(_x_task);
  }

  // 通知一个线程取任务
  cv_.notify_one();
}

/**
 * @brief 获取任务指针
 * @return XTaskBase* 任务指针
 */
::std::shared_ptr<bugu::XTaskBase> bugu::XThreadPool::GetTask() {
  // 独占锁，防止抢占
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  // 当任务队列为空就阻塞
  if (x_tasks_.empty()) {
    cv_.wait(lock);
  }

  // 退出
  if (!is_running_) {
    return nullptr;
  }

  // 防止多次通知
  if (x_tasks_.empty()) {
    return nullptr;
  }

  // 取出队头任务
  auto task = x_tasks_.front();
  x_tasks_.pop();
  return task;
}

/**
 * 获取线程池运行状态
 * @return bool 线程池运行状态
 */
bool bugu::XThreadPool::is_running() const {
  return is_running_;
}

/**
 * 获取线程池当前执行中的任务数量
 * @return int 任务数量
 */
int bugu::XThreadPool::task_run_count() {
  return task_run_count_;
}


```

`app/detect/service/src/thread_pool/x_thread_pool.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_
#define BUGU_DETECT_SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <queue>
#include <shared_mutex>
#include <thread>
#include <vector>

namespace bugu {
class XTaskBase;

/**
 * @brief 线程池
 */
class XThreadPool {
 private:
  ::std::size_t thread_nums_ = 0; ///< 线程数量
  ::std::vector<::std::unique_ptr<::std::thread>> threads_;  ///< 线程池线程
  ::std::queue<::std::shared_ptr<XTaskBase>> x_tasks_;   ///< 任务队列
  ::std::atomic<bool> is_running_ = false;      ///< 线程池运行状态
  ::std::atomic<int> task_run_count_ = 0; ///< 正在运行的任务数量，原子变量，线程安全

  mutable ::std::shared_mutex mutex_;
  ::std::condition_variable_any cv_;

 public:
  ~XThreadPool();

  // 禁止生成拷移动构造函数, 拷贝构造函数
  XThreadPool(XThreadPool &&_pool) = delete;
  XThreadPool(const XThreadPool &_pool) = delete;
  XThreadPool &operator=(const XThreadPool &_pool) = delete;

  /**
   * @brief 单件模式
   * @return XThreadPool*
   */
  static XThreadPool *Get() {
    static XThreadPool p;
    return &p;
  }

 private:
  XThreadPool() = default;

 public:
  /**
   * @brief 初始化所有线程，并启动线程
   */
  ::std::size_t Init(::std::size_t _thread_nums);

  /**
   * @brief 线程池退出
   */
  void Stop();

  /**
   * @brief 插入任务
   * @param _x_task 任务指针
   */
  void AddTask(::std::shared_ptr<XTaskBase> &&_x_task);

 private:
  /**
   * @brief 线程池线程的入口函数
   */
  void Run();

  /**
   * @brief 获取任务指针
   * @return XTaskBase* 任务指针
   */
  ::std::shared_ptr<XTaskBase> GetTask();

  // 获取器和设置器
 public:
  /**
   * 获取线程池运行状态
   * @return bool 线程池运行状态
   */
  bool is_running() const;

  /**
   * 获取线程池当前执行中的任务数量
   * @return int 任务数量
   */
  int task_run_count();
};
} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_

```

`app/detect/service/src/utils/credentials.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#include "credentials.h"

#include <fstream>

::std::string bugu::Credentials::GetFileContents(const std::string &_path) {
  ::std::ifstream file_stream(_path);
  if (!file_stream.good()) {
    ::std::cerr << "Open Cert File Failed" << ::std::endl;
    exit(-1);
  }
  ::std::string contents;
  contents.assign((::std::istreambuf_iterator<char>(file_stream)), ::std::istreambuf_iterator<char>());
  file_stream.close();
  return contents;
}

::std::shared_ptr<::grpc::ServerCredentials> bugu::Credentials::GetServerCredentials() {
  auto root_cert = GetFileContents("../cert/ca.crt");
  auto key_str = GetFileContents("../cert/server.key");
  auto cert_str = GetFileContents("../cert/server.pem");
  auto x509KeyPair = ::grpc::SslServerCredentialsOptions::PemKeyCertPair{key_str, cert_str};

  ::grpc::SslServerCredentialsOptions cred_option;
  cred_option.pem_root_certs = root_cert;
  cred_option.pem_key_cert_pairs.push_back(x509KeyPair);

  return ::grpc::SslServerCredentials(cred_option);
}

::std::shared_ptr<::grpc::ChannelCredentials> bugu::Credentials::GetClientCredentials() {
  auto root_cert = GetFileContents("../cert/ca.crt");
  auto key_str = GetFileContents("../cert/client.key");
  auto cert_str = GetFileContents("../cert/client.pem");

  ::grpc::SslCredentialsOptions cred_option;
  cred_option.pem_root_certs  = root_cert;
  cred_option.pem_private_key = key_str;
  cred_option.pem_cert_chain  = cert_str;

  return ::grpc::SslCredentials(cred_option);
}


```

`app/detect/service/src/utils/credentials.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_UTILS_CREDENTIALS_H_
#define BUGU_DETECT_SERVICE_SRC_UTILS_CREDENTIALS_H_

#include <grpc++/grpc++.h>

#include <string>
#include <memory>

namespace bugu {

class Credentials {
 public:
  static ::std::string GetFileContents(const ::std::string &_path);
  static ::std::shared_ptr<::grpc::ServerCredentials> GetServerCredentials();
  static ::std::shared_ptr<::grpc::ChannelCredentials> GetClientCredentials();
};

} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_UTILS_CREDENTIALS_H_

```

`app/detect/service/src/utils/interrupt_sleeper.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/30.
//

#ifndef BUGU_DETECT_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_
#define BUGU_DETECT_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_

#include <atomic>
#include <chrono>
#include <memory>
#include <mutex>

namespace bugu {

class InterruptSleeper {
 private:
  ::std::condition_variable cv_;
  ::std::mutex mutex_;
  ::std::atomic<bool> terminate_ = false;

 public:
  void wait() {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    cv_.wait(lock, [&] { return terminate_.load(); });
  }

  template<typename R, typename P>
  bool wait_for(::std::chrono::duration<R, P> const &_time) {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    return !cv_.wait_for(lock, _time, [&] { return terminate_.load(); });
  }

  void interrupt() {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    terminate_.store(true);
    cv_.notify_all();
  }
};

} // namespace bugu

#endif //BUGU_DETECT_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_

```

`app/obfusion/service/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.11)

set(LIB_MAJOR_VERSION "1")
set(LIB_MINOR_VERSION "0")
set(LIB_PATCH_VERSION "0")
set(LIB_VERSION_STRING "${LIB_MAJOR_VERSION}.${LIB_MINOR_VERSION}.${LIB_PATCH_VERSION}")

project(bugu.obfusion.service
        VERSION "${LIB_VERSION_STRING}"
        LANGUAGES C CXX
        HOMEPAGE_URL "https://github.com/hominsu/bugu")

set(CMAKE_CXX_STANDARD 17)

message("")
message("Operation system is ${CMAKE_SYSTEM}")
message("Current compiler: ${CMAKE_CXX_COMPILER_ID}")
message("Current compiler version: ${CMAKE_CXX_COMPILER_VERSION}")
message("Current compiler directory: ${CMAKE_CXX_COMPILER}")
if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
    link_directories(/opt/homebrew/lib)
    include_directories(/opt/homebrew/include)
    set(OPENSSL_ROOT_DIR /opt/homebrew/opt/openssl@1.1/)
    set(OPENSSL_INCLUDE_DIR /opt/homebrew/opt/openssl@1.1/include)
elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
    link_directories(/usr/local/lib)
    include_directories(/usr/local/include)
elseif (${CMAKE_SYSTEM_NAME} MATCHES "Windows")
    if (MSVC)   # if msvc
        add_compile_options("$<$<C_COMPILER_ID:MSVC>:/utf-8>")
        add_compile_options("$<$<CXX_COMPILER_ID:MSVC>:/utf-8>")
    endif ()
else ()
    message(FATAL_ERROR "Platform ${CMAKE_SYSTEM} is not support for this project")
endif ()

if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel." FORCE)
endif ()

if (CMAKE_BUILD_TYPE STREQUAL Debug)
    ADD_DEFINITIONS(-DBUGU_DEBUG)
    message(STATUS "CMake Build Type: Debug")
    message("")
elseif (CMAKE_BUILD_TYPE STREQUAL Release)
    ADD_DEFINITIONS(-DBUGU_RELEASE)
    message(STATUS "CMake Build Type: Release")
    message("")
endif ()

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror -Wno-unused-parameter")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g")
#set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3")

find_program(CCACHE_FOUND ccache)
if (CCACHE_FOUND)
    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)
    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)
    if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Qunused-arguments -fcolor-diagnostics")
    endif ()
endif (CCACHE_FOUND)

if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    if (NUEJSON_ENABLE_INSTRUMENTATION_OPT AND NOT CMAKE_CROSSCOMPILING)
        if (CMAKE_SYSTEM_PROCESSOR STREQUAL "powerpc" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64le")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mcpu=native")
        elseif (NOT CMAKE_SYSTEM_PROCESSOR STREQUAL "arm64" AND NOT CMAKE_SYSTEM_NAME MATCHES "Darwin")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native")
        endif ()
    endif ()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror")
    set(EXTRA_CXX_FLAGS -Weffc++ -Wswitch-default -Wfloat-equal -Wconversion -Wsign-conversion)
elseif (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    if (NOT CMAKE_CROSSCOMPILING)
        if (CMAKE_SYSTEM_PROCESSOR STREQUAL "powerpc" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64le")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mcpu=native")
        elseif (NOT CMAKE_SYSTEM_PROCESSOR STREQUAL "arm64" AND NOT CMAKE_SYSTEM_NAME MATCHES "Darwin")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native")
        endif ()
    endif ()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror -Wno-missing-field-initializers -Wno-register")
    set(EXTRA_CXX_FLAGS -Weffc++ -Wswitch-default -Wfloat-equal -Wconversion -Wimplicit-fallthrough)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    add_definitions(-D_CRT_SECURE_NO_WARNINGS=1)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /EHsc")
    # Always compile with /WX
    if (CMAKE_CXX_FLAGS MATCHES "/WX-")
        string(REGEX REPLACE "/WX-" "/WX" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
    else ()
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /WX")
    endif ()
elseif (CMAKE_CXX_COMPILER_ID MATCHES "XL")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -qarch=auto")
endif ()

add_subdirectory(src)
add_subdirectory(third_party/obfusion)
```

`app/obfusion/service/Dockerfile`:

```
#build stage
FROM alpine:latest as builder
# app dir
ARG APP_RELATIVE_PATH
# install: git(makefile use git to describe the version)
RUN apk --no-cache add bash findutils git build-base cmake \
    re2-dev c-ares-dev grpc grpc-dev protobuf-dev libprotobuf protoc libprotoc \
    openssl-dev openssl-libs-static
# build app
COPY . /src
WORKDIR /src
RUN make grpc-cpp && cd /src/app/obfusion/service && make conf
WORKDIR /src/app/${APP_RELATIVE_PATH}
RUN git submodule update --init --recommend-shallow --recursive
RUN make build

#final stage
FROM alpine:latest
# image info
ARG AUTHOR_NAME
ARG AUTHOR_EMAIL
ARG VERSION
# label
LABEL author=$AUTHOR_NAME email=${AUTHOR_EMAIL} version=$VERSION
# app dir
ARG APP_RELATIVE_PATH
# install: tzdata c-ares libprotobuf
RUN apk --no-cache add tzdata ca-certificates c-ares libprotobuf grpc
# cpoy the app from builder
COPY --from=builder /src/app/${APP_RELATIVE_PATH}/bin /app
WORKDIR /app
EXPOSE 9000
VOLUME /data/conf
CMD ["./server"]

```

`app/obfusion/service/Makefile`:

```
include ../../../cpp_makefile
```

`app/obfusion/service/configs/config.json`:

```json
{
  "server": {
    "grpc": {
      "addr": "0.0.0.0:9000"
    }
  }
}
```

`app/obfusion/service/include/bugu_obfusion/bugu_obfusion.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#ifndef BUGU_OBFUSION_SERVICE_INCLUDE_BUGU_OBFUSION_BUGU_OBFUSION_H_
#define BUGU_OBFUSION_SERVICE_INCLUDE_BUGU_OBFUSION_BUGU_OBFUSION_H_

#if defined(__has_builtin)
#define BUGU_HAS_BUILTIN(x) __has_builtin(x)
#else
#define BUGU_HAS_BUILTIN(x) 0
#endif

#ifndef BUGU_ASSERT
#include <cassert>
#define BUGU_ASSERT(x) assert(x)
#endif // BUGU_ASSERT

#if defined(_WIN64) || defined(WIN64) || defined(_WIN32) || defined(WIN32)
#if defined(_WIN64) || defined(WIN64)
#define BUGU_ARCH_64 1
#else
#define BUGU_ARCH_32 1
#endif
#define BUGU_PLATFORM_STRING "windows"
#define BUGU_WINDOWS 1
#elif defined(__linux__)
#define BUGU_PLATFORM_STRING "linux"
#define BUGU_LINUX 1
#ifdef _LP64
#define BUGU_ARCH_64 1
#else /* _LP64 */
#define BUGU_ARCH_32 1
#endif /* _LP64 */
#elif defined(__APPLE__)
#define BUGU_PLATFORM_STRING "osx"
#define BUGU_APPLE 1
#ifdef _LP64
#define BUGU_ARCH_64 1
#else /* _LP64 */
#define BUGU_ARCH_32 1
#endif /* _LP64 */
#endif

#ifndef BUGU_WINDOWS
#define BUGU_WINDOWS 0
#endif
#ifndef BUGU_LINUX
#define BUGU_LINUX 0
#endif
#ifndef BUGU_APPLE
#define BUGU_APPLE 0
#endif

#ifdef _MSC_VER
#if _MSC_VER < 1700
typedef __int8 int8_t;
typedef __int16 int16_t;
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int8 uint8_t;
typedef unsigned __int16 uint16_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif /* _MSC_VER < 1700 */
#else
#include <stdint.h>
#endif /* _MSC_VER */

#ifdef _MSC_VER
#if _MSC_VER < 1400
#define PRIdS __PRIS_PREFIX "d"
#define PRIxS __PRIS_PREFIX "x"
#define PRIuS __PRIS_PREFIX "u"
#define PRIXS __PRIS_PREFIX "X"
#define PRIoS __PRIS_PREFIX "o"
#else
#include <inttypes.h>
#endif /* _MSC_VER < 1400 */
#else
#include <inttypes.h>
#endif /* _MSC_VER */

#endif //BUGU_OBFUSION_SERVICE_INCLUDE_BUGU_OBFUSION_BUGU_OBFUSION_H_

```

`app/obfusion/service/src/CMakeLists.txt`:

```txt
# Threads
find_package(Threads REQUIRED)
if (Threads_FOUND)
    message("")
endif ()

# OpenSSL
set(OPENSSL_USE_STATIC_LIBS true)
find_package(OpenSSL REQUIRED)
if (OPENSSL_FOUND)
    message(STATUS "OPENSSL_VERSION = ${OPENSSL_VERSION}")
    message(STATUS "OPENSSL_INCLUDE_DIR = ${OPENSSL_INCLUDE_DIR}")
    message(STATUS "OPENSSL_LIBRARIES = ${OPENSSL_LIBRARIES}")
endif ()

# Protobuf
set(protobuf_MODULE_COMPATIBLE TRUE)
find_package(Protobuf REQUIRED)
if (Protobuf_FOUND)
    message(STATUS "Protobuf_VERSION = ${Protobuf_VERSION}")
    message(STATUS "Protobuf_INCLUDE_DIRS = ${Protobuf_INCLUDE_DIRS}")
    message(STATUS "Protobuf_LIBRARY = ${Protobuf_LIBRARY}")
endif ()

# gRPC
find_package(gRPC CONFIG REQUIRED)
if (gRPC_FOUND)
    message(STATUS "gRPC_VERSION = ${gRPC_VERSION}")
endif ()

include_directories(${PROJECT_SOURCE_DIR}/include)
include_directories(${PROJECT_SOURCE_DIR}/third_party)
include_directories(${PROJECT_SOURCE_DIR}/../../../)
file(GLOB ProjectSRC
        "../../../../api/obfusion/service/v1/cpp/*.cc"
        "../../../../api/obfusion/service/v1/cpp/*.h"
        "thread_pool/*.cc"
        "thread/*.cc"
        "utils/*.cc"
        "conf/*.cc"
        "*.cc")

add_executable(${PROJECT_NAME} ${ProjectSRC})
target_link_libraries(${PROJECT_NAME}
        Threads::Threads
        protobuf::libprotobuf
        gRPC::grpc++_reflection
        gRPC::grpc++
        obfusion-static)

```

`app/obfusion/service/src/bugu_obfusion_impl.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/19.
//

#include "bugu_obfusion/bugu_obfusion.h"
#include "bugu_obfusion_impl.h"
#include "data.h"
#include "obfusion_task.h"
#include "thread_pool/x_thread_pool.h"

#include <cstring>
#include <string>

::grpc::Status bugu::BuguObfusionImpl::Obfusion(::grpc::ServerContext *_ctx,
                                                const ::bugu_obfusion::service::v1::ObfusionRequest *_request,
                                                ::bugu_obfusion::service::v1::ObfusionReply *_response) {
  auto size = _request->size();

  auto data = ::bugu::Data::Make(memory_resource_);
  auto buffer = static_cast<char *>(data->New(size));

  ::std::size_t read_bytes;
  ::std::size_t total_read_bytes = 0;

  // Copy the data from request to buffer
  for (auto &d: _request->data()) {
    read_bytes = d.size();
    memcpy(buffer + total_read_bytes, d.data(), read_bytes);
    total_read_bytes += read_bytes;
  }
  BUGU_ASSERT(total_read_bytes == size && "total_read_bytes != size");

  // create the obfusion task and append to the thread pool, block to wait return
  auto obfusion_task = ::std::make_shared<ObfusionTask>(data, memory_resource_);
  thread_pool_->AddTask(obfusion_task);
  auto ret = obfusion_task->get_return();

  _response->add_data(ret->data(), ret->size());
  _response->set_size(ret->size());

//  return {::grpc::StatusCode::UNIMPLEMENTED, "method Obfusion not implemented"};
  return ::grpc::Status::OK;
}

```

`app/obfusion/service/src/bugu_obfusion_impl.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/19.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_BUGU_OBFUSION_IMPL_H_
#define BUGU_OBFUSION_SERVICE_SRC_BUGU_OBFUSION_IMPL_H_

#include "api/obfusion/service/v1/cpp/bugu_obfusion.grpc.pb.h"

#include <grpc++/grpc++.h>
#include <memory_resource>
#include <memory>
#include <thread>

namespace bugu {

class XThreadPool;

class BuguObfusionImpl final : public bugu_obfusion::service::v1::BuguObfusion::Service {
 private:
  ::bugu::XThreadPool *thread_pool_;  ///< 线程池
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

 public:
  explicit BuguObfusionImpl(::bugu::XThreadPool *_thread_pool,
                            ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource)
      : thread_pool_(_thread_pool), memory_resource_(::std::move(_memory_resource)) {};

  ::grpc::Status Obfusion(::grpc::ServerContext *_ctx,
                          const ::bugu_obfusion::service::v1::ObfusionRequest *_request,
                          ::bugu_obfusion::service::v1::ObfusionReply *_response) override;
};

} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_BUGU_OBFUSION_IMPL_H_

```

`app/obfusion/service/src/bugu_obfusion_server.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/19.
//

#include "bugu_obfusion_server.h"
#include "bugu_obfusion_impl.h"
#include "thread_pool/x_thread_pool.h"
//#include "utils/credentials.h"

#if BUGU_DEBUG
#include <string>
#endif
#include <utility>

bugu::BuguObfusionServer::~BuguObfusionServer() {
  if (IsRunning()) { Stop(); }
}

bugu::BuguObfusionServer *bugu::BuguObfusionServer::Init(::std::string _local_address,
                                                         ::bugu::XThreadPool *_thread_pool,
                                                         ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource) {
  // The thread pool and Grpc service are initialized only once
  if (!init_flag()) {
    local_address_ = ::std::move(_local_address);
    thread_pool_ = _thread_pool;
    memory_resource_ = ::std::move(_memory_resource);
    set_init_flag(true);
  }

  return this;
}

void bugu::BuguObfusionServer::Start() {
  BUGU_ASSERT(init_flag() && "BuguObfusionServer should init first");
  XThread::Start();
}

void bugu::BuguObfusionServer::Stop() {
  ::std::function<void()> func = [this]() {
    server_->Shutdown();
  };
  StopWith(func);
}

void bugu::BuguObfusionServer::Main() {
  BuguObfusionImpl bugu_obfusion_service(thread_pool_, memory_resource_);

  ::grpc::ServerBuilder builder;
  builder.AddListeningPort(local_address_, ::grpc::InsecureServerCredentials());
  builder.RegisterService(&bugu_obfusion_service);

  ::std::unique_ptr<::grpc::Server> server(builder.BuildAndStart());
  server_ = ::std::move(server);

  ::std::clog << "BuguObfusionServer listening on " << local_address_ << ::std::endl;

  server_->Wait();

  ::std::clog << "BuguObfusionServer Shut Down" << ::std::endl;
}

void bugu::BuguObfusionServer::set_init_flag(bool _init_flag) {
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);
  init_flag_ = _init_flag;
}

bool bugu::BuguObfusionServer::init_flag() {
  ::std::shared_lock<::std::shared_mutex> lock(mutex_);
  return init_flag_;
}


```

`app/obfusion/service/src/bugu_obfusion_server.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/19.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_BUGU_OBFUSION_SERVER_H_
#define BUGU_OBFUSION_SERVICE_SRC_BUGU_OBFUSION_SERVER_H_

#include "bugu_obfusion/bugu_obfusion.h"
#include "thread/x_thread.h"

#include <grpc++/grpc++.h>

#include <condition_variable>
#include <memory>
#include <memory_resource>
#include <mutex>
#include <utility>

namespace bugu {

class XThreadPool;

class BuguObfusionServer final : public XThread {
 private:
  bool init_flag_ = false;

  ::std::string local_address_{};  ///< rpc 服务地址：ip+端口
  ::std::unique_ptr<::grpc::Server> server_{};  ///< rpc 服务句柄，用智能指针管理

  ::bugu::XThreadPool *thread_pool_ = nullptr;  ///< 线程池
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

  ::std::shared_mutex mutex_;

 public:
  ~BuguObfusionServer();
  static BuguObfusionServer *Get() {
    static BuguObfusionServer s;
    return &s;
  }

 private:
  BuguObfusionServer() = default;

 public:
  BuguObfusionServer *Init(::std::string _local_address,
                           ::bugu::XThreadPool *_thread_pool,
                           ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource);

  void Start() override;

  void Main() override;

  void Stop() override;

  void set_init_flag(bool _init_flag);

  bool init_flag();
};

} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_BUGU_OBFUSION_SERVER_H_

```

`app/obfusion/service/src/conf/conf.pb.cc`:

```cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conf.proto

#include "conf.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace config {
constexpr Bootstrap::Bootstrap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : server_(nullptr){}
struct BootstrapDefaultTypeInternal {
  constexpr BootstrapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BootstrapDefaultTypeInternal() {}
  union {
    Bootstrap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
constexpr Server_GRPC::Server_GRPC(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : network_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , addr_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , timeout_(nullptr){}
struct Server_GRPCDefaultTypeInternal {
  constexpr Server_GRPCDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Server_GRPCDefaultTypeInternal() {}
  union {
    Server_GRPC _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Server_GRPCDefaultTypeInternal _Server_GRPC_default_instance_;
constexpr Server::Server(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : grpc_(nullptr){}
struct ServerDefaultTypeInternal {
  constexpr ServerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServerDefaultTypeInternal() {}
  union {
    Server _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServerDefaultTypeInternal _Server_default_instance_;
}  // namespace config
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_conf_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_conf_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_conf_2eproto = nullptr;

const uint32_t TableStruct_conf_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Bootstrap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Bootstrap, server_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, network_),
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, addr_),
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, timeout_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Server, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Server, grpc_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::config::Bootstrap)},
  { 7, -1, -1, sizeof(::config::Server_GRPC)},
  { 16, -1, -1, sizeof(::config::Server)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Bootstrap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Server_GRPC_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Server_default_instance_),
};

const char descriptor_table_protodef_conf_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\nconf.proto\022\006config\032\036google/protobuf/du"
  "ration.proto\"+\n\tBootstrap\022\036\n\006server\030\001 \001("
  "\0132\016.config.Server\"~\n\006Server\022!\n\004grpc\030\001 \001("
  "\0132\023.config.Server.GRPC\032Q\n\004GRPC\022\017\n\007networ"
  "k\030\001 \001(\t\022\014\n\004addr\030\002 \001(\t\022*\n\007timeout\030\003 \001(\0132\031"
  ".google.protobuf.Durationb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_conf_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_conf_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_conf_2eproto = {
  false, false, 233, descriptor_table_protodef_conf_2eproto, "conf.proto", 
  &descriptor_table_conf_2eproto_once, descriptor_table_conf_2eproto_deps, 1, 3,
  schemas, file_default_instances, TableStruct_conf_2eproto::offsets,
  file_level_metadata_conf_2eproto, file_level_enum_descriptors_conf_2eproto, file_level_service_descriptors_conf_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_conf_2eproto_getter() {
  return &descriptor_table_conf_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_conf_2eproto(&descriptor_table_conf_2eproto);
namespace config {

// ===================================================================

class Bootstrap::_Internal {
 public:
  static const ::config::Server& server(const Bootstrap* msg);
};

const ::config::Server&
Bootstrap::_Internal::server(const Bootstrap* msg) {
  return *msg->server_;
}
Bootstrap::Bootstrap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Bootstrap)
}
Bootstrap::Bootstrap(const Bootstrap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_server()) {
    server_ = new ::config::Server(*from.server_);
  } else {
    server_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Bootstrap)
}

inline void Bootstrap::SharedCtor() {
server_ = nullptr;
}

Bootstrap::~Bootstrap() {
  // @@protoc_insertion_point(destructor:config.Bootstrap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Bootstrap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete server_;
}

void Bootstrap::ArenaDtor(void* object) {
  Bootstrap* _this = reinterpret_cast< Bootstrap* >(object);
  (void)_this;
}
void Bootstrap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Bootstrap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Bootstrap::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Bootstrap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && server_ != nullptr) {
    delete server_;
  }
  server_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bootstrap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .config.Server server = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_server(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Bootstrap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Bootstrap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .config.Server server = 1;
  if (this->_internal_has_server()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::server(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Bootstrap)
  return target;
}

size_t Bootstrap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Bootstrap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .config.Server server = 1;
  if (this->_internal_has_server()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *server_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bootstrap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Bootstrap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bootstrap::GetClassData() const { return &_class_data_; }

void Bootstrap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Bootstrap *>(to)->MergeFrom(
      static_cast<const Bootstrap &>(from));
}


void Bootstrap::MergeFrom(const Bootstrap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Bootstrap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_server()) {
    _internal_mutable_server()->::config::Server::MergeFrom(from._internal_server());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bootstrap::CopyFrom(const Bootstrap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Bootstrap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bootstrap::IsInitialized() const {
  return true;
}

void Bootstrap::InternalSwap(Bootstrap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(server_, other->server_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Bootstrap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[0]);
}

// ===================================================================

class Server_GRPC::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Duration& timeout(const Server_GRPC* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Duration&
Server_GRPC::_Internal::timeout(const Server_GRPC* msg) {
  return *msg->timeout_;
}
void Server_GRPC::clear_timeout() {
  if (GetArenaForAllocation() == nullptr && timeout_ != nullptr) {
    delete timeout_;
  }
  timeout_ = nullptr;
}
Server_GRPC::Server_GRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Server.GRPC)
}
Server_GRPC::Server_GRPC(const Server_GRPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_network().empty()) {
    network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_network(), 
      GetArenaForAllocation());
  }
  addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_addr().empty()) {
    addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_addr(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_timeout()) {
    timeout_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from.timeout_);
  } else {
    timeout_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Server.GRPC)
}

inline void Server_GRPC::SharedCtor() {
network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
timeout_ = nullptr;
}

Server_GRPC::~Server_GRPC() {
  // @@protoc_insertion_point(destructor:config.Server.GRPC)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Server_GRPC::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  network_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  addr_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete timeout_;
}

void Server_GRPC::ArenaDtor(void* object) {
  Server_GRPC* _this = reinterpret_cast< Server_GRPC* >(object);
  (void)_this;
}
void Server_GRPC::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Server_GRPC::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Server_GRPC::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Server.GRPC)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  network_.ClearToEmpty();
  addr_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && timeout_ != nullptr) {
    delete timeout_;
  }
  timeout_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Server_GRPC::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string network = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_network();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "config.Server.GRPC.network"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string addr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_addr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "config.Server.GRPC.addr"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Duration timeout = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timeout(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Server_GRPC::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Server.GRPC)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string network = 1;
  if (!this->_internal_network().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_network().data(), static_cast<int>(this->_internal_network().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "config.Server.GRPC.network");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_network(), target);
  }

  // string addr = 2;
  if (!this->_internal_addr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_addr().data(), static_cast<int>(this->_internal_addr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "config.Server.GRPC.addr");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_addr(), target);
  }

  // .google.protobuf.Duration timeout = 3;
  if (this->_internal_has_timeout()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::timeout(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Server.GRPC)
  return target;
}

size_t Server_GRPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Server.GRPC)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string network = 1;
  if (!this->_internal_network().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_network());
  }

  // string addr = 2;
  if (!this->_internal_addr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_addr());
  }

  // .google.protobuf.Duration timeout = 3;
  if (this->_internal_has_timeout()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *timeout_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Server_GRPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Server_GRPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Server_GRPC::GetClassData() const { return &_class_data_; }

void Server_GRPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Server_GRPC *>(to)->MergeFrom(
      static_cast<const Server_GRPC &>(from));
}


void Server_GRPC::MergeFrom(const Server_GRPC& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Server.GRPC)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_network().empty()) {
    _internal_set_network(from._internal_network());
  }
  if (!from._internal_addr().empty()) {
    _internal_set_addr(from._internal_addr());
  }
  if (from._internal_has_timeout()) {
    _internal_mutable_timeout()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_timeout());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Server_GRPC::CopyFrom(const Server_GRPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Server.GRPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Server_GRPC::IsInitialized() const {
  return true;
}

void Server_GRPC::InternalSwap(Server_GRPC* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &network_, lhs_arena,
      &other->network_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &addr_, lhs_arena,
      &other->addr_, rhs_arena
  );
  swap(timeout_, other->timeout_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Server_GRPC::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[1]);
}

// ===================================================================

class Server::_Internal {
 public:
  static const ::config::Server_GRPC& grpc(const Server* msg);
};

const ::config::Server_GRPC&
Server::_Internal::grpc(const Server* msg) {
  return *msg->grpc_;
}
Server::Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Server)
}
Server::Server(const Server& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_grpc()) {
    grpc_ = new ::config::Server_GRPC(*from.grpc_);
  } else {
    grpc_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Server)
}

inline void Server::SharedCtor() {
grpc_ = nullptr;
}

Server::~Server() {
  // @@protoc_insertion_point(destructor:config.Server)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Server::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete grpc_;
}

void Server::ArenaDtor(void* object) {
  Server* _this = reinterpret_cast< Server* >(object);
  (void)_this;
}
void Server::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Server::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Server::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Server)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && grpc_ != nullptr) {
    delete grpc_;
  }
  grpc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Server::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .config.Server.GRPC grpc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_grpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Server::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Server)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .config.Server.GRPC grpc = 1;
  if (this->_internal_has_grpc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::grpc(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Server)
  return target;
}

size_t Server::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Server)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .config.Server.GRPC grpc = 1;
  if (this->_internal_has_grpc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *grpc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Server::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Server::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Server::GetClassData() const { return &_class_data_; }

void Server::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Server *>(to)->MergeFrom(
      static_cast<const Server &>(from));
}


void Server::MergeFrom(const Server& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Server)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_grpc()) {
    _internal_mutable_grpc()->::config::Server_GRPC::MergeFrom(from._internal_grpc());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Server::CopyFrom(const Server& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Server)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Server::IsInitialized() const {
  return true;
}

void Server::InternalSwap(Server* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(grpc_, other->grpc_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Server::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[2]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace config
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::config::Bootstrap* Arena::CreateMaybeMessage< ::config::Bootstrap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Bootstrap >(arena);
}
template<> PROTOBUF_NOINLINE ::config::Server_GRPC* Arena::CreateMaybeMessage< ::config::Server_GRPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Server_GRPC >(arena);
}
template<> PROTOBUF_NOINLINE ::config::Server* Arena::CreateMaybeMessage< ::config::Server >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Server >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

```

`app/obfusion/service/src/conf/conf.pb.h`:

```h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_conf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_conf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_conf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_conf_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_conf_2eproto;
namespace config {
class Bootstrap;
struct BootstrapDefaultTypeInternal;
extern BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
class Server;
struct ServerDefaultTypeInternal;
extern ServerDefaultTypeInternal _Server_default_instance_;
class Server_GRPC;
struct Server_GRPCDefaultTypeInternal;
extern Server_GRPCDefaultTypeInternal _Server_GRPC_default_instance_;
}  // namespace config
PROTOBUF_NAMESPACE_OPEN
template<> ::config::Bootstrap* Arena::CreateMaybeMessage<::config::Bootstrap>(Arena*);
template<> ::config::Server* Arena::CreateMaybeMessage<::config::Server>(Arena*);
template<> ::config::Server_GRPC* Arena::CreateMaybeMessage<::config::Server_GRPC>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace config {

// ===================================================================

class Bootstrap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Bootstrap) */ {
 public:
  inline Bootstrap() : Bootstrap(nullptr) {}
  ~Bootstrap() override;
  explicit constexpr Bootstrap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bootstrap(const Bootstrap& from);
  Bootstrap(Bootstrap&& from) noexcept
    : Bootstrap() {
    *this = ::std::move(from);
  }

  inline Bootstrap& operator=(const Bootstrap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bootstrap& operator=(Bootstrap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bootstrap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bootstrap* internal_default_instance() {
    return reinterpret_cast<const Bootstrap*>(
               &_Bootstrap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Bootstrap& a, Bootstrap& b) {
    a.Swap(&b);
  }
  inline void Swap(Bootstrap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bootstrap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bootstrap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bootstrap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bootstrap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bootstrap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bootstrap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Bootstrap";
  }
  protected:
  explicit Bootstrap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 1,
  };
  // .config.Server server = 1;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::config::Server& server() const;
  PROTOBUF_NODISCARD ::config::Server* release_server();
  ::config::Server* mutable_server();
  void set_allocated_server(::config::Server* server);
  private:
  const ::config::Server& _internal_server() const;
  ::config::Server* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::config::Server* server);
  ::config::Server* unsafe_arena_release_server();

  // @@protoc_insertion_point(class_scope:config.Bootstrap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::config::Server* server_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server_GRPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Server.GRPC) */ {
 public:
  inline Server_GRPC() : Server_GRPC(nullptr) {}
  ~Server_GRPC() override;
  explicit constexpr Server_GRPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server_GRPC(const Server_GRPC& from);
  Server_GRPC(Server_GRPC&& from) noexcept
    : Server_GRPC() {
    *this = ::std::move(from);
  }

  inline Server_GRPC& operator=(const Server_GRPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server_GRPC& operator=(Server_GRPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server_GRPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server_GRPC* internal_default_instance() {
    return reinterpret_cast<const Server_GRPC*>(
               &_Server_GRPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Server_GRPC& a, Server_GRPC& b) {
    a.Swap(&b);
  }
  inline void Swap(Server_GRPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server_GRPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server_GRPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server_GRPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server_GRPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Server_GRPC& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server_GRPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Server.GRPC";
  }
  protected:
  explicit Server_GRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkFieldNumber = 1,
    kAddrFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string network = 1;
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // .google.protobuf.Duration timeout = 3;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // @@protoc_insertion_point(class_scope:config.Server.GRPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::Duration* timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Server) */ {
 public:
  inline Server() : Server(nullptr) {}
  ~Server() override;
  explicit constexpr Server(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server(const Server& from);
  Server(Server&& from) noexcept
    : Server() {
    *this = ::std::move(from);
  }

  inline Server& operator=(const Server& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server& operator=(Server&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server* internal_default_instance() {
    return reinterpret_cast<const Server*>(
               &_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Server& a, Server& b) {
    a.Swap(&b);
  }
  inline void Swap(Server* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Server& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Server";
  }
  protected:
  explicit Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Server_GRPC GRPC;

  // accessors -------------------------------------------------------

  enum : int {
    kGrpcFieldNumber = 1,
  };
  // .config.Server.GRPC grpc = 1;
  bool has_grpc() const;
  private:
  bool _internal_has_grpc() const;
  public:
  void clear_grpc();
  const ::config::Server_GRPC& grpc() const;
  PROTOBUF_NODISCARD ::config::Server_GRPC* release_grpc();
  ::config::Server_GRPC* mutable_grpc();
  void set_allocated_grpc(::config::Server_GRPC* grpc);
  private:
  const ::config::Server_GRPC& _internal_grpc() const;
  ::config::Server_GRPC* _internal_mutable_grpc();
  public:
  void unsafe_arena_set_allocated_grpc(
      ::config::Server_GRPC* grpc);
  ::config::Server_GRPC* unsafe_arena_release_grpc();

  // @@protoc_insertion_point(class_scope:config.Server)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::config::Server_GRPC* grpc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Bootstrap

// .config.Server server = 1;
inline bool Bootstrap::_internal_has_server() const {
  return this != internal_default_instance() && server_ != nullptr;
}
inline bool Bootstrap::has_server() const {
  return _internal_has_server();
}
inline void Bootstrap::clear_server() {
  if (GetArenaForAllocation() == nullptr && server_ != nullptr) {
    delete server_;
  }
  server_ = nullptr;
}
inline const ::config::Server& Bootstrap::_internal_server() const {
  const ::config::Server* p = server_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Server&>(
      ::config::_Server_default_instance_);
}
inline const ::config::Server& Bootstrap::server() const {
  // @@protoc_insertion_point(field_get:config.Bootstrap.server)
  return _internal_server();
}
inline void Bootstrap::unsafe_arena_set_allocated_server(
    ::config::Server* server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_);
  }
  server_ = server;
  if (server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Bootstrap.server)
}
inline ::config::Server* Bootstrap::release_server() {
  
  ::config::Server* temp = server_;
  server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Server* Bootstrap::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:config.Bootstrap.server)
  
  ::config::Server* temp = server_;
  server_ = nullptr;
  return temp;
}
inline ::config::Server* Bootstrap::_internal_mutable_server() {
  
  if (server_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Server>(GetArenaForAllocation());
    server_ = p;
  }
  return server_;
}
inline ::config::Server* Bootstrap::mutable_server() {
  ::config::Server* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:config.Bootstrap.server)
  return _msg;
}
inline void Bootstrap::set_allocated_server(::config::Server* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::config::Server>::GetOwningArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    
  } else {
    
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:config.Bootstrap.server)
}

// -------------------------------------------------------------------

// Server_GRPC

// string network = 1;
inline void Server_GRPC::clear_network() {
  network_.ClearToEmpty();
}
inline const std::string& Server_GRPC::network() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server_GRPC::set_network(ArgT0&& arg0, ArgT... args) {
 
 network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Server.GRPC.network)
}
inline std::string* Server_GRPC::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.network)
  return _s;
}
inline const std::string& Server_GRPC::_internal_network() const {
  return network_.Get();
}
inline void Server_GRPC::_internal_set_network(const std::string& value) {
  
  network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Server_GRPC::_internal_mutable_network() {
  
  return network_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Server_GRPC::release_network() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.network)
  return network_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Server_GRPC::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  network_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), network,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.network)
}

// string addr = 2;
inline void Server_GRPC::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& Server_GRPC::addr() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server_GRPC::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Server.GRPC.addr)
}
inline std::string* Server_GRPC::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.addr)
  return _s;
}
inline const std::string& Server_GRPC::_internal_addr() const {
  return addr_.Get();
}
inline void Server_GRPC::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Server_GRPC::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Server_GRPC::release_addr() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Server_GRPC::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.addr)
}

// .google.protobuf.Duration timeout = 3;
inline bool Server_GRPC::_internal_has_timeout() const {
  return this != internal_default_instance() && timeout_ != nullptr;
}
inline bool Server_GRPC::has_timeout() const {
  return _internal_has_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Server_GRPC::_internal_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Server_GRPC::timeout() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.timeout)
  return _internal_timeout();
}
inline void Server_GRPC::unsafe_arena_set_allocated_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Server.GRPC.timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::release_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::_internal_mutable_timeout() {
  
  if (timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    timeout_ = p;
  }
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::mutable_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.timeout)
  return _msg;
}
inline void Server_GRPC::set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout));
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.timeout)
}

// -------------------------------------------------------------------

// Server

// .config.Server.GRPC grpc = 1;
inline bool Server::_internal_has_grpc() const {
  return this != internal_default_instance() && grpc_ != nullptr;
}
inline bool Server::has_grpc() const {
  return _internal_has_grpc();
}
inline void Server::clear_grpc() {
  if (GetArenaForAllocation() == nullptr && grpc_ != nullptr) {
    delete grpc_;
  }
  grpc_ = nullptr;
}
inline const ::config::Server_GRPC& Server::_internal_grpc() const {
  const ::config::Server_GRPC* p = grpc_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Server_GRPC&>(
      ::config::_Server_GRPC_default_instance_);
}
inline const ::config::Server_GRPC& Server::grpc() const {
  // @@protoc_insertion_point(field_get:config.Server.grpc)
  return _internal_grpc();
}
inline void Server::unsafe_arena_set_allocated_grpc(
    ::config::Server_GRPC* grpc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grpc_);
  }
  grpc_ = grpc;
  if (grpc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Server.grpc)
}
inline ::config::Server_GRPC* Server::release_grpc() {
  
  ::config::Server_GRPC* temp = grpc_;
  grpc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Server_GRPC* Server::unsafe_arena_release_grpc() {
  // @@protoc_insertion_point(field_release:config.Server.grpc)
  
  ::config::Server_GRPC* temp = grpc_;
  grpc_ = nullptr;
  return temp;
}
inline ::config::Server_GRPC* Server::_internal_mutable_grpc() {
  
  if (grpc_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Server_GRPC>(GetArenaForAllocation());
    grpc_ = p;
  }
  return grpc_;
}
inline ::config::Server_GRPC* Server::mutable_grpc() {
  ::config::Server_GRPC* _msg = _internal_mutable_grpc();
  // @@protoc_insertion_point(field_mutable:config.Server.grpc)
  return _msg;
}
inline void Server::set_allocated_grpc(::config::Server_GRPC* grpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete grpc_;
  }
  if (grpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::config::Server_GRPC>::GetOwningArena(grpc);
    if (message_arena != submessage_arena) {
      grpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grpc, submessage_arena);
    }
    
  } else {
    
  }
  grpc_ = grpc;
  // @@protoc_insertion_point(field_set_allocated:config.Server.grpc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_conf_2eproto

```

`app/obfusion/service/src/conf/conf.proto`:

```proto
syntax = "proto3";

package config;

import "google/protobuf/duration.proto";

message Bootstrap {
  Server server = 1;
}

message Server {
  message GRPC {
    string network = 1;
    string addr = 2;
    google.protobuf.Duration timeout = 3;
  }
  GRPC grpc = 1;
}

```

`app/obfusion/service/src/conf/config.h`:

```h
//
// Created by Homin Su on 2022/5/29.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_CONF_CONFIG_H_
#define BUGU_OBFUSION_SERVICE_SRC_CONF_CONFIG_H_

#include "bugu_obfusion/bugu_obfusion.h"
#include "conf.pb.h"

#include "google/protobuf/message.h"
#include "google/protobuf/util/json_util.h"

#include <cstdio>

#include <exception>

namespace bugu {

class Config {
 public:
  void Load(const char *_path);
  void Scan(::google::protobuf::Message *_message);

 private:
  void read(FILE *_in);

  ::std::string get_str() {
    return {buffer_.begin(), buffer_.end()};
  }

 private:
  std::vector<char> buffer_;
};

inline void Config::Load(const char *_path) {
  FILE *input;
#if BUGU_WINDOWS
  fopen_s(&input, _path, "r");
#elif BUGU_LINUX || BUGU_APPLE
  input = fopen(_path, "r");
#endif
  if (input == nullptr) { exit(EXIT_FAILURE); }
  read(input);
  fclose(input);
}

inline void Config::read(FILE *_in) {
  char buf[65536];
  if (!buffer_.empty()) { buffer_.clear(); }
  while (true) {
    size_t n = fread(buf, 1, sizeof(buf), _in);
    if (n == 0) { break; }
    buffer_.insert(buffer_.end(), buf, buf + n);
  }
}

void Config::Scan(::google::protobuf::Message *_message) {
  if (!google::protobuf::util::JsonStringToMessage(get_str(), _message).ok()) {
    throw ::std::runtime_error("Parse json data to message failed");
  }
}

} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_CONF_CONFIG_H_

```

`app/obfusion/service/src/data.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#include "bugu_obfusion/bugu_obfusion.h"
#include "data.h"

bugu::Data::Data() = default;

bugu::Data::~Data() {
  // 内存池未定义或没有数据就不用释放
  if (nullptr == memory_resource_ || nullptr == data_) {
    return;
  }

  // 释放分配的内存
  memory_resource_->deallocate(data_, memory_size_);
  data_ = nullptr;
  memory_size_ = 0;
  size_ = 0;
}

/**
 * @brief 创建 Data 对象
 * @param _memory_resource 内存池对象
 * @return Data 的智能指针对象
 */
::std::shared_ptr<bugu::Data> bugu::Data::Make(::std::shared_ptr<::std::pmr::memory_resource> _memory_resource) {
  // 创建 Data 的智能指针对象
  ::std::shared_ptr<Data> data_ptr(new bugu::Data());
  data_ptr->memory_resource_ = ::std::move(_memory_resource);

  return data_ptr;
}

/**
 * @brief 创建内存空间
 * @param _memory_size 占用内存字节数
 * @return 创建的内存空间的指针，创建失败为空 nullptr
 */
void *bugu::Data::New(::std::size_t _memory_size) {
  BUGU_ASSERT(_memory_size > 0 && "Data::New _memory_size <= 0");

  // 异常处理
  if (nullptr == memory_resource_) {
    return nullptr;
  }

  // 申请空间
  data_ = memory_resource_->allocate(_memory_size);

  memory_size_ = _memory_size;
  size_ = _memory_size;

  return data_;
}

/**
 * @brief 获取数据块的指针
 * @return 数据块的指针
 */
void *bugu::Data::data() const {
  return data_;
}

/**
 * @brief 获取实际数据的字节数
 * @return 实际数据的字节数
 */
::std::size_t bugu::Data::size() const {
  return size_;
}

/**
 * @brief 设置实际数据字节数
 * @param size 实际数据字节数
 */
void bugu::Data::set_size(::std::size_t _size) {
  size_ = _size;
}

/**
 * @brief 获取分配的内存大小
 * @return ::std::size_t 分配的内存大小
 */
::std::size_t bugu::Data::memory_size() const {
  return memory_size_;
}

/**
 * @brief 是否是文件结尾
 * @return true or false
 */
bool bugu::Data::end() const {
  return end_;
}

/**
 * @brief 设置为文件结尾
 * @param _end true or false
 */
void bugu::Data::set_end(bool _end) {
  end_ = _end;
}


```

`app/obfusion/service/src/data.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_DATA_H_
#define BUGU_OBFUSION_SERVICE_SRC_DATA_H_

#include <memory>
#include <memory_resource>

namespace bugu {

/**
 * @brief 内存池数据块
 */
class Data {
 private:
  void *data_ = nullptr;
  bool end_ = false;        ///< 是否是文件结尾
  ::std::size_t size_ = 0;         ///< 数据字节数
  ::std::size_t memory_size_ = 0;  ///< 申请内存空间字节数
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

 private:
  Data();

 public:
  ~Data();

  /**
   * @brief 创建 Data 对象
   * @param _memory_resource
   * @return Data 的智能指针对象
   */
  static ::std::shared_ptr<Data> Make(::std::shared_ptr<::std::pmr::memory_resource> _memory_resource);

  /**
   * @brief 创建内存空间
   * @param _memory_size 占用内存字节数
   * @return 创建的内存空间的指针，创建失败为空 nullptr
   */
  void *New(::std::size_t _memory_size);

  /**
   * @brief 获取数据块的指针
   * @return 数据块的指针
   */
  [[nodiscard]] void *data() const;

  /**
   * @brief 获取实际数据的字节数
   * @return 实际数据的字节数
   */
  [[nodiscard]] ::std::size_t size() const;

  /**
   * @brief 设置实际数据字节数
   * @param size 实际数据字节数
   */
  void set_size(::std::size_t _size);

  /**
   * @brief 获取分配的内存大小
   * @return ::std::size_t 分配的内存大小
   */
  [[nodiscard]] ::std::size_t memory_size() const;

  /**
   * @brief 是否是文件结尾
   * @return
   */
  [[nodiscard]] bool end() const;

  /**
   * @brief 设置为文件结尾
   * @param _end true or false
   */
  void set_end(bool _end);
};

/**
 * @brief 定义了 Byte、KB、MB、GB 的大小
 */
enum class Unit : ::std::size_t {
  Byte = 1, KB = 1024 * Byte, MB = 1024 * KB, GB = 1024 * MB
};

/**
 * @brief 将字节的大小换算成对应单位的大小
 * @tparam size_type 输入类型，只能为算术类型
 * @param _size 字节大小
 * @param _unit 转换的单位
 * @return 转换后的数值
 */
template<typename size_type,
    class = typename ::std::enable_if<
        ::std::is_arithmetic<size_type>::value>::type
>
double UnitConvert(size_type _size, Unit _unit) {
  return _size / static_cast<double>(_unit);
}

constexpr ::std::size_t KB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::KB) * _size;
}

constexpr ::std::size_t MB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::MB) * _size;
}

constexpr ::std::size_t GB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::GB) * _size;
}

} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_DATA_H_

```

`app/obfusion/service/src/main.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by HominSu on 2022/5/16.
//

#include "bugu_obfusion_server.h"
#include "conf/config.h"
#include "thread_pool/x_thread_pool.h"
#include "utils/interrupt_sleeper.h"

#include <cstdio>
#include <csignal>

#include <memory_resource>
#include <memory>
#include <mutex>

::bugu::InterruptSleeper interrupt_sleeper;

void handler(int signal) {
  fprintf(stdout, "terminate with signal: %" PRId32 "\n", signal);
  interrupt_sleeper.interrupt();
}

int main() {
  auto bootstrap = ::std::make_shared<config::Bootstrap>();

  ::bugu::Config conf;

  conf.Load("/data/conf/config.json");
  conf.Scan(bootstrap.get());

  // Init the threadpool and memory-resource
  auto thread_pool = ::bugu::XThreadPool::Get();
  thread_pool->Init(::std::thread::hardware_concurrency());
  auto memory_resource = ::std::make_shared<::std::pmr::synchronized_pool_resource>();

  // Init Grpc server
  auto server = ::bugu::BuguObfusionServer::Get();
  server->Init(bootstrap->server().grpc().addr(), thread_pool, memory_resource);
  server->Start();

  // capture the int and term signal
  struct sigaction sa{};
  sa.sa_handler = handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  sigaction(SIGINT, &sa, nullptr);
  sigaction(SIGTERM, &sa, nullptr);

  // block to wait the exit
  interrupt_sleeper.wait();

  ::bugu::BuguObfusionServer::Get()->Stop();
  ::bugu::XThreadPool::Get()->Stop();

  return 0;
}

```

`app/obfusion/service/src/obfusion_task.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/19.
//

#include "obfusion_task.h"
#include "obfusion/include/obfusion.h"
#include "data.h"

void bugu::ObfusionTask::Main() {
  obfusion obf;
  // shellcode binary data is present from offset 184 to 189 ("calc\0" string)
  // we need to supply this information so the obfuscator doesn't try to disassemble binary data
  ::std::vector<::std::pair<u32, u32>> data_ranges;
  data_ranges.push_back(::std::make_pair<u32, u32>(184, 189));

  // initial setup of obfuscation parameters
  obf.set_obf_steps(5,
                    20); // we want the obfuscated instructions to be divided into 5-20 separate instructions (approximately) (def. 3-8)
  obf.set_jmp_perc(20); // there should be 20% chance of inserting a jump at every instruction of the obfuscated output (def. 5%)

  obf.load32(data_->data(), data_->size(), data_ranges);

  // obfuscate with random seed of 0xCAFEBABE and 3 obfuscation passes
  obf.obfuscate(0xCAFEBABE, 3);

  u8 *shell_data = nullptr;
  u32 shell_size;
  // dump the obfuscated shellcode into the buffer
  obf.dump(&shell_data, &shell_size);

  auto data = ::bugu::Data::Make(memory_resource_);
  auto buffer = static_cast<char *>(data->New(shell_size));

  memcpy(buffer, shell_data, shell_size);
  delete[] shell_data;

  set_return(data);
}

```

`app/obfusion/service/src/obfusion_task.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/19.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_OBFUSION_TASK_H_
#define BUGU_OBFUSION_SERVICE_SRC_OBFUSION_TASK_H_

#include "thread_pool/x_task.h"

#include <fstream>
#include <memory>
#include <memory_resource>
#include <string>
#include <utility>

namespace bugu {

class Data;

class ObfusionTask : public XTask<::std::shared_ptr<Data>> {
 private:
  ::std::shared_ptr<Data> data_;
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

 public:
  explicit ObfusionTask(::std::shared_ptr<Data> _data,
                        ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource)
      : data_(std::move(_data)), memory_resource_(std::move(_memory_resource)) {};
  ~ObfusionTask() override = default;

 private:
  /**
   * 线程入口函数
   */
  void Main() final;
};

} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_OBFUSION_TASK_H_

```

`app/obfusion/service/src/thread/x_thread.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#include "x_thread.h"

/**
 * @brief 线程开始函数
 * @details 该函数是多线程的开始函数，会将 Main 函数放入一个线程中运行
 */
void bugu::XThread::Start() {
  if (!this->IsRunning()) {
    this->SetIsRunning(true);
    this->thread_ = ::std::thread(&XThread::Main, this);
  }
}

/**
 * @brief 等待线程完成
 */
void bugu::XThread::Wait() {
  if (this->thread_.joinable()) {
    this->thread_.join();
  }
}

/**
 * @brief 停止线程
 */
void bugu::XThread::Stop() {
  if (this->IsRunning()) {
    this->SetIsRunning(false);
  }
  Wait();
}

void bugu::XThread::StopWith(::std::function<void()> &_do) {
  _do();
  Stop();
}

/**
 * @brief 休眠该线程若干毫秒
 * @details 接收一个 ::std::chrono::milliseconds 的时间戳，调用 ::std::this_thread::sleep_for() 休眠该线程指定时间
 * @param _time ::std::chrono::milliseconds 时间戳
 */
void bugu::XThread::ThreadSleep(::std::chrono::milliseconds _time) {
  ::std::this_thread::sleep_for(_time);
}

/**
 * @brief 获取 isRunning_ 状态
 * @return bool 返回值为 true，说明线程当前处于运行状态
 */
bool bugu::XThread::IsRunning() const {
  ::std::shared_lock<::std::shared_mutex> lock(is_running_mutex_);
  return is_running_;
}

/**
 * @brief 设置线程运行状态
 * @param is_running 运行状态
 */
void bugu::XThread::SetIsRunning(bool is_running) {
  ::std::unique_lock<::std::shared_mutex> lock(is_running_mutex_);
  is_running_ = is_running;
}

```

`app/obfusion/service/src/thread/x_thread.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_THREAD_X_THREAD_H_
#define BUGU_OBFUSION_SERVICE_SRC_THREAD_X_THREAD_H_

#include <mutex>
#include <thread>
#include <shared_mutex>
#include <functional>

namespace bugu {
/**
 * @brief 线程基类
 * @details Start() 启动服务，Stop() 关闭服务
 */
class XThread {
 private:
  ::std::thread thread_;  ///< 线程句柄
  bool is_running_ = false;  ///< 当前线程运行状态
  mutable ::std::shared_mutex is_running_mutex_;  ///< 线程运行状态互斥量

 public:
  virtual void Start();
  virtual void Wait();
  virtual void Stop();
  virtual void StopWith(::std::function<void()> &_do);
  virtual void ThreadSleep(::std::chrono::milliseconds _time);

  bool IsRunning() const;

 private:
  void SetIsRunning(bool is_running);

  /**
   * @brief 该纯虚函数必须在子类中实现，用于线程函数的主函数
   */
  virtual void Main() = 0;
};

} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_THREAD_X_THREAD_H_

```

`app/obfusion/service/src/thread_pool/x_task.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_THREAD_POOL_X_TASK_H_
#define BUGU_OBFUSION_SERVICE_SRC_THREAD_POOL_X_TASK_H_

#include <functional>
#include <future>

namespace bugu {
/**
 * @brief 线程池任务基类
 */
class XTaskBase {
 public:
  ::std::function<bool()> is_running = nullptr; ///< 线程池运行状态函数指针

 public:
  virtual ~XTaskBase() = default;
  virtual void Main() = 0;
};

/**
 * @brief 线程池任务模版类，ret_type 设定值类型
 * @tparam ret_type 值类型，不允许为 ::std::thread
 */
template<class ret_type,
    class = typename ::std::enable_if
        <!::std::is_same<ret_type, ::std::thread>::value>::type
>
class XTask : public XTaskBase {
 private:
  ::std::promise<ret_type> p_; ///< 接收返回值

 public:
  /**
   * @brief 设置 future 的值
   * @param ret_type int value
   */
  void set_return(ret_type &&_value) {
    p_.set_value(::std::forward<ret_type>(_value));
  }

  void set_return(const ret_type &_value) {
    p_.set_value(_value);
  }

  /**
   * @brief 阻塞等待 set_value
   * @return decltype(auto)
   */
  decltype(auto) get_return() {
    return p_.get_future().get();
  }
};
} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_THREAD_POOL_X_TASK_H_

```

`app/obfusion/service/src/thread_pool/x_thread_pool.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#include "bugu_obfusion/bugu_obfusion.h"
#include "x_thread_pool.h"
#include "x_task.h"

#include <iostream>
#include <sstream>
#include <thread>

bugu::XThreadPool::~XThreadPool() {
  // 检查是否停止
  if (is_running_) {
    Stop();
  }
}

/**
 * @brief 初始化所有线程，并启动线程
 * @param _thread_nums 线程数量
 */
::std::size_t bugu::XThreadPool::Init(::std::size_t _thread_nums) {
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  thread_nums_ = _thread_nums;

  BUGU_ASSERT(thread_nums_ > 0 && "thread_nums_ <= 0");
  if (thread_nums_ <= 0) {
    throw ::std::runtime_error("thread_nums_ <= 0");
  }

  BUGU_ASSERT(threads_.empty() && "threads should be empty");
  if (!threads_.empty()) {
    throw ::std::runtime_error("!threads_.empty()");
  }

  // 创建线程对象
  for (::std::size_t i = 0; i < thread_nums_; ++i) {
    threads_.push_back(::std::make_unique<::std::thread>(&bugu::XThreadPool::Run, this));
  }

  // 设置线程池运行状态
  is_running_ = true;

  return thread_nums_;
}

/**
 * @brief 线程池退出
 */
void bugu::XThreadPool::Stop() {
  // 设置退出状态
  is_running_ = false;

  // 通知全部线程
  cv_.notify_all();

  // 等待线程结束任务退出
  for (auto &th: threads_) {
    th->join();
  }

  // 独占锁
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  // 清理线程池中的线程对象
  threads_.clear();
}

/**
 * @brief 线程池线程的入口函数
 */
void bugu::XThreadPool::Run() {
#ifdef BUGU_DEBUG
  ::std::stringstream str_info;
  str_info << "Run: " << ::std::this_thread::get_id() << ::std::endl;
  ::std::cout << str_info.str();
#endif

  while (is_running_) {
    // 获取任务
    auto task = GetTask();
    // 获取到空指针, continue之后然后继续获取或退出线程
    if (nullptr == task) {
      continue;
    }

    ++task_run_count_;  // 设置运行中的任务个数
    try {
      // 执行任务
      task->Main();
    } catch (::std::exception &e) {
      ::std::stringstream str_e;
      str_e << "Failure in thread " << ::std::this_thread::get_id() << ", Exception: " << e.what() << ::std::endl;
      ::std::cerr << str_e.str();
    } catch (...) {
      ::std::stringstream str_e;
      str_e << "Unknown failure in thread " << ::std::this_thread::get_id() << ::std::endl;
      ::std::cerr << str_e.str();
    }
    --task_run_count_;
#ifdef BUGU_DEBUG
    ::std::cout << "run: " << task_run_count_ << ::std::endl;
#endif
  }
}

/**
 * @brief 插入任务
 * @param _x_task 任务指针
 */
void bugu::XThreadPool::AddTask(::std::shared_ptr<XTaskBase> &&_x_task) {
  // 将任务插入到队列
  {
    // 独占锁
    ::std::unique_lock<::std::shared_mutex> lock(mutex_);
    // 将线程池运行状态函数的函数指针传入任务中
    _x_task->is_running = [this] {
      return is_running();
    };
    x_tasks_.push(_x_task);
  }

  // 通知一个线程取任务
  cv_.notify_one();
}

/**
 * @brief 获取任务指针
 * @return XTaskBase* 任务指针
 */
::std::shared_ptr<bugu::XTaskBase> bugu::XThreadPool::GetTask() {
  // 独占锁，防止抢占
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  // 当任务队列为空就阻塞
  if (x_tasks_.empty()) {
    cv_.wait(lock);
  }

  // 退出
  if (!is_running_) {
    return nullptr;
  }

  // 防止多次通知
  if (x_tasks_.empty()) {
    return nullptr;
  }

  // 取出队头任务
  auto task = x_tasks_.front();
  x_tasks_.pop();
  return task;
}

/**
 * 获取线程池运行状态
 * @return bool 线程池运行状态
 */
bool bugu::XThreadPool::is_running() const {
  return is_running_;
}

/**
 * 获取线程池当前执行中的任务数量
 * @return int 任务数量
 */
int bugu::XThreadPool::task_run_count() {
  return task_run_count_;
}

```

`app/obfusion/service/src/thread_pool/x_thread_pool.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_
#define BUGU_OBFUSION_SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <queue>
#include <shared_mutex>
#include <thread>
#include <vector>

namespace bugu {
class XTaskBase;

/**
 * @brief 线程池
 */
class XThreadPool {
 private:
  ::std::size_t thread_nums_ = 0; ///< 线程数量
  ::std::vector<::std::unique_ptr<::std::thread>> threads_;  ///< 线程池线程
  ::std::queue<::std::shared_ptr<XTaskBase>> x_tasks_;   ///< 任务队列
  ::std::atomic<bool> is_running_ = false;      ///< 线程池运行状态
  ::std::atomic<int> task_run_count_ = 0; ///< 正在运行的任务数量，原子变量，线程安全

  mutable ::std::shared_mutex mutex_;
  ::std::condition_variable_any cv_;

 public:
  ~XThreadPool();

  // 禁止生成拷移动构造函数, 拷贝构造函数
  XThreadPool(XThreadPool &&_pool) = delete;
  XThreadPool(const XThreadPool &_pool) = delete;
  XThreadPool &operator=(const XThreadPool &_pool) = delete;

  /**
   * @brief 单件模式
   * @return XThreadPool*
   */
  static XThreadPool *Get() {
    static XThreadPool p;
    return &p;
  }

 private:
  XThreadPool() = default;

 public:
  /**
   * @brief 初始化所有线程，并启动线程
   */
  ::std::size_t Init(::std::size_t _thread_nums);

  /**
   * @brief 线程池退出
   */
  void Stop();

  /**
   * @brief 插入任务
   * @param _x_task 任务指针
   */
  void AddTask(::std::shared_ptr<XTaskBase> &&_x_task);

 private:
  /**
   * @brief 线程池线程的入口函数
   */
  void Run();

  /**
   * @brief 获取任务指针
   * @return XTaskBase* 任务指针
   */
  ::std::shared_ptr<XTaskBase> GetTask();

  // 获取器和设置器
 public:
  /**
   * 获取线程池运行状态
   * @return bool 线程池运行状态
   */
  bool is_running() const;

  /**
   * 获取线程池当前执行中的任务数量
   * @return int 任务数量
   */
  int task_run_count();
};
} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_

```

`app/obfusion/service/src/utils/credentials.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/26.
//

#include "credentials.h"

#include <fstream>

::std::string bugu::Credentials::GetFileContents(const std::string &_path) {
  ::std::ifstream file_stream(_path);
  if (!file_stream.good()) {
    ::std::cerr << "Open Cert File Failed" << ::std::endl;
    exit(-1);
  }
  ::std::string contents;
  contents.assign((::std::istreambuf_iterator<char>(file_stream)), ::std::istreambuf_iterator<char>());
  file_stream.close();
  return contents;
}

::std::shared_ptr<::grpc::ServerCredentials> bugu::Credentials::GetServerCredentials(const ::std::string &_root_cert_dir,
                                                                                     const ::std::string &_server_key_dir,
                                                                                     const ::std::string &_server_cert_dir) {
  auto root_cert = GetFileContents(_root_cert_dir);
  auto key_str = GetFileContents(_server_key_dir);
  auto cert_str = GetFileContents(_server_cert_dir);
  auto x509KeyPair = ::grpc::SslServerCredentialsOptions::PemKeyCertPair{key_str, cert_str};

  ::grpc::SslServerCredentialsOptions cred_option;
  cred_option.pem_root_certs = root_cert;
  cred_option.pem_key_cert_pairs.push_back(x509KeyPair);

  return ::grpc::SslServerCredentials(cred_option);
}

::std::shared_ptr<::grpc::ChannelCredentials> bugu::Credentials::GetClientCredentials(const ::std::string &_root_cert_dir,
                                                                                      const ::std::string &_client_key_dir,
                                                                                      const ::std::string &_client_cert_dir) {
  auto root_cert = GetFileContents(_root_cert_dir);
  auto key_str = GetFileContents(_client_key_dir);
  auto cert_str = GetFileContents(_client_cert_dir);

  ::grpc::SslCredentialsOptions cred_option;
  cred_option.pem_root_certs = root_cert;
  cred_option.pem_private_key = key_str;
  cred_option.pem_cert_chain = cert_str;

  return ::grpc::SslCredentials(cred_option);
}

```

`app/obfusion/service/src/utils/credentials.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/26.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_UTILS_CREDENTIALS_H_
#define BUGU_OBFUSION_SERVICE_SRC_UTILS_CREDENTIALS_H_

#include <grpc++/grpc++.h>

#include <string>
#include <memory>

namespace bugu {

class Credentials {
 public:
  static ::std::string GetFileContents(const ::std::string &_path);

  static ::std::shared_ptr<::grpc::ServerCredentials> GetServerCredentials(const ::std::string &_root_cert_dir = "/cert/ca.crt",
                                                                           const ::std::string &_server_key_dir = "/cert/server.key",
                                                                           const ::std::string &_server_cert_dir = "/cert/server.pem");
  static ::std::shared_ptr<::grpc::ChannelCredentials> GetClientCredentials(const ::std::string &_root_cert_dir = "/cert/ca.crt",
                                                                            const ::std::string &_client_key_dir = "/cert/client.key",
                                                                            const ::std::string &_client_cert_dir = "/cert/client.pem");
};

} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_UTILS_CREDENTIALS_H_

```

`app/obfusion/service/src/utils/interrupt_sleeper.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/26.
//

#ifndef BUGU_OBFUSION_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_
#define BUGU_OBFUSION_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_

#include <atomic>
#include <chrono>
#include <memory>
#include <mutex>

namespace bugu {

class InterruptSleeper {
 private:
  ::std::condition_variable cv_;
  ::std::mutex mutex_;
  ::std::atomic<bool> terminate_ = false;

 public:
  void wait() {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    cv_.wait(lock, [&] { return terminate_.load(); });
  }

  template<typename R, typename P>
  bool wait_for(::std::chrono::duration<R, P> const &_time) {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    return !cv_.wait_for(lock, _time, [&] { return terminate_.load(); });
  }

  void interrupt() {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    terminate_.store(true);
    cv_.notify_all();
  }
};

} // namespace bugu

#endif //BUGU_OBFUSION_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_

```

`app/packer/service/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.11)

set(LIB_MAJOR_VERSION "1")
set(LIB_MINOR_VERSION "0")
set(LIB_PATCH_VERSION "0")
set(LIB_VERSION_STRING "${LIB_MAJOR_VERSION}.${LIB_MINOR_VERSION}.${LIB_PATCH_VERSION}")

project(bugu.packer.service
        VERSION "${LIB_VERSION_STRING}"
        LANGUAGES C CXX
        HOMEPAGE_URL "https://github.com/hominsu/bugu")

set(CMAKE_CXX_STANDARD 17)

message("")
message("Operation system is ${CMAKE_SYSTEM}")
message("Current compiler: ${CMAKE_CXX_COMPILER_ID}")
message("Current compiler version: ${CMAKE_CXX_COMPILER_VERSION}")
message("Current compiler directory: ${CMAKE_CXX_COMPILER}")
if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
    link_directories(/opt/homebrew/lib)
    include_directories(/opt/homebrew/include)
    set(OPENSSL_ROOT_DIR /opt/homebrew/opt/openssl@1.1/)
    set(OPENSSL_INCLUDE_DIR /opt/homebrew/opt/openssl@1.1/include)
elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
    link_directories(/usr/local/lib)
    include_directories(/usr/local/include)
elseif (${CMAKE_SYSTEM_NAME} MATCHES "Windows")
    if (MSVC)   # if msvc
        add_compile_options("$<$<C_COMPILER_ID:MSVC>:/utf-8>")
        add_compile_options("$<$<CXX_COMPILER_ID:MSVC>:/utf-8>")
    endif ()
else ()
    message(FATAL_ERROR "Platform ${CMAKE_SYSTEM} is not support for this project")
endif ()

if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel." FORCE)
endif ()

if (CMAKE_BUILD_TYPE STREQUAL Debug)
    ADD_DEFINITIONS(-DBUGU_DEBUG)
    message(STATUS "CMake Build Type: Debug")
    message("")
elseif (CMAKE_BUILD_TYPE STREQUAL Release)
    ADD_DEFINITIONS(-DBUGU_RELEASE)
    message(STATUS "CMake Build Type: Release")
    message("")
endif ()

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror -Wno-unused-parameter")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g")
#set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O3")

find_program(CCACHE_FOUND ccache)
if (CCACHE_FOUND)
    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)
    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)
    if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Qunused-arguments -fcolor-diagnostics")
    endif ()
endif (CCACHE_FOUND)

if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    if (NUEJSON_ENABLE_INSTRUMENTATION_OPT AND NOT CMAKE_CROSSCOMPILING)
        if (CMAKE_SYSTEM_PROCESSOR STREQUAL "powerpc" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64le")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mcpu=native")
        elseif (NOT CMAKE_SYSTEM_PROCESSOR STREQUAL "arm64" AND NOT CMAKE_SYSTEM_NAME MATCHES "Darwin")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native")
        endif ()
    endif ()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror")
    set(EXTRA_CXX_FLAGS -Weffc++ -Wswitch-default -Wfloat-equal -Wconversion -Wsign-conversion)
elseif (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    if (NOT CMAKE_CROSSCOMPILING)
        if (CMAKE_SYSTEM_PROCESSOR STREQUAL "powerpc" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64" OR CMAKE_SYSTEM_PROCESSOR STREQUAL "ppc64le")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mcpu=native")
        elseif (NOT CMAKE_SYSTEM_PROCESSOR STREQUAL "arm64" AND NOT CMAKE_SYSTEM_NAME MATCHES "Darwin")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native")
        endif ()
    endif ()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Werror -Wno-missing-field-initializers -Wno-register")
    set(EXTRA_CXX_FLAGS -Weffc++ -Wswitch-default -Wfloat-equal -Wconversion -Wimplicit-fallthrough)
elseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    add_definitions(-D_CRT_SECURE_NO_WARNINGS=1)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /EHsc")
    # Always compile with /WX
    if (CMAKE_CXX_FLAGS MATCHES "/WX-")
        string(REGEX REPLACE "/WX-" "/WX" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
    else ()
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /WX")
    endif ()
elseif (CMAKE_CXX_COMPILER_ID MATCHES "XL")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -qarch=auto")
endif ()

add_subdirectory(src)
```

`app/packer/service/Dockerfile`:

```
#build stage
FROM alpine:latest as builder
# app dir
ARG APP_RELATIVE_PATH
# install: git(makefile use git to describe the version)
RUN apk --no-cache add bash findutils git build-base cmake \
    re2-dev c-ares-dev grpc grpc-dev protobuf-dev libprotobuf protoc libprotoc \
    openssl-dev openssl-libs-static
# build app
COPY . /src
WORKDIR /src
RUN make grpc-cpp && cd /src/app/obfusion/service && make conf
WORKDIR /src/app/${APP_RELATIVE_PATH}
RUN git submodule update --init --recommend-shallow --recursive
RUN make build

#final stage
FROM alpine:latest
# image info
ARG AUTHOR_NAME
ARG AUTHOR_EMAIL
ARG VERSION
# label
LABEL author=$AUTHOR_NAME email=${AUTHOR_EMAIL} version=$VERSION
# app dir
ARG APP_RELATIVE_PATH
# install: tzdata c-ares libprotobuf
RUN apk --no-cache add tzdata ca-certificates c-ares libprotobuf grpc
# cpoy the app from builder
COPY --from=builder /src/app/${APP_RELATIVE_PATH}/bin /app
WORKDIR /app
EXPOSE 9000
VOLUME /data/conf
CMD ["./server"]

```

`app/packer/service/Makefile`:

```
include ../../../cpp_makefile
```

`app/packer/service/configs/config.json`:

```json
{
  "server": {
    "grpc": {
      "addr": "0.0.0.0:9000"
    }
  }
}
```

`app/packer/service/include/bugu_packer/bugu_packer.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#ifndef SERVICE_INCLUDE_BUGU_PACKER_BUGU_PACKER_H_
#define SERVICE_INCLUDE_BUGU_PACKER_BUGU_PACKER_H_

#if defined(__has_builtin)
#define BUGU_HAS_BUILTIN(x) __has_builtin(x)
#else
#define BUGU_HAS_BUILTIN(x) 0
#endif

#ifndef BUGU_ASSERT
#include <cassert>
#define BUGU_ASSERT(x) assert(x)
#endif // BUGU_ASSERT

#if defined(_WIN64) || defined(WIN64) || defined(_WIN32) || defined(WIN32)
#if defined(_WIN64) || defined(WIN64)
#define BUGU_ARCH_64 1
#else
#define BUGU_ARCH_32 1
#endif
#define BUGU_PLATFORM_STRING "windows"
#define BUGU_WINDOWS 1
#elif defined(__linux__)
#define BUGU_PLATFORM_STRING "linux"
#define BUGU_LINUX 1
#ifdef _LP64
#define BUGU_ARCH_64 1
#else /* _LP64 */
#define BUGU_ARCH_32 1
#endif /* _LP64 */
#elif defined(__APPLE__)
#define BUGU_PLATFORM_STRING "osx"
#define BUGU_APPLE 1
#ifdef _LP64
#define BUGU_ARCH_64 1
#else /* _LP64 */
#define BUGU_ARCH_32 1
#endif /* _LP64 */
#endif

#ifndef BUGU_WINDOWS
#define BUGU_WINDOWS 0
#endif
#ifndef BUGU_LINUX
#define BUGU_LINUX 0
#endif
#ifndef BUGU_APPLE
#define BUGU_APPLE 0
#endif

#ifdef _MSC_VER
#if _MSC_VER < 1700
typedef __int8 int8_t;
typedef __int16 int16_t;
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int8 uint8_t;
typedef unsigned __int16 uint16_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif /* _MSC_VER < 1700 */
#else
#include <stdint.h>
#endif /* _MSC_VER */

#ifdef _MSC_VER
#if _MSC_VER < 1400
#define PRIdS __PRIS_PREFIX "d"
#define PRIxS __PRIS_PREFIX "x"
#define PRIuS __PRIS_PREFIX "u"
#define PRIXS __PRIS_PREFIX "X"
#define PRIoS __PRIS_PREFIX "o"
#else
#include <inttypes.h>
#endif /* _MSC_VER < 1400 */
#else
#include <inttypes.h>
#endif /* _MSC_VER */

#endif //SERVICE_INCLUDE_BUGU_PACKER_BUGU_PACKER_H_

```

`app/packer/service/src/CMakeLists.txt`:

```txt
# Threads
find_package(Threads REQUIRED)
if (Threads_FOUND)
    message("")
endif ()

# OpenSSL
set(OPENSSL_USE_STATIC_LIBS true)
find_package(OpenSSL REQUIRED)
if (OPENSSL_FOUND)
    message(STATUS "OPENSSL_VERSION = ${OPENSSL_VERSION}")
    message(STATUS "OPENSSL_INCLUDE_DIR = ${OPENSSL_INCLUDE_DIR}")
    message(STATUS "OPENSSL_LIBRARIES = ${OPENSSL_LIBRARIES}")
endif ()

# Protobuf
set(protobuf_MODULE_COMPATIBLE TRUE)
find_package(Protobuf REQUIRED)
if (Protobuf_FOUND)
    message(STATUS "Protobuf_VERSION = ${Protobuf_VERSION}")
    message(STATUS "Protobuf_INCLUDE_DIRS = ${Protobuf_INCLUDE_DIRS}")
    message(STATUS "Protobuf_LIBRARY = ${Protobuf_LIBRARY}")
endif ()

# gRPC
find_package(gRPC CONFIG REQUIRED)
if (gRPC_FOUND)
    message(STATUS "gRPC_VERSION = ${gRPC_VERSION}")
endif ()

include_directories(${PROJECT_SOURCE_DIR}/include)
include_directories(${PROJECT_SOURCE_DIR}/third_party)
include_directories(${PROJECT_SOURCE_DIR}/../../../)
file(GLOB ProjectSRC
        "../../../../api/packer/service/v1/cpp/*.cc"
        "../../../../api/packer/service/v1/cpp/*.h"
        "thread_pool/*.cc"
        "thread/*.cc"
        "utils/*.cc"
        "conf/*.cc"
        "*.cc")

add_executable(${PROJECT_NAME} ${ProjectSRC})
target_link_libraries(${PROJECT_NAME}
        Threads::Threads
        protobuf::libprotobuf
        gRPC::grpc++_reflection
        gRPC::grpc++)

```

`app/packer/service/src/bugu_packer_impl.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#include "bugu_packer/bugu_packer.h"
#include "bugu_packer_impl.h"
#include "data.h"
#include "packer_task.h"
#include "thread_pool/x_thread_pool.h"

#include <cstring>
#include <string>

::grpc::Status bugu::BuguPackerImpl::Packer(::grpc::ServerContext *_ctx,
                                            const ::bugu_packer::service::v1::PackerRequest *_request,
                                            ::bugu_packer::service::v1::PackerReply *_response) {
  auto size = _request->size();

  auto data = ::bugu::Data::Make(memory_resource_);
  auto buffer = static_cast<char *>(data->New(size));

  ::std::size_t read_bytes;
  ::std::size_t total_read_bytes = 0;

  // Copy the data from request to buffer
  for (auto &d: _request->data()) {
    read_bytes = d.size();
    memcpy(buffer + total_read_bytes, d.data(), read_bytes);
    total_read_bytes += read_bytes;
  }
  BUGU_ASSERT(total_read_bytes == size && "total_read_bytes != size");

  // create the packer task and append to the thread pool, block to wait return
  auto packer_task = ::std::make_shared<PackerTask>(data, memory_resource_);
  thread_pool_->AddTask(packer_task);
  auto ret = packer_task->get_return();

  _response->add_data(ret->data(), ret->size());
  _response->set_size(ret->size());

//  return {::grpc::StatusCode::UNIMPLEMENTED, "method Packer not implemented"};
  return ::grpc::Status::OK;
}

```

`app/packer/service/src/bugu_packer_impl.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef BUGU_PACKER_SERVICE_SRC_BUGU_PACKER_IMPL_H_
#define BUGU_PACKER_SERVICE_SRC_BUGU_PACKER_IMPL_H_

#include "api/packer/service/v1/cpp/bugu_packer.grpc.pb.h"

#include <grpc++/grpc++.h>
#include <memory_resource>
#include <memory>
#include <thread>

namespace bugu {

class XThreadPool;

class BuguPackerImpl final : public bugu_packer::service::v1::BuguPacker::Service {
 private:
  ::bugu::XThreadPool *thread_pool_;  ///< 线程池
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

 public:
  explicit BuguPackerImpl(::bugu::XThreadPool *_thread_pool,
                            ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource)
      : thread_pool_(_thread_pool), memory_resource_(::std::move(_memory_resource)) {};

  ::grpc::Status Packer(::grpc::ServerContext *_ctx,
                          const ::bugu_packer::service::v1::PackerRequest *_request,
                          ::bugu_packer::service::v1::PackerReply *_response) override;
};

} // namespace bugu

#endif //BUGU_PACKER_SERVICE_SRC_BUGU_PACKER_IMPL_H_

```

`app/packer/service/src/bugu_packer_server.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#include "bugu_packer_server.h"
#include "bugu_packer_impl.h"
#include "thread_pool/x_thread_pool.h"
//#include "utils/credentials.h"

#if BUGU_DEBUG
#include <string>
#endif
#include <utility>

bugu::BuguPackerServer::~BuguPackerServer() {
  if (IsRunning()) { Stop(); }
}

bugu::BuguPackerServer *bugu::BuguPackerServer::Init(::std::string _local_address,
                                                         ::bugu::XThreadPool *_thread_pool,
                                                         ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource) {
  // The thread pool and Grpc service are initialized only once
  if (!init_flag()) {
    local_address_ = ::std::move(_local_address);
    thread_pool_ = _thread_pool;
    memory_resource_ = ::std::move(_memory_resource);
    set_init_flag(true);
  }

  return this;
}

void bugu::BuguPackerServer::Start() {
  BUGU_ASSERT(init_flag() && "BuguPackerServer should init first");
  XThread::Start();
}

void bugu::BuguPackerServer::Stop() {
  ::std::function<void()> func = [this]() {
    server_->Shutdown();
  };
  StopWith(func);
}

void bugu::BuguPackerServer::Main() {
  BuguPackerImpl bugu_packer_service(thread_pool_, memory_resource_);

  ::grpc::ServerBuilder builder;
  builder.AddListeningPort(local_address_, ::grpc::InsecureServerCredentials());
  builder.RegisterService(&bugu_packer_service);

  ::std::unique_ptr<::grpc::Server> server(builder.BuildAndStart());
  server_ = ::std::move(server);

  ::std::clog << "BuguPackerServer listening on " << local_address_ << ::std::endl;

  server_->Wait();

  ::std::clog << "BuguPackerServer Shut Down" << ::std::endl;
}

void bugu::BuguPackerServer::set_init_flag(bool _init_flag) {
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);
  init_flag_ = _init_flag;
}

bool bugu::BuguPackerServer::init_flag() {
  ::std::shared_lock<::std::shared_mutex> lock(mutex_);
  return init_flag_;
}

```

`app/packer/service/src/bugu_packer_server.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef BUGU_PACKER_SERVICE_SRC_BUGU_PACKER_SERVER_H_
#define BUGU_PACKER_SERVICE_SRC_BUGU_PACKER_SERVER_H_

#include "bugu_packer/bugu_packer.h"
#include "thread/x_thread.h"

#include <grpc++/grpc++.h>

#include <condition_variable>
#include <memory>
#include <memory_resource>
#include <mutex>
#include <utility>

namespace bugu {

class XThreadPool;

class BuguPackerServer final : public XThread {
 private:
  bool init_flag_ = false;

  ::std::string local_address_{};  ///< rpc 服务地址：ip+端口
  ::std::unique_ptr<::grpc::Server> server_{};  ///< rpc 服务句柄，用智能指针管理

  ::bugu::XThreadPool *thread_pool_ = nullptr;  ///< 线程池
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

  ::std::shared_mutex mutex_;

 public:
  ~BuguPackerServer();
  static BuguPackerServer *Get() {
    static BuguPackerServer s;
    return &s;
  }

 private:
  BuguPackerServer() = default;

 public:
  BuguPackerServer *Init(::std::string _local_address,
                         ::bugu::XThreadPool *_thread_pool,
                         ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource);

  void Start() override;

  void Main() override;

  void Stop() override;

  void set_init_flag(bool _init_flag);

  bool init_flag();
};

} // namespace bugu

#endif //BUGU_PACKER_SERVICE_SRC_BUGU_PACKER_SERVER_H_

```

`app/packer/service/src/conf/conf.pb.cc`:

```cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conf.proto

#include "conf.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace config {
constexpr Bootstrap::Bootstrap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : server_(nullptr){}
struct BootstrapDefaultTypeInternal {
  constexpr BootstrapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BootstrapDefaultTypeInternal() {}
  union {
    Bootstrap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
constexpr Server_GRPC::Server_GRPC(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : network_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , addr_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , timeout_(nullptr){}
struct Server_GRPCDefaultTypeInternal {
  constexpr Server_GRPCDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Server_GRPCDefaultTypeInternal() {}
  union {
    Server_GRPC _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Server_GRPCDefaultTypeInternal _Server_GRPC_default_instance_;
constexpr Server::Server(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : grpc_(nullptr){}
struct ServerDefaultTypeInternal {
  constexpr ServerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServerDefaultTypeInternal() {}
  union {
    Server _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServerDefaultTypeInternal _Server_default_instance_;
}  // namespace config
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_conf_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_conf_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_conf_2eproto = nullptr;

const uint32_t TableStruct_conf_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Bootstrap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Bootstrap, server_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, network_),
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, addr_),
  PROTOBUF_FIELD_OFFSET(::config::Server_GRPC, timeout_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::config::Server, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::config::Server, grpc_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::config::Bootstrap)},
  { 7, -1, -1, sizeof(::config::Server_GRPC)},
  { 16, -1, -1, sizeof(::config::Server)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Bootstrap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Server_GRPC_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::config::_Server_default_instance_),
};

const char descriptor_table_protodef_conf_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\nconf.proto\022\006config\032\036google/protobuf/du"
  "ration.proto\"+\n\tBootstrap\022\036\n\006server\030\001 \001("
  "\0132\016.config.Server\"~\n\006Server\022!\n\004grpc\030\001 \001("
  "\0132\023.config.Server.GRPC\032Q\n\004GRPC\022\017\n\007networ"
  "k\030\001 \001(\t\022\014\n\004addr\030\002 \001(\t\022*\n\007timeout\030\003 \001(\0132\031"
  ".google.protobuf.Durationb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_conf_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_conf_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_conf_2eproto = {
  false, false, 233, descriptor_table_protodef_conf_2eproto, "conf.proto", 
  &descriptor_table_conf_2eproto_once, descriptor_table_conf_2eproto_deps, 1, 3,
  schemas, file_default_instances, TableStruct_conf_2eproto::offsets,
  file_level_metadata_conf_2eproto, file_level_enum_descriptors_conf_2eproto, file_level_service_descriptors_conf_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_conf_2eproto_getter() {
  return &descriptor_table_conf_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_conf_2eproto(&descriptor_table_conf_2eproto);
namespace config {

// ===================================================================

class Bootstrap::_Internal {
 public:
  static const ::config::Server& server(const Bootstrap* msg);
};

const ::config::Server&
Bootstrap::_Internal::server(const Bootstrap* msg) {
  return *msg->server_;
}
Bootstrap::Bootstrap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Bootstrap)
}
Bootstrap::Bootstrap(const Bootstrap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_server()) {
    server_ = new ::config::Server(*from.server_);
  } else {
    server_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Bootstrap)
}

inline void Bootstrap::SharedCtor() {
server_ = nullptr;
}

Bootstrap::~Bootstrap() {
  // @@protoc_insertion_point(destructor:config.Bootstrap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Bootstrap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete server_;
}

void Bootstrap::ArenaDtor(void* object) {
  Bootstrap* _this = reinterpret_cast< Bootstrap* >(object);
  (void)_this;
}
void Bootstrap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Bootstrap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Bootstrap::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Bootstrap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && server_ != nullptr) {
    delete server_;
  }
  server_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Bootstrap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .config.Server server = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_server(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Bootstrap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Bootstrap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .config.Server server = 1;
  if (this->_internal_has_server()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::server(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Bootstrap)
  return target;
}

size_t Bootstrap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Bootstrap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .config.Server server = 1;
  if (this->_internal_has_server()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *server_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Bootstrap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Bootstrap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Bootstrap::GetClassData() const { return &_class_data_; }

void Bootstrap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Bootstrap *>(to)->MergeFrom(
      static_cast<const Bootstrap &>(from));
}


void Bootstrap::MergeFrom(const Bootstrap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Bootstrap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_server()) {
    _internal_mutable_server()->::config::Server::MergeFrom(from._internal_server());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Bootstrap::CopyFrom(const Bootstrap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Bootstrap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bootstrap::IsInitialized() const {
  return true;
}

void Bootstrap::InternalSwap(Bootstrap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(server_, other->server_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Bootstrap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[0]);
}

// ===================================================================

class Server_GRPC::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Duration& timeout(const Server_GRPC* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Duration&
Server_GRPC::_Internal::timeout(const Server_GRPC* msg) {
  return *msg->timeout_;
}
void Server_GRPC::clear_timeout() {
  if (GetArenaForAllocation() == nullptr && timeout_ != nullptr) {
    delete timeout_;
  }
  timeout_ = nullptr;
}
Server_GRPC::Server_GRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Server.GRPC)
}
Server_GRPC::Server_GRPC(const Server_GRPC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_network().empty()) {
    network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_network(), 
      GetArenaForAllocation());
  }
  addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_addr().empty()) {
    addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_addr(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_timeout()) {
    timeout_ = new ::PROTOBUF_NAMESPACE_ID::Duration(*from.timeout_);
  } else {
    timeout_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Server.GRPC)
}

inline void Server_GRPC::SharedCtor() {
network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
addr_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
timeout_ = nullptr;
}

Server_GRPC::~Server_GRPC() {
  // @@protoc_insertion_point(destructor:config.Server.GRPC)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Server_GRPC::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  network_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  addr_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete timeout_;
}

void Server_GRPC::ArenaDtor(void* object) {
  Server_GRPC* _this = reinterpret_cast< Server_GRPC* >(object);
  (void)_this;
}
void Server_GRPC::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Server_GRPC::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Server_GRPC::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Server.GRPC)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  network_.ClearToEmpty();
  addr_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && timeout_ != nullptr) {
    delete timeout_;
  }
  timeout_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Server_GRPC::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string network = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_network();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "config.Server.GRPC.network"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string addr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_addr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "config.Server.GRPC.addr"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Duration timeout = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timeout(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Server_GRPC::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Server.GRPC)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string network = 1;
  if (!this->_internal_network().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_network().data(), static_cast<int>(this->_internal_network().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "config.Server.GRPC.network");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_network(), target);
  }

  // string addr = 2;
  if (!this->_internal_addr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_addr().data(), static_cast<int>(this->_internal_addr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "config.Server.GRPC.addr");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_addr(), target);
  }

  // .google.protobuf.Duration timeout = 3;
  if (this->_internal_has_timeout()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::timeout(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Server.GRPC)
  return target;
}

size_t Server_GRPC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Server.GRPC)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string network = 1;
  if (!this->_internal_network().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_network());
  }

  // string addr = 2;
  if (!this->_internal_addr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_addr());
  }

  // .google.protobuf.Duration timeout = 3;
  if (this->_internal_has_timeout()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *timeout_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Server_GRPC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Server_GRPC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Server_GRPC::GetClassData() const { return &_class_data_; }

void Server_GRPC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Server_GRPC *>(to)->MergeFrom(
      static_cast<const Server_GRPC &>(from));
}


void Server_GRPC::MergeFrom(const Server_GRPC& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Server.GRPC)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_network().empty()) {
    _internal_set_network(from._internal_network());
  }
  if (!from._internal_addr().empty()) {
    _internal_set_addr(from._internal_addr());
  }
  if (from._internal_has_timeout()) {
    _internal_mutable_timeout()->::PROTOBUF_NAMESPACE_ID::Duration::MergeFrom(from._internal_timeout());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Server_GRPC::CopyFrom(const Server_GRPC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Server.GRPC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Server_GRPC::IsInitialized() const {
  return true;
}

void Server_GRPC::InternalSwap(Server_GRPC* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &network_, lhs_arena,
      &other->network_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &addr_, lhs_arena,
      &other->addr_, rhs_arena
  );
  swap(timeout_, other->timeout_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Server_GRPC::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[1]);
}

// ===================================================================

class Server::_Internal {
 public:
  static const ::config::Server_GRPC& grpc(const Server* msg);
};

const ::config::Server_GRPC&
Server::_Internal::grpc(const Server* msg) {
  return *msg->grpc_;
}
Server::Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:config.Server)
}
Server::Server(const Server& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_grpc()) {
    grpc_ = new ::config::Server_GRPC(*from.grpc_);
  } else {
    grpc_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:config.Server)
}

inline void Server::SharedCtor() {
grpc_ = nullptr;
}

Server::~Server() {
  // @@protoc_insertion_point(destructor:config.Server)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Server::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete grpc_;
}

void Server::ArenaDtor(void* object) {
  Server* _this = reinterpret_cast< Server* >(object);
  (void)_this;
}
void Server::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Server::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Server::Clear() {
// @@protoc_insertion_point(message_clear_start:config.Server)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && grpc_ != nullptr) {
    delete grpc_;
  }
  grpc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Server::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .config.Server.GRPC grpc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_grpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Server::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:config.Server)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .config.Server.GRPC grpc = 1;
  if (this->_internal_has_grpc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::grpc(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:config.Server)
  return target;
}

size_t Server::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:config.Server)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .config.Server.GRPC grpc = 1;
  if (this->_internal_has_grpc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *grpc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Server::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Server::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Server::GetClassData() const { return &_class_data_; }

void Server::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Server *>(to)->MergeFrom(
      static_cast<const Server &>(from));
}


void Server::MergeFrom(const Server& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:config.Server)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_grpc()) {
    _internal_mutable_grpc()->::config::Server_GRPC::MergeFrom(from._internal_grpc());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Server::CopyFrom(const Server& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:config.Server)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Server::IsInitialized() const {
  return true;
}

void Server::InternalSwap(Server* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(grpc_, other->grpc_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Server::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_conf_2eproto_getter, &descriptor_table_conf_2eproto_once,
      file_level_metadata_conf_2eproto[2]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace config
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::config::Bootstrap* Arena::CreateMaybeMessage< ::config::Bootstrap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Bootstrap >(arena);
}
template<> PROTOBUF_NOINLINE ::config::Server_GRPC* Arena::CreateMaybeMessage< ::config::Server_GRPC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Server_GRPC >(arena);
}
template<> PROTOBUF_NOINLINE ::config::Server* Arena::CreateMaybeMessage< ::config::Server >(Arena* arena) {
  return Arena::CreateMessageInternal< ::config::Server >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

```

`app/packer/service/src/conf/conf.pb.h`:

```h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_conf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_conf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_conf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_conf_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_conf_2eproto;
namespace config {
class Bootstrap;
struct BootstrapDefaultTypeInternal;
extern BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
class Server;
struct ServerDefaultTypeInternal;
extern ServerDefaultTypeInternal _Server_default_instance_;
class Server_GRPC;
struct Server_GRPCDefaultTypeInternal;
extern Server_GRPCDefaultTypeInternal _Server_GRPC_default_instance_;
}  // namespace config
PROTOBUF_NAMESPACE_OPEN
template<> ::config::Bootstrap* Arena::CreateMaybeMessage<::config::Bootstrap>(Arena*);
template<> ::config::Server* Arena::CreateMaybeMessage<::config::Server>(Arena*);
template<> ::config::Server_GRPC* Arena::CreateMaybeMessage<::config::Server_GRPC>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace config {

// ===================================================================

class Bootstrap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Bootstrap) */ {
 public:
  inline Bootstrap() : Bootstrap(nullptr) {}
  ~Bootstrap() override;
  explicit constexpr Bootstrap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bootstrap(const Bootstrap& from);
  Bootstrap(Bootstrap&& from) noexcept
    : Bootstrap() {
    *this = ::std::move(from);
  }

  inline Bootstrap& operator=(const Bootstrap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bootstrap& operator=(Bootstrap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bootstrap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bootstrap* internal_default_instance() {
    return reinterpret_cast<const Bootstrap*>(
               &_Bootstrap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Bootstrap& a, Bootstrap& b) {
    a.Swap(&b);
  }
  inline void Swap(Bootstrap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bootstrap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bootstrap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bootstrap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bootstrap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bootstrap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bootstrap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Bootstrap";
  }
  protected:
  explicit Bootstrap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 1,
  };
  // .config.Server server = 1;
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::config::Server& server() const;
  PROTOBUF_NODISCARD ::config::Server* release_server();
  ::config::Server* mutable_server();
  void set_allocated_server(::config::Server* server);
  private:
  const ::config::Server& _internal_server() const;
  ::config::Server* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::config::Server* server);
  ::config::Server* unsafe_arena_release_server();

  // @@protoc_insertion_point(class_scope:config.Bootstrap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::config::Server* server_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server_GRPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Server.GRPC) */ {
 public:
  inline Server_GRPC() : Server_GRPC(nullptr) {}
  ~Server_GRPC() override;
  explicit constexpr Server_GRPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server_GRPC(const Server_GRPC& from);
  Server_GRPC(Server_GRPC&& from) noexcept
    : Server_GRPC() {
    *this = ::std::move(from);
  }

  inline Server_GRPC& operator=(const Server_GRPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server_GRPC& operator=(Server_GRPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server_GRPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server_GRPC* internal_default_instance() {
    return reinterpret_cast<const Server_GRPC*>(
               &_Server_GRPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Server_GRPC& a, Server_GRPC& b) {
    a.Swap(&b);
  }
  inline void Swap(Server_GRPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server_GRPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server_GRPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server_GRPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server_GRPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Server_GRPC& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server_GRPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Server.GRPC";
  }
  protected:
  explicit Server_GRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkFieldNumber = 1,
    kAddrFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string network = 1;
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // .google.protobuf.Duration timeout = 3;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // @@protoc_insertion_point(class_scope:config.Server.GRPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::Duration* timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Server) */ {
 public:
  inline Server() : Server(nullptr) {}
  ~Server() override;
  explicit constexpr Server(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server(const Server& from);
  Server(Server&& from) noexcept
    : Server() {
    *this = ::std::move(from);
  }

  inline Server& operator=(const Server& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server& operator=(Server&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server* internal_default_instance() {
    return reinterpret_cast<const Server*>(
               &_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Server& a, Server& b) {
    a.Swap(&b);
  }
  inline void Swap(Server* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Server& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Server";
  }
  protected:
  explicit Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Server_GRPC GRPC;

  // accessors -------------------------------------------------------

  enum : int {
    kGrpcFieldNumber = 1,
  };
  // .config.Server.GRPC grpc = 1;
  bool has_grpc() const;
  private:
  bool _internal_has_grpc() const;
  public:
  void clear_grpc();
  const ::config::Server_GRPC& grpc() const;
  PROTOBUF_NODISCARD ::config::Server_GRPC* release_grpc();
  ::config::Server_GRPC* mutable_grpc();
  void set_allocated_grpc(::config::Server_GRPC* grpc);
  private:
  const ::config::Server_GRPC& _internal_grpc() const;
  ::config::Server_GRPC* _internal_mutable_grpc();
  public:
  void unsafe_arena_set_allocated_grpc(
      ::config::Server_GRPC* grpc);
  ::config::Server_GRPC* unsafe_arena_release_grpc();

  // @@protoc_insertion_point(class_scope:config.Server)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::config::Server_GRPC* grpc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_conf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Bootstrap

// .config.Server server = 1;
inline bool Bootstrap::_internal_has_server() const {
  return this != internal_default_instance() && server_ != nullptr;
}
inline bool Bootstrap::has_server() const {
  return _internal_has_server();
}
inline void Bootstrap::clear_server() {
  if (GetArenaForAllocation() == nullptr && server_ != nullptr) {
    delete server_;
  }
  server_ = nullptr;
}
inline const ::config::Server& Bootstrap::_internal_server() const {
  const ::config::Server* p = server_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Server&>(
      ::config::_Server_default_instance_);
}
inline const ::config::Server& Bootstrap::server() const {
  // @@protoc_insertion_point(field_get:config.Bootstrap.server)
  return _internal_server();
}
inline void Bootstrap::unsafe_arena_set_allocated_server(
    ::config::Server* server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_);
  }
  server_ = server;
  if (server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Bootstrap.server)
}
inline ::config::Server* Bootstrap::release_server() {
  
  ::config::Server* temp = server_;
  server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Server* Bootstrap::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:config.Bootstrap.server)
  
  ::config::Server* temp = server_;
  server_ = nullptr;
  return temp;
}
inline ::config::Server* Bootstrap::_internal_mutable_server() {
  
  if (server_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Server>(GetArenaForAllocation());
    server_ = p;
  }
  return server_;
}
inline ::config::Server* Bootstrap::mutable_server() {
  ::config::Server* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:config.Bootstrap.server)
  return _msg;
}
inline void Bootstrap::set_allocated_server(::config::Server* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::config::Server>::GetOwningArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    
  } else {
    
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:config.Bootstrap.server)
}

// -------------------------------------------------------------------

// Server_GRPC

// string network = 1;
inline void Server_GRPC::clear_network() {
  network_.ClearToEmpty();
}
inline const std::string& Server_GRPC::network() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server_GRPC::set_network(ArgT0&& arg0, ArgT... args) {
 
 network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Server.GRPC.network)
}
inline std::string* Server_GRPC::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.network)
  return _s;
}
inline const std::string& Server_GRPC::_internal_network() const {
  return network_.Get();
}
inline void Server_GRPC::_internal_set_network(const std::string& value) {
  
  network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Server_GRPC::_internal_mutable_network() {
  
  return network_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Server_GRPC::release_network() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.network)
  return network_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Server_GRPC::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  network_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), network,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.network)
}

// string addr = 2;
inline void Server_GRPC::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& Server_GRPC::addr() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server_GRPC::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Server.GRPC.addr)
}
inline std::string* Server_GRPC::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.addr)
  return _s;
}
inline const std::string& Server_GRPC::_internal_addr() const {
  return addr_.Get();
}
inline void Server_GRPC::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Server_GRPC::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Server_GRPC::release_addr() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Server_GRPC::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.addr)
}

// .google.protobuf.Duration timeout = 3;
inline bool Server_GRPC::_internal_has_timeout() const {
  return this != internal_default_instance() && timeout_ != nullptr;
}
inline bool Server_GRPC::has_timeout() const {
  return _internal_has_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Server_GRPC::_internal_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Server_GRPC::timeout() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.timeout)
  return _internal_timeout();
}
inline void Server_GRPC::unsafe_arena_set_allocated_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Server.GRPC.timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::release_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::_internal_mutable_timeout() {
  
  if (timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    timeout_ = p;
  }
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::mutable_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.timeout)
  return _msg;
}
inline void Server_GRPC::set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout));
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.timeout)
}

// -------------------------------------------------------------------

// Server

// .config.Server.GRPC grpc = 1;
inline bool Server::_internal_has_grpc() const {
  return this != internal_default_instance() && grpc_ != nullptr;
}
inline bool Server::has_grpc() const {
  return _internal_has_grpc();
}
inline void Server::clear_grpc() {
  if (GetArenaForAllocation() == nullptr && grpc_ != nullptr) {
    delete grpc_;
  }
  grpc_ = nullptr;
}
inline const ::config::Server_GRPC& Server::_internal_grpc() const {
  const ::config::Server_GRPC* p = grpc_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Server_GRPC&>(
      ::config::_Server_GRPC_default_instance_);
}
inline const ::config::Server_GRPC& Server::grpc() const {
  // @@protoc_insertion_point(field_get:config.Server.grpc)
  return _internal_grpc();
}
inline void Server::unsafe_arena_set_allocated_grpc(
    ::config::Server_GRPC* grpc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grpc_);
  }
  grpc_ = grpc;
  if (grpc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Server.grpc)
}
inline ::config::Server_GRPC* Server::release_grpc() {
  
  ::config::Server_GRPC* temp = grpc_;
  grpc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Server_GRPC* Server::unsafe_arena_release_grpc() {
  // @@protoc_insertion_point(field_release:config.Server.grpc)
  
  ::config::Server_GRPC* temp = grpc_;
  grpc_ = nullptr;
  return temp;
}
inline ::config::Server_GRPC* Server::_internal_mutable_grpc() {
  
  if (grpc_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Server_GRPC>(GetArenaForAllocation());
    grpc_ = p;
  }
  return grpc_;
}
inline ::config::Server_GRPC* Server::mutable_grpc() {
  ::config::Server_GRPC* _msg = _internal_mutable_grpc();
  // @@protoc_insertion_point(field_mutable:config.Server.grpc)
  return _msg;
}
inline void Server::set_allocated_grpc(::config::Server_GRPC* grpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete grpc_;
  }
  if (grpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::config::Server_GRPC>::GetOwningArena(grpc);
    if (message_arena != submessage_arena) {
      grpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grpc, submessage_arena);
    }
    
  } else {
    
  }
  grpc_ = grpc;
  // @@protoc_insertion_point(field_set_allocated:config.Server.grpc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_conf_2eproto

```

`app/packer/service/src/conf/conf.proto`:

```proto
syntax = "proto3";

package config;

import "google/protobuf/duration.proto";

message Bootstrap {
  Server server = 1;
}

message Server {
  message GRPC {
    string network = 1;
    string addr = 2;
    google.protobuf.Duration timeout = 3;
  }
  GRPC grpc = 1;
}

```

`app/packer/service/src/conf/config.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef BUGU_PACKER_SERVICE_SRC_CONF_CONFIG_H_
#define BUGU_PACKER_SERVICE_SRC_CONF_CONFIG_H_

#include "bugu_packer/bugu_packer.h"
#include "conf.pb.h"

#include "google/protobuf/message.h"
#include "google/protobuf/util/json_util.h"

#include <cstdio>

#include <exception>

namespace bugu {

class Config {
 public:
  void Load(const char *_path);
  void Scan(::google::protobuf::Message *_message);

 private:
  void read(FILE *_in);

  ::std::string get_str() {
    return {buffer_.begin(), buffer_.end()};
  }

 private:
  std::vector<char> buffer_;
};

inline void Config::Load(const char *_path) {
  FILE *input;
#if BUGU_WINDOWS
  fopen_s(&input, _path, "r");
#elif BUGU_LINUX || BUGU_APPLE
  input = fopen(_path, "r");
#endif
  if (input == nullptr) { exit(EXIT_FAILURE); }
  read(input);
  fclose(input);
}

inline void Config::read(FILE *_in) {
  char buf[65536];
  if (!buffer_.empty()) { buffer_.clear(); }
  while (true) {
    size_t n = fread(buf, 1, sizeof(buf), _in);
    if (n == 0) { break; }
    buffer_.insert(buffer_.end(), buf, buf + n);
  }
}

void Config::Scan(::google::protobuf::Message *_message) {
  if (!google::protobuf::util::JsonStringToMessage(get_str(), _message).ok()) {
    throw ::std::runtime_error("Parse json data to message failed");
  }
}

} // namespace bugu

#endif //BUGU_PACKER_SERVICE_SRC_CONF_CONFIG_H_

```

`app/packer/service/src/data.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#include "bugu_packer/bugu_packer.h"
#include "data.h"

bugu::Data::Data() = default;

bugu::Data::~Data() {
  // 内存池未定义或没有数据就不用释放
  if (nullptr == memory_resource_ || nullptr == data_) {
    return;
  }

  // 释放分配的内存
  memory_resource_->deallocate(data_, memory_size_);
  data_ = nullptr;
  memory_size_ = 0;
  size_ = 0;
}

/**
 * @brief 创建 Data 对象
 * @param _memory_resource 内存池对象
 * @return Data 的智能指针对象
 */
::std::shared_ptr<bugu::Data> bugu::Data::Make(::std::shared_ptr<::std::pmr::memory_resource> _memory_resource) {
  // 创建 Data 的智能指针对象
  ::std::shared_ptr<Data> data_ptr(new bugu::Data());
  data_ptr->memory_resource_ = ::std::move(_memory_resource);

  return data_ptr;
}

/**
 * @brief 创建内存空间
 * @param _memory_size 占用内存字节数
 * @return 创建的内存空间的指针，创建失败为空 nullptr
 */
void *bugu::Data::New(::std::size_t _memory_size) {
  BUGU_ASSERT(_memory_size > 0 && "Data::New _memory_size <= 0");

  // 异常处理
  if (nullptr == memory_resource_) {
    return nullptr;
  }

  // 申请空间
  data_ = memory_resource_->allocate(_memory_size);

  memory_size_ = _memory_size;
  size_ = _memory_size;

  return data_;
}

/**
 * @brief 获取数据块的指针
 * @return 数据块的指针
 */
void *bugu::Data::data() const {
  return data_;
}

/**
 * @brief 获取实际数据的字节数
 * @return 实际数据的字节数
 */
::std::size_t bugu::Data::size() const {
  return size_;
}

/**
 * @brief 设置实际数据字节数
 * @param size 实际数据字节数
 */
void bugu::Data::set_size(::std::size_t _size) {
  size_ = _size;
}

/**
 * @brief 获取分配的内存大小
 * @return ::std::size_t 分配的内存大小
 */
::std::size_t bugu::Data::memory_size() const {
  return memory_size_;
}

/**
 * @brief 是否是文件结尾
 * @return true or false
 */
bool bugu::Data::end() const {
  return end_;
}

/**
 * @brief 设置为文件结尾
 * @param _end true or false
 */
void bugu::Data::set_end(bool _end) {
  end_ = _end;
}


```

`app/packer/service/src/data.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef BUGU_PACKER_SERVICE_SRC_DATA_H_
#define BUGU_PACKER_SERVICE_SRC_DATA_H_

#include <memory>
#include <memory_resource>

namespace bugu {

/**
 * @brief 内存池数据块
 */
class Data {
 private:
  void *data_ = nullptr;
  bool end_ = false;        ///< 是否是文件结尾
  ::std::size_t size_ = 0;         ///< 数据字节数
  ::std::size_t memory_size_ = 0;  ///< 申请内存空间字节数
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

 private:
  Data();

 public:
  ~Data();

  /**
   * @brief 创建 Data 对象
   * @param _memory_resource
   * @return Data 的智能指针对象
   */
  static ::std::shared_ptr<Data> Make(::std::shared_ptr<::std::pmr::memory_resource> _memory_resource);

  /**
   * @brief 创建内存空间
   * @param _memory_size 占用内存字节数
   * @return 创建的内存空间的指针，创建失败为空 nullptr
   */
  void *New(::std::size_t _memory_size);

  /**
   * @brief 获取数据块的指针
   * @return 数据块的指针
   */
  [[nodiscard]] void *data() const;

  /**
   * @brief 获取实际数据的字节数
   * @return 实际数据的字节数
   */
  [[nodiscard]] ::std::size_t size() const;

  /**
   * @brief 设置实际数据字节数
   * @param size 实际数据字节数
   */
  void set_size(::std::size_t _size);

  /**
   * @brief 获取分配的内存大小
   * @return ::std::size_t 分配的内存大小
   */
  [[nodiscard]] ::std::size_t memory_size() const;

  /**
   * @brief 是否是文件结尾
   * @return
   */
  [[nodiscard]] bool end() const;

  /**
   * @brief 设置为文件结尾
   * @param _end true or false
   */
  void set_end(bool _end);
};

/**
 * @brief 定义了 Byte、KB、MB、GB 的大小
 */
enum class Unit : ::std::size_t {
  Byte = 1, KB = 1024 * Byte, MB = 1024 * KB, GB = 1024 * MB
};

/**
 * @brief 将字节的大小换算成对应单位的大小
 * @tparam size_type 输入类型，只能为算术类型
 * @param _size 字节大小
 * @param _unit 转换的单位
 * @return 转换后的数值
 */
template<typename size_type,
    class = typename ::std::enable_if<
        ::std::is_arithmetic<size_type>::value>::type
>
double UnitConvert(size_type _size, Unit _unit) {
  return _size / static_cast<double>(_unit);
}

constexpr ::std::size_t KB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::KB) * _size;
}

constexpr ::std::size_t MB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::MB) * _size;
}

constexpr ::std::size_t GB(::std::size_t _size) {
  return static_cast<::std::size_t>(Unit::GB) * _size;
}

} // namespace bugu

#endif //BUGU_PACKER_SERVICE_SRC_DATA_H_

```

`app/packer/service/src/main.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#include "bugu_packer_server.h"
#include "conf/config.h"
#include "thread_pool/x_thread_pool.h"
#include "utils/interrupt_sleeper.h"

#include <cstdio>
#include <csignal>

#include <memory_resource>
#include <memory>
#include <mutex>

::bugu::InterruptSleeper interrupt_sleeper;

void handler(int signal) {
  fprintf(stdout, "terminate with signal: %" PRId32 "\n", signal);
  interrupt_sleeper.interrupt();
}

int main() {
  auto bootstrap = ::std::make_shared<config::Bootstrap>();

  ::bugu::Config conf;

  conf.Load("/data/conf/config.json");
  conf.Scan(bootstrap.get());

  // Init the threadpool and memory-resource
  auto thread_pool = ::bugu::XThreadPool::Get();
  thread_pool->Init(::std::thread::hardware_concurrency());
  auto memory_resource = ::std::make_shared<::std::pmr::synchronized_pool_resource>();

  // Init Grpc server
  auto server = ::bugu::BuguPackerServer::Get();
  server->Init(bootstrap->server().grpc().addr(), thread_pool, memory_resource);
  server->Start();

  // capture the int and term signal
  struct sigaction sa{};
  sa.sa_handler = handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  sigaction(SIGINT, &sa, nullptr);
  sigaction(SIGTERM, &sa, nullptr);

  // block to wait the exit
  interrupt_sleeper.wait();

  ::bugu::BuguPackerServer::Get()->Stop();
  ::bugu::XThreadPool::Get()->Stop();

  return 0;
}

```

`app/packer/service/src/packer_task.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#include "packer_task.h"

void bugu::PackerTask::Main() {

}

```

`app/packer/service/src/packer_task.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef BUGU_PACKER_SERVICE_SRC_PACKER_TASK_H_
#define BUGU_PACKER_SERVICE_SRC_PACKER_TASK_H_

#include "thread_pool/x_task.h"

#include <fstream>
#include <memory>
#include <memory_resource>
#include <string>
#include <utility>

namespace bugu {

class Data;

class PackerTask : public XTask<::std::shared_ptr<Data>> {
 private:
  ::std::shared_ptr<Data> data_;
  ::std::shared_ptr<::std::pmr::memory_resource> memory_resource_;  ///< 内存池

 public:
  explicit PackerTask(::std::shared_ptr<Data> _data,
                        ::std::shared_ptr<::std::pmr::memory_resource> _memory_resource)
      : data_(std::move(_data)), memory_resource_(std::move(_memory_resource)) {};
  ~PackerTask() override = default;

 private:
  /**
   * 线程入口函数
   */
  void Main() final;
};

} // namespace bugu

#endif //BUGU_PACKER_SERVICE_SRC_PACKER_TASK_H_

```

`app/packer/service/src/thread/x_thread.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#include "x_thread.h"

/**
 * @brief 线程开始函数
 * @details 该函数是多线程的开始函数，会将 Main 函数放入一个线程中运行
 */
void bugu::XThread::Start() {
  if (!this->IsRunning()) {
    this->SetIsRunning(true);
    this->thread_ = ::std::thread(&XThread::Main, this);
  }
}

/**
 * @brief 等待线程完成
 */
void bugu::XThread::Wait() {
  if (this->thread_.joinable()) {
    this->thread_.join();
  }
}

/**
 * @brief 停止线程
 */
void bugu::XThread::Stop() {
  if (this->IsRunning()) {
    this->SetIsRunning(false);
  }
  Wait();
}

void bugu::XThread::StopWith(::std::function<void()> &_do) {
  _do();
  Stop();
}

/**
 * @brief 休眠该线程若干毫秒
 * @details 接收一个 ::std::chrono::milliseconds 的时间戳，调用 ::std::this_thread::sleep_for() 休眠该线程指定时间
 * @param _time ::std::chrono::milliseconds 时间戳
 */
void bugu::XThread::ThreadSleep(::std::chrono::milliseconds _time) {
  ::std::this_thread::sleep_for(_time);
}

/**
 * @brief 获取 isRunning_ 状态
 * @return bool 返回值为 true，说明线程当前处于运行状态
 */
bool bugu::XThread::IsRunning() const {
  ::std::shared_lock<::std::shared_mutex> lock(is_running_mutex_);
  return is_running_;
}

/**
 * @brief 设置线程运行状态
 * @param is_running 运行状态
 */
void bugu::XThread::SetIsRunning(bool is_running) {
  ::std::unique_lock<::std::shared_mutex> lock(is_running_mutex_);
  is_running_ = is_running;
}


```

`app/packer/service/src/thread/x_thread.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/5/17.
//

#ifndef SERVICE_SRC_THREAD_X_THREAD_H_
#define SERVICE_SRC_THREAD_X_THREAD_H_

#include <mutex>
#include <thread>
#include <shared_mutex>
#include <functional>

namespace bugu {
/**
 * @brief 线程基类
 * @details Start() 启动服务，Stop() 关闭服务
 */
class XThread {
 private:
  ::std::thread thread_;  ///< 线程句柄
  bool is_running_ = false;  ///< 当前线程运行状态
  mutable ::std::shared_mutex is_running_mutex_;  ///< 线程运行状态互斥量

 public:
  virtual void Start();
  virtual void Wait();
  virtual void Stop();
  virtual void StopWith(::std::function<void()> &_do);
  virtual void ThreadSleep(::std::chrono::milliseconds _time);

  bool IsRunning() const;

 private:
  void SetIsRunning(bool is_running);

  /**
   * @brief 该纯虚函数必须在子类中实现，用于线程函数的主函数
   */
  virtual void Main() = 0;
};

} // namespace bugu

#endif //SERVICE_SRC_THREAD_X_THREAD_H_

```

`app/packer/service/src/thread_pool/x_task.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef BUGU_PACKER_SERVICE_SRC_THREAD_POOL_X_TASK_H_
#define BUGU_PACKER_SERVICE_SRC_THREAD_POOL_X_TASK_H_

#include <functional>
#include <future>

namespace bugu {
/**
 * @brief 线程池任务基类
 */
class XTaskBase {
 public:
  ::std::function<bool()> is_running = nullptr; ///< 线程池运行状态函数指针

 public:
  virtual ~XTaskBase() = default;
  virtual void Main() = 0;
};

/**
 * @brief 线程池任务模版类，ret_type 设定值类型
 * @tparam ret_type 值类型，不允许为 ::std::thread
 */
template<class ret_type,
    class = typename ::std::enable_if
        <!::std::is_same<ret_type, ::std::thread>::value>::type
>
class XTask : public XTaskBase {
 private:
  ::std::promise<ret_type> p_; ///< 接收返回值

 public:
  /**
   * @brief 设置 future 的值
   * @param ret_type int value
   */
  void set_return(ret_type &&_value) {
    p_.set_value(::std::forward<ret_type>(_value));
  }

  void set_return(const ret_type &_value) {
    p_.set_value(_value);
  }

  /**
   * @brief 阻塞等待 set_value
   * @return decltype(auto)
   */
  decltype(auto) get_return() {
    return p_.get_future().get();
  }
};
} // namespace bugu

#endif //BUGU_PACKER_SERVICE_SRC_THREAD_POOL_X_TASK_H_

```

`app/packer/service/src/thread_pool/x_thread_pool.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#include "bugu_packer/bugu_packer.h"
#include "x_thread_pool.h"
#include "x_task.h"

#include <iostream>
#include <sstream>
#include <thread>

bugu::XThreadPool::~XThreadPool() {
  // 检查是否停止
  if (is_running_) {
    Stop();
  }
}

/**
 * @brief 初始化所有线程，并启动线程
 * @param _thread_nums 线程数量
 */
::std::size_t bugu::XThreadPool::Init(::std::size_t _thread_nums) {
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  thread_nums_ = _thread_nums;

  BUGU_ASSERT(thread_nums_ > 0 && "thread_nums_ <= 0");
  if (thread_nums_ <= 0) {
    throw ::std::runtime_error("thread_nums_ <= 0");
  }

  BUGU_ASSERT(threads_.empty() && "threads should be empty");
  if (!threads_.empty()) {
    throw ::std::runtime_error("!threads_.empty()");
  }

  // 创建线程对象
  for (::std::size_t i = 0; i < thread_nums_; ++i) {
    threads_.push_back(::std::make_unique<::std::thread>(&bugu::XThreadPool::Run, this));
  }

  // 设置线程池运行状态
  is_running_ = true;

  return thread_nums_;
}

/**
 * @brief 线程池退出
 */
void bugu::XThreadPool::Stop() {
  // 设置退出状态
  is_running_ = false;

  // 通知全部线程
  cv_.notify_all();

  // 等待线程结束任务退出
  for (auto &th: threads_) {
    th->join();
  }

  // 独占锁
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  // 清理线程池中的线程对象
  threads_.clear();
}

/**
 * @brief 线程池线程的入口函数
 */
void bugu::XThreadPool::Run() {
#ifdef BUGU_DEBUG
  ::std::stringstream str_info;
  str_info << "Run: " << ::std::this_thread::get_id() << ::std::endl;
  ::std::cout << str_info.str();
#endif

  while (is_running_) {
    // 获取任务
    auto task = GetTask();
    // 获取到空指针, continue之后然后继续获取或退出线程
    if (nullptr == task) {
      continue;
    }

    ++task_run_count_;  // 设置运行中的任务个数
    try {
      // 执行任务
      task->Main();
    } catch (::std::exception &e) {
      ::std::stringstream str_e;
      str_e << "Failure in thread " << ::std::this_thread::get_id() << ", Exception: " << e.what() << ::std::endl;
      ::std::cerr << str_e.str();
    } catch (...) {
      ::std::stringstream str_e;
      str_e << "Unknown failure in thread " << ::std::this_thread::get_id() << ::std::endl;
      ::std::cerr << str_e.str();
    }
    --task_run_count_;
#ifdef BUGU_DEBUG
    ::std::cout << "run: " << task_run_count_ << ::std::endl;
#endif
  }
}

/**
 * @brief 插入任务
 * @param _x_task 任务指针
 */
void bugu::XThreadPool::AddTask(::std::shared_ptr<XTaskBase> &&_x_task) {
  // 将任务插入到队列
  {
    // 独占锁
    ::std::unique_lock<::std::shared_mutex> lock(mutex_);
    // 将线程池运行状态函数的函数指针传入任务中
    _x_task->is_running = [this] {
      return is_running();
    };
    x_tasks_.push(_x_task);
  }

  // 通知一个线程取任务
  cv_.notify_one();
}

/**
 * @brief 获取任务指针
 * @return XTaskBase* 任务指针
 */
::std::shared_ptr<bugu::XTaskBase> bugu::XThreadPool::GetTask() {
  // 独占锁，防止抢占
  ::std::unique_lock<::std::shared_mutex> lock(mutex_);

  // 当任务队列为空就阻塞
  if (x_tasks_.empty()) {
    cv_.wait(lock);
  }

  // 退出
  if (!is_running_) {
    return nullptr;
  }

  // 防止多次通知
  if (x_tasks_.empty()) {
    return nullptr;
  }

  // 取出队头任务
  auto task = x_tasks_.front();
  x_tasks_.pop();
  return task;
}

/**
 * 获取线程池运行状态
 * @return bool 线程池运行状态
 */
bool bugu::XThreadPool::is_running() const {
  return is_running_;
}

/**
 * 获取线程池当前执行中的任务数量
 * @return int 任务数量
 */
int bugu::XThreadPool::task_run_count() {
  return task_run_count_;
}


```

`app/packer/service/src/thread_pool/x_thread_pool.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_
#define SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <queue>
#include <shared_mutex>
#include <thread>
#include <vector>

namespace bugu {
class XTaskBase;

/**
 * @brief 线程池
 */
class XThreadPool {
 private:
  ::std::size_t thread_nums_ = 0; ///< 线程数量
  ::std::vector<::std::unique_ptr<::std::thread>> threads_;  ///< 线程池线程
  ::std::queue<::std::shared_ptr<XTaskBase>> x_tasks_;   ///< 任务队列
  ::std::atomic<bool> is_running_ = false;      ///< 线程池运行状态
  ::std::atomic<int> task_run_count_ = 0; ///< 正在运行的任务数量，原子变量，线程安全

  mutable ::std::shared_mutex mutex_;
  ::std::condition_variable_any cv_;

 public:
  ~XThreadPool();

  // 禁止生成拷移动构造函数, 拷贝构造函数
  XThreadPool(XThreadPool &&_pool) = delete;
  XThreadPool(const XThreadPool &_pool) = delete;
  XThreadPool &operator=(const XThreadPool &_pool) = delete;

  /**
   * @brief 单件模式
   * @return XThreadPool*
   */
  static XThreadPool *Get() {
    static XThreadPool p;
    return &p;
  }

 private:
  XThreadPool() = default;

 public:
  /**
   * @brief 初始化所有线程，并启动线程
   */
  ::std::size_t Init(::std::size_t _thread_nums);

  /**
   * @brief 线程池退出
   */
  void Stop();

  /**
   * @brief 插入任务
   * @param _x_task 任务指针
   */
  void AddTask(::std::shared_ptr<XTaskBase> &&_x_task);

 private:
  /**
   * @brief 线程池线程的入口函数
   */
  void Run();

  /**
   * @brief 获取任务指针
   * @return XTaskBase* 任务指针
   */
  ::std::shared_ptr<XTaskBase> GetTask();

  // 获取器和设置器
 public:
  /**
   * 获取线程池运行状态
   * @return bool 线程池运行状态
   */
  bool is_running() const;

  /**
   * 获取线程池当前执行中的任务数量
   * @return int 任务数量
   */
  int task_run_count();
};
} // namespace bugu

#endif //SERVICE_SRC_THREAD_POOL_X_THREAD_POOL_H_

```

`app/packer/service/src/utils/credentials.cc`:

```cc
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#include "credentials.h"

#include <fstream>

::std::string bugu::Credentials::GetFileContents(const std::string &_path) {
  ::std::ifstream file_stream(_path);
  if (!file_stream.good()) {
    ::std::cerr << "Open Cert File Failed" << ::std::endl;
    exit(-1);
  }
  ::std::string contents;
  contents.assign((::std::istreambuf_iterator<char>(file_stream)), ::std::istreambuf_iterator<char>());
  file_stream.close();
  return contents;
}

::std::shared_ptr<::grpc::ServerCredentials> bugu::Credentials::GetServerCredentials(const ::std::string &_root_cert_dir,
                                                                                     const ::std::string &_server_key_dir,
                                                                                     const ::std::string &_server_cert_dir) {
  auto root_cert = GetFileContents(_root_cert_dir);
  auto key_str = GetFileContents(_server_key_dir);
  auto cert_str = GetFileContents(_server_cert_dir);
  auto x509KeyPair = ::grpc::SslServerCredentialsOptions::PemKeyCertPair{key_str, cert_str};

  ::grpc::SslServerCredentialsOptions cred_option;
  cred_option.pem_root_certs = root_cert;
  cred_option.pem_key_cert_pairs.push_back(x509KeyPair);

  return ::grpc::SslServerCredentials(cred_option);
}

::std::shared_ptr<::grpc::ChannelCredentials> bugu::Credentials::GetClientCredentials(const ::std::string &_root_cert_dir,
                                                                                      const ::std::string &_client_key_dir,
                                                                                      const ::std::string &_client_cert_dir) {
  auto root_cert = GetFileContents(_root_cert_dir);
  auto key_str = GetFileContents(_client_key_dir);
  auto cert_str = GetFileContents(_client_cert_dir);

  ::grpc::SslCredentialsOptions cred_option;
  cred_option.pem_root_certs = root_cert;
  cred_option.pem_private_key = key_str;
  cred_option.pem_cert_chain = cert_str;

  return ::grpc::SslCredentials(cred_option);
}

```

`app/packer/service/src/utils/credentials.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef BUGU_PACKER_SERVICE_SRC_UTILS_CREDENTIALS_H_
#define BUGU_PACKER_SERVICE_SRC_UTILS_CREDENTIALS_H_

#include <grpc++/grpc++.h>

#include <string>
#include <memory>

namespace bugu {

class Credentials {
 public:
  static ::std::string GetFileContents(const ::std::string &_path);

  static ::std::shared_ptr<::grpc::ServerCredentials> GetServerCredentials(const ::std::string &_root_cert_dir = "/cert/ca.crt",
                                                                           const ::std::string &_server_key_dir = "/cert/server.key",
                                                                           const ::std::string &_server_cert_dir = "/cert/server.pem");
  static ::std::shared_ptr<::grpc::ChannelCredentials> GetClientCredentials(const ::std::string &_root_cert_dir = "/cert/ca.crt",
                                                                            const ::std::string &_client_key_dir = "/cert/client.key",
                                                                            const ::std::string &_client_cert_dir = "/cert/client.pem");
};

} // namespace bugu

#endif //BUGU_PACKER_SERVICE_SRC_UTILS_CREDENTIALS_H_

```

`app/packer/service/src/utils/interrupt_sleeper.h`:

```h
// MIT License
//
// Copyright (c) 2022. HominSu
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// Created by Homin Su on 2022/6/16.
//

#ifndef BUGU_PACKER_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_
#define BUGU_PACKER_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_

#include <atomic>
#include <chrono>
#include <memory>
#include <mutex>

namespace bugu {

class InterruptSleeper {
 private:
  ::std::condition_variable cv_;
  ::std::mutex mutex_;
  ::std::atomic<bool> terminate_ = false;

 public:
  void wait() {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    cv_.wait(lock, [&] { return terminate_.load(); });
  }

  template<typename R, typename P>
  bool wait_for(::std::chrono::duration<R, P> const &_time) {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    return !cv_.wait_for(lock, _time, [&] { return terminate_.load(); });
  }

  void interrupt() {
    ::std::unique_lock<::std::mutex> lock(mutex_);
    terminate_.store(true);
    cv_.notify_all();
  }
};

} // namespace bugu

#endif //BUGU_PACKER_SERVICE_SRC_UTILS_INTERRUPT_SLEEPER_H_

```

`app_makefile`:

```
AUTHOR_NAME=hominsu
AUTHOR_EMAIL=hominsu@foxmail.com

GOPATH:=$(shell go env GOPATH)
VERSION=$(shell git describe --tags --always)

APP_RELATIVE_PATH=$(shell a=`basename $$PWD` && cd .. && b=`basename $$PWD` && echo $$b/$$a)
INTERNAL_PROTO_FILES=$(shell find internal -name *.proto)
API_PROTO_FILES=$(shell cd ../../../api/$(APP_RELATIVE_PATH) && find . -name *.proto)
CPP_API_PROTO_FILES=$(shell cd ../../../api/$(APP_RELATIVE_PATH) && find . -name *.proto | grep -v error)

REPO=hominsu

APP_NAME=$(shell echo $(APP_RELATIVE_PATH) | sed -En "s/\//-/p")
DOCKER_IMAGE=$(REPO)/$(shell echo $(APP_NAME) |awk -F '@' '{print "bugu-" $$0 ":$(VERSION)"}')

.PHONY: grpc-go
# generate grpc go code
grpc-go:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--go_out=paths=source_relative:. \
		--go-grpc_out=paths=source_relative:. \
		$(API_PROTO_FILES)

.PHONY: grpc-cpp
# generate grpc cpp code
grpc-cpp:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=./v1 \
			--proto_path=../../../third_party \
			--cpp_out=./v1/cpp \
			--grpc_out=./v1/cpp \
			--plugin=protoc-gen-grpc=`which grpc_cpp_plugin` \
			$(CPP_API_PROTO_FILES)

.PHONY: grpc
# generate grpc code
grpc: grpc-go grpc-cpp

.PHONY: http
# generate http code
http:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
    	--proto_path=../../../third_party \
    	--proto_path=../../../api \
        --go_out=paths=source_relative:. \
        --go-http_out=paths=source_relative:. \
        $(API_PROTO_FILES)

.PHONY: errors
# generate errors code
errors:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--go_out=paths=source_relative:. \
		--go-errors_out=paths=source_relative:. \
		$(API_PROTO_FILES)

.PHONY: validate
# generate validate proto
validate:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--go_out=paths=source_relative:. \
		--validate_out=paths=source_relative,lang=go:. \
		$(API_PROTO_FILES)

.PHONY: swagger
# generate swagger
swagger:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--openapiv2_out . \
		--openapiv2_opt logtostderr=true \
		$(API_PROTO_FILES)

.PHONY: proto
# generate internal proto struct
proto:
	protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--go_out=paths=source_relative:. \
		$(INTERNAL_PROTO_FILES)

.PHONY: generate
# generate client code
generate:
	go generate ./...

.PHONY: build
# build
build:
	mkdir -p bin/ && go build -ldflags "-X main.Version=$(VERSION)" -o ./bin/ ./...

.PHONY: test
# test
test:
	go test -v ./... -cover

.PHONY: run
run:
	cd cmd/server/ && go run .

.PHONY: docker
docker:
	cd ../../.. && \
	docker build \
		--build-arg AUTHOR_NAME=$(AUTHOR_NAME) \
		--build-arg AUTHOR_EMAIL=$(AUTHOR_EMAIL) \
		--build-arg VERSION=$(VERSION) \
		--build-arg APP_RELATIVE_PATH=$(APP_RELATIVE_PATH) \
		--file app/$(APP_RELATIVE_PATH)/Dockerfile \
		--tag $(DOCKER_IMAGE) .

.PHONY: buildx
buildx:
	cd ../../.. && \
	docker buildx build \
		--build-arg AUTHOR_NAME=$(AUTHOR_NAME) \
		--build-arg AUTHOR_EMAIL=$(AUTHOR_EMAIL) \
		--build-arg VERSION=$(VERSION) \
		--build-arg APP_RELATIVE_PATH=$(APP_RELATIVE_PATH) \
		--file app/$(APP_RELATIVE_PATH)/Dockerfile \
		--platform=linux/arm64,linux/amd64 \
		--push \
		--tag $(DOCKER_IMAGE) .

.PHONY: wire
# generate wire
wire:
	cd cmd/server && wire

.PHONY: api
# generate api
api: grpc http validate swagger errors

.PHONY: conf
# generate conf
conf: proto

.PHONY: all
# generate all
all: grpc http proto generate build test

# show help
help:
	@echo ''
	@echo 'Usage:'
	@echo ' make [target]'
	@echo ''
	@echo 'Targets:'
	@awk '/^[a-zA-Z\-\_0-9]+:/ { \
	helpMessage = match(lastLine, /^# (.*)/); \
		if (helpMessage) { \
			helpCommand = substr($$1, 0, index($$1, ":")-1); \
			helpMessage = substr(lastLine, RSTART + 2, RLENGTH); \
			printf "\033[36m%-22s\033[0m %s\n", helpCommand,helpMessage; \
		} \
	} \
	{ lastLine = $$0 }' $(MAKEFILE_LIST)

.DEFAULT_GOAL := help
```

`cpp_makefile`:

```
AUTHOR_NAME=hominsu
AUTHOR_EMAIL=hominsu@foxmail.com

GOPATH:=$(shell go env GOPATH)
VERSION=$(shell git describe --tags --always)

APP_RELATIVE_PATH=$(shell a=`basename $$PWD` && cd .. && b=`basename $$PWD` && echo $$b/$$a)
INTERNAL_PROTO_FILES=$(shell cd src/conf && find . -name *.proto)
API_PROTO_FILES=$(shell cd ../../../api/$(APP_RELATIVE_PATH) && find . -name *.proto)
CPP_API_PROTO_FILES=$(shell cd ../../../api/$(APP_RELATIVE_PATH) && find . -name *.proto | grep -v error)

REPO=hominsu

APP_NAME=$(shell echo $(APP_RELATIVE_PATH) | sed -En "s/\//-/p")
DOCKER_IMAGE=$(REPO)/$(shell echo $(APP_NAME) |awk -F '@' '{print "bugu-" $$0 ":$(VERSION)"}')

.PHONY: grpc-go
# generate grpc go code
grpc-go:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--go_out=paths=source_relative:. \
		--go-grpc_out=paths=source_relative:. \
		$(API_PROTO_FILES)

.PHONY: grpc-cpp
# generate grpc cpp code
grpc-cpp:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=./v1 \
			--proto_path=../../../third_party \
			--cpp_out=./v1/cpp \
			--grpc_out=./v1/cpp \
			--plugin=protoc-gen-grpc=`which grpc_cpp_plugin` \
			$(CPP_API_PROTO_FILES)

.PHONY: grpc
# generate grpc code
grpc: grpc-go grpc-cpp

.PHONY: http
# generate http code
http:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
    	--proto_path=../../../third_party \
    	--proto_path=../../../api \
        --go_out=paths=source_relative:. \
        --go-http_out=paths=source_relative:. \
        $(API_PROTO_FILES)

.PHONY: errors
# generate errors code
errors:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--go_out=paths=source_relative:. \
		--go-errors_out=paths=source_relative:. \
		$(API_PROTO_FILES)

.PHONY: validate
# generate validate proto
validate:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--go_out=paths=source_relative:. \
		--validate_out=paths=source_relative,lang=go:. \
		$(API_PROTO_FILES)

.PHONY: swagger
# generate swagger
swagger:
	cd ../../../api/$(APP_RELATIVE_PATH) && protoc --proto_path=. \
		--proto_path=../../../third_party \
		--proto_path=../../../api \
		--openapiv2_out . \
		--openapiv2_opt logtostderr=true \
		$(API_PROTO_FILES)

.PHONY: proto
# generate internal proto struct
proto:
	cd src/conf && protoc --proto_path=. \
		--cpp_out=. \
		$(INTERNAL_PROTO_FILES)

.PHONY: generate
# generate client code
generate:
	go generate ./...

.PHONY: build
# build
build:
	mkdir -p bin/ && \
	cmake -H. -Bbuild -DCMAKE_BUILD_TYPE=Release && \
	cmake --build ./build --parallel && \
	mv build/src/bugu.obfusion.service bin/server &&\
	rm -rf build

.PHONY: docker
docker:
	cd ../../.. && \
	docker build \
		--build-arg AUTHOR_NAME=$(AUTHOR_NAME) \
		--build-arg AUTHOR_EMAIL=$(AUTHOR_EMAIL) \
		--build-arg VERSION=$(VERSION) \
		--build-arg APP_RELATIVE_PATH=$(APP_RELATIVE_PATH) \
		--file app/$(APP_RELATIVE_PATH)/Dockerfile \
		--tag $(DOCKER_IMAGE) .

.PHONY: buildx
buildx:
	cd ../../.. && \
	docker buildx build \
		--build-arg AUTHOR_NAME=$(AUTHOR_NAME) \
		--build-arg AUTHOR_EMAIL=$(AUTHOR_EMAIL) \
		--build-arg VERSION=$(VERSION) \
		--build-arg APP_RELATIVE_PATH=$(APP_RELATIVE_PATH) \
		--file app/$(APP_RELATIVE_PATH)/Dockerfile \
		--platform=linux/arm64,linux/amd64 \
		--push \
		--tag $(DOCKER_IMAGE) .

.PHONY: wire
# generate wire
wire:

.PHONY: api
# generate api
api: grpc http validate swagger errors

.PHONY: conf
# generate conf
conf: proto

.PHONY: all
# generate all
all: grpc http proto generate build

# show help
help:
	@echo ''
	@echo 'Usage:'
	@echo ' make [target]'
	@echo ''
	@echo 'Targets:'
	@awk '/^[a-zA-Z\-\_0-9]+:/ { \
	helpMessage = match(lastLine, /^# (.*)/); \
		if (helpMessage) { \
			helpCommand = substr($$1, 0, index($$1, ":")-1); \
			helpMessage = substr(lastLine, RSTART + 2, RLENGTH); \
			printf "\033[36m%-22s\033[0m %s\n", helpCommand,helpMessage; \
		} \
	} \
	{ lastLine = $$0 }' $(MAKEFILE_LIST)

.DEFAULT_GOAL := help
```

`deploy/consul/docker-compose.yml`:

```yml
version: '3.4'

services:
  consul-1:
    image: consul:latest
    container_name: consul-1
    command: agent -server -bootstrap-expect=3 -node=consul-1 -bind=0.0.0.0 -client=0.0.0.0 -datacenter=datacenter-1
    restart: unless-stopped
    volumes:
      - "./data/consul-1:/consul/data"
    networks:
      net:
        aliases:
          - consul-1

  consul-2:
    image: consul:latest
    container_name: consul-2
    command: agent -server -retry-join=consul-1 -node=consul-2 -bind=0.0.0.0 -client=0.0.0.0 -datacenter=datacenter-1
    restart: unless-stopped
    depends_on:
      - consul-1
    volumes:
      - "./data/consul-2:/consul/data"
    networks:
      net:
        aliases:
          - consul-2

  consul-3:
    image: consul:latest
    container_name: consul-3
    command: agent -server -retry-join=consul-1 -node=consul-3 -bind=0.0.0.0 -client=0.0.0.0 -datacenter=datacenter-1
    restart: unless-stopped
    depends_on:
      - consul-1
    volumes:
      - "./data/consul-3:/consul/data"
    networks:
      net:
        aliases:
          - consul-3

  consul-4:
    image: consul:latest
    container_name: consul-4
    command: agent -retry-join=consul-1 -node=consul-4 -bind=0.0.0.0 -client=0.0.0.0 -datacenter=datacenter-1 -ui
    restart: unless-stopped
    ports:
      - "8500:8500"
    depends_on:
      - consul-2
      - consul-3
    volumes:
      - "./data/consul-4:/consul/data"
    networks:
      net:
        aliases:
          - consul-4

networks:
  net:
    ipam:
      driver: default
      config:
        - subnet: 10.10.10.0/24

```

`deploy/docker-compose/docker-bake.hcl`:

```hcl
variable "REPO" {
  default = "hominsu"
}

variable "AUTHOR_NAME" {
  default = "hominsu"
}

variable "AUTHOR_EMAIL" {
  default = "hominsu@foxmail.com"
}

variable "VERSION" {
  default = ""
}

group "default" {
  targets = [
    "bugu-bugu-service",
    "bugu-obfusion-service",
  ]
}

target "bugu-bugu-service" {
  context    = "."
  dockerfile = "app/bugu/service/Dockerfile"
  args       = {
    AUTHOR_NAME       = "${AUTHOR_NAME}"
    AUTHOR_EMAIL      = "${AUTHOR_EMAIL}"
    APP_RELATIVE_PATH = "bugu/service"
  }
  tags = [
    "${REPO}/bugu-bugu-service:latest",
    notequal("", VERSION) ? "${REPO}/bugu-bugu-service:${VERSION}" : "",
  ]
  platforms = ["linux/amd64"]
}

target "bugu-obfusion-service" {
  context    = "."
  dockerfile = "app/obfusion/service/Dockerfile"
  args       = {
    AUTHOR_NAME       = "${AUTHOR_NAME}"
    AUTHOR_EMAIL      = "${AUTHOR_EMAIL}"
    APP_RELATIVE_PATH = "obfusion/service"
  }
  tags = [
    "${REPO}/bugu-obfusion-service:latest",
    notequal("", VERSION) ? "${REPO}/bugu-obfusion-service:${VERSION}" : "",
  ]
  platforms = ["linux/amd64"]
}
```

`deploy/docker-compose/docker-compose.yml`:

```yml
version: '3.4'

services:
  bugu-bugu-service:
    image: hominsu/bugu-bugu-service:latest
    container_name: bugu-bugu-service
    restart: always
    depends_on:
      bugu-obfusion-service:
        condition: service_started
    environment:
      TZ: "Asia/Shanghai"
    volumes:
      - type: bind
        source: "../../app/bugu/service/configs"
        target: "/data/conf"
        bind:
          create_host_path: true
      - type: bind
        source: "./data/file"
        target: "/data/file"
        bind:
          create_host_path: true
    ports:
      - mode: ingress
        target: 8000
        published: 8000
        protocol: tcp
    networks:
      net:
        aliases:
          - bugu-bugu-service

  bugu-obfusion-service:
    image: hominsu/bugu-obfusion-service:latest
    container_name: bugu-obfusion-service
    restart: always
    environment:
      TZ: "Asia/Shanghai"
    volumes:
      - type: bind
        source: "../../app/obfusion/service/configs"
        target: "/data/conf"
        bind:
          create_host_path: true
    ports:
      - mode: ingress
        target: 9000
        published: 9000
        protocol: tcp
    networks:
      net:
        aliases:
          - bugu-obfusion-service

  bugu-detect-service:
    image: hominsu/bugu-detect-service:latest
    container_name: bugu-detect-service
    restart: always
    environment:
      TZ: "Asia/Shanghai"
    volumes:
      - type: bind
        source: "../../app/detect/service/configs"
        target: "/data/conf"
        bind:
          create_host_path: true
    ports:
      - mode: ingress
        target: 9000
        published: 9000
        protocol: tcp
    networks:
      net:
        aliases:
          - bugu-detect-service

  bugu-packer-service:
    image: hominsu/bugu-packer-service:latest
    container_name: bugu-packer-service
    restart: always
    environment:
      TZ: "Asia/Shanghai"
    volumes:
      - type: bind
        source: "../../app/packer/service/configs"
        target: "/data/conf"
        bind:
          create_host_path: true
    ports:
      - mode: ingress
        target: 9000
        published: 9000
        protocol: tcp
    networks:
      net:
        aliases:
          - bugu-packer-service

networks:
  net:
    ipam:
      driver: default
      config:
        - subnet: 172.10.10.0/24

```

`docs/README.md`:

```md
<div id="top"></div>

<!-- PROJECT SHIELDS -->
<p align="center">
<a href="https://github.com/hominsu/bugu/graphs/contributors"><img src="https://img.shields.io/github/contributors/hominsu/bugu.svg?style=for-the-badge" alt="Contributors"></a>
<a href="https://github.com/hominsu/bugu/network/members"><img src="https://img.shields.io/github/forks/hominsu/bugu.svg?style=for-the-badge" alt="Forks"></a>
<a href="https://github.com/hominsu/bugu/stargazers"><img src="https://img.shields.io/github/stars/hominsu/bugu.svg?style=for-the-badge" alt="Stargazers"></a>
<a href="https://github.com/hominsu/bugu/issues"><img src="https://img.shields.io/github/issues/hominsu/bugu.svg?style=for-the-badge" alt="Issues"></a>
<a href="https://github.com/hominsu/bugu/blob/master/LICENSE"><img src="https://img.shields.io/github/license/hominsu/bugu.svg?style=for-the-badge" alt="License"></a>
<a href="https://github.com/hominsu/bugu/actions/workflows/docker-publish.yml"><img src="https://img.shields.io/github/workflow/status/hominsu/bugu/Docker%20Deploy?style=for-the-badge" alt="Deploy"></a>
</p>


<!-- PROJECT LOGO -->
<br/>
<div align="center">
<!--   <a href="https://github.com/hominsu/bugu">
    <img src="images/logo.png" alt="Logo" width="80" height="80">
  </a> -->

<h3 align="center">bugu</h3>

  <p align="center">
    Malicious code detection and complication system
    <br/>
    <a href="https://hominsu.github.io/bugu/"><strong>Explore the docs » (you are here)</strong></a>
    <br/>
    <br/>
    <a href="https://github.com/hominsu/bugu">View Demo</a>
    ·
    <a href="https://github.com/hominsu/bugu/issues">Report Bug</a>
    ·
    <a href="https://github.com/hominsu/bugu/issues">Request Feature</a>
  </p>
</div>

## Description

Kill - free system based on artificial intelligence detection

## Details

```mermaid
flowchart LR
	admin("admin service") <-.-> user("user service")
	bugu("bugu service") <-.-> user
	bugu <-.-> detect("detect service")
	bugu <-.-> packer("packer service")
	bugu <-.-> confusion("confusion service")
	
	subgraph DB
	redis[("redis")]
	userdb[("user db")]
	kafka[("kafka")]
	end
	
	subgraph File
	oss[("oss")]
	metadatadb[("file meta db")]
	end
	
	bugu <-.file.-> oss
	admin <-.file.-> oss
	
	bugu <-.file metadata.-> metadatadb
	admin <-.file metadata.-> metadatadb
	
	user <-.user info.-> userdb
	user <-.user cache.-> redis
	
	bugu -.delay task.-> kafka
	detect <-.delay task.- kafka
	packer <-.delay task.- kafka
	confusion <-.delay task.- kafka
	
	subgraph Other Infrastructure
	consul("Consul")
	sls("Aliyun Log Service")
	end
	
```

```

`docs/_coverpage.md`:

```md
# bugu

> Kill - free system based on artificial intelligence detection

- simple、fast
- A variety of no-kill technologies

[GitHub](https://github.com/hominsu/bugu)
[Quick Started](/README)

```

`docs/_navbar.md`:

```md
* Translations
  * [:uk: English](/)
  * [:cn: 中文](/zh-cn/)
```

`docs/_sidebar.md`:

```md
* [Quick Start](README.md "Quick Start")
* [Interface API](https://hominsu.github.io/htp-platform/api.html "Interface API")
```

`docs/api.html`:

```html
<!DOCTYPE html>
<html>
<head>
    <title>E-Code Interface API</title>
    <!-- needed for adaptive design -->
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.font.im/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">

    <!--
    ReDoc doesn't change outer page styles
    -->
    <style>
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
<redoc spec-url='https://raw.githubusercontent.com/hominsu/bugu/main/api/bugu/service/v1/bugu.swagger.json'></redoc>
<script src="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js"></script>
</body>
</html>

```

`docs/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>bugu Document</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="description" content="Description">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css">
</head>
<body>
<div data-app id="main"></div>

<!-- Docsify v4 -->
<script src="//cdn.jsdelivr.net/npm/docsify@4"></script>

<!-- plugins -->
<script src="//cdn.jsdelivr.net/npm/docsify-edit-on-github"></script>       <!-- 在 Github 上编辑 -->
<script src="//cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>  <!-- 支持 mermaid -->
<script src="//cdn.jsdelivr.net/npm/docsify/lib/plugins/emoji.min.js"></script>         <!-- 支持 emoji -->
<script src="//cdn.jsdelivr.net/npm/docsify/lib/plugins/zoom-image.min.js"></script>    <!-- Zoom image -->
<script src="//cdn.jsdelivr.net/npm/docsify@4.12.2/lib/plugins/search.min.js"></script> <!-- 全文搜索 -->
<script src="//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js"></script>  <!-- 复制到剪贴板 -->
<script src="//cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js"></script>    <!-- C++ 代码高亮 -->
<script src="//cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js"></script>   <!-- bash 代码高亮 -->
<script src="//cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js"></script>   <!-- json 代码高亮 -->

<script>
    let num = 0;
    mermaid.initialize({startOnLoad: false});

    window.$docsify = {
        name: 'bugu',
        el: '#main',
        coverpage: ['/', '/zh-cn/'],
        loadNavbar: true,
        loadSidebar: true,
        subMaxLevel: 2,
        auto2top: true,

        search: {
            maxAge: 86400000, // 过期时间，单位毫秒，默认一天
            paths: 'auto',
            placeholder: {
                '/': 'Type to search',
                '/zh-cn/': '搜索',
            },
            noData: {
                '/': 'No Results',
                '/zh-cn/': '找不到结果',
            },
        },

        plugins: [
            EditOnGithubPlugin.create('https://github.com/hominsu/bugu/blob/main/docs/')
        ],
        markdown: {
            renderer: {
                code: function (code, lang) {
                    if (lang === "mermaid") {
                        return (
                            '<div class="mermaid">' + mermaid.render('mermaid-svg-' + num++, code) + "</div>"
                        );
                    }
                    return this.origin.code.apply(this, arguments);
                }
            }
        }
    }
</script>
</body>
</html>

```

`docs/zh-cn/README_zh.md`:

```md
<div id="top"></div>

<!-- PROJECT SHIELDS -->
<p align="center">
<a href="https://github.com/hominsu/bugu/graphs/contributors"><img src="https://img.shields.io/github/contributors/hominsu/bugu.svg?style=for-the-badge" alt="Contributors"></a>
<a href="https://github.com/hominsu/bugu/network/members"><img src="https://img.shields.io/github/forks/hominsu/bugu.svg?style=for-the-badge" alt="Forks"></a>
<a href="https://github.com/hominsu/bugu/stargazers"><img src="https://img.shields.io/github/stars/hominsu/bugu.svg?style=for-the-badge" alt="Stargazers"></a>
<a href="https://github.com/hominsu/bugu/issues"><img src="https://img.shields.io/github/issues/hominsu/bugu.svg?style=for-the-badge" alt="Issues"></a>
<a href="https://github.com/hominsu/bugu/blob/master/LICENSE"><img src="https://img.shields.io/github/license/hominsu/bugu.svg?style=for-the-badge" alt="License"></a>
<a href="https://github.com/hominsu/bugu/actions/workflows/docker-publish.yml"><img src="https://img.shields.io/github/workflow/status/hominsu/bugu/Docker%20Deploy?style=for-the-badge" alt="Deploy"></a>
</p>


<!-- PROJECT LOGO -->
<br/>
<div align="center">
<!--   <a href="https://github.com/hominsu/bugu">
    <img src="images/logo.png" alt="Logo" width="80" height="80">
  </a> -->

<h3 align="center">bugu</h3>

  <p align="center">
    恶意代码检测和复杂化系统
    <br/>
    <a href="https://hominsu.github.io/bugu/"><strong>Explore the docs » (you are here)</strong></a>
    <br/>
    <br/>
    <a href="https://github.com/hominsu/bugu">View Demo</a>
    ·
    <a href="https://github.com/hominsu/bugu/issues">Report Bug</a>
    ·
    <a href="https://github.com/hominsu/bugu/issues">Request Feature</a>
  </p>
</div>

## Description

基于人工智能检测的免杀系统

## Details

```mermaid
flowchart LR
	admin("admin service") <-.-> user("user service")
	bugu("bugu service") <-.-> user
	bugu <-.-> detect("detect service")
	bugu <-.-> packer("packer service")
	bugu <-.-> confusion("confusion service")
	
	subgraph DB
	redis[("redis")]
	userdb[("user db")]
	kafka[("kafka")]
	end
	
	subgraph File
	oss[("oss")]
	metadatadb[("file meta db")]
	end
	
	bugu <-.file.-> oss
	admin <-.file.-> oss
	
	bugu <-.file metadata.-> metadatadb
	admin <-.file metadata.-> metadatadb
	
	user <-.user info.-> userdb
	user <-.user cache.-> redis
	
	bugu -.delay task.-> kafka
	detect <-.delay task.- kafka
	packer <-.delay task.- kafka
	confusion <-.delay task.- kafka
	
	subgraph Other Infrastructure
	consul("Consul")
	sls("Aliyun Log Service")
	end
	
```

```

`docs/zh-cn/_coverpage.md`:

```md
# bugu

> 基于人工智能检测的免杀系统

- 简单、快速
- 多种免杀方法

[GitHub](https://github.com/hominsu/bugu)
[快速开始](/zh-cn/README_zh)

```

`docs/zh-cn/_sidebar.md`:

```md
* [快速开始](/zh-cn/README_zh.md "快速开始")
* [接口 API](https://hominsu.github.io/htp-platform/api.html "接口 API")
```

`go.mod`:

```mod
module github.com/hominsu/bugu

go 1.18

require (
	github.com/envoyproxy/protoc-gen-validate v0.6.7
	github.com/go-kratos/kratos/v2 v2.3.1
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.10.3
	google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd
	google.golang.org/grpc v1.47.0
	google.golang.org/protobuf v1.28.0
)

require (
	github.com/go-playground/form/v4 v4.2.0 // indirect
	github.com/golang/protobuf v1.5.2 // indirect
	github.com/gorilla/mux v1.8.0 // indirect
	github.com/kr/pretty v0.3.0 // indirect
	github.com/rogpeppe/go-internal v1.8.0 // indirect
	golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd // indirect
	golang.org/x/sys v0.0.0-20220412211240-33da011f77ad // indirect
	golang.org/x/text v0.3.7 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

```

`go.sum`:

```sum
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/StackExchange/wmi v1.2.1/go.mod h1:rcmrprowKIVzvc+NUiLncP2uuArMWLCbu9SBzvHz7e8=
github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=
github.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20211001041855-01bcc9b48dfe/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/go-control-plane v0.10.2-0.20220325020618-49ff273808a1/go.mod h1:KJwIaB5Mv44NWtYuAOFCVOjcI94vtpEz2JU/D2v6IjE=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/envoyproxy/protoc-gen-validate v0.6.7 h1:qcZcULcd/abmQg6dwigimCNEyi4gg31M/xaciQlDml8=
github.com/envoyproxy/protoc-gen-validate v0.6.7/go.mod h1:dyJXwwfPK2VSqiB9Klm1J6romD608Ba7Hij42vrOBCo=
github.com/fsnotify/fsnotify v1.5.4/go.mod h1:OVB6XrOHzAwXMpEM7uPOzcehqUV2UqJxmVXmkdnm1bU=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-kratos/aegis v0.1.2/go.mod h1:jYeSQ3Gesba478zEnujOiG5QdsyF3Xk/8owFUeKcHxw=
github.com/go-kratos/kratos/v2 v2.3.1 h1:Qfx3JSEIrfZl0f8mXvbeGv3tRIZ2L/ArhcKwxAr3uMo=
github.com/go-kratos/kratos/v2 v2.3.1/go.mod h1:5acyLj4EgY428AJnZl2EwCrMV1OVlttQFBum+SghMiA=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.2.3/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-ole/go-ole v1.2.5/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
github.com/go-playground/assert/v2 v2.0.1 h1:MsBgLAaY856+nPRTKrp3/OZK38U/wa0CcBYNjji3q3A=
github.com/go-playground/assert/v2 v2.0.1/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/form/v4 v4.2.0 h1:N1wh+Goz61e6w66vo8vJkQt+uwZSoLz50kZPJWR8eic=
github.com/go-playground/form/v4 v4.2.0/go.mod h1:q1a2BY+AQUUzhl6xA/6hBetay6dEIhMHjgvJiGo6K7U=
github.com/golang-jwt/jwt/v4 v4.4.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
github.com/golang/protobuf v1.5.2 h1:ROPKBNFfQgOUMifHyP+KYbvpjbdoFNs+aK7DXlji0Tw=
github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.7/go.mod h1:n+brtR0CgQNWTVd5ZUFpTBC8YFBDLK/h/bpaJ8/DtOE=
github.com/google/go-cmp v0.5.8 h1:e6P7q2lk1O+qJJb4BtCQXlK8vWEO8V1ZeuEdJNOqZyg=
github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/mux v1.8.0 h1:i40aqfkR1h2SlN9hojwV5ZA91wcXFOvkdNIeFDP5koI=
github.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=
github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.10.3 h1:BGNSrTRW4rwfhJiFwvwF4XQ0Y72Jj9YEgxVrtovbD5o=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.10.3/go.mod h1:VHn7KgNsRriXa4mcgtkpR00OXyQY6g67JWMvn+R27A4=
github.com/iancoleman/strcase v0.2.0/go.mod h1:iwCmte+B7n89clKwxIoIXy/HfoL7AsD47ZCWhYzw7ho=
github.com/imdario/mergo v0.3.12/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=
github.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=
github.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/lyft/protoc-gen-star v0.6.0/go.mod h1:TGAoBVkt8w7MPG72TrKIu85MIdXwDuzJYeZuUPFPNwA=
github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=
github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/sftp v1.10.1/go.mod h1:lYOWFsE0bwd1+KfKJaKeuokY15vzFx25BLbzYYoAxZI=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=
github.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=
github.com/rogpeppe/go-internal v1.8.0 h1:FCbCCtXNOY3UtUuHUYaghJg4y7Fd14rXifAYUAtL9R8=
github.com/rogpeppe/go-internal v1.8.0/go.mod h1:WmiCO8CzOY8rg0OYDC4/i/2WRWAB6poM+XZ2dLUbcbE=
github.com/shirou/gopsutil/v3 v3.21.8/go.mod h1:YWp/H8Qs5fVmf17v7JNZzA0mPJ+mS2e9JdiUF9LlKzQ=
github.com/spf13/afero v1.3.3/go.mod h1:5KUK8ByomD5Ti5Artl0RtHeI5pTF7MIDuXL3yY520V4=
github.com/spf13/afero v1.6.0/go.mod h1:Ai8FlHk4v/PARR026UzYexafAt9roJ7LcLMAmO6Z93I=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/tklauser/go-sysconf v0.3.9/go.mod h1:11DU/5sG7UexIrp/O6g35hrWzu0JxlwQ3LSFUzyeuhs=
github.com/tklauser/numcpus v0.3.0/go.mod h1:yFGUr7TUHQRAhyqBcEg0Ge34zDBAsIvJJcyE6boqnA8=
github.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=
go.opentelemetry.io/otel v1.7.0/go.mod h1:5BdUoMIz5WEs0vt0CUEMtSSaTSHBBVwrhnz7+nrD5xk=
go.opentelemetry.io/otel/sdk v1.7.0/go.mod h1:uTEOTwaqIVuTGiJN7ii13Ibp75wJmYUDe374q6cZwUU=
go.opentelemetry.io/otel/trace v1.7.0/go.mod h1:fzLSB9nqR2eXzxPXb2JW9IKE+ScyXA48yyE4TNvoHqU=
go.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20210508222113-6edffad5e616/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.5.0/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=
golang.org/x/net v0.0.0-20210813160813-60bc85c4be6d/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd h1:O7DYs+zxREGLKzKoMQrtrEacpb0ZVXA5rIwylE2Xchk=
golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220513210516-0976fa681c29/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423185535-09eb48e85fd7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210816074244-15123e1e1f71/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210816183151-1e6c022a8912/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220412211240-33da011f77ad h1:ntjMns5wyP/fN65tdBD4g8J5w8n015+iIIs9rtjXkY0=
golang.org/x/sys v0.0.0-20220412211240-33da011f77ad/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd h1:e0TwkXOdbnH/1x5rc5MZ/VYyiZ4v+RdVfrGMqEwT68I=
google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTpR3n0=
google.golang.org/grpc v1.36.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/grpc v1.46.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.46.2/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.47.0 h1:9n77onPX5F3qfFCqjy9dhn8PbNQsIKeVU04J9G7umt8=
google.golang.org/grpc v1.47.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.28.0 h1:w43yiav+6bVFTBQFZX0r7ipe9JQ1QsbMgHwbBziscLw=
google.golang.org/protobuf v1.28.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=

```

`pkg/file.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package pkg

import (
	"crypto/md5"
	"crypto/sha1"
	"encoding/hex"
	"hash"
	"io"
	"os"
	"path/filepath"
)

type Sha1Stream struct {
	_sha1 hash.Hash
}

func (ss *Sha1Stream) UpdateByte(data []byte) (size int64, err error) {
	if ss._sha1 == nil {
		ss._sha1 = sha1.New()
	}

	rSize, err := ss._sha1.Write(data)
	if err != nil {
		return 0, err
	}

	return int64(rSize), nil
}

func (ss *Sha1Stream) UpdateIO(ioReader io.Reader) (size int64, err error) {
	if ss._sha1 == nil {
		ss._sha1 = sha1.New()
	}

	rSize, err := io.Copy(ss._sha1, ioReader)
	if err != nil {
		return 0, err
	}

	return rSize, nil
}

func (ss *Sha1Stream) Reset() {
	ss._sha1.Reset()
}

func (ss *Sha1Stream) Sum() string {
	return hex.EncodeToString(ss._sha1.Sum([]byte("")))
}

func Sha1(data []byte) (string, int64, error) {
	_sha1 := sha1.New()
	size, err := _sha1.Write(data)
	if err != nil {
		return "", 0, err
	}
	return hex.EncodeToString(_sha1.Sum([]byte(""))), int64(size), nil
}

func IOSha1(ioReader io.Reader) (string, int64, error) {
	_sha1 := sha1.New()
	size, err := io.Copy(_sha1, ioReader)
	if err != nil {
		return "", 0, err
	}
	return hex.EncodeToString(_sha1.Sum([]byte(""))), size, nil
}

func MD5(data []byte) (string, int64, error) {
	_md5 := md5.New()
	size, err := _md5.Write(data)
	if err != nil {
		return "", 0, err
	}
	return hex.EncodeToString(_md5.Sum([]byte(""))), int64(size), nil
}

func IOMd5(file io.Reader) (string, int64, error) {
	_md5 := md5.New()
	size, err := io.Copy(_md5, file)
	if err != nil {
		return "", 0, err
	}
	return hex.EncodeToString(_md5.Sum(nil)), size, nil
}

func PathExists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}

func GetFileSize(filename string) (int64, error) {
	var result int64
	err := filepath.Walk(filename, func(path string, f os.FileInfo, err error) error {
		result = f.Size()
		return nil
	})
	if err != nil {
		return 0, err
	}
	return result, nil
}

```

`pkg/go.mod`:

```mod
module github.com/hominsu/bugu/pkg

go 1.18

require (
	github.com/go-kratos/kratos/v2 v2.3.1
	golang.org/x/crypto v0.0.0-20220525230936-793ad666bf5e
)

require (
	github.com/golang/protobuf v1.5.2 // indirect
	google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd // indirect
	google.golang.org/grpc v1.46.2 // indirect
	google.golang.org/protobuf v1.28.0 // indirect
)

```

`pkg/go.sum`:

```sum
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/StackExchange/wmi v1.2.1/go.mod h1:rcmrprowKIVzvc+NUiLncP2uuArMWLCbu9SBzvHz7e8=
github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cncf/udpa/go v0.0.0-20210930031921-04548b0d99d4/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=
github.com/cncf/xds/go v0.0.0-20210922020428-25de7278fc84/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20211001041855-01bcc9b48dfe/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20211011173535-cb28da3451f1/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/go-control-plane v0.10.2-0.20220325020618-49ff273808a1/go.mod h1:KJwIaB5Mv44NWtYuAOFCVOjcI94vtpEz2JU/D2v6IjE=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/fsnotify/fsnotify v1.5.4/go.mod h1:OVB6XrOHzAwXMpEM7uPOzcehqUV2UqJxmVXmkdnm1bU=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-kratos/aegis v0.1.2/go.mod h1:jYeSQ3Gesba478zEnujOiG5QdsyF3Xk/8owFUeKcHxw=
github.com/go-kratos/kratos/v2 v2.3.1 h1:Qfx3JSEIrfZl0f8mXvbeGv3tRIZ2L/ArhcKwxAr3uMo=
github.com/go-kratos/kratos/v2 v2.3.1/go.mod h1:5acyLj4EgY428AJnZl2EwCrMV1OVlttQFBum+SghMiA=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.2.3/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-ole/go-ole v1.2.5/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
github.com/go-playground/assert/v2 v2.0.1/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/form/v4 v4.2.0/go.mod h1:q1a2BY+AQUUzhl6xA/6hBetay6dEIhMHjgvJiGo6K7U=
github.com/golang-jwt/jwt/v4 v4.4.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
github.com/golang/protobuf v1.5.2 h1:ROPKBNFfQgOUMifHyP+KYbvpjbdoFNs+aK7DXlji0Tw=
github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.7 h1:81/ik6ipDQS2aGcBfIN5dHDB36BwrStyeAQquSYCV4o=
github.com/google/go-cmp v0.5.7/go.mod h1:n+brtR0CgQNWTVd5ZUFpTBC8YFBDLK/h/bpaJ8/DtOE=
github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=
github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
github.com/imdario/mergo v0.3.12/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=
github.com/shirou/gopsutil/v3 v3.21.8/go.mod h1:YWp/H8Qs5fVmf17v7JNZzA0mPJ+mS2e9JdiUF9LlKzQ=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/tklauser/go-sysconf v0.3.9/go.mod h1:11DU/5sG7UexIrp/O6g35hrWzu0JxlwQ3LSFUzyeuhs=
github.com/tklauser/numcpus v0.3.0/go.mod h1:yFGUr7TUHQRAhyqBcEg0Ge34zDBAsIvJJcyE6boqnA8=
go.opentelemetry.io/otel v1.7.0/go.mod h1:5BdUoMIz5WEs0vt0CUEMtSSaTSHBBVwrhnz7+nrD5xk=
go.opentelemetry.io/otel/sdk v1.7.0/go.mod h1:uTEOTwaqIVuTGiJN7ii13Ibp75wJmYUDe374q6cZwUU=
go.opentelemetry.io/otel/trace v1.7.0/go.mod h1:fzLSB9nqR2eXzxPXb2JW9IKE+ScyXA48yyE4TNvoHqU=
go.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20220525230936-793ad666bf5e h1:T8NU3HyQ8ClP4SEE+KbFlg6n0NhuTsN4MyznaarGsZM=
golang.org/x/crypto v0.0.0-20220525230936-793ad666bf5e/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=
golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2 h1:CIJ76btIcR3eFI5EgSo6k1qKw9KJexJuRLI9G7Hp5wE=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220513210516-0976fa681c29/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423185535-09eb48e85fd7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210816074244-15123e1e1f71/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220412211240-33da011f77ad h1:ntjMns5wyP/fN65tdBD4g8J5w8n015+iIIs9rtjXkY0=
golang.org/x/sys v0.0.0-20220412211240-33da011f77ad/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6 h1:aRYxNxv6iGQlyVaZmk6ZgYEDa+Jg18DxebPSrd6bg1M=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1NKEZ+0owSTG1fDTci4IqFcE=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd h1:e0TwkXOdbnH/1x5rc5MZ/VYyiZ4v+RdVfrGMqEwT68I=
google.golang.org/genproto v0.0.0-20220519153652-3a47de7e79bd/go.mod h1:RAyBrSAP7Fh3Nc84ghnVLDPuV51xc9agzmm4Ph6i0Q4=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTpR3n0=
google.golang.org/grpc v1.36.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/grpc v1.46.0/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/grpc v1.46.2 h1:u+MLGgVf7vRdjEYZ8wDFhAVNmhkbJ5hmrA1LMWK1CAQ=
google.golang.org/grpc v1.46.2/go.mod h1:vN9eftEi1UMyUsIF80+uQXhHjbXYbm0uXoFCACuMGWk=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.28.0 h1:w43yiav+6bVFTBQFZX0r7ipe9JQ1QsbMgHwbBziscLw=
google.golang.org/protobuf v1.28.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=

```

`pkg/hash.go`:

```go
/*
 * MIT License
 *
 * Copyright (c) 2022. HominSu
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

package pkg

import (
	"github.com/go-kratos/kratos/v2/errors"
	"golang.org/x/crypto/bcrypt"
)

const (
	// reason holds the error reason.
	reason string = "INTERNAL_SERVER_ERROR"
)

var ErrHashFailed = errors.InternalServer(reason, "Hash password failed")

func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", ErrHashFailed
	}
	return string(bytes), nil
}

func VerifyPassword(hashed, password string) bool {
	if err := bcrypt.CompareHashAndPassword([]byte(hashed), []byte(password)); err != nil {
		return false
	}
	return true
}

```

`third_party/README.md`:

```md
# third_party

```

`third_party/errors/errors.proto`:

```proto
syntax = "proto3";

package errors;

option go_package = "github.com/go-kratos/kratos/v2/errors;errors";
option java_multiple_files = true;
option java_package = "com.github.kratos.errors";
option objc_class_prefix = "KratosErrors";

import "google/protobuf/descriptor.proto";

extend google.protobuf.EnumOptions {
  int32 default_code = 1108;
}

extend google.protobuf.EnumValueOptions {
  int32 code = 1109;
}
```

`third_party/google/api/annotations.proto`:

```proto
// Copyright (c) 2015, Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package google.api;

import "google/api/http.proto";
import "google/protobuf/descriptor.proto";

option go_package = "google.golang.org/genproto/googleapis/api/annotations;annotations";
option java_multiple_files = true;
option java_outer_classname = "AnnotationsProto";
option java_package = "com.google.api";
option objc_class_prefix = "GAPI";

extend google.protobuf.MethodOptions {
  // See `HttpRule`.
  HttpRule http = 72295728;
}

```

`third_party/google/api/http.proto`:

```proto
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package google.api;

option cc_enable_arenas = true;
option go_package = "google.golang.org/genproto/googleapis/api/annotations;annotations";
option java_multiple_files = true;
option java_outer_classname = "HttpProto";
option java_package = "com.google.api";
option objc_class_prefix = "GAPI";

// Defines the HTTP configuration for an API service. It contains a list of
// [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method
// to one or more HTTP REST API methods.
message Http {
  // A list of HTTP configuration rules that apply to individual API methods.
  //
  // **NOTE:** All service configuration rules follow "last one wins" order.
  repeated HttpRule rules = 1;

  // When set to true, URL path parameters will be fully URI-decoded except in
  // cases of single segment matches in reserved expansion, where "%2F" will be
  // left encoded.
  //
  // The default behavior is to not decode RFC 6570 reserved characters in multi
  // segment matches.
  bool fully_decode_reserved_expansion = 2;
}

// # gRPC Transcoding
//
// gRPC Transcoding is a feature for mapping between a gRPC method and one or
// more HTTP REST endpoints. It allows developers to build a single API service
// that supports both gRPC APIs and REST APIs. Many systems, including [Google
// APIs](https://github.com/googleapis/googleapis),
// [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC
// Gateway](https://github.com/grpc-ecosystem/grpc-gateway),
// and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature
// and use it for large scale production services.
//
// `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies
// how different portions of the gRPC request message are mapped to the URL
// path, URL query parameters, and HTTP request body. It also controls how the
// gRPC response message is mapped to the HTTP response body. `HttpRule` is
// typically specified as an `google.api.http` annotation on the gRPC method.
//
// Each mapping specifies a URL path template and an HTTP method. The path
// template may refer to one or more fields in the gRPC request message, as long
// as each field is a non-repeated field with a primitive (non-message) type.
// The path template controls how fields of the request message are mapped to
// the URL path.
//
// Example:
//
//     service Messaging {
//       rpc GetMessage(GetMessageRequest) returns (Message) {
//         option (google.api.http) = {
//             get: "/v1/{name=messages/*}"
//         };
//       }
//     }
//     message GetMessageRequest {
//       string name = 1; // Mapped to URL path.
//     }
//     message Message {
//       string text = 1; // The resource content.
//     }
//
// This enables an HTTP REST to gRPC mapping as below:
//
// HTTP | gRPC
// -----|-----
// `GET /v1/messages/123456`  | `GetMessage(name: "messages/123456")`
//
// Any fields in the request message which are not bound by the path template
// automatically become HTTP query parameters if there is no HTTP request body.
// For example:
//
//     service Messaging {
//       rpc GetMessage(GetMessageRequest) returns (Message) {
//         option (google.api.http) = {
//             get:"/v1/messages/{message_id}"
//         };
//       }
//     }
//     message GetMessageRequest {
//       message SubMessage {
//         string subfield = 1;
//       }
//       string message_id = 1; // Mapped to URL path.
//       int64 revision = 2;    // Mapped to URL query parameter `revision`.
//       SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.
//     }
//
// This enables a HTTP JSON to RPC mapping as below:
//
// HTTP | gRPC
// -----|-----
// `GET /v1/messages/123456?revision=2&sub.subfield=foo` |
// `GetMessage(message_id: "123456" revision: 2 sub: SubMessage(subfield:
// "foo"))`
//
// Note that fields which are mapped to URL query parameters must have a
// primitive type or a repeated primitive type or a non-repeated message type.
// In the case of a repeated type, the parameter can be repeated in the URL
// as `...?param=A&param=B`. In the case of a message type, each field of the
// message is mapped to a separate parameter, such as
// `...?foo.a=A&foo.b=B&foo.c=C`.
//
// For HTTP methods that allow a request body, the `body` field
// specifies the mapping. Consider a REST update method on the
// message resource collection:
//
//     service Messaging {
//       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
//         option (google.api.http) = {
//           patch: "/v1/messages/{message_id}"
//           body: "message"
//         };
//       }
//     }
//     message UpdateMessageRequest {
//       string message_id = 1; // mapped to the URL
//       Message message = 2;   // mapped to the body
//     }
//
// The following HTTP JSON to RPC mapping is enabled, where the
// representation of the JSON in the request body is determined by
// protos JSON encoding:
//
// HTTP | gRPC
// -----|-----
// `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
// "123456" message { text: "Hi!" })`
//
// The special name `*` can be used in the body mapping to define that
// every field not bound by the path template should be mapped to the
// request body.  This enables the following alternative definition of
// the update method:
//
//     service Messaging {
//       rpc UpdateMessage(Message) returns (Message) {
//         option (google.api.http) = {
//           patch: "/v1/messages/{message_id}"
//           body: "*"
//         };
//       }
//     }
//     message Message {
//       string message_id = 1;
//       string text = 2;
//     }
//
//
// The following HTTP JSON to RPC mapping is enabled:
//
// HTTP | gRPC
// -----|-----
// `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
// "123456" text: "Hi!")`
//
// Note that when using `*` in the body mapping, it is not possible to
// have HTTP parameters, as all fields not bound by the path end in
// the body. This makes this option more rarely used in practice when
// defining REST APIs. The common usage of `*` is in custom methods
// which don't use the URL at all for transferring data.
//
// It is possible to define multiple HTTP methods for one RPC by using
// the `additional_bindings` option. Example:
//
//     service Messaging {
//       rpc GetMessage(GetMessageRequest) returns (Message) {
//         option (google.api.http) = {
//           get: "/v1/messages/{message_id}"
//           additional_bindings {
//             get: "/v1/users/{user_id}/messages/{message_id}"
//           }
//         };
//       }
//     }
//     message GetMessageRequest {
//       string message_id = 1;
//       string user_id = 2;
//     }
//
// This enables the following two alternative HTTP JSON to RPC mappings:
//
// HTTP | gRPC
// -----|-----
// `GET /v1/messages/123456` | `GetMessage(message_id: "123456")`
// `GET /v1/users/me/messages/123456` | `GetMessage(user_id: "me" message_id:
// "123456")`
//
// ## Rules for HTTP mapping
//
// 1. Leaf request fields (recursive expansion nested messages in the request
//    message) are classified into three categories:
//    - Fields referred by the path template. They are passed via the URL path.
//    - Fields referred by the [HttpRule.body][google.api.HttpRule.body]. They are passed via the HTTP
//      request body.
//    - All other fields are passed via the URL query parameters, and the
//      parameter name is the field path in the request message. A repeated
//      field can be represented as multiple query parameters under the same
//      name.
//  2. If [HttpRule.body][google.api.HttpRule.body] is "*", there is no URL query parameter, all fields
//     are passed via URL path and HTTP request body.
//  3. If [HttpRule.body][google.api.HttpRule.body] is omitted, there is no HTTP request body, all
//     fields are passed via URL path and URL query parameters.
//
// ### Path template syntax
//
//     Template = "/" Segments [ Verb ] ;
//     Segments = Segment { "/" Segment } ;
//     Segment  = "*" | "**" | LITERAL | Variable ;
//     Variable = "{" FieldPath [ "=" Segments ] "}" ;
//     FieldPath = IDENT { "." IDENT } ;
//     Verb     = ":" LITERAL ;
//
// The syntax `*` matches a single URL path segment. The syntax `**` matches
// zero or more URL path segments, which must be the last part of the URL path
// except the `Verb`.
//
// The syntax `Variable` matches part of the URL path as specified by its
// template. A variable template must not contain other variables. If a variable
// matches a single path segment, its template may be omitted, e.g. `{var}`
// is equivalent to `{var=*}`.
//
// The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`
// contains any reserved character, such characters should be percent-encoded
// before the matching.
//
// If a variable contains exactly one path segment, such as `"{var}"` or
// `"{var=*}"`, when such a variable is expanded into a URL path on the client
// side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The
// server side does the reverse decoding. Such variables show up in the
// [Discovery
// Document](https://developers.google.com/discovery/v1/reference/apis) as
// `{var}`.
//
// If a variable contains multiple path segments, such as `"{var=foo/*}"`
// or `"{var=**}"`, when such a variable is expanded into a URL path on the
// client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.
// The server side does the reverse decoding, except "%2F" and "%2f" are left
// unchanged. Such variables show up in the
// [Discovery
// Document](https://developers.google.com/discovery/v1/reference/apis) as
// `{+var}`.
//
// ## Using gRPC API Service Configuration
//
// gRPC API Service Configuration (service config) is a configuration language
// for configuring a gRPC service to become a user-facing product. The
// service config is simply the YAML representation of the `google.api.Service`
// proto message.
//
// As an alternative to annotating your proto file, you can configure gRPC
// transcoding in your service config YAML files. You do this by specifying a
// `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same
// effect as the proto annotation. This can be particularly useful if you
// have a proto that is reused in multiple services. Note that any transcoding
// specified in the service config will override any matching transcoding
// configuration in the proto.
//
// Example:
//
//     http:
//       rules:
//         # Selects a gRPC method and applies HttpRule to it.
//         - selector: example.v1.Messaging.GetMessage
//           get: /v1/messages/{message_id}/{sub.subfield}
//
// ## Special notes
//
// When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the
// proto to JSON conversion must follow the [proto3
// specification](https://developers.google.com/protocol-buffers/docs/proto3#json).
//
// While the single segment variable follows the semantics of
// [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String
// Expansion, the multi segment variable **does not** follow RFC 6570 Section
// 3.2.3 Reserved Expansion. The reason is that the Reserved Expansion
// does not expand special characters like `?` and `#`, which would lead
// to invalid URLs. As the result, gRPC Transcoding uses a custom encoding
// for multi segment variables.
//
// The path variables **must not** refer to any repeated or mapped field,
// because client libraries are not capable of handling such variable expansion.
//
// The path variables **must not** capture the leading "/" character. The reason
// is that the most common use case "{var}" does not capture the leading "/"
// character. For consistency, all path variables must share the same behavior.
//
// Repeated message fields must not be mapped to URL query parameters, because
// no client library can support such complicated mapping.
//
// If an API needs to use a JSON array for request or response body, it can map
// the request or response body to a repeated field. However, some gRPC
// Transcoding implementations may not support this feature.
message HttpRule {
  // Selects a method to which this rule applies.
  //
  // Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
  string selector = 1;

  // Determines the URL pattern is matched by this rules. This pattern can be
  // used with any of the {get|put|post|delete|patch} methods. A custom method
  // can be defined using the 'custom' field.
  oneof pattern {
    // Maps to HTTP GET. Used for listing and getting information about
    // resources.
    string get = 2;

    // Maps to HTTP PUT. Used for replacing a resource.
    string put = 3;

    // Maps to HTTP POST. Used for creating a resource or performing an action.
    string post = 4;

    // Maps to HTTP DELETE. Used for deleting a resource.
    string delete = 5;

    // Maps to HTTP PATCH. Used for updating a resource.
    string patch = 6;

    // The custom pattern is used for specifying an HTTP method that is not
    // included in the `pattern` field, such as HEAD, or "*" to leave the
    // HTTP method unspecified for this rule. The wild-card rule is useful
    // for services that provide content to Web (HTML) clients.
    CustomHttpPattern custom = 8;
  }

  // The name of the request field whose value is mapped to the HTTP request
  // body, or `*` for mapping all request fields not captured by the path
  // pattern to the HTTP body, or omitted for not having any HTTP request body.
  //
  // NOTE: the referred field must be present at the top-level of the request
  // message type.
  string body = 7;

  // Optional. The name of the response field whose value is mapped to the HTTP
  // response body. When omitted, the entire response message will be used
  // as the HTTP response body.
  //
  // NOTE: The referred field must be present at the top-level of the response
  // message type.
  string response_body = 12;

  // Additional HTTP bindings for the selector. Nested bindings must
  // not contain an `additional_bindings` field themselves (that is,
  // the nesting may only be one level deep).
  repeated HttpRule additional_bindings = 11;
}

// A custom pattern is used for defining custom HTTP verb.
message CustomHttpPattern {
  // The name of this custom HTTP verb.
  string kind = 1;

  // The path matched by this custom verb.
  string path = 2;
}

```

`third_party/google/api/httpbody.proto`:

```proto
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package google.api;

import "google/protobuf/any.proto";

option cc_enable_arenas = true;
option go_package = "google.golang.org/genproto/googleapis/api/httpbody;httpbody";
option java_multiple_files = true;
option java_outer_classname = "HttpBodyProto";
option java_package = "com.google.api";
option objc_class_prefix = "GAPI";

// Message that represents an arbitrary HTTP body. It should only be used for
// payload formats that can't be represented as JSON, such as raw binary or
// an HTML page.
//
//
// This message can be used both in streaming and non-streaming API methods in
// the request as well as the response.
//
// It can be used as a top-level request field, which is convenient if one
// wants to extract parameters from either the URL or HTTP template into the
// request fields and also want access to the raw HTTP body.
//
// Example:
//
//     message GetResourceRequest {
//       // A unique request id.
//       string request_id = 1;
//
//       // The raw HTTP body is bound to this field.
//       google.api.HttpBody http_body = 2;
//     }
//
//     service ResourceService {
//       rpc GetResource(GetResourceRequest) returns (google.api.HttpBody);
//       rpc UpdateResource(google.api.HttpBody) returns
//       (google.protobuf.Empty);
//     }
//
// Example with streaming methods:
//
//     service CaldavService {
//       rpc GetCalendar(stream google.api.HttpBody)
//         returns (stream google.api.HttpBody);
//       rpc UpdateCalendar(stream google.api.HttpBody)
//         returns (stream google.api.HttpBody);
//     }
//
// Use of this type only changes how the request and response bodies are
// handled, all other features will continue to work unchanged.
message HttpBody {
  // The HTTP Content-Type header value specifying the content type of the body.
  string content_type = 1;

  // The HTTP request/response body as raw binary.
  bytes data = 2;

  // Application specific response metadata. Must be set in the first response
  // for streaming APIs.
  repeated google.protobuf.Any extensions = 3;
}

```

`third_party/google/protobuf/descriptor.proto`:

```proto
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// The messages in this file describe the definitions found in .proto files.
// A valid .proto file can be translated directly to a FileDescriptorProto
// without any other information (e.g. without reading its imports).


syntax = "proto2";

package google.protobuf;

option go_package = "google.golang.org/protobuf/types/descriptorpb";
option java_package = "com.google.protobuf";
option java_outer_classname = "DescriptorProtos";
option csharp_namespace = "Google.Protobuf.Reflection";
option objc_class_prefix = "GPB";
option cc_enable_arenas = true;

// descriptor.proto must be optimized for speed because reflection-based
// algorithms don't work during bootstrapping.
option optimize_for = SPEED;

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
message FileDescriptorSet {
  repeated FileDescriptorProto file = 1;
}

// Describes a complete .proto file.
message FileDescriptorProto {
  optional string name = 1;     // file name, relative to root of source tree
  optional string package = 2;  // e.g. "foo", "foo.bar", etc.

  // Names of files imported by this file.
  repeated string dependency = 3;
  // Indexes of the public imported files in the dependency list above.
  repeated int32 public_dependency = 10;
  // Indexes of the weak imported files in the dependency list.
  // For Google-internal migration only. Do not use.
  repeated int32 weak_dependency = 11;

  // All top-level definitions in this file.
  repeated DescriptorProto message_type = 4;
  repeated EnumDescriptorProto enum_type = 5;
  repeated ServiceDescriptorProto service = 6;
  repeated FieldDescriptorProto extension = 7;

  optional FileOptions options = 8;

  // This field contains optional information about the original source code.
  // You may safely remove this entire field without harming runtime
  // functionality of the descriptors -- the information is needed only by
  // development tools.
  optional SourceCodeInfo source_code_info = 9;

  // The syntax of the proto file.
  // The supported values are "proto2" and "proto3".
  optional string syntax = 12;
}

// Describes a message type.
message DescriptorProto {
  optional string name = 1;

  repeated FieldDescriptorProto field = 2;
  repeated FieldDescriptorProto extension = 6;

  repeated DescriptorProto nested_type = 3;
  repeated EnumDescriptorProto enum_type = 4;

  message ExtensionRange {
    optional int32 start = 1;  // Inclusive.
    optional int32 end = 2;    // Exclusive.

    optional ExtensionRangeOptions options = 3;
  }
  repeated ExtensionRange extension_range = 5;

  repeated OneofDescriptorProto oneof_decl = 8;

  optional MessageOptions options = 7;

  // Range of reserved tag numbers. Reserved tag numbers may not be used by
  // fields or extension ranges in the same message. Reserved ranges may
  // not overlap.
  message ReservedRange {
    optional int32 start = 1;  // Inclusive.
    optional int32 end = 2;    // Exclusive.
  }
  repeated ReservedRange reserved_range = 9;
  // Reserved field names, which may not be used by fields in the same message.
  // A given name may only be reserved once.
  repeated string reserved_name = 10;
}

message ExtensionRangeOptions {
  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;


  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

// Describes a field within a message.
message FieldDescriptorProto {
  enum Type {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    TYPE_DOUBLE = 1;
    TYPE_FLOAT = 2;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    TYPE_INT64 = 3;
    TYPE_UINT64 = 4;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    TYPE_INT32 = 5;
    TYPE_FIXED64 = 6;
    TYPE_FIXED32 = 7;
    TYPE_BOOL = 8;
    TYPE_STRING = 9;
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    TYPE_GROUP = 10;
    TYPE_MESSAGE = 11;  // Length-delimited aggregate.

    // New in version 2.
    TYPE_BYTES = 12;
    TYPE_UINT32 = 13;
    TYPE_ENUM = 14;
    TYPE_SFIXED32 = 15;
    TYPE_SFIXED64 = 16;
    TYPE_SINT32 = 17;  // Uses ZigZag encoding.
    TYPE_SINT64 = 18;  // Uses ZigZag encoding.
  }

  enum Label {
    // 0 is reserved for errors
    LABEL_OPTIONAL = 1;
    LABEL_REQUIRED = 2;
    LABEL_REPEATED = 3;
  }

  optional string name = 1;
  optional int32 number = 3;
  optional Label label = 4;

  // If type_name is set, this need not be set.  If both this and type_name
  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  optional Type type = 5;

  // For message and enum types, this is the name of the type.  If the name
  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  // rules are used to find the type (i.e. first the nested types within this
  // message are searched, then within the parent, on up to the root
  // namespace).
  optional string type_name = 6;

  // For extensions, this is the name of the type being extended.  It is
  // resolved in the same manner as type_name.
  optional string extendee = 2;

  // For numeric types, contains the original text representation of the value.
  // For booleans, "true" or "false".
  // For strings, contains the default text contents (not escaped in any way).
  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  // TODO(kenton):  Base-64 encode?
  optional string default_value = 7;

  // If set, gives the index of a oneof in the containing type's oneof_decl
  // list.  This field is a member of that oneof.
  optional int32 oneof_index = 9;

  // JSON name of this field. The value is set by protocol compiler. If the
  // user has set a "json_name" option on this field, that option's value
  // will be used. Otherwise, it's deduced from the field's name by converting
  // it to camelCase.
  optional string json_name = 10;

  optional FieldOptions options = 8;

  // If true, this is a proto3 "optional". When a proto3 field is optional, it
  // tracks presence regardless of field type.
  //
  // When proto3_optional is true, this field must be belong to a oneof to
  // signal to old proto3 clients that presence is tracked for this field. This
  // oneof is known as a "synthetic" oneof, and this field must be its sole
  // member (each proto3 optional field gets its own synthetic oneof). Synthetic
  // oneofs exist in the descriptor only, and do not generate any API. Synthetic
  // oneofs must be ordered after all "real" oneofs.
  //
  // For message fields, proto3_optional doesn't create any semantic change,
  // since non-repeated message fields always track presence. However it still
  // indicates the semantic detail of whether the user wrote "optional" or not.
  // This can be useful for round-tripping the .proto file. For consistency we
  // give message fields a synthetic oneof also, even though it is not required
  // to track presence. This is especially important because the parser can't
  // tell if a field is a message or an enum, so it must always create a
  // synthetic oneof.
  //
  // Proto2 optional fields do not set this flag, because they already indicate
  // optional with `LABEL_OPTIONAL`.
  optional bool proto3_optional = 17;
}

// Describes a oneof.
message OneofDescriptorProto {
  optional string name = 1;
  optional OneofOptions options = 2;
}

// Describes an enum type.
message EnumDescriptorProto {
  optional string name = 1;

  repeated EnumValueDescriptorProto value = 2;

  optional EnumOptions options = 3;

  // Range of reserved numeric values. Reserved values may not be used by
  // entries in the same enum. Reserved ranges may not overlap.
  //
  // Note that this is distinct from DescriptorProto.ReservedRange in that it
  // is inclusive such that it can appropriately represent the entire int32
  // domain.
  message EnumReservedRange {
    optional int32 start = 1;  // Inclusive.
    optional int32 end = 2;    // Inclusive.
  }

  // Range of reserved numeric values. Reserved numeric values may not be used
  // by enum values in the same enum declaration. Reserved ranges may not
  // overlap.
  repeated EnumReservedRange reserved_range = 4;

  // Reserved enum value names, which may not be reused. A given name may only
  // be reserved once.
  repeated string reserved_name = 5;
}

// Describes a value within an enum.
message EnumValueDescriptorProto {
  optional string name = 1;
  optional int32 number = 2;

  optional EnumValueOptions options = 3;
}

// Describes a service.
message ServiceDescriptorProto {
  optional string name = 1;
  repeated MethodDescriptorProto method = 2;

  optional ServiceOptions options = 3;
}

// Describes a method of a service.
message MethodDescriptorProto {
  optional string name = 1;

  // Input and output type names.  These are resolved in the same way as
  // FieldDescriptorProto.type_name, but must refer to a message type.
  optional string input_type = 2;
  optional string output_type = 3;

  optional MethodOptions options = 4;

  // Identifies if client streams multiple client messages
  optional bool client_streaming = 5 [default = false];
  // Identifies if server streams multiple server messages
  optional bool server_streaming = 6 [default = false];
}


// ===================================================================
// Options

// Each of the definitions above may have "options" attached.  These are
// just annotations which may cause code to be generated slightly differently
// or may contain hints for code that manipulates protocol messages.
//
// Clients may define custom options as extensions of the *Options messages.
// These extensions may not yet be known at parsing time, so the parser cannot
// store the values in them.  Instead it stores them in a field in the *Options
// message called uninterpreted_option. This field must have the same name
// across all *Options messages. We then use this field to populate the
// extensions when we build a descriptor, at which point all protos have been
// parsed and so all extensions are known.
//
// Extension numbers for custom options may be chosen as follows:
// * For options which will only be used within a single application or
//   organization, or for experimental options, use field numbers 50000
//   through 99999.  It is up to you to ensure that you do not use the
//   same number for multiple options.
// * For options which will be published and used publicly by multiple
//   independent entities, e-mail protobuf-global-extension-registry@google.com
//   to reserve extension numbers. Simply provide your project name (e.g.
//   Objective-C plugin) and your project website (if available) -- there's no
//   need to explain how you intend to use them. Usually you only need one
//   extension number. You can declare multiple options with only one extension
//   number by putting them in a sub-message. See the Custom Options section of
//   the docs for examples:
//   https://developers.google.com/protocol-buffers/docs/proto#options
//   If this turns out to be popular, a web service will be set up
//   to automatically assign option numbers.

message FileOptions {

  // Sets the Java package where classes generated from this .proto will be
  // placed.  By default, the proto package is used, but this is often
  // inappropriate because proto packages do not normally start with backwards
  // domain names.
  optional string java_package = 1;


  // Controls the name of the wrapper Java class generated for the .proto file.
  // That class will always contain the .proto file's getDescriptor() method as
  // well as any top-level extensions defined in the .proto file.
  // If java_multiple_files is disabled, then all the other classes from the
  // .proto file will be nested inside the single wrapper outer class.
  optional string java_outer_classname = 8;

  // If enabled, then the Java code generator will generate a separate .java
  // file for each top-level message, enum, and service defined in the .proto
  // file.  Thus, these types will *not* be nested inside the wrapper class
  // named by java_outer_classname.  However, the wrapper class will still be
  // generated to contain the file's getDescriptor() method as well as any
  // top-level extensions defined in the file.
  optional bool java_multiple_files = 10 [default = false];

  // This option does nothing.
  optional bool java_generate_equals_and_hash = 20 [deprecated=true];

  // If set true, then the Java2 code generator will generate code that
  // throws an exception whenever an attempt is made to assign a non-UTF-8
  // byte sequence to a string field.
  // Message reflection will do the same.
  // However, an extension field still accepts non-UTF-8 byte sequences.
  // This option has no effect on when used with the lite runtime.
  optional bool java_string_check_utf8 = 27 [default = false];


  // Generated classes can be optimized for speed or code size.
  enum OptimizeMode {
    SPEED = 1;         // Generate complete code for parsing, serialization,
    // etc.
    CODE_SIZE = 2;     // Use ReflectionOps to implement these methods.
    LITE_RUNTIME = 3;  // Generate code using MessageLite and the lite runtime.
  }
  optional OptimizeMode optimize_for = 9 [default = SPEED];

  // Sets the Go package where structs generated from this .proto will be
  // placed. If omitted, the Go package will be derived from the following:
  //   - The basename of the package import path, if provided.
  //   - Otherwise, the package statement in the .proto file, if present.
  //   - Otherwise, the basename of the .proto file, without extension.
  optional string go_package = 11;




  // Should generic services be generated in each language?  "Generic" services
  // are not specific to any particular RPC system.  They are generated by the
  // main code generators in each language (without additional plugins).
  // Generic services were the only kind of service generation supported by
  // early versions of google.protobuf.
  //
  // Generic services are now considered deprecated in favor of using plugins
  // that generate code specific to your particular RPC system.  Therefore,
  // these default to false.  Old code which depends on generic services should
  // explicitly set them to true.
  optional bool cc_generic_services = 16 [default = false];
  optional bool java_generic_services = 17 [default = false];
  optional bool py_generic_services = 18 [default = false];
  optional bool php_generic_services = 42 [default = false];

  // Is this file deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for everything in the file, or it will be completely ignored; in the very
  // least, this is a formalization for deprecating files.
  optional bool deprecated = 23 [default = false];

  // Enables the use of arenas for the proto messages in this file. This applies
  // only to generated classes for C++.
  optional bool cc_enable_arenas = 31 [default = true];


  // Sets the objective c class prefix which is prepended to all objective c
  // generated classes from this .proto. There is no default.
  optional string objc_class_prefix = 36;

  // Namespace for generated classes; defaults to the package.
  optional string csharp_namespace = 37;

  // By default Swift generators will take the proto package and CamelCase it
  // replacing '.' with underscore and use that to prefix the types/symbols
  // defined. When this options is provided, they will use this value instead
  // to prefix the types/symbols defined.
  optional string swift_prefix = 39;

  // Sets the php class prefix which is prepended to all php generated classes
  // from this .proto. Default is empty.
  optional string php_class_prefix = 40;

  // Use this option to change the namespace of php generated classes. Default
  // is empty. When this option is empty, the package name will be used for
  // determining the namespace.
  optional string php_namespace = 41;

  // Use this option to change the namespace of php generated metadata classes.
  // Default is empty. When this option is empty, the proto file name will be
  // used for determining the namespace.
  optional string php_metadata_namespace = 44;

  // Use this option to change the package of ruby generated classes. Default
  // is empty. When this option is not set, the package name will be used for
  // determining the ruby package.
  optional string ruby_package = 45;


  // The parser stores options it doesn't recognize here.
  // See the documentation for the "Options" section above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message.
  // See the documentation for the "Options" section above.
  extensions 1000 to max;

  reserved 38;
}

message MessageOptions {
  // Set true to use the old proto1 MessageSet wire format for extensions.
  // This is provided for backwards-compatibility with the MessageSet wire
  // format.  You should not use this for any other reason:  It's less
  // efficient, has fewer features, and is more complicated.
  //
  // The message must be defined exactly as follows:
  //   message Foo {
  //     option message_set_wire_format = true;
  //     extensions 4 to max;
  //   }
  // Note that the message cannot have any defined fields; MessageSets only
  // have extensions.
  //
  // All extensions of your type must be singular messages; e.g. they cannot
  // be int32s, enums, or repeated messages.
  //
  // Because this is an option, the above two restrictions are not enforced by
  // the protocol compiler.
  optional bool message_set_wire_format = 1 [default = false];

  // Disables the generation of the standard "descriptor()" accessor, which can
  // conflict with a field of the same name.  This is meant to make migration
  // from proto1 easier; new code should avoid fields named "descriptor".
  optional bool no_standard_descriptor_accessor = 2 [default = false];

  // Is this message deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the message, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating messages.
  optional bool deprecated = 3 [default = false];

  reserved 4, 5, 6;

  // Whether the message is an automatically generated map entry type for the
  // maps field.
  //
  // For maps fields:
  //     map<KeyType, ValueType> map_field = 1;
  // The parsed descriptor looks like:
  //     message MapFieldEntry {
  //         option map_entry = true;
  //         optional KeyType key = 1;
  //         optional ValueType value = 2;
  //     }
  //     repeated MapFieldEntry map_field = 1;
  //
  // Implementations may choose not to generate the map_entry=true message, but
  // use a native map in the target language to hold the keys and values.
  // The reflection APIs in such implementations still need to work as
  // if the field is a repeated message field.
  //
  // NOTE: Do not set the option in .proto files. Always use the maps syntax
  // instead. The option should only be implicitly set by the proto compiler
  // parser.
  optional bool map_entry = 7;

  reserved 8;  // javalite_serializable
  reserved 9;  // javanano_as_lite


  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message FieldOptions {
  // The ctype option instructs the C++ code generator to use a different
  // representation of the field than it normally would.  See the specific
  // options below.  This option is not yet implemented in the open source
  // release -- sorry, we'll try to include it in a future version!
  optional CType ctype = 1 [default = STRING];
  enum CType {
    // Default mode.
    STRING = 0;

    CORD = 1;

    STRING_PIECE = 2;
  }
  // The packed option can be enabled for repeated primitive fields to enable
  // a more efficient representation on the wire. Rather than repeatedly
  // writing the tag and type for each element, the entire array is encoded as
  // a single length-delimited blob. In proto3, only explicit setting it to
  // false will avoid using packed encoding.
  optional bool packed = 2;

  // The jstype option determines the JavaScript type used for values of the
  // field.  The option is permitted only for 64 bit integral and fixed types
  // (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
  // is represented as JavaScript string, which avoids loss of precision that
  // can happen when a large value is converted to a floating point JavaScript.
  // Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
  // use the JavaScript "number" type.  The behavior of the default option
  // JS_NORMAL is implementation dependent.
  //
  // This option is an enum to permit additional types to be added, e.g.
  // goog.math.Integer.
  optional JSType jstype = 6 [default = JS_NORMAL];
  enum JSType {
    // Use the default type.
    JS_NORMAL = 0;

    // Use JavaScript strings.
    JS_STRING = 1;

    // Use JavaScript numbers.
    JS_NUMBER = 2;
  }

  // Should this field be parsed lazily?  Lazy applies only to message-type
  // fields.  It means that when the outer message is initially parsed, the
  // inner message's contents will not be parsed but instead stored in encoded
  // form.  The inner message will actually be parsed when it is first accessed.
  //
  // This is only a hint.  Implementations are free to choose whether to use
  // eager or lazy parsing regardless of the value of this option.  However,
  // setting this option true suggests that the protocol author believes that
  // using lazy parsing on this field is worth the additional bookkeeping
  // overhead typically needed to implement it.
  //
  // This option does not affect the public interface of any generated code;
  // all method signatures remain the same.  Furthermore, thread-safety of the
  // interface is not affected by this option; const methods remain safe to
  // call from multiple threads concurrently, while non-const methods continue
  // to require exclusive access.
  //
  //
  // Note that implementations may choose not to check required fields within
  // a lazy sub-message.  That is, calling IsInitialized() on the outer message
  // may return true even if the inner message has missing required fields.
  // This is necessary because otherwise the inner message would have to be
  // parsed in order to perform the check, defeating the purpose of lazy
  // parsing.  An implementation which chooses not to check required fields
  // must be consistent about it.  That is, for any particular sub-message, the
  // implementation must either *always* check its required fields, or *never*
  // check its required fields, regardless of whether or not the message has
  // been parsed.
  optional bool lazy = 5 [default = false];

  // Is this field deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for accessors, or it will be completely ignored; in the very least, this
  // is a formalization for deprecating fields.
  optional bool deprecated = 3 [default = false];

  // For Google-internal migration only. Do not use.
  optional bool weak = 10 [default = false];


  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;

  reserved 4;  // removed jtype
}

message OneofOptions {
  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message EnumOptions {

  // Set this option to true to allow mapping different tag names to the same
  // value.
  optional bool allow_alias = 2;

  // Is this enum deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the enum, or it will be completely ignored; in the very least, this
  // is a formalization for deprecating enums.
  optional bool deprecated = 3 [default = false];

  reserved 5;  // javanano_as_lite

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message EnumValueOptions {
  // Is this enum value deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the enum value, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating enum values.
  optional bool deprecated = 1 [default = false];

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message ServiceOptions {

  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
  //   framework.  We apologize for hoarding these numbers to ourselves, but
  //   we were already using them long before we decided to release Protocol
  //   Buffers.

  // Is this service deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the service, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating services.
  optional bool deprecated = 33 [default = false];

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

message MethodOptions {

  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
  //   framework.  We apologize for hoarding these numbers to ourselves, but
  //   we were already using them long before we decided to release Protocol
  //   Buffers.

  // Is this method deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the method, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating methods.
  optional bool deprecated = 33 [default = false];

  // Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
  // or neither? HTTP based RPC implementation may choose GET verb for safe
  // methods, and PUT verb for idempotent methods instead of the default POST.
  enum IdempotencyLevel {
    IDEMPOTENCY_UNKNOWN = 0;
    NO_SIDE_EFFECTS = 1;  // implies idempotent
    IDEMPOTENT = 2;       // idempotent, but may have side effects
  }
  optional IdempotencyLevel idempotency_level = 34
  [default = IDEMPOTENCY_UNKNOWN];

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}


// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
message UninterpretedOption {
  // The name of the uninterpreted option.  Each string represents a segment in
  // a dot-separated name.  is_extension is true iff a segment represents an
  // extension (denoted with parentheses in options specs in .proto files).
  // E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
  // "foo.(bar.baz).qux".
  message NamePart {
    required string name_part = 1;
    required bool is_extension = 2;
  }
  repeated NamePart name = 2;

  // The value of the uninterpreted option, in whatever type the tokenizer
  // identified it as during parsing. Exactly one of these should be set.
  optional string identifier_value = 3;
  optional uint64 positive_int_value = 4;
  optional int64 negative_int_value = 5;
  optional double double_value = 6;
  optional bytes string_value = 7;
  optional string aggregate_value = 8;
}

// ===================================================================
// Optional source code info

// Encapsulates information about the original source file from which a
// FileDescriptorProto was generated.
message SourceCodeInfo {
  // A Location identifies a piece of source code in a .proto file which
  // corresponds to a particular definition.  This information is intended
  // to be useful to IDEs, code indexers, documentation generators, and similar
  // tools.
  //
  // For example, say we have a file like:
  //   message Foo {
  //     optional string foo = 1;
  //   }
  // Let's look at just the field definition:
  //   optional string foo = 1;
  //   ^       ^^     ^^  ^  ^^^
  //   a       bc     de  f  ghi
  // We have the following locations:
  //   span   path               represents
  //   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
  //   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
  //   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
  //   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
  //   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
  //
  // Notes:
  // - A location may refer to a repeated field itself (i.e. not to any
  //   particular index within it).  This is used whenever a set of elements are
  //   logically enclosed in a single code segment.  For example, an entire
  //   extend block (possibly containing multiple extension definitions) will
  //   have an outer location whose path refers to the "extensions" repeated
  //   field without an index.
  // - Multiple locations may have the same path.  This happens when a single
  //   logical declaration is spread out across multiple places.  The most
  //   obvious example is the "extend" block again -- there may be multiple
  //   extend blocks in the same scope, each of which will have the same path.
  // - A location's span is not always a subset of its parent's span.  For
  //   example, the "extendee" of an extension declaration appears at the
  //   beginning of the "extend" block and is shared by all extensions within
  //   the block.
  // - Just because a location's span is a subset of some other location's span
  //   does not mean that it is a descendant.  For example, a "group" defines
  //   both a type and a field in a single declaration.  Thus, the locations
  //   corresponding to the type and field and their components will overlap.
  // - Code which tries to interpret locations should probably be designed to
  //   ignore those that it doesn't understand, as more types of locations could
  //   be recorded in the future.
  repeated Location location = 1;
  message Location {
    // Identifies which part of the FileDescriptorProto was defined at this
    // location.
    //
    // Each element is a field number or an index.  They form a path from
    // the root FileDescriptorProto to the place where the definition occurs.  For
    // example, this path:
    //   [ 4, 3, 2, 7, 1 ]
    // refers to:
    //   file.message_type(3)  // 4, 3
    //       .field(7)         // 2, 7
    //       .name()           // 1
    // This is because FileDescriptorProto.message_type has field number 4:
    //   repeated DescriptorProto message_type = 4;
    // and DescriptorProto.field has field number 2:
    //   repeated FieldDescriptorProto field = 2;
    // and FieldDescriptorProto.name has field number 1:
    //   optional string name = 1;
    //
    // Thus, the above path gives the location of a field name.  If we removed
    // the last element:
    //   [ 4, 3, 2, 7 ]
    // this path refers to the whole field declaration (from the beginning
    // of the label to the terminating semicolon).
    repeated int32 path = 1 [packed = true];

    // Always has exactly three or four elements: start line, start column,
    // end line (optional, otherwise assumed same as start line), end column.
    // These are packed into a single field for efficiency.  Note that line
    // and column numbers are zero-based -- typically you will want to add
    // 1 to each before displaying to a user.
    repeated int32 span = 2 [packed = true];

    // If this SourceCodeInfo represents a complete declaration, these are any
    // comments appearing before and after the declaration which appear to be
    // attached to the declaration.
    //
    // A series of line comments appearing on consecutive lines, with no other
    // tokens appearing on those lines, will be treated as a single comment.
    //
    // leading_detached_comments will keep paragraphs of comments that appear
    // before (but not connected to) the current element. Each paragraph,
    // separated by empty lines, will be one comment element in the repeated
    // field.
    //
    // Only the comment content is provided; comment markers (e.g. //) are
    // stripped out.  For block comments, leading whitespace and an asterisk
    // will be stripped from the beginning of each line other than the first.
    // Newlines are included in the output.
    //
    // Examples:
    //
    //   optional int32 foo = 1;  // Comment attached to foo.
    //   // Comment attached to bar.
    //   optional int32 bar = 2;
    //
    //   optional string baz = 3;
    //   // Comment attached to baz.
    //   // Another line attached to baz.
    //
    //   // Comment attached to qux.
    //   //
    //   // Another line attached to qux.
    //   optional double qux = 4;
    //
    //   // Detached comment for corge. This is not leading or trailing comments
    //   // to qux or corge because there are blank lines separating it from
    //   // both.
    //
    //   // Detached comment for corge paragraph 2.
    //
    //   optional string corge = 5;
    //   /* Block comment attached
    //    * to corge.  Leading asterisks
    //    * will be removed. */
    //   /* Block comment attached to
    //    * grault. */
    //   optional int32 grault = 6;
    //
    //   // ignored detached comments.
    optional string leading_comments = 3;
    optional string trailing_comments = 4;
    repeated string leading_detached_comments = 6;
  }
}

// Describes the relationship between generated code and its original source
// file. A GeneratedCodeInfo message is associated with only one generated
// source file, but may contain references to different source .proto files.
message GeneratedCodeInfo {
  // An Annotation connects some span of text in generated code to an element
  // of its generating .proto file.
  repeated Annotation annotation = 1;
  message Annotation {
    // Identifies the element in the original source .proto file. This field
    // is formatted the same as SourceCodeInfo.Location.path.
    repeated int32 path = 1 [packed = true];

    // Identifies the filesystem path to the original source .proto.
    optional string source_file = 2;

    // Identifies the starting offset in bytes in the generated code
    // that relates to the identified object.
    optional int32 begin = 3;

    // Identifies the ending offset in bytes in the generated code that
    // relates to the identified offset. The end offset should be one past
    // the last relevant byte (so the length of the text = end - begin).
    optional int32 end = 4;
  }
}

```

`third_party/google/protobuf/empty.proto`:

```proto
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option go_package = "google.golang.org/protobuf/types/known/emptypb";
option java_package = "com.google.protobuf";
option java_outer_classname = "EmptyProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";
option cc_enable_arenas = true;

// A generic empty message that you can re-use to avoid defining duplicated
// empty messages in your APIs. A typical example is to use it as the request
// or the response type of an API method. For instance:
//
//     service Foo {
//       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
//     }
//
message Empty {}
```

`third_party/google/protobuf/timestamp.proto`:

```proto
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option cc_enable_arenas = true;
option go_package = "github.com/golang/protobuf/ptypes/timestamp";
option java_package = "com.google.protobuf";
option java_outer_classname = "TimestampProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";

// A Timestamp represents a point in time independent of any time zone or local
// calendar, encoded as a count of seconds and fractions of seconds at
// nanosecond resolution. The count is relative to an epoch at UTC midnight on
// January 1, 1970, in the proleptic Gregorian calendar which extends the
// Gregorian calendar backwards to year one.
//
// All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
// second table is needed for interpretation, using a [24-hour linear
// smear](https://developers.google.com/time/smear).
//
// The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
// restricting to that range, we ensure that we can convert to and from [RFC
// 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
//
// # Examples
//
// Example 1: Compute Timestamp from POSIX `time()`.
//
//     Timestamp timestamp;
//     timestamp.set_seconds(time(NULL));
//     timestamp.set_nanos(0);
//
// Example 2: Compute Timestamp from POSIX `gettimeofday()`.
//
//     struct timeval tv;
//     gettimeofday(&tv, NULL);
//
//     Timestamp timestamp;
//     timestamp.set_seconds(tv.tv_sec);
//     timestamp.set_nanos(tv.tv_usec * 1000);
//
// Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
//
//     FILETIME ft;
//     GetSystemTimeAsFileTime(&ft);
//     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
//
//     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
//     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
//     Timestamp timestamp;
//     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
//     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
//
// Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
//
//     long millis = System.currentTimeMillis();
//
//     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
//         .setNanos((int) ((millis % 1000) * 1000000)).build();
//
//
// Example 5: Compute Timestamp from current time in Python.
//
//     timestamp = Timestamp()
//     timestamp.GetCurrentTime()
//
// # JSON Mapping
//
// In JSON format, the Timestamp type is encoded as a string in the
// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
// format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
// where {year} is always expressed using four digits while {month}, {day},
// {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
// seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
// are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
// is required. A proto3 JSON serializer should always use UTC (as indicated by
// "Z") when printing the Timestamp type and a proto3 JSON parser should be
// able to accept both UTC and other timezones (as indicated by an offset).
//
// For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
// 01:30 UTC on January 15, 2017.
//
// In JavaScript, one can convert a Date object to this format using the
// standard
// [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
// method. In Python, a standard `datetime.datetime` object can be converted
// to this format using
// [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
// the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
// the Joda Time's [`ISODateTimeFormat.dateTime()`](
// http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
// ) to obtain a formatter capable of generating timestamps in this format.
//
//
message Timestamp {
  // Represents seconds of UTC time since Unix epoch
  // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  // 9999-12-31T23:59:59Z inclusive.
  int64 seconds = 1;

  // Non-negative fractions of a second at nanosecond resolution. Negative
  // second values with fractions must still have non-negative nanos values
  // that count forward in time. Must be from 0 to 999,999,999
  // inclusive.
  int32 nanos = 2;
}

```

`third_party/protoc-gen-openapiv2/options/annotations.proto`:

```proto
syntax = "proto3";

package grpc.gateway.protoc_gen_openapiv2.options;

option go_package = "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options";

import "google/protobuf/descriptor.proto";
import "protoc-gen-openapiv2/options/openapiv2.proto";

extend google.protobuf.FileOptions {
  // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
  //
  // All IDs are the same, as assigned. It is okay that they are the same, as they extend
  // different descriptor messages.
  Swagger openapiv2_swagger = 1042;
}
extend google.protobuf.MethodOptions {
  // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
  //
  // All IDs are the same, as assigned. It is okay that they are the same, as they extend
  // different descriptor messages.
  Operation openapiv2_operation = 1042;
}
extend google.protobuf.MessageOptions {
  // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
  //
  // All IDs are the same, as assigned. It is okay that they are the same, as they extend
  // different descriptor messages.
  Schema openapiv2_schema = 1042;
}
extend google.protobuf.ServiceOptions {
  // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
  //
  // All IDs are the same, as assigned. It is okay that they are the same, as they extend
  // different descriptor messages.
  Tag openapiv2_tag = 1042;
}
extend google.protobuf.FieldOptions {
  // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
  //
  // All IDs are the same, as assigned. It is okay that they are the same, as they extend
  // different descriptor messages.
  JSONSchema openapiv2_field = 1042;
}

```

`third_party/protoc-gen-openapiv2/options/openapiv2.proto`:

```proto
syntax = "proto3";

package grpc.gateway.protoc_gen_openapiv2.options;

option go_package = "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options";

import "google/protobuf/struct.proto";

// Scheme describes the schemes supported by the OpenAPI Swagger
// and Operation objects.
enum Scheme {
  UNKNOWN = 0;
  HTTP = 1;
  HTTPS = 2;
  WS = 3;
  WSS = 4;
}

// `Swagger` is a representation of OpenAPI v2 specification's Swagger object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#swaggerObject
//
// Example:
//
//  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//    info: {
//      title: "Echo API";
//      version: "1.0";
//      description: ";
//      contact: {
//        name: "gRPC-Gateway project";
//        url: "https://github.com/grpc-ecosystem/grpc-gateway";
//        email: "none@example.com";
//      };
//      license: {
//        name: "BSD 3-Clause License";
//        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
//      };
//    };
//    schemes: HTTPS;
//    consumes: "application/json";
//    produces: "application/json";
//  };
//
message Swagger {
  // Specifies the OpenAPI Specification version being used. It can be
  // used by the OpenAPI UI and other clients to interpret the API listing. The
  // value MUST be "2.0".
  string swagger = 1;
  // Provides metadata about the API. The metadata can be used by the
  // clients if needed.
  Info info = 2;
  // The host (name or ip) serving the API. This MUST be the host only and does
  // not include the scheme nor sub-paths. It MAY include a port. If the host is
  // not included, the host serving the documentation is to be used (including
  // the port). The host does not support path templating.
  string host = 3;
  // The base path on which the API is served, which is relative to the host. If
  // it is not included, the API is served directly under the host. The value
  // MUST start with a leading slash (/). The basePath does not support path
  // templating.
  // Note that using `base_path` does not change the endpoint paths that are
  // generated in the resulting OpenAPI file. If you wish to use `base_path`
  // with relatively generated OpenAPI paths, the `base_path` prefix must be
  // manually removed from your `google.api.http` paths and your code changed to
  // serve the API from the `base_path`.
  string base_path = 4;
  // The transfer protocol of the API. Values MUST be from the list: "http",
  // "https", "ws", "wss". If the schemes is not included, the default scheme to
  // be used is the one used to access the OpenAPI definition itself.
  repeated Scheme schemes = 5;
  // A list of MIME types the APIs can consume. This is global to all APIs but
  // can be overridden on specific API calls. Value MUST be as described under
  // Mime Types.
  repeated string consumes = 6;
  // A list of MIME types the APIs can produce. This is global to all APIs but
  // can be overridden on specific API calls. Value MUST be as described under
  // Mime Types.
  repeated string produces = 7;
  // field 8 is reserved for 'paths'.
  reserved 8;
  // field 9 is reserved for 'definitions', which at this time are already
  // exposed as and customizable as proto messages.
  reserved 9;
  // An object to hold responses that can be used across operations. This
  // property does not define global responses for all operations.
  map<string, Response> responses = 10;
  // Security scheme definitions that can be used across the specification.
  SecurityDefinitions security_definitions = 11;
  // A declaration of which security schemes are applied for the API as a whole.
  // The list of values describes alternative security schemes that can be used
  // (that is, there is a logical OR between the security requirements).
  // Individual operations can override this definition.
  repeated SecurityRequirement security = 12;
  // field 13 is reserved for 'tags', which are supposed to be exposed as and
  // customizable as proto services. TODO(ivucica): add processing of proto
  // service objects into OpenAPI v2 Tag objects.
  reserved 13;
  // Additional external documentation.
  ExternalDocumentation external_docs = 14;
  map<string, google.protobuf.Value> extensions = 15;
}

// `Operation` is a representation of OpenAPI v2 specification's Operation object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#operationObject
//
// Example:
//
//  service EchoService {
//    rpc Echo(SimpleMessage) returns (SimpleMessage) {
//      option (google.api.http) = {
//        get: "/v1/example/echo/{id}"
//      };
//
//      option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
//        summary: "Get a message.";
//        operation_id: "getMessage";
//        tags: "echo";
//        responses: {
//          key: "200"
//            value: {
//            description: "OK";
//          }
//        }
//      };
//    }
//  }
message Operation {
  // A list of tags for API documentation control. Tags can be used for logical
  // grouping of operations by resources or any other qualifier.
  repeated string tags = 1;
  // A short summary of what the operation does. For maximum readability in the
  // swagger-ui, this field SHOULD be less than 120 characters.
  string summary = 2;
  // A verbose explanation of the operation behavior. GFM syntax can be used for
  // rich text representation.
  string description = 3;
  // Additional external documentation for this operation.
  ExternalDocumentation external_docs = 4;
  // Unique string used to identify the operation. The id MUST be unique among
  // all operations described in the API. Tools and libraries MAY use the
  // operationId to uniquely identify an operation, therefore, it is recommended
  // to follow common programming naming conventions.
  string operation_id = 5;
  // A list of MIME types the operation can consume. This overrides the consumes
  // definition at the OpenAPI Object. An empty value MAY be used to clear the
  // global definition. Value MUST be as described under Mime Types.
  repeated string consumes = 6;
  // A list of MIME types the operation can produce. This overrides the produces
  // definition at the OpenAPI Object. An empty value MAY be used to clear the
  // global definition. Value MUST be as described under Mime Types.
  repeated string produces = 7;
  // field 8 is reserved for 'parameters'.
  reserved 8;
  // The list of possible responses as they are returned from executing this
  // operation.
  map<string, Response> responses = 9;
  // The transfer protocol for the operation. Values MUST be from the list:
  // "http", "https", "ws", "wss". The value overrides the OpenAPI Object
  // schemes definition.
  repeated Scheme schemes = 10;
  // Declares this operation to be deprecated. Usage of the declared operation
  // should be refrained. Default value is false.
  bool deprecated = 11;
  // A declaration of which security schemes are applied for this operation. The
  // list of values describes alternative security schemes that can be used
  // (that is, there is a logical OR between the security requirements). This
  // definition overrides any declared top-level security. To remove a top-level
  // security declaration, an empty array can be used.
  repeated SecurityRequirement security = 12;
  map<string, google.protobuf.Value> extensions = 13;
}

// `Header` is a representation of OpenAPI v2 specification's Header object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#headerObject
//
message Header {
  // `Description` is a short description of the header.
  string description = 1;
  // The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
  string type = 2;
  // `Format` The extending format for the previously mentioned type.
  string format = 3;
  // field 4 is reserved for 'items', but in OpenAPI-specific way.
  reserved 4;
  // field 5 is reserved `Collection Format` Determines the format of the array if type array is used.
  reserved 5;
  // `Default` Declares the value of the header that the server will use if none is provided.
  // See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
  // Unlike JSON Schema this value MUST conform to the defined type for the header.
  string default = 6;
  // field 7 is reserved for 'maximum'.
  reserved 7;
  // field 8 is reserved for 'exclusiveMaximum'.
  reserved 8;
  // field 9 is reserved for 'minimum'.
  reserved 9;
  // field 10 is reserved for 'exclusiveMinimum'.
  reserved 10;
  // field 11 is reserved for 'maxLength'.
  reserved 11;
  // field 12 is reserved for 'minLength'.
  reserved 12;
  // 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
  string pattern = 13;
  // field 14 is reserved for 'maxItems'.
  reserved 14;
  // field 15 is reserved for 'minItems'.
  reserved 15;
  // field 16 is reserved for 'uniqueItems'.
  reserved 16;
  // field 17 is reserved for 'enum'.
  reserved 17;
  // field 18 is reserved for 'multipleOf'.
  reserved 18;
}

// `Response` is a representation of OpenAPI v2 specification's Response object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#responseObject
//
message Response {
  // `Description` is a short description of the response.
  // GFM syntax can be used for rich text representation.
  string description = 1;
  // `Schema` optionally defines the structure of the response.
  // If `Schema` is not provided, it means there is no content to the response.
  Schema schema = 2;
  // `Headers` A list of headers that are sent with the response.
  // `Header` name is expected to be a string in the canonical format of the MIME header key
  // See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
  map<string, Header> headers = 3;
  // `Examples` gives per-mimetype response examples.
  // See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
  map<string, string> examples = 4;
  map<string, google.protobuf.Value> extensions = 5;
}

// `Info` is a representation of OpenAPI v2 specification's Info object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#infoObject
//
// Example:
//
//  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//    info: {
//      title: "Echo API";
//      version: "1.0";
//      description: ";
//      contact: {
//        name: "gRPC-Gateway project";
//        url: "https://github.com/grpc-ecosystem/grpc-gateway";
//        email: "none@example.com";
//      };
//      license: {
//        name: "BSD 3-Clause License";
//        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
//      };
//    };
//    ...
//  };
//
message Info {
  // The title of the application.
  string title = 1;
  // A short description of the application. GFM syntax can be used for rich
  // text representation.
  string description = 2;
  // The Terms of Service for the API.
  string terms_of_service = 3;
  // The contact information for the exposed API.
  Contact contact = 4;
  // The license information for the exposed API.
  License license = 5;
  // Provides the version of the application API (not to be confused
  // with the specification version).
  string version = 6;
  map<string, google.protobuf.Value> extensions = 7;
}

// `Contact` is a representation of OpenAPI v2 specification's Contact object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#contactObject
//
// Example:
//
//  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//    info: {
//      ...
//      contact: {
//        name: "gRPC-Gateway project";
//        url: "https://github.com/grpc-ecosystem/grpc-gateway";
//        email: "none@example.com";
//      };
//      ...
//    };
//    ...
//  };
//
message Contact {
  // The identifying name of the contact person/organization.
  string name = 1;
  // The URL pointing to the contact information. MUST be in the format of a
  // URL.
  string url = 2;
  // The email address of the contact person/organization. MUST be in the format
  // of an email address.
  string email = 3;
}

// `License` is a representation of OpenAPI v2 specification's License object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#licenseObject
//
// Example:
//
//  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//    info: {
//      ...
//      license: {
//        name: "BSD 3-Clause License";
//        url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/master/LICENSE.txt";
//      };
//      ...
//    };
//    ...
//  };
//
message License {
  // The license name used for the API.
  string name = 1;
  // A URL to the license used for the API. MUST be in the format of a URL.
  string url = 2;
}

// `ExternalDocumentation` is a representation of OpenAPI v2 specification's
// ExternalDocumentation object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#externalDocumentationObject
//
// Example:
//
//  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//    ...
//    external_docs: {
//      description: "More about gRPC-Gateway";
//      url: "https://github.com/grpc-ecosystem/grpc-gateway";
//    }
//    ...
//  };
//
message ExternalDocumentation {
  // A short description of the target documentation. GFM syntax can be used for
  // rich text representation.
  string description = 1;
  // The URL for the target documentation. Value MUST be in the format
  // of a URL.
  string url = 2;
}

// `Schema` is a representation of OpenAPI v2 specification's Schema object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
//
message Schema {
  JSONSchema json_schema = 1;
  // Adds support for polymorphism. The discriminator is the schema property
  // name that is used to differentiate between other schema that inherit this
  // schema. The property name used MUST be defined at this schema and it MUST
  // be in the required property list. When used, the value MUST be the name of
  // this schema or any schema that inherits it.
  string discriminator = 2;
  // Relevant only for Schema "properties" definitions. Declares the property as
  // "read only". This means that it MAY be sent as part of a response but MUST
  // NOT be sent as part of the request. Properties marked as readOnly being
  // true SHOULD NOT be in the required list of the defined schema. Default
  // value is false.
  bool read_only = 3;
  // field 4 is reserved for 'xml'.
  reserved 4;
  // Additional external documentation for this schema.
  ExternalDocumentation external_docs = 5;
  // A free-form property to include an example of an instance for this schema in JSON.
  // This is copied verbatim to the output.
  string example = 6;
}

// `JSONSchema` represents properties from JSON Schema taken, and as used, in
// the OpenAPI v2 spec.
//
// This includes changes made by OpenAPI v2.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
//
// See also: https://cswr.github.io/JsonSchema/spec/basic_types/,
// https://github.com/json-schema-org/json-schema-spec/blob/master/schema.json
//
// Example:
//
//  message SimpleMessage {
//    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
//      json_schema: {
//        title: "SimpleMessage"
//        description: "A simple message."
//        required: ["id"]
//      }
//    };
//
//    // Id represents the message identifier.
//    string id = 1; [
//        (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
//          description: "The unique identifier of the simple message."
//        }];
//  }
//
message JSONSchema {
  // field 1 is reserved for '$id', omitted from OpenAPI v2.
  reserved 1;
  // field 2 is reserved for '$schema', omitted from OpenAPI v2.
  reserved 2;
  // Ref is used to define an external reference to include in the message.
  // This could be a fully qualified proto message reference, and that type must
  // be imported into the protofile. If no message is identified, the Ref will
  // be used verbatim in the output.
  // For example:
  //  `ref: ".google.protobuf.Timestamp"`.
  string ref = 3;
  // field 4 is reserved for '$comment', omitted from OpenAPI v2.
  reserved 4;
  // The title of the schema.
  string title = 5;
  // A short description of the schema.
  string description = 6;
  string default = 7;
  bool read_only = 8;
  // A free-form property to include a JSON example of this field. This is copied
  // verbatim to the output swagger.json. Quotes must be escaped.
  // This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
  string example = 9;
  double multiple_of = 10;
  // Maximum represents an inclusive upper limit for a numeric instance. The
  // value of MUST be a number,
  double maximum = 11;
  bool exclusive_maximum = 12;
  // minimum represents an inclusive lower limit for a numeric instance. The
  // value of MUST be a number,
  double minimum = 13;
  bool exclusive_minimum = 14;
  uint64 max_length = 15;
  uint64 min_length = 16;
  string pattern = 17;
  // field 18 is reserved for 'additionalItems', omitted from OpenAPI v2.
  reserved 18;
  // field 19 is reserved for 'items', but in OpenAPI-specific way.
  // TODO(ivucica): add 'items'?
  reserved 19;
  uint64 max_items = 20;
  uint64 min_items = 21;
  bool unique_items = 22;
  // field 23 is reserved for 'contains', omitted from OpenAPI v2.
  reserved 23;
  uint64 max_properties = 24;
  uint64 min_properties = 25;
  repeated string required = 26;
  // field 27 is reserved for 'additionalProperties', but in OpenAPI-specific
  // way. TODO(ivucica): add 'additionalProperties'?
  reserved 27;
  // field 28 is reserved for 'definitions', omitted from OpenAPI v2.
  reserved 28;
  // field 29 is reserved for 'properties', but in OpenAPI-specific way.
  // TODO(ivucica): add 'additionalProperties'?
  reserved 29;
  // following fields are reserved, as the properties have been omitted from
  // OpenAPI v2:
  // patternProperties, dependencies, propertyNames, const
  reserved 30 to 33;
  // Items in 'array' must be unique.
  repeated string array = 34;

  enum JSONSchemaSimpleTypes {
    UNKNOWN = 0;
    ARRAY = 1;
    BOOLEAN = 2;
    INTEGER = 3;
    NULL = 4;
    NUMBER = 5;
    OBJECT = 6;
    STRING = 7;
  }

  repeated JSONSchemaSimpleTypes type = 35;
  // `Format`
  string format = 36;
  // following fields are reserved, as the properties have been omitted from
  // OpenAPI v2: contentMediaType, contentEncoding, if, then, else
  reserved 37 to 41;
  // field 42 is reserved for 'allOf', but in OpenAPI-specific way.
  // TODO(ivucica): add 'allOf'?
  reserved 42;
  // following fields are reserved, as the properties have been omitted from
  // OpenAPI v2:
  // anyOf, oneOf, not
  reserved 43 to 45;
  // Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
  repeated string enum = 46;

  // Additional field level properties used when generating the OpenAPI v2 file.
  FieldConfiguration field_configuration = 1001;

  // 'FieldConfiguration' provides additional field level properties used when generating the OpenAPI v2 file.
  // These properties are not defined by OpenAPIv2, but they are used to control the generation.
  message FieldConfiguration {
    // Alternative parameter name when used as path parameter. If set, this will
    // be used as the complete parameter name when this field is used as a path
    // parameter. Use this to avoid having auto generated path parameter names
    // for overlapping paths.
    string path_param_name = 47;
  }
}

// `Tag` is a representation of OpenAPI v2 specification's Tag object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#tagObject
//
message Tag {
  // field 1 is reserved for 'name'. In our generator, this is (to be) extracted
  // from the name of proto service, and thus not exposed to the user, as
  // changing tag object's name would break the link to the references to the
  // tag in individual operation specifications.
  //
  // TODO(ivucica): Add 'name' property. Use it to allow override of the name of
  // global Tag object, then use that name to reference the tag throughout the
  // OpenAPI file.
  reserved 1;
  // A short description for the tag. GFM syntax can be used for rich text
  // representation.
  string description = 2;
  // Additional external documentation for this tag.
  ExternalDocumentation external_docs = 3;
}

// `SecurityDefinitions` is a representation of OpenAPI v2 specification's
// Security Definitions object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
//
// A declaration of the security schemes available to be used in the
// specification. This does not enforce the security schemes on the operations
// and only serves to provide the relevant details for each scheme.
message SecurityDefinitions {
  // A single security scheme definition, mapping a "name" to the scheme it
  // defines.
  map<string, SecurityScheme> security = 1;
}

// `SecurityScheme` is a representation of OpenAPI v2 specification's
// Security Scheme object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securitySchemeObject
//
// Allows the definition of a security scheme that can be used by the
// operations. Supported schemes are basic authentication, an API key (either as
// a header or as a query parameter) and OAuth2's common flows (implicit,
// password, application and access code).
message SecurityScheme {
  // The type of the security scheme. Valid values are "basic",
  // "apiKey" or "oauth2".
  enum Type {
    TYPE_INVALID = 0;
    TYPE_BASIC = 1;
    TYPE_API_KEY = 2;
    TYPE_OAUTH2 = 3;
  }

  // The location of the API key. Valid values are "query" or "header".
  enum In {
    IN_INVALID = 0;
    IN_QUERY = 1;
    IN_HEADER = 2;
  }

  // The flow used by the OAuth2 security scheme. Valid values are
  // "implicit", "password", "application" or "accessCode".
  enum Flow {
    FLOW_INVALID = 0;
    FLOW_IMPLICIT = 1;
    FLOW_PASSWORD = 2;
    FLOW_APPLICATION = 3;
    FLOW_ACCESS_CODE = 4;
  }

  // The type of the security scheme. Valid values are "basic",
  // "apiKey" or "oauth2".
  Type type = 1;
  // A short description for security scheme.
  string description = 2;
  // The name of the header or query parameter to be used.
  // Valid for apiKey.
  string name = 3;
  // The location of the API key. Valid values are "query" or
  // "header".
  // Valid for apiKey.
  In in = 4;
  // The flow used by the OAuth2 security scheme. Valid values are
  // "implicit", "password", "application" or "accessCode".
  // Valid for oauth2.
  Flow flow = 5;
  // The authorization URL to be used for this flow. This SHOULD be in
  // the form of a URL.
  // Valid for oauth2/implicit and oauth2/accessCode.
  string authorization_url = 6;
  // The token URL to be used for this flow. This SHOULD be in the
  // form of a URL.
  // Valid for oauth2/password, oauth2/application and oauth2/accessCode.
  string token_url = 7;
  // The available scopes for the OAuth2 security scheme.
  // Valid for oauth2.
  Scopes scopes = 8;
  map<string, google.protobuf.Value> extensions = 9;
}

// `SecurityRequirement` is a representation of OpenAPI v2 specification's
// Security Requirement object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityRequirementObject
//
// Lists the required security schemes to execute this operation. The object can
// have multiple security schemes declared in it which are all required (that
// is, there is a logical AND between the schemes).
//
// The name used for each property MUST correspond to a security scheme
// declared in the Security Definitions.
message SecurityRequirement {
  // If the security scheme is of type "oauth2", then the value is a list of
  // scope names required for the execution. For other security scheme types,
  // the array MUST be empty.
  message SecurityRequirementValue {
    repeated string scope = 1;
  }
  // Each name must correspond to a security scheme which is declared in
  // the Security Definitions. If the security scheme is of type "oauth2",
  // then the value is a list of scope names required for the execution.
  // For other security scheme types, the array MUST be empty.
  map<string, SecurityRequirementValue> security_requirement = 1;
}

// `Scopes` is a representation of OpenAPI v2 specification's Scopes object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#scopesObject
//
// Lists the available scopes for an OAuth2 security scheme.
message Scopes {
  // Maps between a name of a scope to a short description of it (as the value
  // of the property).
  map<string, string> scope = 1;
}

```

`third_party/validate/README.md`:

```md
# protoc-gen-validate (PGV)

* https://github.com/envoyproxy/protoc-gen-validate

```

`third_party/validate/validate.proto`:

```proto
syntax = "proto2";
package validate;

option go_package = "github.com/envoyproxy/protoc-gen-validate/validate";
option java_package = "io.envoyproxy.pgv.validate";

import "google/protobuf/descriptor.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

// Validation rules applied at the message level
extend google.protobuf.MessageOptions {
    // Disabled nullifies any validation rules for this message, including any
    // message fields associated with it that do support validation.
    optional bool disabled = 1071;
    // Ignore skips generation of validation methods for this message.
    optional bool ignored = 1072;
}

// Validation rules applied at the oneof level
extend google.protobuf.OneofOptions {
    // Required ensures that exactly one the field options in a oneof is set;
    // validation fails if no fields in the oneof are set.
    optional bool required = 1071;
}

// Validation rules applied at the field level
extend google.protobuf.FieldOptions {
    // Rules specify the validations to be performed on this field. By default,
    // no validation is performed against a field.
    optional FieldRules rules = 1071;
}

// FieldRules encapsulates the rules for each type of field. Depending on the
// field, the correct set should be used to ensure proper validations.
message FieldRules {
    optional MessageRules message = 17;
    oneof type {
        // Scalar Field Types
        FloatRules    float    = 1;
        DoubleRules   double   = 2;
        Int32Rules    int32    = 3;
        Int64Rules    int64    = 4;
        UInt32Rules   uint32   = 5;
        UInt64Rules   uint64   = 6;
        SInt32Rules   sint32   = 7;
        SInt64Rules   sint64   = 8;
        Fixed32Rules  fixed32  = 9;
        Fixed64Rules  fixed64  = 10;
        SFixed32Rules sfixed32 = 11;
        SFixed64Rules sfixed64 = 12;
        BoolRules     bool     = 13;
        StringRules   string   = 14;
        BytesRules    bytes    = 15;

        // Complex Field Types
        EnumRules     enum     = 16;
        RepeatedRules repeated = 18;
        MapRules      map      = 19;

        // Well-Known Field Types
        AnyRules       any       = 20;
        DurationRules  duration  = 21;
        TimestampRules timestamp = 22;
    }
}

// FloatRules describes the constraints applied to `float` values
message FloatRules {
    // Const specifies that this field must be exactly the specified value
    optional float const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional float lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional float lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional float gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional float gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated float in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated float not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// DoubleRules describes the constraints applied to `double` values
message DoubleRules {
    // Const specifies that this field must be exactly the specified value
    optional double const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional double lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional double lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional double gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional double gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated double in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated double not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// Int32Rules describes the constraints applied to `int32` values
message Int32Rules {
    // Const specifies that this field must be exactly the specified value
    optional int32 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional int32 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional int32 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional int32 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional int32 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated int32 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated int32 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// Int64Rules describes the constraints applied to `int64` values
message Int64Rules {
    // Const specifies that this field must be exactly the specified value
    optional int64 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional int64 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional int64 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional int64 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional int64 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated int64 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated int64 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// UInt32Rules describes the constraints applied to `uint32` values
message UInt32Rules {
    // Const specifies that this field must be exactly the specified value
    optional uint32 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional uint32 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional uint32 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional uint32 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional uint32 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated uint32 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated uint32 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// UInt64Rules describes the constraints applied to `uint64` values
message UInt64Rules {
    // Const specifies that this field must be exactly the specified value
    optional uint64 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional uint64 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional uint64 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional uint64 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional uint64 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated uint64 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated uint64 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// SInt32Rules describes the constraints applied to `sint32` values
message SInt32Rules {
    // Const specifies that this field must be exactly the specified value
    optional sint32 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional sint32 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional sint32 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional sint32 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional sint32 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated sint32 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated sint32 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// SInt64Rules describes the constraints applied to `sint64` values
message SInt64Rules {
    // Const specifies that this field must be exactly the specified value
    optional sint64 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional sint64 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional sint64 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional sint64 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional sint64 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated sint64 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated sint64 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// Fixed32Rules describes the constraints applied to `fixed32` values
message Fixed32Rules {
    // Const specifies that this field must be exactly the specified value
    optional fixed32 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional fixed32 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional fixed32 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional fixed32 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional fixed32 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated fixed32 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated fixed32 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// Fixed64Rules describes the constraints applied to `fixed64` values
message Fixed64Rules {
    // Const specifies that this field must be exactly the specified value
    optional fixed64 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional fixed64 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional fixed64 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional fixed64 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional fixed64 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated fixed64 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated fixed64 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// SFixed32Rules describes the constraints applied to `sfixed32` values
message SFixed32Rules {
    // Const specifies that this field must be exactly the specified value
    optional sfixed32 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional sfixed32 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional sfixed32 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional sfixed32 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional sfixed32 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated sfixed32 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated sfixed32 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// SFixed64Rules describes the constraints applied to `sfixed64` values
message SFixed64Rules {
    // Const specifies that this field must be exactly the specified value
    optional sfixed64 const = 1;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional sfixed64 lt = 2;

    // Lte specifies that this field must be less than or equal to the
    // specified value, inclusive
    optional sfixed64 lte = 3;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive. If the value of Gt is larger than a specified Lt or Lte, the
    // range is reversed.
    optional sfixed64 gt = 4;

    // Gte specifies that this field must be greater than or equal to the
    // specified value, inclusive. If the value of Gte is larger than a
    // specified Lt or Lte, the range is reversed.
    optional sfixed64 gte = 5;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated sfixed64 in = 6;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated sfixed64 not_in = 7;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 8;
}

// BoolRules describes the constraints applied to `bool` values
message BoolRules {
    // Const specifies that this field must be exactly the specified value
    optional bool const = 1;
}

// StringRules describe the constraints applied to `string` values
message StringRules {
    // Const specifies that this field must be exactly the specified value
    optional string const = 1;

    // Len specifies that this field must be the specified number of
    // characters (Unicode code points). Note that the number of
    // characters may differ from the number of bytes in the string.
    optional uint64 len = 19;

    // MinLen specifies that this field must be the specified number of
    // characters (Unicode code points) at a minimum. Note that the number of
    // characters may differ from the number of bytes in the string.
    optional uint64 min_len = 2;

    // MaxLen specifies that this field must be the specified number of
    // characters (Unicode code points) at a maximum. Note that the number of
    // characters may differ from the number of bytes in the string.
    optional uint64 max_len = 3;

    // LenBytes specifies that this field must be the specified number of bytes
    // at a minimum
    optional uint64 len_bytes = 20;

    // MinBytes specifies that this field must be the specified number of bytes
    // at a minimum
    optional uint64 min_bytes = 4;

    // MaxBytes specifies that this field must be the specified number of bytes
    // at a maximum
    optional uint64 max_bytes = 5;

    // Pattern specifes that this field must match against the specified
    // regular expression (RE2 syntax). The included expression should elide
    // any delimiters.
    optional string pattern  = 6;

    // Prefix specifies that this field must have the specified substring at
    // the beginning of the string.
    optional string prefix   = 7;

    // Suffix specifies that this field must have the specified substring at
    // the end of the string.
    optional string suffix   = 8;

    // Contains specifies that this field must have the specified substring
    // anywhere in the string.
    optional string contains = 9;

    // NotContains specifies that this field cannot have the specified substring
    // anywhere in the string.
    optional string not_contains = 23;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated string in     = 10;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated string not_in = 11;

    // WellKnown rules provide advanced constraints against common string
    // patterns
    oneof well_known {
        // Email specifies that the field must be a valid email address as
        // defined by RFC 5322
        bool email    = 12;

        // Hostname specifies that the field must be a valid hostname as
        // defined by RFC 1034. This constraint does not support
        // internationalized domain names (IDNs).
        bool hostname = 13;

        // Ip specifies that the field must be a valid IP (v4 or v6) address.
        // Valid IPv6 addresses should not include surrounding square brackets.
        bool ip       = 14;

        // Ipv4 specifies that the field must be a valid IPv4 address.
        bool ipv4     = 15;

        // Ipv6 specifies that the field must be a valid IPv6 address. Valid
        // IPv6 addresses should not include surrounding square brackets.
        bool ipv6     = 16;

        // Uri specifies that the field must be a valid, absolute URI as defined
        // by RFC 3986
        bool uri      = 17;

        // UriRef specifies that the field must be a valid URI as defined by RFC
        // 3986 and may be relative or absolute.
        bool uri_ref  = 18;

        // Address specifies that the field must be either a valid hostname as
        // defined by RFC 1034 (which does not support internationalized domain
        // names or IDNs), or it can be a valid IP (v4 or v6).
        bool address  = 21;

        // Uuid specifies that the field must be a valid UUID as defined by
        // RFC 4122
        bool uuid     = 22;

        // WellKnownRegex specifies a common well known pattern defined as a regex.
        KnownRegex well_known_regex = 24;
    }

  // This applies to regexes HTTP_HEADER_NAME and HTTP_HEADER_VALUE to enable
  // strict header validation.
  // By default, this is true, and HTTP header validations are RFC-compliant.
  // Setting to false will enable a looser validations that only disallows
  // \r\n\0 characters, which can be used to bypass header matching rules.
  optional bool strict = 25 [default = true];

  // IgnoreEmpty specifies that the validation rules of this field should be
  // evaluated only if the field is not empty
  optional bool ignore_empty = 26;
}

// WellKnownRegex contain some well-known patterns.
enum KnownRegex {
  UNKNOWN = 0;

  // HTTP header name as defined by RFC 7230.
  HTTP_HEADER_NAME = 1;

  // HTTP header value as defined by RFC 7230.
  HTTP_HEADER_VALUE = 2;
}

// BytesRules describe the constraints applied to `bytes` values
message BytesRules {
    // Const specifies that this field must be exactly the specified value
    optional bytes const = 1;

    // Len specifies that this field must be the specified number of bytes
    optional uint64 len = 13;

    // MinLen specifies that this field must be the specified number of bytes
    // at a minimum
    optional uint64 min_len = 2;

    // MaxLen specifies that this field must be the specified number of bytes
    // at a maximum
    optional uint64 max_len = 3;

    // Pattern specifes that this field must match against the specified
    // regular expression (RE2 syntax). The included expression should elide
    // any delimiters.
    optional string pattern  = 4;

    // Prefix specifies that this field must have the specified bytes at the
    // beginning of the string.
    optional bytes  prefix   = 5;

    // Suffix specifies that this field must have the specified bytes at the
    // end of the string.
    optional bytes  suffix   = 6;

    // Contains specifies that this field must have the specified bytes
    // anywhere in the string.
    optional bytes  contains = 7;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated bytes in     = 8;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated bytes not_in = 9;

    // WellKnown rules provide advanced constraints against common byte
    // patterns
    oneof well_known {
        // Ip specifies that the field must be a valid IP (v4 or v6) address in
        // byte format
        bool ip   = 10;

        // Ipv4 specifies that the field must be a valid IPv4 address in byte
        // format
        bool ipv4 = 11;

        // Ipv6 specifies that the field must be a valid IPv6 address in byte
        // format
        bool ipv6 = 12;
    }

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 14;
}

// EnumRules describe the constraints applied to enum values
message EnumRules {
    // Const specifies that this field must be exactly the specified value
    optional int32 const        = 1;

    // DefinedOnly specifies that this field must be only one of the defined
    // values for this enum, failing on any undefined value.
    optional bool  defined_only = 2;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated int32 in           = 3;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated int32 not_in       = 4;
}

// MessageRules describe the constraints applied to embedded message values.
// For message-type fields, validation is performed recursively.
message MessageRules {
    // Skip specifies that the validation rules of this field should not be
    // evaluated
    optional bool skip     = 1;

    // Required specifies that this field must be set
    optional bool required = 2;
}

// RepeatedRules describe the constraints applied to `repeated` values
message RepeatedRules {
    // MinItems specifies that this field must have the specified number of
    // items at a minimum
    optional uint64 min_items = 1;

    // MaxItems specifies that this field must have the specified number of
    // items at a maximum
    optional uint64 max_items = 2;

    // Unique specifies that all elements in this field must be unique. This
    // contraint is only applicable to scalar and enum types (messages are not
    // supported).
    optional bool   unique    = 3;

    // Items specifies the contraints to be applied to each item in the field.
    // Repeated message fields will still execute validation against each item
    // unless skip is specified here.
    optional FieldRules items = 4;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 5;
}

// MapRules describe the constraints applied to `map` values
message MapRules {
    // MinPairs specifies that this field must have the specified number of
    // KVs at a minimum
    optional uint64 min_pairs = 1;

    // MaxPairs specifies that this field must have the specified number of
    // KVs at a maximum
    optional uint64 max_pairs = 2;

    // NoSparse specifies values in this field cannot be unset. This only
    // applies to map's with message value types.
    optional bool no_sparse = 3;

    // Keys specifies the constraints to be applied to each key in the field.
    optional FieldRules keys   = 4;

    // Values specifies the constraints to be applied to the value of each key
    // in the field. Message values will still have their validations evaluated
    // unless skip is specified here.
    optional FieldRules values = 5;

    // IgnoreEmpty specifies that the validation rules of this field should be
    // evaluated only if the field is not empty
    optional bool ignore_empty = 6;
}

// AnyRules describe constraints applied exclusively to the
// `google.protobuf.Any` well-known type
message AnyRules {
    // Required specifies that this field must be set
    optional bool required = 1;

    // In specifies that this field's `type_url` must be equal to one of the
    // specified values.
    repeated string in     = 2;

    // NotIn specifies that this field's `type_url` must not be equal to any of
    // the specified values.
    repeated string not_in = 3;
}

// DurationRules describe the constraints applied exclusively to the
// `google.protobuf.Duration` well-known type
message DurationRules {
    // Required specifies that this field must be set
    optional bool required = 1;

    // Const specifies that this field must be exactly the specified value
    optional google.protobuf.Duration const = 2;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional google.protobuf.Duration lt = 3;

    // Lt specifies that this field must be less than the specified value,
    // inclusive
    optional google.protobuf.Duration lte = 4;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive
    optional google.protobuf.Duration gt = 5;

    // Gte specifies that this field must be greater than the specified value,
    // inclusive
    optional google.protobuf.Duration gte = 6;

    // In specifies that this field must be equal to one of the specified
    // values
    repeated google.protobuf.Duration in = 7;

    // NotIn specifies that this field cannot be equal to one of the specified
    // values
    repeated google.protobuf.Duration not_in = 8;
}

// TimestampRules describe the constraints applied exclusively to the
// `google.protobuf.Timestamp` well-known type
message TimestampRules {
    // Required specifies that this field must be set
    optional bool required = 1;

    // Const specifies that this field must be exactly the specified value
    optional google.protobuf.Timestamp const = 2;

    // Lt specifies that this field must be less than the specified value,
    // exclusive
    optional google.protobuf.Timestamp lt = 3;

    // Lte specifies that this field must be less than the specified value,
    // inclusive
    optional google.protobuf.Timestamp lte = 4;

    // Gt specifies that this field must be greater than the specified value,
    // exclusive
    optional google.protobuf.Timestamp gt = 5;

    // Gte specifies that this field must be greater than the specified value,
    // inclusive
    optional google.protobuf.Timestamp gte = 6;

    // LtNow specifies that this must be less than the current time. LtNow
    // can only be used with the Within rule.
    optional bool lt_now  = 7;

    // GtNow specifies that this must be greater than the current time. GtNow
    // can only be used with the Within rule.
    optional bool gt_now  = 8;

    // Within specifies that this field must be within this duration of the
    // current time. This constraint can be used alone or with the LtNow and
    // GtNow rules.
    optional google.protobuf.Duration within = 9;
}

```