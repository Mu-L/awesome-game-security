Project Path: arc_gmh5225_DSEDodge-Signed-Kernel-Driver_sflspr1a

Source Tree:

```txt
arc_gmh5225_DSEDodge-Signed-Kernel-Driver_sflspr1a
├── CERT
│   ├── Demo_CA_Root.cer
│   ├── Demo_CA_Root.pvk
│   ├── Demo_SPC_Code_Signing.cer
│   ├── Demo_SPC_Code_Signing.pvk
│   ├── README.txt
│   └── log.txt
├── KMDFDriver
│   ├── Device.c
│   ├── Device.h
│   ├── Driver.c
│   ├── Driver.h
│   ├── KMDFDriver.inf
│   ├── KMDFDriver.vcxproj
│   ├── KMDFDriver.vcxproj.filters
│   ├── Public.h
│   ├── Queue.c
│   ├── Queue.h
│   └── Trace.h
├── KMDFDriver.sln
└── README.md

```

`CERT/README.txt`:

```txt
#--------------------------------------------------------------------------------------------------------
# Create Root Certificate Authority (CA) to add to the UEFI Certificates and Trusted Root of the Local Machine
# The Kernel will trust anything signed by this authority.
#--------------------------------------------------------------------------------------------------------

makecert -r -pe -n "CN=Demo_CA_Root" -ss CA -sr CurrentUser -a sha256 -cy authority -sky signature -sv Demo_CA_Root.pvk Demo_CA_Root.cer -e 02/22/2023

#--------------------------------------------------------------------------------------------------------
# Create Cross Signing Certificate (SPC) that is Issued By our own Root Certificate Authority (CA)
#--------------------------------------------------------------------------------------------------------

makecert -pe -n "CN=Demo_SPC_Code_Signing" -a sha256 -cy end -sky signature -ic Demo_CA_Root.cer -iv Demo_CA_Root.pvk -sv Demo_SPC_Code_Signing.pvk Demo_SPC_Code_Signing.cer -eku 1.3.6.1.5.5.7.3.3 -e 02/22/2023

#--------------------------------------------------------------------------------------------------------
# Create the Production Code Signing Certificate that uses the SPC which is issued by our own CA
#--------------------------------------------------------------------------------------------------------

pvk2pfx -pvk Demo_SPC_Code_Signing.pvk -spc Demo_SPC_Code_Signing.cer -pfx Demo_SPC_PFX.pfx -po x

#--------------------------------------------------------------------------------------------------------
# Post Build: Create a Security Catalog for the Kernel Mode Driver
#--------------------------------------------------------------------------------------------------------

inf2cat /os:10_x64 /driver:.\x64\Release /uselocaltime

#--------------------------------------------------------------------------------------------------------
# Post Build: Signed Timestamp from Symantec for the Catalog
#--------------------------------------------------------------------------------------------------------

SignTool sign /fd sha256 /td SHA256 /tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /f .\CERT\Demo_SPC_PFX.pfx /p x /v .\x64\Release\KMDFDriver\kmdfdriver.cat

#--------------------------------------------------------------------------------------------------------
# Post Build: Signed Timestamp from Symantec for the Driver
#--------------------------------------------------------------------------------------------------------

SignTool sign /fd sha256 /td SHA256 /tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /f .\CERT\Demo_SPC_PFX.pfx /p x /v .\x64\Release\KMDFDriver\KMDFDriver.sys

```

`CERT/log.txt`:

```txt
**********************************************************************
** Visual Studio 2022 Developer Command Prompt v17.3.1
** Copyright (c) 2022 Microsoft Corporation
**********************************************************************

C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver>makecert -r -pe -n "CN=Demo_CA_Root" -ss CA -sr CurrentUser ^
More?    -a sha256 -cy authority -sky signature -len 4096 ^
More?    -sv Demo_CA_Root.pvk Demo_CA_Root.cer ^
More?    -e 02/22/2023
Succeeded

C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver>cd CERT

C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver\CERT>makecert -pe -n "CN=Demo_SPC_Code_Signing" -a sha256 -cy end ^
More?    -sky signature ^
More?    -ic Demo_CA_Root.cer -iv Demo_CA_Root.pvk ^
More?    -sv Demo_SPC_Code_Signing.pvk Demo_SPC_Code_Signing.cer ^
More?    -eku 1.3.6.1.5.5.7.3.3 ^
More?    -e 02/22/2023
Succeeded

C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver\CERT>pvk2pfx -pvk Demo_SPC_Code_Signing.pvk -spc Demo_SPC_Code_Signing.cer ^
More?    -pfx Demo_SPC_PFX.pfx ^
More?    -po x

C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver>inf2cat /os:10_x64 /driver:.\x64\Release /uselocaltime
...........................................
Signability test complete.

Errors:
None

Warnings:
None

Catalog generation complete.
C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver\x64\Release\kmdfdriver.cat
C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver\x64\Release\kmdfdriver\kmdfdriver.cat

C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver>SignTool sign /fd sha256 /td SHA256 /tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /f .\CERT\Demo_SPC_PFX.pfx /p x /v .\x64\Release\KMDFDriver\kmdfdriver.cat
The following certificate was selected:
    Issued to: Demo_SPC_Code_Signing
    Issued by: Demo_CA_Root
    Expires:   Wed Feb 22 00:00:00 2023
    SHA1 hash: BE60A7829512DE13AFDA4AB4D06B5424DE6DE2C8

Done Adding Additional Store
Successfully signed: .\x64\Release\KMDFDriver\kmdfdriver.cat

Number of files successfully Signed: 1
Number of warnings: 0
Number of errors: 0

C:\Users\KIEF\Documents\GitHub\DSEDodge-Signed-Kernel-Driver>SignTool sign /fd sha256 /td SHA256 /tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /f .\CERT\Demo_SPC_PFX.pfx /p x /v .\x64\Release\KMDFDriver\KMDFDriver.sys
The following certificate was selected:
    Issued to: Demo_SPC_Code_Signing
    Issued by: Demo_CA_Root
    Expires:   Wed Feb 22 00:00:00 2023
    SHA1 hash: BE60A7829512DE13AFDA4AB4D06B5424DE6DE2C8

Done Adding Additional Store
Successfully signed: .\x64\Release\KMDFDriver\KMDFDriver.sys

Number of files successfully Signed: 1
Number of warnings: 0
Number of errors: 0

```

`KMDFDriver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32811.315
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KMDFDriver", "KMDFDriver\KMDFDriver.vcxproj", "{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Debug|ARM64.Build.0 = Debug|ARM64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Debug|x64.ActiveCfg = Debug|x64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Debug|x64.Build.0 = Debug|x64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Debug|x64.Deploy.0 = Debug|x64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Release|ARM64.ActiveCfg = Release|ARM64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Release|ARM64.Build.0 = Release|ARM64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Release|ARM64.Deploy.0 = Release|ARM64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Release|x64.ActiveCfg = Release|x64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Release|x64.Build.0 = Release|x64
		{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {07D546DC-DF7D-4608-9761-50CE76C988CF}
	EndGlobalSection
EndGlobal

```

`KMDFDriver/Device.c`:

```c
/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, KMDFDriverCreateDevice)
#endif

NTSTATUS
KMDFDriverCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_OBJECT_ATTRIBUTES deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDFDEVICE device;
    NTSTATUS status;

    PAGED_CODE();

    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status)) {
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        deviceContext = DeviceGetContext(device);

        //
        // Initialize the context.
        //
        deviceContext->PrivateDeviceData = 0;

        //
        // Create a device interface so that applications can find and talk
        // to us.
        //
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_KMDFDriver,
            NULL // ReferenceString
            );

        if (NT_SUCCESS(status)) {
            //
            // Initialize the I/O Package and any Queues
            //
            status = KMDFDriverQueueInitialize(device);
        }
    }

    return status;
}

```

`KMDFDriver/Device.h`:

```h
/*++

Module Name:

    device.h

Abstract:

    This file contains the device definitions.

Environment:

    Kernel-mode Driver Framework

--*/

#include "public.h"

EXTERN_C_START

//
// The device context performs the same job as
// a WDM device extension in the driver frameworks
//
typedef struct _DEVICE_CONTEXT
{
    ULONG PrivateDeviceData;  // just a placeholder

} DEVICE_CONTEXT, *PDEVICE_CONTEXT;

//
// This macro will generate an inline function called DeviceGetContext
// which will be used to get a pointer to the device context memory
// in a type safe manner.
//
WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(DEVICE_CONTEXT, DeviceGetContext)

//
// Function to initialize the device and its callbacks
//
NTSTATUS
KMDFDriverCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    );

EXTERN_C_END

```

`KMDFDriver/Driver.c`:

```c
/*++

Module Name:

    driver.c

Abstract:

    This file contains the driver entry points and callbacks.

Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "driver.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, KMDFDriverEvtDeviceAdd)
#pragma alloc_text (PAGE, KMDFDriverEvtDriverContextCleanup)
#endif

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT  DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    DriverEntry initializes the driver and is the first routine called by the
    system after the driver is loaded. DriverEntry specifies the other entry
    points in the function driver, such as EvtDevice and DriverUnload.

Parameters Description:

    DriverObject - represents the instance of the function driver that is loaded
    into memory. DriverEntry must initialize members of DriverObject before it
    returns to the caller. DriverObject is allocated by the system before the
    driver is loaded, and it is released by the system after the system unloads
    the function driver from memory.

    RegistryPath - represents the driver specific path in the Registry.
    The function driver can use the path to store driver related data between
    reboots. The path does not store hardware instance specific data.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise.

--*/
{
    WDF_DRIVER_CONFIG config;
    NTSTATUS status;
    WDF_OBJECT_ATTRIBUTES attributes;

    //
    // Initialize WPP Tracing
    //
    WPP_INIT_TRACING(DriverObject, RegistryPath);

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

    //
    // Register a cleanup callback so that we can call WPP_CLEANUP when
    // the framework driver object is deleted during driver unload.
    //
    WDF_OBJECT_ATTRIBUTES_INIT(&attributes);
    attributes.EvtCleanupCallback = KMDFDriverEvtDriverContextCleanup;

    WDF_DRIVER_CONFIG_INIT(&config,
                           KMDFDriverEvtDeviceAdd
                           );

    status = WdfDriverCreate(DriverObject,
                             RegistryPath,
                             &attributes,
                             &config,
                             WDF_NO_HANDLE
                             );

    if (!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER, "WdfDriverCreate failed %!STATUS!", status);
        WPP_CLEANUP(DriverObject);
        return status;
    }

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");

    return status;
}

NTSTATUS
KMDFDriverEvtDeviceAdd(
    _In_    WDFDRIVER       Driver,
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++
Routine Description:

    EvtDeviceAdd is called by the framework in response to AddDevice
    call from the PnP manager. We create and initialize a device object to
    represent a new instance of the device.

Arguments:

    Driver - Handle to a framework driver object created in DriverEntry

    DeviceInit - Pointer to a framework-allocated WDFDEVICE_INIT structure.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;

    UNREFERENCED_PARAMETER(Driver);

    PAGED_CODE();

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

    status = KMDFDriverCreateDevice(DeviceInit);

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");

    return status;
}

VOID
KMDFDriverEvtDriverContextCleanup(
    _In_ WDFOBJECT DriverObject
    )
/*++
Routine Description:

    Free all the resources allocated in DriverEntry.

Arguments:

    DriverObject - handle to a WDF Driver object.

Return Value:

    VOID.

--*/
{
    UNREFERENCED_PARAMETER(DriverObject);

    PAGED_CODE();

    TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

    //
    // Stop WPP Tracing
    //
    WPP_CLEANUP(WdfDriverWdmGetDriverObject((WDFDRIVER)DriverObject));
}

```

`KMDFDriver/Driver.h`:

```h
/*++

Module Name:

    driver.h

Abstract:

    This file contains the driver definitions.

Environment:

    Kernel-mode Driver Framework

--*/

#include <ntddk.h>
#include <wdf.h>
#include <initguid.h>

#include "device.h"
#include "queue.h"
#include "trace.h"

EXTERN_C_START

//
// WDFDRIVER Events
//

DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_DEVICE_ADD KMDFDriverEvtDeviceAdd;
EVT_WDF_OBJECT_CONTEXT_CLEANUP KMDFDriverEvtDriverContextCleanup;

EXTERN_C_END

```

`KMDFDriver/KMDFDriver.inf`:

```inf
;
; KMDFDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=KMDFDriver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
KMDFDriver_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
KMDFDriver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%KMDFDriver.DeviceDesc%=KMDFDriver_Device, Root\KMDFDriver ; TODO: edit hw-id

[KMDFDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
KMDFDriver.sys

;-------------- Service installation
[KMDFDriver_Device.NT.Services]
AddService = KMDFDriver,%SPSVCINST_ASSOCSERVICE%, KMDFDriver_Service_Inst

; -------------- KMDFDriver driver install sections
[KMDFDriver_Service_Inst]
DisplayName    = %KMDFDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\KMDFDriver.sys

;
;--- KMDFDriver_Device Coinstaller installation ------
;

[KMDFDriver_Device.NT.CoInstallers]
AddReg=KMDFDriver_Device_CoInstaller_AddReg
CopyFiles=KMDFDriver_Device_CoInstaller_CopyFiles

[KMDFDriver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[KMDFDriver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[KMDFDriver_Device.NT.Wdf]
KmdfService =  KMDFDriver, KMDFDriver_wdfsect
[KMDFDriver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "KMDFDriver Installation Disk"
KMDFDriver.DeviceDesc = "KMDFDriver Device"
KMDFDriver.SVCDESC = "KMDFDriver Service"

```

`KMDFDriver/KMDFDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Device.c" />
    <ClCompile Include="Driver.c" />
    <ClCompile Include="Queue.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Device.h" />
    <ClInclude Include="Driver.h" />
    <ClInclude Include="Public.h" />
    <ClInclude Include="Queue.h" />
    <ClInclude Include="Trace.h" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="KMDFDriver.inf" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FB81B3DA-2F00-4442-8E38-AEB04BC8DF5A}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>KMDFDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
    <TimeStampServer />
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <PostBuildEvent />
    <PostBuildEvent />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KMDFDriver/KMDFDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Device.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Public.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Queue.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Trace.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Device.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Queue.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="KMDFDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
</Project>
```

`KMDFDriver/Public.h`:

```h
/*++

Module Name:

    public.h

Abstract:

    This module contains the common declarations shared by driver
    and user applications.

Environment:

    user and kernel

--*/

//
// Define an Interface Guid so that apps can find the device and talk to it.
//

DEFINE_GUID (GUID_DEVINTERFACE_KMDFDriver,
    0x50735e1c,0xb0e3,0x44cb,0xb4,0x78,0x90,0xa2,0x4d,0x6c,0x94,0x06);
// {50735e1c-b0e3-44cb-b478-90a24d6c9406}

```

`KMDFDriver/Queue.c`:

```c
/*++

Module Name:

    queue.c

Abstract:

    This file contains the queue entry points and callbacks.

Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "queue.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, KMDFDriverQueueInitialize)
#endif

NTSTATUS
KMDFDriverQueueInitialize(
    _In_ WDFDEVICE Device
    )
/*++

Routine Description:

     The I/O dispatch callbacks for the frameworks device object
     are configured in this function.

     A single default I/O Queue is configured for parallel request
     processing, and a driver context memory allocation is created
     to hold our structure QUEUE_CONTEXT.

Arguments:

    Device - Handle to a framework device object.

Return Value:

    VOID

--*/
{
    WDFQUEUE queue;
    NTSTATUS status;
    WDF_IO_QUEUE_CONFIG queueConfig;

    PAGED_CODE();

    //
    // Configure a default queue so that requests that are not
    // configure-fowarded using WdfDeviceConfigureRequestDispatching to goto
    // other queues get dispatched here.
    //
    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(
         &queueConfig,
        WdfIoQueueDispatchParallel
        );

    queueConfig.EvtIoDeviceControl = KMDFDriverEvtIoDeviceControl;
    queueConfig.EvtIoStop = KMDFDriverEvtIoStop;

    status = WdfIoQueueCreate(
                 Device,
                 &queueConfig,
                 WDF_NO_OBJECT_ATTRIBUTES,
                 &queue
                 );

    if(!NT_SUCCESS(status)) {
        TraceEvents(TRACE_LEVEL_ERROR, TRACE_QUEUE, "WdfIoQueueCreate failed %!STATUS!", status);
        return status;
    }

    return status;
}

VOID
KMDFDriverEvtIoDeviceControl(
    _In_ WDFQUEUE Queue,
    _In_ WDFREQUEST Request,
    _In_ size_t OutputBufferLength,
    _In_ size_t InputBufferLength,
    _In_ ULONG IoControlCode
    )
/*++

Routine Description:

    This event is invoked when the framework receives IRP_MJ_DEVICE_CONTROL request.

Arguments:

    Queue -  Handle to the framework queue object that is associated with the
             I/O request.

    Request - Handle to a framework request object.

    OutputBufferLength - Size of the output buffer in bytes

    InputBufferLength - Size of the input buffer in bytes

    IoControlCode - I/O control code.

Return Value:

    VOID

--*/
{
    TraceEvents(TRACE_LEVEL_INFORMATION, 
                TRACE_QUEUE, 
                "%!FUNC! Queue 0x%p, Request 0x%p OutputBufferLength %d InputBufferLength %d IoControlCode %d", 
                Queue, Request, (int) OutputBufferLength, (int) InputBufferLength, IoControlCode);

    WdfRequestComplete(Request, STATUS_SUCCESS);

    return;
}

VOID
KMDFDriverEvtIoStop(
    _In_ WDFQUEUE Queue,
    _In_ WDFREQUEST Request,
    _In_ ULONG ActionFlags
)
/*++

Routine Description:

    This event is invoked for a power-managed queue before the device leaves the working state (D0).

Arguments:

    Queue -  Handle to the framework queue object that is associated with the
             I/O request.

    Request - Handle to a framework request object.

    ActionFlags - A bitwise OR of one or more WDF_REQUEST_STOP_ACTION_FLAGS-typed flags
                  that identify the reason that the callback function is being called
                  and whether the request is cancelable.

Return Value:

    VOID

--*/
{
    TraceEvents(TRACE_LEVEL_INFORMATION, 
                TRACE_QUEUE, 
                "%!FUNC! Queue 0x%p, Request 0x%p ActionFlags %d", 
                Queue, Request, ActionFlags);

    //
    // In most cases, the EvtIoStop callback function completes, cancels, or postpones
    // further processing of the I/O request.
    //
    // Typically, the driver uses the following rules:
    //
    // - If the driver owns the I/O request, it calls WdfRequestUnmarkCancelable
    //   (if the request is cancelable) and either calls WdfRequestStopAcknowledge
    //   with a Requeue value of TRUE, or it calls WdfRequestComplete with a
    //   completion status value of STATUS_SUCCESS or STATUS_CANCELLED.
    //
    //   Before it can call these methods safely, the driver must make sure that
    //   its implementation of EvtIoStop has exclusive access to the request.
    //
    //   In order to do that, the driver must synchronize access to the request
    //   to prevent other threads from manipulating the request concurrently.
    //   The synchronization method you choose will depend on your driver's design.
    //
    //   For example, if the request is held in a shared context, the EvtIoStop callback
    //   might acquire an internal driver lock, take the request from the shared context,
    //   and then release the lock. At this point, the EvtIoStop callback owns the request
    //   and can safely complete or requeue the request.
    //
    // - If the driver has forwarded the I/O request to an I/O target, it either calls
    //   WdfRequestCancelSentRequest to attempt to cancel the request, or it postpones
    //   further processing of the request and calls WdfRequestStopAcknowledge with
    //   a Requeue value of FALSE.
    //
    // A driver might choose to take no action in EvtIoStop for requests that are
    // guaranteed to complete in a small amount of time.
    //
    // In this case, the framework waits until the specified request is complete
    // before moving the device (or system) to a lower power state or removing the device.
    // Potentially, this inaction can prevent a system from entering its hibernation state
    // or another low system power state. In extreme cases, it can cause the system
    // to crash with bugcheck code 9F.
    //

    return;
}

```

`KMDFDriver/Queue.h`:

```h
/*++

Module Name:

    queue.h

Abstract:

    This file contains the queue definitions.

Environment:

    Kernel-mode Driver Framework

--*/

EXTERN_C_START

//
// This is the context that can be placed per queue
// and would contain per queue information.
//
typedef struct _QUEUE_CONTEXT {

    ULONG PrivateDeviceData;  // just a placeholder

} QUEUE_CONTEXT, *PQUEUE_CONTEXT;

WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(QUEUE_CONTEXT, QueueGetContext)

NTSTATUS
KMDFDriverQueueInitialize(
    _In_ WDFDEVICE Device
    );

//
// Events from the IoQueue object
//
EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL KMDFDriverEvtIoDeviceControl;
EVT_WDF_IO_QUEUE_IO_STOP KMDFDriverEvtIoStop;

EXTERN_C_END

```

`KMDFDriver/Trace.h`:

```h
/*++

Module Name:

    Trace.h

Abstract:

    Header file for the debug tracing related function defintions and macros.

Environment:

    Kernel mode

--*/

//
// Define the tracing flags.
//
// Tracing GUID - 71664625-de2c-4c3f-a49e-955caf4beec3
//

#define WPP_CONTROL_GUIDS                                              \
    WPP_DEFINE_CONTROL_GUID(                                           \
        KMDFDriverTraceGuid, (71664625,de2c,4c3f,a49e,955caf4beec3), \
                                                                            \
        WPP_DEFINE_BIT(MYDRIVER_ALL_INFO)                              \
        WPP_DEFINE_BIT(TRACE_DRIVER)                                   \
        WPP_DEFINE_BIT(TRACE_DEVICE)                                   \
        WPP_DEFINE_BIT(TRACE_QUEUE)                                    \
        )                             

#define WPP_FLAG_LEVEL_LOGGER(flag, level)                                  \
    WPP_LEVEL_LOGGER(flag)

#define WPP_FLAG_LEVEL_ENABLED(flag, level)                                 \
    (WPP_LEVEL_ENABLED(flag) &&                                             \
     WPP_CONTROL(WPP_BIT_ ## flag).Level >= level)

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) \
           WPP_LEVEL_LOGGER(flags)
               
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) \
           (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)

//           
// WPP orders static parameters before dynamic parameters. To support the Trace function
// defined below which sets FLAGS=MYDRIVER_ALL_INFO, a custom macro must be defined to
// reorder the arguments to what the .tpl configuration file expects.
//
#define WPP_RECORDER_FLAGS_LEVEL_ARGS(flags, lvl) WPP_RECORDER_LEVEL_FLAGS_ARGS(lvl, flags)
#define WPP_RECORDER_FLAGS_LEVEL_FILTER(flags, lvl) WPP_RECORDER_LEVEL_FLAGS_FILTER(lvl, flags)

//
// This comment block is scanned by the trace preprocessor to define our
// Trace function.
//
// begin_wpp config
// FUNC Trace{FLAGS=MYDRIVER_ALL_INFO}(LEVEL, MSG, ...);
// FUNC TraceEvents(LEVEL, FLAGS, MSG, ...);
// end_wpp
//

```

`README.md`:

```md
## Leveraging PTT to defeat DSE and run Kernel Drivers with Secure Boot Enabled

... With a Test Signing Certificate and No Extended Validation.

Code Signing is an amazing thing, But it has a glaring flaw depending on your motherboard which allows you to run Test Signed Kernel Drivers in a full trust environment with no indication to the OS that something may be wrong.

_Before you start you need to install the [Windows Driver Kit](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk)_

### 1. [Creating the Certificates](https://github.com/HypsyNZ/DSEDodge-Signed-Kernel-Driver/tree/main/CERT#readme)

To begin, we need to create our own `CA` and `SPC` and a `PFX` we can use as a `Production Certificate` later.

_You should rename these_

```ps
makecert -r -pe -n "CN=Demo_CA_Root" -ss CA -sr CurrentUser ^
   -a sha256 -cy authority -sky signature ^
   -sv Demo_CA_Root.pvk Demo_CA_Root.cer ^
   -e 02/22/2023

makecert -pe -n "CN=Demo_SPC_Code_Signing" -a sha256 -cy end ^
   -sky signature ^
   -ic Demo_CA_Root.cer -iv Demo_CA_Root.pvk ^
   -sv Demo_SPC_Code_Signing.pvk Demo_SPC_Code_Signing.cer ^
   -eku 1.3.6.1.5.5.7.3.3 ^
   -e 02/22/2023

pvk2pfx -pvk Demo_SPC_Code_Signing.pvk -spc Demo_SPC_Code_Signing.cer ^
   -pfx Demo_SPC_PFX.pfx ^
   -po x
```

### 3. USB Drive

Put the `Demo_SPC_Code_Signing.cer` and `Demo_CA_Root.cer` Certificate onto a USB stick, we are going to import the Certificates into the `BIOS` so the Kernel will trust our `Signature` and install/run our driver as if Microsoft had signed it themselves.

### 4. Restart PC and Enter the Bios

_(These steps may vary slightly depending on your BIOS but the concept is the same)_

Select the `Secure Boot Menu` in your Bios

In the `Key Management` section select `Authorized Signatures` (Or wherever the `Microsoft Production PCA Certificate` is located)

Select `Append/Add` from the Menu that pops up

Locate `Demo_SPC_Code_Signing.cer` and `Demo_CA_Root.cer` on your `USB`, pressing enter twice when selecting them.

The second time you press enter you'll be prompted to confirm you want to update the Certificate Store, Select `Yes`.

### 5. Success, We are now an "Extended Validator" on this PC.

The certificates you just added to the `BIOS` can now be used for "Extended Validation" of Kernel Drivers without using any exploits, essentially bypassing Driver Signing Enforcement (DSE) because there is no third party involved and you just sign it yourself without the extra steps.

![](https://i.imgur.com/ydRADjq.jpg)

### 6. Trust the CA Certificate

Restart the computer and open the `Demo_CA_Root.cer` certificate

![](https://i.imgur.com/xtpSmeb.png)

Install the certificate to the `Trusted Root` of the `Local Machine`

![](https://i.imgur.com/VMEsUtF.png)

Now drivers signed by `Demo_SPC_PFX.pfx` will be trusted.

### 7. BUILDING THE DRIVER

Now you can Production Sign your driver instead of Test Signing

`Demo_SPC_Code_Signing.cer` is the `Cross-Signing Certificate`

`Demo_SPC_PFX.pfx` is the `Production Certificate`

![](https://i.imgur.com/CSzLRM7.png)

### 7. CREATE AND SIGN THE SECURITY CATALOG / TIMESTAMP DRIVER

DSE will stop us from installing the Kernel Driver if the catalog isn't signed correctly, manually run these commands.

```cmd
inf2cat /os:10_x64 /driver:.\x64\Release /uselocaltime

SignTool sign /fd sha256 /td SHA256 /tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /f .\CERT\Demo_SPC_PFX.pfx /p x /v .\x64\Release\KMDFDriver\kmdfdriver.cat

SignTool sign /fd sha256 /td SHA256 /tr "http://sha256timestamp.ws.symantec.com/sha256/timestamp" /f .\CERT\Demo_SPC_PFX.pfx /p x /v .\x64\Release\KMDFDriver\KMDFDriver.sys

```

### 8. Install your Driver

Now you can install and run your driver without configuring [BCEDIT](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option)

![](https://i.imgur.com/g26mIU7.png)

### 9. Run your Driver

With your `CA Root Certificate` in `Authorized Signatures` in the `BIOS` the Kernel won't stop your Driver from running and you can make `Production Certificates` whenever you want for use on your own PC.

------

Tested on a motherboard with the `Z490 Chipset`

OS: [`Windows 10 Professional - Full Strip & Lockdown Edition - 21H2`](https://github.com/HypsyNZ/ISOKIT/tree/master/21H2)

This may not work on earlier chipsets, It may be removed in later ones.

Whether this works or not totally depends on your Motherboard/CPU combination.

#### Have Fun and remember, Gödel's theorem suggests certain information can travel faster than the speed of light.

```